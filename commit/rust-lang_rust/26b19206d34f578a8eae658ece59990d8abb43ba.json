{"sha": "26b19206d34f578a8eae658ece59990d8abb43ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YjE5MjA2ZDM0ZjU3OGE4ZWFlNjU4ZWNlNTk5OTBkOGFiYjQzYmE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-22T19:02:04Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-26T16:21:17Z"}, "message": "make check works", "tree": {"sha": "699152913e6fbda1d26a24c5a25a8c9a90af438b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/699152913e6fbda1d26a24c5a25a8c9a90af438b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26b19206d34f578a8eae658ece59990d8abb43ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26b19206d34f578a8eae658ece59990d8abb43ba", "html_url": "https://github.com/rust-lang/rust/commit/26b19206d34f578a8eae658ece59990d8abb43ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26b19206d34f578a8eae658ece59990d8abb43ba/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d45dd9423e0fa11510f3e62dd0f286bf6c0cdf37", "url": "https://api.github.com/repos/rust-lang/rust/commits/d45dd9423e0fa11510f3e62dd0f286bf6c0cdf37", "html_url": "https://github.com/rust-lang/rust/commit/d45dd9423e0fa11510f3e62dd0f286bf6c0cdf37"}], "stats": {"total": 209, "additions": 130, "deletions": 79}, "files": [{"sha": "f00dd3b852c6d72389012fbf2400d8278bbd6f2d", "filename": "src/librustc/metadata/util.rs", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustc%2Fmetadata%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustc%2Fmetadata%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Futil.rs?ref=26b19206d34f578a8eae658ece59990d8abb43ba", "patch": "@@ -19,7 +19,7 @@ use middle::def;\n use middle::lang_items;\n use middle::ty::{self, Ty};\n use middle::def_id::{DefId, DefIndex};\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::any::Any;\n use std::cell::RefCell;\n@@ -75,6 +75,7 @@ pub trait CrateStore<'tcx> : Any {\n     fn item_symbol(&self, def: DefId) -> String;\n     fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn method_arg_names(&self, did: DefId) -> Vec<String>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n@@ -104,10 +105,12 @@ pub trait CrateStore<'tcx> : Any {\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_impl(&self, did: DefId) -> bool;\n-    fn is_static_method(&self, did: DefId) -> bool;\n+    fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_extern_fn(&self, tcx: &ty::ctxt<'tcx>, did: DefId) -> bool;\n     fn is_static(&self, did: DefId) -> bool;\n+    fn is_static_method(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n+    fn is_typedef(&self, did: DefId) -> bool;\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n@@ -117,8 +120,11 @@ pub trait CrateStore<'tcx> : Any {\n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n     fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n     fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n+    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n     fn crate_name(&self, cnum: ast::CrateNum) -> String;\n     fn crate_hash(&self, cnum: ast::CrateNum) -> Svh;\n+    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n+                                -> FnvHashMap<DefId, Vec<ast::Attribute>>;\n     fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>;\n     fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n@@ -232,6 +238,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_adt_def(&self.intr, &*cdata, def.index, tcx)\n     }\n \n+    fn method_arg_names(&self, did: DefId) -> Vec<String>\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::get_method_arg_names(&cdata, did.index)\n+    }\n+\n     fn item_path(&self, def: DefId) -> Vec<ast_map::PathElem> {\n         let cdata = self.get_crate_data(def.krate);\n         let path = decoder::get_item_path(&*cdata, def.index);\n@@ -352,10 +364,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_impl(&*cdata, did.index)\n     }\n \n-    fn is_static_method(&self, def: DefId) -> bool\n-    {\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::is_static_method(&*cdata, def.index)\n+    fn is_default_impl(&self, impl_did: DefId) -> bool {\n+        let cdata = self.get_crate_data(impl_did.krate);\n+        decoder::is_default_impl(&*cdata, impl_did.index)\n     }\n \n     fn is_extern_fn(&self, tcx: &ty::ctxt<'tcx>, did: DefId) -> bool\n@@ -370,11 +381,22 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_static(&*cdata, did.index)\n     }\n \n+    fn is_static_method(&self, def: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::is_static_method(&*cdata, def.index)\n+    }\n+\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool\n     {\n         self.do_is_statically_included_foreign_item(id)\n     }\n \n+    fn is_typedef(&self, did: DefId) -> bool {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_typedef(&*cdata, did.index)\n+    }\n+\n     fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n                                 -> Vec<(ast::CrateNum, LinkagePreference)>\n     {\n@@ -414,6 +436,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).is_allocator()\n     }\n \n+    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n+    {\n+        decoder::get_crate_attributes(self.get_crate_data(cnum).data())\n+    }\n+\n     fn crate_name(&self, cnum: ast::CrateNum) -> String\n     {\n         self.get_crate_data(cnum).name.clone()\n@@ -425,6 +452,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_crate_hash(cdata.data())\n     }\n \n+    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n+                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n+    {\n+        decoder::get_struct_field_attrs(&*self.get_crate_data(cnum))\n+    }\n+\n     fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(cnum);"}, {"sha": "8ddce8a77d06ba35d8379767ceb80c2ebdeaa230", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=26b19206d34f578a8eae658ece59990d8abb43ba", "patch": "@@ -16,8 +16,7 @@ use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use rustc_front::hir;\n \n-use rustc::metadata::csearch;\n-use rustc::metadata::decoder;\n+use rustc::metadata::util::{self as mdutil, CrateStore};\n use rustc::middle::def;\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty;\n@@ -129,8 +128,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n \n pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n                   did: DefId) -> Vec<clean::Attribute> {\n-    let attrs = csearch::get_item_attrs(&tcx.sess.cstore, did);\n-    attrs.into_iter().map(|a| a.clean(cx)).collect()\n+    tcx.get_attrs(did).iter().map(|a| a.clean(cx)).collect()\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n@@ -140,7 +138,7 @@ pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     match cx.tcx_opt() {\n         Some(tcx) => {\n-            let fqn = csearch::get_item_path(tcx, did);\n+            let fqn = tcx.sess.cstore.item_path(did);\n             let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n             cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n         }\n@@ -211,7 +209,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: DefId) -> clean::ItemEnum {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n-        ty::TyEnum(edef, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n+        ty::TyEnum(edef, _) if !tcx.sess.cstore.is_typedef(did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n@@ -250,23 +248,19 @@ pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n     // type being inlined, but impls can also be used when generating\n     // documentation for primitives (no way to find those specifically).\n     if cx.populated_crate_impls.borrow_mut().insert(did.krate) {\n-        csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n-                                              did.krate,\n-                                              |def, _, _| {\n-            populate_impls(cx, tcx, def, &mut impls)\n-        });\n+        for item in tcx.sess.cstore.crate_top_level_items(did.krate) {\n+            populate_impls(cx, tcx, item.def, &mut impls);\n+        }\n \n         fn populate_impls(cx: &DocContext, tcx: &ty::ctxt,\n-                          def: decoder::DefLike,\n+                          def: mdutil::DefLike,\n                           impls: &mut Vec<clean::Item>) {\n             match def {\n-                decoder::DlImpl(did) => build_impl(cx, tcx, did, impls),\n-                decoder::DlDef(def::DefMod(did)) => {\n-                    csearch::each_child_of_item(&tcx.sess.cstore,\n-                                                did,\n-                                                |def, _, _| {\n-                        populate_impls(cx, tcx, def, impls)\n-                    })\n+                mdutil::DlImpl(did) => build_impl(cx, tcx, did, impls),\n+                mdutil::DlDef(def::DefMod(did)) => {\n+                    for item in tcx.sess.cstore.item_children(did) {\n+                        populate_impls(cx, tcx, item.def, impls)\n+                    }\n                 }\n                 _ => {}\n             }\n@@ -285,7 +279,7 @@ pub fn build_impl(cx: &DocContext,\n     }\n \n     let attrs = load_attrs(cx, tcx, did);\n-    let associated_trait = csearch::get_impl_trait(tcx, did);\n+    let associated_trait = tcx.impl_trait_ref(did);\n     if let Some(ref t) = associated_trait {\n         // If this is an impl for a #[doc(hidden)] trait, be sure to not inline\n         let trait_attrs = load_attrs(cx, tcx, t.def_id);\n@@ -295,7 +289,7 @@ pub fn build_impl(cx: &DocContext,\n     }\n \n     // If this is a defaulted impl, then bail out early here\n-    if csearch::is_default_impl(&tcx.sess.cstore, did) {\n+    if tcx.sess.cstore.is_default_impl(did) {\n         return ret.push(clean::Item {\n             inner: clean::DefaultImplItem(clean::DefaultImpl {\n                 // FIXME: this should be decoded\n@@ -315,7 +309,7 @@ pub fn build_impl(cx: &DocContext,\n     }\n \n     let predicates = tcx.lookup_predicates(did);\n-    let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n+    let trait_items = tcx.sess.cstore.impl_items(did)\n             .iter()\n             .filter_map(|did| {\n         let did = did.def_id();\n@@ -393,7 +387,7 @@ pub fn build_impl(cx: &DocContext,\n             }\n         }\n     }).collect::<Vec<_>>();\n-    let polarity = csearch::get_impl_polarity(tcx, did);\n+    let polarity = tcx.trait_impl_polarity(did);\n     let ty = tcx.lookup_item_type(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| {\n         match bound {\n@@ -454,24 +448,24 @@ fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n         let mut visited = HashSet::new();\n-        csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, vis| {\n-            match def {\n-                decoder::DlDef(def::DefForeignMod(did)) => {\n+        for item in tcx.sess.cstore.item_children(did) {\n+            match item.def {\n+                mdutil::DlDef(def::DefForeignMod(did)) => {\n                     fill_in(cx, tcx, did, items);\n                 }\n-                decoder::DlDef(def) if vis == hir::Public => {\n+                mdutil::DlDef(def) if item.vis == hir::Public => {\n                     if !visited.insert(def) { return }\n                     match try_inline_def(cx, tcx, def) {\n                         Some(i) => items.extend(i),\n                         None => {}\n                     }\n                 }\n-                decoder::DlDef(..) => {}\n+                mdutil::DlDef(..) => {}\n                 // All impls were inlined above\n-                decoder::DlImpl(..) => {}\n-                decoder::DlField => panic!(\"unimplemented field\"),\n+                mdutil::DlImpl(..) => {}\n+                mdutil::DlField => panic!(\"unimplemented field\"),\n             }\n-        });\n+        }\n     }\n }\n "}, {"sha": "831d861306850ade7b63cc1c3282bfe4b424ec0b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=26b19206d34f578a8eae658ece59990d8abb43ba", "patch": "@@ -35,9 +35,7 @@ use syntax::parse::token::{self, InternedString, special_idents};\n use syntax::ptr::P;\n \n use rustc_trans::back::link;\n-use rustc::metadata::cstore;\n-use rustc::metadata::csearch;\n-use rustc::metadata::decoder;\n+use rustc::metadata::util::{self as mdutil, CrateStore};\n use rustc::middle::def;\n use rustc::middle::def_id::{DefId, DefIndex};\n use rustc::middle::subst::{self, ParamSpace, VecPerParamSpace};\n@@ -126,6 +124,8 @@ pub struct Crate {\n     pub external_traits: HashMap<DefId, Trait>,\n }\n \n+struct CrateNum(ast::CrateNum);\n+\n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n         use rustc::session::config::Input;\n@@ -135,9 +135,9 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n         }\n \n         let mut externs = Vec::new();\n-        cx.sess().cstore.iter_crate_data(|n, meta| {\n-            externs.push((n, meta.clean(cx)));\n-        });\n+        for cnum in cx.sess().cstore.crates() {\n+            externs.push((cnum, CrateNum(cnum).clean(cx)));\n+        }\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n         // Figure out the name of this crate\n@@ -219,24 +219,22 @@ pub struct ExternalCrate {\n     pub primitives: Vec<PrimitiveType>,\n }\n \n-impl Clean<ExternalCrate> for cstore::crate_metadata {\n+impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n         cx.tcx_opt().map(|tcx| {\n-            csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n-                                                  self.cnum,\n-                                                  |def, _, _| {\n-                let did = match def {\n-                    decoder::DlDef(def::DefMod(did)) => did,\n-                    _ => return\n+            for item in tcx.sess.cstore.crate_top_level_items(self.0) {\n+                let did = match item.def {\n+                    mdutil::DlDef(def::DefMod(did)) => did,\n+                    _ => continue\n                 };\n                 let attrs = inline::load_attrs(cx, tcx, did);\n                 PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n-            })\n+            }\n         });\n         ExternalCrate {\n-            name: self.name.to_string(),\n-            attrs: decoder::get_crate_attributes(self.data()).clean(cx),\n+            name: cx.sess().cstore.crate_name(self.0),\n+            attrs: cx.sess().cstore.crate_attrs(self.0).clean(cx),\n             primitives: primitives,\n         }\n     }\n@@ -656,7 +654,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n                 (tcx.lang_items.sync_trait().unwrap(),\n                  external_path(cx, \"Sync\", None, vec![], &empty)),\n         };\n-        let fqn = csearch::get_item_path(tcx, did);\n+        let fqn = tcx.sess.cstore.item_path(did);\n         let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(did,\n                                                                 (fqn, TypeTrait));\n@@ -678,7 +676,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n             Some(tcx) => tcx,\n             None => return RegionBound(Lifetime::statik())\n         };\n-        let fqn = csearch::get_item_path(tcx, self.def_id);\n+        let fqn = tcx.sess.cstore.item_path(self.def_id);\n         let fqn = fqn.into_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n         let path = external_path(cx, fqn.last().unwrap(),\n@@ -1140,7 +1138,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n         let mut names = if let Some(_) = cx.map.as_local_node_id(did) {\n             vec![].into_iter()\n         } else {\n-            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).into_iter()\n+            cx.tcx().sess.cstore.method_arg_names(did).into_iter()\n         }.peekable();\n         if names.peek().map(|s| &**s) == Some(\"self\") {\n             let _ = names.next();\n@@ -1665,7 +1663,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyStruct(def, substs) |\n             ty::TyEnum(def, substs) => {\n                 let did = def.did;\n-                let fqn = csearch::get_item_path(cx.tcx(), did);\n+                let fqn = cx.tcx().sess.cstore.item_path(did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let kind = match self.sty {\n                     ty::TyStruct(..) => TypeStruct,\n@@ -1683,7 +1681,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             }\n             ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n                 let did = principal.def_id();\n-                let fqn = csearch::get_item_path(cx.tcx(), did);\n+                let fqn = cx.tcx().sess.cstore.item_path(did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let (typarams, bindings) = bounds.clean(cx);\n                 let path = external_path(cx, &fqn.last().unwrap().to_string(),\n@@ -1737,9 +1735,9 @@ impl Clean<Item> for hir::StructField {\n impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         use syntax::parse::token::special_idents::unnamed_field;\n-        use rustc::metadata::csearch;\n-\n-        let attr_map = csearch::get_struct_field_attrs(&cx.tcx().sess.cstore, self.did);\n+        // FIXME: possible O(n^2)-ness! Not my fault.\n+        let attr_map =\n+            cx.tcx().sess.cstore.crate_struct_field_attrs(self.did.krate);\n \n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n@@ -2815,7 +2813,7 @@ fn lang_struct(cx: &DocContext, did: Option<DefId>,\n         Some(did) => did,\n         None => return fallback(box t.clean(cx)),\n     };\n-    let fqn = csearch::get_item_path(cx.tcx(), did);\n+    let fqn = cx.tcx().sess.cstore.item_path(did);\n     let fqn: Vec<String> = fqn.into_iter().map(|i| {\n         i.to_string()\n     }).collect();"}, {"sha": "8b97ff2f75bcb55951f92f88ab89a581ad6bf05f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=26b19206d34f578a8eae658ece59990d8abb43ba", "patch": "@@ -12,6 +12,7 @@ pub use self::MaybeTyped::*;\n use rustc_lint;\n use rustc_driver::{driver, target_features};\n use rustc::session::{self, config};\n+use rustc::metadata::cstore::CStore;\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::ty;\n@@ -23,9 +24,11 @@ use rustc_front::lowering::{lower_crate, LoweringContext};\n \n use syntax::{ast, codemap, diagnostic};\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::parse::token;\n \n use std::cell::{RefCell, Cell};\n use std::collections::{HashMap, HashSet};\n+use std::rc::Rc;\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -118,8 +121,10 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let span_diagnostic_handler =\n         diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts, cpath,\n-                                       span_diagnostic_handler);\n+                                       span_diagnostic_handler, cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);\n@@ -130,7 +135,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let name = link::find_crate_name(Some(&sess), &krate.attrs,\n                                      &input);\n \n-    let krate = driver::phase_2_configure_and_expand(&sess, krate, &name, None)\n+    let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, &name, None)\n                     .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let krate = driver::assign_node_ids(&sess, krate);\n@@ -141,6 +146,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let hir_map = driver::make_map(&sess, &mut hir_forest);\n \n     driver::phase_3_run_analysis_passes(&sess,\n+                                        &cstore,\n                                         hir_map,\n                                         &arenas,\n                                         &name,"}, {"sha": "9eb5e0dfb73eac96d4ef354280c922a17dcbbe79", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=26b19206d34f578a8eae658ece59990d8abb43ba", "patch": "@@ -19,12 +19,14 @@ use std::io::prelude::*;\n use std::io;\n use std::path::PathBuf;\n use std::process::Command;\n+use std::rc::Rc;\n use std::str;\n use std::sync::{Arc, Mutex};\n \n use testing;\n use rustc_lint;\n use rustc::front::map as hir_map;\n+use rustc::metadata::cstore::CStore;\n use rustc::session::{self, config};\n use rustc::session::config::{get_unstable_features_setting, OutputType};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n@@ -33,6 +35,7 @@ use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n use syntax::codemap::CodeMap;\n use syntax::diagnostic;\n+use syntax::parse::token;\n \n use core;\n use clean;\n@@ -73,15 +76,18 @@ pub fn run(input: &str,\n     let span_diagnostic_handler =\n     diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n-                                      Some(input_path.clone()),\n-                                      span_diagnostic_handler);\n+                                       Some(input_path.clone()),\n+                                       span_diagnostic_handler,\n+                                       cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(config::parse_cfgspecs(cfgs));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n-    let krate = driver::phase_2_configure_and_expand(&sess, krate,\n+    let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate,\n                                                      \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n     let krate = driver::assign_node_ids(&sess, krate);\n@@ -223,9 +229,12 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let span_diagnostic_handler =\n         diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n                                        None,\n-                                       span_diagnostic_handler);\n+                                       span_diagnostic_handler,\n+                                       cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\");\n@@ -236,7 +245,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     if no_run {\n         control.after_analysis.stop = Compilation::Stop;\n     }\n-    driver::compile_input(sess, cfg, &input, &out, &None, None, control);\n+    driver::compile_input(sess, &cstore, cfg, &input, &out, &None, None, control);\n \n     if no_run { return }\n "}, {"sha": "b8d3a8b1f1fa668128ff92f470db941077478bee", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=26b19206d34f578a8eae658ece59990d8abb43ba", "patch": "@@ -22,11 +22,12 @@ extern crate syntax;\n use std::ffi::{CStr, CString};\n use std::mem::transmute;\n use std::path::PathBuf;\n+use std::rc::Rc;\n use std::thread::Builder;\n \n use rustc::front::map as ast_map;\n use rustc::llvm;\n-use rustc::metadata::cstore::RequireDynamic;\n+use rustc::metadata::cstore::{CStore, RequireDynamic};\n use rustc::metadata::util::CrateStore;\n use rustc::middle::ty;\n use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n@@ -37,6 +38,7 @@ use rustc_resolve::MakeGlobMap;\n use libc::c_void;\n \n use syntax::diagnostics::registry::Registry;\n+use syntax::parse::token;\n \n fn main() {\n     let program = r#\"\n@@ -211,7 +213,10 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n     let handle = thread.spawn(move || {\n         let opts = build_exec_options(sysroot);\n-        let sess = build_session(opts, None, Registry::new(&rustc::DIAGNOSTICS));\n+        let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+        let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n+        let sess = build_session(opts, None, Registry::new(&rustc::DIAGNOSTICS),\n+                                 cstore_);\n         rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n         let cfg = build_configuration(&sess);\n@@ -220,7 +225,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n         let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n \n-        let krate = driver::phase_2_configure_and_expand(&sess, krate, &id, None)\n+        let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None)\n             .expect(\"phase_2 returned `None`\");\n \n         let krate = driver::assign_node_ids(&sess, krate);\n@@ -230,11 +235,12 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let ast_map = driver::make_map(&sess, &mut hir_forest);\n \n         driver::phase_3_run_analysis_passes(\n-            &sess, ast_map, &arenas, &id, MakeGlobMap::No, |tcx, mir_map, analysis| {\n+            &sess, &cstore, ast_map, &arenas, &id,\n+            MakeGlobMap::No, |tcx, mir_map, analysis| {\n \n             let trans = driver::phase_4_translate_to_llvm(tcx, mir_map, analysis);\n \n-            let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n+            let crates = tcx.sess.cstore.used_crates(RequireDynamic);\n \n             // Collect crates used in the session.\n             // Reverse order finds dependencies first."}, {"sha": "a46ccc49259e7d418402867d56276f9f06888e91", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b19206d34f578a8eae658ece59990d8abb43ba/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=26b19206d34f578a8eae658ece59990d8abb43ba", "patch": "@@ -15,12 +15,15 @@ extern crate rustc_driver;\n extern crate rustc_lint;\n extern crate syntax;\n \n+use rustc::metadata::cstore::CStore;\n use rustc::session::{build_session, Session};\n use rustc::session::config::{basic_options, build_configuration, Input, OutputType};\n use rustc_driver::driver::{compile_input, CompileController};\n use syntax::diagnostics::registry::Registry;\n+use syntax::parse::token;\n \n use std::path::PathBuf;\n+use std::rc::Rc;\n \n fn main() {\n     let src = r#\"\n@@ -44,23 +47,25 @@ fn main() {\n     compile(src.to_string(), tmpdir.join(\"out\"), sysroot.clone());\n }\n \n-fn basic_sess(sysroot: PathBuf) -> Session {\n+fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n     let mut opts = basic_options();\n     opts.output_types.insert(OutputType::Exe, None);\n     opts.maybe_sysroot = Some(sysroot);\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n-    let sess = build_session(opts, None, descriptions);\n+    let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n+    let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n+    let sess = build_session(opts, None, descriptions, cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    sess\n+    (sess, cstore)\n }\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n-    let sess = basic_sess(sysroot);\n+    let (sess, cstore) = basic_sess(sysroot);\n     let cfg = build_configuration(&sess);\n     let control = CompileController::basic();\n \n-    compile_input(sess,\n+    compile_input(sess, &cstore,\n             cfg,\n             &Input::Str(code),\n             &None,"}]}