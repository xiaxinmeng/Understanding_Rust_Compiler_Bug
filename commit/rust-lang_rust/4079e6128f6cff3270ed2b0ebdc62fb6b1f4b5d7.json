{"sha": "4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNzllNjEyOGY2Y2ZmMzI3MGVkMmIwZWJkYzYyZmI2YjFmNGI1ZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-28T01:12:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-28T01:12:12Z"}, "message": "Auto merge of #42417 - eddyb:separate-fn-sig, r=nikomatsakis\n\nDon't drag function signatures along function item types.\n\nThis PR separates the signature of a function from the \"function item type\" (`TyFnDef`), leaving only the `DefId` and parameter `Substs`, making them even more like (captureless) closure types.\n\nThe motivation for this change is reducing typesystem complexity, and its consequences:\n* operating on the signature instead of just the parameters was less efficient\n  * specifically, signatures can easily add several levels of depth on top of the parameter types\n  * and the signatured were always substituted and normalized, so typically even more complex\n* it was *the only* type that was *both* nominal (identity) and structural (signature)\n  * harder to model in Chalk than either a purely nominal or structural type\n  * subtyping worked on the signature but parameters were always invariant\n  * call type-checking was transforming signatures but keeping the nominal half intact\n  * the signature could therefore get out of sync during type inference in several ways\n\nThat last point comes with a `[breaking-change]`, because functions with `'static` in their return types will now *not* be as usable as if they were using lifetime parameters instead:\n```rust\n// Will cause lifetime mismatch in main after this PR.\nfn bar() -> &'static str { \"bar\" }\n// Will continue to work fine, as every use can choose its own lifetime.\nfn bar<'a>() -> &'a str { \"bar\" }\n\nfn main() {\n    let s = String::from(\"foo\");\n    Some(&s[..]).unwrap_or_else(bar);\n}\n```\n\nr? @nikomatsakis", "tree": {"sha": "6fd26e62bb4ec2af0808f61de8e67e12d2946ac1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fd26e62bb4ec2af0808f61de8e67e12d2946ac1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "html_url": "https://github.com/rust-lang/rust/commit/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f590a44ce61888c78b9044817d8b798db5cd2ffd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f590a44ce61888c78b9044817d8b798db5cd2ffd", "html_url": "https://github.com/rust-lang/rust/commit/f590a44ce61888c78b9044817d8b798db5cd2ffd"}, {"sha": "69076f3a786e0412510af925f38a2a7f78b8e6ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/69076f3a786e0412510af925f38a2a7f78b8e6ef", "html_url": "https://github.com/rust-lang/rust/commit/69076f3a786e0412510af925f38a2a7f78b8e6ef"}], "stats": {"total": 1656, "additions": 777, "deletions": 879}, "files": [{"sha": "4f365a97f4ceba1719af50f475bf9b06e1068263", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -524,10 +524,9 @@ for ty::TypeVariants<'tcx>\n                 region.hash_stable(hcx, hasher);\n                 pointee_ty.hash_stable(hcx, hasher);\n             }\n-            TyFnDef(def_id, substs, ref sig) => {\n+            TyFnDef(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n-                sig.hash_stable(hcx, hasher);\n             }\n             TyFnPtr(ref sig) => {\n                 sig.hash_stable(hcx, hasher);"}, {"sha": "d5020b12ee00e12c5e86295d92ad75a9a8219c03", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -1369,7 +1369,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Some(self.tcx.closure_kind(def_id))\n     }\n \n-    pub fn closure_type(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n+    /// Obtain the signature of a function or closure.\n+    /// For closures, unlike `tcx.fn_sig(def_id)`, this method will\n+    /// work during the type-checking of the enclosing function and\n+    /// return the closure signature in its partially inferred state.\n+    pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n         if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 if let Some(&ty) = tables.borrow().closure_tys.get(&id) {\n@@ -1378,7 +1382,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.tcx.closure_type(def_id)\n+        self.tcx.fn_sig(def_id)\n     }\n }\n "}, {"sha": "eab5a8f910331184187caac0a7dd822df61afd86", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -12,7 +12,7 @@\n //! `unsafe`.\n use self::RootUnsafeContext::*;\n \n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, TyCtxt};\n use lint;\n \n use syntax::ast;\n@@ -40,14 +40,6 @@ enum RootUnsafeContext {\n     UnsafeBlock(ast::NodeId),\n }\n \n-fn type_is_unsafe_function(ty: Ty) -> bool {\n-    match ty.sty {\n-        ty::TyFnDef(.., f) |\n-        ty::TyFnPtr(f) => f.unsafety() == hir::Unsafety::Unsafe,\n-        _ => false,\n-    }\n-}\n-\n struct EffectCheckVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -174,10 +166,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n-                let base_type = self.tcx.type_of(def_id);\n-                debug!(\"effect: method call case, base type is {:?}\",\n-                        base_type);\n-                if type_is_unsafe_function(base_type) {\n+                let sig = self.tcx.fn_sig(def_id);\n+                debug!(\"effect: method call case, signature is {:?}\",\n+                        sig);\n+\n+                if sig.0.unsafety == hir::Unsafety::Unsafe {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n                 }\n@@ -186,8 +179,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n                 let base_type = self.tables.expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n-                if type_is_unsafe_function(base_type) {\n-                    self.require_unsafe(expr.span, \"call to unsafe function\")\n+                match base_type.sty {\n+                    ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                        if base_type.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n+                            self.require_unsafe(expr.span, \"call to unsafe function\")\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {"}, {"sha": "fde207e4b2f79f75922a2fb36ef74ce9739ad07b", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -66,11 +66,8 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.tcx.type_of(def_id).sty {\n-            ty::TyFnDef(.., bfty) => bfty.abi() == RustIntrinsic,\n-            _ => return false\n-        };\n-        intrinsic && self.tcx.item_name(def_id) == \"transmute\"\n+        self.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n+        self.tcx.item_name(def_id) == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>) {\n@@ -153,22 +150,14 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n         } else {\n             Def::Err\n         };\n-        match def {\n-            Def::Fn(did) if self.def_id_is_transmute(did) => {\n+        if let Def::Fn(did) = def {\n+            if self.def_id_is_transmute(did) {\n                 let typ = self.tables.node_id_to_type(expr.id);\n-                let typ = self.tcx.lift_to_global(&typ).unwrap();\n-                match typ.sty {\n-                    ty::TyFnDef(.., sig) if sig.abi() == RustIntrinsic => {\n-                        let from = sig.inputs().skip_binder()[0];\n-                        let to = *sig.output().skip_binder();\n-                        self.check_transmute(expr.span, from, to);\n-                    }\n-                    _ => {\n-                        span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n-                    }\n-                }\n+                let sig = typ.fn_sig(self.tcx);\n+                let from = sig.inputs().skip_binder()[0];\n+                let to = *sig.output().skip_binder();\n+                self.check_transmute(expr.span, from, to);\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);"}, {"sha": "c6c052fa4b1bc100b8bd034126464cd2d71d4bc8", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = self.type_of(method.def_id).fn_sig();\n+        let ref sig = self.fn_sig(method.def_id);\n         for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);"}, {"sha": "c356e53234d9c3e3248eb17138fce58c9f012e19", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -1137,9 +1137,19 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n-    let sig = fn_type.fn_sig();\n+    let sig = fn_type.fn_sig(selcx.tcx());\n+    let Normalized {\n+        value: sig,\n+        obligations\n+    } = normalize_with_depth(selcx,\n+                             obligation.param_env,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &sig);\n+\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n         .with_addl_obligations(fn_pointer_vtable.nested)\n+        .with_addl_obligations(obligations)\n }\n \n fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n@@ -1149,7 +1159,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.closure_type(vtable.closure_def_id)\n+    let closure_type = closure_typer.fn_sig(vtable.closure_def_id)\n         .subst(selcx.tcx(), vtable.substs.substs);\n     let Normalized {\n         value: closure_type,"}, {"sha": "a66b6b863541e2446170291ace748b925f95c010", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -1404,19 +1404,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::TyFnDef(.., ty::Binder(ty::FnSig {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: Abi::Rust,\n-                variadic: false,\n-                ..\n-            })) |\n-            ty::TyFnPtr(ty::Binder(ty::FnSig {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: Abi::Rust,\n-                variadic: false,\n-                ..\n-            })) => {\n-                candidates.vec.push(FnPointerCandidate);\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                if let ty::Binder(ty::FnSig {\n+                    unsafety: hir::Unsafety::Normal,\n+                    abi: Abi::Rust,\n+                    variadic: false,\n+                    ..\n+                }) = self_ty.fn_sig(self.tcx()) {\n+                    candidates.vec.push(FnPointerCandidate);\n+                }\n             }\n \n             _ => { }\n@@ -2348,19 +2344,26 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // ok to skip binder; it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let sig = self_ty.fn_sig();\n+        let sig = self_ty.fn_sig(self.tcx());\n         let trait_ref =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n                                                          self_ty,\n                                                          sig,\n                                                          util::TupleArgumentsFlag::Yes)\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n+        let Normalized { value: trait_ref, obligations } =\n+            project::normalize_with_depth(self,\n+                                          obligation.param_env,\n+                                          obligation.cause.clone(),\n+                                          obligation.recursion_depth + 1,\n+                                          &trait_ref);\n+\n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                      obligation.param_env,\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n-        Ok(VtableFnPointerData { fn_ty: self_ty, nested: vec![] })\n+        Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n     }\n \n     fn confirm_closure_candidate(&mut self,\n@@ -2799,7 +2802,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let closure_type = self.infcx.closure_type(closure_def_id)\n+        let closure_type = self.infcx.fn_sig(closure_def_id)\n             .subst(self.tcx(), substs.substs);\n         let ty::Binder((trait_ref, _)) =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),"}, {"sha": "5f869fc5567ee186d58a7641505634de882a94b9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -1378,9 +1378,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_fn_def(self, def_id: DefId,\n-                     substs: &'tcx Substs<'tcx>,\n-                     fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnDef(def_id, substs, fty))\n+                     substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnDef(def_id, substs))\n     }\n \n     pub fn mk_fn_ptr(self, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {"}, {"sha": "68f85ba7d33e23dc87beb3ab93134b71352c6edd", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -68,14 +68,15 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             // view of possibly unifying\n             simplify_type(tcx, mt.ty, can_simplify_params)\n         }\n+        ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n         ty::TyNever => Some(NeverSimplifiedType),\n         ty::TyTuple(ref tys, _) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n-        ty::TyFnDef(.., ref f) | ty::TyFnPtr(ref f) => {\n+        ty::TyFnPtr(ref f) => {\n             Some(FunctionSimplifiedType(f.skip_binder().inputs().len()))\n         }\n         ty::TyProjection(_) | ty::TyParam(_) => {"}, {"sha": "d5aa9f55ff0c4e34beb5942070f79ba6bee1f78b", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -155,9 +155,8 @@ impl FlagComputation {\n                 self.add_tys(&ts[..]);\n             }\n \n-            &ty::TyFnDef(_, substs, f) => {\n+            &ty::TyFnDef(_, substs) => {\n                 self.add_substs(substs);\n-                self.add_fn_sig(f);\n             }\n \n             &ty::TyFnPtr(f) => {"}, {"sha": "b9896e0cecf5dac93d19cebe75950af51194daf8", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -348,7 +348,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n                                       .filter_map(|ty| characteristic_def_id_of_type(ty))\n                                       .next(),\n \n-        ty::TyFnDef(def_id, ..) |\n+        ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => Some(def_id),\n \n         ty::TyBool |"}, {"sha": "a6c59d4c2235436fc1e6f739b02c34ea76fa2bfc", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -875,13 +875,12 @@ define_maps! { <'tcx>\n     /// for trans. This is also the only query that can fetch non-local MIR, at present.\n     [] optimized_mir: Mir(DefId) -> &'tcx mir::Mir<'tcx>,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n+    /// Type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n     [] closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    [] closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    /// The signature of functions and closures.\n+    [] fn_sig: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n     [] coerce_unsized_info: ItemSignature(DefId)"}, {"sha": "f4d0867d130001846310f4bf0ce373ed5ad96ff1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -206,7 +206,7 @@ impl AssociatedItem {\n                 // late-bound regions, and we don't want method signatures to show up\n                 // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n                 // regions just fine, showing `fn(&MyType)`.\n-                format!(\"{}\", tcx.type_of(self.def_id).fn_sig().skip_binder())\n+                format!(\"{}\", tcx.fn_sig(self.def_id).skip_binder())\n             }\n             ty::AssociatedKind::Type => format!(\"type {};\", self.name.to_string()),\n             ty::AssociatedKind::Const => {"}, {"sha": "2e9780572c9b40bfa8d4ac2a1b1aafee64fb9835", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -291,7 +291,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = relation.relate_item_substs(a.def_id, a.substs, b.substs)?;\n+            let substs = relate_substs(relation, None, a.substs, b.substs)?;\n             Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n@@ -308,7 +308,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = relation.relate_item_substs(a.def_id, a.substs, b.substs)?;\n+            let substs = relate_substs(relation, None, a.substs, b.substs)?;\n             Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n@@ -440,13 +440,11 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             }\n         }\n \n-        (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n-         &ty::TyFnDef(b_def_id, b_substs, b_fty))\n+        (&ty::TyFnDef(a_def_id, a_substs), &ty::TyFnDef(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n-            let substs = relate_substs(relation, None, a_substs, b_substs)?;\n-            let fty = relation.relate(&a_fty, &b_fty)?;\n-            Ok(tcx.mk_fn_def(a_def_id, substs, fty))\n+            let substs = relation.relate_item_substs(a_def_id, a_substs, b_substs)?;\n+            Ok(tcx.mk_fn_def(a_def_id, substs))\n         }\n \n         (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>"}, {"sha": "d05262965d7fd6daf8505f23bcdd7bb51c842c8b", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -531,10 +531,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyDynamic(ref trait_ty, ref region) =>\n                 ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n             ty::TyTuple(ts, defaulted) => ty::TyTuple(ts.fold_with(folder), defaulted),\n-            ty::TyFnDef(def_id, substs, f) => {\n-                ty::TyFnDef(def_id,\n-                            substs.fold_with(folder),\n-                            f.fold_with(folder))\n+            ty::TyFnDef(def_id, substs) => {\n+                ty::TyFnDef(def_id, substs.fold_with(folder))\n             }\n             ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n             ty::TyRef(ref r, tm) => {\n@@ -568,9 +566,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyDynamic(ref trait_ty, ref reg) =>\n                 trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n             ty::TyTuple(ts, _) => ts.visit_with(visitor),\n-            ty::TyFnDef(_, substs, ref f) => {\n-                substs.visit_with(visitor) || f.visit_with(visitor)\n-            }\n+            ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),"}, {"sha": "ed3312d88a38420babc569919be055fe161b30f3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use hir::map::DefPathHash;\n \n use middle::region;\n-use ty::subst::Substs;\n+use ty::subst::{Substs, Subst};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n use ty::subst::Kind;\n@@ -138,7 +138,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n-    TyFnDef(DefId, &'tcx Substs<'tcx>, PolyFnSig<'tcx>),\n+    TyFnDef(DefId, &'tcx Substs<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n     TyFnPtr(PolyFnSig<'tcx>),\n@@ -1329,9 +1329,12 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self) -> PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n         match self.sty {\n-            TyFnDef(.., f) | TyFnPtr(f) => f,\n+            TyFnDef(def_id, substs) => {\n+                tcx.fn_sig(def_id).subst(tcx, substs)\n+            }\n+            TyFnPtr(f) => f,\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }"}, {"sha": "98ef7918fef82ac263afe005a05ddd94a86e0e93", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -679,7 +679,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n             TyAnon(def_id, _) |\n-            TyFnDef(def_id, ..) => self.def_id(def_id),\n+            TyFnDef(def_id, _) => self.def_id(def_id),\n             TyAdt(d, _) => self.def_id(d.did),\n             TyFnPtr(f) => {\n                 self.hash(f.unsafety());"}, {"sha": "71844abfe534c14b8e6cf5dcd0f6e97de1325467", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -115,9 +115,8 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());\n         }\n-        ty::TyFnDef(_, substs, ft) => {\n+        ty::TyFnDef(_, substs) => {\n             stack.extend(substs.types().rev());\n-            push_sig_subtypes(stack, ft);\n         }\n         ty::TyFnPtr(ft) => {\n             push_sig_subtypes(stack, ft);"}, {"sha": "eb6bffc29c56171ecc37cd1d07a7cc0571defb39", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -753,8 +753,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n                 write!(f, \")\")\n             }\n-            TyFnDef(def_id, substs, ref bare_fn) => {\n-                write!(f, \"{} {{\", bare_fn.0)?;\n+            TyFnDef(def_id, substs) => {\n+                ty::tls::with(|tcx| {\n+                    let mut sig = tcx.fn_sig(def_id);\n+                    if let Some(substs) = tcx.lift(&substs) {\n+                        sig = sig.subst(tcx, substs);\n+                    }\n+                    write!(f, \"{} {{\", sig.0)\n+                })?;\n                 parameterized(f, substs, def_id, &[])?;\n                 write!(f, \"}}\")\n             }"}, {"sha": "4bef191b113bd66816416df4614fe65146c6c794", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -161,18 +161,13 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            terminator: &'a Option<mir::Terminator<'tcx>>)\n                            -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n-        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n-        {\n-            if let mir::Operand::Constant(ref func) = *oper\n-            {\n-                if let ty::TyFnDef(def_id, _, sig) = func.ty.sty\n-                {\n-                    let abi = sig.abi();\n+        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n+            if let mir::Operand::Constant(ref func) = *oper {\n+                if let ty::TyFnDef(def_id, _) = func.ty.sty {\n+                    let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n-                    if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                        if name == \"rustc_peek\" {\n-                            return Some((args, source_info.span));\n-                        }\n+                    if abi == Abi::RustIntrinsic &&  name == \"rustc_peek\" {\n+                        return Some((args, source_info.span));\n                     }\n                 }\n             }"}, {"sha": "0a966b0c170712dceabb786c3b72e1e8f81bcc7f", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -12,7 +12,7 @@ use eval;\n \n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n use rustc::mir::{Field, BorrowKind, Mutability};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, TypeVariants, Region};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -549,8 +549,8 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     let substs = match ty.sty {\n-                        TypeVariants::TyAdt(_, substs) => substs,\n-                        TypeVariants::TyFnDef(_, substs, _) => substs,\n+                        ty::TyAdt(_, substs) |\n+                        ty::TyFnDef(_, substs) => substs,\n                         _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n                     };\n                     PatternKind::Variant {"}, {"sha": "ad154f9b8153106b73263b07b5fa92f1a2ef7198", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -1154,24 +1154,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tables.node_id_to_type(expr.id);\n-                match typ.sty {\n-                    ty::TyFnDef(.., bare_fn) if bare_fn.abi() == RustIntrinsic => {\n-                        let from = bare_fn.inputs().skip_binder()[0];\n-                        let to = *bare_fn.output().skip_binder();\n-                        return Some((&from.sty, &to.sty));\n-                    }\n-                    _ => (),\n-                }\n+                let sig = cx.tables.node_id_to_type(expr.id).fn_sig(cx.tcx);\n+                let from = sig.inputs().skip_binder()[0];\n+                let to = *sig.output().skip_binder();\n+                return Some((&from.sty, &to.sty));\n             }\n             None\n         }\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n-            match cx.tcx.type_of(def_id).sty {\n-                ty::TyFnDef(.., bfty) if bfty.abi() == RustIntrinsic => (),\n-                _ => return false,\n-            }\n+            cx.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n             cx.tcx.item_name(def_id) == \"transmute\"\n         }\n     }"}, {"sha": "ac3977bd216e7a4587f293ffb4c961635c391766", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -659,7 +659,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n         let def_id = self.cx.tcx.hir.local_def_id(id);\n-        let sig = self.cx.tcx.type_of(def_id).fn_sig();\n+        let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {"}, {"sha": "502eab44dac52d7c116aa6103b77fae04bc15079", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -106,7 +106,7 @@ provide! { <'tcx> tcx, def_id, cdata,\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n-    closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+    fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n     is_const_fn => { cdata.is_const_fn(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }"}, {"sha": "3e6d06ec86ff89530f3ca014e92db8f870300997", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -1084,14 +1084,20 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn closure_ty(&self,\n-                      closure_id: DefIndex,\n-                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                      -> ty::PolyFnSig<'tcx> {\n-        match self.entry(closure_id).kind {\n-            EntryKind::Closure(data) => data.decode(self).ty.decode((self, tcx)),\n+    pub fn fn_sig(&self,\n+                  id: DefIndex,\n+                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                  -> ty::PolyFnSig<'tcx> {\n+        let sig = match self.entry(id).kind {\n+            EntryKind::Fn(data) |\n+            EntryKind::ForeignFn(data) => data.decode(self).sig,\n+            EntryKind::Method(data) => data.decode(self).fn_data.sig,\n+            EntryKind::Variant(data) |\n+            EntryKind::Struct(data, _) => data.decode(self).ctor_sig.unwrap(),\n+            EntryKind::Closure(data) => data.decode(self).sig,\n             _ => bug!(),\n-        }\n+        };\n+        sig.decode((self, tcx))\n     }\n \n     #[inline]"}, {"sha": "e9701b95002d4dc5d4706ffe6e1c94c29a7051cb", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -16,6 +16,7 @@ use schema::*;\n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n                             EncodedMetadata, EncodedMetadataHashes,\n                             EncodedMetadataHash};\n+use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::ich::Fingerprint;\n@@ -499,6 +500,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             struct_ctor: None,\n+            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n+                Some(self.lazy(&tcx.fn_sig(def_id)))\n+            } else {\n+                None\n+            }\n         };\n \n         let enum_id = tcx.hir.as_local_node_id(enum_did).unwrap();\n@@ -518,7 +524,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if variant.ctor_kind == CtorKind::Fn {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -617,6 +627,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             struct_ctor: Some(def_id.index),\n+            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n+                Some(self.lazy(&tcx.fn_sig(def_id)))\n+            } else {\n+                None\n+            }\n         };\n \n         let struct_id = tcx.hir.as_local_node_id(adt_def_id).unwrap();\n@@ -641,7 +656,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if variant.ctor_kind == CtorKind::Fn {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -695,7 +714,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names: arg_names\n+                        arg_names: arg_names,\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -732,7 +752,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 }\n             },\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if trait_item.kind == ty::AssociatedKind::Method {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -747,6 +771,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n+        let tcx = self.tcx;\n+\n         let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.hir.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n@@ -768,6 +794,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     FnData {\n                         constness: sig.constness,\n                         arg_names: self.encode_fn_arg_names_for_body(body),\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -806,7 +833,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if impl_item.kind == ty::AssociatedKind::Method {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -881,6 +912,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 let data = FnData {\n                     constness: constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n+                    sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n \n                 EntryKind::Fn(self.lazy(&data))\n@@ -910,6 +942,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     struct_ctor: struct_ctor,\n+                    ctor_sig: None,\n                 }), repr_options)\n             }\n             hir::ItemUnion(..) => {\n@@ -920,6 +953,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     struct_ctor: None,\n+                    ctor_sig: None,\n                 }), repr_options)\n             }\n             hir::ItemDefaultImpl(..) => {\n@@ -1037,7 +1071,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemTrait(..) => self.encode_variances_of(def_id),\n+                hir::ItemFn(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: match item.node {\n@@ -1175,7 +1209,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.closure_type(def_id)),\n+            sig: self.lazy(&tcx.fn_sig(def_id)),\n         };\n \n         Entry {\n@@ -1363,6 +1397,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n                     arg_names: self.encode_fn_arg_names(names),\n+                    sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(&data))\n             }\n@@ -1381,7 +1416,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: match nitem.node {\n+                hir::ForeignItemFn(..) => self.encode_variances_of(def_id),\n+                _ => LazySeq::empty(),\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n "}, {"sha": "9ef5b9408303d7f886ad74a3a145e2a872d6665b", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -343,18 +343,18 @@ pub enum EntryKind<'tcx> {\n     Type,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>, ReprOptions),\n-    Union(Lazy<VariantData>, ReprOptions),\n-    Fn(Lazy<FnData>),\n-    ForeignFn(Lazy<FnData>),\n+    Variant(Lazy<VariantData<'tcx>>),\n+    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Fn(Lazy<FnData<'tcx>>),\n+    ForeignFn(Lazy<FnData<'tcx>>),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n     Closure(Lazy<ClosureData<'tcx>>),\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n-    Method(Lazy<MethodData>),\n+    Method(Lazy<MethodData<'tcx>>),\n     AssociatedType(AssociatedContainer),\n     AssociatedConst(AssociatedContainer, u8),\n }\n@@ -439,27 +439,33 @@ pub struct MacroDef {\n impl_stable_hash_for!(struct MacroDef { body, legacy });\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct FnData {\n+pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n     pub arg_names: LazySeq<ast::Name>,\n+    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct FnData { constness, arg_names });\n+impl_stable_hash_for!(struct FnData<'tcx> { constness, arg_names, sig });\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData {\n+pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item.\n     pub struct_ctor: Option<DefIndex>,\n+\n+    /// If this is a tuple struct or variant\n+    /// ctor, this is its \"function\" signature.\n+    pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct VariantData {\n+impl_stable_hash_for!(struct VariantData<'tcx> {\n     ctor_kind,\n     discr,\n-    struct_ctor\n+    struct_ctor,\n+    ctor_sig\n });\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -543,16 +549,16 @@ impl AssociatedContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData {\n-    pub fn_data: FnData,\n+pub struct MethodData<'tcx> {\n+    pub fn_data: FnData<'tcx>,\n     pub container: AssociatedContainer,\n     pub has_self: bool,\n }\n-impl_stable_hash_for!(struct MethodData { fn_data, container, has_self });\n+impl_stable_hash_for!(struct MethodData<'tcx> { fn_data, container, has_self });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub kind: ty::ClosureKind,\n-    pub ty: Lazy<ty::PolyFnSig<'tcx>>,\n+    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n-impl_stable_hash_for!(struct ClosureData<'tcx> { kind, ty });\n+impl_stable_hash_for!(struct ClosureData<'tcx> { kind, sig });"}, {"sha": "326c1df69ebebd364c4990d2cadccd097c64985c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -205,11 +205,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n                 let diverges = expr.ty.is_never();\n                 let intrinsic = match ty.sty {\n-                    ty::TyFnDef(def_id, _, ref f) if\n-                        f.abi() == Abi::RustIntrinsic ||\n-                        f.abi() == Abi::PlatformIntrinsic =>\n-                    {\n-                        Some(this.hir.tcx().item_name(def_id).as_str())\n+                    ty::TyFnDef(def_id, _)  => {\n+                        let f = ty.fn_sig(this.hir.tcx());\n+                        if f.abi() == Abi::RustIntrinsic ||\n+                           f.abi() == Abi::PlatformIntrinsic {\n+                            Some(this.hir.tcx().item_name(def_id).as_str())\n+                        } else {\n+                            None\n+                        }\n                     }\n                     _ => None\n                 };"}, {"sha": "0010f312ef9852e13bfe166f4c0a0c6768fa76cb", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -19,7 +19,6 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::cast::CastKind as TyCastKind;\n-use rustc::ty::subst::Subst;\n use rustc::hir;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n@@ -586,7 +585,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     });\n     Expr {\n         temp_lifetime: temp_lifetime,\n-        ty: cx.tcx.type_of(def_id).subst(cx.tcx, substs),\n+        ty: cx.tcx().mk_fn_def(def_id, substs),\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {"}, {"sha": "11ad5d1509d29bcd17b2cd0bb1c541986de4cf31", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -58,7 +58,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             // types in the MIR. They will be substituted again with\n             // the param-substs, but because they are concrete, this\n             // will not do any harm.\n-            let sig = tcx.erase_late_bound_regions(&ty.fn_sig());\n+            let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n             let arg_tys = sig.inputs();\n \n             build_call_shim(\n@@ -153,8 +153,8 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     } else {\n         Substs::identity_for_item(tcx, def_id)\n     };\n-    let fn_ty = tcx.type_of(def_id).subst(tcx, substs);\n-    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let sig = tcx.fn_sig(def_id).subst(tcx, substs);\n+    let sig = tcx.erase_late_bound_regions(&sig);\n     let span = tcx.def_span(def_id);\n \n     let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n@@ -276,8 +276,8 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n \n-    let fn_ty = tcx.type_of(def_id);\n-    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let sig = tcx.fn_sig(def_id);\n+    let sig = tcx.erase_late_bound_regions(&sig);\n     let span = tcx.def_span(def_id);\n \n     debug!(\"build_call_shim: sig={:?}\", sig);\n@@ -409,11 +409,8 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n {\n     let tcx = infcx.tcx;\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    let sig = match tcx.type_of(def_id).sty {\n-        ty::TyFnDef(_, _, fty) => tcx.no_late_bound_regions(&fty)\n-            .expect(\"LBR in ADT constructor signature\"),\n-        _ => bug!(\"unexpected type for ctor {:?}\", def_id)\n-    };\n+    let sig = tcx.no_late_bound_regions(&tcx.fn_sig(def_id))\n+        .expect(\"LBR in ADT constructor signature\");\n     let sig = tcx.erase_regions(&sig);\n \n     let (adt_def, substs) = match sig.output().sty {"}, {"sha": "5f80c7bee147832ca51ef19283df30b27a76e3f5", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let terminator = bb_data.terminator();\n                 if let TerminatorKind::Call {\n                     func: Operand::Constant(ref f), .. } = terminator.kind {\n-                    if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                    if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n                         callsites.push_back(CallSite {\n                             callee: callee_def_id,\n                             substs: substs,\n@@ -131,7 +131,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     let terminator = bb_data.terminator();\n                     if let TerminatorKind::Call {\n                         func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                        if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n                             // Don't inline the same function multiple times.\n                             if callsite.callee != callee_def_id {\n                                 callsites.push_back(CallSite {\n@@ -270,8 +270,9 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 }\n \n                 TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n-                    if let ty::TyFnDef(.., f) = f.ty.sty {\n+                    if let ty::TyFnDef(def_id, _) = f.ty.sty {\n                         // Don't give intrinsics the extra penalty for calls\n+                        let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n                             cost += INSTR_COST;\n                         } else {"}, {"sha": "91d6ce60b39044809ea169ab71f798d8fcc1ac36", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -750,8 +750,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             let fn_ty = func.ty(self.mir, self.tcx);\n             let (is_shuffle, is_const_fn) = match fn_ty.sty {\n-                ty::TyFnDef(def_id, _, f) => {\n-                    (f.abi() == Abi::PlatformIntrinsic &&\n+                ty::TyFnDef(def_id, _) => {\n+                    (self.tcx.fn_sig(def_id).abi() == Abi::PlatformIntrinsic &&\n                      self.tcx.item_name(def_id).as_str().starts_with(\"simd_shuffle\"),\n                      self.tcx.is_const_fn(def_id))\n                 }"}, {"sha": "7e6fccf30192ce626dbc072efd9b4948bf41b747", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n-                    ty::TyFnDef(.., sig) | ty::TyFnPtr(sig) => sig,\n+                    ty::TyFnDef(..) | ty::TyFnPtr(_) => func_ty.fn_sig(tcx),\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n                         return;"}, {"sha": "9eb96fea52778e6677d09a28deacfd1ee99d15fe", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -400,7 +400,13 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        self.ev.tcx.type_of(self.item_def_id).visit_with(self);\n+        let ty = self.ev.tcx.type_of(self.item_def_id);\n+        ty.visit_with(self);\n+        if let ty::TyFnDef(def_id, _) = ty.sty {\n+            if def_id == self.item_def_id {\n+                self.ev.tcx.fn_sig(def_id).visit_with(self);\n+            }\n+        }\n         self\n     }\n \n@@ -910,7 +916,13 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        self.tcx.type_of(self.item_def_id).visit_with(self);\n+        let ty = self.tcx.type_of(self.item_def_id);\n+        ty.visit_with(self);\n+        if let ty::TyFnDef(def_id, _) = ty.sty {\n+            if def_id == self.item_def_id {\n+                self.tcx.fn_sig(def_id).visit_with(self);\n+            }\n+        }\n         self\n     }\n "}, {"sha": "10b66fb1991087a351150bcc8ec921a8cd7ce349", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -154,6 +154,13 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         assert!(!item_type.has_erasable_regions());\n         hasher.visit_ty(item_type);\n \n+        // If this is a function, we hash the signature as well.\n+        // This is not *strictly* needed, but it may help in some\n+        // situations, see the `run-make/a-b-a-linker-guard` test.\n+        if let ty::TyFnDef(..) = item_type.sty {\n+            item_type.fn_sig(tcx).visit_with(&mut hasher);\n+        }\n+\n         // also include any type parameters (for generic items)\n         if let Some(substs) = substs {\n             assert!(!substs.has_erasable_regions());"}, {"sha": "3c502eec549b27413ccc5208c35a2b1c5bef0c90", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -587,7 +587,7 @@ fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<TransItem<'tcx>>)\n {\n-    if let ty::TyFnDef(def_id, substs, _) = ty.sty {\n+    if let ty::TyFnDef(def_id, substs) = ty.sty {\n         let instance = monomorphize::resolve(scx, def_id, substs);\n         visit_instance_use(scx, instance, is_direct_call, output);\n     }"}, {"sha": "9b0803908b162582e1dc86bbdc152f4b4f3a4dc5", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -495,12 +495,12 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            -> ty::PolyFnSig<'tcx>\n {\n     match ty.sty {\n-        ty::TyFnDef(_, _, sig) => sig,\n+        ty::TyFnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(sig) => sig,\n+        ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx()),\n         ty::TyClosure(def_id, substs) => {\n             let tcx = ccx.tcx();\n-            let sig = tcx.closure_type(def_id).subst(tcx, substs.substs);\n+            let sig = tcx.fn_sig(def_id).subst(tcx, substs.substs);\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n             let env_ty = match tcx.closure_kind(def_id) {"}, {"sha": "0cc1993601119597c7d2e553f9abd8126a1d70d8", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -488,7 +488,6 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"type_metadata: {:?}\", t);\n \n-    let sty = &t.sty;\n     let ptr_metadata = |ty: Ty<'tcx>| {\n         match ty.sty {\n             ty::TySlice(typ) => {\n@@ -518,7 +517,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n+    let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.sty {\n         ty::TyNever    |\n         ty::TyBool     |\n         ty::TyChar     |\n@@ -557,10 +556,10 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 Err(metadata) => return metadata,\n             }\n         }\n-        ty::TyFnDef(.., sig) | ty::TyFnPtr(sig) => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n-                                                       sig,\n+                                                       t.fn_sig(cx.tcx()),\n                                                        usage_site_span).metadata;\n             match debug_context(cx).type_map\n                                    .borrow()\n@@ -610,7 +609,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty)\n+            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", t)\n         }\n     };\n "}, {"sha": "bfca4fec706eda94267e9779c79320c94d18866a", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -96,8 +96,8 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 push_type_params(cx, principal.substs, output);\n             }\n         },\n-        ty::TyFnDef(.., sig) |\n-        ty::TyFnPtr(sig) => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            let sig = t.fn_sig(cx.tcx());\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }"}, {"sha": "9956c28e6412139d2f2fc2fddc106b74b020a104", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -95,11 +95,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ccx = bcx.ccx;\n     let tcx = ccx.tcx();\n \n-    let (def_id, substs, sig) = match callee_ty.sty {\n-        ty::TyFnDef(def_id, substs, sig) => (def_id, substs, sig),\n+    let (def_id, substs) = match callee_ty.sty {\n+        ty::TyFnDef(def_id, substs) => (def_id, substs),\n         _ => bug!(\"expected fn item type, found {}\", callee_ty)\n     };\n \n+    let sig = callee_ty.fn_sig(tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     let arg_tys = sig.inputs();\n     let ret_ty = sig.output();\n@@ -986,7 +987,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n \n     let tcx = bcx.tcx();\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig());\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n \n     // every intrinsic takes a SIMD vector as its first argument"}, {"sha": "16972a1b1ae249a9683776534d2e241de7a85c66", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -404,20 +404,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n-                let (instance, mut llfn, sig) = match callee.ty.sty {\n-                    ty::TyFnDef(def_id, substs, sig) => {\n+                let (instance, mut llfn) = match callee.ty.sty {\n+                    ty::TyFnDef(def_id, substs) => {\n                         (Some(monomorphize::resolve(bcx.ccx.shared(), def_id, substs)),\n-                         None,\n-                         sig)\n+                         None)\n                     }\n-                    ty::TyFnPtr(sig) => {\n-                        (None,\n-                         Some(callee.immediate()),\n-                         sig)\n+                    ty::TyFnPtr(_) => {\n+                        (None, Some(callee.immediate()))\n                     }\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n                 let def = instance.map(|i| i.def);\n+                let sig = callee.ty.fn_sig(bcx.tcx());\n                 let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                 let abi = sig.abi;\n "}, {"sha": "fcb4b25e6fe88d6a8bf6d6f7584ade9bad7ef86c", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     let fn_ty = func.ty(self.mir, tcx);\n                     let fn_ty = self.monomorphize(&fn_ty);\n                     let (def_id, substs) = match fn_ty.sty {\n-                        ty::TyFnDef(def_id, substs, _) => (def_id, substs),\n+                        ty::TyFnDef(def_id, substs) => (def_id, substs),\n                         _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n                                        func, fn_ty)\n                     };\n@@ -560,7 +560,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n-                            ty::TyFnDef(def_id, substs, _) => {\n+                            ty::TyFnDef(def_id, substs) => {\n                                 callee::resolve_and_get_fn(self.ccx, def_id, substs)\n                             }\n                             _ => {\n@@ -579,7 +579,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     .find(|it| it.kind == ty::AssociatedKind::Method)\n                                     .unwrap().def_id;\n                                 // Now create its substs [Closure, Tuple]\n-                                let input = tcx.closure_type(def_id)\n+                                let input = tcx.fn_sig(def_id)\n                                     .subst(tcx, substs.substs).input(0);\n                                 let input = tcx.erase_late_bound_regions_and_normalize(&input);\n                                 let substs = tcx.mk_substs([operand.ty, input]"}, {"sha": "4bd5091a4f35f8069ea4225e58a17a3a07916468", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n-                            ty::TyFnDef(def_id, substs, _) => {\n+                            ty::TyFnDef(def_id, substs) => {\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n                             }"}, {"sha": "1f6a262162d3950021550cba8a44dce92be8777d", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -40,7 +40,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let self_ty = tcx.mk_closure_from_closure_substs(\n         closure_did, substs);\n \n-    let sig = tcx.closure_type(closure_did).subst(tcx, substs.substs);\n+    let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs([\n@@ -165,9 +165,11 @@ pub fn resolve<'a, 'tcx>(\n     } else {\n         let item_type = def_ty(scx, def_id, substs);\n         let def = match item_type.sty {\n-            ty::TyFnDef(_, _, f) if\n-                f.abi() == Abi::RustIntrinsic ||\n-                f.abi() == Abi::PlatformIntrinsic =>\n+            ty::TyFnDef(..) if {\n+                    let f = item_type.fn_sig(scx.tcx());\n+                    f.abi() == Abi::RustIntrinsic ||\n+                    f.abi() == Abi::PlatformIntrinsic\n+                } =>\n             {\n                 debug!(\" => intrinsic\");\n                 ty::InstanceDef::Intrinsic(def_id)"}, {"sha": "f59f6850da103de65ee6f877b7f635c63cbc6e20", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -401,8 +401,9 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                         output);\n                 }\n             },\n-            ty::TyFnDef(.., sig) |\n-            ty::TyFnPtr(sig) => {\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) => {\n+                let sig = t.fn_sig(self.tcx);\n                 if sig.unsafety() == hir::Unsafety::Unsafe {\n                     output.push_str(\"unsafe \");\n                 }"}, {"sha": "68726a7b1c4ebe111a7c53f35cf7ca2d63bd0774", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -619,7 +619,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = pat_ty.fn_sig().output();\n+        let pat_ty = pat_ty.fn_sig(tcx).output();\n         let pat_ty = tcx.no_late_bound_regions(&pat_ty).expect(\"expected fn type\");\n         self.demand_eqtype(pat.span, expected, pat_ty);\n "}, {"sha": "a0801a7486654580f86ef2e6a8e5717fba2c6342", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id).is_none() {\n-                    let closure_ty = self.closure_type(def_id).subst(self.tcx, substs.substs);\n+                    let closure_ty = self.fn_sig(def_id).subst(self.tcx, substs.substs);\n                     let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                    infer::FnCall,\n                                                                    &closure_ty)\n@@ -196,8 +196,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expected: Expectation<'tcx>)\n                             -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n-            ty::TyFnDef(def_id, .., sig) => {\n-                (sig, self.tcx.hir.span_if_local(def_id))\n+            ty::TyFnDef(def_id, _) => {\n+                (callee_ty.fn_sig(self.tcx), self.tcx.hir.span_if_local(def_id))\n             }\n             ty::TyFnPtr(sig) => (sig, None),\n             ref t => {"}, {"sha": "46d304976dc635b11585a36ba061e301b90b9cba", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -356,8 +356,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                if let ty::TyFnDef(.., f) = self.expr_ty.sty {\n+                if let ty::TyFnDef(..) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n+                    let f = self.expr_ty.fn_sig(fcx.tcx);\n                     let res = fcx.try_coerce(self.expr,\n                                              self.expr_ty,\n                                              self.expr_diverges,"}, {"sha": "17d02223716827e7fbf3530496abaabdf0fb648a", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -210,13 +210,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         match a.sty {\n-            ty::TyFnDef(.., a_f) => {\n+            ty::TyFnDef(..) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n                 // require double indirection).\n                 // Additionally, we permit coercion of function\n                 // items to drop the unsafe qualifier.\n-                self.coerce_from_fn_item(a, a_f, b)\n+                self.coerce_from_fn_item(a, b)\n             }\n             ty::TyFnPtr(a_f) => {\n                 // We permit coercion of fn pointers to drop the\n@@ -600,7 +600,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     fn coerce_from_fn_item(&self,\n                            a: Ty<'tcx>,\n-                           fn_ty_a: ty::PolyFnSig<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n@@ -612,9 +611,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         match b.sty {\n             ty::TyFnPtr(_) => {\n-                let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n-                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b,\n-                    simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))\n+                let a_sig = a.fn_sig(self.tcx);\n+                let InferOk { value: a_sig, mut obligations } =\n+                    self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n+\n+                let a_fn_pointer = self.tcx.mk_fn_ptr(a_sig);\n+                let InferOk { value, obligations: o2 } =\n+                    self.coerce_from_safe_fn(a_fn_pointer, a_sig, b,\n+                        simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))?;\n+\n+                obligations.extend(o2);\n+                Ok(InferOk { value, obligations })\n             }\n             _ => self.unify_and(a, b, identity),\n         }\n@@ -639,7 +646,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n                 //     `fn(arg0,arg1,...) -> _`\n-                let sig = self.closure_type(def_id_a).subst(self.tcx, substs_a.substs);\n+                let sig = self.fn_sig(def_id_a).subst(self.tcx, substs_a.substs);\n                 let converted_sig = sig.map_bound(|s| {\n                     let params_iter = match s.inputs()[0].sty {\n                         ty::TyTuple(params, _) => {\n@@ -775,42 +782,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n-        match (&prev_ty.sty, &new_ty.sty) {\n-            (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n-                // The signature must always match.\n-                let fty = self.at(cause, self.param_env)\n-                              .trace(prev_ty, new_ty)\n-                              .lub(&a_fty, &b_fty)\n-                              .map(|ok| self.register_infer_ok_obligations(ok))?;\n-\n-                if a_def_id == b_def_id {\n-                    // Same function, maybe the parameters match.\n-                    let substs = self.commit_if_ok(|_| {\n-                        self.at(cause, self.param_env)\n-                            .trace(prev_ty, new_ty)\n-                            .lub(&a_substs, &b_substs)\n-                            .map(|ok| self.register_infer_ok_obligations(ok))\n-                    });\n-\n-                    if let Ok(substs) = substs {\n-                        // We have a LUB of prev_ty and new_ty, just return it.\n-                        return Ok(self.tcx.mk_fn_def(a_def_id, substs, fty));\n-                    }\n-                }\n+        if let (&ty::TyFnDef(..), &ty::TyFnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n+            // Don't reify if the function types have a LUB, i.e. they\n+            // are the same function and their parameters have a LUB.\n+            let lub_ty = self.commit_if_ok(|_| {\n+                self.at(cause, self.param_env)\n+                    .lub(prev_ty, new_ty)\n+                    .map(|ok| self.register_infer_ok_obligations(ok))\n+            });\n+\n+            if lub_ty.is_ok() {\n+                // We have a LUB of prev_ty and new_ty, just return it.\n+                return lub_ty;\n+            }\n \n-                // Reify both sides and return the reified fn pointer type.\n-                let fn_ptr = self.tcx.mk_fn_ptr(fty);\n-                for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n-                    // The only adjustment that can produce an fn item is\n-                    // `NeverToAny`, so this should always be valid.\n-                    self.apply_adjustments(expr, vec![Adjustment {\n-                        kind: Adjust::ReifyFnPointer,\n-                        target: fn_ptr\n-                    }]);\n-                }\n-                return Ok(fn_ptr);\n+            // The signature must match.\n+            let a_sig = prev_ty.fn_sig(self.tcx);\n+            let a_sig = self.normalize_associated_types_in(new.span, &a_sig);\n+            let b_sig = new_ty.fn_sig(self.tcx);\n+            let b_sig = self.normalize_associated_types_in(new.span, &b_sig);\n+            let sig = self.at(cause, self.param_env)\n+                          .trace(prev_ty, new_ty)\n+                          .lub(&a_sig, &b_sig)\n+                          .map(|ok| self.register_infer_ok_obligations(ok))?;\n+\n+            // Reify both sides and return the reified fn pointer type.\n+            let fn_ptr = self.tcx.mk_fn_ptr(sig);\n+            for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n+                // The only adjustment that can produce an fn item is\n+                // `NeverToAny`, so this should always be valid.\n+                self.apply_adjustments(expr, vec![Adjustment {\n+                    kind: Adjust::ReifyFnPointer,\n+                    target: fn_ptr\n+                }]);\n             }\n-            _ => {}\n+            return Ok(fn_ptr);\n         }\n \n         let mut coerce = Coerce::new(self, cause.clone());"}, {"sha": "fd5147d76e8fdb72ebed4dbc0c0bac2cfcddce93", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -256,17 +256,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Compute skolemized form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n-        let m_sig = |method: &ty::AssociatedItem| {\n-            match tcx.type_of(method.def_id).sty {\n-                ty::TyFnDef(_, _, f) => f,\n-                _ => bug!()\n-            }\n-        };\n-\n         let (impl_sig, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                             infer::HigherRankedType,\n-                                                            &m_sig(impl_m));\n+                                                            &tcx.fn_sig(impl_m.def_id));\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n@@ -277,7 +270,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let trait_sig = inh.liberate_late_bound_regions(\n             impl_m.def_id,\n-            &m_sig(trait_m));\n+            &tcx.fn_sig(trait_m.def_id));\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n@@ -507,8 +500,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n-        let method_ty = tcx.type_of(method.def_id);\n-        let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n+        let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n         match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n             ExplicitSelf::ByValue => \"self\".to_string(),\n             ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n@@ -637,14 +629,8 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_m: &ty::AssociatedItem,\n                                                 trait_item_span: Option<Span>)\n                                                 -> Result<(), ErrorReported> {\n-    let m_fty = |method: &ty::AssociatedItem| {\n-        match tcx.type_of(method.def_id).sty {\n-            ty::TyFnDef(_, _, f) => f,\n-            _ => bug!()\n-        }\n-    };\n-    let impl_m_fty = m_fty(impl_m);\n-    let trait_m_fty = m_fty(trait_m);\n+    let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n+    let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {"}, {"sha": "287c591c1183d5e12f12fb9461b439b5995f6169", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -143,12 +143,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n-                match self.tcx.type_of(def_id).sty {\n-                    ty::TypeVariants::TyFnDef(_, _, sig) => {\n-                        sig.inputs().skip_binder().len() == 1\n-                    }\n-                    _ => false,\n-                }\n+                self.tcx.fn_sig(def_id).inputs().skip_binder().len() == 1\n             }\n             _ => false,\n         }"}, {"sha": "3acfbd1d844038183f92c32ea1b24433e353ed4d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -13,7 +13,6 @@\n \n use intrinsics;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::util::nodemap::FxHashMap;\n use require_same_types;\n@@ -35,22 +34,22 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    output: Ty<'tcx>) {\n     let def_id = tcx.hir.local_def_id(it.id);\n \n-    let substs = Substs::for_item(tcx, def_id,\n-                                  |_, _| tcx.types.re_erased,\n-                                  |def, _| tcx.mk_param_from_def(def));\n+    match it.node {\n+        hir::ForeignItemFn(..) => {}\n+        _ => {\n+            struct_span_err!(tcx.sess, it.span, E0619,\n+                             \"intrinsic must be a function\")\n+                .span_label(it.span, \"expected a function\")\n+                .emit();\n+            return;\n+        }\n+    }\n \n-    let fty = tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n-        inputs.into_iter(),\n-        output,\n-        false,\n-        hir::Unsafety::Unsafe,\n-        abi\n-    )));\n     let i_n_tps = tcx.generics_of(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, _, ref generics) => generics.span,\n-            hir::ForeignItemStatic(..) => it.span\n+            _ => bug!()\n         };\n \n         struct_span_err!(tcx.sess, span, E0094,\n@@ -59,14 +58,18 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         i_n_tps, n_tps)\n             .span_label(span, format!(\"expected {} type parameter\", n_tps))\n             .emit();\n-    } else {\n-        require_same_types(tcx,\n-                           &ObligationCause::new(it.span,\n-                                                 it.id,\n-                                                 ObligationCauseCode::IntrinsicType),\n-                           tcx.type_of(def_id),\n-                           fty);\n+        return;\n     }\n+\n+    let fty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+        inputs.into_iter(),\n+        output,\n+        false,\n+        hir::Unsafety::Unsafe,\n+        abi\n+    )));\n+    let cause = ObligationCause::new(it.span, it.id, ObligationCauseCode::IntrinsicType);\n+    require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(def_id)), fty);\n }\n \n /// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n@@ -376,7 +379,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                     let mut structural_to_nomimal = FxHashMap();\n \n-                    let sig = tcx.type_of(def_id).fn_sig();\n+                    let sig = tcx.fn_sig(def_id);\n                     let sig = tcx.no_late_bound_regions(&sig).unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,"}, {"sha": "209245187b13fd8bdc4903f266af7ccde2e051c1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let sig = self.tcx.type_of(def_id).fn_sig();\n+        let sig = self.tcx.fn_sig(def_id);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type."}, {"sha": "4f4169ac93d1b3d98027be9149eb20a868ef72b0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let fn_sig = tcx.type_of(def_id).fn_sig();\n+        let fn_sig = tcx.fn_sig(def_id);\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n                                                                     &fn_sig).0;"}, {"sha": "ee9a347ae95111b299c963ebb98a3ce554fae271", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -673,7 +673,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                expected: ty::Ty<'tcx>) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n-                let fty = self.tcx.type_of(def_id).fn_sig();\n+                let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let output = fty.output().subst(self.tcx, substs);\n@@ -1288,7 +1288,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n-        let self_ty = self.tcx.type_of(method).fn_sig().input(0);\n+        let self_ty = self.tcx.fn_sig(method).input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n                self_ty,"}, {"sha": "701de029b2bd5362bf9941574246d416eb3ab70d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -718,20 +718,12 @@ pub fn provide(providers: &mut Providers) {\n         typeck_item_bodies,\n         typeck_tables_of,\n         has_typeck_tables,\n-        closure_type,\n         closure_kind,\n         adt_destructor,\n         ..*providers\n     };\n }\n \n-fn closure_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          def_id: DefId)\n-                          -> ty::PolyFnSig<'tcx> {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n-}\n-\n fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n@@ -844,7 +836,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let Some(decl) = fn_decl {\n-            let fn_sig = tcx.type_of(def_id).fn_sig();\n+            let fn_sig = tcx.fn_sig(def_id);\n \n             check_abi(tcx, span, fn_sig.abi());\n \n@@ -2173,7 +2165,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                           -> ty::TypeAndMut<'tcx>\n     {\n         // extract method return type, which will be &T;\n-        // all LB regions should have been instantiated during method lookup\n         let ret_ty = method.sig.output();\n \n         // method returns &T, but the type as visible to user is T, so deref\n@@ -2580,8 +2571,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n                     }\n-                    ty::TyFnDef(.., f) => {\n-                        let ptr_ty = self.tcx.mk_fn_ptr(f);\n+                    ty::TyFnDef(..) => {\n+                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n                         let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &format!(\"{}\", ptr_ty));\n                     }"}, {"sha": "cbda1227742ca32d5756e27344e204cd02736915", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -177,12 +177,11 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n-                    let method_ty = fcx.tcx.type_of(item.def_id);\n-                    let method_ty = fcx.normalize_associated_types_in(span, &method_ty);\n+                    let sig = fcx.tcx.fn_sig(item.def_id);\n+                    let sig = fcx.normalize_associated_types_in(span, &sig);\n                     let predicates = fcx.tcx.predicates_of(item.def_id)\n                         .instantiate_identity(fcx.tcx);\n                     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n-                    let sig = method_ty.fn_sig();\n                     this.check_fn_or_method(fcx, span, sig, &predicates,\n                                             item.def_id, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n@@ -331,9 +330,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n     fn check_item_fn(&mut self, item: &hir::Item) {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let ty = fcx.tcx.type_of(def_id);\n-            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n-            let sig = item_ty.fn_sig();\n+            let sig = fcx.tcx.fn_sig(def_id);\n+            let sig = fcx.normalize_associated_types_in(item.span, &sig);\n \n             let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n             let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n@@ -461,9 +459,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         let span = method_sig.decl.inputs[0].span;\n \n-        let method_ty = fcx.tcx.type_of(method.def_id);\n-        let fty = fcx.normalize_associated_types_in(span, &method_ty);\n-        let sig = fcx.liberate_late_bound_regions(method.def_id, &fty.fn_sig());\n+        let sig = fcx.tcx.fn_sig(method.def_id);\n+        let sig = fcx.normalize_associated_types_in(span, &sig);\n+        let sig = fcx.liberate_late_bound_regions(method.def_id, &sig);\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n "}, {"sha": "fd6dda5ccf4a72e9c81be10c6bef8beec7c4f7ca", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 82, "deletions": 30, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -97,6 +97,7 @@ pub fn provide(providers: &mut Providers) {\n         type_param_predicates,\n         trait_def,\n         adt_def,\n+        fn_sig,\n         impl_trait_ref,\n         impl_polarity,\n         is_foreign_item,\n@@ -447,6 +448,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n+                if let hir::ForeignItemFn(..) = item.node {\n+                    tcx.fn_sig(def_id);\n+                }\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n@@ -497,6 +501,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n+            if let hir::ItemFn(..) = it.node {\n+                tcx.fn_sig(def_id);\n+            }\n         }\n     }\n }\n@@ -511,6 +518,9 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast:\n         hir::TraitItemKind::Type(_, Some(_)) |\n         hir::TraitItemKind::Method(..) => {\n             tcx.type_of(def_id);\n+            if let hir::TraitItemKind::Method(..) = trait_item.node {\n+                tcx.fn_sig(def_id);\n+            }\n         }\n \n         hir::TraitItemKind::Type(_, None) => {}\n@@ -524,6 +534,9 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: ast::N\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n+    if let hir::ImplItemKind::Method(..) = tcx.hir.expect_impl_item(impl_item_id).node {\n+        tcx.fn_sig(def_id);\n+    }\n }\n \n fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -963,10 +976,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match tcx.hir.get(node_id) {\n         NodeTraitItem(item) => {\n             match item.node {\n-                TraitItemKind::Method(ref sig, _) => {\n-                    let fty = AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl);\n+                TraitItemKind::Method(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, fty)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 TraitItemKind::Const(ref ty, _) |\n                 TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n@@ -978,10 +990,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeImplItem(item) => {\n             match item.node {\n-                ImplItemKind::Method(ref sig, _) => {\n-                    let fty = AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl);\n+                ImplItemKind::Method(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, fty)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n                 ImplItemKind::Type(ref ty) => {\n@@ -1001,10 +1012,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ItemTy(ref t, _) | ItemImpl(.., ref t, _) => {\n                     icx.to_ty(t)\n                 }\n-                ItemFn(ref decl, unsafety, _, abi, _, _) => {\n-                    let tofd = AstConv::ty_of_fn(&icx, unsafety, abi, &decl);\n+                ItemFn(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, tofd)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ItemEnum(..) |\n                 ItemStruct(..) |\n@@ -1029,33 +1039,24 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         NodeForeignItem(foreign_item) => {\n-            let abi = tcx.hir.get_foreign_abi(node_id);\n-\n             match foreign_item.node {\n-                ForeignItemFn(ref fn_decl, _, _) => {\n-                    compute_type_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n+                ForeignItemFn(..) => {\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ForeignItemStatic(ref t, _) => icx.to_ty(t)\n             }\n         }\n \n         NodeStructCtor(&ref def) |\n         NodeVariant(&Spanned { node: hir::Variant_ { data: ref def, .. }, .. }) => {\n-            let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n             match *def {\n-                VariantData::Unit(..) | VariantData::Struct(..) => ty,\n-                VariantData::Tuple(ref fields, _) => {\n-                    let inputs = fields.iter().map(|f| {\n-                        tcx.type_of(tcx.hir.local_def_id(f.id))\n-                    });\n+                VariantData::Unit(..) | VariantData::Struct(..) => {\n+                    tcx.type_of(tcx.hir.get_parent_did(node_id))\n+                }\n+                VariantData::Tuple(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n-                        inputs,\n-                        ty,\n-                        false,\n-                        hir::Unsafety::Normal,\n-                        abi::Abi::Rust\n-                    )))\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n             }\n         }\n@@ -1105,6 +1106,58 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    def_id: DefId)\n+                    -> ty::PolyFnSig<'tcx> {\n+    use rustc::hir::map::*;\n+    use rustc::hir::*;\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+\n+    let icx = ItemCtxt::new(tcx, def_id);\n+\n+    match tcx.hir.get(node_id) {\n+        NodeTraitItem(&hir::TraitItem { node: TraitItemKind::Method(ref sig, _), .. }) |\n+        NodeImplItem(&hir::ImplItem { node: ImplItemKind::Method(ref sig, _), .. }) => {\n+            AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl)\n+        }\n+\n+        NodeItem(&hir::Item { node: ItemFn(ref decl, unsafety, _, abi, _, _), .. }) => {\n+            AstConv::ty_of_fn(&icx, unsafety, abi, decl)\n+        }\n+\n+        NodeForeignItem(&hir::ForeignItem { node: ForeignItemFn(ref fn_decl, _, _), .. }) => {\n+            let abi = tcx.hir.get_foreign_abi(node_id);\n+            compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n+        }\n+\n+        NodeStructCtor(&VariantData::Tuple(ref fields, _)) |\n+        NodeVariant(&Spanned { node: hir::Variant_ {\n+            data: VariantData::Tuple(ref fields, _), ..\n+        }, .. }) => {\n+            let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n+            let inputs = fields.iter().map(|f| {\n+                tcx.type_of(tcx.hir.local_def_id(f.id))\n+            });\n+            ty::Binder(tcx.mk_fn_sig(\n+                inputs,\n+                ty,\n+                false,\n+                hir::Unsafety::Normal,\n+                abi::Abi::Rust\n+            ))\n+        }\n+\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+            tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n+        }\n+\n+        x => {\n+            bug!(\"unexpected sort of node in fn_sig(): {:?}\", x);\n+        }\n+    }\n+}\n+\n fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             def_id: DefId)\n                             -> Option<ty::TraitRef<'tcx>> {\n@@ -1502,12 +1555,12 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n+fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     decl: &hir::FnDecl,\n     abi: abi::Abi)\n-    -> Ty<'tcx>\n+    -> ty::PolyFnSig<'tcx>\n {\n     let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), hir::Unsafety::Unsafe, abi, decl);\n \n@@ -1533,8 +1586,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = Substs::identity_for_item(tcx, def_id);\n-    tcx.mk_fn_def(def_id, substs, fty)\n+    fty\n }\n \n fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "bf5adc8644d516af15cf2cb71c802e7c9d7d28c2", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -4736,4 +4736,5 @@ register_diagnostics! {\n     E0568, // auto-traits can not have predicates,\n     E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n     E0592, // duplicate definitions with name `{}`\n+    E0619, // intrinsic must be a function\n }"}, {"sha": "519e1ca6e5a3c31a34d81c4a47427c6f387cacb1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -198,22 +198,21 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n                 _ => ()\n             }\n-            let substs = tcx.intern_substs(&[]);\n-            let se_ty = tcx.mk_fn_def(main_def_id, substs,\n-                ty::Binder(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n+                tcx.mk_fn_sig(\n                     iter::empty(),\n                     tcx.mk_nil(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust\n-                ))\n-            );\n+                )\n+            ));\n \n             require_same_types(\n                 tcx,\n                 &ObligationCause::new(main_span, main_id, ObligationCauseCode::MainFunctionType),\n                 se_ty,\n-                main_t);\n+                tcx.mk_fn_ptr(tcx.fn_sig(main_def_id)));\n         }\n         _ => {\n             span_bug!(main_span,\n@@ -248,9 +247,8 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => ()\n             }\n \n-            let substs = tcx.intern_substs(&[]);\n-            let se_ty = tcx.mk_fn_def(start_def_id, substs,\n-                ty::Binder(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n+                tcx.mk_fn_sig(\n                     [\n                         tcx.types.isize,\n                         tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n@@ -259,14 +257,14 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust\n-                ))\n-            );\n+                )\n+            ));\n \n             require_same_types(\n                 tcx,\n                 &ObligationCause::new(start_span, start_id, ObligationCauseCode::StartFunctionType),\n                 se_ty,\n-                start_t);\n+                tcx.mk_fn_ptr(tcx.fn_sig(start_def_id)));\n         }\n         _ => {\n             span_bug!(start_span,"}, {"sha": "f4963619370e41ef2b1cc8f6e746b00596f62ace", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 146, "deletions": 248, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -14,11 +14,9 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use middle::resolve_lifetime as rl;\n use rustc::dep_graph::{AssertDepGraphSafe, DepKind};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -61,10 +59,10 @@ pub struct Constraint<'a> {\n ///     }\n ///\n /// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n-/// the def-id and generics of `Foo`.\n-pub struct CurrentItem<'a> {\n+/// the def-id and the start of `Foo`'s inferreds.\n+pub struct CurrentItem {\n     def_id: DefId,\n-    generics: &'a ty::Generics,\n+    inferred_start: InferredIndex,\n }\n \n pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n@@ -91,29 +89,71 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        match item.node {\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.visit_node_helper(item.id);\n+\n+                if let hir::VariantData::Tuple(..) = *struct_def {\n+                    self.visit_node_helper(struct_def.id());\n+                }\n+            }\n+\n+            hir::ItemEnum(ref enum_def, _) => {\n+                self.visit_node_helper(item.id);\n+\n+                for variant in &enum_def.variants {\n+                    if let hir::VariantData::Tuple(..) = variant.node.data {\n+                        self.visit_node_helper(variant.node.data.id());\n+                    }\n+                }\n+            }\n+\n+            hir::ItemFn(..) => {\n+                self.visit_node_helper(item.id);\n+            }\n+\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if let hir::ForeignItemFn(..) = foreign_item.node {\n+                        self.visit_node_helper(foreign_item.id);\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(..) = trait_item.node {\n+            self.visit_node_helper(trait_item.id);\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(..) = impl_item.node {\n+            self.visit_node_helper(impl_item.id);\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn visit_node_helper(&mut self, id: ast::NodeId) {\n         let tcx = self.terms_cx.tcx;\n-        let def_id = tcx.hir.local_def_id(item.id);\n+        let def_id = tcx.hir.local_def_id(id);\n \n         // Encapsulate constructing the constraints into a task we can\n         // reference later. This can go away once the red-green\n         // algorithm is in place.\n         //\n         // See README.md for a detailed discussion\n         // on dep-graph management.\n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => {\n-                let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-                tcx.dep_graph.with_task(dep_node,\n-                                        AssertDepGraphSafe(self),\n-                                        def_id,\n-                                        visit_item_task);\n-            }\n-            _ => {\n-                // Nothing to do here, skip the task.\n-            }\n-        }\n+        let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+        tcx.dep_graph.with_task(dep_node,\n+                                AssertDepGraphSafe(self),\n+                                def_id,\n+                                visit_item_task);\n \n         fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n                                      def_id: DefId)\n@@ -122,197 +162,57 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-/// Is `param_id` a lifetime according to `map`?\n-fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n-    match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true,\n-        _ => false,\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.terms_cx.tcx\n     }\n \n     fn build_constraints_for_item(&mut self, def_id: DefId) {\n         let tcx = self.tcx();\n-        let id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-        let item = tcx.hir.expect_item(id);\n-        debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n+        debug!(\"build_constraints_for_item({})\", tcx.item_path_str(def_id));\n \n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => {\n-                let generics = tcx.generics_of(def_id);\n-                let current_item = &CurrentItem { def_id, generics };\n+        // Skip items with no generics - there's nothing to infer in them.\n+        if tcx.generics_of(def_id).count() == 0 {\n+            return;\n+        }\n \n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let inferred_start = self.terms_cx.inferred_starts[&id];\n+        let current_item = &CurrentItem { def_id, inferred_start };\n+        match tcx.type_of(def_id).sty {\n+            ty::TyAdt(def, _) => {\n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(generics);\n \n-                for field in tcx.adt_def(def_id).all_fields() {\n+                for field in def.all_fields() {\n                     self.add_constraints_from_ty(current_item,\n                                                  tcx.type_of(field.did),\n                                                  self.covariant);\n                 }\n             }\n \n-            hir::ItemTrait(..) |\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {\n-                span_bug!(item.span, \"`build_constraints_for_item` invoked for non-type-def\");\n+            ty::TyFnDef(..) => {\n+                self.add_constraints_from_sig(current_item,\n+                                              tcx.fn_sig(def_id),\n+                                              self.covariant);\n             }\n-        }\n-    }\n-\n-    /// Load the generics for another item, adding a corresponding\n-    /// relation into the dependencies to indicate that the variance\n-    /// for `current` relies on `def_id`.\n-    fn read_generics(&mut self, current: &CurrentItem, def_id: DefId) -> &'tcx ty::Generics {\n-        let generics = self.tcx().generics_of(def_id);\n-        if self.tcx().dep_graph.is_fully_enabled() {\n-            self.dependencies.add(current.def_id, def_id);\n-        }\n-        generics\n-    }\n \n-    fn opt_inferred_index(&self, param_id: ast::NodeId) -> Option<&InferredIndex> {\n-        self.terms_cx.inferred_map.get(&param_id)\n-    }\n-\n-    fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n-        let tcx = self.terms_cx.tcx;\n-        assert!(is_lifetime(&tcx.hir, param_id));\n-        match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::Region::EarlyBound(_, lifetime_decl_id)) => lifetime_decl_id,\n-            Some(_) => bug!(\"should not encounter non early-bound cases\"),\n-\n-            // The lookup should only fail when `param_id` is\n-            // itself a lifetime binding: use it as the decl_id.\n-            None => param_id,\n-        }\n-\n-    }\n-\n-    /// Is `param_id` a type parameter for which we infer variance?\n-    fn is_to_be_inferred(&self, param_id: ast::NodeId) -> bool {\n-        let result = self.terms_cx.inferred_map.contains_key(&param_id);\n-\n-        // To safe-guard against invalid inferred_map constructions,\n-        // double-check if variance is inferred at some use of a type\n-        // parameter (by inspecting parent of its binding declaration\n-        // to see if it is introduced by a type or by a fn/impl).\n-\n-        let check_result = |this: &ConstraintContext| -> bool {\n-            let tcx = this.terms_cx.tcx;\n-            let decl_id = this.find_binding_for_lifetime(param_id);\n-            // Currently only called on lifetimes; double-checking that.\n-            assert!(is_lifetime(&tcx.hir, param_id));\n-            let parent_id = tcx.hir.get_parent(decl_id);\n-            let parent = tcx.hir\n-                .find(parent_id)\n-                .unwrap_or_else(|| bug!(\"tcx.hir missing entry for id: {}\", parent_id));\n-\n-            let is_inferred;\n-            macro_rules! cannot_happen { () => { {\n-                bug!(\"invalid parent: {} for {}\",\n-                     tcx.hir.node_to_string(parent_id),\n-                     tcx.hir.node_to_string(param_id));\n-            } } }\n-\n-            match parent {\n-                hir_map::NodeItem(p) => {\n-                    match p.node {\n-                        hir::ItemTy(..) |\n-                        hir::ItemEnum(..) |\n-                        hir::ItemStruct(..) |\n-                        hir::ItemUnion(..) |\n-                        hir::ItemTrait(..) => is_inferred = true,\n-                        hir::ItemFn(..) => is_inferred = false,\n-                        _ => cannot_happen!(),\n-                    }\n-                }\n-                hir_map::NodeTraitItem(..) => is_inferred = false,\n-                hir_map::NodeImplItem(..) => is_inferred = false,\n-                _ => cannot_happen!(),\n-            }\n-\n-            return is_inferred;\n-        };\n-\n-        assert_eq!(result, check_result(self));\n-\n-        return result;\n-    }\n-\n-    /// Returns a variance term representing the declared variance of the type/region parameter\n-    /// with the given id.\n-    fn declared_variance(&self,\n-                         param_def_id: DefId,\n-                         item_def_id: DefId,\n-                         index: usize)\n-                         -> VarianceTermPtr<'a> {\n-        assert_eq!(param_def_id.krate, item_def_id.krate);\n-\n-        if let Some(param_node_id) = self.tcx().hir.as_local_node_id(param_def_id) {\n-            // Parameter on an item defined within current crate:\n-            // variance not yet inferred, so return a symbolic\n-            // variance.\n-            if let Some(&InferredIndex(index)) = self.opt_inferred_index(param_node_id) {\n-                self.terms_cx.inferred_infos[index].term\n-            } else {\n-                // If there is no inferred entry for a type parameter,\n-                // it must be declared on a (locally defiend) trait -- they don't\n-                // get inferreds because they are always invariant.\n-                if cfg!(debug_assertions) {\n-                    let item_node_id = self.tcx().hir.as_local_node_id(item_def_id).unwrap();\n-                    let item = self.tcx().hir.expect_item(item_node_id);\n-                    let success = match item.node {\n-                        hir::ItemTrait(..) => true,\n-                        _ => false,\n-                    };\n-                    if !success {\n-                        bug!(\"parameter {:?} has no inferred, but declared on non-trait: {:?}\",\n-                             item_def_id,\n-                             item);\n-                    }\n-                }\n-                self.invariant\n+            _ => {\n+                span_bug!(tcx.def_span(def_id),\n+                          \"`build_constraints_for_item` unsupported for this item\");\n             }\n-        } else {\n-            // Parameter on an item defined within another crate:\n-            // variance already inferred, just look it up.\n-            let variances = self.tcx().variances_of(item_def_id);\n-            self.constant_term(variances[index])\n         }\n     }\n \n     fn add_constraint(&mut self,\n-                      InferredIndex(index): InferredIndex,\n+                      current: &CurrentItem,\n+                      index: u32,\n                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraint(index={}, variance={:?})\", index, variance);\n         self.constraints.push(Constraint {\n-            inferred: InferredIndex(index),\n+            inferred: InferredIndex(current.inferred_start.0 + index as usize),\n             variance: variance,\n         });\n     }\n@@ -354,15 +254,26 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n                trait_ref,\n                variance);\n+        self.add_constraints_from_invariant_substs(current, trait_ref.substs, variance);\n+    }\n \n-        let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n+    fn add_constraints_from_invariant_substs(&mut self,\n+                                             current: &CurrentItem,\n+                                             substs: &Substs<'tcx>,\n+                                             variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_invariant_substs: substs={:?} variance={:?}\",\n+               substs,\n+               variance);\n \n-        self.add_constraints_from_substs(current,\n-                                         trait_ref.def_id,\n-                                         &trait_generics.types,\n-                                         &trait_generics.regions,\n-                                         trait_ref.substs,\n-                                         variance);\n+        // Trait are always invariant so we can take advantage of that.\n+        let variance_i = self.invariant(variance);\n+        for ty in substs.types() {\n+            self.add_constraints_from_ty(current, ty, variance_i);\n+        }\n+\n+        for region in substs.regions() {\n+            self.add_constraints_from_region(current, region, variance_i);\n+        }\n     }\n \n     /// Adds constraints appropriate for an instance of `ty` appearing\n@@ -382,8 +293,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // leaf type -- noop\n             }\n \n-            ty::TyClosure(..) |\n-            ty::TyAnon(..) => {\n+            ty::TyFnDef(..) |\n+            ty::TyClosure(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n \n@@ -409,26 +320,15 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let adt_generics = self.read_generics(current, def.did);\n-\n-                self.add_constraints_from_substs(current,\n-                                                 def.did,\n-                                                 &adt_generics.types,\n-                                                 &adt_generics.regions,\n-                                                 substs,\n-                                                 variance);\n+                self.add_constraints_from_substs(current, def.did, substs, variance);\n             }\n \n             ty::TyProjection(ref data) => {\n-                let trait_ref = &data.trait_ref;\n-                let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n-\n-                self.add_constraints_from_substs(current,\n-                                                 trait_ref.def_id,\n-                                                 &trait_generics.types,\n-                                                 &trait_generics.regions,\n-                                                 trait_ref.substs,\n-                                                 variance);\n+                self.add_constraints_from_trait_ref(current, data.trait_ref, variance);\n+            }\n+\n+            ty::TyAnon(_, substs) => {\n+                self.add_constraints_from_invariant_substs(current, substs, variance);\n             }\n \n             ty::TyDynamic(ref data, r) => {\n@@ -447,26 +347,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyParam(ref data) => {\n-                assert_eq!(current.generics.parent, None);\n-                let mut i = data.idx as usize;\n-                if !current.generics.has_self || i > 0 {\n-                    i -= current.generics.regions.len();\n-                }\n-                let def_id = current.generics.types[i].def_id;\n-                let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                match self.terms_cx.inferred_map.get(&node_id) {\n-                    Some(&index) => {\n-                        self.add_constraint(index, variance);\n-                    }\n-                    None => {\n-                        // We do not infer variance for type parameters\n-                        // declared on methods. They will not be present\n-                        // in the inferred_map.\n-                    }\n-                }\n+                self.add_constraint(current, data.idx, variance);\n             }\n \n-            ty::TyFnDef(.., sig) |\n             ty::TyFnPtr(sig) => {\n                 self.add_constraints_from_sig(current, sig, variance);\n             }\n@@ -489,30 +372,52 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn add_constraints_from_substs(&mut self,\n                                    current: &CurrentItem,\n                                    def_id: DefId,\n-                                   type_param_defs: &[ty::TypeParameterDef],\n-                                   region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n                def_id,\n                substs,\n                variance);\n \n-        for p in type_param_defs {\n-            let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n+        // We don't record `inferred_starts` entries for empty generics.\n+        if substs.is_empty() {\n+            return;\n+        }\n+\n+        // Add a corresponding relation into the dependencies to\n+        // indicate that the variance for `current` relies on `def_id`.\n+        if self.tcx().dep_graph.is_fully_enabled() {\n+            self.dependencies.add(current.def_id, def_id);\n+        }\n+\n+        let (local, remote) = if let Some(id) = self.tcx().hir.as_local_node_id(def_id) {\n+            (Some(self.terms_cx.inferred_starts[&id]), None)\n+        } else {\n+            (None, Some(self.tcx().variances_of(def_id)))\n+        };\n+\n+        for (i, k) in substs.iter().enumerate() {\n+            let variance_decl = if let Some(InferredIndex(start)) = local {\n+                // Parameter on an item defined within current crate:\n+                // variance not yet inferred, so return a symbolic\n+                // variance.\n+                self.terms_cx.inferred_terms[start + i]\n+            } else {\n+                // Parameter on an item defined within another crate:\n+                // variance already inferred, just look it up.\n+                self.constant_term(remote.as_ref().unwrap()[i])\n+            };\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            self.add_constraints_from_ty(current, substs_ty, variance_i);\n-        }\n-\n-        for p in region_param_defs {\n-            let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n-            let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = substs.region_for_def(p);\n-            self.add_constraints_from_region(current, substs_r, variance_i);\n+            if let Some(ty) = k.as_type() {\n+                self.add_constraints_from_ty(current, ty, variance_i);\n+            } else if let Some(r) = k.as_region() {\n+                self.add_constraints_from_region(current, r, variance_i);\n+            } else {\n+                bug!();\n+            }\n         }\n     }\n \n@@ -537,21 +442,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                assert_eq!(current.generics.parent, None);\n-                let i = data.index as usize - current.generics.has_self as usize;\n-                let def_id = current.generics.regions[i].def_id;\n-                let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                if self.is_to_be_inferred(node_id) {\n-                    let &index = self.opt_inferred_index(node_id).unwrap();\n-                    self.add_constraint(index, variance);\n-                }\n+                self.add_constraint(current, data.index, variance);\n             }\n \n             ty::ReStatic => {}\n \n             ty::ReLateBound(..) => {\n-                // We do not infer variance for region parameters on\n-                // methods or in fn types.\n+                // Late-bound regions do not get substituted the same\n+                // way early-bound regions do, so we skip them here.\n             }\n \n             ty::ReFree(..) |"}, {"sha": "7a9f35545e2f383defa9c09444aac638c0793c63", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -54,45 +54,63 @@ fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n                             -> Rc<Vec<ty::Variance>> {\n-    let item_id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n-    let item = tcx.hir.expect_item(item_id);\n-    match item.node {\n-        hir::ItemTrait(..) => {\n-            // Traits are always invariant.\n-            let generics = tcx.generics_of(item_def_id);\n-            assert!(generics.parent.is_none());\n-            Rc::new(vec![ty::Variance::Invariant; generics.count()])\n-        }\n+    let id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n+    let unsupported = || {\n+        // Variance not relevant.\n+        span_bug!(tcx.hir.span(id), \"asked to compute variance for wrong kind of item\")\n+    };\n+    match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) |\n+            hir::ItemFn(..) => {}\n \n-        hir::ItemEnum(..) |\n-        hir::ItemStruct(..) |\n-        hir::ItemUnion(..) => {\n-            // Everything else must be inferred.\n+            _ => unsupported()\n+        },\n \n-            // Lacking red/green, we read the variances for all items here\n-            // but ignore the dependencies, then re-synthesize the ones we need.\n-            let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n-            let dep_node = item_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-            tcx.dep_graph.read(dep_node);\n-            for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n-                if dep_def_id.is_local() {\n-                    let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-                    tcx.dep_graph.read(dep_node);\n-                } else {\n-                    let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVariances);\n-                    tcx.dep_graph.read(dep_node);\n-                }\n-            }\n-\n-            crate_map.variances.get(&item_def_id)\n-                               .unwrap_or(&crate_map.empty_variance)\n-                               .clone()\n-        }\n+        hir::map::NodeTraitItem(item) => match item.node {\n+            hir::TraitItemKind::Method(..) => {}\n+\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeImplItem(item) => match item.node {\n+            hir::ImplItemKind::Method(..) => {}\n+\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeForeignItem(item) => match item.node {\n+            hir::ForeignItemFn(..) => {}\n \n-        _ => {\n-            // Variance not relevant.\n-            span_bug!(item.span, \"asked to compute variance for wrong kind of item\")\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeVariant(_) | hir::map::NodeStructCtor(_) => {}\n+\n+        _ => unsupported()\n+    }\n+\n+    // Everything else must be inferred.\n+\n+    // Lacking red/green, we read the variances for all items here\n+    // but ignore the dependencies, then re-synthesize the ones we need.\n+    let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n+    let dep_node = item_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+    tcx.dep_graph.read(dep_node);\n+    for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n+        if dep_def_id.is_local() {\n+            let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+            tcx.dep_graph.read(dep_node);\n+        } else {\n+            let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVariances);\n+            tcx.dep_graph.read(dep_node);\n         }\n     }\n+\n+    crate_map.variances.get(&item_def_id)\n+                       .unwrap_or(&crate_map.empty_variance)\n+                       .clone()\n }\n "}, {"sha": "495eb95419a90876581ef3165507f97373e7c417", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -36,15 +36,18 @@ struct SolveContext<'a, 'tcx: 'a> {\n pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n     let ConstraintContext { terms_cx, dependencies, constraints, .. } = constraints_cx;\n \n-    let solutions = terms_cx.inferred_infos\n-        .iter()\n-        .map(|ii| ii.initial_variance)\n-        .collect();\n+    let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];\n+    for &(id, ref variances) in &terms_cx.lang_items {\n+        let InferredIndex(start) = terms_cx.inferred_starts[&id];\n+        for (i, &variance) in variances.iter().enumerate() {\n+            solutions[start + i] = variance;\n+        }\n+    }\n \n     let mut solutions_cx = SolveContext {\n-        terms_cx: terms_cx,\n-        constraints: constraints,\n-        solutions: solutions,\n+        terms_cx,\n+        constraints,\n+        solutions,\n     };\n     solutions_cx.solve();\n     let variances = solutions_cx.create_map();\n@@ -71,12 +74,9 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 let old_value = self.solutions[inferred];\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n-                    debug!(\"Updating inferred {} (node {}) \\\n+                    debug!(\"Updating inferred {} \\\n                             from {:?} to {:?} due to {:?}\",\n                            inferred,\n-                           self.terms_cx\n-                                   .inferred_infos[inferred]\n-                               .param_id,\n                            old_value,\n                            new_value,\n                            term);\n@@ -89,49 +89,28 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n     }\n \n     fn create_map(&self) -> FxHashMap<DefId, Rc<Vec<ty::Variance>>> {\n-        // Collect all the variances for a particular item and stick\n-        // them into the variance map. We rely on the fact that we\n-        // generate all the inferreds for a particular item\n-        // consecutively (that is, we collect solutions for an item\n-        // until we see a new item id, and we assume (1) the solutions\n-        // are in the same order as the type parameters were declared\n-        // and (2) all solutions or a given item appear before a new\n-        // item id).\n-\n         let tcx = self.terms_cx.tcx;\n \n-        let mut map = FxHashMap();\n-\n         let solutions = &self.solutions;\n-        let inferred_infos = &self.terms_cx.inferred_infos;\n-        let mut index = 0;\n-        let num_inferred = self.terms_cx.num_inferred();\n-        while index < num_inferred {\n-            let item_id = inferred_infos[index].item_id;\n-\n-            let mut item_variances = vec![];\n-\n-            while index < num_inferred && inferred_infos[index].item_id == item_id {\n-                let info = &inferred_infos[index];\n-                let variance = solutions[index];\n-                debug!(\"Index {} Info {} Variance {:?}\",\n-                       index,\n-                       info.index,\n-                       variance);\n-\n-                assert_eq!(item_variances.len(), info.index);\n-                item_variances.push(variance);\n-                index += 1;\n-            }\n+        self.terms_cx.inferred_starts.iter().map(|(&id, &InferredIndex(start))| {\n+            let def_id = tcx.hir.local_def_id(id);\n+            let generics = tcx.generics_of(def_id);\n \n-            debug!(\"item_id={} item_variances={:?}\", item_id, item_variances);\n+            let mut variances = solutions[start..start+generics.count()].to_vec();\n \n-            let item_def_id = tcx.hir.local_def_id(item_id);\n+            debug!(\"id={} variances={:?}\", id, variances);\n \n-            map.insert(item_def_id, Rc::new(item_variances));\n-        }\n+            // Functions can have unused type parameters: make those invariant.\n+            if let ty::TyFnDef(..) = tcx.type_of(def_id).sty {\n+                for variance in &mut variances {\n+                    if *variance == ty::Bivariant {\n+                        *variance = ty::Invariant;\n+                    }\n+                }\n+            }\n \n-        map\n+            (def_id, Rc::new(variances))\n+        }).collect()\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "38457146a9714deebfa958aafa42959bed515e39", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 61, "deletions": 99, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -22,7 +22,6 @@\n use arena::TypedArena;\n use rustc::ty::{self, TyCtxt};\n use std::fmt;\n-use std::rc::Rc;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -63,31 +62,17 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n-    pub empty_variances: Rc<Vec<ty::Variance>>,\n-\n     // For marker types, UnsafeCell, and other lang items where\n     // variance is hardcoded, records the item-id and the hardcoded\n     // variance.\n     pub lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n \n-    // Maps from the node id of a type/generic parameter to the\n-    // corresponding inferred index.\n-    pub inferred_map: NodeMap<InferredIndex>,\n-\n-    // Maps from an InferredIndex to the info for that variable.\n-    pub inferred_infos: Vec<InferredInfo<'a>>,\n-}\n-\n-pub struct InferredInfo<'a> {\n-    pub item_id: ast::NodeId,\n-    pub index: usize,\n-    pub param_id: ast::NodeId,\n-    pub term: VarianceTermPtr<'a>,\n+    // Maps from the node id of an item to the first inferred index\n+    // used for its type & region parameters.\n+    pub inferred_starts: NodeMap<InferredIndex>,\n \n-    // Initial value to use for this parameter when inferring\n-    // variance. For most parameters, this is Bivariant. But for lang\n-    // items and input type parameters on traits, it is different.\n-    pub initial_variance: ty::Variance,\n+    // Maps from an InferredIndex to the term for that variable.\n+    pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n }\n \n pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -96,14 +81,10 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n         arena: arena,\n-        inferred_map: NodeMap(),\n-        inferred_infos: Vec::new(),\n+        inferred_starts: NodeMap(),\n+        inferred_terms: vec![],\n \n         lang_items: lang_items(tcx),\n-\n-        // cache and share the variance struct used for items with\n-        // no type/region parameters\n-        empty_variances: Rc::new(vec![]),\n     };\n \n     // See README.md for a discussion on dep-graph management.\n@@ -135,67 +116,28 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n }\n \n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n-    fn add_inferreds_for_item(&mut self,\n-                              item_id: ast::NodeId,\n-                              generics: &hir::Generics) {\n-        //! Add \"inferreds\" for the generic parameters declared on this\n-        //! item. This has a lot of annoying parameters because we are\n-        //! trying to drive this from the AST, rather than the\n-        //! ty::Generics, so that we can get span info -- but this\n-        //! means we must accommodate syntactic distinctions.\n-        //!\n+    fn add_inferreds_for_item(&mut self, id: ast::NodeId) {\n+        let tcx = self.tcx;\n+        let def_id = tcx.hir.local_def_id(id);\n+        let count = tcx.generics_of(def_id).count();\n \n-        // NB: In the code below for writing the results back into the\n-        // `CrateVariancesMap`, we rely on the fact that all inferreds\n-        // for a particular item are assigned continuous indices.\n-\n-        for (p, i) in generics.lifetimes.iter().zip(0..) {\n-            let id = p.lifetime.id;\n-            self.add_inferred(item_id, i, id);\n-        }\n-\n-        for (p, i) in generics.ty_params.iter().zip(generics.lifetimes.len()..) {\n-            self.add_inferred(item_id, i, p.id);\n+        if count == 0 {\n+            return;\n         }\n-    }\n \n-    fn add_inferred(&mut self, item_id: ast::NodeId, index: usize, param_id: ast::NodeId) {\n-        let inf_index = InferredIndex(self.inferred_infos.len());\n-        let term = self.arena.alloc(InferredTerm(inf_index));\n-        let initial_variance = self.pick_initial_variance(item_id, index);\n-        self.inferred_infos.push(InferredInfo {\n-            item_id: item_id,\n-            index: index,\n-            param_id: param_id,\n-            term: term,\n-            initial_variance: initial_variance,\n-        });\n-        let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n+        // Record the start of this item's inferreds.\n+        let start = self.inferred_terms.len();\n+        let newly_added = self.inferred_starts.insert(id, InferredIndex(start)).is_none();\n         assert!(newly_added);\n \n-        debug!(\"add_inferred(item_path={}, \\\n-                item_id={}, \\\n-                index={}, \\\n-                param_id={}, \\\n-                inf_index={:?}, \\\n-                initial_variance={:?})\",\n-               self.tcx.item_path_str(self.tcx.hir.local_def_id(item_id)),\n-               item_id,\n-               index,\n-               param_id,\n-               inf_index,\n-               initial_variance);\n-    }\n-\n-    fn pick_initial_variance(&self, item_id: ast::NodeId, index: usize) -> ty::Variance {\n-        match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n-            Some(&(_, ref variances)) => variances[index],\n-            None => ty::Bivariant,\n-        }\n-    }\n+        // NB: In the code below for writing the results back into the\n+        // `CrateVariancesMap`, we rely on the fact that all inferreds\n+        // for a particular item are assigned continuous indices.\n \n-    pub fn num_inferred(&self) -> usize {\n-        self.inferred_infos.len()\n+        let arena = self.arena;\n+        self.inferred_terms.extend((start..start+count).map(|i| {\n+            &*arena.alloc(InferredTerm(InferredIndex(i)))\n+        }));\n     }\n }\n \n@@ -205,30 +147,50 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                self.tcx.hir.node_to_string(item.id));\n \n         match item.node {\n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) => {\n-                self.add_inferreds_for_item(item.id, generics);\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.add_inferreds_for_item(item.id);\n+\n+                if let hir::VariantData::Tuple(..) = *struct_def {\n+                    self.add_inferreds_for_item(struct_def.id());\n+                }\n+            }\n+\n+            hir::ItemEnum(ref enum_def, _) => {\n+                self.add_inferreds_for_item(item.id);\n+\n+                for variant in &enum_def.variants {\n+                    if let hir::VariantData::Tuple(..) = variant.node.data {\n+                        self.add_inferreds_for_item(variant.node.data.id());\n+                    }\n+                }\n+            }\n+\n+            hir::ItemFn(..) => {\n+                self.add_inferreds_for_item(item.id);\n             }\n \n-            hir::ItemTrait(..) |\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) |\n-            hir::ItemDefaultImpl(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemTy(..) => {}\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if let hir::ForeignItemFn(..) = foreign_item.node {\n+                        self.add_inferreds_for_item(foreign_item.id);\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(..) = trait_item.node {\n+            self.add_inferreds_for_item(trait_item.id);\n+        }\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(..) = impl_item.node {\n+            self.add_inferreds_for_item(impl_item.id);\n+        }\n     }\n }"}, {"sha": "fa5a999adf1960c00dfb57d52365d19397d25a79", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -149,7 +149,7 @@ pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n }\n \n fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n-    let sig = cx.tcx.type_of(did).fn_sig();\n+    let sig = cx.tcx.fn_sig(did);\n \n     let constness = if cx.tcx.is_const_fn(did) {\n         hir::Constness::Const"}, {"sha": "478e2fc5085d19fe8dba0e3fcc7ea6ac6d30e777", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -1367,7 +1367,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             ty::AssociatedKind::Method => {\n                 let generics = (cx.tcx.generics_of(self.def_id),\n                                 &cx.tcx.predicates_of(self.def_id)).clean(cx);\n-                let sig = cx.tcx.type_of(self.def_id).fn_sig();\n+                let sig = cx.tcx.fn_sig(self.def_id);\n                 let mut decl = (self.def_id, sig).clean(cx);\n \n                 if self.method_has_self_argument {\n@@ -1842,17 +1842,21 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 mutability: mt.mutbl.clean(cx),\n                 type_: box mt.ty.clean(cx),\n             },\n-            ty::TyFnDef(.., sig) |\n-            ty::TyFnPtr(sig) => BareFunction(box BareFunctionDecl {\n-                unsafety: sig.unsafety(),\n-                generics: Generics {\n-                    lifetimes: Vec::new(),\n-                    type_params: Vec::new(),\n-                    where_predicates: Vec::new()\n-                },\n-                decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n-                abi: sig.abi(),\n-            }),\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) => {\n+                let ty = cx.tcx.lift(self).unwrap();\n+                let sig = ty.fn_sig(cx.tcx);\n+                BareFunction(box BareFunctionDecl {\n+                    unsafety: sig.unsafety(),\n+                    generics: Generics {\n+                        lifetimes: Vec::new(),\n+                        type_params: Vec::new(),\n+                        where_predicates: Vec::new()\n+                    },\n+                    decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n+                    abi: sig.abi(),\n+                })\n+            }\n             ty::TyAdt(def, substs) => {\n                 let did = def.did;\n                 let kind = match def.adt_kind() {"}, {"sha": "d62f6b0f1a37140aa870e30cbcc5313533396926", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -38,11 +38,13 @@ pub fn f1_int_uint() {\n pub fn f1_uint_uint() {\n     f1(2u32, 4u32);\n     //~^ ERROR `u32: Foo` is not satisfied\n+    //~| ERROR `u32: Foo` is not satisfied\n }\n \n pub fn f1_uint_int() {\n     f1(2u32, 4i32);\n     //~^ ERROR `u32: Foo` is not satisfied\n+    //~| ERROR `u32: Foo` is not satisfied\n }\n \n pub fn f2_int() {"}, {"sha": "c42d78c323e3ce643d1fff53e2afeec0e130b131", "filename": "src/test/compile-fail/invalid-intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -11,6 +11,6 @@\n #![feature(intrinsics)]\n extern \"rust-intrinsic\" {\n     pub static breakpoint : unsafe extern \"rust-intrinsic\" fn();\n-    //~^ ERROR intrinsic has wrong type\n+    //~^ ERROR intrinsic must be a function\n }\n-fn main() { unsafe { breakpoint(); } }\n\\ No newline at end of file\n+fn main() { unsafe { breakpoint(); } }"}, {"sha": "15375936b898c80de754ba8191984790bda0e5e4", "filename": "src/test/compile-fail/on-unimplemented/multiple-impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -44,12 +44,18 @@ fn main() {\n     //~^ ERROR E0277\n     //~| NOTE trait message\n     //~| NOTE required by\n+    //~| ERROR E0277\n+    //~| NOTE trait message\n     Index::index(&[] as &[i32], Foo(2u32));\n     //~^ ERROR E0277\n     //~| NOTE on impl for Foo\n     //~| NOTE required by\n+    //~| ERROR E0277\n+    //~| NOTE on impl for Foo\n     Index::index(&[] as &[i32], Bar(2u32));\n     //~^ ERROR E0277\n     //~| NOTE on impl for Bar\n     //~| NOTE required by\n+    //~| ERROR E0277\n+    //~| NOTE on impl for Bar\n }"}, {"sha": "66d612baab4e8648b80a6275cf9c318e8aba0988", "filename": "src/test/compile-fail/on-unimplemented/on-impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -33,4 +33,6 @@ fn main() {\n     //~^ ERROR E0277\n     //~| NOTE a usize is required\n     //~| NOTE required by\n+    //~| ERROR E0277\n+    //~| NOTE a usize is required\n }"}, {"sha": "41d204a541b5ad9b4481dd1fe51abff1d3afb359", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check that `T:'a` is contravariant in T.\n-\n-#![feature(rustc_attrs)]\n-\n-#[rustc_variance]\n-trait Foo: 'static { //~ ERROR [o]\n-}\n-\n-#[rustc_variance]\n-trait Bar<T> { //~ ERROR [o, o]\n-    fn do_it(&self)\n-        where T: 'static;\n-}\n-\n-fn main() { }"}, {"sha": "9b88e38e085546feb68ef1435e7aa7a66334b182", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -14,13 +14,11 @@\n // Check that bounds on type parameters (other than `Self`) do not\n // influence variance.\n \n-#[rustc_variance]\n-trait Getter<T> { //~ ERROR [o, o]\n+trait Getter<T> {\n     fn get(&self) -> T;\n }\n \n-#[rustc_variance]\n-trait Setter<T> { //~ ERROR [o, o]\n+trait Setter<T> {\n     fn get(&self, T);\n }\n \n@@ -34,20 +32,6 @@ enum TestEnum<U,T:Setter<U>> { //~ ERROR [*, +]\n     Foo(T)\n }\n \n-#[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR [o, o, o]\n-    fn getter(&self, u: U) -> T;\n-}\n-\n-#[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR [o, o]\n-}\n-\n-#[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR [o, o]\n-    fn getter<T:Getter<U>>(&self);\n-}\n-\n #[rustc_variance]\n struct TestContraStruct<U,T:Setter<U>> { //~ ERROR [*, +]\n     t: T"}, {"sha": "5075dd2ceedc093ba972f70c5d952e6332bdc508", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "patch": "@@ -36,37 +36,14 @@ struct TestIndirect2<A:'static, B:'static> { //~ ERROR [o, o]\n     m: TestMut<B, A>\n }\n \n-#[rustc_variance]\n-trait Getter<A> { //~ ERROR [o, o]\n+trait Getter<A> {\n     fn get(&self) -> A;\n }\n \n-#[rustc_variance]\n-trait Setter<A> { //~ ERROR [o, o]\n-    fn set(&mut self, a: A);\n-}\n-\n-#[rustc_variance]\n-trait GetterSetter<A> { //~ ERROR [o, o]\n-    fn get(&self) -> A;\n+trait Setter<A> {\n     fn set(&mut self, a: A);\n }\n \n-#[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR [o, o]\n-    // Here, the use of `A` in the method bound *does* affect\n-    // variance.  Think of it as if the method requested a dictionary\n-    // for `T:Getter<A>`.  Since this dictionary is an input, it is\n-    // contravariant, and the Getter is covariant w/r/t A, yielding an\n-    // overall contravariant result.\n-    fn do_it<T:Getter<A>>(&self);\n-}\n-\n-#[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR [o, o]\n-    fn do_it<T:Setter<A>>(&self);\n-}\n-\n #[rustc_variance]\n struct TestObject<A, R> { //~ ERROR [o, o]\n     n: Box<Setter<A>+Send>,"}]}