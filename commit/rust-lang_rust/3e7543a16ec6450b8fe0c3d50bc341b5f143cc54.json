{"sha": "3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNzU0M2ExNmVjNjQ1MGI4ZmUwYzNkNTBiYzM0MWI1ZjE0M2NjNTQ=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-12-15T15:23:33Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-12-15T23:31:01Z"}, "message": "WIP: Cross-compilation for Redox target", "tree": {"sha": "6045720352a5a4eaa69986b07fe6459e19c26022", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6045720352a5a4eaa69986b07fe6459e19c26022"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "html_url": "https://github.com/rust-lang/rust/commit/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f86e01462781705798adaccbcc3dceb0ecff239b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f86e01462781705798adaccbcc3dceb0ecff239b", "html_url": "https://github.com/rust-lang/rust/commit/f86e01462781705798adaccbcc3dceb0ecff239b"}], "stats": {"total": 1472, "additions": 1462, "deletions": 10}, "files": [{"sha": "e0763276113f251ae50989f0cb9a0687846141fb", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -36,7 +36,8 @@ fn main() {\n     // targets, which means we have to build the alloc_jemalloc crate\n     // for targets like emscripten, even if we don't use it.\n     if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n-       target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") {\n+       target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") ||\n+       target.contains(\"redox\") {\n         println!(\"cargo:rustc-cfg=dummy_jemalloc\");\n         return;\n     }"}, {"sha": "487e8e8e6ec39b70f27b5d80ed8c198a628df930", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -19,6 +19,7 @@\n             issue = \"27783\")]\n #![feature(allocator)]\n #![feature(staged_api)]\n+#![cfg_attr(target_os = \"redox\", feature(libc))]\n #![cfg_attr(unix, feature(libc))]\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n@@ -71,7 +72,49 @@ pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n     imp::usable_size(size, align)\n }\n \n-#[cfg(unix)]\n+#[cfg(target_os = \"redox\")]\n+mod imp {\n+    extern crate libc;\n+\n+    use core::cmp;\n+    use core::ptr;\n+    use MIN_ALIGN;\n+\n+    pub unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n+        libc::malloc(size as libc::size_t) as *mut u8\n+    }\n+\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n+        } else {\n+            let new_ptr = allocate(size, align);\n+            if !new_ptr.is_null() {\n+                ptr::copy(ptr, new_ptr, cmp::min(size, old_size));\n+                deallocate(ptr, old_size, align);\n+            }\n+            new_ptr\n+        }\n+    }\n+\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8,\n+                                     old_size: usize,\n+                                     _size: usize,\n+                                     _align: usize)\n+                                     -> usize {\n+        old_size\n+    }\n+\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n+        libc::free(ptr as *mut libc::c_void)\n+    }\n+\n+    pub fn usable_size(size: usize, _align: usize) -> usize {\n+        size\n+    }\n+}\n+\n+#[cfg(any(unix))]\n mod imp {\n     extern crate libc;\n "}, {"sha": "0384c6666e3bba965375eab5d582d2f4ad7acfb2", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -23,6 +23,9 @@ compiler_builtins = { path = \"../libcompiler_builtins\" }\n std_unicode = { path = \"../libstd_unicode\" }\n unwind = { path = \"../libunwind\" }\n \n+[replace]\n+\"core:0.0.0\" = { path = \"../libcore\" }\n+\n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n gcc = \"0.3.27\""}, {"sha": "535cb7e136ce4a9c1fef8ecec064bc8ec1e36a85", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -26,7 +26,7 @@ fn main() {\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n     if cfg!(feature = \"backtrace\") && !target.contains(\"apple\") && !target.contains(\"msvc\") &&\n-        !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") {\n+        !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") && !target.contains(\"redox\") {\n         build_libbacktrace(&host, &target);\n     }\n "}, {"sha": "3c9e66a469cd87b58d01b3d2d95d64fdc1d29c29", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -299,6 +299,7 @@\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(zero_one)]\n+#![cfg_attr(target_os = \"redox\", feature(naked_functions))]\n #![cfg_attr(test, feature(update_panic_count))]\n \n // Explicitly import the prelude. The compiler uses this same unstable attribute"}, {"sha": "fce1cb364fa6c92999ce8006e28ae0b1546c8d76", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -10,8 +10,6 @@\n \n #![allow(dead_code, missing_docs, bad_style)]\n \n-pub extern crate syscall;\n-\n use io::{self, ErrorKind};\n \n pub mod args;\n@@ -33,7 +31,9 @@ pub mod process;\n pub mod rand;\n pub mod rwlock;\n pub mod stack_overflow;\n+pub mod start;\n pub mod stdio;\n+pub mod syscall;\n pub mod thread;\n pub mod thread_local;\n pub mod time;"}, {"sha": "3fdf61cfed83c22cfd24c77f9d0b2109e4fd1c49", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -20,10 +20,11 @@ use vec::{IntoIter, Vec};\n \n use self::dns::{Dns, DnsQuery};\n \n-pub extern crate libc as netc;\n pub use self::tcp::{TcpStream, TcpListener};\n pub use self::udp::UdpSocket;\n \n+pub mod netc;\n+\n mod dns;\n mod tcp;\n mod udp;"}, {"sha": "78045c54fb2072dd63cc4df6d2c5107c2b31aa85", "filename": "src/libstd/sys/redox/net/netc.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,47 @@\n+pub type in_addr_t = u32;\n+pub type in_port_t = u16;\n+\n+pub type socklen_t = u32;\n+pub type sa_family_t = u16;\n+\n+pub const AF_INET: sa_family_t = 1;\n+pub const AF_INET6: sa_family_t = 2;\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct in_addr {\n+    pub s_addr: in_addr_t,\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct in6_addr {\n+    pub s6_addr: [u8; 16],\n+    __align: [u32; 0],\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct sockaddr {\n+    pub sa_family: sa_family_t,\n+    pub sa_data: [u8; 14],\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct sockaddr_in {\n+    pub sin_family: sa_family_t,\n+    pub sin_port: in_port_t,\n+    pub sin_addr: in_addr,\n+    pub sin_zero: [u8; 8],\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct sockaddr_in6 {\n+    pub sin6_family: sa_family_t,\n+    pub sin6_port: in_port_t,\n+    pub sin6_flowinfo: u32,\n+    pub sin6_addr: in6_addr,\n+    pub sin6_scope_id: u32,\n+}"}, {"sha": "eb28eca38bcd94a51015d281553d63d75f3b440f", "filename": "src/libstd/sys/redox/rand.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frand.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -9,15 +9,19 @@\n // except according to those terms.\n \n use io;\n-use libc;\n use rand::Rng;\n \n-pub struct OsRng;\n+// FIXME: Use rand:\n+pub struct OsRng {\n+    state: [u64; 2]\n+}\n \n impl OsRng {\n     /// Create a new `OsRng`.\n     pub fn new() -> io::Result<OsRng> {\n-        Ok(OsRng)\n+        Ok(OsRng {\n+            state: [0xBADF00D1, 0xDEADBEEF]\n+        })\n     }\n }\n \n@@ -26,7 +30,20 @@ impl Rng for OsRng {\n         self.next_u64() as u32\n     }\n     fn next_u64(&mut self) -> u64 {\n-        unsafe { libc::random() }\n+        // Store the first and second part.\n+        let mut x = self.state[0];\n+        let y = self.state[1];\n+\n+        // Put the second part into the first slot.\n+        self.state[0] = y;\n+        // Twist the first slot.\n+        x ^= x << 23;\n+        // Update the second slot.\n+        self.state[1] = x ^ y ^ (x >> 17) ^ (y >> 26);\n+\n+        // Generate the final integer.\n+        self.state[1].wrapping_add(y)\n+\n     }\n     fn fill_bytes(&mut self, buf: &mut [u8]) {\n         for chunk in buf.chunks_mut(8) {"}, {"sha": "b689be1cf4d255dcc580333ce4c8514a4466b9ff", "filename": "src/libstd/sys/redox/start.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fstart.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fstart.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstart.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,43 @@\n+use sys::syscall::exit;\n+\n+#[allow(private_no_mangle_fns)]\n+#[no_mangle]\n+#[naked]\n+#[cfg(target_arch = \"x86\")]\n+pub unsafe fn _start() {\n+    asm!(\"push esp\n+        call _start_stack\n+        pop esp\"\n+        :\n+        :\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+    let _ = exit(0);\n+}\n+\n+#[allow(private_no_mangle_fns)]\n+#[no_mangle]\n+#[naked]\n+#[cfg(target_arch = \"x86_64\")]\n+pub unsafe fn _start() {\n+    asm!(\"mov rdi, rsp\n+        and rsp, 0xFFFFFFFFFFFFFFF0\n+        call _start_stack\"\n+        :\n+        :\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+    let _ = exit(0);\n+}\n+\n+#[allow(private_no_mangle_fns)]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn _start_stack(stack: *const usize){\n+    extern \"C\" {\n+        fn main(argc: usize, argv: *const *const u8) -> usize;\n+    }\n+\n+    let argc = *stack as usize;\n+    let argv = stack.offset(1) as *const *const u8;\n+    let _ = exit(main(argc, argv));\n+}"}, {"sha": "939ebf510725dd7456b6e9af26d7311abe421036", "filename": "src/libstd/sys/redox/syscall/call.rs", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,287 @@\n+use super::arch::*;\n+use super::data::{Stat, StatVfs, TimeSpec};\n+use super::error::Result;\n+use super::number::*;\n+\n+use core::mem;\n+\n+/// Set the end of the process's heap\n+///\n+/// When `addr` is `0`, this function will return the current break.\n+///\n+/// When `addr` is nonzero, this function will attempt to set the end of the process's\n+/// heap to `addr` and return the new program break. The new program break should be\n+/// checked by the allocator, it may not be exactly `addr`, as it may be aligned to a page\n+/// boundary.\n+///\n+/// On error, `Err(ENOMEM)` will be returned indicating that no memory is available\n+pub unsafe fn brk(addr: usize) -> Result<usize> {\n+    syscall1(SYS_BRK, addr)\n+}\n+\n+/// Change the process's working directory\n+///\n+/// This function will attempt to set the process's working directory to `path`, which can be\n+/// either a relative, scheme relative, or absolute path.\n+///\n+/// On success, `Ok(0)` will be returned. On error, one of the following errors will be returned.\n+///\n+/// # Errors\n+///\n+/// * `EACCES` - permission is denied for one of the components of `path`, or `path`\n+/// * `EFAULT` - `path` does not point to the process's addressible memory\n+/// * `EIO` - an I/O error occured\n+/// * `ENOENT` - `path` does not exit\n+/// * `ENOTDIR` - `path` is not a directory\n+pub fn chdir(path: &str) -> Result<usize> {\n+    unsafe { syscall2(SYS_CHDIR, path.as_ptr() as usize, path.len()) }\n+}\n+\n+pub fn chmod(path: &str, mode: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_CHMOD, path.as_ptr() as usize, path.len(), mode) }\n+}\n+\n+/// Produce a fork of the current process, or a new process thread\n+pub unsafe fn clone(flags: usize) -> Result<usize> {\n+    syscall1_clobber(SYS_CLONE, flags)\n+}\n+\n+/// Close a file\n+pub fn close(fd: usize) -> Result<usize> {\n+    unsafe { syscall1(SYS_CLOSE, fd) }\n+}\n+\n+/// Get the current system time\n+pub fn clock_gettime(clock: usize, tp: &mut TimeSpec) -> Result<usize> {\n+    unsafe { syscall2(SYS_CLOCK_GETTIME, clock, tp as *mut TimeSpec as usize) }\n+}\n+\n+/// Copy and transform a file descriptor\n+pub fn dup(fd: usize, buf: &[u8]) -> Result<usize> {\n+    unsafe { syscall3(SYS_DUP, fd, buf.as_ptr() as usize, buf.len()) }\n+}\n+\n+/// Replace the current process with a new executable\n+pub fn execve(path: &str, args: &[[usize; 2]]) -> Result<usize> {\n+    unsafe { syscall4(SYS_EXECVE, path.as_ptr() as usize, path.len(), args.as_ptr() as usize, args.len()) }\n+}\n+\n+/// Exit the current process\n+pub fn exit(status: usize) -> Result<usize> {\n+    unsafe { syscall1(SYS_EXIT, status) }\n+}\n+\n+/// Register a file for event-based I/O\n+pub fn fcntl(fd: usize, cmd: usize, arg: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_FCNTL, fd, cmd, arg) }\n+}\n+\n+/// Register a file for event-based I/O\n+pub fn fevent(fd: usize, flags: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_FEVENT, fd, flags) }\n+}\n+\n+/// Map a file into memory\n+pub unsafe fn fmap(fd: usize, offset: usize, size: usize) -> Result<usize> {\n+    syscall3(SYS_FMAP, fd, offset, size)\n+}\n+\n+/// Unmap a memory-mapped file\n+pub unsafe fn funmap(addr: usize) -> Result<usize> {\n+    syscall1(SYS_FUNMAP, addr)\n+}\n+\n+/// Retrieve the canonical path of a file\n+pub fn fpath(fd: usize, buf: &mut [u8]) -> Result<usize> {\n+    unsafe { syscall3(SYS_FPATH, fd, buf.as_mut_ptr() as usize, buf.len()) }\n+}\n+\n+/// Get metadata about a file\n+pub fn fstat(fd: usize, stat: &mut Stat) -> Result<usize> {\n+    unsafe { syscall3(SYS_FSTAT, fd, stat as *mut Stat as usize, mem::size_of::<Stat>()) }\n+}\n+\n+/// Get metadata about a filesystem\n+pub fn fstatvfs(fd: usize, stat: &mut StatVfs) -> Result<usize> {\n+    unsafe { syscall3(SYS_FSTATVFS, fd, stat as *mut StatVfs as usize, mem::size_of::<StatVfs>()) }\n+}\n+\n+/// Sync a file descriptor to its underlying medium\n+pub fn fsync(fd: usize) -> Result<usize> {\n+    unsafe { syscall1(SYS_FSYNC, fd) }\n+}\n+\n+/// Truncate or extend a file to a specified length\n+pub fn ftruncate(fd: usize, len: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_FTRUNCATE, fd, len) }\n+}\n+\n+/// Fast userspace mutex - TODO: Document\n+pub unsafe fn futex(addr: *mut i32, op: usize, val: i32, val2: usize, addr2: *mut i32) -> Result<usize> {\n+    syscall5(SYS_FUTEX, addr as usize, op, (val as isize) as usize, val2, addr2 as usize)\n+}\n+\n+/// Get the current working directory\n+pub fn getcwd(buf: &mut [u8]) -> Result<usize> {\n+    unsafe { syscall2(SYS_GETCWD, buf.as_mut_ptr() as usize, buf.len()) }\n+}\n+\n+/// Get the effective group ID\n+pub fn getegid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETEGID) }\n+}\n+\n+/// Get the effective namespace\n+pub fn getens() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETENS) }\n+}\n+\n+/// Get the effective user ID\n+pub fn geteuid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETEUID) }\n+}\n+\n+/// Get the current group ID\n+pub fn getgid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETGID) }\n+}\n+\n+/// Get the current namespace\n+pub fn getns() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETNS) }\n+}\n+\n+/// Get the current process ID\n+pub fn getpid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETPID) }\n+}\n+\n+/// Get the current user ID\n+pub fn getuid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETUID) }\n+}\n+\n+/// Set the I/O privilege level\n+pub unsafe fn iopl(level: usize) -> Result<usize> {\n+    syscall1(SYS_IOPL, level)\n+}\n+\n+/// Send a signal `sig` to the process identified by `pid`\n+pub fn kill(pid: usize, sig: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_KILL, pid, sig) }\n+}\n+\n+/// Create a link to a file\n+pub unsafe fn link(old: *const u8, new: *const u8) -> Result<usize> {\n+    syscall2(SYS_LINK, old as usize, new as usize)\n+}\n+\n+/// Seek to `offset` bytes in a file descriptor\n+pub fn lseek(fd: usize, offset: isize, whence: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_LSEEK, fd, offset as usize, whence) }\n+}\n+\n+/// Make a new scheme namespace\n+pub fn mkns(schemes: &[[usize; 2]]) -> Result<usize> {\n+    unsafe { syscall2(SYS_MKNS, schemes.as_ptr() as usize, schemes.len()) }\n+}\n+\n+/// Sleep for the time specified in `req`\n+pub fn nanosleep(req: &TimeSpec, rem: &mut TimeSpec) -> Result<usize> {\n+    unsafe { syscall2(SYS_NANOSLEEP, req as *const TimeSpec as usize, rem as *mut TimeSpec as usize) }\n+}\n+\n+/// Open a file\n+pub fn open(path: &str, flags: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_OPEN, path.as_ptr() as usize, path.len(), flags) }\n+}\n+\n+/// Allocate pages, linearly in physical memory\n+pub unsafe fn physalloc(size: usize) -> Result<usize> {\n+    syscall1(SYS_PHYSALLOC, size)\n+}\n+\n+/// Free physically allocated pages\n+pub unsafe fn physfree(physical_address: usize, size: usize) -> Result<usize> {\n+    syscall2(SYS_PHYSFREE, physical_address, size)\n+}\n+\n+/// Map physical memory to virtual memory\n+pub unsafe fn physmap(physical_address: usize, size: usize, flags: usize) -> Result<usize> {\n+    syscall3(SYS_PHYSMAP, physical_address, size, flags)\n+}\n+\n+/// Unmap previously mapped physical memory\n+pub unsafe fn physunmap(virtual_address: usize) -> Result<usize> {\n+    syscall1(SYS_PHYSUNMAP, virtual_address)\n+}\n+\n+/// Create a pair of file descriptors referencing the read and write ends of a pipe\n+pub fn pipe2(fds: &mut [usize; 2], flags: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_PIPE2, fds.as_ptr() as usize, flags) }\n+}\n+\n+/// Read from a file descriptor into a buffer\n+pub fn read(fd: usize, buf: &mut [u8]) -> Result<usize> {\n+    unsafe { syscall3(SYS_READ, fd, buf.as_mut_ptr() as usize, buf.len()) }\n+}\n+\n+/// Remove a directory\n+pub fn rmdir(path: &str) -> Result<usize> {\n+    unsafe { syscall2(SYS_RMDIR, path.as_ptr() as usize, path.len()) }\n+}\n+\n+/// Set the current process group IDs\n+pub fn setregid(rgid: usize, egid: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_SETREGID, rgid, egid) }\n+}\n+\n+/// Make a new scheme namespace\n+pub fn setrens(rns: usize, ens: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_SETRENS, rns, ens) }\n+}\n+\n+/// Set the current process user IDs\n+pub fn setreuid(ruid: usize, euid: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_SETREUID, ruid, euid) }\n+}\n+\n+/// Remove a file\n+pub fn unlink(path: &str) -> Result<usize> {\n+    unsafe { syscall2(SYS_UNLINK, path.as_ptr() as usize, path.len()) }\n+}\n+\n+/// Convert a virtual address to a physical one\n+pub unsafe fn virttophys(virtual_address: usize) -> Result<usize> {\n+    syscall1(SYS_VIRTTOPHYS, virtual_address)\n+}\n+\n+/// Check if a child process has exited or received a signal\n+pub fn waitpid(pid: usize, status: &mut usize, options: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_WAITPID, pid, status as *mut usize as usize, options) }\n+}\n+\n+/// Write a buffer to a file descriptor\n+///\n+/// The kernel will attempt to write the bytes in `buf` to the file descriptor `fd`, returning\n+/// either an `Err`, explained below, or `Ok(count)` where `count` is the number of bytes which\n+/// were written.\n+///\n+/// # Errors\n+///\n+/// * `EAGAIN` - the file descriptor was opened with `O_NONBLOCK` and writing would block\n+/// * `EBADF` - the file descriptor is not valid or is not open for writing\n+/// * `EFAULT` - `buf` does not point to the process's addressible memory\n+/// * `EIO` - an I/O error occured\n+/// * `ENOSPC` - the device containing the file descriptor has no room for data\n+/// * `EPIPE` - the file descriptor refers to a pipe or socket whose reading end is closed\n+pub fn write(fd: usize, buf: &[u8]) -> Result<usize> {\n+    unsafe { syscall3(SYS_WRITE, fd, buf.as_ptr() as usize, buf.len()) }\n+}\n+\n+/// Yield the process's time slice to the kernel\n+///\n+/// This function will return Ok(0) on success\n+pub fn sched_yield() -> Result<usize> {\n+    unsafe { syscall0(SYS_YIELD) }\n+}"}, {"sha": "240690befde1da1e1e1e9ea6df6163309c1fa740", "filename": "src/libstd/sys/redox/syscall/data.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,127 @@\n+use core::ops::{Deref, DerefMut};\n+use core::{mem, slice};\n+\n+#[derive(Copy, Clone, Debug, Default)]\n+pub struct Event {\n+    pub id: usize,\n+    pub flags: usize,\n+    pub data: usize\n+}\n+\n+impl Deref for Event {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self as *const Event as *const u8, mem::size_of::<Event>()) as &[u8]\n+        }\n+    }\n+}\n+\n+impl DerefMut for Event {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self as *mut Event as *mut u8, mem::size_of::<Event>()) as &mut [u8]\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct Packet {\n+    pub id: u64,\n+    pub pid: usize,\n+    pub uid: u32,\n+    pub gid: u32,\n+    pub a: usize,\n+    pub b: usize,\n+    pub c: usize,\n+    pub d: usize\n+}\n+\n+impl Deref for Packet {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self as *const Packet as *const u8, mem::size_of::<Packet>()) as &[u8]\n+        }\n+    }\n+}\n+\n+impl DerefMut for Packet {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self as *mut Packet as *mut u8, mem::size_of::<Packet>()) as &mut [u8]\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct Stat {\n+    pub st_dev: u64,\n+    pub st_ino: u64,\n+    pub st_mode: u16,\n+    pub st_nlink: u32,\n+    pub st_uid: u32,\n+    pub st_gid: u32,\n+    pub st_size: u64,\n+    pub st_blksize: u32,\n+    pub st_blocks: u64,\n+    pub st_mtime: u64,\n+    pub st_mtime_nsec: u32,\n+    pub st_atime: u64,\n+    pub st_atime_nsec: u32,\n+    pub st_ctime: u64,\n+    pub st_ctime_nsec: u32,\n+}\n+\n+impl Deref for Stat {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self as *const Stat as *const u8, mem::size_of::<Stat>()) as &[u8]\n+        }\n+    }\n+}\n+\n+impl DerefMut for Stat {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self as *mut Stat as *mut u8, mem::size_of::<Stat>()) as &mut [u8]\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct StatVfs {\n+    pub f_bsize: u32,\n+    pub f_blocks: u64,\n+    pub f_bfree: u64,\n+    pub f_bavail: u64,\n+    //TODO: More fields https://linux.die.net/man/2/statvfs\n+}\n+\n+impl Deref for StatVfs {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self as *const StatVfs as *const u8, mem::size_of::<StatVfs>()) as &[u8]\n+        }\n+    }\n+}\n+\n+impl DerefMut for StatVfs {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self as *mut StatVfs as *mut u8, mem::size_of::<StatVfs>()) as &mut [u8]\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct TimeSpec {\n+    pub tv_sec: i64,\n+    pub tv_nsec: i32,\n+}"}, {"sha": "7cbcbe98765edc7f67a03d6c166d99fa2e2afc29", "filename": "src/libstd/sys/redox/syscall/error.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,315 @@\n+use core::{fmt, result};\n+\n+#[derive(Eq, PartialEq)]\n+pub struct Error {\n+    pub errno: i32,\n+}\n+\n+pub type Result<T> = result::Result<T, Error>;\n+\n+impl Error {\n+    pub fn new(errno: i32) -> Error {\n+        Error { errno: errno }\n+    }\n+\n+    pub fn mux(result: Result<usize>) -> usize {\n+        match result {\n+            Ok(value) => value,\n+            Err(error) => -error.errno as usize,\n+        }\n+    }\n+\n+    pub fn demux(value: usize) -> Result<usize> {\n+        let errno = -(value as i32);\n+        if errno >= 1 && errno < STR_ERROR.len() as i32 {\n+            Err(Error::new(errno))\n+        } else {\n+            Ok(value)\n+        }\n+    }\n+\n+    pub fn text(&self) -> &str {\n+        if let Some(description) = STR_ERROR.get(self.errno as usize) {\n+            description\n+        } else {\n+            \"Unknown Error\"\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> result::Result<(), fmt::Error> {\n+        f.write_str(self.text())\n+    }\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> result::Result<(), fmt::Error> {\n+        f.write_str(self.text())\n+    }\n+}\n+\n+pub const EPERM: i32 = 1;  /* Operation not permitted */\n+pub const ENOENT: i32 = 2;  /* No such file or directory */\n+pub const ESRCH: i32 = 3;  /* No such process */\n+pub const EINTR: i32 = 4;  /* Interrupted system call */\n+pub const EIO: i32 = 5;  /* I/O error */\n+pub const ENXIO: i32 = 6;  /* No such device or address */\n+pub const E2BIG: i32 = 7;  /* Argument list too long */\n+pub const ENOEXEC: i32 = 8;  /* Exec format error */\n+pub const EBADF: i32 = 9;  /* Bad file number */\n+pub const ECHILD: i32 = 10;  /* No child processes */\n+pub const EAGAIN: i32 = 11;  /* Try again */\n+pub const ENOMEM: i32 = 12;  /* Out of memory */\n+pub const EACCES: i32 = 13;  /* Permission denied */\n+pub const EFAULT: i32 = 14;  /* Bad address */\n+pub const ENOTBLK: i32 = 15;  /* Block device required */\n+pub const EBUSY: i32 = 16;  /* Device or resource busy */\n+pub const EEXIST: i32 = 17;  /* File exists */\n+pub const EXDEV: i32 = 18;  /* Cross-device link */\n+pub const ENODEV: i32 = 19;  /* No such device */\n+pub const ENOTDIR: i32 = 20;  /* Not a directory */\n+pub const EISDIR: i32 = 21;  /* Is a directory */\n+pub const EINVAL: i32 = 22;  /* Invalid argument */\n+pub const ENFILE: i32 = 23;  /* File table overflow */\n+pub const EMFILE: i32 = 24;  /* Too many open files */\n+pub const ENOTTY: i32 = 25;  /* Not a typewriter */\n+pub const ETXTBSY: i32 = 26;  /* Text file busy */\n+pub const EFBIG: i32 = 27;  /* File too large */\n+pub const ENOSPC: i32 = 28;  /* No space left on device */\n+pub const ESPIPE: i32 = 29;  /* Illegal seek */\n+pub const EROFS: i32 = 30;  /* Read-only file system */\n+pub const EMLINK: i32 = 31;  /* Too many links */\n+pub const EPIPE: i32 = 32;  /* Broken pipe */\n+pub const EDOM: i32 = 33;  /* Math argument out of domain of func */\n+pub const ERANGE: i32 = 34;  /* Math result not representable */\n+pub const EDEADLK: i32 = 35;  /* Resource deadlock would occur */\n+pub const ENAMETOOLONG: i32 = 36;  /* File name too long */\n+pub const ENOLCK: i32 = 37;  /* No record locks available */\n+pub const ENOSYS: i32 = 38;  /* Function not implemented */\n+pub const ENOTEMPTY: i32 = 39;  /* Directory not empty */\n+pub const ELOOP: i32 = 40;  /* Too many symbolic links encountered */\n+pub const EWOULDBLOCK: i32 = 41;  /* Operation would block */\n+pub const ENOMSG: i32 = 42;  /* No message of desired type */\n+pub const EIDRM: i32 = 43;  /* Identifier removed */\n+pub const ECHRNG: i32 = 44;  /* Channel number out of range */\n+pub const EL2NSYNC: i32 = 45;  /* Level 2 not synchronized */\n+pub const EL3HLT: i32 = 46;  /* Level 3 halted */\n+pub const EL3RST: i32 = 47;  /* Level 3 reset */\n+pub const ELNRNG: i32 = 48;  /* Link number out of range */\n+pub const EUNATCH: i32 = 49;  /* Protocol driver not attached */\n+pub const ENOCSI: i32 = 50;  /* No CSI structure available */\n+pub const EL2HLT: i32 = 51;  /* Level 2 halted */\n+pub const EBADE: i32 = 52;  /* Invalid exchange */\n+pub const EBADR: i32 = 53;  /* Invalid request descriptor */\n+pub const EXFULL: i32 = 54;  /* Exchange full */\n+pub const ENOANO: i32 = 55;  /* No anode */\n+pub const EBADRQC: i32 = 56;  /* Invalid request code */\n+pub const EBADSLT: i32 = 57;  /* Invalid slot */\n+pub const EDEADLOCK: i32 = 58; /* Resource deadlock would occur */\n+pub const EBFONT: i32 = 59;  /* Bad font file format */\n+pub const ENOSTR: i32 = 60;  /* Device not a stream */\n+pub const ENODATA: i32 = 61;  /* No data available */\n+pub const ETIME: i32 = 62;  /* Timer expired */\n+pub const ENOSR: i32 = 63;  /* Out of streams resources */\n+pub const ENONET: i32 = 64;  /* Machine is not on the network */\n+pub const ENOPKG: i32 = 65;  /* Package not installed */\n+pub const EREMOTE: i32 = 66;  /* Object is remote */\n+pub const ENOLINK: i32 = 67;  /* Link has been severed */\n+pub const EADV: i32 = 68;  /* Advertise error */\n+pub const ESRMNT: i32 = 69;  /* Srmount error */\n+pub const ECOMM: i32 = 70;  /* Communication error on send */\n+pub const EPROTO: i32 = 71;  /* Protocol error */\n+pub const EMULTIHOP: i32 = 72;  /* Multihop attempted */\n+pub const EDOTDOT: i32 = 73;  /* RFS specific error */\n+pub const EBADMSG: i32 = 74;  /* Not a data message */\n+pub const EOVERFLOW: i32 = 75;  /* Value too large for defined data type */\n+pub const ENOTUNIQ: i32 = 76;  /* Name not unique on network */\n+pub const EBADFD: i32 = 77;  /* File descriptor in bad state */\n+pub const EREMCHG: i32 = 78;  /* Remote address changed */\n+pub const ELIBACC: i32 = 79;  /* Can not access a needed shared library */\n+pub const ELIBBAD: i32 = 80;  /* Accessing a corrupted shared library */\n+pub const ELIBSCN: i32 = 81;  /* .lib section in a.out corrupted */\n+pub const ELIBMAX: i32 = 82;  /* Attempting to link in too many shared libraries */\n+pub const ELIBEXEC: i32 = 83;  /* Cannot exec a shared library directly */\n+pub const EILSEQ: i32 = 84;  /* Illegal byte sequence */\n+pub const ERESTART: i32 = 85;  /* Interrupted system call should be restarted */\n+pub const ESTRPIPE: i32 = 86;  /* Streams pipe error */\n+pub const EUSERS: i32 = 87;  /* Too many users */\n+pub const ENOTSOCK: i32 = 88;  /* Socket operation on non-socket */\n+pub const EDESTADDRREQ: i32 = 89;  /* Destination address required */\n+pub const EMSGSIZE: i32 = 90;  /* Message too long */\n+pub const EPROTOTYPE: i32 = 91;  /* Protocol wrong type for socket */\n+pub const ENOPROTOOPT: i32 = 92;  /* Protocol not available */\n+pub const EPROTONOSUPPORT: i32 = 93;  /* Protocol not supported */\n+pub const ESOCKTNOSUPPORT: i32 = 94;  /* Socket type not supported */\n+pub const EOPNOTSUPP: i32 = 95;  /* Operation not supported on transport endpoint */\n+pub const EPFNOSUPPORT: i32 = 96;  /* Protocol family not supported */\n+pub const EAFNOSUPPORT: i32 = 97;  /* Address family not supported by protocol */\n+pub const EADDRINUSE: i32 = 98;  /* Address already in use */\n+pub const EADDRNOTAVAIL: i32 = 99;  /* Cannot assign requested address */\n+pub const ENETDOWN: i32 = 100; /* Network is down */\n+pub const ENETUNREACH: i32 = 101; /* Network is unreachable */\n+pub const ENETRESET: i32 = 102; /* Network dropped connection because of reset */\n+pub const ECONNABORTED: i32 = 103; /* Software caused connection abort */\n+pub const ECONNRESET: i32 = 104; /* Connection reset by peer */\n+pub const ENOBUFS: i32 = 105; /* No buffer space available */\n+pub const EISCONN: i32 = 106; /* Transport endpoint is already connected */\n+pub const ENOTCONN: i32 = 107; /* Transport endpoint is not connected */\n+pub const ESHUTDOWN: i32 = 108; /* Cannot send after transport endpoint shutdown */\n+pub const ETOOMANYREFS: i32 = 109; /* Too many references: cannot splice */\n+pub const ETIMEDOUT: i32 = 110; /* Connection timed out */\n+pub const ECONNREFUSED: i32 = 111; /* Connection refused */\n+pub const EHOSTDOWN: i32 = 112; /* Host is down */\n+pub const EHOSTUNREACH: i32 = 113; /* No route to host */\n+pub const EALREADY: i32 = 114; /* Operation already in progress */\n+pub const EINPROGRESS: i32 = 115; /* Operation now in progress */\n+pub const ESTALE: i32 = 116; /* Stale NFS file handle */\n+pub const EUCLEAN: i32 = 117; /* Structure needs cleaning */\n+pub const ENOTNAM: i32 = 118; /* Not a XENIX named type file */\n+pub const ENAVAIL: i32 = 119; /* No XENIX semaphores available */\n+pub const EISNAM: i32 = 120; /* Is a named type file */\n+pub const EREMOTEIO: i32 = 121; /* Remote I/O error */\n+pub const EDQUOT: i32 = 122; /* Quota exceeded */\n+pub const ENOMEDIUM: i32 = 123; /* No medium found */\n+pub const EMEDIUMTYPE: i32 = 124; /* Wrong medium type */\n+pub const ECANCELED: i32 = 125; /* Operation Canceled */\n+pub const ENOKEY: i32 = 126; /* Required key not available */\n+pub const EKEYEXPIRED: i32 = 127; /* Key has expired */\n+pub const EKEYREVOKED: i32 = 128; /* Key has been revoked */\n+pub const EKEYREJECTED: i32 = 129; /* Key was rejected by service */\n+pub const EOWNERDEAD: i32 = 130; /* Owner died */\n+pub const ENOTRECOVERABLE: i32 = 131; /* State not recoverable */\n+\n+pub static STR_ERROR: [&'static str; 132] = [\"Success\",\n+                                             \"Operation not permitted\",\n+                                             \"No such file or directory\",\n+                                             \"No such process\",\n+                                             \"Interrupted system call\",\n+                                             \"I/O error\",\n+                                             \"No such device or address\",\n+                                             \"Argument list too long\",\n+                                             \"Exec format error\",\n+                                             \"Bad file number\",\n+                                             \"No child processes\",\n+                                             \"Try again\",\n+                                             \"Out of memory\",\n+                                             \"Permission denied\",\n+                                             \"Bad address\",\n+                                             \"Block device required\",\n+                                             \"Device or resource busy\",\n+                                             \"File exists\",\n+                                             \"Cross-device link\",\n+                                             \"No such device\",\n+                                             \"Not a directory\",\n+                                             \"Is a directory\",\n+                                             \"Invalid argument\",\n+                                             \"File table overflow\",\n+                                             \"Too many open files\",\n+                                             \"Not a typewriter\",\n+                                             \"Text file busy\",\n+                                             \"File too large\",\n+                                             \"No space left on device\",\n+                                             \"Illegal seek\",\n+                                             \"Read-only file system\",\n+                                             \"Too many links\",\n+                                             \"Broken pipe\",\n+                                             \"Math argument out of domain of func\",\n+                                             \"Math result not representable\",\n+                                             \"Resource deadlock would occur\",\n+                                             \"File name too long\",\n+                                             \"No record locks available\",\n+                                             \"Function not implemented\",\n+                                             \"Directory not empty\",\n+                                             \"Too many symbolic links encountered\",\n+                                             \"Operation would block\",\n+                                             \"No message of desired type\",\n+                                             \"Identifier removed\",\n+                                             \"Channel number out of range\",\n+                                             \"Level 2 not synchronized\",\n+                                             \"Level 3 halted\",\n+                                             \"Level 3 reset\",\n+                                             \"Link number out of range\",\n+                                             \"Protocol driver not attached\",\n+                                             \"No CSI structure available\",\n+                                             \"Level 2 halted\",\n+                                             \"Invalid exchange\",\n+                                             \"Invalid request descriptor\",\n+                                             \"Exchange full\",\n+                                             \"No anode\",\n+                                             \"Invalid request code\",\n+                                             \"Invalid slot\",\n+                                             \"Resource deadlock would occur\",\n+                                             \"Bad font file format\",\n+                                             \"Device not a stream\",\n+                                             \"No data available\",\n+                                             \"Timer expired\",\n+                                             \"Out of streams resources\",\n+                                             \"Machine is not on the network\",\n+                                             \"Package not installed\",\n+                                             \"Object is remote\",\n+                                             \"Link has been severed\",\n+                                             \"Advertise error\",\n+                                             \"Srmount error\",\n+                                             \"Communication error on send\",\n+                                             \"Protocol error\",\n+                                             \"Multihop attempted\",\n+                                             \"RFS specific error\",\n+                                             \"Not a data message\",\n+                                             \"Value too large for defined data type\",\n+                                             \"Name not unique on network\",\n+                                             \"File descriptor in bad state\",\n+                                             \"Remote address changed\",\n+                                             \"Can not access a needed shared library\",\n+                                             \"Accessing a corrupted shared library\",\n+                                             \".lib section in a.out corrupted\",\n+                                             \"Attempting to link in too many shared libraries\",\n+                                             \"Cannot exec a shared library directly\",\n+                                             \"Illegal byte sequence\",\n+                                             \"Interrupted system call should be restarted\",\n+                                             \"Streams pipe error\",\n+                                             \"Too many users\",\n+                                             \"Socket operation on non-socket\",\n+                                             \"Destination address required\",\n+                                             \"Message too long\",\n+                                             \"Protocol wrong type for socket\",\n+                                             \"Protocol not available\",\n+                                             \"Protocol not supported\",\n+                                             \"Socket type not supported\",\n+                                             \"Operation not supported on transport endpoint\",\n+                                             \"Protocol family not supported\",\n+                                             \"Address family not supported by protocol\",\n+                                             \"Address already in use\",\n+                                             \"Cannot assign requested address\",\n+                                             \"Network is down\",\n+                                             \"Network is unreachable\",\n+                                             \"Network dropped connection because of reset\",\n+                                             \"Software caused connection abort\",\n+                                             \"Connection reset by peer\",\n+                                             \"No buffer space available\",\n+                                             \"Transport endpoint is already connected\",\n+                                             \"Transport endpoint is not connected\",\n+                                             \"Cannot send after transport endpoint shutdown\",\n+                                             \"Too many references: cannot splice\",\n+                                             \"Connection timed out\",\n+                                             \"Connection refused\",\n+                                             \"Host is down\",\n+                                             \"No route to host\",\n+                                             \"Operation already in progress\",\n+                                             \"Operation now in progress\",\n+                                             \"Stale NFS file handle\",\n+                                             \"Structure needs cleaning\",\n+                                             \"Not a XENIX named type file\",\n+                                             \"No XENIX semaphores available\",\n+                                             \"Is a named type file\",\n+                                             \"Remote I/O error\",\n+                                             \"Quota exceeded\",\n+                                             \"No medium found\",\n+                                             \"Wrong medium type\",\n+                                             \"Operation Canceled\",\n+                                             \"Required key not available\",\n+                                             \"Key has expired\",\n+                                             \"Key has been revoked\",\n+                                             \"Key was rejected by service\",\n+                                             \"Owner died\",\n+                                             \"State not recoverable\"];"}, {"sha": "97ff8e2d79ae77fa76eb75b64d7796f2c1d1329e", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,84 @@\n+pub const CLONE_VM: usize = 0x100;\n+pub const CLONE_FS: usize = 0x200;\n+pub const CLONE_FILES: usize = 0x400;\n+pub const CLONE_VFORK: usize = 0x4000;\n+\n+pub const CLOCK_REALTIME: usize = 1;\n+pub const CLOCK_MONOTONIC: usize = 4;\n+\n+pub const EVENT_NONE: usize = 0;\n+pub const EVENT_READ: usize = 1;\n+pub const EVENT_WRITE: usize = 2;\n+\n+pub const F_GETFL: usize = 1;\n+pub const F_SETFL: usize = 2;\n+\n+pub const FUTEX_WAIT: usize = 0;\n+pub const FUTEX_WAKE: usize = 1;\n+pub const FUTEX_REQUEUE: usize = 2;\n+\n+pub const MAP_WRITE: usize = 1;\n+pub const MAP_WRITE_COMBINE: usize = 2;\n+\n+pub const MODE_TYPE: u16 = 0xF000;\n+pub const MODE_DIR: u16 = 0x4000;\n+pub const MODE_FILE: u16 = 0x8000;\n+\n+pub const MODE_PERM: u16 = 0x0FFF;\n+pub const MODE_SETUID: u16 = 0o4000;\n+pub const MODE_SETGID: u16 = 0o2000;\n+\n+pub const O_RDONLY: usize =     0x0001_0000;\n+pub const O_WRONLY: usize =     0x0002_0000;\n+pub const O_RDWR: usize =       0x0003_0000;\n+pub const O_NONBLOCK: usize =   0x0004_0000;\n+pub const O_APPEND: usize =     0x0008_0000;\n+pub const O_SHLOCK: usize =     0x0010_0000;\n+pub const O_EXLOCK: usize =     0x0020_0000;\n+pub const O_ASYNC: usize =      0x0040_0000;\n+pub const O_FSYNC: usize =      0x0080_0000;\n+pub const O_CLOEXEC: usize =    0x0100_0000;\n+pub const O_CREAT: usize =      0x0200_0000;\n+pub const O_TRUNC: usize =      0x0400_0000;\n+pub const O_EXCL: usize =       0x0800_0000;\n+pub const O_DIRECTORY: usize =  0x1000_0000;\n+pub const O_STAT: usize =       0x2000_0000;\n+pub const O_ACCMODE: usize =    O_RDONLY | O_WRONLY | O_RDWR;\n+\n+pub const SEEK_SET: usize = 0;\n+pub const SEEK_CUR: usize = 1;\n+pub const SEEK_END: usize = 2;\n+\n+pub const SIGHUP: usize =   1;\n+pub const SIGINT: usize =   2;\n+pub const SIGQUIT: usize =  3;\n+pub const SIGILL: usize =   4;\n+pub const SIGTRAP: usize =  5;\n+pub const SIGABRT: usize =  6;\n+pub const SIGBUS: usize =   7;\n+pub const SIGFPE: usize =   8;\n+pub const SIGKILL: usize =  9;\n+pub const SIGUSR1: usize =  10;\n+pub const SIGSEGV: usize =  11;\n+pub const SIGUSR2: usize =  12;\n+pub const SIGPIPE: usize =  13;\n+pub const SIGALRM: usize =  14;\n+pub const SIGTERM: usize =  15;\n+pub const SIGSTKFLT: usize= 16;\n+pub const SIGCHLD: usize =  17;\n+pub const SIGCONT: usize =  18;\n+pub const SIGSTOP: usize =  19;\n+pub const SIGTSTP: usize =  20;\n+pub const SIGTTIN: usize =  21;\n+pub const SIGTTOU: usize =  22;\n+pub const SIGURG: usize =   23;\n+pub const SIGXCPU: usize =  24;\n+pub const SIGXFSZ: usize =  25;\n+pub const SIGVTALRM: usize= 26;\n+pub const SIGPROF: usize =  27;\n+pub const SIGWINCH: usize = 28;\n+pub const SIGIO: usize =    29;\n+pub const SIGPWR: usize =   30;\n+pub const SIGSYS: usize =   31;\n+\n+pub const WNOHANG: usize = 1;"}, {"sha": "77f98d5b36bf45fe14bcc1feb1bad094aaff8c51", "filename": "src/libstd/sys/redox/syscall/mod.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,33 @@\n+pub use self::arch::*;\n+pub use self::call::*;\n+pub use self::data::*;\n+pub use self::error::*;\n+pub use self::flag::*;\n+pub use self::number::*;\n+pub use self::scheme::*;\n+\n+#[cfg(target_arch = \"x86\")]\n+#[path=\"x86.rs\"]\n+mod arch;\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[path=\"x86_64.rs\"]\n+mod arch;\n+\n+/// Function definitions\n+pub mod call;\n+\n+/// Complex structures that are used for some system calls\n+pub mod data;\n+\n+/// All errors that can be generated by a system call\n+pub mod error;\n+\n+/// Flags used as an argument to many system calls\n+pub mod flag;\n+\n+/// Call numbers used by each system call\n+pub mod number;\n+\n+/// A trait useful for scheme handlers\n+pub mod scheme;"}, {"sha": "719c8af218fd86766c9fd6e497a67e789ea16f8b", "filename": "src/libstd/sys/redox/syscall/number.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,63 @@\n+pub const SYS_CLASS: usize =    0xF000_0000;\n+pub const SYS_CLASS_PATH: usize=0x1000_0000;\n+pub const SYS_CLASS_FILE: usize=0x2000_0000;\n+\n+pub const SYS_ARG: usize =      0x0F00_0000;\n+pub const SYS_ARG_SLICE: usize =0x0100_0000;\n+pub const SYS_ARG_MSLICE: usize=0x0200_0000;\n+pub const SYS_ARG_PATH: usize = 0x0300_0000;\n+\n+pub const SYS_RET: usize =      0x00F0_0000;\n+pub const SYS_RET_FILE: usize = 0x0010_0000;\n+\n+pub const SYS_LINK: usize =     SYS_CLASS_PATH | SYS_ARG_PATH | 9;\n+pub const SYS_OPEN: usize =     SYS_CLASS_PATH | SYS_RET_FILE | 5;\n+pub const SYS_CHMOD: usize =    SYS_CLASS_PATH | 15;\n+pub const SYS_RMDIR: usize =    SYS_CLASS_PATH | 84;\n+pub const SYS_UNLINK: usize =   SYS_CLASS_PATH | 10;\n+\n+pub const SYS_CLOSE: usize =    SYS_CLASS_FILE | 6;\n+pub const SYS_DUP: usize =      SYS_CLASS_FILE | SYS_RET_FILE | 41;\n+pub const SYS_READ: usize =     SYS_CLASS_FILE | SYS_ARG_MSLICE | 3;\n+pub const SYS_WRITE: usize =    SYS_CLASS_FILE | SYS_ARG_SLICE | 4;\n+pub const SYS_LSEEK: usize =    SYS_CLASS_FILE | 19;\n+pub const SYS_FCNTL: usize =    SYS_CLASS_FILE | 55;\n+pub const SYS_FEVENT: usize =   SYS_CLASS_FILE | 927;\n+pub const SYS_FMAP: usize =     SYS_CLASS_FILE | 90;\n+pub const SYS_FUNMAP: usize =   SYS_CLASS_FILE | 91;\n+pub const SYS_FPATH: usize =    SYS_CLASS_FILE | SYS_ARG_MSLICE | 928;\n+pub const SYS_FSTAT: usize =    SYS_CLASS_FILE | SYS_ARG_MSLICE | 28;\n+pub const SYS_FSTATVFS: usize = SYS_CLASS_FILE | SYS_ARG_MSLICE | 100;\n+pub const SYS_FSYNC: usize =    SYS_CLASS_FILE | 118;\n+pub const SYS_FTRUNCATE: usize =SYS_CLASS_FILE | 93;\n+\n+pub const SYS_BRK: usize =      45;\n+pub const SYS_CHDIR: usize =    12;\n+pub const SYS_CLOCK_GETTIME: usize = 265;\n+pub const SYS_CLONE: usize =    120;\n+pub const SYS_EXECVE: usize =   11;\n+pub const SYS_EXIT: usize =     1;\n+pub const SYS_FUTEX: usize =    240;\n+pub const SYS_GETCWD: usize =   183;\n+pub const SYS_GETEGID: usize =  202;\n+pub const SYS_GETENS: usize =   951;\n+pub const SYS_GETEUID: usize =  201;\n+pub const SYS_GETGID: usize =   200;\n+pub const SYS_GETNS: usize =    950;\n+pub const SYS_GETPID: usize =   20;\n+pub const SYS_GETUID: usize =   199;\n+pub const SYS_IOPL: usize =     110;\n+pub const SYS_KILL: usize =     37;\n+pub const SYS_MKNS: usize =     984;\n+pub const SYS_NANOSLEEP: usize =162;\n+pub const SYS_PHYSALLOC: usize =945;\n+pub const SYS_PHYSFREE: usize = 946;\n+pub const SYS_PHYSMAP: usize =  947;\n+pub const SYS_PHYSUNMAP: usize =948;\n+pub const SYS_VIRTTOPHYS: usize=949;\n+pub const SYS_PIPE2: usize =    331;\n+pub const SYS_SETREGID: usize = 204;\n+pub const SYS_SETRENS: usize =  952;\n+pub const SYS_SETREUID: usize = 203;\n+pub const SYS_WAITPID: usize =  7;\n+pub const SYS_YIELD: usize =    158;"}, {"sha": "d322f0b5a9c8c660a0c2401612c2cc56eb585898", "filename": "src/libstd/sys/redox/syscall/scheme.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fscheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fscheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fscheme.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,232 @@\n+use core::{mem, slice};\n+\n+use super::*;\n+\n+pub trait Scheme {\n+    fn handle(&self, packet: &mut Packet) {\n+        packet.a = Error::mux(match packet.a {\n+            SYS_OPEN => self.open(unsafe { slice::from_raw_parts(packet.b as *const u8, packet.c) }, packet.d, packet.uid, packet.gid),\n+            SYS_CHMOD => self.chmod(unsafe { slice::from_raw_parts(packet.b as *const u8, packet.c) }, packet.d as u16, packet.uid, packet.gid),\n+            SYS_RMDIR => self.rmdir(unsafe { slice::from_raw_parts(packet.b as *const u8, packet.c) }, packet.uid, packet.gid),\n+            SYS_UNLINK => self.unlink(unsafe { slice::from_raw_parts(packet.b as *const u8, packet.c) }, packet.uid, packet.gid),\n+\n+            SYS_DUP => self.dup(packet.b, unsafe { slice::from_raw_parts(packet.c as *const u8, packet.d) }),\n+            SYS_READ => self.read(packet.b, unsafe { slice::from_raw_parts_mut(packet.c as *mut u8, packet.d) }),\n+            SYS_WRITE => self.write(packet.b, unsafe { slice::from_raw_parts(packet.c as *const u8, packet.d) }),\n+            SYS_LSEEK => self.seek(packet.b, packet.c, packet.d),\n+            SYS_FCNTL => self.fcntl(packet.b, packet.c, packet.d),\n+            SYS_FEVENT => self.fevent(packet.b, packet.c),\n+            SYS_FMAP => self.fmap(packet.b, packet.c, packet.d),\n+            SYS_FPATH => self.fpath(packet.b, unsafe { slice::from_raw_parts_mut(packet.c as *mut u8, packet.d) }),\n+            SYS_FSTAT => if packet.d >= mem::size_of::<Stat>() { self.fstat(packet.b, unsafe { &mut *(packet.c as *mut Stat) }) } else { Err(Error::new(EFAULT)) },\n+            SYS_FSTATVFS => if packet.d >= mem::size_of::<StatVfs>() { self.fstatvfs(packet.b, unsafe { &mut *(packet.c as *mut StatVfs) }) } else { Err(Error::new(EFAULT)) },\n+            SYS_FSYNC => self.fsync(packet.b),\n+            SYS_FTRUNCATE => self.ftruncate(packet.b, packet.c),\n+            SYS_CLOSE => self.close(packet.b),\n+\n+            _ => Err(Error::new(ENOSYS))\n+        });\n+    }\n+\n+    /* Scheme operations */\n+\n+    #[allow(unused_variables)]\n+    fn open(&self, path: &[u8], flags: usize, uid: u32, gid: u32) -> Result<usize> {\n+        Err(Error::new(ENOENT))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn chmod(&self, path: &[u8], mode: u16, uid: u32, gid: u32) -> Result<usize> {\n+        Err(Error::new(ENOENT))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn rmdir(&self, path: &[u8], uid: u32, gid: u32) -> Result<usize> {\n+        Err(Error::new(ENOENT))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn unlink(&self, path: &[u8], uid: u32, gid: u32) -> Result<usize> {\n+        Err(Error::new(ENOENT))\n+    }\n+\n+    /* Resource operations */\n+    #[allow(unused_variables)]\n+    fn dup(&self, old_id: usize, buf: &[u8]) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn read(&self, id: usize, buf: &mut [u8]) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn write(&self, id: usize, buf: &[u8]) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn seek(&self, id: usize, pos: usize, whence: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fcntl(&self, id: usize, cmd: usize, arg: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fevent(&self, id: usize, flags: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fmap(&self, id: usize, offset: usize, size: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fpath(&self, id: usize, buf: &mut [u8]) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fstat(&self, id: usize, stat: &mut Stat) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fstatvfs(&self, id: usize, stat: &mut StatVfs) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fsync(&self, id: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn ftruncate(&self, id: usize, len: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn close(&self, id: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+}\n+\n+pub trait SchemeMut {\n+    fn handle(&mut self, packet: &mut Packet) {\n+        packet.a = Error::mux(match packet.a {\n+            SYS_OPEN => self.open(unsafe { slice::from_raw_parts(packet.b as *const u8, packet.c) }, packet.d, packet.uid, packet.gid),\n+            SYS_CHMOD => self.chmod(unsafe { slice::from_raw_parts(packet.b as *const u8, packet.c) }, packet.d as u16, packet.uid, packet.gid),\n+            SYS_RMDIR => self.rmdir(unsafe { slice::from_raw_parts(packet.b as *const u8, packet.c) }, packet.uid, packet.gid),\n+            SYS_UNLINK => self.unlink(unsafe { slice::from_raw_parts(packet.b as *const u8, packet.c) }, packet.uid, packet.gid),\n+\n+            SYS_DUP => self.dup(packet.b, unsafe { slice::from_raw_parts(packet.c as *const u8, packet.d) }),\n+            SYS_READ => self.read(packet.b, unsafe { slice::from_raw_parts_mut(packet.c as *mut u8, packet.d) }),\n+            SYS_WRITE => self.write(packet.b, unsafe { slice::from_raw_parts(packet.c as *const u8, packet.d) }),\n+            SYS_LSEEK => self.seek(packet.b, packet.c, packet.d),\n+            SYS_FCNTL => self.fcntl(packet.b, packet.c, packet.d),\n+            SYS_FEVENT => self.fevent(packet.b, packet.c),\n+            SYS_FMAP => self.fmap(packet.b, packet.c, packet.d),\n+            SYS_FPATH => self.fpath(packet.b, unsafe { slice::from_raw_parts_mut(packet.c as *mut u8, packet.d) }),\n+            SYS_FSTAT => if packet.d >= mem::size_of::<Stat>() { self.fstat(packet.b, unsafe { &mut *(packet.c as *mut Stat) }) } else { Err(Error::new(EFAULT)) },\n+            SYS_FSTATVFS => if packet.d >= mem::size_of::<StatVfs>() { self.fstatvfs(packet.b, unsafe { &mut *(packet.c as *mut StatVfs) }) } else { Err(Error::new(EFAULT)) },\n+            SYS_FSYNC => self.fsync(packet.b),\n+            SYS_FTRUNCATE => self.ftruncate(packet.b, packet.c),\n+            SYS_CLOSE => self.close(packet.b),\n+\n+            _ => Err(Error::new(ENOSYS))\n+        });\n+    }\n+\n+    /* Scheme operations */\n+    #[allow(unused_variables)]\n+    fn open(&mut self, path: &[u8], flags: usize, uid: u32, gid: u32) -> Result<usize> {\n+        Err(Error::new(ENOENT))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn chmod(&self, path: &[u8], mode: u16, uid: u32, gid: u32) -> Result<usize> {\n+        Err(Error::new(ENOENT))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn rmdir(&mut self, path: &[u8], uid: u32, gid: u32) -> Result<usize> {\n+        Err(Error::new(ENOENT))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn unlink(&mut self, path: &[u8], uid: u32, gid: u32) -> Result<usize> {\n+        Err(Error::new(ENOENT))\n+    }\n+\n+    /* Resource operations */\n+    #[allow(unused_variables)]\n+    fn dup(&mut self, old_id: usize, buf: &[u8]) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn read(&mut self, id: usize, buf: &mut [u8]) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn write(&mut self, id: usize, buf: &[u8]) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn seek(&mut self, id: usize, pos: usize, whence: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fcntl(&mut self, id: usize, cmd: usize, arg: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fevent(&mut self, id: usize, flags: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fmap(&mut self, id: usize, offset: usize, size: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fpath(&mut self, id: usize, buf: &mut [u8]) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fstat(&mut self, id: usize, stat: &mut Stat) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fstatvfs(&self, id: usize, stat: &mut StatVfs) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn fsync(&mut self, id: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn ftruncate(&mut self, id: usize, len: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+\n+    #[allow(unused_variables)]\n+    fn close(&mut self, id: usize) -> Result<usize> {\n+        Err(Error::new(EBADF))\n+    }\n+}"}, {"sha": "4bb6060c43e067e9aacb4a1ade45f8ca81ea8e8e", "filename": "src/libstd/sys/redox/syscall/x86.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fx86.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,72 @@\n+use super::error::{Error, Result};\n+\n+pub unsafe fn syscall0(mut a: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall1(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+// Clobbers all registers - special for clone\n+pub unsafe fn syscall1_clobber(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b)\n+        : \"memory\", \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall4(mut a: usize, b: usize, c: usize, d: usize, e: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d), \"{esi}\"(e)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall5(mut a: usize, b: usize, c: usize, d: usize, e: usize, f: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d), \"{esi}\"(e), \"{edi}\"(f)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}"}, {"sha": "6c1f96adef925f80328f0a7f4ec2ab102d015466", "filename": "src/libstd/sys/redox/syscall/x86_64.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fx86_64.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -0,0 +1,72 @@\n+use super::error::{Error, Result};\n+\n+pub unsafe fn syscall0(mut a: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall1(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+// Clobbers all registers - special for clone\n+pub unsafe fn syscall1_clobber(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b)\n+        : \"memory\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall4(mut a: usize, b: usize, c: usize, d: usize, e: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d), \"{rsi}\"(e)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall5(mut a: usize, b: usize, c: usize, d: usize, e: usize, f: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d), \"{rsi}\"(e), \"{rdi}\"(f)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}"}, {"sha": "82acbf934881dc1048dd98a151d15b900b170d22", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7543a16ec6450b8fe0c3d50bc341b5f143cc54/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3e7543a16ec6450b8fe0c3d50bc341b5f143cc54", "patch": "@@ -914,6 +914,11 @@ fn use_color(opts: &TestOpts) -> bool {\n     }\n }\n \n+#[cfg(target_os = \"redox\")]\n+fn stdout_isatty() -> bool {\n+    // FIXME: Implement isatty on Redox\n+    false\n+}\n #[cfg(unix)]\n fn stdout_isatty() -> bool {\n     unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n@@ -1103,6 +1108,12 @@ fn get_concurrency() -> usize {\n         }\n     }\n \n+    #[cfg(target_os = \"redox\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: Implement num_cpus on Redox\n+        1\n+    }\n+\n     #[cfg(any(target_os = \"linux\",\n               target_os = \"macos\",\n               target_os = \"ios\","}]}