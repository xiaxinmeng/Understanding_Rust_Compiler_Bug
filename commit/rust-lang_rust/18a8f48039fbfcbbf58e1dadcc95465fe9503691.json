{"sha": "18a8f48039fbfcbbf58e1dadcc95465fe9503691", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YThmNDgwMzlmYmZjYmJmNThlMWRhZGNjOTU0NjVmZTk1MDM2OTE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-23T17:25:40Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-23T17:25:40Z"}, "message": "Merge #1031\n\n1031: Move most things out of ra_ide_api_light r=matklad a=detrumi\n\nThis moves everything except `structure` out of `ra_ide_api_light`. So this PR and #1019 finish up #1009, whichever is merged last should probably remove the `ra_ide_api_light` crate.\r\n\r\nAlso, `LocalEdit` was removed since it wasn't used any more.\n\nCo-authored-by: Wilco Kusee <wilcokusee@gmail.com>", "tree": {"sha": "503037f1f48c53eb460fb730fed576070527203d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/503037f1f48c53eb460fb730fed576070527203d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18a8f48039fbfcbbf58e1dadcc95465fe9503691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18a8f48039fbfcbbf58e1dadcc95465fe9503691", "html_url": "https://github.com/rust-lang/rust/commit/18a8f48039fbfcbbf58e1dadcc95465fe9503691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18a8f48039fbfcbbf58e1dadcc95465fe9503691/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "2dfb47cc3dd68b7ca575e7eb4238221fdc8e7cdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dfb47cc3dd68b7ca575e7eb4238221fdc8e7cdb", "html_url": "https://github.com/rust-lang/rust/commit/2dfb47cc3dd68b7ca575e7eb4238221fdc8e7cdb"}, {"sha": "a3711e08dc4e393957dff136218c47d8b77da14f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3711e08dc4e393957dff136218c47d8b77da14f", "html_url": "https://github.com/rust-lang/rust/commit/a3711e08dc4e393957dff136218c47d8b77da14f"}], "stats": {"total": 458, "additions": 222, "deletions": 236}, "files": [{"sha": "b9dc424c62c215c358c34df6a08f1149eb9b65ae", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=18a8f48039fbfcbbf58e1dadcc95465fe9503691", "patch": "@@ -1,6 +1,5 @@\n use itertools::Itertools;\n use hir::{Problem, source_binder};\n-use ra_ide_api_light::Severity;\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n@@ -11,6 +10,12 @@ use ra_text_edit::{TextEdit, TextEditBuilder};\n \n use crate::{Diagnostic, FileId, FileSystemEdit, SourceChange, SourceFileEdit, db::RootDatabase};\n \n+#[derive(Debug, Copy, Clone)]\n+pub enum Severity {\n+    Error,\n+    WeakWarning,\n+}\n+\n pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic> {\n     let source_file = db.parse(file_id);\n     let mut res = Vec::new();"}, {"sha": "99f18b6b8c343e9640554fa9507ef62b9aecb334", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=18a8f48039fbfcbbf58e1dadcc95465fe9503691", "patch": "@@ -37,6 +37,8 @@ mod line_index;\n mod folding_ranges;\n mod line_index_utils;\n mod join_lines;\n+mod typing;\n+mod matching_brace;\n \n #[cfg(test)]\n mod marks;\n@@ -69,10 +71,10 @@ pub use crate::{\n     line_index::{LineIndex, LineCol},\n     line_index_utils::translate_offset_with_edit,\n     folding_ranges::{Fold, FoldKind},\n+    syntax_highlighting::HighlightedRange,\n+    diagnostics::Severity,\n };\n-pub use ra_ide_api_light::{\n-    HighlightedRange, Severity, StructureNode, LocalEdit,\n-};\n+pub use ra_ide_api_light::StructureNode;\n pub use ra_db::{\n     Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId,\n     Edition\n@@ -266,7 +268,7 @@ impl Analysis {\n     /// supported).\n     pub fn matching_brace(&self, position: FilePosition) -> Option<TextUnit> {\n         let file = self.db.parse(position.file_id);\n-        ra_ide_api_light::matching_brace(&file, position.offset)\n+        matching_brace::matching_brace(&file, position.offset)\n     }\n \n     /// Returns a syntax tree represented as `String`, for debug purposes.\n@@ -294,25 +296,26 @@ impl Analysis {\n     /// Returns an edit which should be applied when opening a new line, fixing\n     /// up minor stuff like continuing the comment.\n     pub fn on_enter(&self, position: FilePosition) -> Option<SourceChange> {\n-        let file = self.db.parse(position.file_id);\n-        let edit = ra_ide_api_light::on_enter(&file, position.offset)?;\n-        Some(SourceChange::from_local_edit(position.file_id, edit))\n+        typing::on_enter(&self.db, position)\n     }\n \n     /// Returns an edit which should be applied after `=` was typed. Primarily,\n     /// this works when adding `let =`.\n     // FIXME: use a snippet completion instead of this hack here.\n     pub fn on_eq_typed(&self, position: FilePosition) -> Option<SourceChange> {\n         let file = self.db.parse(position.file_id);\n-        let edit = ra_ide_api_light::on_eq_typed(&file, position.offset)?;\n-        Some(SourceChange::from_local_edit(position.file_id, edit))\n+        let edit = typing::on_eq_typed(&file, position.offset)?;\n+        Some(SourceChange {\n+            label: \"add semicolon\".to_string(),\n+            source_file_edits: vec![SourceFileEdit { edit, file_id: position.file_id }],\n+            file_system_edits: vec![],\n+            cursor_position: None,\n+        })\n     }\n \n     /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n     pub fn on_dot_typed(&self, position: FilePosition) -> Option<SourceChange> {\n-        let file = self.db.parse(position.file_id);\n-        let edit = ra_ide_api_light::on_dot_typed(&file, position.offset)?;\n-        Some(SourceChange::from_local_edit(position.file_id, edit))\n+        typing::on_dot_typed(&self.db, position)\n     }\n \n     /// Returns a tree representation of symbols in the file. Useful to draw a\n@@ -434,18 +437,6 @@ impl Analysis {\n     }\n }\n \n-impl SourceChange {\n-    pub(crate) fn from_local_edit(file_id: FileId, edit: LocalEdit) -> SourceChange {\n-        let file_edit = SourceFileEdit { file_id, edit: edit.edit };\n-        SourceChange {\n-            label: edit.label,\n-            source_file_edits: vec![file_edit],\n-            file_system_edits: vec![],\n-            cursor_position: edit.cursor_position.map(|offset| FilePosition { offset, file_id }),\n-        }\n-    }\n-}\n-\n #[test]\n fn analysis_is_send() {\n     fn is_send<T: Send>() {}"}, {"sha": "d1405f14fcd90fcc813777d339ca242779cfb510", "filename": "crates/ra_ide_api/src/matching_brace.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs?ref=18a8f48039fbfcbbf58e1dadcc95465fe9503691", "patch": "@@ -0,0 +1,45 @@\n+use ra_syntax::{\n+    SourceFile, TextUnit,\n+    algo::find_leaf_at_offset,\n+    SyntaxKind::{self, *},\n+    ast::AstNode,\n+};\n+\n+pub fn matching_brace(file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n+    const BRACES: &[SyntaxKind] =\n+        &[L_CURLY, R_CURLY, L_BRACK, R_BRACK, L_PAREN, R_PAREN, L_ANGLE, R_ANGLE];\n+    let (brace_node, brace_idx) = find_leaf_at_offset(file.syntax(), offset)\n+        .filter_map(|node| {\n+            let idx = BRACES.iter().position(|&brace| brace == node.kind())?;\n+            Some((node, idx))\n+        })\n+        .next()?;\n+    let parent = brace_node.parent()?;\n+    let matching_kind = BRACES[brace_idx ^ 1];\n+    let matching_node = parent.children().find(|node| node.kind() == matching_kind)?;\n+    Some(matching_node.range().start())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::{add_cursor, assert_eq_text, extract_offset};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_matching_brace() {\n+        fn do_check(before: &str, after: &str) {\n+            let (pos, before) = extract_offset(before);\n+            let file = SourceFile::parse(&before);\n+            let new_pos = match matching_brace(&file, pos) {\n+                None => pos,\n+                Some(pos) => pos,\n+            };\n+            let actual = add_cursor(&before, new_pos);\n+            assert_eq_text!(after, &actual);\n+        }\n+\n+        do_check(\"struct Foo { a: i32, }<|>\", \"struct Foo <|>{ a: i32, }\");\n+    }\n+\n+}"}, {"sha": "72029e0ed27bb526b4ea5736c1a9596b21c26345", "filename": "crates/ra_ide_api/src/snapshots/tests__highlighting.snap", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__highlighting.snap", "raw_url": "https://github.com/rust-lang/rust/raw/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__highlighting.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__highlighting.snap?ref=18a8f48039fbfcbbf58e1dadcc95465fe9503691", "patch": "@@ -0,0 +1,34 @@\n+---\n+created: \"2019-03-23T16:20:31.394314144Z\"\n+creator: insta@0.7.1\n+source: crates/ra_ide_api/src/syntax_highlighting.rs\n+expression: result\n+---\n+Ok(\n+    [\n+        HighlightedRange {\n+            range: [1; 11),\n+            tag: \"comment\"\n+        },\n+        HighlightedRange {\n+            range: [12; 14),\n+            tag: \"keyword\"\n+        },\n+        HighlightedRange {\n+            range: [15; 19),\n+            tag: \"function\"\n+        },\n+        HighlightedRange {\n+            range: [29; 37),\n+            tag: \"macro\"\n+        },\n+        HighlightedRange {\n+            range: [38; 50),\n+            tag: \"string\"\n+        },\n+        HighlightedRange {\n+            range: [52; 54),\n+            tag: \"literal\"\n+        }\n+    ]\n+)"}, {"sha": "a0c5e78ad79d18515faf8e0b093a5113c80626e2", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=18a8f48039fbfcbbf58e1dadcc95465fe9503691", "patch": "@@ -1,12 +1,81 @@\n-use ra_syntax::AstNode;\n+use rustc_hash::FxHashSet;\n+\n+use ra_syntax::{ast, AstNode, TextRange, Direction, SyntaxKind::*};\n use ra_db::SourceDatabase;\n \n-use crate::{\n-    FileId, HighlightedRange,\n-    db::RootDatabase,\n-};\n+use crate::{FileId, db::RootDatabase};\n+\n+#[derive(Debug)]\n+pub struct HighlightedRange {\n+    pub range: TextRange,\n+    pub tag: &'static str,\n+}\n \n pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRange> {\n     let source_file = db.parse(file_id);\n-    ra_ide_api_light::highlight(source_file.syntax())\n+\n+    // Visited nodes to handle highlighting priorities\n+    let mut highlighted = FxHashSet::default();\n+    let mut res = Vec::new();\n+    for node in source_file.syntax().descendants() {\n+        if highlighted.contains(&node) {\n+            continue;\n+        }\n+        let tag = match node.kind() {\n+            COMMENT => \"comment\",\n+            STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => \"string\",\n+            ATTR => \"attribute\",\n+            NAME_REF => \"text\",\n+            NAME => \"function\",\n+            INT_NUMBER | FLOAT_NUMBER | CHAR | BYTE => \"literal\",\n+            LIFETIME => \"parameter\",\n+            k if k.is_keyword() => \"keyword\",\n+            _ => {\n+                if let Some(macro_call) = ast::MacroCall::cast(node) {\n+                    if let Some(path) = macro_call.path() {\n+                        if let Some(segment) = path.segment() {\n+                            if let Some(name_ref) = segment.name_ref() {\n+                                highlighted.insert(name_ref.syntax());\n+                                let range_start = name_ref.syntax().range().start();\n+                                let mut range_end = name_ref.syntax().range().end();\n+                                for sibling in path.syntax().siblings(Direction::Next) {\n+                                    match sibling.kind() {\n+                                        EXCL | IDENT => range_end = sibling.range().end(),\n+                                        _ => (),\n+                                    }\n+                                }\n+                                res.push(HighlightedRange {\n+                                    range: TextRange::from_to(range_start, range_end),\n+                                    tag: \"macro\",\n+                                })\n+                            }\n+                        }\n+                    }\n+                }\n+                continue;\n+            }\n+        };\n+        res.push(HighlightedRange { range: node.range(), tag })\n+    }\n+    res\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use insta::assert_debug_snapshot_matches;\n+\n+    use crate::mock_analysis::single_file;\n+\n+    #[test]\n+    fn test_highlighting() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+// comment\n+fn main() {}\n+    println!(\"Hello, {}!\", 92);\n+\"#,\n+        );\n+        let result = analysis.highlight(file_id);\n+        assert_debug_snapshot_matches!(\"highlighting\", result);\n+    }\n }"}, {"sha": "94b228466c5992b70a93a0132fef43d765540f51", "filename": "crates/ra_ide_api/src/typing.rs", "status": "renamed", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=18a8f48039fbfcbbf58e1dadcc95465fe9503691", "patch": "@@ -5,30 +5,37 @@ use ra_syntax::{\n     ast::{self, AstToken},\n };\n use ra_fmt::leading_indent;\n-use crate::{LocalEdit, TextEditBuilder};\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+use ra_db::{FilePosition, SourceDatabase};\n+use crate::{db::RootDatabase, SourceChange, SourceFileEdit};\n \n-pub fn on_enter(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n-    let comment =\n-        find_leaf_at_offset(file.syntax(), offset).left_biased().and_then(ast::Comment::cast)?;\n+pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n+    let file = db.parse(position.file_id);\n+    let comment = find_leaf_at_offset(file.syntax(), position.offset)\n+        .left_biased()\n+        .and_then(ast::Comment::cast)?;\n \n     if let ast::CommentFlavor::Multiline = comment.flavor() {\n         return None;\n     }\n \n     let prefix = comment.prefix();\n-    if offset < comment.syntax().range().start() + TextUnit::of_str(prefix) + TextUnit::from(1) {\n+    if position.offset\n+        < comment.syntax().range().start() + TextUnit::of_str(prefix) + TextUnit::from(1)\n+    {\n         return None;\n     }\n \n-    let indent = node_indent(file, comment.syntax())?;\n+    let indent = node_indent(&file, comment.syntax())?;\n     let inserted = format!(\"\\n{}{} \", indent, prefix);\n-    let cursor_position = offset + TextUnit::of_str(&inserted);\n+    let cursor_position = position.offset + TextUnit::of_str(&inserted);\n     let mut edit = TextEditBuilder::default();\n-    edit.insert(offset, inserted);\n-    Some(LocalEdit {\n+    edit.insert(position.offset, inserted);\n+    Some(SourceChange {\n         label: \"on enter\".to_string(),\n-        edit: edit.finish(),\n-        cursor_position: Some(cursor_position),\n+        source_file_edits: vec![SourceFileEdit { edit: edit.finish(), file_id: position.file_id }],\n+        file_system_edits: vec![],\n+        cursor_position: Some(FilePosition { offset: cursor_position, file_id: position.file_id }),\n     })\n }\n \n@@ -52,7 +59,7 @@ fn node_indent<'a>(file: &'a SourceFile, node: &SyntaxNode) -> Option<&'a str> {\n     Some(&text[pos..])\n }\n \n-pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<LocalEdit> {\n+pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<TextEdit> {\n     assert_eq!(file.syntax().text().char_at(eq_offset), Some('='));\n     let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n     if let_stmt.has_semi() {\n@@ -72,17 +79,14 @@ pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<LocalEdit>\n     let offset = let_stmt.syntax().range().end();\n     let mut edit = TextEditBuilder::default();\n     edit.insert(offset, \";\".to_string());\n-    Some(LocalEdit {\n-        label: \"add semicolon\".to_string(),\n-        edit: edit.finish(),\n-        cursor_position: None,\n-    })\n+    Some(edit.finish())\n }\n \n-pub fn on_dot_typed(file: &SourceFile, dot_offset: TextUnit) -> Option<LocalEdit> {\n-    assert_eq!(file.syntax().text().char_at(dot_offset), Some('.'));\n+pub(crate) fn on_dot_typed(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n+    let file = db.parse(position.file_id);\n+    assert_eq!(file.syntax().text().char_at(position.offset), Some('.'));\n \n-    let whitespace = find_leaf_at_offset(file.syntax(), dot_offset)\n+    let whitespace = find_leaf_at_offset(file.syntax(), position.offset)\n         .left_biased()\n         .and_then(ast::Whitespace::cast)?;\n \n@@ -103,15 +107,18 @@ pub fn on_dot_typed(file: &SourceFile, dot_offset: TextUnit) -> Option<LocalEdit\n     }\n     let mut edit = TextEditBuilder::default();\n     edit.replace(\n-        TextRange::from_to(dot_offset - current_indent_len, dot_offset),\n+        TextRange::from_to(position.offset - current_indent_len, position.offset),\n         target_indent.into(),\n     );\n-    let res = LocalEdit {\n+    let res = SourceChange {\n         label: \"reindent dot\".to_string(),\n-        edit: edit.finish(),\n-        cursor_position: Some(\n-            dot_offset + target_indent_len - current_indent_len + TextUnit::of_char('.'),\n-        ),\n+        source_file_edits: vec![SourceFileEdit { edit: edit.finish(), file_id: position.file_id }],\n+        file_system_edits: vec![],\n+        cursor_position: Some(FilePosition {\n+            offset: position.offset + target_indent_len - current_indent_len\n+                + TextUnit::of_char('.'),\n+            file_id: position.file_id,\n+        }),\n     };\n     Some(res)\n }\n@@ -120,6 +127,8 @@ pub fn on_dot_typed(file: &SourceFile, dot_offset: TextUnit) -> Option<LocalEdit\n mod tests {\n     use test_utils::{add_cursor, assert_eq_text, extract_offset};\n \n+    use crate::mock_analysis::single_file;\n+\n     use super::*;\n \n     #[test]\n@@ -131,7 +140,7 @@ mod tests {\n             let before = edit.finish().apply(&before);\n             let file = SourceFile::parse(&before);\n             if let Some(result) = on_eq_typed(&file, offset) {\n-                let actual = result.edit.apply(&before);\n+                let actual = result.apply(&before);\n                 assert_eq_text!(after, &actual);\n             } else {\n                 assert_eq_text!(&before, after)\n@@ -177,9 +186,10 @@ fn foo() {\n         let mut edit = TextEditBuilder::default();\n         edit.insert(offset, \".\".to_string());\n         let before = edit.finish().apply(&before);\n-        let file = SourceFile::parse(&before);\n-        if let Some(result) = on_dot_typed(&file, offset) {\n-            let actual = result.edit.apply(&before);\n+        let (analysis, file_id) = single_file(&before);\n+        if let Some(result) = analysis.on_dot_typed(FilePosition { offset, file_id }) {\n+            assert_eq!(result.source_file_edits.len(), 1);\n+            let actual = result.source_file_edits[0].edit.apply(&before);\n             assert_eq_text!(after, &actual);\n         } else {\n             assert_eq_text!(&before, after)\n@@ -358,10 +368,12 @@ fn foo() {\n     fn test_on_enter() {\n         fn apply_on_enter(before: &str) -> Option<String> {\n             let (offset, before) = extract_offset(before);\n-            let file = SourceFile::parse(&before);\n-            let result = on_enter(&file, offset)?;\n-            let actual = result.edit.apply(&before);\n-            let actual = add_cursor(&actual, result.cursor_position.unwrap());\n+            let (analysis, file_id) = single_file(&before);\n+            let result = analysis.on_enter(FilePosition { offset, file_id })?;\n+\n+            assert_eq!(result.source_file_edits.len(), 1);\n+            let actual = result.source_file_edits[0].edit.apply(&before);\n+            let actual = add_cursor(&actual, result.cursor_position.unwrap().offset);\n             Some(actual)\n         }\n ", "previous_filename": "crates/ra_ide_api_light/src/typing.rs"}, {"sha": "df7f144b627c5121bb3cd7a41b881e4bca7f8268", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "modified", "additions": 1, "deletions": 139, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a8f48039fbfcbbf58e1dadcc95465fe9503691/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=18a8f48039fbfcbbf58e1dadcc95465fe9503691", "patch": "@@ -4,147 +4,9 @@\n //! an edit or some auxiliary info.\n \n mod structure;\n-mod typing;\n \n-use rustc_hash::FxHashSet;\n-use ra_text_edit::TextEditBuilder;\n-use ra_syntax::{\n-    SourceFile, SyntaxNode, TextRange, TextUnit, Direction,\n-    algo::find_leaf_at_offset,\n-    SyntaxKind::{self, *},\n-    ast::{self, AstNode},\n-};\n+use ra_syntax::TextRange;\n \n pub use crate::{\n     structure::{file_structure, StructureNode},\n-    typing::{on_enter, on_dot_typed, on_eq_typed},\n };\n-\n-#[derive(Debug)]\n-pub struct LocalEdit {\n-    pub label: String,\n-    pub edit: ra_text_edit::TextEdit,\n-    pub cursor_position: Option<TextUnit>,\n-}\n-\n-#[derive(Debug)]\n-pub struct HighlightedRange {\n-    pub range: TextRange,\n-    pub tag: &'static str,\n-}\n-\n-#[derive(Debug, Copy, Clone)]\n-pub enum Severity {\n-    Error,\n-    WeakWarning,\n-}\n-\n-#[derive(Debug)]\n-pub struct Diagnostic {\n-    pub range: TextRange,\n-    pub msg: String,\n-    pub severity: Severity,\n-    pub fix: Option<LocalEdit>,\n-}\n-\n-pub fn matching_brace(file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n-    const BRACES: &[SyntaxKind] =\n-        &[L_CURLY, R_CURLY, L_BRACK, R_BRACK, L_PAREN, R_PAREN, L_ANGLE, R_ANGLE];\n-    let (brace_node, brace_idx) = find_leaf_at_offset(file.syntax(), offset)\n-        .filter_map(|node| {\n-            let idx = BRACES.iter().position(|&brace| brace == node.kind())?;\n-            Some((node, idx))\n-        })\n-        .next()?;\n-    let parent = brace_node.parent()?;\n-    let matching_kind = BRACES[brace_idx ^ 1];\n-    let matching_node = parent.children().find(|node| node.kind() == matching_kind)?;\n-    Some(matching_node.range().start())\n-}\n-\n-pub fn highlight(root: &SyntaxNode) -> Vec<HighlightedRange> {\n-    // Visited nodes to handle highlighting priorities\n-    let mut highlighted = FxHashSet::default();\n-    let mut res = Vec::new();\n-    for node in root.descendants() {\n-        if highlighted.contains(&node) {\n-            continue;\n-        }\n-        let tag = match node.kind() {\n-            COMMENT => \"comment\",\n-            STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => \"string\",\n-            ATTR => \"attribute\",\n-            NAME_REF => \"text\",\n-            NAME => \"function\",\n-            INT_NUMBER | FLOAT_NUMBER | CHAR | BYTE => \"literal\",\n-            LIFETIME => \"parameter\",\n-            k if k.is_keyword() => \"keyword\",\n-            _ => {\n-                if let Some(macro_call) = ast::MacroCall::cast(node) {\n-                    if let Some(path) = macro_call.path() {\n-                        if let Some(segment) = path.segment() {\n-                            if let Some(name_ref) = segment.name_ref() {\n-                                highlighted.insert(name_ref.syntax());\n-                                let range_start = name_ref.syntax().range().start();\n-                                let mut range_end = name_ref.syntax().range().end();\n-                                for sibling in path.syntax().siblings(Direction::Next) {\n-                                    match sibling.kind() {\n-                                        EXCL | IDENT => range_end = sibling.range().end(),\n-                                        _ => (),\n-                                    }\n-                                }\n-                                res.push(HighlightedRange {\n-                                    range: TextRange::from_to(range_start, range_end),\n-                                    tag: \"macro\",\n-                                })\n-                            }\n-                        }\n-                    }\n-                }\n-                continue;\n-            }\n-        };\n-        res.push(HighlightedRange { range: node.range(), tag })\n-    }\n-    res\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_syntax::AstNode;\n-    use insta::assert_debug_snapshot_matches;\n-\n-    use test_utils::{add_cursor, assert_eq_text, extract_offset};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn test_highlighting() {\n-        let file = SourceFile::parse(\n-            r#\"\n-// comment\n-fn main() {}\n-    println!(\"Hello, {}!\", 92);\n-\"#,\n-        );\n-        let hls = highlight(file.syntax());\n-        assert_debug_snapshot_matches!(\"highlighting\", hls);\n-    }\n-\n-    #[test]\n-    fn test_matching_brace() {\n-        fn do_check(before: &str, after: &str) {\n-            let (pos, before) = extract_offset(before);\n-            let file = SourceFile::parse(&before);\n-            let new_pos = match matching_brace(&file, pos) {\n-                None => pos,\n-                Some(pos) => pos,\n-            };\n-            let actual = add_cursor(&before, new_pos);\n-            assert_eq_text!(after, &actual);\n-        }\n-\n-        do_check(\"struct Foo { a: i32, }<|>\", \"struct Foo <|>{ a: i32, }\");\n-    }\n-\n-}"}, {"sha": "ef306a7a02f9c71255b79361ced428024331fdee", "filename": "crates/ra_ide_api_light/src/snapshots/tests__highlighting.snap", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2dfb47cc3dd68b7ca575e7eb4238221fdc8e7cdb/crates%2Fra_ide_api_light%2Fsrc%2Fsnapshots%2Ftests__highlighting.snap", "raw_url": "https://github.com/rust-lang/rust/raw/2dfb47cc3dd68b7ca575e7eb4238221fdc8e7cdb/crates%2Fra_ide_api_light%2Fsrc%2Fsnapshots%2Ftests__highlighting.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fsnapshots%2Ftests__highlighting.snap?ref=2dfb47cc3dd68b7ca575e7eb4238221fdc8e7cdb", "patch": "@@ -1,32 +0,0 @@\n----\n-created: \"2019-01-22T14:45:01.959724300+00:00\"\n-creator: insta@0.4.0\n-expression: hls\n-source: \"crates\\\\ra_ide_api_light\\\\src\\\\lib.rs\"\n----\n-[\n-    HighlightedRange {\n-        range: [1; 11),\n-        tag: \"comment\"\n-    },\n-    HighlightedRange {\n-        range: [12; 14),\n-        tag: \"keyword\"\n-    },\n-    HighlightedRange {\n-        range: [15; 19),\n-        tag: \"function\"\n-    },\n-    HighlightedRange {\n-        range: [29; 37),\n-        tag: \"macro\"\n-    },\n-    HighlightedRange {\n-        range: [38; 50),\n-        tag: \"string\"\n-    },\n-    HighlightedRange {\n-        range: [52; 54),\n-        tag: \"literal\"\n-    }\n-]"}]}