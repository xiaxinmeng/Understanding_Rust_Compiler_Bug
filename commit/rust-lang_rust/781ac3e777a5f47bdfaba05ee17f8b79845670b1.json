{"sha": "781ac3e777a5f47bdfaba05ee17f8b79845670b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MWFjM2U3NzdhNWY0N2JkZmFiYTA1ZWUxN2Y4Yjc5ODQ1NjcwYjE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-05-04T13:17:37Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-05-05T08:20:41Z"}, "message": "std: deprecate cast::transmute_mut.\n\nTurning a `&T` into an `&mut T` carries a large risk of undefined\nbehaviour, and needs to be done very very carefully. Providing a\nconvenience function for exactly this task is a bad idea, just tempting\npeople into doing the wrong thing.\n\nThe right thing is to use types like `Cell`, `RefCell` or `Unsafe`.\n\nFor memory safety, Rust has that guarantee that `&mut` pointers do not\nalias with any other pointer, that is, if you have a `&mut T` then that\nis the only usable pointer to that `T`. This allows Rust to assume that\nwrites through a `&mut T` do not affect the values of any other `&` or\n`&mut` references. `&` pointers have no guarantees about aliasing or\nnot, so it's entirely possible for the same pointer to be passed into\nboth arguments of a function like\n\n    fn foo(x: &int, y: &int) { ... }\n\nConverting either of `x` or `y` to a `&mut` pointer and modifying it\nwould affect the other value: invalid behaviour.\n\n(Similarly, it's undefined behaviour to modify the value of an immutable\nlocal, like `let x = 1;`.)\n\nAt a low-level, the *only* safe way to obtain an `&mut` out of a `&` is\nusing the `Unsafe` type (there are higher level wrappers around it, like\n`Cell`, `RefCell`, `Mutex` etc.). The `Unsafe` type is registered with\nthe compiler so that it can reason a little about these `&` to `&mut`\ncasts, but it is still up to the user to ensure that the `&mut`s\nobtained out of an `Unsafe` never alias.\n\n(Note that *any* conversion from `&` to `&mut` can be invalid, including\na plain `transmute`, or casting `&T` -> `*T` -> `*mut T` -> `&mut T`.)\n\n[breaking-change]", "tree": {"sha": "4c79abc527b6dfdfadd39bf7fe8ac96ad05326a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c79abc527b6dfdfadd39bf7fe8ac96ad05326a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/781ac3e777a5f47bdfaba05ee17f8b79845670b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/781ac3e777a5f47bdfaba05ee17f8b79845670b1", "html_url": "https://github.com/rust-lang/rust/commit/781ac3e777a5f47bdfaba05ee17f8b79845670b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/781ac3e777a5f47bdfaba05ee17f8b79845670b1/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abdacecdf86b4b5a4f432560445a24e1c5f4751b", "url": "https://api.github.com/repos/rust-lang/rust/commits/abdacecdf86b4b5a4f432560445a24e1c5f4751b", "html_url": "https://github.com/rust-lang/rust/commit/abdacecdf86b4b5a4f432560445a24e1c5f4751b"}], "stats": {"total": 61, "additions": 37, "deletions": 24}, "files": [{"sha": "d80385587dad5f66998a75dc743115a06ef0bee4", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=781ac3e777a5f47bdfaba05ee17f8b79845670b1", "patch": "@@ -26,7 +26,7 @@\n \n extern crate collections;\n \n-use std::cast::{transmute, transmute_mut, transmute_mut_lifetime};\n+use std::cast::{transmute, transmute_mut_lifetime};\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::mem;\n@@ -281,8 +281,8 @@ impl Arena {\n     #[inline]\n     pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n-            // FIXME: Borrow check\n-            let this = transmute_mut(self);\n+            // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+            let this: &mut Arena = transmute::<&_, &mut _>(self);\n             if intrinsics::needs_drop::<T>() {\n                 this.alloc_noncopy(op)\n             } else {\n@@ -438,7 +438,8 @@ impl<T> TypedArena<T> {\n     #[inline]\n     pub fn alloc<'a>(&'a self, object: T) -> &'a T {\n         unsafe {\n-            let this = cast::transmute_mut(self);\n+            // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+            let this: &mut TypedArena<T> = cast::transmute::<&_, &mut _>(self);\n             if this.ptr == this.end {\n                 this.grow()\n             }"}, {"sha": "aae15a86614420acb4824132d4d8318c56e4b309", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=781ac3e777a5f47bdfaba05ee17f8b79845670b1", "patch": "@@ -174,7 +174,8 @@ impl rtio::RtioFileStream for FileDesc {\n     fn tell(&self) -> Result<u64, IoError> {\n         // This transmute is fine because our seek implementation doesn't\n         // actually use the mutable self at all.\n-        unsafe { cast::transmute_mut(self).seek(0, io::SeekCur) }\n+        // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+        unsafe { cast::transmute::<&_, &mut FileDesc>(self).seek(0, io::SeekCur) }\n     }\n \n     fn fsync(&mut self) -> Result<(), IoError> {"}, {"sha": "9037363f9a00eb46c7338b0f41efbcca1b3a10b5", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=781ac3e777a5f47bdfaba05ee17f8b79845670b1", "patch": "@@ -445,7 +445,8 @@ impl rtio::RtioFileStream for FileWatcher {\n     fn tell(&self) -> Result<u64, IoError> {\n         use libc::SEEK_CUR;\n         // this is temporary\n-        let self_ = unsafe { cast::transmute_mut(self) };\n+        // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+        let self_ = unsafe { cast::transmute::<&_, &mut FileWatcher>(self) };\n         self_.seek_common(0, SEEK_CUR)\n     }\n     fn fsync(&mut self) -> Result<(), IoError> {"}, {"sha": "7a8f517bbf92c0af6d6014f554b68b550c353b4d", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=781ac3e777a5f47bdfaba05ee17f8b79845670b1", "patch": "@@ -60,6 +60,7 @@ pub unsafe fn transmute<L, G>(thing: L) -> G {\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n+#[deprecated=\"casting &T to &mut T is undefined behaviour: use Cell<T>, RefCell<T> or Unsafe<T>\"]\n pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n \n /// Coerce a reference to have an arbitrary associated lifetime."}, {"sha": "bbe34d20f6a2e2f0ea615a630a1e12215ec94315", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=781ac3e777a5f47bdfaba05ee17f8b79845670b1", "patch": "@@ -318,6 +318,11 @@ mod stream;\n mod shared;\n mod sync;\n \n+// FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+unsafe fn transmute_mut<'a,T>(x: &'a T) -> &'a mut T {\n+    cast::transmute::<&_, &mut _>(x)\n+}\n+\n // Use a power of 2 to allow LLVM to optimize to something that's not a\n // division, this is hit pretty regularly.\n static RESCHED_FREQ: int = 256;\n@@ -565,7 +570,7 @@ impl<T: Send> Sender<T> {\n \n         unsafe {\n             let mut tmp = Sender::new(Stream(new_inner));\n-            mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n+            mem::swap(&mut transmute_mut(self).inner, &mut tmp.inner);\n         }\n         return ret;\n     }\n@@ -599,7 +604,7 @@ impl<T: Send> Clone for Sender<T> {\n             (*packet.get()).inherit_blocker(sleeper);\n \n             let mut tmp = Sender::new(Shared(packet.clone()));\n-            mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n+            mem::swap(&mut transmute_mut(self).inner, &mut tmp.inner);\n         }\n         Sender::new(Shared(packet))\n     }\n@@ -790,7 +795,7 @@ impl<T: Send> Receiver<T> {\n                 }\n             };\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n+                mem::swap(&mut transmute_mut(self).inner,\n                           &mut new_port.inner);\n             }\n         }\n@@ -837,7 +842,7 @@ impl<T: Send> Receiver<T> {\n                 Sync(ref p) => return unsafe { (*p.get()).recv() }\n             };\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n+                mem::swap(&mut transmute_mut(self).inner,\n                           &mut new_port.inner);\n             }\n         }\n@@ -874,7 +879,7 @@ impl<T: Send> select::Packet for Receiver<T> {\n                 }\n             };\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n+                mem::swap(&mut transmute_mut(self).inner,\n                           &mut new_port.inner);\n             }\n         }\n@@ -906,7 +911,7 @@ impl<T: Send> select::Packet for Receiver<T> {\n             };\n             task = t;\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n+                mem::swap(&mut transmute_mut(self).inner,\n                           &mut new_port.inner);\n             }\n         }\n@@ -930,7 +935,7 @@ impl<T: Send> select::Packet for Receiver<T> {\n             let mut new_port = match result { Ok(b) => return b, Err(p) => p };\n             was_upgrade = true;\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n+                mem::swap(&mut transmute_mut(self).inner,\n                           &mut new_port.inner);\n             }\n         }"}, {"sha": "e5c7ba4aa54bcbf9b0166c5eecda9086d8300d9c", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=781ac3e777a5f47bdfaba05ee17f8b79845670b1", "patch": "@@ -196,11 +196,11 @@ pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n         match x {\n             None => f(None),\n             // We're violating a lot of compiler guarantees with this\n-            // invocation of `transmute_mut`, but we're doing runtime checks to\n+            // invocation of `transmute`, but we're doing runtime checks to\n             // ensure that it's always valid (only one at a time).\n             //\n             // there is no need to be upset!\n-            Some(x) => { f(Some(unsafe { cast::transmute_mut(x) })) }\n+            Some(x) => { f(Some(unsafe { cast::transmute::<&_, &mut _>(x) })) }\n         }\n     })\n }"}, {"sha": "d8c866ef44a39193e34996efaef6f649741cf248", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=781ac3e777a5f47bdfaba05ee17f8b79845670b1", "patch": "@@ -1739,15 +1739,19 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n-            Some(cast::transmute_mut(&*raw::shift_ptr(s)))\n+            // FIXME #13933: this `&` -> `&mut` cast is a little\n+            // dubious\n+            Some(&mut *(raw::shift_ptr(s) as *mut _))\n         }\n     }\n \n     fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n         if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n-            Some(cast::transmute_mut(&*raw::pop_ptr(s)))\n+            // FIXME #13933: this `&` -> `&mut` cast is a little\n+            // dubious\n+            Some(&mut *(raw::pop_ptr(s) as *mut _))\n         }\n     }\n \n@@ -3108,23 +3112,23 @@ mod tests {\n     #[should_fail]\n     fn test_from_elem_fail() {\n         use cast;\n+        use cell::Cell;\n         use rc::Rc;\n \n         struct S {\n-            f: int,\n+            f: Cell<int>,\n             boxes: (~int, Rc<int>)\n         }\n \n         impl Clone for S {\n             fn clone(&self) -> S {\n-                let s = unsafe { cast::transmute_mut(self) };\n-                s.f += 1;\n-                if s.f == 10 { fail!() }\n-                S { f: s.f, boxes: s.boxes.clone() }\n+                self.f.set(self.f.get() + 1);\n+                if self.f.get() == 10 { fail!() }\n+                S { f: self.f, boxes: self.boxes.clone() }\n             }\n         }\n \n-        let s = S { f: 0, boxes: (box 0, Rc::new(0)) };\n+        let s = S { f: Cell::new(0), boxes: (box 0, Rc::new(0)) };\n         let _ = Vec::from_elem(100, s);\n     }\n "}, {"sha": "f5369ec862f8a0bf8bb004805ab354da1c0adf8c", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781ac3e777a5f47bdfaba05ee17f8b79845670b1/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=781ac3e777a5f47bdfaba05ee17f8b79845670b1", "patch": "@@ -148,7 +148,7 @@ impl<T: Send + Share + Clone> Arc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the Arc itself to be `mut`, so we're returning the only possible\n         // reference to the inner data.\n-        unsafe { cast::transmute_mut(self.deref()) }\n+        unsafe { cast::transmute::<&_, &mut _>(self.deref()) }\n     }\n }\n "}]}