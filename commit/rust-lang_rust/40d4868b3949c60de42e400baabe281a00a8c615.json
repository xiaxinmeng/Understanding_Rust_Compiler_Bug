{"sha": "40d4868b3949c60de42e400baabe281a00a8c615", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZDQ4NjhiMzk0OWM2MGRlNDJlNDAwYmFhYmUyODFhMDBhOGM2MTU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-04T09:25:09Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-13T01:35:32Z"}, "message": "Be less aggressive with `DroplessArena`/`TypedArena` growth.\n\n`DroplessArena` and `TypedArena` use an aggressive growth strategy: the\nfirst chunk is 4 KiB, the second is 8 KiB, and it keeps on doubling\nindefinitely. DHAT profiles show that sometimes this results in large\nchunks (e.g. 16-128 MiB) that are barely filled. Although these don't\ncontribute to RSS, they clog up the DHAT profiles.\n\nThis commit changes things so that the doubling stops at 2 MiB. This is\nlarge enough that chunk allocations are still rare (you might get 100s\ninstead of 10s of them) but avoids lots of unused space in the worst\ncase. It gives a slight speed-up to cycle counts in some cases.", "tree": {"sha": "60e3b51b166aa6d4f4364f615e547953b4320209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60e3b51b166aa6d4f4364f615e547953b4320209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40d4868b3949c60de42e400baabe281a00a8c615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40d4868b3949c60de42e400baabe281a00a8c615", "html_url": "https://github.com/rust-lang/rust/commit/40d4868b3949c60de42e400baabe281a00a8c615", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40d4868b3949c60de42e400baabe281a00a8c615/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9111d8b66e013a881bae4e09646514be86ca4c87", "url": "https://api.github.com/repos/rust-lang/rust/commits/9111d8b66e013a881bae4e09646514be86ca4c87", "html_url": "https://github.com/rust-lang/rust/commit/9111d8b66e013a881bae4e09646514be86ca4c87"}], "stats": {"total": 39, "additions": 26, "deletions": 13}, "files": [{"sha": "bbe80c26dcbf98d9c2612e15eb6b4670fdd4c274", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/40d4868b3949c60de42e400baabe281a00a8c615/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d4868b3949c60de42e400baabe281a00a8c615/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=40d4868b3949c60de42e400baabe281a00a8c615", "patch": "@@ -5,8 +5,7 @@\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n //!\n-//! This crate implements `TypedArena`, a simple arena that can only hold\n-//! objects of a single type.\n+//! This crate implements several kinds of arena.\n \n #![doc(\n     html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -98,7 +97,13 @@ impl<T> TypedArenaChunk<T> {\n     }\n }\n \n+// The arenas start with PAGE-sized chunks, and then each new chunk is twice as\n+// big as its predecessor, up until we reach HUGE_PAGE-sized chunks, whereupon\n+// we stop growing. This scales well, from arenas that are barely used up to\n+// arenas that are used for 100s of MiBs. Note also that the chosen sizes match\n+// the usual sizes of pages and huge pages on Linux.\n const PAGE: usize = 4096;\n+const HUGE_PAGE: usize = 2 * 1024 * 1024;\n \n impl<T> Default for TypedArena<T> {\n     /// Creates a new `TypedArena`.\n@@ -211,6 +216,9 @@ impl<T> TypedArena<T> {\n     #[cold]\n     fn grow(&self, n: usize) {\n         unsafe {\n+            // We need the element size in to convert chunk sizes (ranging from\n+            // PAGE to HUGE_PAGE bytes) to element counts.\n+            let elem_size = cmp::max(1, mem::size_of::<T>());\n             let mut chunks = self.chunks.borrow_mut();\n             let (chunk, mut new_capacity);\n             if let Some(last_chunk) = chunks.last_mut() {\n@@ -221,18 +229,20 @@ impl<T> TypedArena<T> {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n+                    // If the previous chunk's capacity is less than HUGE_PAGE\n+                    // bytes, then this chunk will be least double the previous\n+                    // chunk's size.\n                     new_capacity = last_chunk.storage.capacity();\n-                    loop {\n+                    if new_capacity < HUGE_PAGE / elem_size {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n-                        if new_capacity >= n {\n-                            break;\n-                        }\n                     }\n                 }\n             } else {\n-                let elem_size = cmp::max(1, mem::size_of::<T>());\n-                new_capacity = cmp::max(n, PAGE / elem_size);\n+                new_capacity = PAGE / elem_size;\n             }\n+            // Also ensure that this chunk can fit `n`.\n+            new_capacity = cmp::max(n, new_capacity);\n+\n             chunk = TypedArenaChunk::<T>::new(new_capacity);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n@@ -347,17 +357,20 @@ impl DroplessArena {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n+                    // If the previous chunk's capacity is less than HUGE_PAGE\n+                    // bytes, then this chunk will be least double the previous\n+                    // chunk's size.\n                     new_capacity = last_chunk.storage.capacity();\n-                    loop {\n+                    if new_capacity < HUGE_PAGE {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n-                        if new_capacity >= needed_bytes {\n-                            break;\n-                        }\n                     }\n                 }\n             } else {\n-                new_capacity = cmp::max(needed_bytes, PAGE);\n+                new_capacity = PAGE;\n             }\n+            // Also ensure that this chunk can fit `needed_bytes`.\n+            new_capacity = cmp::max(needed_bytes, new_capacity);\n+\n             chunk = TypedArenaChunk::<u8>::new(new_capacity);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());"}]}