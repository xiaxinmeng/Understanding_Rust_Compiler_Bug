{"sha": "3bf33b9060065b69f22c50d0ec924eaf51da830a", "node_id": "C_kwDOAAsO6NoAKDNiZjMzYjkwNjAwNjViNjlmMjJjNTBkMGVjOTI0ZWFmNTFkYTgzMGE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-04T23:53:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-04T23:53:31Z"}, "message": "Rollup merge of #95588 - RalfJung:strict-provenance, r=scottmcm\n\nexplicitly distinguish pointer::addr and pointer::expose_addr\n\n``@bgeron`` pointed out that the current docs promise that `ptr.addr()` and `ptr as usize` are equivalent. I don't think that is a promise we want to make. (Conceptually, `ptr as usize` might 'escape' the provenance to enable future `usize as ptr` casts, but `ptr.addr()` dertainly does not do that.)\n\nSo I propose we word the docs a bit more carefully here. ``@Gankra`` what do you think?", "tree": {"sha": "b65be5cb64ea858cc7fc1a100cc024660b1d11cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b65be5cb64ea858cc7fc1a100cc024660b1d11cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bf33b9060065b69f22c50d0ec924eaf51da830a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiS4T8CRBK7hj4Ov3rIwAATzgIABwARTTPAsEe4DoCrGOmSmrf\nudq4WcRab2dJ5u2NGaiKQS8pvbDVKkbpCllXhg2lm4Ed+mEnWGeg6H/0fkMvqG4T\nuNq5pnhyAz+D2Y0zXU3ECtFKTjF4T3s6c1FG5Y06cLbekmjBcfoJP8l4WBEa62vq\nV0EuJI+mAFVEztSYQXtTjMBoB130LXRoONeqeLbrRFyHtxj+IgbOZiw/bHaoG9qy\n5uGshaKygKiJH8ozwYNqA08uKKwvHRQR48mBlOJRMtZapL+5yErdvikOkcVqnaxk\nESBViWtzsrJjV+ggBkoQE7+Gb093d9LHfTCFD80y+MKKi93/aH6csOCdmBGRacM=\n=yatj\n-----END PGP SIGNATURE-----\n", "payload": "tree b65be5cb64ea858cc7fc1a100cc024660b1d11cc\nparent a5c81695a95e2a1a8e2ea4310bf670a9c1734387\nparent 0252fc9619805e59a32e8cf9a13591df69a56a5b\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649116411 +0200\ncommitter GitHub <noreply@github.com> 1649116411 +0200\n\nRollup merge of #95588 - RalfJung:strict-provenance, r=scottmcm\n\nexplicitly distinguish pointer::addr and pointer::expose_addr\n\n``@bgeron`` pointed out that the current docs promise that `ptr.addr()` and `ptr as usize` are equivalent. I don't think that is a promise we want to make. (Conceptually, `ptr as usize` might 'escape' the provenance to enable future `usize as ptr` casts, but `ptr.addr()` dertainly does not do that.)\n\nSo I propose we word the docs a bit more carefully here. ``@Gankra`` what do you think?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf33b9060065b69f22c50d0ec924eaf51da830a", "html_url": "https://github.com/rust-lang/rust/commit/3bf33b9060065b69f22c50d0ec924eaf51da830a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bf33b9060065b69f22c50d0ec924eaf51da830a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5c81695a95e2a1a8e2ea4310bf670a9c1734387", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c81695a95e2a1a8e2ea4310bf670a9c1734387", "html_url": "https://github.com/rust-lang/rust/commit/a5c81695a95e2a1a8e2ea4310bf670a9c1734387"}, {"sha": "0252fc9619805e59a32e8cf9a13591df69a56a5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0252fc9619805e59a32e8cf9a13591df69a56a5b", "html_url": "https://github.com/rust-lang/rust/commit/0252fc9619805e59a32e8cf9a13591df69a56a5b"}], "stats": {"total": 236, "additions": 217, "deletions": 19}, "files": [{"sha": "f862912432e56ddaa97b9bfbd6afea72469a6eb6", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3bf33b9060065b69f22c50d0ec924eaf51da830a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf33b9060065b69f22c50d0ec924eaf51da830a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=3bf33b9060065b69f22c50d0ec924eaf51da830a", "patch": "@@ -152,18 +152,27 @@ impl<T: ?Sized> *const T {\n \n     /// Gets the \"address\" portion of the pointer.\n     ///\n-    /// This is equivalent to `self as usize`, which semantically discards\n-    /// *provenance* and *address-space* information. To properly restore that information,\n-    /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    /// This is similar to `self as usize`, which semantically discards *provenance* and\n+    /// *address-space* information. However, unlike `self as usize`, casting the returned address\n+    /// back to a pointer yields [`invalid`][], which is undefined behavior to dereference. To\n+    /// properly restore the lost information and obtain a dereferencable pointer, use\n+    /// [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    ///\n+    /// If using those APIs is not possible because there is no way to preserve a pointer with the\n+    /// required provenance, use [`expose_addr`][pointer::expose_addr] and\n+    /// [`from_exposed_addr`][from_exposed_addr] instead. However, note that this makes\n+    /// your code less portable and less amenable to tools that check for compliance with the Rust\n+    /// memory model.\n     ///\n     /// On most platforms this will produce a value with the same bytes as the original\n     /// pointer, because all the bytes are dedicated to describing the address.\n     /// Platforms which need to store additional information in the pointer may\n     /// perform a change of representation to produce a value containing only the address\n     /// portion of the pointer. What that means is up to the platform to define.\n     ///\n-    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n-    /// see the [module documentation][crate::ptr] for details.\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment, and as such\n+    /// might change in the future (including possibly weakening this so it becomes wholly\n+    /// equivalent to `self as usize`). See the [module documentation][crate::ptr] for details.\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n@@ -175,6 +184,41 @@ impl<T: ?Sized> *const T {\n         self as usize\n     }\n \n+    /// Gets the \"address\" portion of the pointer, and 'exposes' the \"provenance\" part for future\n+    /// use in [`from_exposed_addr`][].\n+    ///\n+    /// This is equivalent to `self as usize`, which semantically discards *provenance* and\n+    /// *address-space* information. Furthermore, this (like the `as` cast) has the implicit\n+    /// side-effect of marking the provenance as 'exposed', so on platforms that support it you can\n+    /// later call [`from_exposed_addr`][] to reconstitute the original pointer including its\n+    /// provenance. (Reconstructing address space information, if required, is your responsibility.)\n+    ///\n+    /// Using this method means that code is *not* following Strict Provenance rules. Supporting\n+    /// [`from_exposed_addr`][] complicates specification and reasoning and may not be supported by\n+    /// tools that help you to stay conformant with the Rust memory model, so it is recommended to\n+    /// use [`addr`][pointer::addr] wherever possible.\n+    ///\n+    /// On most platforms this will produce a value with the same bytes as the original pointer,\n+    /// because all the bytes are dedicated to describing the address. Platforms which need to store\n+    /// additional information in the pointer may not support this operation, since the 'expose'\n+    /// side-effect which is required for [`from_exposed_addr`][] to work is typically not\n+    /// available.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n+    /// [module documentation][crate::ptr] for details.\n+    ///\n+    /// [`from_exposed_addr`]: from_exposed_addr\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn expose_addr(self) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        self as usize\n+    }\n+\n     /// Creates a new pointer with the given address.\n     ///\n     /// This performs the same operation as an `addr as ptr` cast, but copies"}, {"sha": "ba8b0670147aeb69f2a57b26cb40026101f232bd", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 119, "deletions": 9, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/3bf33b9060065b69f22c50d0ec924eaf51da830a/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf33b9060065b69f22c50d0ec924eaf51da830a/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=3bf33b9060065b69f22c50d0ec924eaf51da830a", "patch": "@@ -70,7 +70,7 @@\n //! interpretation of provenance. It's ok if your code doesn't strictly conform to it.**\n //!\n //! [Strict Provenance][] is an experimental set of APIs that help tools that try\n-//! to validate the memory-safety of your program's execution. Notably this includes [miri][]\n+//! to validate the memory-safety of your program's execution. Notably this includes [Miri][]\n //! and [CHERI][], which can detect when you access out of bounds memory or otherwise violate\n //! Rust's memory model.\n //!\n@@ -136,7 +136,7 @@\n //!\n //! The strict provenance experiment is mostly only interested in exploring stricter *spatial*\n //! provenance. In this sense it can be thought of as a subset of the more ambitious and\n-//! formal [Stacked Borrows][] research project, which is what tools like [miri][] are based on.\n+//! formal [Stacked Borrows][] research project, which is what tools like [Miri][] are based on.\n //! In particular, Stacked Borrows is necessary to properly describe what borrows are allowed\n //! to do and when they become invalidated. This necessarily involves much more complex\n //! *temporal* reasoning than simply identifying allocations. Adjusting APIs and code\n@@ -170,7 +170,8 @@\n //! Under Strict Provenance, a usize *cannot* accurately represent a pointer, and converting from\n //! a pointer to a usize is generally an operation which *only* extracts the address. It is\n //! therefore *impossible* to construct a valid pointer from a usize because there is no way\n-//! to restore the address-space and provenance.\n+//! to restore the address-space and provenance. In other words, pointer-integer-pointer\n+//! roundtrips are not possible (in the sense that the resulting pointer is not dereferencable).\n //!\n //! The key insight to making this model *at all* viable is the [`with_addr`][] method:\n //!\n@@ -194,10 +195,10 @@\n //! and then immediately converting back to a pointer. To make this use case more ergonomic,\n //! we provide the [`map_addr`][] method.\n //!\n-//! To help make it clear that code is \"following\" Strict Provenance semantics, we also\n-//! provide an [`addr`][] method which is currently equivalent to `ptr as usize`. In the\n-//! future we may provide a lint for pointer<->integer casts to help you audit if your\n-//! code conforms to strict provenance.\n+//! To help make it clear that code is \"following\" Strict Provenance semantics, we also provide an\n+//! [`addr`][] method which promises that the returned address is not part of a\n+//! pointer-usize-pointer roundtrip. In the future we may provide a lint for pointer<->integer\n+//! casts to help you audit if your code conforms to strict provenance.\n //!\n //!\n //! ## Using Strict Provenance\n@@ -310,6 +311,41 @@\n //!   For instance, ARM explicitly supports high-bit tagging, and so CHERI on ARM inherits\n //!   that and should support it.\n //!\n+//! ## Pointer-usize-pointer roundtrips and 'exposed' provenance\n+//!\n+//! **This section is *non-normative* and is part of the [Strict Provenance] experiment.**\n+//!\n+//! As discussed above, pointer-usize-pointer roundtrips are not possible under [Strict Provenance].\n+//! However, there exists legacy Rust code that is full of such roundtrips, and legacy platform APIs\n+//! regularly assume that `usize` can capture all the information that makes up a pointer. There\n+//! also might be code that cannot be ported to Strict Provenance (which is something we would [like\n+//! to hear about][Strict Provenance]).\n+//!\n+//! For situations like this, there is a fallback plan, a way to 'opt out' of Strict Provenance.\n+//! However, note that this makes your code a lot harder to specify, and the code will not work\n+//! (well) with tools like [Miri] and [CHERI].\n+//!\n+//! This fallback plan is provided by the [`expose_addr`] and [`from_exposed_addr`] methods (which\n+//! are equivalent to `as` casts between pointers and integers). [`expose_addr`] is a lot like\n+//! [`addr`], but additionally adds the provenance of the pointer to a global list of 'exposed'\n+//! provenances. (This list is purely conceptual, it exists for the purpose of specifying Rust but\n+//! is not materialized in actual executions, except in tools like [Miri].) [`from_exposed_addr`]\n+//! can be used to construct a pointer with one of these previously 'exposed' provenances.\n+//! [`from_exposed_addr`] takes only `addr: usize` as arguments, so unlike in [`with_addr`] there is\n+//! no indication of what the correct provenance for the returned pointer is -- and that is exactly\n+//! what makes pointer-usize-pointer roundtrips so tricky to rigorously specify! There is no\n+//! algorithm that decides which provenance will be used. You can think of this as \"guessing\" the\n+//! right provenance, and the guess will be \"maximally in your favor\", in the sense that if there is\n+//! any way to avoid undefined behavior, then that is the guess that will be taken. However, if\n+//! there is *no* previously 'exposed' provenance that justifies the way the returned pointer will\n+//! be used, the program has undefined behavior.\n+//!\n+//! Using [`expose_addr`] or [`from_exposed_addr`] (or the equivalent `as` casts) means that code is\n+//! *not* following Strict Provenance rules. The goal of the Strict Provenance experiment is to\n+//! determine whether it is possible to use Rust without [`expose_addr`] and [`from_exposed_addr`].\n+//! If this is successful, it would be a major win for avoiding specification complexity and to\n+//! facilitate adoption of tools like [CHERI] and [Miri] that can be a big help in increasing the\n+//! confidence in (unsafe) Rust code.\n //!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n@@ -322,7 +358,9 @@\n //! [`map_addr`]: pointer::map_addr\n //! [`addr`]: pointer::addr\n //! [`ptr::invalid`]: core::ptr::invalid\n-//! [miri]: https://github.com/rust-lang/miri\n+//! [`expose_addr`]: pointer::expose_addr\n+//! [`from_exposed_addr`]: from_exposed_addr\n+//! [Miri]: https://github.com/rust-lang/miri\n //! [CHERI]: https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/\n //! [Strict Provenance]: https://github.com/rust-lang/rust/issues/95228\n //! [Stacked Borrows]: https://plv.mpi-sws.org/rustbelt/stacked-borrows/\n@@ -547,6 +585,78 @@ pub const fn invalid_mut<T>(addr: usize) -> *mut T {\n     addr as *mut T\n }\n \n+/// Convert an address back to a pointer, picking up a previously 'exposed' provenance.\n+///\n+/// This is equivalent to `addr as *const T`. The provenance of the returned pointer is that of *any*\n+/// pointer that was previously passed to [`expose_addr`][pointer::expose_addr] or a `ptr as usize`\n+/// cast. If there is no previously 'exposed' provenance that justifies the way this pointer will be\n+/// used, the program has undefined behavior. Note that there is no algorithm that decides which\n+/// provenance will be used. You can think of this as \"guessing\" the right provenance, and the guess\n+/// will be \"maximally in your favor\", in the sense that if there is any way to avoid undefined\n+/// behavior, then that is the guess that will be taken.\n+///\n+/// On platforms with multiple address spaces, it is your responsibility to ensure that the\n+/// address makes sense in the address space that this pointer will be used with.\n+///\n+/// Using this method means that code is *not* following strict provenance rules. \"Guessing\" a\n+/// suitable provenance complicates specification and reasoning and may not be supported by\n+/// tools that help you to stay conformant with the Rust memory model, so it is recommended to\n+/// use [`with_addr`][pointer::with_addr] wherever possible.\n+///\n+/// On most platforms this will produce a value with the same bytes as the address. Platforms\n+/// which need to store additional information in a pointer may not support this operation,\n+/// since it is generally not possible to actually *compute* which provenance the returned\n+/// pointer has to pick up.\n+///\n+/// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n+/// [module documentation][crate::ptr] for details.\n+#[must_use]\n+#[inline]\n+#[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+pub fn from_exposed_addr<T>(addr: usize) -> *const T\n+where\n+    T: Sized,\n+{\n+    // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+    addr as *const T\n+}\n+\n+/// Convert an address back to a mutable pointer, picking up a previously 'exposed' provenance.\n+///\n+/// This is equivalent to `addr as *mut T`. The provenance of the returned pointer is that of *any*\n+/// pointer that was previously passed to [`expose_addr`][pointer::expose_addr] or a `ptr as usize`\n+/// cast. If there is no previously 'exposed' provenance that justifies the way this pointer will be\n+/// used, the program has undefined behavior. Note that there is no algorithm that decides which\n+/// provenance will be used. You can think of this as \"guessing\" the right provenance, and the guess\n+/// will be \"maximally in your favor\", in the sense that if there is any way to avoid undefined\n+/// behavior, then that is the guess that will be taken.\n+///\n+/// On platforms with multiple address spaces, it is your responsibility to ensure that the\n+/// address makes sense in the address space that this pointer will be used with.\n+///\n+/// Using this method means that code is *not* following strict provenance rules. \"Guessing\" a\n+/// suitable provenance complicates specification and reasoning and may not be supported by\n+/// tools that help you to stay conformant with the Rust memory model, so it is recommended to\n+/// use [`with_addr`][pointer::with_addr] wherever possible.\n+///\n+/// On most platforms this will produce a value with the same bytes as the address. Platforms\n+/// which need to store additional information in a pointer may not support this operation,\n+/// since it is generally not possible to actually *compute* which provenance the returned\n+/// pointer has to pick up.\n+///\n+/// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n+/// [module documentation][crate::ptr] for details.\n+#[must_use]\n+#[inline]\n+#[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+pub fn from_exposed_addr_mut<T>(addr: usize) -> *mut T\n+where\n+    T: Sized,\n+{\n+    // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+    addr as *mut T\n+}\n+\n /// Forms a raw slice from a pointer and a length.\n ///\n /// The `len` argument is the number of **elements**, not the number of bytes.\n@@ -763,7 +873,7 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n         );\n     }\n \n-    // NOTE(scottmcm) MIRI is disabled here as reading in smaller units is a\n+    // NOTE(scottmcm) Miri is disabled here as reading in smaller units is a\n     // pessimization for it.  Also, if the type contains any unaligned pointers,\n     // copying those over multiple reads is difficult to support.\n     #[cfg(not(miri))]"}, {"sha": "5db9c3e941eb4946cbfc11d14e1027d2dd96bda6", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3bf33b9060065b69f22c50d0ec924eaf51da830a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf33b9060065b69f22c50d0ec924eaf51da830a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=3bf33b9060065b69f22c50d0ec924eaf51da830a", "patch": "@@ -156,18 +156,27 @@ impl<T: ?Sized> *mut T {\n \n     /// Gets the \"address\" portion of the pointer.\n     ///\n-    /// This is equivalent to `self as usize`, which semantically discards\n-    /// *provenance* and *address-space* information. To properly restore that information,\n-    /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    /// This is similar to `self as usize`, which semantically discards *provenance* and\n+    /// *address-space* information. However, unlike `self as usize`, casting the returned address\n+    /// back to a pointer yields [`invalid`][], which is undefined behavior to dereference. To\n+    /// properly restore the lost information and obtain a dereferencable pointer, use\n+    /// [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    ///\n+    /// If using those APIs is not possible because there is no way to preserve a pointer with the\n+    /// required provenance, use [`expose_addr`][pointer::expose_addr] and\n+    /// [`from_exposed_addr_mut`][from_exposed_addr_mut] instead. However, note that this makes\n+    /// your code less portable and less amenable to tools that check for compliance with the Rust\n+    /// memory model.\n     ///\n     /// On most platforms this will produce a value with the same bytes as the original\n     /// pointer, because all the bytes are dedicated to describing the address.\n     /// Platforms which need to store additional information in the pointer may\n     /// perform a change of representation to produce a value containing only the address\n     /// portion of the pointer. What that means is up to the platform to define.\n     ///\n-    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n-    /// see the [module documentation][crate::ptr] for details.\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment, and as such\n+    /// might change in the future (including possibly weakening this so it becomes wholly\n+    /// equivalent to `self as usize`). See the [module documentation][crate::ptr] for details.\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n@@ -179,6 +188,41 @@ impl<T: ?Sized> *mut T {\n         self as usize\n     }\n \n+    /// Gets the \"address\" portion of the pointer, and 'exposes' the \"provenance\" part for future\n+    /// use in [`from_exposed_addr`][].\n+    ///\n+    /// This is equivalent to `self as usize`, which semantically discards *provenance* and\n+    /// *address-space* information. Furthermore, this (like the `as` cast) has the implicit\n+    /// side-effect of marking the provenance as 'exposed', so on platforms that support it you can\n+    /// later call [`from_exposed_addr_mut`][] to reconstitute the original pointer including its\n+    /// provenance. (Reconstructing address space information, if required, is your responsibility.)\n+    ///\n+    /// Using this method means that code is *not* following Strict Provenance rules. Supporting\n+    /// [`from_exposed_addr_mut`][] complicates specification and reasoning and may not be supported\n+    /// by tools that help you to stay conformant with the Rust memory model, so it is recommended\n+    /// to use [`addr`][pointer::addr] wherever possible.\n+    ///\n+    /// On most platforms this will produce a value with the same bytes as the original pointer,\n+    /// because all the bytes are dedicated to describing the address. Platforms which need to store\n+    /// additional information in the pointer may not support this operation, since the 'expose'\n+    /// side-effect which is required for [`from_exposed_addr_mut`][] to work is typically not\n+    /// available.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n+    /// [module documentation][crate::ptr] for details.\n+    ///\n+    /// [`from_exposed_addr_mut`]: from_exposed_addr_mut\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn expose_addr(self) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        self as usize\n+    }\n+\n     /// Creates a new pointer with the given address.\n     ///\n     /// This performs the same operation as an `addr as ptr` cast, but copies"}]}