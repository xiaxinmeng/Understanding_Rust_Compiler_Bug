{"sha": "799eb105b92a8ef2238b217291ea6169d70acec4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5OWViMTA1YjkyYThlZjIyMzhiMjE3MjkxZWE2MTY5ZDcwYWNlYzQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-04T21:23:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-04T21:34:14Z"}, "message": "Use a linenoise with win32 support", "tree": {"sha": "f14e838ded5a35b3938d5b92745c55f5925c2081", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f14e838ded5a35b3938d5b92745c55f5925c2081"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/799eb105b92a8ef2238b217291ea6169d70acec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/799eb105b92a8ef2238b217291ea6169d70acec4", "html_url": "https://github.com/rust-lang/rust/commit/799eb105b92a8ef2238b217291ea6169d70acec4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/799eb105b92a8ef2238b217291ea6169d70acec4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a450119b0bd454038c483785f652419ab3c3b1c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a450119b0bd454038c483785f652419ab3c3b1c8", "html_url": "https://github.com/rust-lang/rust/commit/a450119b0bd454038c483785f652419ab3c3b1c8"}], "stats": {"total": 1683, "additions": 1358, "deletions": 325}, "files": [{"sha": "35b8426c55548d95cbc48c451e29e32ba4abf450", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -78,7 +78,7 @@ RUNTIME_CXXS_$(1) := \\\n               rt/arch/$$(HOST_$(1))/context.cpp \\\n               rt/arch/$$(HOST_$(1))/gpr.cpp\n \n-RUNTIME_CS_$(1) := rt/linenoise/linenoise.c\n+RUNTIME_CS_$(1) := rt/linenoise/linenoise.c rt/linenoise/utf8.c\n \n RUNTIME_S_$(1) := rt/arch/$$(HOST_$(1))/_context.S \\\n                   rt/arch/$$(HOST_$(1))/ccall.S \\"}, {"sha": "dc09858638211966c4206e7f109ae8b210f7b8bc", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -9,7 +9,6 @@ extern mod rustrt {\n     fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n     fn linenoiseSetCompletionCallback(callback: *u8);\n     fn linenoiseAddCompletion(completions: *(), line: *c_char);\n-    fn linenoiseClearScreen();\n }\n \n /// Add a line to history\n@@ -48,11 +47,6 @@ pub fn read(prompt: ~str) -> Option<~str> {\n     }\n }\n \n-/// Clear the screen\n-pub fn clear() {\n-    rustrt::linenoiseClearScreen();\n-}\n-\n pub type CompletionCb = fn~(~str, fn(~str));\n \n fn complete_key(_v: @CompletionCb) {}"}, {"sha": "f008d2d3d5e38f6c4c29f6a767ca39c62853ce38", "filename": "src/rt/linenoise/README.markdown", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2FREADME.markdown", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2FREADME.markdown", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2FREADME.markdown?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -0,0 +1,47 @@\n+# Linenoise\n+\n+A minimal, zero-config, BSD licensed, readline replacement.\n+\n+News: linenoise now includes minimal completion support, thanks to Pieter Noordhuis (@pnoordhuis).\n+\n+News: linenoise is now part of [Android](http://android.git.kernel.org/?p=platform/system/core.git;a=tree;f=liblinenoise;h=56450eaed7f783760e5e6a5993ef75cde2e29dea;hb=HEAD Android)!\n+\n+## Can a line editing library be 20k lines of code?\n+\n+Line editing with some support for history is a really important feature for command line utilities. Instead of retyping almost the same stuff again and again it's just much better to hit the up arrow and edit on syntax errors, or in order to try a slightly different command. But apparently code dealing with terminals is some sort of Black Magic: readline is 30k lines of code, libedit 20k. Is it reasonable to link small utilities to huge libraries just to get a minimal support for line editing?\n+\n+So what usually happens is either:\n+\n+ * Large programs with configure scripts disabling line editing if readline is not present in the system, or not supporting it at all since readline is GPL licensed and libedit (the BSD clone) is not as known and available as readline is (Real world example of this problem: Tclsh).\n+ * Smaller programs not using a configure script not supporting line editing at all (A problem we had with Redis-cli for instance).\n+ \n+The result is a pollution of binaries without line editing support.\n+\n+So I spent more or less two hours doing a reality check resulting in this little library: is it *really* needed for a line editing library to be 20k lines of code? Apparently not, it is possibe to get a very small, zero configuration, trivial to embed library, that solves the problem. Smaller programs will just include this, supporing line editing out of the box. Larger programs may use this little library or just checking with configure if readline/libedit is available and resorting to linenoise if not.\n+\n+## Terminals, in 2010.\n+\n+Apparently almost every terminal you can happen to use today has some kind of support for VT100 alike escape sequences. So I tried to write a lib using just very basic VT100 features. The resulting library appears to work everywhere I tried to use it.\n+\n+Since it's so young I guess there are a few bugs, or the lib may not compile or work with some operating system, but it's a matter of a few weeks and eventually we'll get it right, and there will be no excuses for not shipping command line tools without built-in line editing support.\n+\n+The library is currently less than 400 lines of code. In order to use it in your project just look at the *example.c* file in the source distribution, it is trivial. Linenoise is BSD code, so you can use both in free software and commercial software.\n+\n+## Tested with...\n+\n+ * Linux text only console ($TERM = linux)\n+ * Linux KDE terminal application ($TERM = xterm)\n+ * Linux xterm ($TERM = xterm)\n+ * Mac OS X iTerm ($TERM = xterm)\n+ * Mac OS X default Terminal.app ($TERM = xterm)\n+ * OpenBSD 4.5 through an OSX Terminal.app ($TERM = screen)\n+ * IBM AIX 6.1\n+ * FreeBSD xterm ($TERM = xterm)\n+\n+Please test it everywhere you can and report back!\n+\n+## Let's push this forward!\n+\n+Please fork it and add something interesting and send me a pull request. What's especially interesting are fixes, new key bindings, completion.\n+\n+Send feedbacks to antirez at gmail"}, {"sha": "cb51a0af8f9259eca7504261e63bb35627f3cc5c", "filename": "src/rt/linenoise/example.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Fexample.c", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Fexample.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Fexample.c?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -0,0 +1,30 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"linenoise.h\"\n+\n+#ifndef NO_COMPLETION\n+void completion(const char *buf, linenoiseCompletions *lc) {\n+    if (buf[0] == 'h') {\n+        linenoiseAddCompletion(lc,\"hello\");\n+        linenoiseAddCompletion(lc,\"hello there\");\n+    }\n+}\n+#endif\n+\n+int main(void) {\n+    char *line;\n+\n+#ifndef NO_COMPLETION\n+    linenoiseSetCompletionCallback(completion);\n+#endif\n+    linenoiseHistoryLoad(\"history.txt\"); /* Load the history at startup */\n+    while((line = linenoise(\"hello> \")) != NULL) {\n+        if (line[0] != '\\0') {\n+            printf(\"echo: '%s'\\n\", line);\n+            linenoiseHistoryAdd(line);\n+            linenoiseHistorySave(\"history.txt\"); /* Save every new entry */\n+        }\n+        free(line);\n+    }\n+    return 0;\n+}"}, {"sha": "5e3216e4591d719df286f4ce4c886fcb17232cce", "filename": "src/rt/linenoise/linenoise.c", "status": "modified", "additions": 1073, "deletions": 308, "changes": 1381, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Flinenoise.c", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Flinenoise.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.c?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -2,8 +2,9 @@\n  * line editing lib needs to be 20,000 lines of C code.\n  *\n  * You can find the latest source code at:\n- * \n- *   http://github.com/antirez/linenoise\n+ *\n+ *   http://github.com/msteveb/linenoise\n+ *   (forked from http://github.com/antirez/linenoise)\n  *\n  * Does a number of crazy assumptions that happen to be true in 99.9999% of\n  * the 2010 UNIX computers around.\n@@ -12,20 +13,21 @@\n  *\n  * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>\n  * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n+ * Copyright (c) 2011, Steve Bennett <steveb at workware dot net dot au>\n  *\n  * All rights reserved.\n- * \n+ *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions are\n  * met:\n- * \n+ *\n  *  *  Redistributions of source code must retain the above copyright\n  *     notice, this list of conditions and the following disclaimer.\n  *\n  *  *  Redistributions in binary form must reproduce the above copyright\n  *     notice, this list of conditions and the following disclaimer in the\n  *     documentation and/or other materials provided with the distribution.\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n@@ -37,31 +39,23 @@\n  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- * \n+ *\n  * ------------------------------------------------------------------------\n  *\n  * References:\n  * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n  * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\n  *\n- * Todo list:\n- * - Switch to gets() if $TERM is something we can't support.\n- * - Filter bogus Ctrl+<char> combinations.\n- * - Win32 support\n- *\n  * Bloat:\n  * - Completion?\n- * - History search like Ctrl+r in readline?\n  *\n+ * Unix/termios\n+ * ------------\n  * List of escape sequences used by this program, we do everything just\n- * with three sequences. In order to be so cheap we may have some\n+ * a few sequences. In order to be so cheap we may have some\n  * flickering effect with some slow terminal, but the lesser sequences\n  * the more compatible.\n  *\n- * CHA (Cursor Horizontal Absolute)\n- *    Sequence: ESC [ n G\n- *    Effect: moves cursor to column n\n- *\n  * EL (Erase Line)\n  *    Sequence: ESC [ n K\n  *    Effect: if n is 0 or missing, clear from cursor to end of line\n@@ -72,6 +66,10 @@\n  *    Sequence: ESC [ n C\n  *    Effect: moves cursor forward of n chars\n  *\n+ * CR (Carriage Return)\n+ *    Sequence: \\r\n+ *    Effect: moves cursor to column 1\n+ *\n  * The following are used to clear the screen: ESC [ H ESC [ 2 J\n  * This is actually composed of two sequences:\n  *\n@@ -82,65 +80,154 @@\n  * ED2 (Clear entire screen)\n  *    Sequence: ESC [ 2 J\n  *    Effect: clear the whole screen\n- * \n+ *\n+ * == For highlighting control characters, we also use the following two ==\n+ * SO (enter StandOut)\n+ *    Sequence: ESC [ 7 m\n+ *    Effect: Uses some standout mode such as reverse video\n+ *\n+ * SE (Standout End)\n+ *    Sequence: ESC [ 0 m\n+ *    Effect: Exit standout mode\n+ *\n+ * == Only used if TIOCGWINSZ fails ==\n+ * DSR/CPR (Report cursor position)\n+ *    Sequence: ESC [ 6 n\n+ *    Effect: reports current cursor position as ESC [ NNN ; MMM R\n+ *\n+ * win32/console\n+ * -------------\n+ * If __MINGW32__ is defined, the win32 console API is used.\n+ * This could probably be made to work for the msvc compiler too.\n+ * This support based in part on work by Jon Griffiths.\n  */\n \n+#ifdef _WIN32 /* Windows platform, either MinGW or Visual Studio (MSVC) */\n+#include <windows.h>\n+#include <fcntl.h>\n+#define USE_WINCONSOLE\n+#ifdef __MINGW32__\n+#define HAVE_UNISTD_H\n+#else\n+/* Microsoft headers don't like old POSIX names */\n+#define strdup _strdup\n+#define snprintf _snprintf\n+#endif\n+#else\n #include <termios.h>\n+#include <sys/ioctl.h>\n+#include <sys/poll.h>\n+#define USE_TERMIOS\n+#define HAVE_UNISTD_H\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n #include <unistd.h>\n+#endif\n #include <stdlib.h>\n+#include <stdarg.h>\n #include <stdio.h>\n #include <errno.h>\n #include <string.h>\n #include <stdlib.h>\n #include <sys/types.h>\n-#include <sys/ioctl.h>\n-#include <unistd.h>\n+\n #include \"linenoise.h\"\n+#include \"utf8.h\"\n \n #define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100\n #define LINENOISE_MAX_LINE 4096\n-static char *unsupported_term[] = {\"dumb\",\"cons25\",NULL};\n-static linenoiseCompletionCallback *completionCallback = NULL;\n \n-static struct termios orig_termios; /* in order to restore at exit */\n-static int rawmode = 0; /* for atexit() function to check if restore is needed*/\n-static int atexit_registered = 0; /* register atexit just 1 time */\n+#define ctrl(C) ((C) - '@')\n+\n+/* Use -ve numbers here to co-exist with normal unicode chars */\n+enum {\n+    SPECIAL_NONE,\n+    SPECIAL_UP = -20,\n+    SPECIAL_DOWN = -21,\n+    SPECIAL_LEFT = -22,\n+    SPECIAL_RIGHT = -23,\n+    SPECIAL_DELETE = -24,\n+    SPECIAL_HOME = -25,\n+    SPECIAL_END = -26,\n+};\n+\n static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;\n static int history_len = 0;\n-char **history = NULL;\n+static char **history = NULL;\n \n-static void linenoiseAtExit(void);\n-int linenoiseHistoryAdd(const char *line);\n+/* Structure to contain the status of the current (being edited) line */\n+struct current {\n+    char *buf;  /* Current buffer. Always null terminated */\n+    int bufmax; /* Size of the buffer, including space for the null termination */\n+    int len;    /* Number of bytes in 'buf' */\n+    int chars;  /* Number of chars in 'buf' (utf-8 chars) */\n+    int pos;    /* Cursor position, measured in chars */\n+    int cols;   /* Size of the window, in chars */\n+    const char *prompt;\n+#if defined(USE_TERMIOS)\n+    int fd;     /* Terminal fd */\n+#elif defined(USE_WINCONSOLE)\n+    HANDLE outh; /* Console output handle */\n+    HANDLE inh; /* Console input handle */\n+    int rows;   /* Screen rows */\n+    int x;      /* Current column during output */\n+    int y;      /* Current row */\n+#endif\n+};\n \n-static int isUnsupportedTerm(void) {\n-    char *term = getenv(\"TERM\");\n-    int j;\n+static int fd_read(struct current *current);\n+static int getWindowSize(struct current *current);\n \n-    if (term == NULL) return 0;\n-    for (j = 0; unsupported_term[j]; j++)\n-        if (!strcasecmp(term,unsupported_term[j])) return 1;\n-    return 0;\n-}\n-\n-static void freeHistory(void) {\n+void linenoiseHistoryFree(void) {\n     if (history) {\n         int j;\n \n         for (j = 0; j < history_len; j++)\n             free(history[j]);\n         free(history);\n+        history = NULL;\n+    }\n+}\n+\n+#if defined(USE_TERMIOS)\n+static void linenoiseAtExit(void);\n+static struct termios orig_termios; /* in order to restore at exit */\n+static int rawmode = 0; /* for atexit() function to check if restore is needed*/\n+static int atexit_registered = 0; /* register atexit just 1 time */\n+\n+static const char *unsupported_term[] = {\"dumb\",\"cons25\",NULL};\n+\n+static int isUnsupportedTerm(void) {\n+    char *term = getenv(\"TERM\");\n+\n+    if (term) {\n+        int j;\n+        for (j = 0; unsupported_term[j]; j++) {\n+            if (strcasecmp(term, unsupported_term[j]) == 0) {\n+                return 1;\n+            }\n+        }\n     }\n+    return 0;\n }\n \n-static int enableRawMode(int fd) {\n+static int enableRawMode(struct current *current) {\n     struct termios raw;\n \n-    if (!isatty(STDIN_FILENO)) goto fatal;\n+    current->fd = STDIN_FILENO;\n+\n+    if (!isatty(current->fd) || isUnsupportedTerm() ||\n+        tcgetattr(current->fd, &orig_termios) == -1) {\n+fatal:\n+        errno = ENOTTY;\n+        return -1;\n+    }\n+\n     if (!atexit_registered) {\n         atexit(linenoiseAtExit);\n         atexit_registered = 1;\n     }\n-    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;\n \n     raw = orig_termios;  /* modify the original mode */\n     /* input modes: no break, no CR to NL, no parity check, no strip char,\n@@ -158,118 +245,675 @@ static int enableRawMode(int fd) {\n     raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n \n     /* put terminal in raw mode after flushing */\n-    if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;\n+    if (tcsetattr(current->fd,TCSADRAIN,&raw) < 0) {\n+        goto fatal;\n+    }\n     rawmode = 1;\n-    return 0;\n \n-fatal:\n-    errno = ENOTTY;\n-    return -1;\n+    current->cols = 0;\n+    return 0;\n }\n \n-static void disableRawMode(int fd) {\n+static void disableRawMode(struct current *current) {\n     /* Don't even check the return value as it's too late. */\n-    if (rawmode && tcsetattr(fd,TCSAFLUSH,&orig_termios) != -1)\n+    if (rawmode && tcsetattr(current->fd,TCSADRAIN,&orig_termios) != -1)\n         rawmode = 0;\n }\n \n /* At exit we'll try to fix the terminal to the initial conditions. */\n static void linenoiseAtExit(void) {\n-    disableRawMode(STDIN_FILENO);\n-    freeHistory();\n+    if (rawmode) {\n+        tcsetattr(STDIN_FILENO, TCSADRAIN, &orig_termios);\n+    }\n+    linenoiseHistoryFree();\n }\n \n-static int getColumns(void) {\n+/* gcc/glibc insists that we care about the return code of write! */\n+#define IGNORE_RC(EXPR) if (EXPR) {}\n+\n+/* This is fdprintf() on some systems, but use a different\n+ * name to avoid conflicts\n+ */\n+static void fd_printf(int fd, const char *format, ...)\n+{\n+    va_list args;\n+    char buf[64];\n+    int n;\n+\n+    va_start(args, format);\n+    n = vsnprintf(buf, sizeof(buf), format, args);\n+    va_end(args);\n+    IGNORE_RC(write(fd, buf, n));\n+}\n+\n+static void clearScreen(struct current *current)\n+{\n+    fd_printf(current->fd, \"\\x1b[H\\x1b[2J\");\n+}\n+\n+static void cursorToLeft(struct current *current)\n+{\n+    fd_printf(current->fd, \"\\r\");\n+}\n+\n+static int outputChars(struct current *current, const char *buf, int len)\n+{\n+    return write(current->fd, buf, len);\n+}\n+\n+static void outputControlChar(struct current *current, char ch)\n+{\n+    fd_printf(current->fd, \"\\x1b[7m^%c\\x1b[0m\", ch);\n+}\n+\n+static void eraseEol(struct current *current)\n+{\n+    fd_printf(current->fd, \"\\x1b[0K\");\n+}\n+\n+static void setCursorPos(struct current *current, int x)\n+{\n+    fd_printf(current->fd, \"\\r\\x1b[%dC\", x);\n+}\n+\n+/**\n+ * Reads a char from 'fd', waiting at most 'timeout' milliseconds.\n+ *\n+ * A timeout of -1 means to wait forever.\n+ *\n+ * Returns -1 if no char is received within the time or an error occurs.\n+ */\n+static int fd_read_char(int fd, int timeout)\n+{\n+    struct pollfd p;\n+    unsigned char c;\n+\n+    p.fd = fd;\n+    p.events = POLLIN;\n+\n+    if (poll(&p, 1, timeout) == 0) {\n+        /* timeout */\n+        return -1;\n+    }\n+    if (read(fd, &c, 1) != 1) {\n+        return -1;\n+    }\n+    return c;\n+}\n+\n+/**\n+ * Reads a complete utf-8 character\n+ * and returns the unicode value, or -1 on error.\n+ */\n+static int fd_read(struct current *current)\n+{\n+#ifdef USE_UTF8\n+    char buf[4];\n+    int n;\n+    int i;\n+    int c;\n+\n+    if (read(current->fd, &buf[0], 1) != 1) {\n+        return -1;\n+    }\n+    n = utf8_charlen(buf[0]);\n+    if (n < 1 || n > 3) {\n+        return -1;\n+    }\n+    for (i = 1; i < n; i++) {\n+        if (read(current->fd, &buf[i], 1) != 1) {\n+            return -1;\n+        }\n+    }\n+    buf[n] = 0;\n+    /* decode and return the character */\n+    utf8_tounicode(buf, &c);\n+    return c;\n+#else\n+    return fd_read_char(current->fd, -1);\n+#endif\n+}\n+\n+static int getWindowSize(struct current *current)\n+{\n     struct winsize ws;\n \n-    if (ioctl(1, TIOCGWINSZ, &ws) == -1) return 80;\n-    return ws.ws_col;\n+    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 && ws.ws_col != 0) {\n+        current->cols = ws.ws_col;\n+        return 0;\n+    }\n+\n+    /* Failed to query the window size. Perhaps we are on a serial terminal.\n+     * Try to query the width by sending the cursor as far to the right\n+     * and reading back the cursor position.\n+     * Note that this is only done once per call to linenoise rather than\n+     * every time the line is refreshed for efficiency reasons.\n+     */\n+    if (current->cols == 0) {\n+        current->cols = 80;\n+\n+        /* Move cursor far right and report cursor position, then back to the left */\n+        fd_printf(current->fd, \"\\x1b[999C\" \"\\x1b[6n\");\n+\n+        /* Parse the response: ESC [ rows ; cols R */\n+        if (fd_read_char(current->fd, 100) == 0x1b && fd_read_char(current->fd, 100) == '[') {\n+            int n = 0;\n+            while (1) {\n+                int ch = fd_read_char(current->fd, 100);\n+                if (ch == ';') {\n+                    /* Ignore rows */\n+                    n = 0;\n+                }\n+                else if (ch == 'R') {\n+                    /* Got cols */\n+                    if (n != 0 && n < 1000) {\n+                        current->cols = n;\n+                    }\n+                    break;\n+                }\n+                else if (ch >= 0 && ch <= '9') {\n+                    n = n * 10 + ch - '0';\n+                }\n+                else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    return 0;\n+}\n+\n+/**\n+ * If escape (27) was received, reads subsequent\n+ * chars to determine if this is a known special key.\n+ *\n+ * Returns SPECIAL_NONE if unrecognised, or -1 if EOF.\n+ *\n+ * If no additional char is received within a short time,\n+ * 27 is returned.\n+ */\n+static int check_special(int fd)\n+{\n+    int c = fd_read_char(fd, 50);\n+    int c2;\n+\n+    if (c < 0) {\n+        return 27;\n+    }\n+\n+    c2 = fd_read_char(fd, 50);\n+    if (c2 < 0) {\n+        return c2;\n+    }\n+    if (c == '[' || c == 'O') {\n+        /* Potential arrow key */\n+        switch (c2) {\n+            case 'A':\n+                return SPECIAL_UP;\n+            case 'B':\n+                return SPECIAL_DOWN;\n+            case 'C':\n+                return SPECIAL_RIGHT;\n+            case 'D':\n+                return SPECIAL_LEFT;\n+            case 'F':\n+                return SPECIAL_END;\n+            case 'H':\n+                return SPECIAL_HOME;\n+        }\n+    }\n+    if (c == '[' && c2 >= '1' && c2 <= '8') {\n+        /* extended escape */\n+        c = fd_read_char(fd, 50);\n+        if (c == '~') {\n+            switch (c2) {\n+                case '3':\n+                    return SPECIAL_DELETE;\n+                case '7':\n+                    return SPECIAL_HOME;\n+                case '8':\n+                    return SPECIAL_END;\n+            }\n+        }\n+        while (c != -1 && c != '~') {\n+            /* .e.g \\e[12~ or '\\e[11;2~   discard the complete sequence */\n+            c = fd_read_char(fd, 50);\n+        }\n+    }\n+\n+    return SPECIAL_NONE;\n+}\n+#elif defined(USE_WINCONSOLE)\n+\n+static DWORD orig_consolemode = 0;\n+\n+static int enableRawMode(struct current *current) {\n+    DWORD n;\n+    INPUT_RECORD irec;\n+\n+    current->outh = GetStdHandle(STD_OUTPUT_HANDLE);\n+    current->inh = GetStdHandle(STD_INPUT_HANDLE);\n+\n+    if (!PeekConsoleInput(current->inh, &irec, 1, &n)) {\n+        return -1;\n+    }\n+    if (getWindowSize(current) != 0) {\n+        return -1;\n+    }\n+    if (GetConsoleMode(current->inh, &orig_consolemode)) {\n+        SetConsoleMode(current->inh, ENABLE_PROCESSED_INPUT);\n+    }\n+    return 0;\n+}\n+\n+static void disableRawMode(struct current *current)\n+{\n+    SetConsoleMode(current->inh, orig_consolemode);\n+}\n+\n+static void clearScreen(struct current *current)\n+{\n+    COORD topleft = { 0, 0 };\n+    DWORD n;\n+\n+    FillConsoleOutputCharacter(current->outh, ' ',\n+        current->cols * current->rows, topleft, &n);\n+    FillConsoleOutputAttribute(current->outh,\n+        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN,\n+        current->cols * current->rows, topleft, &n);\n+    SetConsoleCursorPosition(current->outh, topleft);\n+}\n+\n+static void cursorToLeft(struct current *current)\n+{\n+    COORD pos = { 0, (SHORT)current->y };\n+    DWORD n;\n+\n+    FillConsoleOutputAttribute(current->outh,\n+        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN, current->cols, pos, &n);\n+    current->x = 0;\n+}\n+\n+static int outputChars(struct current *current, const char *buf, int len)\n+{\n+    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n+    DWORD n;\n+\t\n+    WriteConsoleOutputCharacter(current->outh, buf, len, pos, &n);\n+    current->x += len;\n+    return 0;\n+}\n+\n+static void outputControlChar(struct current *current, char ch)\n+{\n+    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n+    DWORD n;\n+\n+    FillConsoleOutputAttribute(current->outh, BACKGROUND_INTENSITY, 2, pos, &n);\n+    outputChars(current, \"^\", 1);\n+    outputChars(current, &ch, 1);\n+}\n+\n+static void eraseEol(struct current *current)\n+{\n+    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n+    DWORD n;\n+\n+    FillConsoleOutputCharacter(current->outh, ' ', current->cols - current->x, pos, &n);\n+}\n+\n+static void setCursorPos(struct current *current, int x)\n+{\n+    COORD pos = { (SHORT)x, (SHORT)current->y };\n+\n+    SetConsoleCursorPosition(current->outh, pos);\n+    current->x = x;\n+}\n+\n+static int fd_read(struct current *current)\n+{\n+    while (1) {\n+        INPUT_RECORD irec;\n+        DWORD n;\n+        if (WaitForSingleObject(current->inh, INFINITE) != WAIT_OBJECT_0) {\n+            break;\n+        }\n+        if (!ReadConsoleInput (current->inh, &irec, 1, &n)) {\n+            break;\n+        }\n+        if (irec.EventType == KEY_EVENT && irec.Event.KeyEvent.bKeyDown) {\n+            KEY_EVENT_RECORD *k = &irec.Event.KeyEvent;\n+            if (k->dwControlKeyState & ENHANCED_KEY) {\n+                switch (k->wVirtualKeyCode) {\n+                 case VK_LEFT:\n+                    return SPECIAL_LEFT;\n+                 case VK_RIGHT:\n+                    return SPECIAL_RIGHT;\n+                 case VK_UP:\n+                    return SPECIAL_UP;\n+                 case VK_DOWN:\n+                    return SPECIAL_DOWN;\n+                 case VK_DELETE:\n+                    return SPECIAL_DELETE;\n+                 case VK_HOME:\n+                    return SPECIAL_HOME;\n+                 case VK_END:\n+                    return SPECIAL_END;\n+                }\n+            }\n+            /* Note that control characters are already translated in AsciiChar */\n+            else {\n+#ifdef USE_UTF8\n+                return k->uChar.UnicodeChar;\n+#else\n+                return k->uChar.AsciiChar;\n+#endif\n+            }\n+        }\n+    }\n+    return -1;\n+}\n+\n+static int getWindowSize(struct current *current)\n+{\n+    CONSOLE_SCREEN_BUFFER_INFO info;\n+    if (!GetConsoleScreenBufferInfo(current->outh, &info)) {\n+        return -1;\n+    }\n+    current->cols = info.dwSize.X;\n+    current->rows = info.dwSize.Y;\n+    if (current->cols <= 0 || current->rows <= 0) {\n+        current->cols = 80;\n+        return -1;\n+    }\n+    current->y = info.dwCursorPosition.Y;\n+    current->x = info.dwCursorPosition.X;\n+    return 0;\n+}\n+#endif\n+\n+static int utf8_getchars(char *buf, int c)\n+{\n+#ifdef USE_UTF8\n+    return utf8_fromunicode(buf, c);\n+#else\n+    *buf = c;\n+    return 1;\n+#endif\n+}\n+\n+/**\n+ * Returns the unicode character at the given offset,\n+ * or -1 if none.\n+ */\n+static int get_char(struct current *current, int pos)\n+{\n+    if (pos >= 0 && pos < current->chars) {\n+        int c;\n+        int i = utf8_index(current->buf, pos);\n+        (void)utf8_tounicode(current->buf + i, &c);\n+        return c;\n+    }\n+    return -1;\n }\n \n-static void refreshLine(int fd, const char *prompt, char *buf, size_t len, size_t pos, size_t cols) {\n-    char seq[64];\n-    size_t plen = strlen(prompt);\n-    \n-    while((plen+pos) >= cols) {\n-        buf++;\n-        len--;\n+static void refreshLine(const char *prompt, struct current *current)\n+{\n+    int plen;\n+    int pchars;\n+    int backup = 0;\n+    int i;\n+    const char *buf = current->buf;\n+    int chars = current->chars;\n+    int pos = current->pos;\n+    int b;\n+    int ch;\n+    int n;\n+\n+    /* Should intercept SIGWINCH. For now, just get the size every time */\n+    getWindowSize(current);\n+\n+    plen = strlen(prompt);\n+    pchars = utf8_strlen(prompt, plen);\n+\n+    /* Account for a line which is too long to fit in the window.\n+     * Note that control chars require an extra column\n+     */\n+\n+    /* How many cols are required to the left of 'pos'?\n+     * The prompt, plus one extra for each control char\n+     */\n+    n = pchars + utf8_strlen(buf, current->len);\n+    b = 0;\n+    for (i = 0; i < pos; i++) {\n+        b += utf8_tounicode(buf + b, &ch);\n+        if (ch < ' ') {\n+            n++;\n+        }\n+    }\n+\n+    /* If too many are need, strip chars off the front of 'buf'\n+     * until it fits. Note that if the current char is a control character,\n+     * we need one extra col.\n+     */\n+    if (current->pos < current->chars && get_char(current, current->pos) < ' ') {\n+        n++;\n+    }\n+\n+    while (n >= current->cols && pos > 0) {\n+        b = utf8_tounicode(buf, &ch);\n+        if (ch < ' ') {\n+            n--;\n+        }\n+        n--;\n+        buf += b;\n         pos--;\n+        chars--;\n+    }\n+\n+    /* Cursor to left edge, then the prompt */\n+    cursorToLeft(current);\n+    outputChars(current, prompt, plen);\n+\n+    /* Now the current buffer content */\n+\n+    /* Need special handling for control characters.\n+     * If we hit 'cols', stop.\n+     */\n+    b = 0; /* unwritted bytes */\n+    n = 0; /* How many control chars were written */\n+    for (i = 0; i < chars; i++) {\n+        int ch;\n+        int w = utf8_tounicode(buf + b, &ch);\n+        if (ch < ' ') {\n+            n++;\n+        }\n+        if (pchars + i + n >= current->cols) {\n+            break;\n+        }\n+        if (ch < ' ') {\n+            /* A control character, so write the buffer so far */\n+            outputChars(current, buf, b);\n+            buf += b + w;\n+            b = 0;\n+            outputControlChar(current, ch + '@');\n+            if (i < pos) {\n+                backup++;\n+            }\n+        }\n+        else {\n+            b += w;\n+        }\n+    }\n+    outputChars(current, buf, b);\n+\n+    /* Erase to right, move cursor to original position */\n+    eraseEol(current);\n+    setCursorPos(current, pos + pchars + backup);\n+}\n+\n+static void set_current(struct current *current, const char *str)\n+{\n+    strncpy(current->buf, str, current->bufmax);\n+    current->buf[current->bufmax - 1] = 0;\n+    current->len = strlen(current->buf);\n+    current->pos = current->chars = utf8_strlen(current->buf, current->len);\n+}\n+\n+static int has_room(struct current *current, int bytes)\n+{\n+    return current->len + bytes < current->bufmax - 1;\n+}\n+\n+/**\n+ * Removes the char at 'pos'.\n+ *\n+ * Returns 1 if the line needs to be refreshed, 2 if not\n+ * and 0 if nothing was removed\n+ */\n+static int remove_char(struct current *current, int pos)\n+{\n+    if (pos >= 0 && pos < current->chars) {\n+        int p1, p2;\n+        int ret = 1;\n+        p1 = utf8_index(current->buf, pos);\n+        p2 = p1 + utf8_index(current->buf + p1, 1);\n+\n+#ifdef USE_TERMIOS\n+        /* optimise remove char in the case of removing the last char */\n+        if (current->pos == pos + 1 && current->pos == current->chars) {\n+            if (current->buf[pos] >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {\n+                ret = 2;\n+                fd_printf(current->fd, \"\\b \\b\");\n+            }\n+        }\n+#endif\n+\n+        /* Move the null char too */\n+        memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1);\n+        current->len -= (p2 - p1);\n+        current->chars--;\n+\n+        if (current->pos > pos) {\n+            current->pos--;\n+        }\n+        return ret;\n     }\n-    while (plen+len > cols) {\n-        len--;\n+    return 0;\n+}\n+\n+/**\n+ * Insert 'ch' at position 'pos'\n+ *\n+ * Returns 1 if the line needs to be refreshed, 2 if not\n+ * and 0 if nothing was inserted (no room)\n+ */\n+static int insert_char(struct current *current, int pos, int ch)\n+{\n+    char buf[3];\n+    int n = utf8_getchars(buf, ch);\n+\n+    if (has_room(current, n) && pos >= 0 && pos <= current->chars) {\n+        int p1, p2;\n+        int ret = 1;\n+        p1 = utf8_index(current->buf, pos);\n+        p2 = p1 + n;\n+\n+#ifdef USE_TERMIOS\n+        /* optimise the case where adding a single char to the end and no scrolling is needed */\n+        if (current->pos == pos && current->chars == pos) {\n+            if (ch >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {\n+                IGNORE_RC(write(current->fd, buf, n));\n+                ret = 2;\n+            }\n+        }\n+#endif\n+\n+        memmove(current->buf + p2, current->buf + p1, current->len - p1);\n+        memcpy(current->buf + p1, buf, n);\n+        current->len += n;\n+\n+        current->chars++;\n+        if (current->pos >= pos) {\n+            current->pos++;\n+        }\n+        return ret;\n     }\n+    return 0;\n+}\n \n-    /* Cursor to left edge */\n-    snprintf(seq,64,\"\\x1b[0G\");\n-    if (write(fd,seq,strlen(seq)) == -1) return;\n-    /* Write the prompt and the current buffer content */\n-    if (write(fd,prompt,strlen(prompt)) == -1) return;\n-    if (write(fd,buf,len) == -1) return;\n-    /* Erase to right */\n-    snprintf(seq,64,\"\\x1b[0K\");\n-    if (write(fd,seq,strlen(seq)) == -1) return;\n-    /* Move cursor to original position. */\n-    snprintf(seq,64,\"\\x1b[0G\\x1b[%dC\", (int)(pos+plen));\n-    if (write(fd,seq,strlen(seq)) == -1) return;\n+/**\n+ * Returns 0 if no chars were removed or non-zero otherwise.\n+ */\n+static int remove_chars(struct current *current, int pos, int n)\n+{\n+    int removed = 0;\n+    while (n-- && remove_char(current, pos)) {\n+        removed++;\n+    }\n+    return removed;\n }\n \n+#ifndef NO_COMPLETION\n+static linenoiseCompletionCallback *completionCallback = NULL;\n+\n static void beep() {\n+#ifdef USE_TERMIOS\n     fprintf(stderr, \"\\x7\");\n     fflush(stderr);\n+#endif\n }\n \n static void freeCompletions(linenoiseCompletions *lc) {\n     size_t i;\n     for (i = 0; i < lc->len; i++)\n         free(lc->cvec[i]);\n-    if (lc->cvec != NULL)\n-        free(lc->cvec);\n+    free(lc->cvec);\n }\n \n-static int completeLine(int fd, const char *prompt, char *buf, size_t buflen, size_t *len, size_t *pos, size_t cols) {\n+static int completeLine(struct current *current) {\n     linenoiseCompletions lc = { 0, NULL };\n-    int nread, nwritten;\n-    char c = 0;\n+    int c = 0;\n \n-    completionCallback(buf,&lc);\n+    completionCallback(current->buf,&lc);\n     if (lc.len == 0) {\n         beep();\n     } else {\n         size_t stop = 0, i = 0;\n-        size_t clen;\n \n         while(!stop) {\n             /* Show completion or original buffer */\n             if (i < lc.len) {\n-                clen = strlen(lc.cvec[i]);\n-                refreshLine(fd,prompt,lc.cvec[i],clen,clen,cols);\n+                struct current tmp = *current;\n+                tmp.buf = lc.cvec[i];\n+                tmp.pos = tmp.len = strlen(tmp.buf);\n+                tmp.chars = utf8_strlen(tmp.buf, tmp.len);\n+                refreshLine(current->prompt, &tmp);\n             } else {\n-                refreshLine(fd,prompt,buf,*len,*pos,cols);\n+                refreshLine(current->prompt, current);\n             }\n \n-            nread = read(fd,&c,1);\n-            if (nread <= 0) {\n-                freeCompletions(&lc);\n-                return -1;\n+            c = fd_read(current);\n+            if (c == -1) {\n+                break;\n             }\n \n             switch(c) {\n-                case 9: /* tab */\n+                case '\\t': /* tab */\n                     i = (i+1) % (lc.len+1);\n                     if (i == lc.len) beep();\n                     break;\n                 case 27: /* escape */\n                     /* Re-show original buffer */\n                     if (i < lc.len) {\n-                        refreshLine(fd,prompt,buf,*len,*pos,cols);\n+                        refreshLine(current->prompt, current);\n                     }\n                     stop = 1;\n                     break;\n                 default:\n                     /* Update buffer and return */\n                     if (i < lc.len) {\n-                        nwritten = snprintf(buf,buflen,\"%s\",lc.cvec[i]);\n-                        *len = *pos = nwritten;\n+                        set_current(current,lc.cvec[i]);\n                     }\n                     stop = 1;\n                     break;\n@@ -281,270 +925,335 @@ static int completeLine(int fd, const char *prompt, char *buf, size_t buflen, si\n     return c; /* Return last read character */\n }\n \n-void linenoiseClearScreen(void) {\n-    if (write(STDIN_FILENO,\"\\x1b[H\\x1b[2J\",7) <= 0) {\n-        /* nothing to do, just to avoid warning. */\n-    }\n+/* Register a callback function to be called for tab-completion. */\n+void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {\n+    completionCallback = fn;\n }\n \n-static int linenoisePrompt(int fd, char *buf, size_t buflen, const char *prompt) {\n-    size_t plen = strlen(prompt);\n-    size_t pos = 0;\n-    size_t len = 0;\n-    size_t cols = getColumns();\n-    int history_index = 0;\n-    size_t old_pos;\n-    size_t diff;\n+void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {\n+    lc->cvec = (char **)realloc(lc->cvec,sizeof(char*)*(lc->len+1));\n+    lc->cvec[lc->len++] = strdup(str);\n+}\n \n-    buf[0] = '\\0';\n-    buflen--; /* Make sure there is always space for the nulterm */\n+#endif\n+\n+static int linenoisePrompt(struct current *current) {\n+    int history_index = 0;\n \n     /* The latest history entry is always our current buffer, that\n      * initially is just an empty string. */\n     linenoiseHistoryAdd(\"\");\n-    \n-    if (write(fd,prompt,plen) == -1) return -1;\n-    while(1) {\n-        char c;\n-        int nread;\n-        char seq[2], seq2[2];\n \n-        nread = read(fd,&c,1);\n-        if (nread <= 0) return len;\n+    set_current(current, \"\");\n+    refreshLine(current->prompt, current);\n \n+    while(1) {\n+        int dir = -1;\n+        int c = fd_read(current);\n+\n+#ifndef NO_COMPLETION\n         /* Only autocomplete when the callback is set. It returns < 0 when\n          * there was an error reading from fd. Otherwise it will return the\n          * character that should be handled next. */\n-        if (c == 9 && completionCallback != NULL) {\n-            c = completeLine(fd,prompt,buf,buflen,&len,&pos,cols);\n+        if (c == '\\t' && current->pos == current->chars && completionCallback != NULL) {\n+            c = completeLine(current);\n             /* Return on errors */\n-            if (c < 0) return len;\n+            if (c < 0) return current->len;\n             /* Read next character when 0 */\n             if (c == 0) continue;\n         }\n+#endif\n \n+process_char:\n+        if (c == -1) return current->len;\n+#ifdef USE_TERMIOS\n+        if (c == 27) {   /* escape sequence */\n+            c = check_special(current->fd);\n+        }\n+#endif\n         switch(c) {\n-        case 13:    /* enter */\n+        case '\\r':    /* enter */\n             history_len--;\n             free(history[history_len]);\n-            return (int)len;\n-        case 3:     /* ctrl-c */\n+            return current->len;\n+        case ctrl('C'):     /* ctrl-c */\n             errno = EAGAIN;\n             return -1;\n         case 127:   /* backspace */\n-        case 8:     /* ctrl-h */\n-            if (pos > 0 && len > 0) {\n-                memmove(buf+pos-1,buf+pos,len-pos);\n-                pos--;\n-                len--;\n-                buf[len] = '\\0';\n-                refreshLine(fd,prompt,buf,len,pos,cols);\n+        case ctrl('H'):\n+            if (remove_char(current, current->pos - 1) == 1) {\n+                refreshLine(current->prompt, current);\n             }\n             break;\n-        case 4:     /* ctrl-d, remove char at right of cursor */\n-            if (len > 1 && pos < (len-1)) {\n-                memmove(buf+pos,buf+pos+1,len-pos);\n-                len--;\n-                buf[len] = '\\0';\n-                refreshLine(fd,prompt,buf,len,pos,cols);\n-            } else if (len == 0) {\n+        case ctrl('D'):     /* ctrl-d */\n+            if (current->len == 0) {\n+                /* Empty line, so EOF */\n                 history_len--;\n                 free(history[history_len]);\n                 return -1;\n             }\n-            break;\n-        case 20:    /* ctrl-t */\n-            if (pos > 0 && pos < len) {\n-                int aux = buf[pos-1];\n-                buf[pos-1] = buf[pos];\n-                buf[pos] = aux;\n-                if (pos != len-1) pos++;\n-                refreshLine(fd,prompt,buf,len,pos,cols);\n+            /* Otherwise fall through to delete char to right of cursor */\n+        case SPECIAL_DELETE:\n+            if (remove_char(current, current->pos) == 1) {\n+                refreshLine(current->prompt, current);\n             }\n             break;\n-        case 2:     /* ctrl-b */\n-            goto left_arrow;\n-        case 6:     /* ctrl-f */\n-            goto right_arrow;\n-        case 16:    /* ctrl-p */\n-            seq[1] = 65;\n-            goto up_down_arrow;\n-        case 14:    /* ctrl-n */\n-            seq[1] = 66;\n-            goto up_down_arrow;\n-            break;\n-        case 27:    /* escape sequence */\n-            if (read(fd,seq,2) == -1) break;\n-            if (seq[0] == 91 && seq[1] == 68) {\n-left_arrow:\n-                /* left arrow */\n-                if (pos > 0) {\n+        case ctrl('W'):    /* ctrl-w */\n+            /* eat any spaces on the left */\n+            {\n+                int pos = current->pos;\n+                while (pos > 0 && get_char(current, pos - 1) == ' ') {\n                     pos--;\n-                    refreshLine(fd,prompt,buf,len,pos,cols);\n                 }\n-            } else if (seq[0] == 91 && seq[1] == 67) {\n-right_arrow:\n-                /* right arrow */\n-                if (pos != len) {\n-                    pos++;\n-                    refreshLine(fd,prompt,buf,len,pos,cols);\n+\n+                /* now eat any non-spaces on the left */\n+                while (pos > 0 && get_char(current, pos - 1) != ' ') {\n+                    pos--;\n                 }\n-            } else if (seq[0] == 91 && (seq[1] == 65 || seq[1] == 66)) {\n-up_down_arrow:\n-                /* up and down arrow: history */\n-                if (history_len > 1) {\n-                    /* Update the current history entry before to\n-                     * overwrite it with tne next one. */\n-                    free(history[history_len-1-history_index]);\n-                    history[history_len-1-history_index] = strdup(buf);\n-                    /* Show the new entry */\n-                    history_index += (seq[1] == 65) ? 1 : -1;\n-                    if (history_index < 0) {\n-                        history_index = 0;\n-                        break;\n-                    } else if (history_index >= history_len) {\n-                        history_index = history_len-1;\n+\n+                if (remove_chars(current, pos, current->pos - pos)) {\n+                    refreshLine(current->prompt, current);\n+                }\n+            }\n+            break;\n+        case ctrl('R'):    /* ctrl-r */\n+            {\n+                /* Display the reverse-i-search prompt and process chars */\n+                char rbuf[50];\n+                char rprompt[80];\n+                int rchars = 0;\n+                int rlen = 0;\n+                int searchpos = history_len - 1;\n+\n+                rbuf[0] = 0;\n+                while (1) {\n+                    int n = 0;\n+                    const char *p = NULL;\n+                    int skipsame = 0;\n+                    int searchdir = -1;\n+\n+                    snprintf(rprompt, sizeof(rprompt), \"(reverse-i-search)'%s': \", rbuf);\n+                    refreshLine(rprompt, current);\n+                    c = fd_read(current);\n+                    if (c == ctrl('H') || c == 127) {\n+                        if (rchars) {\n+                            int p = utf8_index(rbuf, --rchars);\n+                            rbuf[p] = 0;\n+                            rlen = strlen(rbuf);\n+                        }\n+                        continue;\n+                    }\n+#ifdef USE_TERMIOS\n+                    if (c == 27) {\n+                        c = check_special(current->fd);\n+                    }\n+#endif\n+                    if (c == ctrl('P') || c == SPECIAL_UP) {\n+                        /* Search for the previous (earlier) match */\n+                        if (searchpos > 0) {\n+                            searchpos--;\n+                        }\n+                        skipsame = 1;\n+                    }\n+                    else if (c == ctrl('N') || c == SPECIAL_DOWN) {\n+                        /* Search for the next (later) match */\n+                        if (searchpos < history_len) {\n+                            searchpos++;\n+                        }\n+                        searchdir = 1;\n+                        skipsame = 1;\n+                    }\n+                    else if (c >= ' ') {\n+                        if (rlen >= (int)sizeof(rbuf) + 3) {\n+                            continue;\n+                        }\n+\n+                        n = utf8_getchars(rbuf + rlen, c);\n+                        rlen += n;\n+                        rchars++;\n+                        rbuf[rlen] = 0;\n+\n+                        /* Adding a new char resets the search location */\n+                        searchpos = history_len - 1;\n+                    }\n+                    else {\n+                        /* Exit from incremental search mode */\n                         break;\n                     }\n-                    strncpy(buf,history[history_len-1-history_index],buflen);\n-                    buf[buflen] = '\\0';\n-                    len = pos = strlen(buf);\n-                    refreshLine(fd,prompt,buf,len,pos,cols);\n-                }\n-            } else if (seq[0] == 91 && seq[1] > 48 && seq[1] < 55) {\n-                /* extended escape */\n-                if (read(fd,seq2,2) == -1) break;\n-                if (seq[1] == 51 && seq2[0] == 126) {\n-                    /* delete */\n-                    if (len > 0 && pos < len) {\n-                        memmove(buf+pos,buf+pos+1,len-pos-1);\n-                        len--;\n-                        buf[len] = '\\0';\n-                        refreshLine(fd,prompt,buf,len,pos,cols);\n+\n+                    /* Now search through the history for a match */\n+                    for (; searchpos >= 0 && searchpos < history_len; searchpos += searchdir) {\n+                        p = strstr(history[searchpos], rbuf);\n+                        if (p) {\n+                            /* Found a match */\n+                            if (skipsame && strcmp(history[searchpos], current->buf) == 0) {\n+                                /* But it is identical, so skip it */\n+                                continue;\n+                            }\n+                            /* Copy the matching line and set the cursor position */\n+                            set_current(current,history[searchpos]);\n+                            current->pos = utf8_strlen(history[searchpos], p - history[searchpos]);\n+                            break;\n+                        }\n+                    }\n+                    if (!p && n) {\n+                        /* No match, so don't add it */\n+                        rchars--;\n+                        rlen -= n;\n+                        rbuf[rlen] = 0;\n                     }\n                 }\n+                if (c == ctrl('G') || c == ctrl('C')) {\n+                    /* ctrl-g terminates the search with no effect */\n+                    set_current(current, \"\");\n+                    c = 0;\n+                }\n+                else if (c == ctrl('J')) {\n+                    /* ctrl-j terminates the search leaving the buffer in place */\n+                    c = 0;\n+                }\n+                /* Go process the char normally */\n+                refreshLine(current->prompt, current);\n+                goto process_char;\n             }\n             break;\n-        default:\n-            if (len < buflen) {\n-                if (len == pos) {\n-                    buf[pos] = c;\n-                    pos++;\n-                    len++;\n-                    buf[len] = '\\0';\n-                    if (plen+len < cols) {\n-                        /* Avoid a full update of the line in the\n-                         * trivial case. */\n-                        if (write(fd,&c,1) == -1) return -1;\n-                    } else {\n-                        refreshLine(fd,prompt,buf,len,pos,cols);\n+        case ctrl('T'):    /* ctrl-t */\n+            if (current->pos > 0 && current->pos < current->chars) {\n+                c = get_char(current, current->pos);\n+                remove_char(current, current->pos);\n+                insert_char(current, current->pos - 1, c);\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('V'):    /* ctrl-v */\n+            if (has_room(current, 3)) {\n+                /* Insert the ^V first */\n+                if (insert_char(current, current->pos, c)) {\n+                    refreshLine(current->prompt, current);\n+                    /* Now wait for the next char. Can insert anything except \\0 */\n+                    c = fd_read(current);\n+\n+                    /* Remove the ^V first */\n+                    remove_char(current, current->pos - 1);\n+                    if (c != -1) {\n+                        /* Insert the actual char */\n+                        insert_char(current, current->pos, c);\n                     }\n-                } else {\n-                    memmove(buf+pos+1,buf+pos,len-pos);\n-                    buf[pos] = c;\n-                    len++;\n-                    pos++;\n-                    buf[len] = '\\0';\n-                    refreshLine(fd,prompt,buf,len,pos,cols);\n+                    refreshLine(current->prompt, current);\n                 }\n             }\n             break;\n-        case 21: /* Ctrl+u, delete the whole line. */\n-            buf[0] = '\\0';\n-            pos = len = 0;\n-            refreshLine(fd,prompt,buf,len,pos,cols);\n+        case ctrl('B'):\n+        case SPECIAL_LEFT:\n+            if (current->pos > 0) {\n+                current->pos--;\n+                refreshLine(current->prompt, current);\n+            }\n             break;\n-        case 11: /* Ctrl+k, delete from current to end of line. */\n-            buf[pos] = '\\0';\n-            len = pos;\n-            refreshLine(fd,prompt,buf,len,pos,cols);\n+        case ctrl('F'):\n+        case SPECIAL_RIGHT:\n+            if (current->pos < current->chars) {\n+                current->pos++;\n+                refreshLine(current->prompt, current);\n+            }\n             break;\n-        case 1: /* Ctrl+a, go to the start of the line */\n-            pos = 0;\n-            refreshLine(fd,prompt,buf,len,pos,cols);\n+        case ctrl('P'):\n+        case SPECIAL_UP:\n+            dir = 1;\n+        case ctrl('N'):\n+        case SPECIAL_DOWN:\n+            if (history_len > 1) {\n+                /* Update the current history entry before to\n+                 * overwrite it with tne next one. */\n+                free(history[history_len-1-history_index]);\n+                history[history_len-1-history_index] = strdup(current->buf);\n+                /* Show the new entry */\n+                history_index += dir;\n+                if (history_index < 0) {\n+                    history_index = 0;\n+                    break;\n+                } else if (history_index >= history_len) {\n+                    history_index = history_len-1;\n+                    break;\n+                }\n+                set_current(current, history[history_len-1-history_index]);\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('A'): /* Ctrl+a, go to the start of the line */\n+        case SPECIAL_HOME:\n+            current->pos = 0;\n+            refreshLine(current->prompt, current);\n             break;\n-        case 5: /* ctrl+e, go to the end of the line */\n-            pos = len;\n-            refreshLine(fd,prompt,buf,len,pos,cols);\n+        case ctrl('E'): /* ctrl+e, go to the end of the line */\n+        case SPECIAL_END:\n+            current->pos = current->chars;\n+            refreshLine(current->prompt, current);\n             break;\n-        case 12: /* ctrl+l, clear screen */\n-            linenoiseClearScreen();\n-            refreshLine(fd,prompt,buf,len,pos,cols);\n+        case ctrl('U'): /* Ctrl+u, delete to beginning of line. */\n+            if (remove_chars(current, 0, current->pos)) {\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('K'): /* Ctrl+k, delete from current to end of line. */\n+            if (remove_chars(current, current->pos, current->chars - current->pos)) {\n+                refreshLine(current->prompt, current);\n+            }\n             break;\n-        case 23: /* ctrl+w, delete previous word */\n-            old_pos = pos;\n-            while (pos > 0 && buf[pos-1] == ' ')\n-                pos--;\n-            while (pos > 0 && buf[pos-1] != ' ')\n-                pos--;\n-            diff = old_pos - pos;\n-            memmove(&buf[pos], &buf[old_pos], len-old_pos+1);\n-            len -= diff;\n-            refreshLine(fd,prompt,buf,len,pos,cols);\n+        case ctrl('L'): /* Ctrl+L, clear screen */\n+            clearScreen(current);\n+            /* Force recalc of window size for serial terminals */\n+            current->cols = 0;\n+            refreshLine(current->prompt, current);\n+            break;\n+        default:\n+            /* Only tab is allowed without ^V */\n+            if (c == '\\t' || c >= ' ') {\n+                if (insert_char(current, current->pos, c) == 1) {\n+                    refreshLine(current->prompt, current);\n+                }\n+            }\n             break;\n         }\n     }\n-    return len;\n+    return current->len;\n }\n \n-static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {\n-    int fd = STDIN_FILENO;\n+char *linenoise(const char *prompt)\n+{\n     int count;\n+    struct current current;\n+    char buf[LINENOISE_MAX_LINE];\n \n-    if (buflen == 0) {\n-        errno = EINVAL;\n-        return -1;\n-    }\n-    if (!isatty(STDIN_FILENO)) {\n-        if (fgets(buf, buflen, stdin) == NULL) return -1;\n+    if (enableRawMode(&current) == -1) {\n+\tprintf(\"%s\", prompt);\n+        fflush(stdout);\n+        if (fgets(buf, sizeof(buf), stdin) == NULL) {\n+\t\treturn NULL;\n+        }\n         count = strlen(buf);\n         if (count && buf[count-1] == '\\n') {\n             count--;\n             buf[count] = '\\0';\n         }\n-    } else {\n-        if (enableRawMode(fd) == -1) return -1;\n-        count = linenoisePrompt(fd, buf, buflen, prompt);\n-        disableRawMode(fd);\n-        printf(\"\\n\");\n     }\n-    return count;\n-}\n-\n-char *linenoise(const char *prompt) {\n-    char buf[LINENOISE_MAX_LINE];\n-    int count;\n-\n-    if (isUnsupportedTerm()) {\n-        size_t len;\n+    else\n+    {\n+        current.buf = buf;\n+        current.bufmax = sizeof(buf);\n+        current.len = 0;\n+        current.chars = 0;\n+        current.pos = 0;\n+        current.prompt = prompt;\n \n-        printf(\"%s\",prompt);\n-        fflush(stdout);\n-        if (fgets(buf,LINENOISE_MAX_LINE,stdin) == NULL) return NULL;\n-        len = strlen(buf);\n-        while(len && (buf[len-1] == '\\n' || buf[len-1] == '\\r')) {\n-            len--;\n-            buf[len] = '\\0';\n+        count = linenoisePrompt(&current);\n+        disableRawMode(&current);\n+        printf(\"\\n\");\n+        if (count == -1) {\n+            return NULL;\n         }\n-        return strdup(buf);\n-    } else {\n-        count = linenoiseRaw(buf,LINENOISE_MAX_LINE,prompt);\n-        if (count == -1) return NULL;\n-        return strdup(buf);\n     }\n-}\n-\n-/* Register a callback function to be called for tab-completion. */\n-void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {\n-    completionCallback = fn;\n-}\n-\n-void linenoiseAddCompletion(linenoiseCompletions *lc, char *str) {\n-    size_t len = strlen(str);\n-    char *copy = malloc(len+1);\n-    memcpy(copy,str,len+1);\n-    lc->cvec = realloc(lc->cvec,sizeof(char*)*(lc->len+1));\n-    lc->cvec[lc->len++] = copy;\n+    return strdup(buf);\n }\n \n /* Using a circular buffer is smarter, but a bit more complex to handle. */\n@@ -553,10 +1262,16 @@ int linenoiseHistoryAdd(const char *line) {\n \n     if (history_max_len == 0) return 0;\n     if (history == NULL) {\n-        history = malloc(sizeof(char*)*history_max_len);\n+        history = (char **)malloc(sizeof(char*)*history_max_len);\n         if (history == NULL) return 0;\n         memset(history,0,(sizeof(char*)*history_max_len));\n     }\n+\n+    /* do not insert duplicate lines into history */\n+    if (history_len > 0 && strcmp(line, history[history_len - 1]) == 0) {\n+        return 0;\n+    }\n+\n     linecopy = strdup(line);\n     if (!linecopy) return 0;\n     if (history_len == history_max_len) {\n@@ -570,18 +1285,18 @@ int linenoiseHistoryAdd(const char *line) {\n }\n \n int linenoiseHistorySetMaxLen(int len) {\n-    char **new;\n+    char **newHistory;\n \n     if (len < 1) return 0;\n     if (history) {\n         int tocopy = history_len;\n \n-        new = malloc(sizeof(char*)*len);\n-        if (new == NULL) return 0;\n+        newHistory = (char **)malloc(sizeof(char*)*len);\n+        if (newHistory == NULL) return 0;\n         if (len < tocopy) tocopy = len;\n-        memcpy(new,history+(history_max_len-tocopy), sizeof(char*)*tocopy);\n+        memcpy(newHistory,history+(history_max_len-tocopy), sizeof(char*)*tocopy);\n         free(history);\n-        history = new;\n+        history = newHistory;\n     }\n     history_max_len = len;\n     if (history_len > history_max_len)\n@@ -591,13 +1306,32 @@ int linenoiseHistorySetMaxLen(int len) {\n \n /* Save the history in the specified file. On success 0 is returned\n  * otherwise -1 is returned. */\n-int linenoiseHistorySave(char *filename) {\n+int linenoiseHistorySave(const char *filename) {\n     FILE *fp = fopen(filename,\"w\");\n     int j;\n-    \n+\n     if (fp == NULL) return -1;\n-    for (j = 0; j < history_len; j++)\n-        fprintf(fp,\"%s\\n\",history[j]);\n+    for (j = 0; j < history_len; j++) {\n+        const char *str = history[j];\n+        /* Need to encode backslash, nl and cr */\n+        while (*str) {\n+            if (*str == '\\\\') {\n+                fputs(\"\\\\\\\\\", fp);\n+            }\n+            else if (*str == '\\n') {\n+                fputs(\"\\\\n\", fp);\n+            }\n+            else if (*str == '\\r') {\n+                fputs(\"\\\\r\", fp);\n+            }\n+            else {\n+                fputc(*str, fp);\n+            }\n+            str++;\n+        }\n+        fputc('\\n', fp);\n+    }\n+\n     fclose(fp);\n     return 0;\n }\n@@ -607,20 +1341,51 @@ int linenoiseHistorySave(char *filename) {\n  *\n  * If the file exists and the operation succeeded 0 is returned, otherwise\n  * on error -1 is returned. */\n-int linenoiseHistoryLoad(char *filename) {\n+int linenoiseHistoryLoad(const char *filename) {\n     FILE *fp = fopen(filename,\"r\");\n     char buf[LINENOISE_MAX_LINE];\n-    \n+\n     if (fp == NULL) return -1;\n \n     while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {\n-        char *p;\n-        \n-        p = strchr(buf,'\\r');\n-        if (!p) p = strchr(buf,'\\n');\n-        if (p) *p = '\\0';\n+        char *src, *dest;\n+\n+        /* Decode backslash escaped values */\n+        for (src = dest = buf; *src; src++) {\n+            char ch = *src;\n+\n+            if (ch == '\\\\') {\n+                src++;\n+                if (*src == 'n') {\n+                    ch = '\\n';\n+                }\n+                else if (*src == 'r') {\n+                    ch = '\\r';\n+                } else {\n+                    ch = *src;\n+                }\n+            }\n+            *dest++ = ch;\n+        }\n+        /* Remove trailing newline */\n+        if (dest != buf && (dest[-1] == '\\n' || dest[-1] == '\\r')) {\n+            dest--;\n+        }\n+        *dest = 0;\n+\n         linenoiseHistoryAdd(buf);\n     }\n     fclose(fp);\n     return 0;\n }\n+\n+/* Provide access to the history buffer.\n+ *\n+ * If 'len' is not NULL, the length is stored in *len.\n+ */\n+char **linenoiseHistory(int *len) {\n+    if (len) {\n+        *len = history_len;\n+    }\n+    return history;\n+}"}, {"sha": "59f28976d67e5a7280526c803f8da71dee8533ce", "filename": "src/rt/linenoise/linenoise.h", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Flinenoise.h", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Flinenoise.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.h?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -9,18 +9,18 @@\n  * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n  *\n  * All rights reserved.\n- * \n+ *\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions are\n  * met:\n- * \n+ *\n  *  *  Redistributions of source code must retain the above copyright\n  *     notice, this list of conditions and the following disclaimer.\n  *\n  *  *  Redistributions in binary form must reproduce the above copyright\n  *     notice, this list of conditions and the following disclaimer in the\n  *     documentation and/or other materials provided with the distribution.\n- * \n+ *\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n@@ -37,20 +37,23 @@\n #ifndef __LINENOISE_H\n #define __LINENOISE_H\n \n+#ifndef NO_COMPLETION\n typedef struct linenoiseCompletions {\n   size_t len;\n   char **cvec;\n } linenoiseCompletions;\n \n typedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);\n void linenoiseSetCompletionCallback(linenoiseCompletionCallback *);\n-void linenoiseAddCompletion(linenoiseCompletions *, char *);\n+void linenoiseAddCompletion(linenoiseCompletions *, const char *);\n+#endif\n \n char *linenoise(const char *prompt);\n int linenoiseHistoryAdd(const char *line);\n int linenoiseHistorySetMaxLen(int len);\n-int linenoiseHistorySave(char *filename);\n-int linenoiseHistoryLoad(char *filename);\n-void linenoiseClearScreen(void);\n+int linenoiseHistorySave(const char *filename);\n+int linenoiseHistoryLoad(const char *filename);\n+void linenoiseHistoryFree(void);\n+char **linenoiseHistory(int *len);\n \n-#endif /* __LINENOISE_H */\n\\ No newline at end of file\n+#endif /* __LINENOISE_H */"}, {"sha": "26924b46c19154755c904038c949a98b033e3c50", "filename": "src/rt/linenoise/utf8.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Futf8.c", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Futf8.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Futf8.c?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -0,0 +1,115 @@\n+/**\n+ * UTF-8 utility functions\n+ *\n+ * (c) 2010 Steve Bennett <steveb@workware.net.au>\n+ *\n+ * See LICENCE for licence details.\n+ */\n+\n+#include <ctype.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include \"utf8.h\"\n+\n+#ifdef USE_UTF8\n+int utf8_fromunicode(char *p, unsigned short uc)\n+{\n+    if (uc <= 0x7f) {\n+        *p = uc;\n+        return 1;\n+    }\n+    else if (uc <= 0x7ff) {\n+        *p++ = 0xc0 | ((uc & 0x7c0) >> 6);\n+        *p = 0x80 | (uc & 0x3f);\n+        return 2;\n+    }\n+    else {\n+        *p++ = 0xe0 | ((uc & 0xf000) >> 12);\n+        *p++ = 0x80 | ((uc & 0xfc0) >> 6);\n+        *p = 0x80 | (uc & 0x3f);\n+        return 3;\n+    }\n+}\n+\n+int utf8_charlen(int c)\n+{\n+    if ((c & 0x80) == 0) {\n+        return 1;\n+    }\n+    if ((c & 0xe0) == 0xc0) {\n+        return 2;\n+    }\n+    if ((c & 0xf0) == 0xe0) {\n+        return 3;\n+    }\n+    if ((c & 0xf8) == 0xf0) {\n+        return 4;\n+    }\n+    /* Invalid sequence */\n+    return -1;\n+}\n+\n+int utf8_strlen(const char *str, int bytelen)\n+{\n+    int charlen = 0;\n+    if (bytelen < 0) {\n+        bytelen = strlen(str);\n+    }\n+    while (bytelen) {\n+        int c;\n+        int l = utf8_tounicode(str, &c);\n+        charlen++;\n+        str += l;\n+        bytelen -= l;\n+    }\n+    return charlen;\n+}\n+\n+int utf8_index(const char *str, int index)\n+{\n+    const char *s = str;\n+    while (index--) {\n+        int c;\n+        s += utf8_tounicode(s, &c);\n+    }\n+    return s - str;\n+}\n+\n+int utf8_charequal(const char *s1, const char *s2)\n+{\n+    int c1, c2;\n+\n+    utf8_tounicode(s1, &c1);\n+    utf8_tounicode(s2, &c2);\n+\n+    return c1 == c2;\n+}\n+\n+int utf8_tounicode(const char *str, int *uc)\n+{\n+    unsigned const char *s = (unsigned const char *)str;\n+\n+    if (s[0] < 0xc0) {\n+        *uc = s[0];\n+        return 1;\n+    }\n+    if (s[0] < 0xe0) {\n+        if ((s[1] & 0xc0) == 0x80) {\n+            *uc = ((s[0] & ~0xc0) << 6) | (s[1] & ~0x80);\n+            return 2;\n+        }\n+    }\n+    else if (s[0] < 0xf0) {\n+        if (((str[1] & 0xc0) == 0x80) && ((str[2] & 0xc0) == 0x80)) {\n+            *uc = ((s[0] & ~0xe0) << 12) | ((s[1] & ~0x80) << 6) | (s[2] & ~0x80);\n+            return 3;\n+        }\n+    }\n+\n+    /* Invalid sequence, so just return the byte */\n+    *uc = *s;\n+    return 1;\n+}\n+\n+#endif"}, {"sha": "9537939876ae091451500330b488485f740361f7", "filename": "src/rt/linenoise/utf8.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Futf8.h", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Flinenoise%2Futf8.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Futf8.h?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -0,0 +1,79 @@\n+#ifndef UTF8_UTIL_H\n+#define UTF8_UTIL_H\n+/**\n+ * UTF-8 utility functions\n+ *\n+ * (c) 2010 Steve Bennett <steveb@workware.net.au>\n+ *\n+ * See LICENCE for licence details.\n+ */\n+\n+#ifndef USE_UTF8\n+#include <ctype.h>\n+\n+/* No utf-8 support. 1 byte = 1 char */\n+#define utf8_strlen(S, B) ((B) < 0 ? (int)strlen(S) : (B))\n+#define utf8_tounicode(S, CP) (*(CP) = (unsigned char)*(S), 1)\n+#define utf8_index(C, I) (I)\n+#define utf8_charlen(C) 1\n+\n+#else\n+/**\n+ * Converts the given unicode codepoint (0 - 0xffff) to utf-8\n+ * and stores the result at 'p'.\n+ * \n+ * Returns the number of utf-8 characters (1-3).\n+ */\n+int utf8_fromunicode(char *p, unsigned short uc);\n+\n+/**\n+ * Returns the length of the utf-8 sequence starting with 'c'.\n+ * \n+ * Returns 1-4, or -1 if this is not a valid start byte.\n+ *\n+ * Note that charlen=4 is not supported by the rest of the API.\n+ */\n+int utf8_charlen(int c);\n+\n+/**\n+ * Returns the number of characters in the utf-8 \n+ * string of the given byte length.\n+ *\n+ * Any bytes which are not part of an valid utf-8\n+ * sequence are treated as individual characters.\n+ *\n+ * The string *must* be null terminated.\n+ *\n+ * Does not support unicode code points > \\uffff\n+ */\n+int utf8_strlen(const char *str, int bytelen);\n+\n+/**\n+ * Returns the byte index of the given character in the utf-8 string.\n+ * \n+ * The string *must* be null terminated.\n+ *\n+ * This will return the byte length of a utf-8 string\n+ * if given the char length.\n+ */\n+int utf8_index(const char *str, int charindex);\n+\n+/**\n+ * Returns the unicode codepoint corresponding to the\n+ * utf-8 sequence 'str'.\n+ * \n+ * Stores the result in *uc and returns the number of bytes\n+ * consumed.\n+ *\n+ * If 'str' is null terminated, then an invalid utf-8 sequence\n+ * at the end of the string will be returned as individual bytes.\n+ *\n+ * If it is not null terminated, the length *must* be checked first.\n+ *\n+ * Does not support unicode code points > \\uffff\n+ */\n+int utf8_tounicode(const char *str, int *uc);\n+\n+#endif\n+\n+#endif"}, {"sha": "0668479a48d0aaae2ddfec519f1a5d055c6b9ab2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -211,4 +211,3 @@ linenoiseHistoryAdd\n linenoiseHistorySetMaxLen\n linenoiseHistorySave\n linenoiseHistoryLoad\n-linenoiseClearScreen"}, {"sha": "5f1cad3ae17ce6544e0c65246dfc6a03c6cd2453", "filename": "src/rusti/rusti.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eb105b92a8ef2238b217291ea6169d70acec4/src%2Frusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frusti%2Frusti.rs?ref=799eb105b92a8ef2238b217291ea6169d70acec4", "patch": "@@ -243,7 +243,8 @@ fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n             repl.view_items = ~\"\";\n             repl.stmts = ~\"\";\n \n-            rl::clear();\n+            // FIXME: Win32 version of linenoise doesn't have the required function\n+            //rl::clear();\n         }\n         ~\"help\" => {\n             io::println(~\":clear - clear the screen\\n\" +"}]}