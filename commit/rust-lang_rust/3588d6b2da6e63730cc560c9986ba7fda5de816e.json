{"sha": "3588d6b2da6e63730cc560c9986ba7fda5de816e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ODhkNmIyZGE2ZTYzNzMwY2M1NjBjOTk4NmJhN2ZkYTVkZTgxNmU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-01T13:18:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-01T13:18:02Z"}, "message": "add gen_lsp_server", "tree": {"sha": "beb948f7527836c2c3e1c4b9dcc2dd2a79a16abf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beb948f7527836c2c3e1c4b9dcc2dd2a79a16abf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3588d6b2da6e63730cc560c9986ba7fda5de816e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3588d6b2da6e63730cc560c9986ba7fda5de816e", "html_url": "https://github.com/rust-lang/rust/commit/3588d6b2da6e63730cc560c9986ba7fda5de816e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3588d6b2da6e63730cc560c9986ba7fda5de816e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5669dfc56b2b64d79f368eefed13dd75a6f027b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5669dfc56b2b64d79f368eefed13dd75a6f027b", "html_url": "https://github.com/rust-lang/rust/commit/f5669dfc56b2b64d79f368eefed13dd75a6f027b"}], "stats": {"total": 312, "additions": 312, "deletions": 0}, "files": [{"sha": "b31884802afa178b514f964be18c19560ae8cea6", "filename": "crates/gen_lsp_server/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fgen_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fgen_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2FCargo.toml?ref=3588d6b2da6e63730cc560c9986ba7fda5de816e", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"gen_lsp_server\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+languageserver-types = \"0.49.0\"\n+log = \"0.4.3\"\n+\n+failure = \"0.1.2\"\n+serde_json = \"1.0.24\"\n+serde = \"1.0.71\"\n+serde_derive = \"1.0.71\"\n+crossbeam-channel = \"0.2.4\""}, {"sha": "a31e90f35d96403b362e281668fbfd44283b4984", "filename": "crates/gen_lsp_server/src/lib.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs?ref=3588d6b2da6e63730cc560c9986ba7fda5de816e", "patch": "@@ -0,0 +1,77 @@\n+#[macro_use]\n+extern crate failure;\n+#[macro_use]\n+extern crate log;\n+extern crate serde;\n+extern crate serde_json;\n+#[macro_use]\n+extern crate serde_derive;\n+extern crate crossbeam_channel;\n+extern crate languageserver_types;\n+\n+mod msg;\n+mod stdio;\n+\n+use crossbeam_channel::{Sender, Receiver};\n+use languageserver_types::{\n+    ServerCapabilities, InitializeResult,\n+    request::{Initialize},\n+    notification::{Initialized, Exit},\n+};\n+\n+pub type Result<T> = ::std::result::Result<T, failure::Error>;\n+pub use {\n+    msg::{RawMessage, RawRequest, RawResponse, RawResponseError, RawNotification},\n+    stdio::{stdio_transport, Threads},\n+};\n+\n+pub type LspServer = fn(&mut Receiver<RawMessage>, &mut Sender<RawMessage>) -> Result<()>;\n+\n+pub fn run_server(\n+    caps: ServerCapabilities,\n+    server: LspServer,\n+    mut receiver: Receiver<RawMessage>,\n+    mut sender: Sender<RawMessage>,\n+) -> Result<()> {\n+    info!(\"lsp server initializes\");\n+    initialize(&mut receiver, &mut sender, caps)?;\n+    info!(\"lsp server initialized, serving requests\");\n+    server(&mut receiver, &mut sender)?;\n+    info!(\"lsp server waiting for exit notification\");\n+    match receiver.recv() {\n+        Some(RawMessage::Notification(n)) => {\n+            n.cast::<Exit>().map_err(|n| format_err!(\n+                \"unexpected notification during shutdown: {:?}\", n\n+            ))?\n+        }\n+        m => bail!(\"unexpected message during shutdown: {:?}\", m)\n+    }\n+    info!(\"lsp server shutdown complete\");\n+    Ok(())\n+}\n+\n+fn initialize(\n+    receiver: &mut Receiver<RawMessage>,\n+    sender: &mut Sender<RawMessage>,\n+    caps: ServerCapabilities,\n+) -> Result<()> {\n+    let id = match receiver.recv() {\n+        Some(RawMessage::Request(req)) => match req.cast::<Initialize>() {\n+            Err(req) => bail!(\"expected initialize request, got {:?}\", req),\n+            Ok(req) => req.0,\n+        }\n+        msg =>\n+            bail!(\"expected initialize request, got {:?}\", msg),\n+    };\n+    let resp = RawResponse::ok(id, InitializeResult { capabilities: caps });\n+    sender.send(RawMessage::Response(resp));\n+    match receiver.recv() {\n+        Some(RawMessage::Notification(n)) => {\n+            n.cast::<Initialized>().map_err(|_| format_err!(\n+                \"expected initialized notification\"\n+            ))?;\n+        }\n+        _ => bail!(\"expected initialized notification\"),\n+    }\n+    Ok(())\n+}"}, {"sha": "9426e98ec77f370b599d7c7443b9436fcd853a27", "filename": "crates/gen_lsp_server/src/msg.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs?ref=3588d6b2da6e63730cc560c9986ba7fda5de816e", "patch": "@@ -0,0 +1,172 @@\n+use std::io::{BufRead, Write};\n+\n+use serde_json::{Value, from_str, to_string, from_value, to_value};\n+use serde::{Serialize, de::DeserializeOwned};\n+use languageserver_types::{\n+    request::Request,\n+    notification::Notification,\n+};\n+\n+use Result;\n+\n+#[derive(Debug, Serialize, Deserialize)]\n+#[serde(untagged)]\n+pub enum RawMessage {\n+    Request(RawRequest),\n+    Notification(RawNotification),\n+    Response(RawResponse),\n+}\n+\n+#[derive(Debug, Serialize, Deserialize)]\n+pub struct RawRequest {\n+    pub id: u64,\n+    pub method: String,\n+    pub params: Value,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize)]\n+pub struct RawResponse {\n+    // JSON RPC allows this to be null if it was impossible\n+    // to decode the request's id. Ignore this special case\n+    // and just die horribly.\n+    pub id: u64,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub result: Option<Value>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub error: Option<RawResponseError>,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize)]\n+pub struct RawResponseError {\n+    pub code: i32,\n+    pub message: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub data: Option<Value>,\n+}\n+\n+#[allow(unused)]\n+pub enum ErrorCode {\n+    ParseError = -32700,\n+    InvalidRequest = -32600,\n+    MethodNotFound = -32601,\n+    InvalidParams = -32602,\n+    InternalError = -32603,\n+    ServerErrorStart = -32099,\n+    ServerErrorEnd = -32000,\n+    ServerNotInitialized = -32002,\n+    UnknownErrorCode = -32001,\n+    RequestCancelled = -32800,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize)]\n+pub struct RawNotification {\n+    pub method: String,\n+    pub params: Value,\n+}\n+\n+impl RawMessage {\n+    pub fn read(r: &mut impl BufRead) -> Result<Option<RawMessage>> {\n+        let text = match read_msg_text(r)? {\n+            None => return Ok(None),\n+            Some(text) => text,\n+        };\n+        let msg = from_str(&text)?;\n+        Ok(Some(msg))\n+    }\n+    pub fn write(self, w: &mut impl Write) -> Result<()> {\n+        #[derive(Serialize)]\n+        struct JsonRpc {\n+            jsonrpc: &'static str,\n+            #[serde(flatten)]\n+            msg: RawMessage,\n+        }\n+        let text = to_string(&JsonRpc { jsonrpc: \"2.0\", msg: self })?;\n+        write_msg_text(w, &text)?;\n+        Ok(())\n+    }\n+}\n+\n+impl RawRequest {\n+    pub fn cast<R>(self) -> ::std::result::Result<(u64, R::Params), RawRequest>\n+    where\n+        R: Request,\n+        R::Params: DeserializeOwned,\n+    {\n+        if self.method != R::METHOD {\n+            return Err(self);\n+        }\n+        let id = self.id;\n+        let params: R::Params = from_value(self.params).unwrap();\n+        Ok((id, params))\n+    }\n+}\n+\n+impl RawResponse {\n+    pub fn ok(id: u64, result: impl Serialize) -> RawResponse {\n+        RawResponse {\n+            id,\n+            result: Some(to_value(&result).unwrap()),\n+            error: None,\n+        }\n+    }\n+    pub fn err(id: u64, code: i32, message: String) -> RawResponse {\n+        let error = RawResponseError { code, message, data: None };\n+        RawResponse {\n+            id,\n+            result: None,\n+            error: Some(error),\n+        }\n+    }\n+}\n+\n+impl RawNotification {\n+    pub fn cast<N>(self) -> ::std::result::Result<N::Params, RawNotification>\n+    where\n+        N: Notification,\n+        N::Params: DeserializeOwned,\n+    {\n+        if self.method != N::METHOD {\n+            return Err(self);\n+        }\n+        Ok(from_value(self.params).unwrap())\n+    }\n+}\n+\n+fn read_msg_text(inp: &mut impl BufRead) -> Result<Option<String>> {\n+    let mut size = None;\n+    let mut buf = String::new();\n+    loop {\n+        buf.clear();\n+        if inp.read_line(&mut buf)? == 0 {\n+            return Ok(None);\n+        }\n+        if !buf.ends_with(\"\\r\\n\") {\n+            bail!(\"malformed header: {:?}\", buf);\n+        }\n+        let buf = &buf[..buf.len() - 2];\n+        if buf.is_empty() {\n+            break;\n+        }\n+        let mut parts = buf.splitn(2, \": \");\n+        let header_name = parts.next().unwrap();\n+        let header_value = parts.next().ok_or_else(|| format_err!(\"malformed header: {:?}\", buf))?;\n+        if header_name == \"Content-Length\" {\n+            size = Some(header_value.parse::<usize>()?);\n+        }\n+    }\n+    let size = size.ok_or_else(|| format_err!(\"no Content-Length\"))?;\n+    let mut buf = buf.into_bytes();\n+    buf.resize(size, 0);\n+    inp.read_exact(&mut buf)?;\n+    let buf = String::from_utf8(buf)?;\n+    debug!(\"< {}\", buf);\n+    Ok(Some(buf))\n+}\n+\n+fn write_msg_text(out: &mut impl Write, msg: &str) -> Result<()> {\n+    debug!(\"> {}\", msg);\n+    write!(out, \"Content-Length: {}\\r\\n\\r\\n\", msg.len())?;\n+    out.write_all(msg.as_bytes())?;\n+    out.flush()?;\n+    Ok(())\n+}"}, {"sha": "81397bb2a0a7bb6d77c5c857a3537fc29f1f446b", "filename": "crates/gen_lsp_server/src/stdio.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs?ref=3588d6b2da6e63730cc560c9986ba7fda5de816e", "patch": "@@ -0,0 +1,49 @@\n+use std::{\n+    thread,\n+    io::{\n+        stdout, stdin,\n+    },\n+};\n+\n+use crossbeam_channel::{Receiver, Sender, bounded};\n+\n+use {RawMessage, Result};\n+\n+pub fn stdio_transport() -> (Receiver<RawMessage>, Sender<RawMessage>, Threads) {\n+    let (writer_sender, mut writer_receiver) = bounded::<RawMessage>(16);\n+    let writer = thread::spawn(move || {\n+        let stdout = stdout();\n+        let mut stdout = stdout.lock();\n+        writer_receiver.try_for_each(|it| it.write(&mut stdout))?;\n+        Ok(())\n+    });\n+    let (reader_sender, reader_receiver) = bounded::<RawMessage>(16);\n+    let reader = thread::spawn(move || {\n+        let stdin = stdin();\n+        let mut stdin = stdin.lock();\n+        while let Some(msg) = RawMessage::read(&mut stdin)? {\n+            reader_sender.send(msg);\n+        }\n+        Ok(())\n+    });\n+    let threads = Threads { reader, writer };\n+    (reader_receiver, writer_sender, threads)\n+}\n+\n+pub struct Threads {\n+    reader: thread::JoinHandle<Result<()>>,\n+    writer: thread::JoinHandle<Result<()>>,\n+}\n+\n+impl Threads {\n+    pub fn join(self) -> Result<()> {\n+        match self.reader.join() {\n+            Ok(r) => r?,\n+            Err(_) => bail!(\"reader panicked\"),\n+        }\n+        match self.writer.join() {\n+            Ok(r) => r,\n+            Err(_) => bail!(\"writer panicked\"),\n+        }\n+    }\n+}"}]}