{"sha": "0fed53921f9f73e60cc576737688c901192011c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZWQ1MzkyMWY5ZjczZTYwY2M1NzY3Mzc2ODhjOTAxMTkyMDExYzk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T05:58:14Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T19:14:06Z"}, "message": "Remove ebmlivec module", "tree": {"sha": "eccd9e9f4bccbb0720114548aed9d818e03f3d2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eccd9e9f4bccbb0720114548aed9d818e03f3d2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fed53921f9f73e60cc576737688c901192011c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fed53921f9f73e60cc576737688c901192011c9", "html_url": "https://github.com/rust-lang/rust/commit/0fed53921f9f73e60cc576737688c901192011c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fed53921f9f73e60cc576737688c901192011c9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "674fb0911c2eb9aeaa2abdf03b6e4e8756f1cf78", "url": "https://api.github.com/repos/rust-lang/rust/commits/674fb0911c2eb9aeaa2abdf03b6e4e8756f1cf78", "html_url": "https://github.com/rust-lang/rust/commit/674fb0911c2eb9aeaa2abdf03b6e4e8756f1cf78"}], "stats": {"total": 443, "additions": 221, "deletions": 222}, "files": [{"sha": "48a75e172a5455b7715c35c0ff29bf83db3f84c5", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/0fed53921f9f73e60cc576737688c901192011c9/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fed53921f9f73e60cc576737688c901192011c9/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=0fed53921f9f73e60cc576737688c901192011c9", "patch": "@@ -1,6 +1,6 @@\n // Decoding metadata from a single crate's metadata\n \n-import std::ebmlivec;\n+import std::ebml;\n import std::ivec;\n import std::option;\n import std::str;\n@@ -35,65 +35,65 @@ export external_resolver;\n // build.\n type external_resolver = fn(&ast::def_id) -> ast::def_id ;\n \n-fn lookup_hash(d: &ebmlivec::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n-   [ebmlivec::doc] {\n-    let index = ebmlivec::get_doc(d, tag_index);\n-    let table = ebmlivec::get_doc(index, tag_index_table);\n+fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n+   [ebml::doc] {\n+    let index = ebml::get_doc(d, tag_index);\n+    let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n-    let pos = ebmlivec::be_uint_from_bytes(d.data, hash_pos, 4u);\n-    let bucket = ebmlivec::doc_at(d.data, pos);\n+    let pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n+    let bucket = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n-    let result: [ebmlivec::doc] = ~[];\n+    let result: [ebml::doc] = ~[];\n     let belt = tag_index_buckets_bucket_elt;\n-    for each elt: ebmlivec::doc  in ebmlivec::tagged_docs(bucket, belt) {\n-        let pos = ebmlivec::be_uint_from_bytes(elt.data, elt.start, 4u);\n+    for each elt: ebml::doc  in ebml::tagged_docs(bucket, belt) {\n+        let pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n         if eq_fn(ivec::slice[u8](*elt.data, elt.start + 4u, elt.end)) {\n-            result += ~[ebmlivec::doc_at(d.data, pos)];\n+            result += ~[ebml::doc_at(d.data, pos)];\n         }\n     }\n     ret result;\n }\n \n-fn maybe_find_item(item_id: int, items: &ebmlivec::doc) ->\n-   option::t[ebmlivec::doc] {\n+fn maybe_find_item(item_id: int, items: &ebml::doc) ->\n+   option::t[ebml::doc] {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n-        ret ebmlivec::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n+        ret ebml::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }\n     let eqer = bind eq_item(_, item_id);\n     let found = lookup_hash(items, eqer, hash_node_id(item_id));\n     if ivec::len(found) == 0u {\n-        ret option::none[ebmlivec::doc];\n-    } else { ret option::some[ebmlivec::doc](found.(0)); }\n+        ret option::none[ebml::doc];\n+    } else { ret option::some[ebml::doc](found.(0)); }\n }\n \n-fn find_item(item_id: int, items: &ebmlivec::doc) -> ebmlivec::doc {\n+fn find_item(item_id: int, items: &ebml::doc) -> ebml::doc {\n     ret option::get(maybe_find_item(item_id, items));\n }\n \n-// Looks up an item in the given metadata and returns an ebmlivec doc pointing\n+// Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: &@[u8]) -> ebmlivec::doc {\n-    let items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n+fn lookup_item(item_id: int, data: &@[u8]) -> ebml::doc {\n+    let items = ebml::get_doc(ebml::new_doc(data), tag_items);\n     ret find_item(item_id, items);\n }\n \n-fn item_family(item: &ebmlivec::doc) -> u8 {\n-    let fam = ebmlivec::get_doc(item, tag_items_data_item_family);\n-    ret ebmlivec::doc_as_uint(fam) as u8;\n+fn item_family(item: &ebml::doc) -> u8 {\n+    let fam = ebml::get_doc(item, tag_items_data_item_family);\n+    ret ebml::doc_as_uint(fam) as u8;\n }\n \n-fn item_symbol(item: &ebmlivec::doc) -> str {\n-    let sym = ebmlivec::get_doc(item, tag_items_data_item_symbol);\n-    ret str::unsafe_from_bytes(ebmlivec::doc_data(sym));\n+fn item_symbol(item: &ebml::doc) -> str {\n+    let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n+    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n }\n \n-fn variant_tag_id(d: &ebmlivec::doc) -> ast::def_id {\n-    let tagdoc = ebmlivec::get_doc(d, tag_items_data_item_tag_id);\n-    ret parse_def_id(ebmlivec::doc_data(tagdoc));\n+fn variant_tag_id(d: &ebml::doc) -> ast::def_id {\n+    let tagdoc = ebml::get_doc(d, tag_items_data_item_tag_id);\n+    ret parse_def_id(ebml::doc_data(tagdoc));\n }\n \n-fn item_type(item: &ebmlivec::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n+fn item_type(item: &ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n              extres: &external_resolver) -> ty::t {\n     fn parse_external_def_id(this_cnum: ast::crate_num,\n                              extres: &external_resolver, s: str) ->\n@@ -108,18 +108,18 @@ fn item_type(item: &ebmlivec::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n             ret {crate: this_cnum, node: external_def_id.node};\n         } else { ret extres(external_def_id); }\n     }\n-    let tp = ebmlivec::get_doc(item, tag_items_data_item_type);\n+    let tp = ebml::get_doc(item, tag_items_data_item_type);\n     let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n                       def_parser, tcx);\n }\n \n-fn item_ty_param_kinds(item: &ebmlivec::doc) -> [ast::kind] {\n+fn item_ty_param_kinds(item: &ebml::doc) -> [ast::kind] {\n     let ks: [ast::kind] = ~[];\n     let tp = tag_items_data_item_ty_param_kinds;\n-    for each p: ebmlivec::doc in ebmlivec::tagged_docs(item, tp) {\n-        let dat : [u8] = ebmlivec::doc_data(p);\n-        let vi = ebmlivec::vint_at(dat, 0u);\n+    for each p: ebml::doc in ebml::tagged_docs(item, tp) {\n+        let dat : [u8] = ebml::doc_data(p);\n+        let vi = ebml::vint_at(dat, 0u);\n         let i = 0u;\n         while i < vi.val {\n             let k = alt dat.(vi.next + i) as char {\n@@ -134,12 +134,12 @@ fn item_ty_param_kinds(item: &ebmlivec::doc) -> [ast::kind] {\n     ret ks;\n }\n \n-fn tag_variant_ids(item: &ebmlivec::doc, this_cnum: ast::crate_num) ->\n+fn tag_variant_ids(item: &ebml::doc, this_cnum: ast::crate_num) ->\n    [ast::def_id] {\n     let ids: [ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    for each p: ebmlivec::doc  in ebmlivec::tagged_docs(item, v) {\n-        let ext = parse_def_id(ebmlivec::doc_data(p));\n+    for each p: ebml::doc  in ebml::tagged_docs(item, v) {\n+        let ext = parse_def_id(ebml::doc_data(p));\n         ids += ~[{crate: this_cnum, node: ext.node}];\n     }\n     ret ids;\n@@ -152,13 +152,13 @@ fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n         ret str::eq(str::unsafe_from_bytes(data), s);\n     }\n     let s = str::connect(path, \"::\");\n-    let md = ebmlivec::new_doc(data);\n-    let paths = ebmlivec::get_doc(md, tag_paths);\n+    let md = ebml::new_doc(data);\n+    let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n     let result: [ast::def_id] = ~[];\n-    for doc: ebmlivec::doc  in lookup_hash(paths, eqer, hash_path(s)) {\n-        let did_doc = ebmlivec::get_doc(doc, tag_def_id);\n-        result += ~[parse_def_id(ebmlivec::doc_data(did_doc))];\n+    for doc: ebml::doc  in lookup_hash(paths, eqer, hash_path(s)) {\n+        let did_doc = ebml::get_doc(doc, tag_def_id);\n+        result += ~[parse_def_id(ebml::doc_data(did_doc))];\n     }\n     ret result;\n }\n@@ -229,7 +229,7 @@ fn get_tag_variants(data: &@[u8], def: ast::def_id, tcx: &ty::ctxt,\n     let external_crate_id = def.crate;\n     let data =\n         cstore::get_crate_data(tcx.sess.get_cstore(), external_crate_id).data;\n-    let items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n+    let items = ebml::get_doc(ebml::new_doc(data), tag_items);\n     let item = find_item(def.node, items);\n     let infos: [ty::variant_info] = ~[];\n     let variant_ids = tag_variant_ids(item, external_crate_id);\n@@ -266,15 +266,15 @@ fn family_has_type_params(fam_ch: u8) -> bool {\n         };\n }\n \n-fn read_path(d: &ebmlivec::doc) -> {path: str, pos: uint} {\n-    let desc = ebmlivec::doc_data(d);\n-    let pos = ebmlivec::be_uint_from_bytes(@desc, 0u, 4u);\n+fn read_path(d: &ebml::doc) -> {path: str, pos: uint} {\n+    let desc = ebml::doc_data(d);\n+    let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n     let pathbytes = ivec::slice[u8](desc, 4u, ivec::len[u8](desc));\n     let path = str::unsafe_from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }\n \n-fn describe_def(items: &ebmlivec::doc, id: ast::def_id) -> str {\n+fn describe_def(items: &ebml::doc, id: ast::def_id) -> str {\n     if id.crate != ast::local_crate { ret \"external\"; }\n     ret item_family_to_str(item_family(find_item(id.node, items)));\n }\n@@ -294,40 +294,40 @@ fn item_family_to_str(fam: u8) -> str {\n     }\n }\n \n-fn get_meta_items(md: &ebmlivec::doc) -> [@ast::meta_item] {\n+fn get_meta_items(md: &ebml::doc) -> [@ast::meta_item] {\n     let items: [@ast::meta_item] = ~[];\n-    for each meta_item_doc: ebmlivec::doc  in\n-             ebmlivec::tagged_docs(md, tag_meta_item_word) {\n-        let nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::unsafe_from_bytes(ebmlivec::doc_data(nd));\n+    for each meta_item_doc: ebml::doc  in\n+             ebml::tagged_docs(md, tag_meta_item_word) {\n+        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         items += ~[attr::mk_word_item(n)];\n     }\n-    for each meta_item_doc: ebmlivec::doc  in\n-             ebmlivec::tagged_docs(md, tag_meta_item_name_value) {\n-        let nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n-        let vd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::unsafe_from_bytes(ebmlivec::doc_data(nd));\n-        let v = str::unsafe_from_bytes(ebmlivec::doc_data(vd));\n+    for each meta_item_doc: ebml::doc  in\n+             ebml::tagged_docs(md, tag_meta_item_name_value) {\n+        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n+        let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n+        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let v = str::unsafe_from_bytes(ebml::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n         items += ~[attr::mk_name_value_item_str(n, v)];\n     }\n-    for each meta_item_doc: ebmlivec::doc  in\n-             ebmlivec::tagged_docs(md, tag_meta_item_list) {\n-        let nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::unsafe_from_bytes(ebmlivec::doc_data(nd));\n+    for each meta_item_doc: ebml::doc  in\n+             ebml::tagged_docs(md, tag_meta_item_list) {\n+        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items += ~[attr::mk_list_item(n, subitems)];\n     }\n     ret items;\n }\n \n-fn get_attributes(md: &ebmlivec::doc) -> [ast::attribute] {\n+fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n     let attrs: [ast::attribute] = ~[];\n-    alt ebmlivec::maybe_get_doc(md, tag_attributes) {\n+    alt ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n-        for each attr_doc: ebmlivec::doc  in\n-                 ebmlivec::tagged_docs(attrs_d, tag_attribute) {\n+        for each attr_doc: ebml::doc  in\n+                 ebml::tagged_docs(attrs_d, tag_attribute) {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -343,13 +343,13 @@ fn get_attributes(md: &ebmlivec::doc) -> [ast::attribute] {\n     ret attrs;\n }\n \n-fn list_meta_items(meta_items: &ebmlivec::doc, out: io::writer) {\n+fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n     for mi: @ast::meta_item  in get_meta_items(meta_items) {\n         out.write_str(#fmt(\"%s\\n\", pprust::meta_item_to_str(*mi)));\n     }\n }\n \n-fn list_crate_attributes(md: &ebmlivec::doc, out: io::writer) {\n+fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n     out.write_str(\"=Crate Attributes=\\n\");\n \n     for attr: ast::attribute  in get_attributes(md) {\n@@ -360,19 +360,19 @@ fn list_crate_attributes(md: &ebmlivec::doc, out: io::writer) {\n }\n \n fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n-    ret get_attributes(ebmlivec::new_doc(data));\n+    ret get_attributes(ebml::new_doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, ident: str};\n \n fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     let deps: [crate_dep] = ~[];\n-    let cratedoc = ebmlivec::new_doc(data);\n-    let depsdoc = ebmlivec::get_doc(cratedoc, tag_crate_deps);\n+    let cratedoc = ebml::new_doc(data);\n+    let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let crate_num = 1;\n-    for each depdoc: ebmlivec::doc  in\n-             ebmlivec::tagged_docs(depsdoc, tag_crate_dep) {\n-        let depname = str::unsafe_from_bytes(ebmlivec::doc_data(depdoc));\n+    for each depdoc: ebml::doc  in\n+             ebml::tagged_docs(depsdoc, tag_crate_dep) {\n+        let depname = str::unsafe_from_bytes(ebml::doc_data(depdoc));\n         deps += ~[{cnum: crate_num, ident: depname}];\n         crate_num += 1;\n     }\n@@ -389,20 +389,20 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_items(bytes: &@[u8], md: &ebmlivec::doc, out: io::writer) {\n+fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n     out.write_str(\"=Items=\\n\");\n-    let paths = ebmlivec::get_doc(md, tag_paths);\n-    let items = ebmlivec::get_doc(md, tag_items);\n-    let index = ebmlivec::get_doc(paths, tag_index);\n-    let bs = ebmlivec::get_doc(index, tag_index_buckets);\n-    for each bucket: ebmlivec::doc  in\n-             ebmlivec::tagged_docs(bs, tag_index_buckets_bucket) {\n+    let paths = ebml::get_doc(md, tag_paths);\n+    let items = ebml::get_doc(md, tag_items);\n+    let index = ebml::get_doc(paths, tag_index);\n+    let bs = ebml::get_doc(index, tag_index_buckets);\n+    for each bucket: ebml::doc  in\n+             ebml::tagged_docs(bs, tag_index_buckets_bucket) {\n         let et = tag_index_buckets_bucket_elt;\n-        for each elt: ebmlivec::doc  in ebmlivec::tagged_docs(bucket, et) {\n+        for each elt: ebml::doc  in ebml::tagged_docs(bucket, et) {\n             let data = read_path(elt);\n-            let def = ebmlivec::doc_at(bytes, data.pos);\n-            let did_doc = ebmlivec::get_doc(def, tag_def_id);\n-            let did = parse_def_id(ebmlivec::doc_data(did_doc));\n+            let def = ebml::doc_at(bytes, data.pos);\n+            let did_doc = ebml::get_doc(def, tag_def_id);\n+            let did = parse_def_id(ebml::doc_data(did_doc));\n             out.write_str(#fmt(\"%s (%s)\\n\", data.path,\n                                describe_def(items, did)));\n         }\n@@ -411,7 +411,7 @@ fn list_crate_items(bytes: &@[u8], md: &ebmlivec::doc, out: io::writer) {\n }\n \n fn list_crate_metadata(bytes: &@[u8], out: io::writer) {\n-    let md = ebmlivec::new_doc(bytes);\n+    let md = ebml::new_doc(bytes);\n     list_crate_attributes(md, out);\n     list_crate_deps(bytes, out);\n     list_crate_items(bytes, md, out);"}, {"sha": "cf6d011d3764432491220f4c7530f95932753aed", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 134, "deletions": 134, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/0fed53921f9f73e60cc576737688c901192011c9/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fed53921f9f73e60cc576737688c901192011c9/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=0fed53921f9f73e60cc576737688c901192011c9", "patch": "@@ -7,7 +7,7 @@ import std::io;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import std::ebmlivec;\n+import std::ebml;\n import std::map;\n import syntax::ast::*;\n import common::*;\n@@ -24,159 +24,159 @@ type abbrev_map = map::hashmap[ty::t, tyencode::ty_abbrev];\n type encode_ctxt = {ccx: @crate_ctxt, type_abbrevs: abbrev_map};\n \n // Path table encoding\n-fn encode_name(ebml_w: &ebmlivec::writer, name: &str) {\n-    ebmlivec::start_tag(ebml_w, tag_paths_data_name);\n+fn encode_name(ebml_w: &ebml::writer, name: &str) {\n+    ebml::start_tag(ebml_w, tag_paths_data_name);\n     ebml_w.writer.write(str::bytes(name));\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_def_id(ebml_w: &ebmlivec::writer, id: &def_id) {\n-    ebmlivec::start_tag(ebml_w, tag_def_id);\n+fn encode_def_id(ebml_w: &ebml::writer, id: &def_id) {\n+    ebml::start_tag(ebml_w, tag_def_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n type entry[T] = {val: T, pos: uint};\n \n-fn encode_tag_variant_paths(ebml_w: &ebmlivec::writer, variants: &[variant],\n+fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n                             path: &[str], index: &mutable [entry[str]]) {\n     for variant: variant  in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n-        ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+        ebml::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n }\n \n-fn add_to_index(ebml_w: &ebmlivec::writer, path: &[str],\n+fn add_to_index(ebml_w: &ebml::writer, path: &[str],\n                 index: &mutable [entry[str]], name: &str) {\n     let full_path = path + ~[name];\n     index +=\n         ~[{val: str::connect(full_path, \"::\"),\n            pos: ebml_w.writer.tell()}];\n }\n \n-fn encode_native_module_item_paths(ebml_w: &ebmlivec::writer,\n+fn encode_native_module_item_paths(ebml_w: &ebml::writer,\n                                    nmod: &native_mod, path: &[str],\n                                    index: &mutable [entry[str]]) {\n     for nitem: @native_item  in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n-        ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+        ebml::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, nitem.ident);\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n }\n \n-fn encode_module_item_paths(ebml_w: &ebmlivec::writer, module: &_mod,\n+fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n                             path: &[str], index: &mutable [entry[str]]) {\n     for it: @item  in module.items {\n         if !is_exported(it.ident, module) { cont; }\n         alt it.node {\n           item_const(_, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n           }\n           item_fn(_, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n           }\n           item_mod(_mod) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n+            ebml::start_tag(ebml_w, tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             encode_module_item_paths(ebml_w, _mod, path + ~[it.ident], index);\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n           }\n           item_native_mod(nmod) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n+            ebml::start_tag(ebml_w, tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             encode_native_module_item_paths(ebml_w, nmod, path + ~[it.ident],\n                                             index);\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n           }\n           item_ty(_, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n           }\n           item_res(_, _, tps, ctor_id) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(ctor_id));\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n           }\n           item_tag(variants, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n             encode_tag_variant_paths(ebml_w, variants, path, index);\n           }\n           item_obj(_, tps, ctor_id) {\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(ctor_id));\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n           }\n         }\n     }\n }\n \n-fn encode_item_paths(ebml_w: &ebmlivec::writer, crate: &@crate) ->\n+fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) ->\n    [entry[str]] {\n     let index: [entry[str]] = ~[];\n     let path: [str] = ~[];\n-    ebmlivec::start_tag(ebml_w, tag_paths);\n+    ebml::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n     ret index;\n }\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: &ebmlivec::writer, c: u8) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_family);\n+fn encode_family(ebml_w: &ebml::writer, c: u8) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_family);\n     ebml_w.writer.write(~[c]);\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_inlineness(ebml_w: &ebmlivec::writer, c: u8) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_inlineness);\n+fn encode_inlineness(ebml_w: &ebml::writer, c: u8) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_inlineness);\n     ebml_w.writer.write(~[c]);\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n fn def_to_str(did: &def_id) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n \n-fn encode_type_param_kinds(ebml_w: &ebmlivec::writer, tps: &[ty_param]) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n-    ebmlivec::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n+fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n+    ebml::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n     for tp: ty_param in tps {\n         let c = alt tp.kind {\n           kind_unique. { 'u' }\n@@ -185,52 +185,52 @@ fn encode_type_param_kinds(ebml_w: &ebmlivec::writer, tps: &[ty_param]) {\n         };\n         ebml_w.writer.write(~[c as u8]);\n     }\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_variant_id(ebml_w: &ebmlivec::writer, vid: &def_id) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_variant);\n+fn encode_variant_id(ebml_w: &ebml::writer, vid: &def_id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_variant);\n     ebml_w.writer.write(str::bytes(def_to_str(vid)));\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_type(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer, typ: &ty::t) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_type);\n+fn encode_type(ecx: &@encode_ctxt, ebml_w: &ebml::writer, typ: &ty::t) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_type);\n     let f = def_to_str;\n     let ty_str_ctxt =\n         @{ds: f,\n           tcx: ecx.ccx.tcx,\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_symbol(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer, id: node_id) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_symbol);\n+fn encode_symbol(ecx: &@encode_ctxt, ebml_w: &ebml::writer, id: node_id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(str::bytes(ecx.ccx.item_symbols.get(id)));\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_discriminant(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n+fn encode_discriminant(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n                        id: node_id) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(str::bytes(ecx.ccx.discrim_symbols.get(id)));\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_id(ebml_w: &ebmlivec::writer, id: &def_id) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_tag_id);\n+fn encode_tag_id(ebml_w: &ebml::writer, id: &def_id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n+fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n                            id: node_id, variants: &[variant],\n                            index: &mutable [entry[int]],\n                            ty_params: &[ty_param]) {\n     for variant: variant  in variants {\n         index += ~[{val: variant.node.id, pos: ebml_w.writer.tell()}];\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, local_def(id));\n@@ -241,23 +241,23 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n         encode_type_param_kinds(ebml_w, ty_params);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n }\n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebmlivec::writer,\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer,\n                         item: @item, index: &mutable [entry[int]]) {\n     alt item.node {\n       item_const(_, _) {\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'c' as u8);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n       item_fn(fd, tps) {\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w,\n                     alt fd.decl.purity { pure_fn. { 'p' } impure_fn. { 'f' } }\n@@ -270,85 +270,85 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebmlivec::writer,\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n       item_mod(_) {\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'm' as u8);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n       item_native_mod(_) {\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n' as u8);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n       item_ty(_, tps) {\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n       item_tag(variants, tps) {\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 't' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         for v: variant  in variants {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n         encode_tag_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n       }\n       item_res(_, _, tps, ctor_id) {\n         let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n         encode_symbol(ecx, ebml_w, item.id);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n \n         index += ~[{val: ctor_id, pos: ebml_w.writer.tell()}];\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'f' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n       item_obj(_, tps, ctor_id) {\n         let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n \n         index += ~[{val: ctor_id, pos: ebml_w.writer.tell()}];\n-        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'f' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n     }\n }\n \n-fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n+fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n                                nitem: &@native_item) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+    ebml::start_tag(ebml_w, tag_items_data_item);\n     alt nitem.node {\n       native_item_ty. {\n         encode_def_id(ebml_w, local_def(nitem.id));\n@@ -364,13 +364,13 @@ fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n         encode_symbol(ecx, ebml_w, nitem.id);\n       }\n     }\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer) ->\n+fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n    [entry[int]] {\n     let index: [entry[int]] = ~[];\n-    ebmlivec::start_tag(ebml_w, tag_items_data);\n+    ebml::start_tag(ebml_w, tag_items_data);\n     for each kvp: @{key: node_id, val: middle::ast_map::ast_node}  in\n              ecx.ccx.ast_map.items() {\n         alt kvp.val {\n@@ -385,7 +385,7 @@ fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer) ->\n           _ { }\n         }\n     }\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n     ret index;\n }\n \n@@ -408,28 +408,28 @@ fn create_index[T](index: &[entry[T]], hash_fn: fn(&T) -> uint ) ->\n     ret buckets_frozen;\n }\n \n-fn encode_index[T](ebml_w: &ebmlivec::writer, buckets: &[@[entry[T]]],\n+fn encode_index[T](ebml_w: &ebml::writer, buckets: &[@[entry[T]]],\n                    write_fn: fn(&io::writer, &T) ) {\n     let writer = io::new_writer_(ebml_w.writer);\n-    ebmlivec::start_tag(ebml_w, tag_index);\n+    ebml::start_tag(ebml_w, tag_index);\n     let bucket_locs: [uint] = ~[];\n-    ebmlivec::start_tag(ebml_w, tag_index_buckets);\n+    ebml::start_tag(ebml_w, tag_index_buckets);\n     for bucket: @[entry[T]]  in buckets {\n         bucket_locs += ~[ebml_w.writer.tell()];\n-        ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket);\n+        ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n         for elt: entry[T]  in *bucket {\n-            ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n+            ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt.pos, 4u);\n             write_fn(writer, elt.val);\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n         }\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n-    ebmlivec::end_tag(ebml_w);\n-    ebmlivec::start_tag(ebml_w, tag_index_table);\n+    ebml::end_tag(ebml_w);\n+    ebml::start_tag(ebml_w, tag_index_table);\n     for pos: uint  in bucket_locs { writer.write_be_uint(pos, 4u); }\n-    ebmlivec::end_tag(ebml_w);\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n fn write_str(writer: &io::writer, s: &str) { writer.write_str(s); }\n@@ -438,51 +438,51 @@ fn write_int(writer: &io::writer, n: &int) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n-fn encode_meta_item(ebml_w: &ebmlivec::writer, mi: &meta_item) {\n+fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n     alt mi.node {\n       meta_word(name) {\n-        ebmlivec::start_tag(ebml_w, tag_meta_item_word);\n-        ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n+        ebml::start_tag(ebml_w, tag_meta_item_word);\n+        ebml::start_tag(ebml_w, tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(name));\n-        ebmlivec::end_tag(ebml_w);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n       meta_name_value(name, value) {\n         alt value.node {\n           lit_str(value, _) {\n-            ebmlivec::start_tag(ebml_w, tag_meta_item_name_value);\n-            ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n+            ebml::start_tag(ebml_w, tag_meta_item_name_value);\n+            ebml::start_tag(ebml_w, tag_meta_item_name);\n             ebml_w.writer.write(str::bytes(name));\n-            ebmlivec::end_tag(ebml_w);\n-            ebmlivec::start_tag(ebml_w, tag_meta_item_value);\n+            ebml::end_tag(ebml_w);\n+            ebml::start_tag(ebml_w, tag_meta_item_value);\n             ebml_w.writer.write(str::bytes(value));\n-            ebmlivec::end_tag(ebml_w);\n-            ebmlivec::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n+            ebml::end_tag(ebml_w);\n           }\n           _ {/* FIXME (#611) */ }\n         }\n       }\n       meta_list(name, items) {\n-        ebmlivec::start_tag(ebml_w, tag_meta_item_list);\n-        ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n+        ebml::start_tag(ebml_w, tag_meta_item_list);\n+        ebml::start_tag(ebml_w, tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(name));\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n         for inner_item: @meta_item  in items {\n             encode_meta_item(ebml_w, *inner_item);\n         }\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n       }\n     }\n }\n \n-fn encode_attributes(ebml_w: &ebmlivec::writer, attrs: &[attribute]) {\n-    ebmlivec::start_tag(ebml_w, tag_attributes);\n+fn encode_attributes(ebml_w: &ebml::writer, attrs: &[attribute]) {\n+    ebml::start_tag(ebml_w, tag_attributes);\n     for attr: attribute  in attrs {\n-        ebmlivec::start_tag(ebml_w, tag_attribute);\n+        ebml::start_tag(ebml_w, tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n // So there's a special crate attribute called 'link' which defines the\n@@ -536,7 +536,7 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n     ret attrs;\n }\n \n-fn encode_crate_deps(ebml_w: &ebmlivec::writer, cstore: &cstore::cstore) {\n+fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n \n     fn get_ordered_names(cstore: &cstore::cstore) -> [str] {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n@@ -572,13 +572,13 @@ fn encode_crate_deps(ebml_w: &ebmlivec::writer, cstore: &cstore::cstore) {\n     // that they are numbered 1 to n.\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    ebmlivec::start_tag(ebml_w, tag_crate_deps);\n+    ebml::start_tag(ebml_w, tag_crate_deps);\n     for cname: str  in get_ordered_names(cstore) {\n-        ebmlivec::start_tag(ebml_w, tag_crate_dep);\n+        ebml::start_tag(ebml_w, tag_crate_dep);\n         ebml_w.writer.write(str::bytes(cname));\n-        ebmlivec::end_tag(ebml_w);\n+        ebml::end_tag(ebml_w);\n     }\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n }\n \n fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n@@ -588,7 +588,7 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n \n     let string_w = io::string_writer();\n     let buf_w = string_w.get_writer().get_buf_writer();\n-    let ebml_w = ebmlivec::create_writer(buf_w);\n+    let ebml_w = ebml::create_writer(buf_w);\n \n     let crate_attrs = synthesize_crate_attrs(ecx, crate);\n     encode_attributes(ebml_w, crate_attrs);\n@@ -597,18 +597,18 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n \n     // Encode and index the paths.\n \n-    ebmlivec::start_tag(ebml_w, tag_paths);\n+    ebml::start_tag(ebml_w, tag_paths);\n     let paths_index = encode_item_paths(ebml_w, crate);\n     let paths_buckets = create_index(paths_index, hash_path);\n     encode_index(ebml_w, paths_buckets, write_str);\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n     // Encode and index the items.\n \n-    ebmlivec::start_tag(ebml_w, tag_items);\n+    ebml::start_tag(ebml_w, tag_items);\n     let items_index = encode_info_for_items(ecx, ebml_w);\n     let items_buckets = create_index(items_index, hash_node_id);\n     encode_index(ebml_w, items_buckets, write_int);\n-    ebmlivec::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n "}, {"sha": "fa4e0d41051816b8c3d503ffe8171a7dd32d6775", "filename": "src/lib/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0fed53921f9f73e60cc576737688c901192011c9/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0fed53921f9f73e60cc576737688c901192011c9/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=0fed53921f9f73e60cc576737688c901192011c9", "patch": "@@ -92,7 +92,6 @@ mod smallintmap;\n mod ptr;\n mod test;\n mod unsafe;\n-mod ebmlivec = \"ebml.rs\";\n mod term;\n \n // Local Variables:"}]}