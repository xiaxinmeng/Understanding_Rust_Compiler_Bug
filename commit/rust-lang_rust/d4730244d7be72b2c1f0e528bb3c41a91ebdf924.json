{"sha": "d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "node_id": "C_kwDOAAsO6NoAKGQ0NzMwMjQ0ZDdiZTcyYjJjMWYwZTUyOGJiM2M0MWE5MWViZGY5MjQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-05T07:33:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-05T07:33:22Z"}, "message": "Rollup merge of #95512 - davidtwco:diagnostic-translation, r=oli-obk\n\ndiagnostics: translation infrastructure\n\nAn implementation of the infrastructure required to have translatable diagnostic messages.\n\n- Introduces a `DiagnosticMessage` type which can represent both the current non-translatable messages and identifiers for [Fluent](https://projectfluent.org/).\n- Modifies current diagnostic API so that existing calls still work but `DiagnosticMessage`s can be provided too.\n- Adds support for always loading a \"fallback bundle\" containing the English diagnostic messages, which are used when a `DiagnosticMessage::FluentIdentifier` is used in a diagnostic being emitted.\n- Adds support for loading a \"primary bundle\" which contains the user's preferred language translation, and is used preferentially when it contains a diagnostic message being emitted. Primary bundles are loaded either from the path provided to `-Ztranslate-alternate-ftl` (for testing), or from the sysroot at `$sysroot/locale/$locale/*.ftl` given a locale with `-Ztranslate-lang` (which is parsed as a language identifier).\n- Adds \"diagnostic args\" which enable normally-interpolated variables to be made available as variables for Fluent messages to use.\n- Updates `#[derive(SessionDiagnostic)]` so that it can only be used for translatable diagnostics and update the handful of diagnostics which used the derive to be translatable.\n\nFor example, the following diagnostic...\n\n```rust\n#[derive(SessionDiagnostic)]\n#[error = \"E0195\"]\npub struct LifetimesOrBoundsMismatchOnTrait {\n    #[message = \"lifetime parameters or bounds on {item_kind} `{ident}` do not match the trait declaration\"]\n    #[label = \"lifetimes do not match {item_kind} in trait\"]\n    pub span: Span,\n    #[label = \"lifetimes in impl do not match this {item_kind} in trait\"]\n    pub generics_span: Option<Span>,\n    pub item_kind: &'static str,\n    pub ident: Ident,\n}\n```\n\n...becomes...\n\n```rust\n#[derive(SessionDiagnostic)]\n#[error(code = \"E0195\", slug = \"typeck-lifetimes-or-bounds-mismatch-on-trait\")]\npub struct LifetimesOrBoundsMismatchOnTrait {\n    #[primary_span]\n    #[label]\n    pub span: Span,\n    #[label = \"generics-label\"]\n    pub generics_span: Option<Span>,\n    pub item_kind: &'static str,\n    pub ident: Ident,\n}\n```\n\n```fluent\ntypeck-lifetimes-or-bounds-mismatch-on-trait =\n    lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n    .label = lifetimes do not match {$item_kind} in trait\n    .generics-label = lifetimes in impl do not match this {$item_kind} in trait\n```\n\nr? `@estebank`\ncc `@oli-obk` `@Manishearth`", "tree": {"sha": "f4ab3bdc4e725db3cebbae49d440e4d6762977ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ab3bdc4e725db3cebbae49d440e4d6762977ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiS/DCCRBK7hj4Ov3rIwAAUFcIACfuf7C7J3x0gQpXy9zA1eIY\np4TBwi7NFxKmx1eSfrjsMxfmRD6Mdr+o7Q+zGvhsFoWQtmgNpA8/LB9jx7vKN8gR\nYMgZCgdCGhGB6WCOME5TWEQrSj2qzt1KbCDw6f+Nm3bZ1U56aIDfLm5gr4SzyatZ\nO1q824jQLPBpo3AqbC2mrK9S1emx/5DJpAyXZg+cWCAbQhL0SEUok8kWjLpEGORd\n6QSCIQEkBqSKf4PthdsICVCL6KXBDGW9MkTP4sqZEgFH/T1t7ZYP1ulVpvs16/aA\n7ZNmqZ9kP2rkGmZ+XUeLURegRq17/r6U+Yc2nQBJkivm3YhX2zS2EI/XaO/CAAA=\n=fn6R\n-----END PGP SIGNATURE-----\n", "payload": "tree f4ab3bdc4e725db3cebbae49d440e4d6762977ec\nparent 73eab351093a16637298fc501ded798d26419d73\nparent ccd482032672a223ceaa8ab8d7637180a357fdea\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649144002 +0200\ncommitter GitHub <noreply@github.com> 1649144002 +0200\n\nRollup merge of #95512 - davidtwco:diagnostic-translation, r=oli-obk\n\ndiagnostics: translation infrastructure\n\nAn implementation of the infrastructure required to have translatable diagnostic messages.\n\n- Introduces a `DiagnosticMessage` type which can represent both the current non-translatable messages and identifiers for [Fluent](https://projectfluent.org/).\n- Modifies current diagnostic API so that existing calls still work but `DiagnosticMessage`s can be provided too.\n- Adds support for always loading a \"fallback bundle\" containing the English diagnostic messages, which are used when a `DiagnosticMessage::FluentIdentifier` is used in a diagnostic being emitted.\n- Adds support for loading a \"primary bundle\" which contains the user's preferred language translation, and is used preferentially when it contains a diagnostic message being emitted. Primary bundles are loaded either from the path provided to `-Ztranslate-alternate-ftl` (for testing), or from the sysroot at `$sysroot/locale/$locale/*.ftl` given a locale with `-Ztranslate-lang` (which is parsed as a language identifier).\n- Adds \"diagnostic args\" which enable normally-interpolated variables to be made available as variables for Fluent messages to use.\n- Updates `#[derive(SessionDiagnostic)]` so that it can only be used for translatable diagnostics and update the handful of diagnostics which used the derive to be translatable.\n\nFor example, the following diagnostic...\n\n```rust\n#[derive(SessionDiagnostic)]\n#[error = \"E0195\"]\npub struct LifetimesOrBoundsMismatchOnTrait {\n    #[message = \"lifetime parameters or bounds on {item_kind} `{ident}` do not match the trait declaration\"]\n    #[label = \"lifetimes do not match {item_kind} in trait\"]\n    pub span: Span,\n    #[label = \"lifetimes in impl do not match this {item_kind} in trait\"]\n    pub generics_span: Option<Span>,\n    pub item_kind: &'static str,\n    pub ident: Ident,\n}\n```\n\n...becomes...\n\n```rust\n#[derive(SessionDiagnostic)]\n#[error(code = \"E0195\", slug = \"typeck-lifetimes-or-bounds-mismatch-on-trait\")]\npub struct LifetimesOrBoundsMismatchOnTrait {\n    #[primary_span]\n    #[label]\n    pub span: Span,\n    #[label = \"generics-label\"]\n    pub generics_span: Option<Span>,\n    pub item_kind: &'static str,\n    pub ident: Ident,\n}\n```\n\n```fluent\ntypeck-lifetimes-or-bounds-mismatch-on-trait =\n    lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n    .label = lifetimes do not match {$item_kind} in trait\n    .generics-label = lifetimes in impl do not match this {$item_kind} in trait\n```\n\nr? `@estebank`\ncc `@oli-obk` `@Manishearth`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "html_url": "https://github.com/rust-lang/rust/commit/d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73eab351093a16637298fc501ded798d26419d73", "url": "https://api.github.com/repos/rust-lang/rust/commits/73eab351093a16637298fc501ded798d26419d73", "html_url": "https://github.com/rust-lang/rust/commit/73eab351093a16637298fc501ded798d26419d73"}, {"sha": "ccd482032672a223ceaa8ab8d7637180a357fdea", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd482032672a223ceaa8ab8d7637180a357fdea", "html_url": "https://github.com/rust-lang/rust/commit/ccd482032672a223ceaa8ab8d7637180a357fdea"}], "stats": {"total": 3982, "additions": 2911, "deletions": 1071}, "files": [{"sha": "d8cb1133c73a367e1d8998d9690129da75eb8ae9", "filename": "Cargo.lock", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1238,6 +1238,40 @@ dependencies = [\n  \"miniz_oxide\",\n ]\n \n+[[package]]\n+name = \"fluent-bundle\"\n+version = \"0.15.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e242c601dec9711505f6d5bbff5bedd4b61b2469f2e8bb8e57ee7c9747a87ffd\"\n+dependencies = [\n+ \"fluent-langneg\",\n+ \"fluent-syntax\",\n+ \"intl-memoizer\",\n+ \"intl_pluralrules\",\n+ \"rustc-hash\",\n+ \"self_cell\",\n+ \"smallvec\",\n+ \"unic-langid\",\n+]\n+\n+[[package]]\n+name = \"fluent-langneg\"\n+version = \"0.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2c4ad0989667548f06ccd0e306ed56b61bd4d35458d54df5ec7587c0e8ed5e94\"\n+dependencies = [\n+ \"unic-langid\",\n+]\n+\n+[[package]]\n+name = \"fluent-syntax\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c0abed97648395c902868fee9026de96483933faa54ea3b40d652f7dfe61ca78\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n [[package]]\n name = \"fnv\"\n version = \"1.0.7\"\n@@ -1782,6 +1816,26 @@ dependencies = [\n  \"cfg-if 1.0.0\",\n ]\n \n+[[package]]\n+name = \"intl-memoizer\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c310433e4a310918d6ed9243542a6b83ec1183df95dff8f23f87bb88a264a66f\"\n+dependencies = [\n+ \"type-map\",\n+ \"unic-langid\",\n+]\n+\n+[[package]]\n+name = \"intl_pluralrules\"\n+version = \"7.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b18f988384267d7066cc2be425e6faf352900652c046b6971d2e228d3b1c5ecf\"\n+dependencies = [\n+ \"tinystr\",\n+ \"unic-langid\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.10.1\"\n@@ -2812,6 +2866,12 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"proc-macro-hack\"\n+version = \"0.5.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dbf0c48bc1d91375ae5c3cd81e3722dff1abcf81a30960240640d223f59fe0e5\"\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"1.0.30\"\n@@ -3645,13 +3705,29 @@ dependencies = [\n name = \"rustc_error_codes\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"rustc_error_messages\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"fluent-bundle\",\n+ \"fluent-syntax\",\n+ \"intl-memoizer\",\n+ \"rustc_data_structures\",\n+ \"rustc_macros\",\n+ \"rustc_serialize\",\n+ \"rustc_span\",\n+ \"tracing\",\n+ \"unic-langid\",\n+]\n+\n [[package]]\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n  \"rustc_data_structures\",\n+ \"rustc_error_messages\",\n  \"rustc_lint_defs\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n@@ -3708,6 +3784,7 @@ dependencies = [\n  \"odht\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n+ \"rustc_error_messages\",\n  \"rustc_feature\",\n  \"rustc_index\",\n  \"rustc_macros\",\n@@ -3864,6 +3941,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n+ \"rustc_error_messages\",\n  \"rustc_hir\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n@@ -4573,6 +4651,12 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"self_cell\"\n+version = \"0.10.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1ef965a420fe14fdac7dd018862966a4c14094f900e1650bbc71ddd7d580c8af\"\n+\n [[package]]\n name = \"semver\"\n version = \"1.0.3\"\n@@ -5104,6 +5188,12 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"tinystr\"\n+version = \"0.3.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"29738eedb4388d9ea620eeab9384884fc3f06f586a2eddb56bedc5885126c7c1\"\n+\n [[package]]\n name = \"tinyvec\"\n version = \"0.3.4\"\n@@ -5262,6 +5352,15 @@ dependencies = [\n  \"tracing-subscriber\",\n ]\n \n+[[package]]\n+name = \"type-map\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b6d3364c5e96cb2ad1603037ab253ddd34d7fb72a58bdddf4b7350760fc69a46\"\n+dependencies = [\n+ \"rustc-hash\",\n+]\n+\n [[package]]\n name = \"typenum\"\n version = \"1.12.0\"\n@@ -5316,6 +5415,49 @@ dependencies = [\n  \"unic-ucd-version\",\n ]\n \n+[[package]]\n+name = \"unic-langid\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"73328fcd730a030bdb19ddf23e192187a6b01cd98be6d3140622a89129459ce5\"\n+dependencies = [\n+ \"unic-langid-impl\",\n+ \"unic-langid-macros\",\n+]\n+\n+[[package]]\n+name = \"unic-langid-impl\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1a4a8eeaf0494862c1404c95ec2f4c33a2acff5076f64314b465e3ddae1b934d\"\n+dependencies = [\n+ \"tinystr\",\n+]\n+\n+[[package]]\n+name = \"unic-langid-macros\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"18f980d6d87e8805f2836d64b4138cc95aa7986fa63b1f51f67d5fbff64dd6e5\"\n+dependencies = [\n+ \"proc-macro-hack\",\n+ \"tinystr\",\n+ \"unic-langid-impl\",\n+ \"unic-langid-macros-impl\",\n+]\n+\n+[[package]]\n+name = \"unic-langid-macros-impl\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"29396ffd97e27574c3e01368b1a64267d3064969e4848e2e130ff668be9daa9f\"\n+dependencies = [\n+ \"proc-macro-hack\",\n+ \"quote\",\n+ \"syn\",\n+ \"unic-langid-impl\",\n+]\n+\n [[package]]\n name = \"unic-ucd-version\"\n version = \"0.9.0\""}, {"sha": "70f7f1e493e07055316c1aeae9aaa3df971b80bb", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1,6 +1,6 @@\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder, DiagnosticId, ErrorGuaranteed, MultiSpan};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n \n impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     crate fn cannot_move_when_borrowed("}, {"sha": "aa2ddada3502a5a6e147ccf171cb756ddc267353", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use rustc_const_eval::util::CallKind;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n@@ -15,7 +15,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::{self, subst::Subst, suggest_constraining_type_params, PredicateKind, Ty};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::symbol::sym;\n-use rustc_span::{BytePos, MultiSpan, Span};\n+use rustc_span::{BytePos, Span};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n "}, {"sha": "723adb8da1b173efe1669d9b8c306810ba017420", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -109,7 +109,7 @@ impl RegionName {\n                     *span,\n                     format!(\"lifetime `{}` represents this closure's body\", self),\n                 );\n-                diag.note(&note);\n+                diag.note(note);\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::CannotMatchHirTy(\n                 span,"}, {"sha": "138e1fa0176033ed2b121f76b46565c7968c9a10", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -7,11 +7,11 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{token, BlockCheckMode, UnsafeSource};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, Applicability, PResult};\n+use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n use rustc_expand::base::{self, *};\n use rustc_parse_format as parse;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{InnerSpan, MultiSpan, Span};\n+use rustc_span::{InnerSpan, Span};\n use smallvec::SmallVec;\n \n use std::borrow::Cow;\n@@ -446,7 +446,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                                 .iter()\n                                 .filter(|fmt| fmt.precision_span.is_some())\n                                 .count();\n-                        e.span_label(span, &format!(\n+                        e.span_label(\n+                            span,\n+                            &format!(\n                             \"this precision flag adds an extra required argument at position {}, \\\n                              which is why there {} expected\",\n                             pos,\n@@ -455,7 +457,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                             } else {\n                                 format!(\"are {} arguments\", count)\n                             },\n-                        ));\n+                        ),\n+                        );\n                         if let Some(arg) = self.args.get(pos) {\n                             e.span_label(\n                                 arg.span,"}, {"sha": "92c4ab7eb8627b447dfb805d6e8fac4f79a31f4e", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1707,23 +1707,33 @@ impl SharedEmitter {\n \n impl Emitter for SharedEmitter {\n     fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n+        let fluent_args = self.to_fluent_args(diag.args());\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-            msg: diag.message(),\n+            msg: self.translate_messages(&diag.message, &fluent_args).to_string(),\n             code: diag.code.clone(),\n             lvl: diag.level(),\n         })));\n         for child in &diag.children {\n             drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-                msg: child.message(),\n+                msg: self.translate_messages(&child.message, &fluent_args).to_string(),\n                 code: None,\n                 lvl: child.level,\n             })));\n         }\n         drop(self.sender.send(SharedEmitterMessage::AbortIfErrors));\n     }\n+\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+        panic!(\"shared emitter attempted to translate a diagnostic\");\n+    }\n }\n \n impl SharedEmitterMain {\n@@ -1754,9 +1764,9 @@ impl SharedEmitterMain {\n                     let msg = msg.strip_prefix(\"error: \").unwrap_or(&msg);\n \n                     let mut err = match level {\n-                        Level::Error { lint: false } => sess.struct_err(&msg).forget_guarantee(),\n-                        Level::Warning => sess.struct_warn(&msg),\n-                        Level::Note => sess.struct_note_without_error(&msg),\n+                        Level::Error { lint: false } => sess.struct_err(msg).forget_guarantee(),\n+                        Level::Warning => sess.struct_warn(msg),\n+                        Level::Note => sess.struct_note_without_error(msg),\n                         _ => bug!(\"Invalid inline asm diagnostic level\"),\n                     };\n "}, {"sha": "febdd0ed74675df5d6242d7def6b4c39366f408d", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1172,9 +1172,13 @@ static DEFAULT_HOOK: SyncLazy<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send +\n /// When `install_ice_hook` is called, this function will be called as the panic\n /// hook.\n pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n+    let fallback_bundle =\n+        rustc_errors::fallback_fluent_bundle(false).expect(\"failed to load fallback fluent bundle\");\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n         rustc_errors::ColorConfig::Auto,\n         None,\n+        None,\n+        fallback_bundle,\n         false,\n         false,\n         None,\n@@ -1209,7 +1213,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     }\n \n     for note in &xs {\n-        handler.note_without_error(note);\n+        handler.note_without_error(note.as_ref());\n     }\n \n     // If backtraces are enabled, also print the query stack"}, {"sha": "fc84c7c8665b4c17f9ccda3fa13a2be6e01958a7", "filename": "compiler/rustc_error_messages/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_error_messages%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_error_messages%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2FCargo.toml?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"rustc_error_messages\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+fluent-bundle = \"0.15.2\"\n+fluent-syntax = \"0.11\"\n+intl-memoizer = \"0.5.1\"\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+tracing = \"0.1\"\n+unic-langid = { version = \"0.9.0\", features = [\"macros\"] }"}, {"sha": "336e7a66857082ca6bd51e282cfb2bef34a30273", "filename": "compiler/rustc_error_messages/locales/en-US/diagnostics.ftl", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -0,0 +1,87 @@\n+parser-struct-literal-body-without-path =\n+    struct literal body without path\n+    .suggestion = you might have forgotten to add the struct literal inside the block\n+\n+typeck-field-multiply-specified-in-initializer =\n+    field `{$ident}` specified more than once\n+    .label = used more than once\n+    .previous-use-label = first use of `{$ident}`\n+\n+typeck-unrecognized-atomic-operation =\n+    unrecognized atomic operation function: `{$op}`\n+    .label = unrecognized atomic operation\n+\n+typeck-wrong-number-of-generic-arguments-to-intrinsic =\n+    intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n+    .label = expected {$expected} {$descr} {$expected ->\n+        [one] parameter\n+        *[other] parameters\n+    }\n+\n+typeck-unrecognized-intrinsic-function =\n+    unrecognized intrinsic function: `{$name}`\n+    .label = unrecognized intrinsic\n+\n+typeck-lifetimes-or-bounds-mismatch-on-trait =\n+    lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n+    .label = lifetimes do not match {$item_kind} in trait\n+    .generics-label = lifetimes in impl do not match this {$item_kind} in trait\n+\n+typeck-drop-impl-on-wrong-item =\n+    the `Drop` trait may only be implemented for structs, enums, and unions\n+    .label = must be a struct, enum, or union\n+\n+typeck-field-already-declared =\n+    field `{$field_name}` is already declared\n+    .label = field already declared\n+    .previous-decl-label = `{$field_name}` first declared here\n+\n+typeck-copy-impl-on-type-with-dtor =\n+    the trait `Copy` may not be implemented for this type; the type has a destructor\n+    .label = `Copy` not allowed on types with destructors\n+\n+typeck-multiple-relaxed-default-bounds =\n+    type parameter has more than one relaxed default bound, only one is supported\n+\n+typeck-copy-impl-on-non-adt =\n+    the trait `Copy` may not be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n+typeck-trait-object-declared-with-no-traits =\n+    at least one trait is required for an object type\n+\n+typeck-ambiguous-lifetime-bound =\n+    ambiguous lifetime bound, explicit lifetime bound required\n+\n+typeck-assoc-type-binding-not-allowed =\n+    associated type bindings are not allowed here\n+    .label = associated type not allowed here\n+\n+typeck-functional-record-update-on-non-struct =\n+    functional record update syntax requires a struct\n+\n+typeck-typeof-reserved-keyword-used =\n+    `typeof` is a reserved keyword but unimplemented\n+    .label = reserved keyword\n+\n+typeck-return-stmt-outside-of-fn-body =\n+    return statement outside of function body\n+    .encl-body-label = the return is part of this body...\n+    .encl-fn-label = ...not the enclosing function body\n+\n+typeck-yield-expr-outside-of-generator =\n+    yield expression outside of generator literal\n+\n+typeck-struct-expr-non-exhaustive =\n+    cannot create non-exhaustive {$what} using struct expression\n+\n+typeck-method-call-on-unknown-type =\n+    the type of this value must be known to call a method on a raw pointer on it\n+\n+typeck-value-of-associated-struct-already-specified =\n+    the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n+    .label = re-bound here\n+    .previous-bound-label = `{$item_name}` bound here first\n+\n+typeck-address-of-temporary-taken = cannot take address of a temporary\n+    .label = temporary value"}, {"sha": "88f3b547605a272f58c7253409699980c16d1cf0", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -0,0 +1,390 @@\n+#![feature(let_chains)]\n+#![feature(path_try_exists)]\n+\n+use fluent_bundle::FluentResource;\n+use fluent_syntax::parser::ParserError;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_macros::{Decodable, Encodable};\n+use rustc_span::Span;\n+use std::borrow::Cow;\n+use std::error::Error;\n+use std::fmt;\n+use std::fs;\n+use std::io;\n+use std::path::Path;\n+use tracing::{instrument, trace};\n+\n+#[cfg(parallel_compiler)]\n+use intl_memoizer::concurrent::IntlLangMemoizer;\n+#[cfg(not(parallel_compiler))]\n+use intl_memoizer::IntlLangMemoizer;\n+\n+pub use fluent_bundle::{FluentArgs, FluentError, FluentValue};\n+pub use unic_langid::{langid, LanguageIdentifier};\n+\n+static FALLBACK_FLUENT_RESOURCE: &'static str = include_str!(\"../locales/en-US/diagnostics.ftl\");\n+\n+pub type FluentBundle = fluent_bundle::bundle::FluentBundle<FluentResource, IntlLangMemoizer>;\n+\n+#[cfg(parallel_compiler)]\n+fn new_bundle(locales: Vec<LanguageIdentifier>) -> FluentBundle {\n+    FluentBundle::new_concurrent(locales)\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+fn new_bundle(locales: Vec<LanguageIdentifier>) -> FluentBundle {\n+    FluentBundle::new(locales)\n+}\n+\n+#[derive(Debug)]\n+pub enum TranslationBundleError {\n+    /// Failed to read from `.ftl` file.\n+    ReadFtl(io::Error),\n+    /// Failed to parse contents of `.ftl` file.\n+    ParseFtl(ParserError),\n+    /// Failed to add `FluentResource` to `FluentBundle`.\n+    AddResource(FluentError),\n+    /// `$sysroot/share/locale/$locale` does not exist.\n+    MissingLocale(io::Error),\n+    /// Cannot read directory entries of `$sysroot/share/locale/$locale`.\n+    ReadLocalesDir(io::Error),\n+    /// Cannot read directory entry of `$sysroot/share/locale/$locale`.\n+    ReadLocalesDirEntry(io::Error),\n+    /// `$sysroot/share/locale/$locale` is not a directory.\n+    LocaleIsNotDir,\n+}\n+\n+impl fmt::Display for TranslationBundleError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            TranslationBundleError::ReadFtl(e) => write!(f, \"could not read ftl file: {}\", e),\n+            TranslationBundleError::ParseFtl(e) => {\n+                write!(f, \"could not parse ftl file: {}\", e)\n+            }\n+            TranslationBundleError::AddResource(e) => write!(f, \"failed to add resource: {}\", e),\n+            TranslationBundleError::MissingLocale(e) => {\n+                write!(f, \"missing locale directory: {}\", e)\n+            }\n+            TranslationBundleError::ReadLocalesDir(e) => {\n+                write!(f, \"could not read locales dir: {}\", e)\n+            }\n+            TranslationBundleError::ReadLocalesDirEntry(e) => {\n+                write!(f, \"could not read locales dir entry: {}\", e)\n+            }\n+            TranslationBundleError::LocaleIsNotDir => {\n+                write!(f, \"`$sysroot/share/locales/$locale` is not a directory\")\n+            }\n+        }\n+    }\n+}\n+\n+impl Error for TranslationBundleError {\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        match self {\n+            TranslationBundleError::ReadFtl(e) => Some(e),\n+            TranslationBundleError::ParseFtl(e) => Some(e),\n+            TranslationBundleError::AddResource(e) => Some(e),\n+            TranslationBundleError::MissingLocale(e) => Some(e),\n+            TranslationBundleError::ReadLocalesDir(e) => Some(e),\n+            TranslationBundleError::ReadLocalesDirEntry(e) => Some(e),\n+            TranslationBundleError::LocaleIsNotDir => None,\n+        }\n+    }\n+}\n+\n+impl From<(FluentResource, Vec<ParserError>)> for TranslationBundleError {\n+    fn from((_, mut errs): (FluentResource, Vec<ParserError>)) -> Self {\n+        TranslationBundleError::ParseFtl(errs.pop().expect(\"failed ftl parse with no errors\"))\n+    }\n+}\n+\n+impl From<Vec<FluentError>> for TranslationBundleError {\n+    fn from(mut errs: Vec<FluentError>) -> Self {\n+        TranslationBundleError::AddResource(\n+            errs.pop().expect(\"failed adding resource to bundle with no errors\"),\n+        )\n+    }\n+}\n+\n+/// Returns Fluent bundle with the user's locale resources from\n+/// `$sysroot/share/locale/$requested_locale/*.ftl`.\n+///\n+/// If `-Z additional-ftl-path` was provided, load that resource and add it  to the bundle\n+/// (overriding any conflicting messages).\n+#[instrument(level = \"trace\")]\n+pub fn fluent_bundle(\n+    sysroot: &Path,\n+    requested_locale: Option<LanguageIdentifier>,\n+    additional_ftl_path: Option<&Path>,\n+    with_directionality_markers: bool,\n+) -> Result<Option<Lrc<FluentBundle>>, TranslationBundleError> {\n+    if requested_locale.is_none() && additional_ftl_path.is_none() {\n+        return Ok(None);\n+    }\n+\n+    let fallback_locale = langid!(\"en-US\");\n+    let requested_fallback_locale = requested_locale.as_ref() == Some(&fallback_locale);\n+\n+    // If there is only `-Z additional-ftl-path`, assume locale is \"en-US\", otherwise use user\n+    // provided locale.\n+    let locale = requested_locale.clone().unwrap_or(fallback_locale);\n+    trace!(?locale);\n+    let mut bundle = new_bundle(vec![locale]);\n+\n+    // Fluent diagnostics can insert directionality isolation markers around interpolated variables\n+    // indicating that there may be a shift from right-to-left to left-to-right text (or\n+    // vice-versa). These are disabled because they are sometimes visible in the error output, but\n+    // may be worth investigating in future (for example: if type names are left-to-right and the\n+    // surrounding diagnostic messages are right-to-left, then these might be helpful).\n+    bundle.set_use_isolating(with_directionality_markers);\n+\n+    // If the user requests the default locale then don't try to load anything.\n+    if !requested_fallback_locale && let Some(requested_locale) = requested_locale {\n+        let mut sysroot = sysroot.to_path_buf();\n+        sysroot.push(\"share\");\n+        sysroot.push(\"locale\");\n+        sysroot.push(requested_locale.to_string());\n+        trace!(?sysroot);\n+\n+        let _ = sysroot.try_exists().map_err(TranslationBundleError::MissingLocale)?;\n+\n+        if !sysroot.is_dir() {\n+            return Err(TranslationBundleError::LocaleIsNotDir);\n+        }\n+\n+        for entry in sysroot.read_dir().map_err(TranslationBundleError::ReadLocalesDir)? {\n+            let entry = entry.map_err(TranslationBundleError::ReadLocalesDirEntry)?;\n+            let path = entry.path();\n+            trace!(?path);\n+            if path.extension().and_then(|s| s.to_str()) != Some(\"ftl\") {\n+                trace!(\"skipping\");\n+                continue;\n+            }\n+\n+            let resource_str =\n+                fs::read_to_string(path).map_err(TranslationBundleError::ReadFtl)?;\n+            let resource =\n+                FluentResource::try_new(resource_str).map_err(TranslationBundleError::from)?;\n+            trace!(?resource);\n+            bundle.add_resource(resource).map_err(TranslationBundleError::from)?;\n+        }\n+    }\n+\n+    if let Some(additional_ftl_path) = additional_ftl_path {\n+        let resource_str =\n+            fs::read_to_string(additional_ftl_path).map_err(TranslationBundleError::ReadFtl)?;\n+        let resource =\n+            FluentResource::try_new(resource_str).map_err(TranslationBundleError::from)?;\n+        trace!(?resource);\n+        bundle.add_resource_overriding(resource);\n+    }\n+\n+    let bundle = Lrc::new(bundle);\n+    Ok(Some(bundle))\n+}\n+\n+/// Return the default `FluentBundle` with standard \"en-US\" diagnostic messages.\n+#[instrument(level = \"trace\")]\n+pub fn fallback_fluent_bundle(\n+    with_directionality_markers: bool,\n+) -> Result<Lrc<FluentBundle>, TranslationBundleError> {\n+    let fallback_resource = FluentResource::try_new(FALLBACK_FLUENT_RESOURCE.to_string())\n+        .map_err(TranslationBundleError::from)?;\n+    trace!(?fallback_resource);\n+    let mut fallback_bundle = new_bundle(vec![langid!(\"en-US\")]);\n+    // See comment in `fluent_bundle`.\n+    fallback_bundle.set_use_isolating(with_directionality_markers);\n+    fallback_bundle.add_resource(fallback_resource).map_err(TranslationBundleError::from)?;\n+    let fallback_bundle = Lrc::new(fallback_bundle);\n+    Ok(fallback_bundle)\n+}\n+\n+/// Identifier for the Fluent message/attribute corresponding to a diagnostic message.\n+type FluentId = Cow<'static, str>;\n+\n+/// Abstraction over a message in a diagnostic to support both translatable and non-translatable\n+/// diagnostic messages.\n+///\n+/// Intended to be removed once diagnostics are entirely translatable.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n+pub enum DiagnosticMessage {\n+    /// Non-translatable diagnostic message.\n+    // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n+    Str(String),\n+    /// Identifier for a Fluent message (with optional attribute) corresponding to the diagnostic\n+    /// message.\n+    ///\n+    /// <https://projectfluent.org/fluent/guide/hello.html>\n+    /// <https://projectfluent.org/fluent/guide/attributes.html>\n+    FluentIdentifier(FluentId, Option<FluentId>),\n+}\n+\n+impl DiagnosticMessage {\n+    /// Returns the `String` contained within the `DiagnosticMessage::Str` variant, assuming that\n+    /// this diagnostic message is of the legacy, non-translatable variety. Panics if this\n+    /// assumption does not hold.\n+    ///\n+    /// Don't use this - it exists to support some places that do comparison with diagnostic\n+    /// strings.\n+    pub fn expect_str(&self) -> &str {\n+        match self {\n+            DiagnosticMessage::Str(s) => s,\n+            _ => panic!(\"expected non-translatable diagnostic message\"),\n+        }\n+    }\n+\n+    /// Create a `DiagnosticMessage` for the provided Fluent identifier.\n+    pub fn fluent(id: impl Into<FluentId>) -> Self {\n+        DiagnosticMessage::FluentIdentifier(id.into(), None)\n+    }\n+\n+    /// Create a `DiagnosticMessage` for the provided Fluent identifier and attribute.\n+    pub fn fluent_attr(id: impl Into<FluentId>, attr: impl Into<FluentId>) -> Self {\n+        DiagnosticMessage::FluentIdentifier(id.into(), Some(attr.into()))\n+    }\n+}\n+\n+/// `From` impl that enables existing diagnostic calls to functions which now take\n+/// `impl Into<DiagnosticMessage>` to continue to work as before.\n+impl<S: Into<String>> From<S> for DiagnosticMessage {\n+    fn from(s: S) -> Self {\n+        DiagnosticMessage::Str(s.into())\n+    }\n+}\n+\n+/// A span together with some additional data.\n+#[derive(Clone, Debug)]\n+pub struct SpanLabel {\n+    /// The span we are going to include in the final snippet.\n+    pub span: Span,\n+\n+    /// Is this a primary span? This is the \"locus\" of the message,\n+    /// and is indicated with a `^^^^` underline, versus `----`.\n+    pub is_primary: bool,\n+\n+    /// What label should we attach to this span (if any)?\n+    pub label: Option<DiagnosticMessage>,\n+}\n+\n+/// A collection of `Span`s.\n+///\n+/// Spans have two orthogonal attributes:\n+///\n+/// - They can be *primary spans*. In this case they are the locus of\n+///   the error, and would be rendered with `^^^`.\n+/// - They can have a *label*. In this case, the label is written next\n+///   to the mark in the snippet when we render.\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, Encodable, Decodable)]\n+pub struct MultiSpan {\n+    primary_spans: Vec<Span>,\n+    span_labels: Vec<(Span, DiagnosticMessage)>,\n+}\n+\n+impl MultiSpan {\n+    #[inline]\n+    pub fn new() -> MultiSpan {\n+        MultiSpan { primary_spans: vec![], span_labels: vec![] }\n+    }\n+\n+    pub fn from_span(primary_span: Span) -> MultiSpan {\n+        MultiSpan { primary_spans: vec![primary_span], span_labels: vec![] }\n+    }\n+\n+    pub fn from_spans(mut vec: Vec<Span>) -> MultiSpan {\n+        vec.sort();\n+        MultiSpan { primary_spans: vec, span_labels: vec![] }\n+    }\n+\n+    pub fn push_span_label(&mut self, span: Span, label: impl Into<DiagnosticMessage>) {\n+        self.span_labels.push((span, label.into()));\n+    }\n+\n+    /// Selects the first primary span (if any).\n+    pub fn primary_span(&self) -> Option<Span> {\n+        self.primary_spans.first().cloned()\n+    }\n+\n+    /// Returns all primary spans.\n+    pub fn primary_spans(&self) -> &[Span] {\n+        &self.primary_spans\n+    }\n+\n+    /// Returns `true` if any of the primary spans are displayable.\n+    pub fn has_primary_spans(&self) -> bool {\n+        self.primary_spans.iter().any(|sp| !sp.is_dummy())\n+    }\n+\n+    /// Returns `true` if this contains only a dummy primary span with any hygienic context.\n+    pub fn is_dummy(&self) -> bool {\n+        let mut is_dummy = true;\n+        for span in &self.primary_spans {\n+            if !span.is_dummy() {\n+                is_dummy = false;\n+            }\n+        }\n+        is_dummy\n+    }\n+\n+    /// Replaces all occurrences of one Span with another. Used to move `Span`s in areas that don't\n+    /// display well (like std macros). Returns whether replacements occurred.\n+    pub fn replace(&mut self, before: Span, after: Span) -> bool {\n+        let mut replacements_occurred = false;\n+        for primary_span in &mut self.primary_spans {\n+            if *primary_span == before {\n+                *primary_span = after;\n+                replacements_occurred = true;\n+            }\n+        }\n+        for span_label in &mut self.span_labels {\n+            if span_label.0 == before {\n+                span_label.0 = after;\n+                replacements_occurred = true;\n+            }\n+        }\n+        replacements_occurred\n+    }\n+\n+    /// Returns the strings to highlight. We always ensure that there\n+    /// is an entry for each of the primary spans -- for each primary\n+    /// span `P`, if there is at least one label with span `P`, we return\n+    /// those labels (marked as primary). But otherwise we return\n+    /// `SpanLabel` instances with empty labels.\n+    pub fn span_labels(&self) -> Vec<SpanLabel> {\n+        let is_primary = |span| self.primary_spans.contains(&span);\n+\n+        let mut span_labels = self\n+            .span_labels\n+            .iter()\n+            .map(|&(span, ref label)| SpanLabel {\n+                span,\n+                is_primary: is_primary(span),\n+                label: Some(label.clone()),\n+            })\n+            .collect::<Vec<_>>();\n+\n+        for &span in &self.primary_spans {\n+            if !span_labels.iter().any(|sl| sl.span == span) {\n+                span_labels.push(SpanLabel { span, is_primary: true, label: None });\n+            }\n+        }\n+\n+        span_labels\n+    }\n+\n+    /// Returns `true` if any of the span labels is displayable.\n+    pub fn has_span_labels(&self) -> bool {\n+        self.span_labels.iter().any(|(sp, _)| !sp.is_dummy())\n+    }\n+}\n+\n+impl From<Span> for MultiSpan {\n+    fn from(span: Span) -> MultiSpan {\n+        MultiSpan::from_span(span)\n+    }\n+}\n+\n+impl From<Vec<Span>> for MultiSpan {\n+    fn from(spans: Vec<Span>) -> MultiSpan {\n+        MultiSpan::from_spans(spans)\n+    }\n+}"}, {"sha": "5f919982890e0305d7f75bd9170011870dbe0cb3", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -8,6 +8,7 @@ doctest = false\n \n [dependencies]\n tracing = \"0.1\"\n+rustc_error_messages = { path = \"../rustc_error_messages\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "003fd1eea3ace943dbba6f08e90a6b86be3be4fc", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -7,16 +7,23 @@\n \n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n-use crate::{CodeSuggestion, Diagnostic, DiagnosticId, Emitter, Level, SubDiagnostic};\n+use crate::{\n+    CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, Emitter, FluentBundle, Level,\n+    MultiSpan, Style, SubDiagnostic,\n+};\n use annotate_snippets::display_list::{DisplayList, FormatOptions};\n use annotate_snippets::snippet::*;\n use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::FluentArgs;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{MultiSpan, SourceFile};\n+use rustc_span::SourceFile;\n \n /// Generates diagnostics using annotate-snippet\n pub struct AnnotateSnippetEmitterWriter {\n     source_map: Option<Lrc<SourceMap>>,\n+    fluent_bundle: Option<Lrc<FluentBundle>>,\n+    fallback_bundle: Lrc<FluentBundle>,\n+\n     /// If true, hides the longer explanation text\n     short_message: bool,\n     /// If true, will normalize line numbers with `LL` to prevent noise in UI test diffs.\n@@ -28,8 +35,10 @@ pub struct AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let fluent_args = self.to_fluent_args(diag.args());\n+\n         let mut children = diag.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n             &self.source_map,\n@@ -41,7 +50,8 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n \n         self.emit_messages_default(\n             &diag.level,\n-            diag.message(),\n+            &diag.message,\n+            &fluent_args,\n             &diag.code,\n             &primary_span,\n             &children,\n@@ -53,6 +63,14 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         self.source_map.as_ref()\n     }\n \n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        self.fluent_bundle.as_ref()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle> {\n+        &self.fallback_bundle\n+    }\n+\n     fn should_show_explain(&self) -> bool {\n         !self.short_message\n     }\n@@ -82,10 +100,19 @@ fn annotation_type_for_level(level: Level) -> AnnotationType {\n impl AnnotateSnippetEmitterWriter {\n     pub fn new(\n         source_map: Option<Lrc<SourceMap>>,\n+        fluent_bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         short_message: bool,\n         macro_backtrace: bool,\n     ) -> Self {\n-        Self { source_map, short_message, ui_testing: false, macro_backtrace }\n+        Self {\n+            source_map,\n+            fluent_bundle,\n+            fallback_bundle,\n+            short_message,\n+            ui_testing: false,\n+            macro_backtrace,\n+        }\n     }\n \n     /// Allows to modify `Self` to enable or disable the `ui_testing` flag.\n@@ -99,12 +126,14 @@ impl AnnotateSnippetEmitterWriter {\n     fn emit_messages_default(\n         &mut self,\n         level: &Level,\n-        message: String,\n+        messages: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n         code: &Option<DiagnosticId>,\n         msp: &MultiSpan,\n         _children: &[SubDiagnostic],\n         _suggestions: &[CodeSuggestion],\n     ) {\n+        let message = self.translate_messages(messages, args);\n         if let Some(source_map) = &self.source_map {\n             // Make sure our primary file comes first\n             let primary_lo = if let Some(ref primary_span) = msp.primary_span().as_ref() {\n@@ -120,8 +149,7 @@ impl AnnotateSnippetEmitterWriter {\n                 // should be done if it happens\n                 return;\n             };\n-            let mut annotated_files =\n-                FileWithAnnotatedLines::collect_annotations(msp, &self.source_map);\n+            let mut annotated_files = FileWithAnnotatedLines::collect_annotations(self, args, msp);\n             if let Ok(pos) =\n                 annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name))\n             {"}, {"sha": "ecb3cdd627cec71bf6c1d8f1ce9522f9070188ba", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 147, "deletions": 61, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1,15 +1,16 @@\n use crate::snippet::Style;\n-use crate::CodeSuggestion;\n-use crate::Level;\n-use crate::Substitution;\n-use crate::SubstitutionPart;\n-use crate::SuggestionStyle;\n-use crate::ToolMetadata;\n+use crate::{\n+    CodeSuggestion, DiagnosticMessage, Level, MultiSpan, Substitution, SubstitutionPart,\n+    SuggestionStyle, ToolMetadata,\n+};\n use rustc_data_structures::stable_map::FxHashMap;\n+use rustc_error_messages::FluentValue;\n use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_serialize::json::Json;\n use rustc_span::edition::LATEST_STABLE_EDITION;\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n+use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n \n@@ -18,18 +19,79 @@ use std::hash::{Hash, Hasher};\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub struct SuggestionsDisabled;\n \n+/// Simplified version of `FluentArg` that can implement `Encodable` and `Decodable`. Collection of\n+/// `DiagnosticArg` are converted to `FluentArgs` (consuming the collection) at the start of\n+/// diagnostic emission.\n+pub type DiagnosticArg<'source> = (Cow<'source, str>, DiagnosticArgValue<'source>);\n+\n+/// Simplified version of `FluentValue` that can implement `Encodable` and `Decodable`. Converted\n+/// to a `FluentValue` by the emitter to be used in diagnostic translation.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n+pub enum DiagnosticArgValue<'source> {\n+    Str(Cow<'source, str>),\n+    Number(usize),\n+}\n+\n+/// Converts a value of a type into a `DiagnosticArg` (typically a field of a `SessionDiagnostic`\n+/// struct). Implemented as a custom trait rather than `From` so that it is implemented on the type\n+/// being converted rather than on `DiagnosticArgValue`, which enables types from other `rustc_*`\n+/// crates to implement this.\n+pub trait IntoDiagnosticArg {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static>;\n+}\n+\n+impl IntoDiagnosticArg for String {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for Symbol {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_ident_string().into_diagnostic_arg()\n+    }\n+}\n+\n+impl IntoDiagnosticArg for Ident {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n+impl<'a> IntoDiagnosticArg for &'a str {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n+impl IntoDiagnosticArg for usize {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Number(self)\n+    }\n+}\n+\n+impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n+    fn into(self) -> FluentValue<'source> {\n+        match self {\n+            DiagnosticArgValue::Str(s) => From::from(s),\n+            DiagnosticArgValue::Number(n) => From::from(n),\n+        }\n+    }\n+}\n+\n #[must_use]\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct Diagnostic {\n     // NOTE(eddyb) this is private to disallow arbitrary after-the-fact changes,\n     // outside of what methods in this crate themselves allow.\n     crate level: Level,\n \n-    pub message: Vec<(String, Style)>,\n+    pub message: Vec<(DiagnosticMessage, Style)>,\n     pub code: Option<DiagnosticId>,\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n     pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n+    args: Vec<DiagnosticArg<'static>>,\n \n     /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n     /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n@@ -52,7 +114,7 @@ pub enum DiagnosticId {\n #[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct SubDiagnostic {\n     pub level: Level,\n-    pub message: Vec<(String, Style)>,\n+    pub message: Vec<(DiagnosticMessage, Style)>,\n     pub span: MultiSpan,\n     pub render_span: Option<MultiSpan>,\n }\n@@ -105,18 +167,23 @@ impl StringPart {\n }\n \n impl Diagnostic {\n-    pub fn new(level: Level, message: &str) -> Self {\n+    pub fn new<M: Into<DiagnosticMessage>>(level: Level, message: M) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n     }\n \n-    pub fn new_with_code(level: Level, code: Option<DiagnosticId>, message: &str) -> Self {\n+    pub fn new_with_code<M: Into<DiagnosticMessage>>(\n+        level: Level,\n+        code: Option<DiagnosticId>,\n+        message: M,\n+    ) -> Self {\n         Diagnostic {\n             level,\n-            message: vec![(message.to_owned(), Style::NoStyle)],\n+            message: vec![(message.into(), Style::NoStyle)],\n             code,\n             span: MultiSpan::new(),\n             children: vec![],\n             suggestions: Ok(vec![]),\n+            args: vec![],\n             sort_span: DUMMY_SP,\n             is_lint: false,\n         }\n@@ -210,7 +277,7 @@ impl Diagnostic {\n     ///\n     /// This span is *not* considered a [\"primary span\"][`MultiSpan`]; only\n     /// the `Span` supplied when creating the diagnostic is primary.\n-    pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n+    pub fn span_label(&mut self, span: Span, label: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.span.push_span_label(span, label.into());\n         self\n     }\n@@ -234,7 +301,7 @@ impl Diagnostic {\n         self.set_span(after);\n         for span_label in before.span_labels() {\n             if let Some(label) = span_label.label {\n-                self.span_label(after, label);\n+                self.span.push_span_label(after, label);\n             }\n         }\n         self\n@@ -328,52 +395,67 @@ impl Diagnostic {\n     }\n \n     /// Add a note attached to this diagnostic.\n-    pub fn note(&mut self, msg: &str) -> &mut Self {\n+    pub fn note(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.sub(Level::Note, msg, MultiSpan::new(), None);\n         self\n     }\n \n-    pub fn highlighted_note(&mut self, msg: Vec<(String, Style)>) -> &mut Self {\n+    pub fn highlighted_note<M: Into<DiagnosticMessage>>(\n+        &mut self,\n+        msg: Vec<(M, Style)>,\n+    ) -> &mut Self {\n         self.sub_with_highlights(Level::Note, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn note_once(&mut self, msg: &str) -> &mut Self {\n+    pub fn note_once(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.sub(Level::OnceNote, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_note<S: Into<MultiSpan>>(\n+        &mut self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn span_note_once<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_note_once<S: Into<MultiSpan>>(\n+        &mut self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> &mut Self {\n         self.sub(Level::OnceNote, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a warning attached to this diagnostic.\n-    pub fn warn(&mut self, msg: &str) -> &mut Self {\n+    pub fn warn(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a warning above it.\n     /// This is like [`Diagnostic::warn()`], but it gets its own span.\n-    pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_warn<S: Into<MultiSpan>>(\n+        &mut self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> &mut Self {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a help message attached to this diagnostic.\n-    pub fn help(&mut self, msg: &str) -> &mut Self {\n+    pub fn help(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n@@ -386,7 +468,11 @@ impl Diagnostic {\n \n     /// Prints the span with some help above it.\n     /// This is like [`Diagnostic::help()`], but it gets its own span.\n-    pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_help<S: Into<MultiSpan>>(\n+        &mut self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> &mut Self {\n         self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n@@ -422,7 +508,7 @@ impl Diagnostic {\n     /// In other words, multiple changes need to be applied as part of this suggestion.\n     pub fn multipart_suggestion(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -438,7 +524,7 @@ impl Diagnostic {\n     /// In other words, multiple changes need to be applied as part of this suggestion.\n     pub fn multipart_suggestion_verbose(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -452,7 +538,7 @@ impl Diagnostic {\n     /// [`Diagnostic::multipart_suggestion()`] but you can set the [`SuggestionStyle`].\n     pub fn multipart_suggestion_with_style(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n         style: SuggestionStyle,\n@@ -465,7 +551,7 @@ impl Diagnostic {\n                     .map(|(span, snippet)| SubstitutionPart { snippet, span })\n                     .collect(),\n             }],\n-            msg: msg.to_owned(),\n+            msg: msg.into(),\n             style,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -481,7 +567,7 @@ impl Diagnostic {\n     /// improve understandability.\n     pub fn tool_only_multipart_suggestion(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -493,7 +579,7 @@ impl Diagnostic {\n                     .map(|(span, snippet)| SubstitutionPart { snippet, span })\n                     .collect(),\n             }],\n-            msg: msg.to_owned(),\n+            msg: msg.into(),\n             style: SuggestionStyle::CompletelyHidden,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -521,7 +607,7 @@ impl Diagnostic {\n     pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -539,7 +625,7 @@ impl Diagnostic {\n     pub fn span_suggestion_with_style(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n         style: SuggestionStyle,\n@@ -548,7 +634,7 @@ impl Diagnostic {\n             substitutions: vec![Substitution {\n                 parts: vec![SubstitutionPart { snippet: suggestion, span: sp }],\n             }],\n-            msg: msg.to_owned(),\n+            msg: msg.into(),\n             style,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -560,7 +646,7 @@ impl Diagnostic {\n     pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -579,7 +665,7 @@ impl Diagnostic {\n     pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -591,7 +677,7 @@ impl Diagnostic {\n             .collect();\n         self.push_suggestion(CodeSuggestion {\n             substitutions,\n-            msg: msg.to_owned(),\n+            msg: msg.into(),\n             style: SuggestionStyle::ShowCode,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -603,7 +689,7 @@ impl Diagnostic {\n     /// See also [`Diagnostic::span_suggestion()`].\n     pub fn multipart_suggestions(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -616,7 +702,7 @@ impl Diagnostic {\n                         .collect(),\n                 })\n                 .collect(),\n-            msg: msg.to_owned(),\n+            msg: msg.into(),\n             style: SuggestionStyle::ShowCode,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -630,7 +716,7 @@ impl Diagnostic {\n     pub fn span_suggestion_short(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -653,7 +739,7 @@ impl Diagnostic {\n     pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -674,7 +760,7 @@ impl Diagnostic {\n     pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -692,13 +778,13 @@ impl Diagnostic {\n     /// the suggestion in a tool-specific way, as it may not even directly involve Rust code.\n     pub fn tool_only_suggestion_with_metadata(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         applicability: Applicability,\n         tool_metadata: Json,\n     ) {\n         self.push_suggestion(CodeSuggestion {\n             substitutions: vec![],\n-            msg: msg.to_owned(),\n+            msg: msg.into(),\n             style: SuggestionStyle::CompletelyHidden,\n             applicability,\n             tool_metadata: ToolMetadata::new(tool_metadata),\n@@ -732,16 +818,25 @@ impl Diagnostic {\n         self.code.clone()\n     }\n \n-    pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n+    pub fn set_primary_message(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.message[0] = (msg.into(), Style::NoStyle);\n         self\n     }\n \n-    pub fn message(&self) -> String {\n-        self.message.iter().map(|i| i.0.as_str()).collect::<String>()\n+    pub fn args(&self) -> &[DiagnosticArg<'static>] {\n+        &self.args\n+    }\n+\n+    pub fn set_arg(\n+        &mut self,\n+        name: impl Into<Cow<'static, str>>,\n+        arg: DiagnosticArgValue<'static>,\n+    ) -> &mut Self {\n+        self.args.push((name.into(), arg.into()));\n+        self\n     }\n \n-    pub fn styled_message(&self) -> &Vec<(String, Style)> {\n+    pub fn styled_message(&self) -> &Vec<(DiagnosticMessage, Style)> {\n         &self.message\n     }\n \n@@ -752,13 +847,13 @@ impl Diagnostic {\n     pub fn sub(\n         &mut self,\n         level: Level,\n-        message: &str,\n+        message: impl Into<DiagnosticMessage>,\n         span: MultiSpan,\n         render_span: Option<MultiSpan>,\n     ) {\n         let sub = SubDiagnostic {\n             level,\n-            message: vec![(message.to_owned(), Style::NoStyle)],\n+            message: vec![(message.into(), Style::NoStyle)],\n             span,\n             render_span,\n         };\n@@ -767,13 +862,14 @@ impl Diagnostic {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// public methods above.\n-    fn sub_with_highlights(\n+    fn sub_with_highlights<M: Into<DiagnosticMessage>>(\n         &mut self,\n         level: Level,\n-        message: Vec<(String, Style)>,\n+        mut message: Vec<(M, Style)>,\n         span: MultiSpan,\n         render_span: Option<MultiSpan>,\n     ) {\n+        let message = message.drain(..).map(|m| (m.0.into(), m.1)).collect();\n         let sub = SubDiagnostic { level, message, span, render_span };\n         self.children.push(sub);\n     }\n@@ -783,7 +879,7 @@ impl Diagnostic {\n         &self,\n     ) -> (\n         &Level,\n-        &Vec<(String, Style)>,\n+        &Vec<(DiagnosticMessage, Style)>,\n         &Option<DiagnosticId>,\n         &MultiSpan,\n         &Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n@@ -814,13 +910,3 @@ impl PartialEq for Diagnostic {\n         self.keys() == other.keys()\n     }\n }\n-\n-impl SubDiagnostic {\n-    pub fn message(&self) -> String {\n-        self.message.iter().map(|i| i.0.as_str()).collect::<String>()\n-    }\n-\n-    pub fn styled_message(&self) -> &Vec<(String, Style)> {\n-        &self.message\n-    }\n-}"}, {"sha": "74e0f7429461389194ae4f943e251750fafed9ac", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1,8 +1,10 @@\n-use crate::{Diagnostic, DiagnosticId, DiagnosticStyledString, ErrorGuaranteed};\n-use crate::{Handler, Level, StashKey};\n+use crate::diagnostic::DiagnosticArgValue;\n+use crate::{Diagnostic, DiagnosticId, DiagnosticMessage, DiagnosticStyledString, ErrorGuaranteed};\n+use crate::{Handler, Level, MultiSpan, StashKey};\n use rustc_lint_defs::Applicability;\n \n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n+use std::borrow::Cow;\n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n@@ -99,7 +101,10 @@ mod sealed_level_is_error {\n impl<'a> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new_guaranteeing_error<const L: Level>(handler: &'a Handler, message: &str) -> Self\n+    crate fn new_guaranteeing_error<M: Into<DiagnosticMessage>, const L: Level>(\n+        handler: &'a Handler,\n+        message: M,\n+    ) -> Self\n     where\n         (): sealed_level_is_error::IsError<L>,\n     {\n@@ -163,7 +168,11 @@ impl EmissionGuarantee for ErrorGuaranteed {\n impl<'a> DiagnosticBuilder<'a, ()> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new(handler: &'a Handler, level: Level, message: &str) -> Self {\n+    crate fn new<M: Into<DiagnosticMessage>>(\n+        handler: &'a Handler,\n+        level: Level,\n+        message: M,\n+    ) -> Self {\n         let diagnostic = Diagnostic::new_with_code(level, None, message);\n         Self::new_diagnostic(handler, diagnostic)\n     }\n@@ -201,7 +210,7 @@ impl EmissionGuarantee for () {\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new_fatal(handler: &'a Handler, message: &str) -> Self {\n+    crate fn new_fatal(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n         let diagnostic = Diagnostic::new_with_code(Level::Fatal, None, message);\n         Self::new_diagnostic_fatal(handler, diagnostic)\n     }\n@@ -346,7 +355,7 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         }\n \n         // Take the `Diagnostic` by replacing it with a dummy.\n-        let dummy = Diagnostic::new(Level::Allow, \"\");\n+        let dummy = Diagnostic::new(Level::Allow, DiagnosticMessage::Str(\"\".to_string()));\n         let diagnostic = std::mem::replace(&mut *self.inner.diagnostic, dummy);\n \n         // Disable the ICE on `Drop`.\n@@ -399,7 +408,7 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n     /// the diagnostic was constructed. However, the label span is *not* considered a\n     /// [\"primary span\"][`MultiSpan`]; only the `Span` supplied when creating the diagnostic is\n     /// primary.\n-    pub fn span_label(&mut self, span: Span, label: impl Into<String>) -> &mut Self);\n+    pub fn span_label(&mut self, span: Span, label: impl Into<DiagnosticMessage>) -> &mut Self);\n \n     forward!(\n     /// Labels all the given spans with the provided label.\n@@ -434,25 +443,25 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         found: DiagnosticStyledString,\n     ) -> &mut Self);\n \n-    forward!(pub fn note(&mut self, msg: &str) -> &mut Self);\n-    forward!(pub fn note_once(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn note(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n+    forward!(pub fn note_once(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n     forward!(pub fn span_note(\n         &mut self,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> &mut Self);\n     forward!(pub fn span_note_once(\n         &mut self,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> &mut Self);\n-    forward!(pub fn warn(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn warn(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n     forward!(pub fn span_warn(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> &mut Self);\n-    forward!(pub fn help(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn help(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n     forward!(pub fn span_help(\n         &mut self,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> &mut Self);\n     forward!(pub fn help_use_latest_edition(&mut self,) -> &mut Self);\n     forward!(pub fn set_is_lint(&mut self,) -> &mut Self);\n@@ -461,74 +470,79 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n \n     forward!(pub fn multipart_suggestion(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn multipart_suggestion_verbose(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn tool_only_multipart_suggestion(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn multipart_suggestions(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_short(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n \n     forward!(pub fn set_primary_message(&mut self, msg: impl Into<String>) -> &mut Self);\n     forward!(pub fn set_span(&mut self, sp: impl Into<MultiSpan>) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n+    forward!(pub fn set_arg(\n+        &mut self,\n+        name: impl Into<Cow<'static, str>>,\n+        arg: DiagnosticArgValue<'static>,\n+    ) -> &mut Self);\n }\n \n impl<G: EmissionGuarantee> Debug for DiagnosticBuilder<'_, G> {\n@@ -547,7 +561,9 @@ impl Drop for DiagnosticBuilderInner<'_> {\n                 if !panicking() {\n                     handler.emit_diagnostic(&mut Diagnostic::new(\n                         Level::Bug,\n-                        \"the following error was constructed but not emitted\",\n+                        DiagnosticMessage::Str(\n+                            \"the following error was constructed but not emitted\".to_string(),\n+                        ),\n                     ));\n                     handler.emit_diagnostic(&mut self.diagnostic);\n                     panic!();"}, {"sha": "6a763d4d1404b1e6bc6183a4645c3b6bbf40f5dc", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 153, "deletions": 24, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -10,19 +10,20 @@\n use Destination::*;\n \n use rustc_span::source_map::SourceMap;\n-use rustc_span::{MultiSpan, SourceFile, Span};\n+use rustc_span::{SourceFile, Span};\n \n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n use crate::{\n-    CodeSuggestion, Diagnostic, DiagnosticId, Handler, Level, SubDiagnostic, SubstitutionHighlight,\n-    SuggestionStyle,\n+    CodeSuggestion, Diagnostic, DiagnosticArg, DiagnosticId, DiagnosticMessage, FluentBundle,\n+    Handler, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n };\n \n use rustc_lint_defs::pluralize;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::FluentArgs;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use std::borrow::Cow;\n use std::cmp::{max, min, Reverse};\n@@ -58,13 +59,25 @@ impl HumanReadableErrorType {\n         self,\n         dst: Box<dyn Write + Send>,\n         source_map: Option<Lrc<SourceMap>>,\n+        bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         teach: bool,\n         terminal_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n         let color = color_config.suggests_using_colors();\n-        EmitterWriter::new(dst, source_map, short, teach, color, terminal_width, macro_backtrace)\n+        EmitterWriter::new(\n+            dst,\n+            source_map,\n+            bundle,\n+            fallback_bundle,\n+            short,\n+            teach,\n+            color,\n+            terminal_width,\n+            macro_backtrace,\n+        )\n     }\n }\n \n@@ -212,6 +225,74 @@ pub trait Emitter {\n \n     fn source_map(&self) -> Option<&Lrc<SourceMap>>;\n \n+    /// Return `FluentBundle` with localized diagnostics for the locale requested by the user. If no\n+    /// language was requested by the user then this will be `None` and `fallback_fluent_bundle`\n+    /// should be used.\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>>;\n+\n+    /// Return `FluentBundle` with localized diagnostics for the default locale of the compiler.\n+    /// Used when the user has not requested a specific language or when a localized diagnostic is\n+    /// unavailable for the requested locale.\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle>;\n+\n+    /// Convert diagnostic arguments (a rustc internal type that exists to implement\n+    /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n+    ///\n+    /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n+    /// passed around as a reference thereafter.\n+    fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n+        FromIterator::from_iter(args.to_vec().drain(..))\n+    }\n+\n+    /// Convert `DiagnosticMessage`s to a string, performing translation if necessary.\n+    fn translate_messages(\n+        &self,\n+        messages: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n+    ) -> Cow<'_, str> {\n+        Cow::Owned(\n+            messages.iter().map(|(m, _)| self.translate_message(m, args)).collect::<String>(),\n+        )\n+    }\n+\n+    /// Convert a `DiagnosticMessage` to a string, performing translation if necessary.\n+    fn translate_message<'a>(\n+        &'a self,\n+        message: &'a DiagnosticMessage,\n+        args: &'a FluentArgs<'_>,\n+    ) -> Cow<'_, str> {\n+        trace!(?message, ?args);\n+        let (identifier, attr) = match message {\n+            DiagnosticMessage::Str(msg) => return Cow::Borrowed(&msg),\n+            DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n+        };\n+\n+        let bundle = match self.fluent_bundle() {\n+            Some(bundle) if bundle.has_message(&identifier) => bundle,\n+            _ => self.fallback_fluent_bundle(),\n+        };\n+\n+        let message = bundle.get_message(&identifier).expect(\"missing diagnostic in fluent bundle\");\n+        let value = match attr {\n+            Some(attr) => {\n+                message.get_attribute(attr).expect(\"missing attribute in fluent message\").value()\n+            }\n+            None => message.value().expect(\"missing value in fluent message\"),\n+        };\n+\n+        let mut err = vec![];\n+        let translated = bundle.format_pattern(value, Some(&args), &mut err);\n+        trace!(?translated, ?err);\n+        debug_assert!(\n+            err.is_empty(),\n+            \"identifier: {:?}, args: {:?}, errors: {:?}\",\n+            identifier,\n+            args,\n+            err\n+        );\n+        translated\n+    }\n+\n     /// Formats the substitutions of the primary_span\n     ///\n     /// There are a lot of conditions to this method, but in short:\n@@ -225,18 +306,20 @@ pub trait Emitter {\n     fn primary_span_formatted<'a>(\n         &mut self,\n         diag: &'a Diagnostic,\n+        fluent_args: &FluentArgs<'_>,\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = diag.span.clone();\n         let suggestions = diag.suggestions.as_ref().map_or(&[][..], |suggestions| &suggestions[..]);\n         if let Some((sugg, rest)) = suggestions.split_first() {\n+            let msg = self.translate_message(&sugg.msg, fluent_args);\n             if rest.is_empty() &&\n                // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n                sugg.substitutions.len() == 1 &&\n                // don't display multipart suggestions as labels\n                sugg.substitutions[0].parts.len() == 1 &&\n                // don't display long messages as labels\n-               sugg.msg.split_whitespace().count() < 10 &&\n+               msg.split_whitespace().count() < 10 &&\n                // don't display multiline suggestions as labels\n                !sugg.substitutions[0].parts[0].snippet.contains('\\n') &&\n                ![\n@@ -252,12 +335,12 @@ pub trait Emitter {\n                 let msg = if substitution.is_empty() || sugg.style.hide_inline() {\n                     // This substitution is only removal OR we explicitly don't want to show the\n                     // code inline (`hide_inline`). Therefore, we don't show the substitution.\n-                    format!(\"help: {}\", sugg.msg)\n+                    format!(\"help: {}\", &msg)\n                 } else {\n                     // Show the default suggestion text with the substitution\n                     format!(\n                         \"help: {}{}: `{}`\",\n-                        sugg.msg,\n+                        &msg,\n                         if self\n                             .source_map()\n                             .map(|sm| is_case_difference(\n@@ -333,7 +416,7 @@ pub trait Emitter {\n \n                 children.push(SubDiagnostic {\n                     level: Level::Note,\n-                    message: vec![(msg, Style::NoStyle)],\n+                    message: vec![(DiagnosticMessage::Str(msg), Style::NoStyle)],\n                     span: MultiSpan::new(),\n                     render_span: None,\n                 });\n@@ -492,9 +575,19 @@ impl Emitter for EmitterWriter {\n         self.sm.as_ref()\n     }\n \n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        self.fluent_bundle.as_ref()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle> {\n+        &self.fallback_bundle\n+    }\n+\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let fluent_args = self.to_fluent_args(diag.args());\n+\n         let mut children = diag.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n         debug!(\"emit_diagnostic: suggestions={:?}\", suggestions);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n@@ -507,7 +600,8 @@ impl Emitter for EmitterWriter {\n \n         self.emit_messages_default(\n             &diag.level,\n-            &diag.styled_message(),\n+            &diag.message,\n+            &fluent_args,\n             &diag.code,\n             &primary_span,\n             &children,\n@@ -536,6 +630,15 @@ impl Emitter for SilentEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle> {\n+        panic!(\"silent emitter attempted to translate message\")\n+    }\n+\n     fn emit_diagnostic(&mut self, d: &Diagnostic) {\n         if d.level == Level::Fatal {\n             let mut d = d.clone();\n@@ -591,6 +694,8 @@ impl ColorConfig {\n pub struct EmitterWriter {\n     dst: Destination,\n     sm: Option<Lrc<SourceMap>>,\n+    fluent_bundle: Option<Lrc<FluentBundle>>,\n+    fallback_bundle: Lrc<FluentBundle>,\n     short_message: bool,\n     teach: bool,\n     ui_testing: bool,\n@@ -610,6 +715,8 @@ impl EmitterWriter {\n     pub fn stderr(\n         color_config: ColorConfig,\n         source_map: Option<Lrc<SourceMap>>,\n+        fluent_bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         short_message: bool,\n         teach: bool,\n         terminal_width: Option<usize>,\n@@ -619,6 +726,8 @@ impl EmitterWriter {\n         EmitterWriter {\n             dst,\n             sm: source_map,\n+            fluent_bundle,\n+            fallback_bundle,\n             short_message,\n             teach,\n             ui_testing: false,\n@@ -630,6 +739,8 @@ impl EmitterWriter {\n     pub fn new(\n         dst: Box<dyn Write + Send>,\n         source_map: Option<Lrc<SourceMap>>,\n+        fluent_bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         short_message: bool,\n         teach: bool,\n         colored: bool,\n@@ -639,6 +750,8 @@ impl EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst, colored),\n             sm: source_map,\n+            fluent_bundle,\n+            fallback_bundle,\n             short_message,\n             teach,\n             ui_testing: false,\n@@ -1176,7 +1289,8 @@ impl EmitterWriter {\n     fn msg_to_buffer(\n         &self,\n         buffer: &mut StyledBuffer,\n-        msg: &[(String, Style)],\n+        msg: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n         padding: usize,\n         label: &str,\n         override_style: Option<Style>,\n@@ -1229,6 +1343,7 @@ impl EmitterWriter {\n         //                very *weird* formats\n         //                see?\n         for &(ref text, ref style) in msg.iter() {\n+            let text = self.translate_message(text, args);\n             let lines = text.split('\\n').collect::<Vec<_>>();\n             if lines.len() > 1 {\n                 for (i, line) in lines.iter().enumerate() {\n@@ -1239,15 +1354,16 @@ impl EmitterWriter {\n                     buffer.append(line_number, line, style_or_override(*style, override_style));\n                 }\n             } else {\n-                buffer.append(line_number, text, style_or_override(*style, override_style));\n+                buffer.append(line_number, &text, style_or_override(*style, override_style));\n             }\n         }\n     }\n \n     fn emit_message_default(\n         &mut self,\n         msp: &MultiSpan,\n-        msg: &[(String, Style)],\n+        msg: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n         code: &Option<DiagnosticId>,\n         level: &Level,\n         max_line_num_len: usize,\n@@ -1266,7 +1382,7 @@ impl EmitterWriter {\n                 buffer.append(0, level.to_str(), Style::MainHeaderMsg);\n                 buffer.append(0, \": \", Style::NoStyle);\n             }\n-            self.msg_to_buffer(&mut buffer, msg, max_line_num_len, \"note\", None);\n+            self.msg_to_buffer(&mut buffer, msg, args, max_line_num_len, \"note\", None);\n         } else {\n             let mut label_width = 0;\n             // The failure note level itself does not provide any useful diagnostic information\n@@ -1287,8 +1403,9 @@ impl EmitterWriter {\n                 label_width += 2;\n             }\n             for &(ref text, _) in msg.iter() {\n+                let text = self.translate_message(text, args);\n                 // Account for newlines to align output to its label.\n-                for (line, text) in normalize_whitespace(text).lines().enumerate() {\n+                for (line, text) in normalize_whitespace(&text).lines().enumerate() {\n                     buffer.append(\n                         0 + line,\n                         &format!(\n@@ -1302,7 +1419,7 @@ impl EmitterWriter {\n             }\n         }\n \n-        let mut annotated_files = FileWithAnnotatedLines::collect_annotations(msp, &self.sm);\n+        let mut annotated_files = FileWithAnnotatedLines::collect_annotations(self, args, msp);\n \n         // Make sure our primary file comes first\n         let (primary_lo, sm) = if let (Some(sm), Some(ref primary_span)) =\n@@ -1586,6 +1703,7 @@ impl EmitterWriter {\n     fn emit_suggestion_default(\n         &mut self,\n         suggestion: &CodeSuggestion,\n+        args: &FluentArgs<'_>,\n         level: &Level,\n         max_line_num_len: usize,\n     ) -> io::Result<()> {\n@@ -1612,6 +1730,7 @@ impl EmitterWriter {\n         self.msg_to_buffer(\n             &mut buffer,\n             &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+            args,\n             max_line_num_len,\n             \"suggestion\",\n             Some(Style::HeaderMsg),\n@@ -1852,7 +1971,8 @@ impl EmitterWriter {\n     fn emit_messages_default(\n         &mut self,\n         level: &Level,\n-        message: &[(String, Style)],\n+        message: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n         code: &Option<DiagnosticId>,\n         span: &MultiSpan,\n         children: &[SubDiagnostic],\n@@ -1865,7 +1985,7 @@ impl EmitterWriter {\n             num_decimal_digits(n)\n         };\n \n-        match self.emit_message_default(span, message, code, level, max_line_num_len, false) {\n+        match self.emit_message_default(span, message, args, code, level, max_line_num_len, false) {\n             Ok(()) => {\n                 if !children.is_empty()\n                     || suggestions.iter().any(|s| s.style != SuggestionStyle::CompletelyHidden)\n@@ -1888,7 +2008,8 @@ impl EmitterWriter {\n                         let span = child.render_span.as_ref().unwrap_or(&child.span);\n                         if let Err(err) = self.emit_message_default(\n                             &span,\n-                            &child.styled_message(),\n+                            &child.message,\n+                            args,\n                             &None,\n                             &child.level,\n                             max_line_num_len,\n@@ -1904,6 +2025,7 @@ impl EmitterWriter {\n                             if let Err(e) = self.emit_message_default(\n                                 &MultiSpan::new(),\n                                 &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n+                                args,\n                                 &None,\n                                 &Level::Help,\n                                 max_line_num_len,\n@@ -1912,7 +2034,7 @@ impl EmitterWriter {\n                                 panic!(\"failed to emit error: {}\", e);\n                             }\n                         } else if let Err(e) =\n-                            self.emit_suggestion_default(sugg, &Level::Help, max_line_num_len)\n+                            self.emit_suggestion_default(sugg, args, &Level::Help, max_line_num_len)\n                         {\n                             panic!(\"failed to emit error: {}\", e);\n                         };\n@@ -1938,8 +2060,9 @@ impl FileWithAnnotatedLines {\n     /// Preprocess all the annotations so that they are grouped by file and by line number\n     /// This helps us quickly iterate over the whole message (including secondary file spans)\n     pub fn collect_annotations(\n+        emitter: &dyn Emitter,\n+        args: &FluentArgs<'_>,\n         msp: &MultiSpan,\n-        source_map: &Option<Lrc<SourceMap>>,\n     ) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(\n             file_vec: &mut Vec<FileWithAnnotatedLines>,\n@@ -1974,7 +2097,7 @@ impl FileWithAnnotatedLines {\n         let mut output = vec![];\n         let mut multiline_annotations = vec![];\n \n-        if let Some(ref sm) = source_map {\n+        if let Some(ref sm) = emitter.source_map() {\n             for span_label in msp.span_labels() {\n                 if span_label.span.is_dummy() {\n                     continue;\n@@ -2001,7 +2124,10 @@ impl FileWithAnnotatedLines {\n                         start_col: lo.col_display,\n                         end_col: hi.col_display,\n                         is_primary: span_label.is_primary,\n-                        label: span_label.label,\n+                        label: span_label\n+                            .label\n+                            .as_ref()\n+                            .map(|m| emitter.translate_message(m, args).to_string()),\n                         overlaps_exactly: false,\n                     };\n                     multiline_annotations.push((lo.file, ml));\n@@ -2010,7 +2136,10 @@ impl FileWithAnnotatedLines {\n                         start_col: lo.col_display,\n                         end_col: hi.col_display,\n                         is_primary: span_label.is_primary,\n-                        label: span_label.label,\n+                        label: span_label\n+                            .label\n+                            .as_ref()\n+                            .map(|m| emitter.translate_message(m, args).to_string()),\n                         annotation_type: AnnotationType::Singleline,\n                     };\n                     add_annotation_to_file(&mut output, lo.file, lo.line, ann);"}, {"sha": "f78490da245b25ab446e43168186c07f96618da9", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 72, "deletions": 21, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -15,12 +15,13 @@ use crate::emitter::{Emitter, HumanReadableErrorType};\n use crate::registry::Registry;\n use crate::DiagnosticId;\n use crate::ToolMetadata;\n-use crate::{CodeSuggestion, SubDiagnostic};\n+use crate::{CodeSuggestion, FluentBundle, MultiSpan, SpanLabel, SubDiagnostic};\n use rustc_lint_defs::Applicability;\n \n use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::FluentArgs;\n use rustc_span::hygiene::ExpnData;\n-use rustc_span::{MultiSpan, Span, SpanLabel};\n+use rustc_span::Span;\n use std::io::{self, Write};\n use std::path::Path;\n use std::sync::{Arc, Mutex};\n@@ -36,6 +37,8 @@ pub struct JsonEmitter {\n     dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n     sm: Lrc<SourceMap>,\n+    fluent_bundle: Option<Lrc<FluentBundle>>,\n+    fallback_bundle: Lrc<FluentBundle>,\n     pretty: bool,\n     ui_testing: bool,\n     json_rendered: HumanReadableErrorType,\n@@ -47,6 +50,8 @@ impl JsonEmitter {\n     pub fn stderr(\n         registry: Option<Registry>,\n         source_map: Lrc<SourceMap>,\n+        fluent_bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n         terminal_width: Option<usize>,\n@@ -56,6 +61,8 @@ impl JsonEmitter {\n             dst: Box::new(io::BufWriter::new(io::stderr())),\n             registry,\n             sm: source_map,\n+            fluent_bundle,\n+            fallback_bundle,\n             pretty,\n             ui_testing: false,\n             json_rendered,\n@@ -67,13 +74,17 @@ impl JsonEmitter {\n     pub fn basic(\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n+        fluent_bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         terminal_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n         JsonEmitter::stderr(\n             None,\n             Lrc::new(SourceMap::new(file_path_mapping)),\n+            fluent_bundle,\n+            fallback_bundle,\n             pretty,\n             json_rendered,\n             terminal_width,\n@@ -85,6 +96,8 @@ impl JsonEmitter {\n         dst: Box<dyn Write + Send>,\n         registry: Option<Registry>,\n         source_map: Lrc<SourceMap>,\n+        fluent_bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n         terminal_width: Option<usize>,\n@@ -94,6 +107,8 @@ impl JsonEmitter {\n             dst,\n             registry,\n             sm: source_map,\n+            fluent_bundle,\n+            fallback_bundle,\n             pretty,\n             ui_testing: false,\n             json_rendered,\n@@ -173,6 +188,14 @@ impl Emitter for JsonEmitter {\n         Some(&self.sm)\n     }\n \n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        self.fluent_bundle.as_ref()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle> {\n+        &self.fallback_bundle\n+    }\n+\n     fn should_show_explain(&self) -> bool {\n         !matches!(self.json_rendered, HumanReadableErrorType::Short(_))\n     }\n@@ -345,14 +368,18 @@ struct UnusedExterns<'a, 'b, 'c> {\n \n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n-        let sugg = diag.suggestions.iter().flatten().map(|sugg| Diagnostic {\n-            message: sugg.msg.clone(),\n-            code: None,\n-            level: \"help\",\n-            spans: DiagnosticSpan::from_suggestion(sugg, je),\n-            children: vec![],\n-            rendered: None,\n-            tool_metadata: sugg.tool_metadata.clone(),\n+        let args = je.to_fluent_args(diag.args());\n+        let sugg = diag.suggestions.iter().flatten().map(|sugg| {\n+            let translated_message = je.translate_message(&sugg.msg, &args);\n+            Diagnostic {\n+                message: translated_message.to_string(),\n+                code: None,\n+                level: \"help\",\n+                spans: DiagnosticSpan::from_suggestion(sugg, &args, je),\n+                children: vec![],\n+                rendered: None,\n+                tool_metadata: sugg.tool_metadata.clone(),\n+            }\n         });\n \n         // generate regular command line output and store it in the json\n@@ -375,6 +402,8 @@ impl Diagnostic {\n             .new_emitter(\n                 Box::new(buf),\n                 Some(je.sm.clone()),\n+                je.fluent_bundle.clone(),\n+                je.fallback_bundle.clone(),\n                 false,\n                 je.terminal_width,\n                 je.macro_backtrace,\n@@ -384,32 +413,38 @@ impl Diagnostic {\n         let output = Arc::try_unwrap(output.0).unwrap().into_inner().unwrap();\n         let output = String::from_utf8(output).unwrap();\n \n+        let translated_message = je.translate_messages(&diag.message, &args);\n         Diagnostic {\n-            message: diag.message(),\n+            message: translated_message.to_string(),\n             code: DiagnosticCode::map_opt_string(diag.code.clone(), je),\n             level: diag.level.to_str(),\n-            spans: DiagnosticSpan::from_multispan(&diag.span, je),\n+            spans: DiagnosticSpan::from_multispan(&diag.span, &args, je),\n             children: diag\n                 .children\n                 .iter()\n-                .map(|c| Diagnostic::from_sub_diagnostic(c, je))\n+                .map(|c| Diagnostic::from_sub_diagnostic(c, &args, je))\n                 .chain(sugg)\n                 .collect(),\n             rendered: Some(output),\n             tool_metadata: ToolMetadata::default(),\n         }\n     }\n \n-    fn from_sub_diagnostic(diag: &SubDiagnostic, je: &JsonEmitter) -> Diagnostic {\n+    fn from_sub_diagnostic(\n+        diag: &SubDiagnostic,\n+        args: &FluentArgs<'_>,\n+        je: &JsonEmitter,\n+    ) -> Diagnostic {\n+        let translated_message = je.translate_messages(&diag.message, args);\n         Diagnostic {\n-            message: diag.message(),\n+            message: translated_message.to_string(),\n             code: None,\n             level: diag.level.to_str(),\n             spans: diag\n                 .render_span\n                 .as_ref()\n-                .map(|sp| DiagnosticSpan::from_multispan(sp, je))\n-                .unwrap_or_else(|| DiagnosticSpan::from_multispan(&diag.span, je)),\n+                .map(|sp| DiagnosticSpan::from_multispan(sp, args, je))\n+                .unwrap_or_else(|| DiagnosticSpan::from_multispan(&diag.span, args, je)),\n             children: vec![],\n             rendered: None,\n             tool_metadata: ToolMetadata::default(),\n@@ -421,9 +456,16 @@ impl DiagnosticSpan {\n     fn from_span_label(\n         span: SpanLabel,\n         suggestion: Option<(&String, Applicability)>,\n+        args: &FluentArgs<'_>,\n         je: &JsonEmitter,\n     ) -> DiagnosticSpan {\n-        Self::from_span_etc(span.span, span.is_primary, span.label, suggestion, je)\n+        Self::from_span_etc(\n+            span.span,\n+            span.is_primary,\n+            span.label.as_ref().map(|m| je.translate_message(m, args)).map(|m| m.to_string()),\n+            suggestion,\n+            je,\n+        )\n     }\n \n     fn from_span_etc(\n@@ -486,14 +528,22 @@ impl DiagnosticSpan {\n         }\n     }\n \n-    fn from_multispan(msp: &MultiSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n+    fn from_multispan(\n+        msp: &MultiSpan,\n+        args: &FluentArgs<'_>,\n+        je: &JsonEmitter,\n+    ) -> Vec<DiagnosticSpan> {\n         msp.span_labels()\n             .into_iter()\n-            .map(|span_str| Self::from_span_label(span_str, None, je))\n+            .map(|span_str| Self::from_span_label(span_str, None, args, je))\n             .collect()\n     }\n \n-    fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n+    fn from_suggestion(\n+        suggestion: &CodeSuggestion,\n+        args: &FluentArgs<'_>,\n+        je: &JsonEmitter,\n+    ) -> Vec<DiagnosticSpan> {\n         suggestion\n             .substitutions\n             .iter()\n@@ -504,6 +554,7 @@ impl DiagnosticSpan {\n                     DiagnosticSpan::from_span_label(\n                         span_label,\n                         Some((&suggestion_inner.snippet, suggestion.applicability)),\n+                        args,\n                         je,\n                     )\n                 })"}, {"sha": "0f175c732c19c0a5cf078b5436b5e923400a8929", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -39,12 +39,16 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n     rustc_span::create_default_session_globals_then(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         sm.new_source_file(Path::new(\"test.rs\").to_owned().into(), code.to_owned());\n+        let fallback_bundle =\n+            crate::fallback_fluent_bundle(false).expect(\"failed to load fallback fluent bundle\");\n \n         let output = Arc::new(Mutex::new(Vec::new()));\n         let je = JsonEmitter::new(\n             Box::new(Shared { data: output.clone() }),\n             None,\n             sm,\n+            None,\n+            fallback_bundle,\n             true,\n             HumanReadableErrorType::Short(ColorConfig::Never),\n             None,"}, {"sha": "c927fcb2109cb95ba6c4c27e537732a8c3d649ca", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 121, "deletions": 47, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -31,11 +31,15 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n+pub use rustc_error_messages::{\n+    fallback_fluent_bundle, fluent_bundle, DiagnosticMessage, FluentBundle, LanguageIdentifier,\n+    MultiSpan, SpanLabel,\n+};\n pub use rustc_lint_defs::{pluralize, Applicability};\n use rustc_serialize::json::Json;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{Loc, MultiSpan, Span};\n+use rustc_span::{Loc, Span};\n \n use std::borrow::Cow;\n use std::hash::{Hash, Hasher};\n@@ -55,6 +59,7 @@ mod lock;\n pub mod registry;\n mod snippet;\n mod styled_buffer;\n+\n pub use snippet::Style;\n \n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a, ErrorGuaranteed>>;\n@@ -145,7 +150,7 @@ pub struct CodeSuggestion {\n     /// ]\n     /// ```\n     pub substitutions: Vec<Substitution>,\n-    pub msg: String,\n+    pub msg: DiagnosticMessage,\n     /// Visual representation of this suggestion.\n     pub style: SuggestionStyle,\n     /// Whether or not the suggestion is approximate\n@@ -400,7 +405,10 @@ impl fmt::Display for ExplicitBug {\n \n impl error::Error for ExplicitBug {}\n \n-pub use diagnostic::{Diagnostic, DiagnosticId, DiagnosticStyledString, SubDiagnostic};\n+pub use diagnostic::{\n+    Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId, DiagnosticStyledString,\n+    IntoDiagnosticArg, SubDiagnostic,\n+};\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee};\n use std::backtrace::Backtrace;\n \n@@ -538,22 +546,30 @@ impl Handler {\n         can_emit_warnings: bool,\n         treat_err_as_bug: Option<NonZeroUsize>,\n         sm: Option<Lrc<SourceMap>>,\n+        fluent_bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n     ) -> Self {\n         Self::with_tty_emitter_and_flags(\n             color_config,\n             sm,\n+            fluent_bundle,\n+            fallback_bundle,\n             HandlerFlags { can_emit_warnings, treat_err_as_bug, ..Default::default() },\n         )\n     }\n \n     pub fn with_tty_emitter_and_flags(\n         color_config: ColorConfig,\n         sm: Option<Lrc<SourceMap>>,\n+        fluent_bundle: Option<Lrc<FluentBundle>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         flags: HandlerFlags,\n     ) -> Self {\n         let emitter = Box::new(EmitterWriter::stderr(\n             color_config,\n             sm,\n+            fluent_bundle,\n+            fallback_bundle,\n             false,\n             false,\n             None,\n@@ -658,7 +674,7 @@ impl Handler {\n     pub fn struct_span_warn(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         let mut result = self.struct_warn(msg);\n         result.set_span(span);\n@@ -669,7 +685,7 @@ impl Handler {\n     pub fn struct_span_allow(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         let mut result = self.struct_allow(msg);\n         result.set_span(span);\n@@ -681,7 +697,7 @@ impl Handler {\n     pub fn struct_span_warn_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         let mut result = self.struct_span_warn(span, msg);\n@@ -694,25 +710,29 @@ impl Handler {\n     /// Attempting to `.emit()` the builder will only emit if either:\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n-    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Warning, msg)\n     }\n \n     /// Construct a builder at the `Allow` level with the `msg`.\n-    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Allow, msg)\n     }\n \n     /// Construct a builder at the `Expect` level with the `msg`.\n-    pub fn struct_expect(&self, msg: &str, id: LintExpectationId) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_expect(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+        id: LintExpectationId,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Expect(id), msg)\n     }\n \n     /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n     pub fn struct_span_err(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut result = self.struct_err(msg);\n         result.set_span(span);\n@@ -723,7 +743,7 @@ impl Handler {\n     pub fn struct_span_err_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut result = self.struct_span_err(span, msg);\n@@ -733,32 +753,46 @@ impl Handler {\n \n     /// Construct a builder at the `Error` level with the `msg`.\n     // FIXME: This method should be removed (every error should have an associated error code).\n-    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        DiagnosticBuilder::new_guaranteeing_error::<{ Level::Error { lint: false } }>(self, msg)\n+    pub fn struct_err(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        DiagnosticBuilder::new_guaranteeing_error::<_, { Level::Error { lint: false } }>(self, msg)\n     }\n \n     /// This should only be used by `rustc_middle::lint::struct_lint_level`. Do not use it for hard errors.\n     #[doc(hidden)]\n-    pub fn struct_err_lint(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_err_lint(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Error { lint: true }, msg)\n     }\n \n     /// Construct a builder at the `Error` level with the `msg` and the `code`.\n     pub fn struct_err_with_code(\n         &self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut result = self.struct_err(msg);\n         result.code(code);\n         result\n     }\n \n+    /// Construct a builder at the `Warn` level with the `msg` and the `code`.\n+    pub fn struct_warn_with_code(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_, ()> {\n+        let mut result = self.struct_warn(msg);\n+        result.code(code);\n+        result\n+    }\n+\n     /// Construct a builder at the `Fatal` level at the given `span` and with the `msg`.\n     pub fn struct_span_fatal(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, !> {\n         let mut result = self.struct_fatal(msg);\n         result.set_span(span);\n@@ -769,7 +803,7 @@ impl Handler {\n     pub fn struct_span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, !> {\n         let mut result = self.struct_span_fatal(span, msg);\n@@ -778,102 +812,131 @@ impl Handler {\n     }\n \n     /// Construct a builder at the `Error` level with the `msg`.\n-    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_, !> {\n+    pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         DiagnosticBuilder::new_fatal(self, msg)\n     }\n \n     /// Construct a builder at the `Help` level with the `msg`.\n-    pub fn struct_help(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_help(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Help, msg)\n     }\n \n     /// Construct a builder at the `Note` level with the `msg`.\n-    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_note_without_error(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Note, msg)\n     }\n \n-    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: &str) -> ! {\n+    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n         FatalError.raise()\n     }\n \n     pub fn span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> ! {\n         self.emit_diag_at_span(Diagnostic::new_with_code(Fatal, Some(code), msg), span);\n         FatalError.raise()\n     }\n \n-    pub fn span_err(&self, span: impl Into<MultiSpan>, msg: &str) -> ErrorGuaranteed {\n+    pub fn span_err(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         self.emit_diag_at_span(Diagnostic::new(Error { lint: false }, msg), span).unwrap()\n     }\n \n-    pub fn span_err_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+    pub fn span_err_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) {\n         self.emit_diag_at_span(\n             Diagnostic::new_with_code(Error { lint: false }, Some(code), msg),\n             span,\n         );\n     }\n \n-    pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: &str) {\n+    pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diag_at_span(Diagnostic::new(Warning, msg), span);\n     }\n \n-    pub fn span_warn_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+    pub fn span_warn_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) {\n         self.emit_diag_at_span(Diagnostic::new_with_code(Warning, Some(code), msg), span);\n     }\n \n-    pub fn span_bug(&self, span: impl Into<MultiSpan>, msg: &str) -> ! {\n+    pub fn span_bug(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.inner.borrow_mut().span_bug(span, msg)\n     }\n \n     #[track_caller]\n-    pub fn delay_span_bug(&self, span: impl Into<MultiSpan>, msg: &str) -> ErrorGuaranteed {\n+    pub fn delay_span_bug(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         self.inner.borrow_mut().delay_span_bug(span, msg)\n     }\n \n     // FIXME(eddyb) note the comment inside `impl Drop for HandlerInner`, that's\n     // where the explanation of what \"good path\" is (also, it should be renamed).\n-    pub fn delay_good_path_bug(&self, msg: &str) {\n+    pub fn delay_good_path_bug(&self, msg: impl Into<DiagnosticMessage>) {\n         self.inner.borrow_mut().delay_good_path_bug(msg)\n     }\n \n-    pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: &str) {\n+    pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diag_at_span(Diagnostic::new(Bug, msg), span);\n     }\n \n-    pub fn span_note_without_error(&self, span: impl Into<MultiSpan>, msg: &str) {\n+    pub fn span_note_without_error(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) {\n         self.emit_diag_at_span(Diagnostic::new(Note, msg), span);\n     }\n \n-    pub fn span_note_diag(&self, span: Span, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn span_note_diag(\n+        &self,\n+        span: Span,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n         db.set_span(span);\n         db\n     }\n \n     // NOTE: intentionally doesn't raise an error so rustc_codegen_ssa only reports fatal errors in the main thread\n-    pub fn fatal(&self, msg: &str) -> FatalError {\n+    pub fn fatal(&self, msg: impl Into<DiagnosticMessage>) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n \n-    pub fn err(&self, msg: &str) -> ErrorGuaranteed {\n+    pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.inner.borrow_mut().err(msg)\n     }\n \n-    pub fn warn(&self, msg: &str) {\n+    pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n \n-    pub fn note_without_error(&self, msg: &str) {\n+    pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         DiagnosticBuilder::new(self, Note, msg).emit();\n     }\n \n-    pub fn bug(&self, msg: &str) -> ! {\n+    pub fn bug(&self, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.inner.borrow_mut().bug(msg)\n     }\n \n@@ -1143,7 +1206,10 @@ impl HandlerInner {\n \n         match (errors.len(), warnings.len()) {\n             (0, 0) => return,\n-            (0, _) => self.emitter.emit_diagnostic(&Diagnostic::new(Level::Warning, &warnings)),\n+            (0, _) => self.emitter.emit_diagnostic(&Diagnostic::new(\n+                Level::Warning,\n+                DiagnosticMessage::Str(warnings.to_owned()),\n+            )),\n             (_, 0) => {\n                 let _ = self.fatal(&errors);\n             }\n@@ -1218,7 +1284,7 @@ impl HandlerInner {\n         }\n     }\n \n-    fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> ! {\n+    fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Bug, msg), sp);\n         panic::panic_any(ExplicitBug);\n     }\n@@ -1228,7 +1294,11 @@ impl HandlerInner {\n     }\n \n     #[track_caller]\n-    fn delay_span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> ErrorGuaranteed {\n+    fn delay_span_bug(\n+        &mut self,\n+        sp: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n@@ -1244,7 +1314,7 @@ impl HandlerInner {\n \n     // FIXME(eddyb) note the comment inside `impl Drop for HandlerInner`, that's\n     // where the explanation of what \"good path\" is (also, it should be renamed).\n-    fn delay_good_path_bug(&mut self, msg: &str) {\n+    fn delay_good_path_bug(&mut self, msg: impl Into<DiagnosticMessage>) {\n         let mut diagnostic = Diagnostic::new(Level::DelayedBug, msg);\n         if self.flags.report_delayed_bugs {\n             self.emit_diagnostic(&mut diagnostic);\n@@ -1253,33 +1323,37 @@ impl HandlerInner {\n         self.delayed_good_path_bugs.push(DelayedDiagnostic::with_backtrace(diagnostic, backtrace));\n     }\n \n-    fn failure(&mut self, msg: &str) {\n+    fn failure(&mut self, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diagnostic(&mut Diagnostic::new(FailureNote, msg));\n     }\n \n-    fn fatal(&mut self, msg: &str) -> FatalError {\n+    fn fatal(&mut self, msg: impl Into<DiagnosticMessage>) -> FatalError {\n         self.emit(Fatal, msg);\n         FatalError\n     }\n \n-    fn err(&mut self, msg: &str) -> ErrorGuaranteed {\n+    fn err(&mut self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.emit(Error { lint: false }, msg)\n     }\n \n     /// Emit an error; level should be `Error` or `Fatal`.\n-    fn emit(&mut self, level: Level, msg: &str) -> ErrorGuaranteed {\n+    fn emit(&mut self, level: Level, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         if self.treat_err_as_bug() {\n             self.bug(msg);\n         }\n         self.emit_diagnostic(&mut Diagnostic::new(level, msg)).unwrap()\n     }\n \n-    fn bug(&mut self, msg: &str) -> ! {\n+    fn bug(&mut self, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diagnostic(&mut Diagnostic::new(Bug, msg));\n         panic::panic_any(ExplicitBug);\n     }\n \n-    fn flush_delayed(&mut self, bugs: impl IntoIterator<Item = Diagnostic>, explanation: &str) {\n+    fn flush_delayed(\n+        &mut self,\n+        bugs: impl IntoIterator<Item = Diagnostic>,\n+        explanation: impl Into<DiagnosticMessage> + Copy,\n+    ) {\n         let mut no_bugs = true;\n         for mut bug in bugs {\n             if no_bugs {"}, {"sha": "556b2c6fbf3685b283e87592617e081112e59d90", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -10,7 +10,7 @@ use rustc_ast::{self as ast, AstLike, Attribute, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n-use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n@@ -20,7 +20,7 @@ use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n use std::default::Default;"}, {"sha": "0e20e0970f401ba975ac27dea7f9a6858f155a71", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -109,10 +109,11 @@ use crate::mbe::{KleeneToken, TokenTree};\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::MultiSpan;\n use rustc_session::lint::builtin::META_VARIABLE_MISUSE;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::kw;\n-use rustc_span::{symbol::MacroRulesNormalizedIdent, MultiSpan, Span};\n+use rustc_span::{symbol::MacroRulesNormalizedIdent, Span};\n \n use smallvec::SmallVec;\n \n@@ -249,7 +250,7 @@ fn check_binders(\n             if let Some(prev_info) = binders.get(&name) {\n                 // 1. The meta-variable is already bound in the current LHS: This is an error.\n                 let mut span = MultiSpan::from_span(span);\n-                span.push_span_label(prev_info.span, \"previous declaration\".into());\n+                span.push_span_label(prev_info.span, \"previous declaration\");\n                 buffer_lint(sess, span, node_id, \"duplicate matcher binding\");\n             } else if get_binder_info(macros, binders, name).is_none() {\n                 // 2. The meta-variable is free: This is a binder.\n@@ -621,16 +622,16 @@ fn ops_is_prefix(\n     for (i, binder) in binder_ops.iter().enumerate() {\n         if i >= occurrence_ops.len() {\n             let mut span = MultiSpan::from_span(span);\n-            span.push_span_label(binder.span, \"expected repetition\".into());\n+            span.push_span_label(binder.span, \"expected repetition\");\n             let message = &format!(\"variable '{}' is still repeating at this depth\", name);\n             buffer_lint(sess, span, node_id, message);\n             return;\n         }\n         let occurrence = &occurrence_ops[i];\n         if occurrence.op != binder.op {\n             let mut span = MultiSpan::from_span(span);\n-            span.push_span_label(binder.span, \"expected repetition\".into());\n-            span.push_span_label(occurrence.span, \"conflicting repetition\".into());\n+            span.push_span_label(binder.span, \"expected repetition\");\n+            span.push_span_label(occurrence.span, \"conflicting repetition\");\n             let message = \"meta-variable repeats with different Kleene operator\";\n             buffer_lint(sess, span, node_id, message);\n             return;"}, {"sha": "7fef87ed9778ff0bb0417db39f4c46c68f7783a2", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -68,17 +68,18 @@ fn emit_frag_parse_err(\n     arm_span: Span,\n     kind: AstFragmentKind,\n ) {\n-    if parser.token == token::Eof && e.message().ends_with(\", found `<eof>`\") {\n+    // FIXME(davidtwco): avoid depending on the error message text\n+    if parser.token == token::Eof && e.message[0].0.expect_str().ends_with(\", found `<eof>`\") {\n         if !e.span.is_dummy() {\n             // early end of macro arm (#52866)\n             e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n         }\n         let msg = &e.message[0];\n         e.message[0] = (\n-            format!(\n+            rustc_errors::DiagnosticMessage::Str(format!(\n                 \"macro expansion ends with an incomplete expression: {}\",\n-                msg.0.replace(\", found `<eof>`\", \"\"),\n-            ),\n+                msg.0.expect_str().replace(\", found `<eof>`\", \"\"),\n+            )),\n             msg.1,\n         );\n     }"}, {"sha": "52a656e1d1c14e11546cca2720bd08730873b39d", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -128,13 +128,15 @@ fn parse_ident<'sess>(\n     sess: &'sess ParseSess,\n     span: Span,\n ) -> PResult<'sess, Ident> {\n-    let err_fn = |msg| sess.span_diagnostic.struct_span_err(span, msg);\n     if let Some(tt) = iter.next() && let TokenTree::Token(token) = tt {\n         if let Some((elem, false)) = token.ident() {\n             return Ok(elem);\n         }\n         let token_str = pprust::token_to_string(&token);\n-        let mut err = err_fn(&format!(\"expected identifier, found `{}`\", &token_str));\n+        let mut err = sess.span_diagnostic.struct_span_err(\n+            span,\n+            &format!(\"expected identifier, found `{}`\", &token_str)\n+        );\n         err.span_suggestion(\n             token.span,\n             &format!(\"try removing `{}`\", &token_str),\n@@ -143,7 +145,7 @@ fn parse_ident<'sess>(\n         );\n         return Err(err);\n     }\n-    Err(err_fn(\"expected identifier\"))\n+    Err(sess.span_diagnostic.struct_span_err(span, \"expected identifier\"))\n }\n \n /// Tries to move the iterator forward returning `true` if there is a comma. If not, then the"}, {"sha": "bd6f0b77ebf6b8f864a639146549e578ee7cb264", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -7,13 +7,13 @@ use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing}\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Diagnostic, PResult};\n+use rustc_errors::{Diagnostic, MultiSpan, PResult};\n use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::{nt_to_tokenstream, parse_stream_from_source_str};\n use rustc_session::parse::ParseSess;\n use rustc_span::def_id::CrateNum;\n use rustc_span::symbol::{self, kw, sym, Symbol};\n-use rustc_span::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n+use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n \n use pm::bridge::{server, TokenTree};\n use pm::{Delimiter, Level, LineColumn, Spacing};"}, {"sha": "88f3cf9d722a241a2c502257fbe7222e0f601536", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -4,11 +4,11 @@ use rustc_parse::{new_parser_from_source_str, parser::Parser, source_file_to_str\n use rustc_session::parse::ParseSess;\n use rustc_span::create_default_session_if_not_set_then;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n-use rustc_span::{BytePos, MultiSpan, Span};\n+use rustc_span::{BytePos, Span};\n \n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::EmitterWriter;\n-use rustc_errors::{Handler, PResult};\n+use rustc_errors::{Handler, MultiSpan, PResult};\n \n use std::io;\n use std::io::prelude::*;\n@@ -127,6 +127,8 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n     create_default_session_if_not_set_then(|_| {\n         let output = Arc::new(Mutex::new(Vec::new()));\n \n+        let fallback_bundle = rustc_errors::fallback_fluent_bundle(false)\n+            .expect(\"failed to load fallback fluent bundle\");\n         let source_map = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         source_map.new_source_file(Path::new(\"test.rs\").to_owned().into(), file_text.to_owned());\n \n@@ -142,6 +144,8 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n         let emitter = EmitterWriter::new(\n             Box::new(Shared { data: output.clone() }),\n             Some(source_map.clone()),\n+            None,\n+            fallback_bundle,\n             false,\n             false,\n             false,"}, {"sha": "34d366f40133287dda2d2c5637a82d4bef3ebdd2", "filename": "compiler/rustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2FCargo.toml?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -11,6 +11,7 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_feature = { path = \"../rustc_feature\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_error_messages = { path = \"../rustc_error_messages\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_serialize = { path = \"../rustc_serialize\" }"}, {"sha": "15118073b3343020fd508aeba320040e3a069760", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -13,12 +13,13 @@ use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_error_messages::MultiSpan;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{def_id::LocalDefId, BytePos, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{def_id::LocalDefId, BytePos, Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use rustc_target::spec::abi::Abi;\n "}, {"sha": "f25215fe813d6d10b0856d2c697c771934d74aee", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -59,7 +59,7 @@ use crate::traits::{\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n+use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -72,7 +72,7 @@ use rustc_middle::ty::{\n     subst::{GenericArgKind, Subst, SubstsRef},\n     Binder, List, Region, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{sym, BytePos, DesugaringKind, MultiSpan, Pos, Span};\n+use rustc_span::{sym, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::ControlFlow;\n use std::{cmp, fmt, iter};\n@@ -2075,7 +2075,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         {\n                             diag.span_suggestion(\n                                 span,\n-                                msg,\n+                                *msg,\n                                 format!(\"{}.as_ref()\", snippet),\n                                 Applicability::MachineApplicable,\n                             );"}, {"sha": "80500f3fe65bac6e4b606e8649cac403d0fdb80f", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -7,11 +7,10 @@ use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::ObligationCauseCode;\n use rustc_data_structures::stable_set::FxHashSet;\n-use rustc_errors::{Applicability, ErrorGuaranteed};\n+use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::ty::TypeVisitor;\n-use rustc_span::MultiSpan;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     pub(super) fn try_report_mismatched_static_lifetime(&self) -> Option<ErrorGuaranteed> {\n@@ -42,8 +41,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let mut err = self.tcx().sess.struct_span_err(cause.span, \"incompatible lifetime on type\");\n         // FIXME: we should point at the lifetime\n         let mut multi_span: MultiSpan = vec![binding_span].into();\n-        multi_span\n-            .push_span_label(binding_span, \"introduces a `'static` lifetime requirement\".into());\n+        multi_span.push_span_label(binding_span, \"introduces a `'static` lifetime requirement\");\n         err.span_note(multi_span, \"because this has an unmet lifetime requirement\");\n         note_and_explain_region(self.tcx(), &mut err, \"\", sup, \"...\", Some(binding_span));\n         if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {"}, {"sha": "a4c46d5cf0ba26632aa4dca79de1d0633b8b1986", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -5,15 +5,15 @@ use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_data_structures::stable_set::FxHashSet;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n use rustc_middle::ty::{\n     self, AssocItemContainer, StaticLifetimeVisitor, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n };\n use rustc_span::symbol::Ident;\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n \n use std::ops::ControlFlow;\n "}, {"sha": "1788eb8628a0af8089f188f1cc41603b674c5a00", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -4,16 +4,15 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, Subtype};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::print::RegionHighlightMode;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n-\n-use rustc_span::{MultiSpan, Span, Symbol};\n+use rustc_span::{Span, Symbol};\n \n use std::ops::ControlFlow;\n "}, {"sha": "baea3e8285af26c078a90fd908cb78215191f0bc", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::ty::{self, Region};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n-        let mut label_or_note = |span, msg| {\n+        let mut label_or_note = |span, msg: &str| {\n             let sub_count = err.children.iter().filter(|d| d.span.is_dummy()).count();\n             let expanded_sub_count = err.children.iter().filter(|d| !d.span.is_dummy()).count();\n             let span_is_primary = err.span.primary_spans().iter().all(|&sp| sp == span);"}, {"sha": "d297640c1402730895d897742b6f9627b127c6b6", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -2,11 +2,11 @@ use super::ObjectSafetyViolation;\n \n use crate::infer::InferCtxt;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n use std::fmt;\n use std::iter;\n "}, {"sha": "eac6a33cf22981fbd9cf92e9436786ad409c7657", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n-use rustc_errors::{Applicability, ErrorGuaranteed, PResult};\n+use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_hir::Crate;\n@@ -35,7 +35,7 @@ use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{FileName, MultiSpan};\n+use rustc_span::FileName;\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n use tempfile::Builder as TempFileBuilder;"}, {"sha": "e6f9246d73242f4b1c2ebe200a15075b2f30db0d", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -31,7 +31,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticStyledString};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticStyledString, MultiSpan};\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -49,7 +49,7 @@ use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, InnerSpan, MultiSpan, Span};\n+use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::traits::{self, misc::can_type_implement_copy};\n \n@@ -1571,7 +1571,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n                         lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n                     let msg = \"the bound will not be checked when the type alias is used, \\\n                                    and should be removed\";\n-                    err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n+                    err.multipart_suggestion(msg, suggestion, Applicability::MachineApplicable);\n                     if !suggested_changing_assoc_types {\n                         TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n                         suggested_changing_assoc_types = true;"}, {"sha": "3600b6ad212036da44e05b0625f6e7859695b8b4", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -21,7 +21,7 @@ use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc_ast::util::unicode::TEXT_FLOW_CONTROL_CHARS;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n-use rustc_errors::{struct_span_err, Applicability, SuggestionStyle};\n+use rustc_errors::{struct_span_err, Applicability, MultiSpan, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId};\n@@ -38,7 +38,7 @@ use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintI\n use rustc_session::Session;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n use rustc_target::abi;\n use tracing::debug;\n "}, {"sha": "67f5aa0540fbe19c42eb9a331189d3c3e47ec09b", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -37,7 +37,7 @@ fn emit_unfulfilled_expectation_lint(\n         |diag| {\n             let mut diag = diag.build(\"this lint expectation is unfulfilled\");\n             if let Some(rationale) = expectation.reason {\n-                diag.note(&rationale.as_str());\n+                diag.note(rationale.as_str());\n             }\n \n             if expectation.is_unfulfilled_lint_expectations {"}, {"sha": "01f1d1e79ac6c17d113cb14678a2996ee09dda32", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -3,7 +3,7 @@ use crate::late::unerased_lint_store;\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n use rustc_middle::hir::nested_filter;\n@@ -20,7 +20,7 @@ use rustc_session::lint::{\n use rustc_session::parse::{add_feature_diagnostics, feature_err};\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{source_map::MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{Span, DUMMY_SP};\n use tracing::debug;\n \n fn lint_levels(tcx: TyCtxt<'_>, (): ()) -> LintLevelMap {"}, {"sha": "14ac30987b35cb35656d1299be91565cabfe3b4a", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -154,7 +154,7 @@ fn lint_overflowing_range_endpoint<'tcx>(\n                     let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n                     err.span_suggestion(\n                         parent_expr.span,\n-                        &\"use an inclusive range instead\",\n+                        \"use an inclusive range instead\",\n                         suggestion,\n                         Applicability::MachineApplicable,\n                     );\n@@ -399,7 +399,7 @@ fn lint_uint_literal<'tcx>(\n                             lint.build(\"only `u8` can be cast into `char`\")\n                                 .span_suggestion(\n                                     par_e.span,\n-                                    &\"use a `char` literal instead\",\n+                                    \"use a `char` literal instead\",\n                                     format!(\"'\\\\u{{{:X}}}'\", lit_val),\n                                     Applicability::MachineApplicable,\n                                 )"}, {"sha": "494bdaa1e2b9cf3640912d89c80744ecb50a3004", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -3,15 +3,15 @@ use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext}\n use rustc_ast as ast;\n use rustc_ast::util::{classify, parser};\n use rustc_ast::{ExprKind, StmtKind};\n-use rustc_errors::{pluralize, Applicability};\n+use rustc_errors::{pluralize, Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n-use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n \n declare_lint! {\n     /// The `unused_must_use` lint detects unused result of a type flagged as"}, {"sha": "fcd8c37d6774ab78722f348f2f148781f18dae23", "filename": "compiler/rustc_lint_defs/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint_defs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint_defs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2FCargo.toml?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -6,6 +6,7 @@ edition = \"2021\"\n [dependencies]\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_error_messages = { path = \"../rustc_error_messages\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "031b01af5dd95e44056b25920d7d3e3b5960d67f", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -7,10 +7,11 @@ pub use self::Level::*;\n use rustc_ast::node_id::{NodeId, NodeMap};\n use rustc_ast::{AttrId, Attribute};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n+use rustc_error_messages::MultiSpan;\n use rustc_hir::HirId;\n use rustc_serialize::json::Json;\n use rustc_span::edition::Edition;\n-use rustc_span::{sym, symbol::Ident, MultiSpan, Span, Symbol};\n+use rustc_span::{sym, symbol::Ident, Span, Symbol};\n use rustc_target::spec::abi::Abi;\n \n pub mod builtin;"}, {"sha": "3589860eb0eaca281df1407e34aa0269bb2e203d", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -63,9 +63,14 @@ decl_derive!([TypeFoldable, attributes(type_foldable)] => type_foldable::type_fo\n decl_derive!([Lift, attributes(lift)] => lift::lift_derive);\n decl_derive!(\n     [SessionDiagnostic, attributes(\n-        message,\n-        lint,\n+        // struct attributes\n+        warning,\n         error,\n+        note,\n+        help,\n+        // field attributes\n+        skip_arg,\n+        primary_span,\n         label,\n         suggestion,\n         suggestion_short,"}, {"sha": "46f698f6f9b819ef793934c319031b6e2bab8372", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 581, "deletions": 290, "changes": 871, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -5,8 +5,9 @@ use syn::spanned::Spanned;\n \n use std::collections::{BTreeSet, HashMap};\n \n-/// Implements #[derive(SessionDiagnostic)], which allows for errors to be specified as a struct, independent\n-/// from the actual diagnostics emitting code.\n+/// Implements `#[derive(SessionDiagnostic)]`, which allows for errors to be specified as a struct,\n+/// independent from the actual diagnostics emitting code.\n+///\n /// ```ignore (pseudo-rust)\n /// # extern crate rustc_errors;\n /// # use rustc_errors::Applicability;\n@@ -15,11 +16,11 @@ use std::collections::{BTreeSet, HashMap};\n /// # extern crate rust_middle;\n /// # use rustc_middle::ty::Ty;\n /// #[derive(SessionDiagnostic)]\n-/// #[code = \"E0505\"]\n-/// #[error = \"cannot move out of {name} because it is borrowed\"]\n+/// #[error(code = \"E0505\", slug = \"move-out-of-borrow-error\")]\n /// pub struct MoveOutOfBorrowError<'tcx> {\n ///     pub name: Ident,\n ///     pub ty: Ty<'tcx>,\n+///     #[primary_span]\n ///     #[label = \"cannot move out of borrow\"]\n ///     pub span: Span,\n ///     #[label = \"`{ty}` first borrowed here\"]\n@@ -28,6 +29,7 @@ use std::collections::{BTreeSet, HashMap};\n ///     pub opt_sugg: Option<(Span, Applicability)>\n /// }\n /// ```\n+///\n /// Then, later, to emit the error:\n ///\n /// ```ignore (pseudo-rust)\n@@ -47,10 +49,10 @@ pub fn session_diagnostic_derive(s: synstructure::Structure<'_>) -> proc_macro2:\n     SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n }\n \n-// Checks whether the type name of `ty` matches `name`.\n-//\n-// Given some struct at a::b::c::Foo, this will return true for c::Foo, b::c::Foo, or\n-// a::b::c::Foo. This reasonably allows qualified names to be used in the macro.\n+/// Checks whether the type name of `ty` matches `name`.\n+///\n+/// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n+/// `a::b::c::Foo`. This reasonably allows qualified names to be used in the macro.\n fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n     if let syn::Type::Path(ty) = ty {\n         ty.path\n@@ -65,7 +67,7 @@ fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n     }\n }\n \n-/// The central struct for constructing the as_error method from an annotated struct.\n+/// The central struct for constructing the `as_error` method from an annotated struct.\n struct SessionDiagnosticDerive<'a> {\n     structure: synstructure::Structure<'a>,\n     builder: SessionDiagnosticDeriveBuilder<'a>,\n@@ -77,13 +79,6 @@ impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n     }\n }\n \n-/// Equivalent to rustc:errors::diagnostic::DiagnosticId, except stores the quoted expression to\n-/// initialise the code with.\n-enum DiagnosticId {\n-    Error(proc_macro2::TokenStream),\n-    Lint(proc_macro2::TokenStream),\n-}\n-\n #[derive(Debug)]\n enum SessionDiagnosticDeriveError {\n     SynError(syn::Error),\n@@ -98,7 +93,7 @@ impl SessionDiagnosticDeriveError {\n                 // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n                 // error has already been emitted to the compiler.\n                 quote! {\n-                    unreachable!()\n+                    { unreachable!(); }\n                 }\n             }\n         }\n@@ -109,18 +104,19 @@ fn span_err(span: impl proc_macro::MultiSpan, msg: &str) -> proc_macro::Diagnost\n     Diagnostic::spanned(span, proc_macro::Level::Error, msg)\n }\n \n-/// For methods that return a Result<_, SessionDiagnosticDeriveError>: emit a diagnostic on\n-/// span $span with msg $msg (and, optionally, perform additional decoration using the FnOnce\n-/// passed in `diag`). Then, return Err(ErrorHandled).\n+/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+///\n+/// Emit a diagnostic on span `$span` with msg `$msg` (optionally performing additional decoration\n+/// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n macro_rules! throw_span_err {\n     ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n     ($span:expr, $msg:expr, $f:expr) => {{\n         return Err(_throw_span_err($span, $msg, $f));\n     }};\n }\n \n-/// When possible, prefer using throw_span_err! over using this function directly. This only exists\n-/// as a function to constrain `f` to an impl FnOnce.\n+/// When possible, prefer using `throw_span_err!` over using this function directly. This only\n+/// exists as a function to constrain `f` to an `impl FnOnce`.\n fn _throw_span_err(\n     span: impl proc_macro::MultiSpan,\n     msg: &str,\n@@ -149,34 +145,49 @@ impl<'a> SessionDiagnosticDerive<'a> {\n         }\n \n         Self {\n-            builder: SessionDiagnosticDeriveBuilder { diag, sess, fields: fields_map, kind: None },\n+            builder: SessionDiagnosticDeriveBuilder {\n+                diag,\n+                sess,\n+                fields: fields_map,\n+                kind: None,\n+                code: None,\n+                slug: None,\n+            },\n             structure,\n         }\n     }\n+\n     fn into_tokens(self) -> proc_macro2::TokenStream {\n-        let SessionDiagnosticDerive { structure, mut builder } = self;\n+        let SessionDiagnosticDerive { mut structure, mut builder } = self;\n \n         let ast = structure.ast();\n         let attrs = &ast.attrs;\n \n-        let implementation = {\n+        let (implementation, param_ty) = {\n             if let syn::Data::Struct(..) = ast.data {\n                 let preamble = {\n                     let preamble = attrs.iter().map(|attr| {\n                         builder\n                             .generate_structure_code(attr)\n                             .unwrap_or_else(|v| v.to_compile_error())\n                     });\n+\n                     quote! {\n                         #(#preamble)*;\n                     }\n                 };\n \n-                let body = structure.each(|field_binding| {\n+                // Generates calls to `span_label` and similar functions based on the attributes\n+                // on fields. Code for suggestions uses formatting machinery and the value of\n+                // other fields - because any given field can be referenced multiple times, it\n+                // should be accessed through a borrow. When passing fields to `set_arg` (which\n+                // happens below) for Fluent, we want to move the data, so that has to happen\n+                // in a separate pass over the fields.\n+                let attrs = structure.each(|field_binding| {\n                     let field = field_binding.ast();\n                     let result = field.attrs.iter().map(|attr| {\n                         builder\n-                            .generate_field_code(\n+                            .generate_field_attr_code(\n                                 attr,\n                                 FieldInfo {\n                                     vis: &field.vis,\n@@ -187,170 +198,375 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                             )\n                             .unwrap_or_else(|v| v.to_compile_error())\n                     });\n-                    return quote! {\n-                        #(#result);*\n-                    };\n+\n+                    quote! { #(#result);* }\n+                });\n+\n+                // When generating `set_arg` calls, move data rather than borrow it to avoid\n+                // requiring clones - this must therefore be the last use of each field (for\n+                // example, any formatting machinery that might refer to a field should be\n+                // generated already).\n+                structure.bind_with(|_| synstructure::BindStyle::Move);\n+                let args = structure.each(|field_binding| {\n+                    let field = field_binding.ast();\n+                    // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n+                    // need to be passed as an argument to the diagnostic. But when a field has no\n+                    // attributes then it must be passed as an argument to the diagnostic so that\n+                    // it can be referred to by Fluent messages.\n+                    if field.attrs.is_empty() {\n+                        let diag = &builder.diag;\n+                        let ident = field_binding.ast().ident.as_ref().unwrap();\n+                        quote! {\n+                            #diag.set_arg(\n+                                stringify!(#ident),\n+                                #field_binding.into_diagnostic_arg()\n+                            );\n+                        }\n+                    } else {\n+                        quote! {}\n+                    }\n                 });\n-                // Finally, putting it altogether.\n-                match builder.kind {\n-                    None => {\n-                        span_err(ast.span().unwrap(), \"`code` not specified\")\n-                        .help(\"use the [code = \\\"...\\\"] attribute to set this diagnostic's error code \")\n-                        .emit();\n-                        SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+\n+                let span = ast.span().unwrap();\n+                let (diag, sess) = (&builder.diag, &builder.sess);\n+                let init = match (builder.kind, builder.slug) {\n+                    (None, _) => {\n+                        span_err(span, \"diagnostic kind not specified\")\n+                            .help(\"use the `#[error(...)]` attribute to create an error\")\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n-                    Some((kind, _)) => match kind {\n-                        DiagnosticId::Lint(_lint) => todo!(),\n-                        DiagnosticId::Error(code) => {\n-                            let (diag, sess) = (&builder.diag, &builder.sess);\n-                            quote! {\n-                                let mut #diag = #sess.struct_err_with_code(\"\", rustc_errors::DiagnosticId::Error(#code));\n-                                #preamble\n-                                match self {\n-                                    #body\n-                                }\n-                                #diag\n-                            }\n+                    (Some((kind, _)), None) => {\n+                        span_err(span, \"`slug` not specified\")\n+                            .help(&format!(\"use the `#[{}(slug = \\\"...\\\")]` attribute to set this diagnostic's slug\", kind.descr()))\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some((SessionDiagnosticKind::Error, _)), Some((slug, _))) => {\n+                        quote! {\n+                            let mut #diag = #sess.struct_err(\n+                                rustc_errors::DiagnosticMessage::fluent(#slug),\n+                            );\n                         }\n-                    },\n-                }\n+                    }\n+                    (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _))) => {\n+                        quote! {\n+                            let mut #diag = #sess.struct_warn(\n+                                rustc_errors::DiagnosticMessage::fluent(#slug),\n+                            );\n+                        }\n+                    }\n+                };\n+\n+                let implementation = quote! {\n+                    #init\n+                    #preamble\n+                    match self {\n+                        #attrs\n+                    }\n+                    match self {\n+                        #args\n+                    }\n+                    #diag\n+                };\n+                let param_ty = match builder.kind {\n+                    Some((SessionDiagnosticKind::Error, _)) => {\n+                        quote! { rustc_errors::ErrorGuaranteed }\n+                    }\n+                    Some((SessionDiagnosticKind::Warn, _)) => quote! { () },\n+                    _ => unreachable!(),\n+                };\n+\n+                (implementation, param_ty)\n             } else {\n                 span_err(\n                     ast.span().unwrap(),\n                     \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n                 )\n                 .emit();\n-                SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+\n+                let implementation = SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                let param_ty = quote! { rustc_errors::ErrorGuaranteed };\n+                (implementation, param_ty)\n             }\n         };\n \n         let sess = &builder.sess;\n         structure.gen_impl(quote! {\n-            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess>\n+            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess, #param_ty>\n                     for @Self\n             {\n                 fn into_diagnostic(\n                     self,\n                     #sess: &'__session_diagnostic_sess rustc_session::Session\n-                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, rustc_errors::ErrorGuaranteed> {\n+                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, #param_ty> {\n+                    use rustc_errors::IntoDiagnosticArg;\n                     #implementation\n                 }\n             }\n         })\n     }\n }\n \n-/// Field information passed to the builder. Deliberately omits attrs to discourage the generate_*\n-/// methods from walking the attributes themselves.\n+/// Field information passed to the builder. Deliberately omits attrs to discourage the\n+/// `generate_*` methods from walking the attributes themselves.\n struct FieldInfo<'a> {\n     vis: &'a syn::Visibility,\n     binding: &'a synstructure::BindingInfo<'a>,\n     ty: &'a syn::Type,\n     span: &'a proc_macro2::Span,\n }\n \n+/// What kind of session diagnostic is being derived - an error or a warning?\n+#[derive(Copy, Clone)]\n+enum SessionDiagnosticKind {\n+    /// `#[error(..)]`\n+    Error,\n+    /// `#[warn(..)]`\n+    Warn,\n+}\n+\n+impl SessionDiagnosticKind {\n+    /// Returns human-readable string corresponding to the kind.\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            SessionDiagnosticKind::Error => \"error\",\n+            SessionDiagnosticKind::Warn => \"warning\",\n+        }\n+    }\n+}\n+\n /// Tracks persistent information required for building up the individual calls to diagnostic\n-/// methods for the final generated method. This is a separate struct to SessionDerive only to be\n-/// able to destructure and split self.builder and the self.structure up to avoid a double mut\n-/// borrow later on.\n+/// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n+/// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n+/// double mut borrow later on.\n struct SessionDiagnosticDeriveBuilder<'a> {\n-    /// Name of the session parameter that's passed in to the as_error method.\n+    /// Name of the session parameter that's passed in to the `as_error` method.\n     sess: syn::Ident,\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n+    diag: syn::Ident,\n \n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n     fields: HashMap<String, &'a syn::Field>,\n \n-    /// The identifier to use for the generated DiagnosticBuilder instance.\n-    diag: syn::Ident,\n-\n-    /// Whether this is a lint or an error. This dictates how the diag will be initialised. Span\n-    /// stores at what Span the kind was first set at (for error reporting purposes, if the kind\n-    /// was multiply specified).\n-    kind: Option<(DiagnosticId, proc_macro2::Span)>,\n+    /// Kind of diagnostic requested via the struct attribute.\n+    kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n+    /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n+    /// has the actual diagnostic message.\n+    slug: Option<(String, proc_macro::Span)>,\n+    /// Error codes are a optional part of the struct attribute - this is only set to detect\n+    /// multiple specifications.\n+    code: Option<proc_macro::Span>,\n }\n \n impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n+    /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n+    /// attributes like `#[error(..)#`, such as the diagnostic kind and slug. Generates\n+    /// diagnostic builder calls for setting error code and creating note/help messages.\n     fn generate_structure_code(\n         &mut self,\n         attr: &syn::Attribute,\n     ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n-        Ok(match attr.parse_meta()? {\n-            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                let formatted_str = self.build_format(&s.value(), attr.span());\n-                let name = attr.path.segments.last().unwrap().ident.to_string();\n-                let name = name.as_str();\n-                match name {\n-                    \"message\" => {\n-                        let diag = &self.diag;\n-                        quote! {\n-                            #diag.set_primary_message(#formatted_str);\n+        let span = attr.span().unwrap();\n+\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        let meta = attr.parse_meta()?;\n+\n+        if matches!(name, \"help\" | \"note\")\n+            && matches!(meta, syn::Meta::Path(_) | syn::Meta::NameValue(_))\n+        {\n+            let diag = &self.diag;\n+            let slug = match &self.slug {\n+                Some((slug, _)) => slug.as_str(),\n+                None => throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`#[{}{}]` must come after `#[error(..)]` or `#[warn(..)]`\",\n+                        name,\n+                        match meta {\n+                            syn::Meta::Path(_) => \"\",\n+                            syn::Meta::NameValue(_) => \" = ...\",\n+                            _ => unreachable!(),\n+                        }\n+                    )\n+                ),\n+            };\n+            let id = match meta {\n+                syn::Meta::Path(..) => quote! { #name },\n+                syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    quote! { #s }\n+                }\n+                _ => unreachable!(),\n+            };\n+            let fn_name = proc_macro2::Ident::new(name, attr.span());\n+\n+            return Ok(quote! {\n+                #diag.#fn_name(rustc_errors::DiagnosticMessage::fluent_attr(#slug, #id));\n+            });\n+        }\n+\n+        let nested = match meta {\n+            syn::Meta::List(syn::MetaList { nested, .. }) => nested,\n+            syn::Meta::Path(..) => throw_span_err!(\n+                span,\n+                &format!(\"`#[{}]` is not a valid `SessionDiagnostic` struct attribute\", name)\n+            ),\n+            syn::Meta::NameValue(..) => throw_span_err!(\n+                span,\n+                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` struct attribute\", name)\n+            ),\n+        };\n+\n+        let kind = match name {\n+            \"error\" => SessionDiagnosticKind::Error,\n+            \"warning\" => SessionDiagnosticKind::Warn,\n+            other => throw_span_err!(\n+                span,\n+                &format!(\"`#[{}(...)]` is not a valid `SessionDiagnostic` struct attribute\", other)\n+            ),\n+        };\n+        self.set_kind_once(kind, span)?;\n+\n+        let mut tokens = Vec::new();\n+        for attr in nested {\n+            let span = attr.span().unwrap();\n+            let meta = match attr {\n+                syn::NestedMeta::Meta(meta) => meta,\n+                syn::NestedMeta::Lit(_) => throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` struct attribute\",\n+                        name\n+                    )\n+                ),\n+            };\n+\n+            let path = meta.path();\n+            let nested_name = path.segments.last().unwrap().ident.to_string();\n+            match &meta {\n+                // Struct attributes are only allowed to be applied once, and the diagnostic\n+                // changes will be set in the initialisation code.\n+                syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    match nested_name.as_str() {\n+                        \"slug\" => {\n+                            self.set_slug_once(s.value(), s.span().unwrap());\n+                        }\n+                        \"code\" => {\n+                            tokens.push(self.set_code_once(s.value(), s.span().unwrap()));\n+                        }\n+                        other => {\n+                            let diag = span_err(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                    name, other\n+                                ),\n+                            );\n+                            diag.emit();\n                         }\n                     }\n-                    attr @ \"error\" | attr @ \"lint\" => {\n-                        self.set_kind_once(\n-                            if attr == \"error\" {\n-                                DiagnosticId::Error(formatted_str)\n-                            } else if attr == \"lint\" {\n-                                DiagnosticId::Lint(formatted_str)\n-                            } else {\n-                                unreachable!()\n-                            },\n-                            s.span(),\n-                        )?;\n-                        // This attribute is only allowed to be applied once, and the attribute\n-                        // will be set in the initialisation code.\n-                        quote! {}\n-                    }\n-                    other => throw_span_err!(\n-                        attr.span().unwrap(),\n+                }\n+                syn::Meta::NameValue(..) => {\n+                    span_err(\n+                        span,\n                         &format!(\n-                            \"`#[{} = ...]` is not a valid SessionDiagnostic struct attribute\",\n-                            other\n-                        )\n-                    ),\n+                            \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .help(\"value must be a string\")\n+                    .emit();\n+                }\n+                syn::Meta::Path(..) => {\n+                    span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .emit();\n+                }\n+                syn::Meta::List(..) => {\n+                    span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .emit();\n                 }\n             }\n-            _ => todo!(\"unhandled meta kind\"),\n-        })\n+        }\n+\n+        Ok(tokens.drain(..).collect())\n     }\n \n     #[must_use]\n     fn set_kind_once(\n         &mut self,\n-        kind: DiagnosticId,\n-        span: proc_macro2::Span,\n+        kind: SessionDiagnosticKind,\n+        span: proc_macro::Span,\n     ) -> Result<(), SessionDiagnosticDeriveError> {\n-        if self.kind.is_none() {\n-            self.kind = Some((kind, span));\n-            Ok(())\n-        } else {\n-            let kind_str = |kind: &DiagnosticId| match kind {\n-                DiagnosticId::Lint(..) => \"lint\",\n-                DiagnosticId::Error(..) => \"error\",\n-            };\n+        match self.kind {\n+            None => {\n+                self.kind = Some((kind, span));\n+                Ok(())\n+            }\n+            Some((prev_kind, prev_span)) => {\n+                let existing = prev_kind.descr();\n+                let current = kind.descr();\n+\n+                let msg = if current == existing {\n+                    format!(\"`{}` specified multiple times\", existing)\n+                } else {\n+                    format!(\"`{}` specified when `{}` was already specified\", current, existing)\n+                };\n+                throw_span_err!(span, &msg, |diag| diag\n+                    .span_note(prev_span, \"previously specified here\"));\n+            }\n+        }\n+    }\n+\n+    fn set_code_once(&mut self, code: String, span: proc_macro::Span) -> proc_macro2::TokenStream {\n+        match self.code {\n+            None => {\n+                self.code = Some(span);\n+            }\n+            Some(prev_span) => {\n+                span_err(span, \"`code` specified multiple times\")\n+                    .span_note(prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n+        }\n \n-            let existing_kind = kind_str(&self.kind.as_ref().unwrap().0);\n-            let this_kind = kind_str(&kind);\n+        let diag = &self.diag;\n+        quote! { #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string())); }\n+    }\n \n-            let msg = if this_kind == existing_kind {\n-                format!(\"`{}` specified multiple times\", existing_kind)\n-            } else {\n-                format!(\"`{}` specified when `{}` was already specified\", this_kind, existing_kind)\n-            };\n-            throw_span_err!(span.unwrap(), &msg);\n+    fn set_slug_once(&mut self, slug: String, span: proc_macro::Span) {\n+        match self.slug {\n+            None => {\n+                self.slug = Some((slug, span));\n+            }\n+            Some((_, prev_span)) => {\n+                span_err(span, \"`slug` specified multiple times\")\n+                    .span_note(prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n         }\n     }\n \n-    fn generate_field_code(\n+    fn generate_field_attr_code(\n         &mut self,\n         attr: &syn::Attribute,\n         info: FieldInfo<'_>,\n     ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n         let field_binding = &info.binding.binding;\n-\n         let option_ty = option_inner_ty(&info.ty);\n-\n         let generated_code = self.generate_non_option_field_code(\n             attr,\n             FieldInfo {\n@@ -360,15 +576,16 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                 span: info.span,\n             },\n         )?;\n-        Ok(if option_ty.is_none() {\n-            quote! { #generated_code }\n+\n+        if option_ty.is_none() {\n+            Ok(quote! { #generated_code })\n         } else {\n-            quote! {\n+            Ok(quote! {\n                 if let Some(#field_binding) = #field_binding {\n                     #generated_code\n                 }\n-            }\n-        })\n+            })\n+        }\n     }\n \n     fn generate_non_option_field_code(\n@@ -377,203 +594,277 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n         info: FieldInfo<'_>,\n     ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n         let diag = &self.diag;\n+        let span = attr.span().unwrap();\n         let field_binding = &info.binding.binding;\n+\n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n-        // At this point, we need to dispatch based on the attribute key + the\n-        // type.\n+\n         let meta = attr.parse_meta()?;\n-        Ok(match meta {\n-            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                let formatted_str = self.build_format(&s.value(), attr.span());\n+        match meta {\n+            syn::Meta::Path(_) => match name {\n+                \"skip_arg\" => {\n+                    // Don't need to do anything - by virtue of the attribute existing, the\n+                    // `set_arg` call will not be generated.\n+                    Ok(quote! {})\n+                }\n+                \"primary_span\" => {\n+                    self.report_error_if_not_applied_to_span(attr, info)?;\n+                    Ok(quote! {\n+                        #diag.set_span(*#field_binding);\n+                    })\n+                }\n+                \"label\" | \"note\" | \"help\" => {\n+                    self.report_error_if_not_applied_to_span(attr, info)?;\n+                    Ok(self.add_subdiagnostic(field_binding, name, name))\n+                }\n+                other => throw_span_err!(\n+                    span,\n+                    &format!(\"`#[{}]` is not a valid `SessionDiagnostic` field attribute\", other)\n+                ),\n+            },\n+            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => match name {\n+                \"label\" | \"note\" | \"help\" => {\n+                    self.report_error_if_not_applied_to_span(attr, info)?;\n+                    Ok(self.add_subdiagnostic(field_binding, name, &s.value()))\n+                }\n+                other => throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\",\n+                        other\n+                    )\n+                ),\n+            },\n+            syn::Meta::NameValue(_) => throw_span_err!(\n+                span,\n+                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\", name),\n+                |diag| diag.help(\"value must be a string\")\n+            ),\n+            syn::Meta::List(syn::MetaList { path, nested, .. }) => {\n+                let name = path.segments.last().unwrap().ident.to_string();\n+                let name = name.as_ref();\n+\n                 match name {\n-                    \"message\" => {\n-                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                            quote! {\n-                                #diag.set_span(*#field_binding);\n-                                #diag.set_primary_message(#formatted_str);\n-                            }\n-                        } else {\n-                            throw_span_err!(\n-                                attr.span().unwrap(),\n-                                \"the `#[message = \\\"...\\\"]` attribute can only be applied to fields of type Span\"\n-                            );\n-                        }\n-                    }\n-                    \"label\" => {\n-                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                            quote! {\n-                                #diag.span_label(*#field_binding, #formatted_str);\n-                            }\n-                        } else {\n-                            throw_span_err!(\n-                                attr.span().unwrap(),\n-                                \"The `#[label = ...]` attribute can only be applied to fields of type Span\"\n-                            );\n-                        }\n-                    }\n+                    \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\"\n+                    | \"suggestion_verbose\" => (),\n                     other => throw_span_err!(\n-                        attr.span().unwrap(),\n+                        span,\n                         &format!(\n-                            \"`#[{} = ...]` is not a valid SessionDiagnostic field attribute\",\n+                            \"`#[{}(...)]` is not a valid `SessionDiagnostic` field attribute\",\n                             other\n                         )\n                     ),\n-                }\n-            }\n-            syn::Meta::List(list) => {\n-                match list.path.segments.iter().last().unwrap().ident.to_string().as_str() {\n-                    suggestion_kind @ \"suggestion\"\n-                    | suggestion_kind @ \"suggestion_short\"\n-                    | suggestion_kind @ \"suggestion_hidden\"\n-                    | suggestion_kind @ \"suggestion_verbose\" => {\n-                        // For suggest, we need to ensure we are running on a (Span,\n-                        // Applicability) pair.\n-                        let (span, applicability) = (|| match &info.ty {\n-                            ty @ syn::Type::Path(..)\n-                                if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) =>\n-                            {\n-                                let binding = &info.binding.binding;\n-                                Ok((\n-                                    quote!(*#binding),\n-                                    quote!(rustc_errors::Applicability::Unspecified),\n-                                ))\n+                };\n+\n+                let (span_, applicability) = self.span_and_applicability_of_ty(info)?;\n+\n+                let mut msg = None;\n+                let mut code = None;\n+\n+                for attr in nested {\n+                    let meta = match attr {\n+                        syn::NestedMeta::Meta(meta) => meta,\n+                        syn::NestedMeta::Lit(_) => throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` field attribute\",\n+                                name\n+                            )\n+                        ),\n+                    };\n+\n+                    let span = meta.span().unwrap();\n+                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                    let nested_name = nested_name.as_str();\n+\n+                    match meta {\n+                        syn::Meta::NameValue(syn::MetaNameValue {\n+                            lit: syn::Lit::Str(s), ..\n+                        }) => match nested_name {\n+                            \"message\" => {\n+                                msg = Some(s.value());\n                             }\n-                            syn::Type::Tuple(tup) => {\n-                                let mut span_idx = None;\n-                                let mut applicability_idx = None;\n-                                for (idx, elem) in tup.elems.iter().enumerate() {\n-                                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n-                                        if span_idx.is_none() {\n-                                            span_idx = Some(syn::Index::from(idx));\n-                                        } else {\n-                                            throw_span_err!(\n-                                                info.span.unwrap(),\n-                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Span\"\n-                                            );\n-                                        }\n-                                    } else if type_matches_path(\n-                                        elem,\n-                                        &[\"rustc_errors\", \"Applicability\"],\n-                                    ) {\n-                                        if applicability_idx.is_none() {\n-                                            applicability_idx = Some(syn::Index::from(idx));\n-                                        } else {\n-                                            throw_span_err!(\n-                                                info.span.unwrap(),\n-                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n-                                            );\n-                                        }\n-                                    }\n-                                }\n-                                if let Some(span_idx) = span_idx {\n-                                    let binding = &info.binding.binding;\n-                                    let span = quote!(#binding.#span_idx);\n-                                    let applicability = applicability_idx\n-                                        .map(\n-                                            |applicability_idx| quote!(#binding.#applicability_idx),\n-                                        )\n-                                        .unwrap_or_else(|| {\n-                                            quote!(rustc_errors::Applicability::Unspecified)\n-                                        });\n-                                    return Ok((span, applicability));\n-                                }\n-                                throw_span_err!(\n-                                    info.span.unwrap(),\n-                                    \"wrong types for suggestion\",\n-                                    |diag| {\n-                                        diag.help(\"#[suggestion(...)] on a tuple field must be applied to fields of type (Span, Applicability)\")\n-                                    }\n-                                );\n+                            \"code\" => {\n+                                let formatted_str = self.build_format(&s.value(), s.span());\n+                                code = Some(formatted_str);\n                             }\n-                            _ => throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"wrong field type for suggestion\",\n-                                |diag| {\n-                                    diag.help(\"#[suggestion(...)] should be applied to fields of type Span or (Span, Applicability)\")\n-                                }\n+                            other => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` field attribute\",\n+                                    name, other\n+                                )\n                             ),\n-                        })()?;\n-                        // Now read the key-value pairs.\n-                        let mut msg = None;\n-                        let mut code = None;\n-\n-                        for arg in list.nested.iter() {\n-                            if let syn::NestedMeta::Meta(syn::Meta::NameValue(arg_name_value)) = arg\n-                            {\n-                                if let syn::MetaNameValue { lit: syn::Lit::Str(s), .. } =\n-                                    arg_name_value\n-                                {\n-                                    let name = arg_name_value\n-                                        .path\n-                                        .segments\n-                                        .last()\n-                                        .unwrap()\n-                                        .ident\n-                                        .to_string();\n-                                    let name = name.as_str();\n-                                    let formatted_str = self.build_format(&s.value(), arg.span());\n-                                    match name {\n-                                        \"message\" => {\n-                                            msg = Some(formatted_str);\n-                                        }\n-                                        \"code\" => {\n-                                            code = Some(formatted_str);\n-                                        }\n-                                        other => throw_span_err!(\n-                                            arg.span().unwrap(),\n-                                            &format!(\n-                                                \"`{}` is not a valid key for `#[suggestion(...)]`\",\n-                                                other\n-                                            )\n-                                        ),\n-                                    }\n-                                }\n-                            }\n+                        },\n+                        syn::Meta::NameValue(..) => throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                name, nested_name\n+                            ),\n+                            |diag| diag.help(\"value must be a string\")\n+                        ),\n+                        syn::Meta::Path(..) => throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                name, nested_name\n+                            )\n+                        ),\n+                        syn::Meta::List(..) => throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                name, nested_name\n+                            )\n+                        ),\n+                    }\n+                }\n+\n+                let method = format_ident!(\"span_{}\", name);\n+\n+                let slug = self\n+                    .slug\n+                    .as_ref()\n+                    .map(|(slug, _)| slug.as_str())\n+                    .unwrap_or_else(|| \"missing-slug\");\n+                let msg = msg.as_deref().unwrap_or(\"suggestion\");\n+                let msg = quote! { rustc_errors::DiagnosticMessage::fluent_attr(#slug, #msg) };\n+                let code = code.unwrap_or_else(|| quote! { String::new() });\n+\n+                Ok(quote! { #diag.#method(#span_, #msg, #code, #applicability); })\n+            }\n+        }\n+    }\n+\n+    /// Reports an error if the field's type is not `Span`.\n+    fn report_error_if_not_applied_to_span(\n+        &self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<(), SessionDiagnosticDeriveError> {\n+        if !type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+            let name = attr.path.segments.last().unwrap().ident.to_string();\n+            let name = name.as_str();\n+            let meta = attr.parse_meta()?;\n+\n+            throw_span_err!(\n+                attr.span().unwrap(),\n+                &format!(\n+                    \"the `#[{}{}]` attribute can only be applied to fields of type `Span`\",\n+                    name,\n+                    match meta {\n+                        syn::Meta::Path(_) => \"\",\n+                        syn::Meta::NameValue(_) => \" = ...\",\n+                        syn::Meta::List(_) => \"(...)\",\n+                    }\n+                )\n+            );\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug and\n+    /// `fluent_attr_identifier`.\n+    fn add_subdiagnostic(\n+        &self,\n+        field_binding: &proc_macro2::Ident,\n+        kind: &str,\n+        fluent_attr_identifier: &str,\n+    ) -> proc_macro2::TokenStream {\n+        let diag = &self.diag;\n+\n+        let slug =\n+            self.slug.as_ref().map(|(slug, _)| slug.as_str()).unwrap_or_else(|| \"missing-slug\");\n+        let fn_name = format_ident!(\"span_{}\", kind);\n+        quote! {\n+            #diag.#fn_name(\n+                *#field_binding,\n+                rustc_errors::DiagnosticMessage::fluent_attr(#slug, #fluent_attr_identifier)\n+            );\n+        }\n+    }\n+\n+    fn span_and_applicability_of_ty(\n+        &self,\n+        info: FieldInfo<'_>,\n+    ) -> Result<(proc_macro2::TokenStream, proc_macro2::TokenStream), SessionDiagnosticDeriveError>\n+    {\n+        match &info.ty {\n+            // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n+            ty @ syn::Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n+                let binding = &info.binding.binding;\n+                Ok((quote!(*#binding), quote!(rustc_errors::Applicability::Unspecified)))\n+            }\n+            // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n+            syn::Type::Tuple(tup) => {\n+                let mut span_idx = None;\n+                let mut applicability_idx = None;\n+\n+                for (idx, elem) in tup.elems.iter().enumerate() {\n+                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n+                        if span_idx.is_none() {\n+                            span_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more than one `Span`\"\n+                            );\n                         }\n-                        let msg = if let Some(msg) = msg {\n-                            quote!(#msg.as_str())\n+                    } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n+                        if applicability_idx.is_none() {\n+                            applicability_idx = Some(syn::Index::from(idx));\n                         } else {\n                             throw_span_err!(\n-                                list.span().unwrap(),\n-                                \"missing suggestion message\",\n-                                |diag| {\n-                                    diag.help(\"provide a suggestion message using #[suggestion(message = \\\"...\\\")]\")\n-                                }\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n                             );\n-                        };\n-                        let code = code.unwrap_or_else(|| quote! { String::new() });\n-                        // Now build it out:\n-                        let suggestion_method = format_ident!(\"span_{}\", suggestion_kind);\n-                        quote! {\n-                            #diag.#suggestion_method(#span, #msg, #code, #applicability);\n                         }\n                     }\n-                    other => throw_span_err!(\n-                        list.span().unwrap(),\n-                        &format!(\"invalid annotation list `#[{}(...)]`\", other)\n-                    ),\n                 }\n+\n+                if let Some(span_idx) = span_idx {\n+                    let binding = &info.binding.binding;\n+                    let span = quote!(#binding.#span_idx);\n+                    let applicability = applicability_idx\n+                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n+                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+\n+                    return Ok((span, applicability));\n+                }\n+\n+                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n+                    diag.help(\"`#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\")\n+                });\n             }\n-            _ => panic!(\"unhandled meta kind\"),\n-        })\n+            // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n+            _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n+                diag.help(\"`#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\")\n+            }),\n+        }\n     }\n \n     /// In the strings in the attributes supplied to this macro, we want callers to be able to\n-    /// reference fields in the format string. Take this, for example:\n+    /// reference fields in the format string. For example:\n+    ///\n     /// ```ignore (not-usage-example)\n     /// struct Point {\n     ///     #[error = \"Expected a point greater than ({x}, {y})\"]\n     ///     x: i32,\n     ///     y: i32,\n     /// }\n     /// ```\n-    /// We want to automatically pick up that {x} refers `self.x` and {y} refers to `self.y`, then\n-    /// generate this call to format!:\n+    ///\n+    /// We want to automatically pick up that `{x}` refers `self.x` and `{y}` refers to `self.y`,\n+    /// then generate this call to `format!`:\n+    ///\n     /// ```ignore (not-usage-example)\n     /// format!(\"Expected a point greater than ({x}, {y})\", x = self.x, y = self.y)\n     /// ```\n-    /// This function builds the entire call to format!.\n+    ///\n+    /// This function builds the entire call to `format!`.\n     fn build_format(&self, input: &str, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n         // This set is used later to generate the final format string. To keep builds reproducible,\n         // the iteration order needs to be deterministic, hence why we use a BTreeSet here instead\n@@ -646,7 +937,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n     }\n }\n \n-/// If `ty` is an Option, returns Some(inner type). Else, returns None.\n+/// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n fn option_inner_ty(ty: &syn::Type) -> Option<&syn::Type> {\n     if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n         if let syn::Type::Path(ty_path) = ty {"}, {"sha": "e55b0454eefc7c4d3309e3ee6b6f0c1fa6d6091f", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -3,7 +3,7 @@ use std::cmp;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{\n-    Diagnostic, DiagnosticBuilder, DiagnosticId, EmissionGuarantee, ErrorGuaranteed,\n+    Diagnostic, DiagnosticBuilder, DiagnosticId, EmissionGuarantee, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n@@ -14,7 +14,7 @@ use rustc_session::lint::{\n };\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n+use rustc_span::source_map::{DesugaringKind, ExpnKind};\n use rustc_span::{symbol, Span, Symbol, DUMMY_SP};\n \n /// How a lint level was set."}, {"sha": "6ca8f8b1309fafdd0b40b2256b7624a1c7ed68f7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -34,7 +34,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n@@ -54,7 +54,7 @@ use rustc_session::lint::{Level, Lint};\n use rustc_session::Limit;\n use rustc_session::Session;\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n-use rustc_span::source_map::{MultiSpan, SourceMap};\n+use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};"}, {"sha": "49d0ce52052053773013052b858def723b81aa95", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -8,12 +8,18 @@ use crate::ty::{\n };\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n use rustc_span::Span;\n \n+impl<'tcx> IntoDiagnosticArg for Ty<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        format!(\"{}\", self).into_diagnostic_arg()\n+    }\n+}\n+\n impl<'tcx> Ty<'tcx> {\n     /// Similar to `Ty::is_primitive`, but also considers inferred numeric values to be primitive.\n     pub fn is_primitive_ty(self) -> bool {"}, {"sha": "d93c9a79c6556c9e8812529301badc4ccfbe9d3e", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -3,11 +3,11 @@ use crate::ty::diagnostics::suggest_constraining_type_param;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n-use rustc_errors::{pluralize, Diagnostic};\n+use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{BytePos, MultiSpan, Span};\n+use rustc_span::{BytePos, Span};\n use rustc_target::spec::abi;\n \n use std::borrow::Cow;"}, {"sha": "fd7045d6a03f210da9ebfd54ab975d3ff700e179", "filename": "compiler/rustc_middle/src/util/bug.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1,7 +1,8 @@\n // These functions are used by macro expansion for bug! and span_bug!\n \n use crate::ty::{tls, TyCtxt};\n-use rustc_span::{MultiSpan, Span};\n+use rustc_errors::MultiSpan;\n+use rustc_span::Span;\n use std::fmt;\n use std::panic::{panic_any, Location};\n "}, {"sha": "44caa2ac076f23f9de6bf3e5451284d08a982208", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -8,7 +8,7 @@ use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n     error_code, pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed,\n+    ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n@@ -21,7 +21,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n-use rustc_span::{BytePos, DesugaringKind, ExpnKind, MultiSpan, Span};\n+use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {"}, {"sha": "ed2640451705b6080e89b48cfc58e9b69dd2bd47", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -18,10 +18,12 @@ use rustc_ast::{\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, EmissionGuarantee, ErrorGuaranteed};\n-use rustc_errors::{Applicability, DiagnosticBuilder, Handler, PResult};\n+use rustc_errors::{\n+    Applicability, DiagnosticBuilder, DiagnosticMessage, Handler, MultiSpan, PResult,\n+};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident};\n-use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n+use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n use std::ops::{Deref, DerefMut};\n \n use std::mem::take;\n@@ -273,12 +275,12 @@ impl<'a> Parser<'a> {\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        m: &str,\n+        m: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n \n-    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n+    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: impl Into<DiagnosticMessage>) -> ! {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n \n@@ -584,16 +586,22 @@ impl<'a> Parser<'a> {\n                     //     field: value,\n                     // } }\n                     err.delay_as_bug();\n-                    self.struct_span_err(expr.span, \"struct literal body without path\")\n-                        .multipart_suggestion(\n-                            \"you might have forgotten to add the struct literal inside the block\",\n-                            vec![\n-                                (expr.span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n-                                (expr.span.shrink_to_hi(), \" }\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.struct_span_err(\n+                        expr.span,\n+                        DiagnosticMessage::fluent(\"parser-struct-literal-body-without-path\"),\n+                    )\n+                    .multipart_suggestion(\n+                        DiagnosticMessage::fluent_attr(\n+                            \"parser-struct-literal-body-without-path\",\n+                            \"suggestion\",\n+                        ),\n+                        vec![\n+                            (expr.span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n+                            (expr.span.shrink_to_hi(), \" }\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n                     self.restore_snapshot(snapshot);\n                     let mut tail = self.mk_block(\n                         vec![self.mk_stmt_err(expr.span)],"}, {"sha": "7978a1a7f5fff53a4ed770bd82fe1d174c42e905", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1703,7 +1703,7 @@ impl<'a> Parser<'a> {\n                     if matches!(expr.kind, ExprKind::Err) {\n                         let mut err = self\n                             .diagnostic()\n-                            .struct_span_err(self.token.span, &\"invalid interpolated expression\");\n+                            .struct_span_err(self.token.span, \"invalid interpolated expression\");\n                         err.downgrade_to_delayed_bug();\n                         return err;\n                     }\n@@ -1820,7 +1820,7 @@ impl<'a> Parser<'a> {\n                 } else if let Some(fixed) = fix_base_capitalisation(suf) {\n                     let msg = \"invalid base prefix for number literal\";\n \n-                    self.struct_span_err(span, &msg)\n+                    self.struct_span_err(span, msg)\n                         .note(\"base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\")\n                         .span_suggestion(\n                             span,"}, {"sha": "5bf6f22b5d06452f760134a1b5d6756e980fb649", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1010,7 +1010,8 @@ impl<'a> Parser<'a> {\n                 let current_qual_sp = self.prev_token.span;\n                 let current_qual_sp = current_qual_sp.to(sp_start);\n                 if let Ok(current_qual) = self.span_to_snippet(current_qual_sp) {\n-                    if err.message() == \"expected `{`, found keyword `unsafe`\" {\n+                    // FIXME(davidtwco): avoid depending on the error message text\n+                    if err.message[0].0.expect_str() == \"expected `{`, found keyword `unsafe`\" {\n                         let invalid_qual_sp = self.token.uninterpolated_span();\n                         let invalid_qual = self.span_to_snippet(invalid_qual_sp).unwrap();\n "}, {"sha": "792f9d9ccce56476cf602177f83a45d9f46f61f4", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -33,10 +33,10 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::PResult;\n use rustc_errors::{\n-    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError,\n+    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, MultiSpan,\n };\n use rustc_session::parse::ParseSess;\n-use rustc_span::source_map::{MultiSpan, Span, DUMMY_SP};\n+use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use tracing::debug;\n "}, {"sha": "1f12f99efb3d5b21a04a304f7580bc772dfe53cb", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -6,7 +6,7 @@\n \n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{pluralize, struct_span_err, Applicability};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -21,7 +21,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{Span, DUMMY_SP};\n use std::collections::hash_map::Entry;\n \n pub(crate) fn target_from_impl_item<'tcx>("}, {"sha": "700290d67a41b23594d12dffb06b9cf5f2749020", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -620,8 +620,8 @@ fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: D\n     } else {\n         sess.struct_err(&format!(\"internal compiler error: encountered incremental compilation error with {:?}\", dep_node))\n                 .help(&format!(\"This is a known issue with the compiler. Run {} to allow your project to compile\", run_cmd))\n-                .note(&\"Please follow the instructions below to create a bug report with the provided information\")\n-                .note(&\"See <https://github.com/rust-lang/rust/issues/84970> for more information\")\n+                .note(\"Please follow the instructions below to create a bug report with the provided information\")\n+                .note(\"See <https://github.com/rust-lang/rust/issues/84970> for more information\")\n                 .emit();\n         panic!(\"Found unstable fingerprints for {:?}: {:?}\", dep_node, result);\n     }"}, {"sha": "6503b97a1d31fbc8d57e1d298d4f42381387ca82", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -32,10 +32,10 @@ use rustc_ast::node_id::NodeMap;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::pluralize;\n+use rustc_errors::{pluralize, MultiSpan};\n use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{Span, DUMMY_SP};\n \n struct UnusedImport<'a> {\n     use_tree: &'a ast::UseTree,"}, {"sha": "609dbd1fe1b4e8606bb0e2f8946cfd3532f11c13", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::{self as ast, Path};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n-    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n@@ -18,7 +18,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, MultiSpan, Span};\n+use rustc_span::{BytePos, Span};\n use tracing::debug;\n \n use crate::imports::{Import, ImportKind, ImportResolver};\n@@ -1341,7 +1341,7 @@ impl<'a> Resolver<'a> {\n             let def_span = self.session.source_map().guess_head_span(binding.span);\n             let mut note_span = MultiSpan::from_span(def_span);\n             if !first && binding.vis.is_public() {\n-                note_span.push_span_label(def_span, \"consider importing it directly\".into());\n+                note_span.push_span_label(def_span, \"consider importing it directly\");\n             }\n             err.span_note(note_span, &msg);\n         }"}, {"sha": "02abdbaa98354b9e37b09c9cf5a9b252ad3152d8", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -12,7 +12,7 @@ use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBindin\n use rustc_ast::NodeId;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::{pluralize, struct_span_err, Applicability};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir::def::{self, PartialRes};\n use rustc_hir::def_id::DefId;\n use rustc_middle::metadata::ModChild;\n@@ -23,7 +23,7 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::hygiene::LocalExpnId;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n \n use tracing::*;\n \n@@ -739,7 +739,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n             for message in note {\n-                diag.note(&message);\n+                diag.note(message);\n             }\n         }\n "}, {"sha": "1e943f0e44abd5b24c44fb1eb5bb5af3f817ff13", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -14,6 +14,7 @@ use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n@@ -25,7 +26,7 @@ use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use std::iter;\n use std::ops::Deref;\n@@ -1106,7 +1107,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         .collect();\n \n                     if non_visible_spans.len() > 0 {\n-                        let mut m: rustc_span::MultiSpan = non_visible_spans.clone().into();\n+                        let mut m: MultiSpan = non_visible_spans.clone().into();\n                         non_visible_spans\n                             .into_iter()\n                             .for_each(|s| m.push_span_label(s, \"private field\".to_string()));\n@@ -1139,7 +1140,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         }\n                         err.span_suggestion(\n                             span,\n-                            &\"use this syntax instead\",\n+                            \"use this syntax instead\",\n                             path_str.to_string(),\n                             Applicability::MaybeIncorrect,\n                         );"}, {"sha": "d5053034ed88298a0c885e6da5410e4b80c39a10", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -431,6 +431,20 @@ where\n     }\n }\n \n+impl<'a, S: Encoder> Encodable<S> for Cow<'a, str> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        let val: &str = self;\n+        val.encode(s)\n+    }\n+}\n+\n+impl<'a, D: Decoder> Decodable<D> for Cow<'a, str> {\n+    fn decode(d: &mut D) -> Cow<'static, str> {\n+        let v: String = Decodable::decode(d);\n+        Cow::Owned(v)\n+    }\n+}\n+\n impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| match *self {"}, {"sha": "5a447aa6237345f2e6c608666f90bf0fecc34a8f", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -2856,6 +2856,7 @@ crate mod dep_tracking {\n     use crate::lint;\n     use crate::options::WasiExecModel;\n     use crate::utils::{NativeLib, NativeLibKind};\n+    use rustc_errors::LanguageIdentifier;\n     use rustc_feature::UnstableFeatures;\n     use rustc_span::edition::Edition;\n     use rustc_span::RealFileName;\n@@ -2948,6 +2949,7 @@ crate mod dep_tracking {\n         LocationDetail,\n         BranchProtection,\n         OomStrategy,\n+        LanguageIdentifier,\n     );\n \n     impl<T1, T2> DepTrackingHash for (T1, T2)"}, {"sha": "4994f8eaeb2dcaae287369413334f0710c10c62b", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -4,6 +4,7 @@ use crate::early_error;\n use crate::lint;\n use crate::search_paths::SearchPath;\n use crate::utils::NativeLib;\n+use rustc_errors::LanguageIdentifier;\n use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy, SanitizerSet};\n use rustc_target::spec::{\n     RelocModel, RelroLevel, SplitDebuginfo, StackProtector, TargetTriple, TlsModel,\n@@ -365,6 +366,7 @@ mod desc {\n     pub const parse_string: &str = \"a string\";\n     pub const parse_opt_string: &str = parse_string;\n     pub const parse_string_push: &str = parse_string;\n+    pub const parse_opt_langid: &str = \"a language identifier\";\n     pub const parse_opt_pathbuf: &str = \"a path\";\n     pub const parse_list: &str = \"a space-separated list of strings\";\n     pub const parse_opt_comma_list: &str = \"a comma-separated list of strings\";\n@@ -487,6 +489,17 @@ mod parse {\n         }\n     }\n \n+    /// Parse an optional language identifier, e.g. `en-US` or `zh-CN`.\n+    crate fn parse_opt_langid(slot: &mut Option<LanguageIdentifier>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                *slot = rustc_errors::LanguageIdentifier::from_str(s).ok();\n+                true\n+            }\n+            None => false,\n+        }\n+    }\n+\n     crate fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n@@ -1462,6 +1475,15 @@ options! {\n         \"the directory the intermediate files are written to\"),\n     terminal_width: Option<usize> = (None, parse_opt_number, [UNTRACKED],\n         \"set the current terminal width\"),\n+    // Diagnostics are considered side-effects of a query (see `QuerySideEffects`) and are saved\n+    // alongside query results and changes to translation options can affect diagnostics - so\n+    // translation options should be tracked.\n+    translate_lang: Option<LanguageIdentifier> = (None, parse_opt_langid, [TRACKED],\n+        \"language identifier for diagnostic output\"),\n+    translate_additional_ftl: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n+        \"additional fluent translation to preferentially use (for testing translation)\"),\n+    translate_directionality_markers: bool = (false, parse_bool, [TRACKED],\n+        \"emit directionality isolation markers in translated diagnostics\"),\n     tune_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select processor to schedule for (`rustc --print target-cpus` for details)\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "0b9c27c2cd6e387cd849acb9b45a353633aa4928", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -7,12 +7,15 @@ use rustc_ast::node_id::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n-use rustc_errors::{error_code, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{\n+    error_code, fallback_fluent_bundle, Applicability, Diagnostic, DiagnosticBuilder,\n+    ErrorGuaranteed, MultiSpan,\n+};\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n-use rustc_span::{MultiSpan, Span, Symbol};\n+use rustc_span::{Span, Symbol};\n \n use std::str;\n \n@@ -171,8 +174,17 @@ pub struct ParseSess {\n impl ParseSess {\n     /// Used for testing.\n     pub fn new(file_path_mapping: FilePathMapping) -> Self {\n+        let fallback_bundle =\n+            fallback_fluent_bundle(false).expect(\"failed to load fallback fluent bundle\");\n         let sm = Lrc::new(SourceMap::new(file_path_mapping));\n-        let handler = Handler::with_tty_emitter(ColorConfig::Auto, true, None, Some(sm.clone()));\n+        let handler = Handler::with_tty_emitter(\n+            ColorConfig::Auto,\n+            true,\n+            None,\n+            Some(sm.clone()),\n+            None,\n+            fallback_bundle,\n+        );\n         ParseSess::with_span_handler(handler, sm)\n     }\n \n@@ -201,8 +213,11 @@ impl ParseSess {\n     }\n \n     pub fn with_silent_emitter(fatal_note: Option<String>) -> Self {\n+        let fallback_bundle =\n+            fallback_fluent_bundle(false).expect(\"failed to load fallback fluent bundle\");\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let fatal_handler = Handler::with_tty_emitter(ColorConfig::Auto, false, None, None);\n+        let fatal_handler =\n+            Handler::with_tty_emitter(ColorConfig::Auto, false, None, None, None, fallback_bundle);\n         let handler = Handler::with_emitter(\n             false,\n             None,"}, {"sha": "9881046ddfa295afe6822f0ca369f1d37f619e38", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 122, "deletions": 38, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -19,11 +19,14 @@ use rustc_errors::annotate_snippet_emitter_writer::AnnotateSnippetEmitterWriter;\n use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n+use rustc_errors::{\n+    fallback_fluent_bundle, fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n+    EmissionGuarantee, ErrorGuaranteed, FluentBundle, MultiSpan,\n+};\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n use rustc_span::edition::Edition;\n-use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n+use rustc_span::source_map::{FileLoader, RealFileLoader, SourceMap, Span};\n use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n@@ -206,10 +209,10 @@ pub struct PerfStats {\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(SessionDiagnostic)]` -- see [rustc_macros::SessionDiagnostic].\n-pub trait SessionDiagnostic<'a> {\n+pub trait SessionDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n     /// Write out as a diagnostic out of `sess`.\n     #[must_use]\n-    fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a, ErrorGuaranteed>;\n+    fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a, T>;\n }\n \n impl Session {\n@@ -279,116 +282,143 @@ impl Session {\n     pub fn struct_span_warn<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n     pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n-    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_warn(msg)\n     }\n     pub fn struct_span_allow<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_allow(sp, msg)\n     }\n-    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_allow(msg)\n     }\n     pub fn struct_expect(\n         &self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         id: lint::LintExpectationId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_expect(msg, id)\n     }\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n-    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+    pub fn struct_err(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_err(msg)\n     }\n     pub fn struct_err_with_code(\n         &self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n+    pub fn struct_warn_with_code(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_, ()> {\n+        self.diagnostic().struct_warn_with_code(msg, code)\n+    }\n     pub fn struct_span_fatal<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_span_fatal(sp, msg)\n     }\n     pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n-    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_, !> {\n+    pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_fatal(msg)\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().span_fatal(sp, msg)\n     }\n     pub fn span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> ! {\n         self.diagnostic().span_fatal_with_code(sp, msg, code)\n     }\n-    pub fn fatal(&self, msg: &str) -> ! {\n+    pub fn fatal(&self, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().fatal(msg).raise()\n     }\n-    pub fn span_err_or_warn<S: Into<MultiSpan>>(&self, is_warning: bool, sp: S, msg: &str) {\n+    pub fn span_err_or_warn<S: Into<MultiSpan>>(\n+        &self,\n+        is_warning: bool,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) {\n         if is_warning {\n             self.span_warn(sp, msg);\n         } else {\n             self.span_err(sp, msg);\n         }\n     }\n-    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ErrorGuaranteed {\n+    pub fn span_err<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         self.diagnostic().span_err(sp, msg)\n     }\n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.diagnostic().span_err_with_code(sp, &msg, code)\n+    pub fn span_err_with_code<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) {\n+        self.diagnostic().span_err_with_code(sp, msg, code)\n     }\n-    pub fn err(&self, msg: &str) -> ErrorGuaranteed {\n+    pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.diagnostic().err(msg)\n     }\n     pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) -> ErrorGuaranteed {\n         err.into_diagnostic(self).emit()\n     }\n+    pub fn emit_warning<'a>(&'a self, warning: impl SessionDiagnostic<'a, ()>) {\n+        warning.into_diagnostic(self).emit()\n+    }\n     #[inline]\n     pub fn err_count(&self) -> usize {\n         self.diagnostic().err_count()\n@@ -423,25 +453,34 @@ impl Session {\n             Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n         }\n     }\n-    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n-    pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n+    pub fn span_warn_with_code<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) {\n         self.diagnostic().span_warn_with_code(sp, msg, code)\n     }\n-    pub fn warn(&self, msg: &str) {\n+    pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().warn(msg)\n     }\n     /// Delay a span_bug() call until abort_if_errors()\n     #[track_caller]\n-    pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ErrorGuaranteed {\n+    pub fn delay_span_bug<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         self.diagnostic().delay_span_bug(sp, msg)\n     }\n \n     /// Used for code paths of expensive computations that should only take place when\n     /// warnings or errors are emitted. If no messages are emitted (\"good path\"), then\n     /// it's likely a bug.\n-    pub fn delay_good_path_bug(&self, msg: &str) {\n+    pub fn delay_good_path_bug(&self, msg: impl Into<DiagnosticMessage>) {\n         if self.opts.debugging_opts.print_type_sizes\n             || self.opts.debugging_opts.query_dep_graph\n             || self.opts.debugging_opts.dump_mir.is_some()\n@@ -455,13 +494,20 @@ impl Session {\n         self.diagnostic().delay_good_path_bug(msg)\n     }\n \n-    pub fn note_without_error(&self, msg: &str) {\n+    pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().note_without_error(msg)\n     }\n-    pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+    pub fn span_note_without_error<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n-    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_note_without_error(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_note_without_error(msg)\n     }\n \n@@ -1033,6 +1079,8 @@ fn default_emitter(\n     sopts: &config::Options,\n     registry: rustc_errors::registry::Registry,\n     source_map: Lrc<SourceMap>,\n+    bundle: Option<Lrc<FluentBundle>>,\n+    fallback_bundle: Lrc<FluentBundle>,\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Box<dyn Emitter + sync::Send> {\n     let macro_backtrace = sopts.debugging_opts.macro_backtrace;\n@@ -1041,14 +1089,21 @@ fn default_emitter(\n             let (short, color_config) = kind.unzip();\n \n             if let HumanReadableErrorType::AnnotateSnippet(_) = kind {\n-                let emitter =\n-                    AnnotateSnippetEmitterWriter::new(Some(source_map), short, macro_backtrace);\n+                let emitter = AnnotateSnippetEmitterWriter::new(\n+                    Some(source_map),\n+                    bundle,\n+                    fallback_bundle,\n+                    short,\n+                    macro_backtrace,\n+                );\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n             } else {\n                 let emitter = match dst {\n                     None => EmitterWriter::stderr(\n                         color_config,\n                         Some(source_map),\n+                        bundle,\n+                        fallback_bundle,\n                         short,\n                         sopts.debugging_opts.teach,\n                         sopts.debugging_opts.terminal_width,\n@@ -1057,6 +1112,8 @@ fn default_emitter(\n                     Some(dst) => EmitterWriter::new(\n                         dst,\n                         Some(source_map),\n+                        bundle,\n+                        fallback_bundle,\n                         short,\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n@@ -1071,6 +1128,8 @@ fn default_emitter(\n             JsonEmitter::stderr(\n                 Some(registry),\n                 source_map,\n+                bundle,\n+                fallback_bundle,\n                 pretty,\n                 json_rendered,\n                 sopts.debugging_opts.terminal_width,\n@@ -1083,6 +1142,8 @@ fn default_emitter(\n                 dst,\n                 Some(registry),\n                 source_map,\n+                bundle,\n+                fallback_bundle,\n                 pretty,\n                 json_rendered,\n                 sopts.debugging_opts.terminal_width,\n@@ -1152,7 +1213,19 @@ pub fn build_session(\n         sopts.file_path_mapping(),\n         hash_kind,\n     ));\n-    let emitter = default_emitter(&sopts, registry, source_map.clone(), write_dest);\n+\n+    let bundle = fluent_bundle(\n+        &sysroot,\n+        sopts.debugging_opts.translate_lang.clone(),\n+        sopts.debugging_opts.translate_additional_ftl.as_deref(),\n+        sopts.debugging_opts.translate_directionality_markers,\n+    )\n+    .expect(\"failed to load fluent bundle\");\n+    let fallback_bundle =\n+        fallback_fluent_bundle(sopts.debugging_opts.translate_directionality_markers)\n+            .expect(\"failed to load fallback fluent bundle\");\n+    let emitter =\n+        default_emitter(&sopts, registry, source_map.clone(), bundle, fallback_bundle, write_dest);\n \n     let span_diagnostic = rustc_errors::Handler::with_emitter_and_flags(\n         emitter,\n@@ -1385,13 +1458,24 @@ pub enum IncrCompSession {\n }\n \n fn early_error_handler(output: config::ErrorOutputType) -> rustc_errors::Handler {\n+    let fallback_bundle =\n+        fallback_fluent_bundle(false).expect(\"failed to load fallback fluent bundle\");\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false, None, false))\n+            Box::new(EmitterWriter::stderr(\n+                color_config,\n+                None,\n+                None,\n+                fallback_bundle,\n+                short,\n+                false,\n+                None,\n+                false,\n+            ))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } => {\n-            Box::new(JsonEmitter::basic(pretty, json_rendered, None, false))\n+            Box::new(JsonEmitter::basic(pretty, json_rendered, None, fallback_bundle, None, false))\n         }\n     };\n     rustc_errors::Handler::with_emitter(true, None, emitter)"}, {"sha": "5232c8d7006bdb88ab54fd7fddaad7b3fae5e6e9", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -520,20 +520,6 @@ impl Ord for Span {\n     }\n }\n \n-/// A collection of `Span`s.\n-///\n-/// Spans have two orthogonal attributes:\n-///\n-/// - They can be *primary spans*. In this case they are the locus of\n-///   the error, and would be rendered with `^^^`.\n-/// - They can have a *label*. In this case, the label is written next\n-///   to the mark in the snippet when we render.\n-#[derive(Clone, Debug, Hash, PartialEq, Eq, Encodable, Decodable)]\n-pub struct MultiSpan {\n-    primary_spans: Vec<Span>,\n-    span_labels: Vec<(Span, String)>,\n-}\n-\n impl Span {\n     #[inline]\n     pub fn lo(self) -> BytePos {\n@@ -949,20 +935,6 @@ impl Span {\n     }\n }\n \n-/// A span together with some additional data.\n-#[derive(Clone, Debug)]\n-pub struct SpanLabel {\n-    /// The span we are going to include in the final snippet.\n-    pub span: Span,\n-\n-    /// Is this a primary span? This is the \"locus\" of the message,\n-    /// and is indicated with a `^^^^` underline, versus `----`.\n-    pub is_primary: bool,\n-\n-    /// What label should we attach to this span (if any)?\n-    pub label: Option<String>,\n-}\n-\n impl Default for Span {\n     fn default() -> Self {\n         DUMMY_SP\n@@ -1035,115 +1007,6 @@ impl fmt::Debug for SpanData {\n     }\n }\n \n-impl MultiSpan {\n-    #[inline]\n-    pub fn new() -> MultiSpan {\n-        MultiSpan { primary_spans: vec![], span_labels: vec![] }\n-    }\n-\n-    pub fn from_span(primary_span: Span) -> MultiSpan {\n-        MultiSpan { primary_spans: vec![primary_span], span_labels: vec![] }\n-    }\n-\n-    pub fn from_spans(mut vec: Vec<Span>) -> MultiSpan {\n-        vec.sort();\n-        MultiSpan { primary_spans: vec, span_labels: vec![] }\n-    }\n-\n-    pub fn push_span_label(&mut self, span: Span, label: String) {\n-        self.span_labels.push((span, label));\n-    }\n-\n-    /// Selects the first primary span (if any).\n-    pub fn primary_span(&self) -> Option<Span> {\n-        self.primary_spans.first().cloned()\n-    }\n-\n-    /// Returns all primary spans.\n-    pub fn primary_spans(&self) -> &[Span] {\n-        &self.primary_spans\n-    }\n-\n-    /// Returns `true` if any of the primary spans are displayable.\n-    pub fn has_primary_spans(&self) -> bool {\n-        self.primary_spans.iter().any(|sp| !sp.is_dummy())\n-    }\n-\n-    /// Returns `true` if this contains only a dummy primary span with any hygienic context.\n-    pub fn is_dummy(&self) -> bool {\n-        let mut is_dummy = true;\n-        for span in &self.primary_spans {\n-            if !span.is_dummy() {\n-                is_dummy = false;\n-            }\n-        }\n-        is_dummy\n-    }\n-\n-    /// Replaces all occurrences of one Span with another. Used to move `Span`s in areas that don't\n-    /// display well (like std macros). Returns whether replacements occurred.\n-    pub fn replace(&mut self, before: Span, after: Span) -> bool {\n-        let mut replacements_occurred = false;\n-        for primary_span in &mut self.primary_spans {\n-            if *primary_span == before {\n-                *primary_span = after;\n-                replacements_occurred = true;\n-            }\n-        }\n-        for span_label in &mut self.span_labels {\n-            if span_label.0 == before {\n-                span_label.0 = after;\n-                replacements_occurred = true;\n-            }\n-        }\n-        replacements_occurred\n-    }\n-\n-    /// Returns the strings to highlight. We always ensure that there\n-    /// is an entry for each of the primary spans -- for each primary\n-    /// span `P`, if there is at least one label with span `P`, we return\n-    /// those labels (marked as primary). But otherwise we return\n-    /// `SpanLabel` instances with empty labels.\n-    pub fn span_labels(&self) -> Vec<SpanLabel> {\n-        let is_primary = |span| self.primary_spans.contains(&span);\n-\n-        let mut span_labels = self\n-            .span_labels\n-            .iter()\n-            .map(|&(span, ref label)| SpanLabel {\n-                span,\n-                is_primary: is_primary(span),\n-                label: Some(label.clone()),\n-            })\n-            .collect::<Vec<_>>();\n-\n-        for &span in &self.primary_spans {\n-            if !span_labels.iter().any(|sl| sl.span == span) {\n-                span_labels.push(SpanLabel { span, is_primary: true, label: None });\n-            }\n-        }\n-\n-        span_labels\n-    }\n-\n-    /// Returns `true` if any of the span labels is displayable.\n-    pub fn has_span_labels(&self) -> bool {\n-        self.span_labels.iter().any(|(sp, _)| !sp.is_dummy())\n-    }\n-}\n-\n-impl From<Span> for MultiSpan {\n-    fn from(span: Span) -> MultiSpan {\n-        MultiSpan::from_span(span)\n-    }\n-}\n-\n-impl From<Vec<Span>> for MultiSpan {\n-    fn from(spans: Vec<Span>) -> MultiSpan {\n-        MultiSpan::from_spans(spans)\n-    }\n-}\n-\n /// Identifies an offset of a multi-byte character in a `SourceFile`.\n #[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {"}, {"sha": "ff3488b7b769d3b29b59551a51d1361f692b24f0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -15,7 +15,7 @@ use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-    Style,\n+    MultiSpan, Style,\n };\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -33,7 +33,7 @@ use rustc_middle::ty::{\n     self, SubtypePredicate, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::symbol::{kw, sym};\n-use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n use std::iter;\n "}, {"sha": "8dac56120e6605c2294661290d51324807eea2bd", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n     error_code, pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed, Style,\n+    ErrorGuaranteed, MultiSpan, Style,\n };\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -27,7 +27,7 @@ use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_session::Limit;\n use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, DesugaringKind, ExpnKind, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use std::fmt;\n \n@@ -597,7 +597,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     Some(format!(\"{}\", name))\n                 }\n                 _ => {\n-                    err.note(&msg);\n+                    err.note(msg);\n                     None\n                 }\n             }\n@@ -780,7 +780,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if has_custom_message {\n                         err.note(&msg);\n                     } else {\n-                        err.message = vec![(msg, Style::NoStyle)];\n+                        err.message =\n+                            vec![(rustc_errors::DiagnosticMessage::Str(msg), Style::NoStyle)];\n                     }\n                     if snippet.starts_with('&') {\n                         // This is already a literal borrow and the obligation is failing\n@@ -2480,7 +2481,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .opt_associated_item(trait_item_def_id)\n                     .and_then(|i| self.tcx.opt_item_name(i.container.id()))\n                 {\n-                    assoc_span.push_span_label(ident.span, \"in this trait\".into());\n+                    assoc_span.push_span_label(ident.span, \"in this trait\");\n                 }\n                 err.span_note(assoc_span, &msg);\n             }\n@@ -2505,7 +2506,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .opt_associated_item(trait_item_def_id)\n                     .and_then(|i| self.tcx.opt_item_name(i.container.id()))\n                 {\n-                    assoc_span.push_span_label(ident.span, \"in this trait\".into());\n+                    assoc_span.push_span_label(ident.span, \"in this trait\");\n                 }\n                 err.span_note(assoc_span, &msg);\n             }"}, {"sha": "84958136cac97b98dadea1239e44162882d4fd63", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -14,15 +14,15 @@ use crate::infer::TyCtxtInferExt;\n use crate::traits::const_evaluatable::{self, AbstractConst};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n-use rustc_errors::FatalError;\n+use rustc_errors::{FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_middle::ty::{Predicate, ToPredicate};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n use smallvec::SmallVec;\n \n use std::iter;\n@@ -169,10 +169,7 @@ fn lint_object_unsafe_trait(\n         let node = tcx.hir().get_if_local(trait_def_id);\n         let mut spans = MultiSpan::from_span(span);\n         if let Some(hir::Node::Item(item)) = node {\n-            spans.push_span_label(\n-                item.ident.span,\n-                \"this trait cannot be made into an object...\".into(),\n-            );\n+            spans.push_span_label(item.ident.span, \"this trait cannot be made into an object...\");\n             spans.push_span_label(span, format!(\"...because {}\", violation.error_msg()));\n         } else {\n             spans.push_span_label("}, {"sha": "a50301dbc87f0e2b9612ef013fe1809335561eab", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::{\n use crate::errors::AssocTypeBindingNotAllowed;\n use crate::structured_errors::{GenericArgsInfo, StructuredDiagnostic, WrongNumberOfGenericArgs};\n use rustc_ast::ast::ParamKindOrd;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -16,7 +16,7 @@ use rustc_middle::ty::{\n     self, subst, subst::SubstsRef, GenericParamDef, GenericParamDefKind, Ty, TyCtxt,\n };\n use rustc_session::lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS;\n-use rustc_span::{symbol::kw, MultiSpan, Span};\n+use rustc_span::{symbol::kw, Span};\n use smallvec::SmallVec;\n \n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {"}, {"sha": "26f7c267ed1c4622e678a388710e987bc0dd8e75", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1,11 +1,11 @@\n use crate::check::coercion::{AsCoercionSite, CoerceMany};\n use crate::check::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n use rustc_middle::ty::{self, ToPredicate, Ty, TypeFoldable};\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,"}, {"sha": "9ebafc26f61fdda25db65258c8bb9e7677d10f87", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -4,7 +4,7 @@ use super::compare_method::{compare_const_impl, compare_impl_method, compare_ty_\n use super::*;\n \n use rustc_attr as attr;\n-use rustc_errors::{Applicability, ErrorGuaranteed};\n+use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n@@ -20,7 +20,7 @@ use rustc_middle::ty::util::{Discr, IntTypeExt};\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n-use rustc_span::{self, MultiSpan, Span};\n+use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;"}, {"sha": "d403d6e3f33828ccd16d4021e994b6df18dc9e55", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -8,7 +8,7 @@ use crate::check::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n \n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, Diagnostic, ErrorGuaranteed};\n+use rustc_errors::{Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -30,7 +30,7 @@ use rustc_session::lint;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{self, BytePos, MultiSpan, Span};\n+use rustc_span::{self, BytePos, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{"}, {"sha": "1cc1460750a2334881ad2df934229cfbb3721b77", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -11,7 +11,7 @@ use crate::check::{\n \n use rustc_ast as ast;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticId};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticId, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -21,7 +21,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n-use rustc_span::{self, MultiSpan, Span};\n+use rustc_span::{self, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n \n use crate::structured_errors::StructuredDiagnostic;"}, {"sha": "1ccdbb0aa500be1bafaf147c62ec163f3bbb5548", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -2,9 +2,9 @@ use super::FnCtxt;\n use crate::astconv::AstConv;\n \n use rustc_ast::util::parser::ExprPrecedence;\n-use rustc_span::{self, MultiSpan, Span};\n+use rustc_span::{self, Span};\n \n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;"}, {"sha": "cd6b1115ed806444cfe7132d8261ca82e5530e02", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -7,7 +7,7 @@ use crate::errors::{\n };\n use crate::require_same_types;\n \n-use rustc_errors::{pluralize, struct_span_err};\n+use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n use rustc_middle::ty::subst::Subst;\n@@ -43,7 +43,6 @@ fn equate_intrinsic_type<'tcx>(\n                 span,\n                 found,\n                 expected,\n-                expected_pluralize: pluralize!(expected),\n                 descr,\n             });\n             false"}, {"sha": "ecc2996593704a85e15cf76a3c163b32d9688a99", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -5,6 +5,7 @@ use crate::check::FnCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -17,7 +18,7 @@ use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::ToPolyTraitRef;\n use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, MultiSpan, Span};\n+use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{"}, {"sha": "19d52f430fcd56214531951c1362416eb7b142de", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -103,7 +103,7 @@ pub use inherited::{Inherited, InheritedBuilder};\n use crate::astconv::AstConv;\n use crate::check::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -121,7 +121,7 @@ use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, Ident};\n-use rustc_span::{self, BytePos, MultiSpan, Span};\n+use rustc_span::{self, BytePos, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;"}, {"sha": "0baca9048b4cd56f22d4e3f1dc3e526facec0797", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -4,6 +4,7 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -18,7 +19,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{BytePos, MultiSpan, DUMMY_SP};\n+use rustc_span::{BytePos, DUMMY_SP};\n use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::{ObligationCause, Pattern};\n use ty::VariantDef;"}, {"sha": "1118e967707357de5e65fa70a9eec53d318ab454", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -33,7 +33,7 @@\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n@@ -46,7 +46,7 @@ use rustc_middle::ty::{\n };\n use rustc_session::lint;\n use rustc_span::sym;\n-use rustc_span::{BytePos, MultiSpan, Pos, Span, Symbol};\n+use rustc_span::{BytePos, Pos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n use rustc_data_structures::stable_map::FxHashMap;"}, {"sha": "0b78aea9f05bd020b93a721a8fd4765fe8366667", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 61, "deletions": 64, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -3,188 +3,185 @@ use rustc_macros::SessionDiagnostic;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0062\"]\n+#[error(code = \"E0062\", slug = \"typeck-field-multiply-specified-in-initializer\")]\n pub struct FieldMultiplySpecifiedInInitializer {\n-    #[message = \"field `{ident}` specified more than once\"]\n-    #[label = \"used more than once\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n-    #[label = \"first use of `{ident}`\"]\n+    #[label = \"previous-use-label\"]\n     pub prev_span: Span,\n     pub ident: Ident,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0092\"]\n+#[error(code = \"E0092\", slug = \"typeck-unrecognized-atomic-operation\")]\n pub struct UnrecognizedAtomicOperation<'a> {\n-    #[message = \"unrecognized atomic operation function: `{op}`\"]\n-    #[label = \"unrecognized atomic operation\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n     pub op: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0094\"]\n+#[error(code = \"E0094\", slug = \"typeck-wrong-number-of-generic-arguments-to-intrinsic\")]\n pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n-    #[message = \"intrinsic has wrong number of {descr} \\\n-                         parameters: found {found}, expected {expected}\"]\n-    #[label = \"expected {expected} {descr} parameter{expected_pluralize}\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n     pub found: usize,\n     pub expected: usize,\n-    pub expected_pluralize: &'a str,\n     pub descr: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0093\"]\n+#[error(code = \"E0093\", slug = \"typeck-unrecognized-intrinsic-function\")]\n pub struct UnrecognizedIntrinsicFunction {\n-    #[message = \"unrecognized intrinsic function: `{name}`\"]\n-    #[label = \"unrecognized intrinsic\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0195\"]\n+#[error(code = \"E0195\", slug = \"typeck-lifetimes-or-bounds-mismatch-on-trait\")]\n pub struct LifetimesOrBoundsMismatchOnTrait {\n-    #[message = \"lifetime parameters or bounds on {item_kind} `{ident}` do not match the trait declaration\"]\n-    #[label = \"lifetimes do not match {item_kind} in trait\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n-    #[label = \"lifetimes in impl do not match this {item_kind} in trait\"]\n+    #[label = \"generics-label\"]\n     pub generics_span: Option<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0120\"]\n+#[error(code = \"E0120\", slug = \"typeck-drop-impl-on-wrong-item\")]\n pub struct DropImplOnWrongItem {\n-    #[message = \"the `Drop` trait may only be implemented for structs, enums, and unions\"]\n-    #[label = \"must be a struct, enum, or union\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0124\"]\n+#[error(code = \"E0124\", slug = \"typeck-field-already-declared\")]\n pub struct FieldAlreadyDeclared {\n     pub field_name: Ident,\n-    #[message = \"field `{field_name}` is already declared\"]\n-    #[label = \"field already declared\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n-    #[label = \"`{field_name}` first declared here\"]\n+    #[label = \"previous-decl-label\"]\n     pub prev_span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0184\"]\n+#[error(code = \"E0184\", slug = \"typeck-copy-impl-on-type-with-dtor\")]\n pub struct CopyImplOnTypeWithDtor {\n-    #[message = \"the trait `Copy` may not be implemented for this type; the \\\n-                              type has a destructor\"]\n-    #[label = \"Copy not allowed on types with destructors\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0203\"]\n+#[error(code = \"E0203\", slug = \"typeck-multiple-relaxed-default-bounds\")]\n pub struct MultipleRelaxedDefaultBounds {\n-    #[message = \"type parameter has more than one relaxed default bound, only one is supported\"]\n+    #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0206\"]\n+#[error(code = \"E0206\", slug = \"typeck-copy-impl-on-non-adt\")]\n pub struct CopyImplOnNonAdt {\n-    #[message = \"the trait `Copy` may not be implemented for this type\"]\n-    #[label = \"type is not a structure or enumeration\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0224\"]\n+#[error(code = \"E0224\", slug = \"typeck-trait-object-declared-with-no-traits\")]\n pub struct TraitObjectDeclaredWithNoTraits {\n-    #[message = \"at least one trait is required for an object type\"]\n+    #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0227\"]\n+#[error(code = \"E0227\", slug = \"typeck-ambiguous-lifetime-bound\")]\n pub struct AmbiguousLifetimeBound {\n-    #[message = \"ambiguous lifetime bound, explicit lifetime bound required\"]\n+    #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0229\"]\n+#[error(code = \"E0229\", slug = \"typeck-assoc-type-binding-not-allowed\")]\n pub struct AssocTypeBindingNotAllowed {\n-    #[message = \"associated type bindings are not allowed here\"]\n-    #[label = \"associated type not allowed here\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0436\"]\n+#[error(code = \"E0436\", slug = \"typeck-functional-record-update-on-non-struct\")]\n pub struct FunctionalRecordUpdateOnNonStruct {\n-    #[message = \"functional record update syntax requires a struct\"]\n+    #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0516\"]\n+#[error(code = \"E0516\", slug = \"typeck-typeof-reserved-keyword-used\")]\n pub struct TypeofReservedKeywordUsed {\n-    #[message = \"`typeof` is a reserved keyword but unimplemented\"]\n-    #[label = \"reserved keyword\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0572\"]\n+#[error(code = \"E0572\", slug = \"typeck-return-stmt-outside-of-fn-body\")]\n pub struct ReturnStmtOutsideOfFnBody {\n-    #[message = \"return statement outside of function body\"]\n+    #[primary_span]\n     pub span: Span,\n-    #[label = \"the return is part of this body...\"]\n+    #[label = \"encl-body-label\"]\n     pub encl_body_span: Option<Span>,\n-    #[label = \"...not the enclosing function body\"]\n+    #[label = \"encl-fn-label\"]\n     pub encl_fn_span: Option<Span>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0627\"]\n+#[error(code = \"E0627\", slug = \"typeck-yield-expr-outside-of-generator\")]\n pub struct YieldExprOutsideOfGenerator {\n-    #[message = \"yield expression outside of generator literal\"]\n+    #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0639\"]\n+#[error(code = \"E0639\", slug = \"typeck-struct-expr-non-exhaustive\")]\n pub struct StructExprNonExhaustive {\n-    #[message = \"cannot create non-exhaustive {what} using struct expression\"]\n+    #[primary_span]\n     pub span: Span,\n     pub what: &'static str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0699\"]\n+#[error(code = \"E0699\", slug = \"typeck-method-call-on-unknown-type\")]\n pub struct MethodCallOnUnknownType {\n-    #[message = \"the type of this value must be known to call a method on a raw pointer on it\"]\n+    #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0719\"]\n+#[error(code = \"E0719\", slug = \"typeck-value-of-associated-struct-already-specified\")]\n pub struct ValueOfAssociatedStructAlreadySpecified {\n-    #[message = \"the value of the associated type `{item_name}` (from trait `{def_path}`) is already specified\"]\n-    #[label = \"re-bound here\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n-    #[label = \"`{item_name}` bound here first\"]\n+    #[label = \"previous-bound-label\"]\n     pub prev_span: Span,\n     pub item_name: Ident,\n     pub def_path: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0745\"]\n+#[error(code = \"E0745\", slug = \"typeck-address-of-temporary-taken\")]\n pub struct AddressOfTemporaryTaken {\n-    #[message = \"cannot take address of a temporary\"]\n-    #[label = \"temporary value\"]\n+    #[primary_span]\n+    #[label]\n     pub span: Span,\n }"}, {"sha": "24b6639d7f2758373959b4d2115612f9b9a1a0e3", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1,13 +1,14 @@\n use crate::structured_errors::StructuredDiagnostic;\n use rustc_errors::{\n     pluralize, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorGuaranteed,\n+    MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_middle::hir::map::fn_sig;\n use rustc_middle::middle::resolve_lifetime::LifetimeScopeForPath;\n use rustc_middle::ty::{self as ty, TyCtxt};\n use rustc_session::Session;\n-use rustc_span::{def_id::DefId, MultiSpan};\n+use rustc_span::def_id::DefId;\n \n use GenericArgsInfo::*;\n "}, {"sha": "a32b9caa30fde8e5a8836c2e9a7fad8962253641", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -143,13 +143,17 @@ crate fn new_handler(\n     source_map: Option<Lrc<source_map::SourceMap>>,\n     debugging_opts: &DebuggingOptions,\n ) -> rustc_errors::Handler {\n+    let fallback_bundle =\n+        rustc_errors::fallback_fluent_bundle(false).expect(\"failed to load fallback fluent bundle\");\n     let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n         ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n             Box::new(\n                 EmitterWriter::stderr(\n                     color_config,\n                     source_map.map(|sm| sm as _),\n+                    None,\n+                    fallback_bundle,\n                     short,\n                     debugging_opts.teach,\n                     debugging_opts.terminal_width,\n@@ -166,6 +170,8 @@ crate fn new_handler(\n                 JsonEmitter::stderr(\n                     None,\n                     source_map,\n+                    None,\n+                    fallback_bundle,\n                     pretty,\n                     json_rendered,\n                     debugging_opts.terminal_width,"}, {"sha": "63b744133a2c8da4b9bf538a7208ecf9194bdbcd", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -537,12 +537,31 @@ crate fn make_test(\n             // Any errors in parsing should also appear when the doctest is compiled for real, so just\n             // send all the errors that librustc_ast emits directly into a `Sink` instead of stderr.\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            supports_color =\n-                EmitterWriter::stderr(ColorConfig::Auto, None, false, false, Some(80), false)\n-                    .supports_color();\n-\n-            let emitter =\n-                EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+            let fallback_bundle = rustc_errors::fallback_fluent_bundle(false)\n+                .expect(\"failed to load fallback fluent bundle\");\n+            supports_color = EmitterWriter::stderr(\n+                ColorConfig::Auto,\n+                None,\n+                None,\n+                fallback_bundle.clone(),\n+                false,\n+                false,\n+                Some(80),\n+                false,\n+            )\n+            .supports_color();\n+\n+            let emitter = EmitterWriter::new(\n+                box io::sink(),\n+                None,\n+                None,\n+                fallback_bundle,\n+                false,\n+                false,\n+                false,\n+                None,\n+                false,\n+            );\n \n             // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n             let handler = Handler::with_emitter(false, None, box emitter);"}, {"sha": "465dd523ff4521dcee7e27465ddfc97c497313d1", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -32,7 +32,9 @@ struct SyntaxChecker<'a, 'tcx> {\n impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n     fn check_rust_syntax(&self, item: &clean::Item, dox: &str, code_block: RustCodeBlock) {\n         let buffer = Lrc::new(Lock::new(Buffer::default()));\n-        let emitter = BufferEmitter { buffer: Lrc::clone(&buffer) };\n+        let fallback_bundle = rustc_errors::fallback_fluent_bundle(false)\n+            .expect(\"failed to load fallback fluent bundle\");\n+        let emitter = BufferEmitter { buffer: Lrc::clone(&buffer), fallback_bundle };\n \n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let handler = Handler::with_emitter(false, None, Box::new(emitter));\n@@ -171,12 +173,14 @@ struct Buffer {\n \n struct BufferEmitter {\n     buffer: Lrc<Lock<Buffer>>,\n+    fallback_bundle: Lrc<rustc_errors::FluentBundle>,\n }\n \n impl Emitter for BufferEmitter {\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n         let mut buffer = self.buffer.borrow_mut();\n-        buffer.messages.push(format!(\"error from rustc: {}\", diag.message[0].0));\n+        // FIXME(davidtwco): need to support translation here eventually\n+        buffer.messages.push(format!(\"error from rustc: {}\", diag.message[0].0.expect_str()));\n         if diag.is_error() {\n             buffer.has_errors = true;\n         }\n@@ -185,4 +189,12 @@ impl Emitter for BufferEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+        &self.fallback_bundle\n+    }\n }"}, {"sha": "22a3bf57ecf9679819227c61d13581420ff55dde", "filename": "src/test/run-make/translation/Makefile", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Frun-make%2Ftranslation%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Frun-make%2Ftranslation%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftranslation%2FMakefile?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -0,0 +1,33 @@\n+include ../../run-make-fulldeps/tools.mk\n+\n+# This test uses `ln -s` rather than copying to save testing time, but its\n+# usage doesn't work on Windows.\n+# ignore-windows\n+\n+SYSROOT:=$(shell $(RUSTC) --print sysroot)\n+FAKEROOT=$(TMPDIR)/fakeroot\n+\n+all: normal custom sysroot\n+\n+normal: basic-translation.rs\n+\t$(RUSTC) $< 2>&1 | grep \"struct literal body without path\"\n+\n+custom: basic-translation.rs basic-translation.ftl\n+\t$(RUSTC) $< -Ztranslate-additional-ftl=$(CURDIR)/basic-translation.ftl 2>&1 | grep \"this is a test message\"\n+\n+# Make a local copy of the sysroot and add the custom locale to it.\n+sysroot: basic-translation.rs basic-translation.ftl\n+\tmkdir $(FAKEROOT)\n+\tln -s $(SYSROOT)/* $(FAKEROOT)\n+\trm -f $(FAKEROOT)/lib\n+\tmkdir $(FAKEROOT)/lib\n+\tln -s $(SYSROOT)/lib/* $(FAKEROOT)/lib\n+\trm -f $(FAKEROOT)/lib/rustlib\n+\tmkdir $(FAKEROOT)/lib/rustlib\n+\tln -s $(SYSROOT)/lib/rustlib/* $(FAKEROOT)/lib/rustlib\n+\trm -f $(FAKEROOT)/lib/rustlib/src\n+\tmkdir $(FAKEROOT)/lib/rustlib/src\n+\tln -s $(SYSROOT)/lib/rustlib/src/* $(FAKEROOT)/lib/rustlib/src\n+\tmkdir -p $(FAKEROOT)/share/locale/zh-CN/\n+\tln -s $(CURDIR)/basic-translation.ftl $(FAKEROOT)/share/locale/zh-CN/basic-translation.ftl\n+\t$(RUSTC) $< --sysroot $(FAKEROOT) -Ztranslate-lang=zh-CN 2>&1 | grep \"this is a test message\""}, {"sha": "4681b879cda6a3deb25d9474a2d0efec0e9183cc", "filename": "src/test/run-make/translation/basic-translation.ftl", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Frun-make%2Ftranslation%2Fbasic-translation.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Frun-make%2Ftranslation%2Fbasic-translation.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftranslation%2Fbasic-translation.ftl?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -0,0 +1,2 @@\n+parser-struct-literal-body-without-path = this is a test message\n+    .suggestion = this is a test suggestion"}, {"sha": "b8f5bff315337cba90a3b6a1feebf7efb90c2c03", "filename": "src/test/run-make/translation/basic-translation.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Frun-make%2Ftranslation%2Fbasic-translation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Frun-make%2Ftranslation%2Fbasic-translation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftranslation%2Fbasic-translation.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -0,0 +1,18 @@\n+// Exact error being tested isn't relevant, it just needs to be known that it uses Fluent-backed\n+// diagnostics.\n+\n+struct Foo {\n+    val: (),\n+}\n+\n+fn foo() -> Foo {\n+    val: (),\n+}\n+\n+fn main() {\n+    let x = foo();\n+    x.val == 42;\n+    let x = {\n+        val: (),\n+    };\n+}"}, {"sha": "adec548b39053d340b02d04f4dc108a4a5d0df24", "filename": "src/test/ui-fulldeps/session-derive-errors.rs", "status": "modified", "additions": 260, "deletions": 98, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -11,8 +11,8 @@\n #![crate_type = \"lib\"]\n \n extern crate rustc_span;\n-use rustc_span::Span;\n use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n \n extern crate rustc_macros;\n use rustc_macros::SessionDiagnostic;\n@@ -26,241 +26,403 @@ use rustc_errors::Applicability;\n extern crate rustc_session;\n \n #[derive(SessionDiagnostic)]\n-#[message = \"Hello, world!\"]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"hello-world\")]\n struct Hello {}\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[warning(code = \"E0123\", slug = \"hello-world\")]\n+struct HelloWarn {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[derive(SessionDiagnostic)]` can only be used on structs\n enum SessionDiagnosticOnEnum {\n     Foo,\n     Bar,\n }\n \n #[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n #[error = \"E0123\"]\n-#[label = \"This is in the wrong place\"]\n-//~^ ERROR `#[label = ...]` is not a valid SessionDiagnostic struct attribute\n-struct WrongPlace {}\n+//~^ ERROR `#[error = ...]` is not a valid `SessionDiagnostic` struct attribute\n+struct WrongStructAttrStyle {}\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[nonsense(code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[nonsense(...)]` is not a valid `SessionDiagnostic` struct attribute\n+//~^^ ERROR diagnostic kind not specified\n+//~^^^ ERROR cannot find attribute `nonsense` in this scope\n+struct InvalidStructAttr {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(\"E0123\")]\n+//~^ ERROR `#[error(\"...\")]` is not a valid `SessionDiagnostic` struct attribute\n+//~^^ ERROR `slug` not specified\n+struct InvalidLitNestedAttr {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(nonsense, code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(nonsense)]` is not a valid `SessionDiagnostic` struct attribute\n+struct InvalidNestedStructAttr {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(nonsense(...))]` is not a valid `SessionDiagnostic` struct attribute\n+struct InvalidNestedStructAttr1 {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+struct InvalidNestedStructAttr2 {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+struct InvalidNestedStructAttr3 {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct WrongPlaceField {\n-    #[suggestion = \"this is the wrong kind of attribute\"]\n-//~^ ERROR `#[suggestion = ...]` is not a valid SessionDiagnostic field attribute\n+    #[suggestion = \"bar\"]\n+    //~^ ERROR `#[suggestion = ...]` is not a valid `SessionDiagnostic` field attribute\n     sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[message = \"Hello, world!\"]\n-#[error = \"E0123\"]\n-#[error = \"E0456\"] //~ ERROR `error` specified multiple times\n+#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(code = \"E0456\", slug = \"bar\")] //~ ERROR `error` specified multiple times\n struct ErrorSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-#[message = \"Hello, world!\"]\n-#[error = \"E0123\"]\n-#[lint = \"some_useful_lint\"] //~ ERROR `lint` specified when `error` was already specified\n-struct LintSpecifiedAfterError {}\n+#[error(code = \"E0123\", slug = \"foo\")]\n+#[warning(code = \"E0293\", slug = \"bar\")]\n+//~^ ERROR `warning` specified when `error` was already specified\n+struct WarnSpecifiedAfterError {}\n \n #[derive(SessionDiagnostic)]\n-#[message = \"Some lint message\"]\n-#[error = \"E0123\"]\n-struct LintButHasErrorCode {}\n+#[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")] //~ ERROR `code` specified multiple times\n+struct CodeSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-struct ErrorCodeNotProvided {} //~ ERROR `code` not specified\n+#[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")] //~ ERROR `slug` specified multiple times\n+struct SlugSpecifiedTwice {}\n \n-// FIXME: Uncomment when emitting lints is supported.\n-/*\n #[derive(SessionDiagnostic)]\n-#[message = \"Hello, world!\"]\n-#[lint = \"clashing_extern_declarations\"]\n-#[lint = \"improper_ctypes\"] // FIXME: ERROR `lint` specified multiple times\n-struct LintSpecifiedTwice {}\n+struct KindNotProvided {} //~ ERROR diagnostic kind not specified\n \n #[derive(SessionDiagnostic)]\n-#[lint = \"Some lint message\"]\n-#[message = \"Some error message\"]\n-#[error = \"E0123\"] // ERROR `error` specified when `lint` was already specified\n-struct ErrorSpecifiedAfterLint {}\n-*/\n+#[error(code = \"E0456\")] //~ ERROR `slug` not specified\n+struct SlugNotProvided {}\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(slug = \"foo\")]\n+struct CodeNotProvided {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct MessageWrongType {\n+    #[primary_span]\n+    //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    foo: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct InvalidPathFieldAttr {\n+    #[nonsense]\n+    //~^ ERROR `#[nonsense]` is not a valid `SessionDiagnostic` field attribute\n+    //~^^ ERROR cannot find attribute `nonsense` in this scope\n+    foo: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorWithField {\n     name: String,\n-    #[message = \"This error has a field, and references {name}\"]\n-    span: Span\n+    #[label = \"bar\"]\n+    span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorWithMessageAppliedToField {\n-    #[message = \"this message is applied to a String field\"]\n-    //~^ ERROR the `#[message = \"...\"]` attribute can only be applied to fields of type Span\n+    #[label = \"bar\"]\n+    //~^ ERROR the `#[label = ...]` attribute can only be applied to fields of type `Span`\n     name: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"This error has a field, and references {name}\"]\n-//~^ ERROR `name` doesn't refer to a field on this type\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorWithNonexistentField {\n-    span: Span\n+    #[suggestion(message = \"bar\", code = \"{name}\")]\n+    //~^ ERROR `name` doesn't refer to a field on this type\n+    suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"This is missing a closing brace: {name\"]\n //~^ ERROR invalid format string: expected `'}'`\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorMissingClosingBrace {\n+    #[suggestion(message = \"bar\", code = \"{name\")]\n+    suggestion: (Span, Applicability),\n     name: String,\n-    span: Span\n+    val: usize,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"This is missing an opening brace: name}\"]\n //~^ ERROR invalid format string: unmatched `}`\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorMissingOpeningBrace {\n+    #[suggestion(message = \"bar\", code = \"name}\")]\n+    suggestion: (Span, Applicability),\n     name: String,\n-    span: Span\n+    val: usize,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"Something something\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct LabelOnSpan {\n-    #[label = \"See here\"]\n-    sp: Span\n+    #[label = \"bar\"]\n+    sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"Something something\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct LabelOnNonSpan {\n-    #[label = \"See here\"]\n-    //~^ ERROR The `#[label = ...]` attribute can only be applied to fields of type Span\n+    #[label = \"bar\"]\n+    //~^ ERROR the `#[label = ...]` attribute can only be applied to fields of type `Span`\n     id: u32,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct Suggest {\n-    #[suggestion(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n-    #[suggestion_short(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n-    #[suggestion_hidden(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n-    #[suggestion_verbose(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    #[suggestion(message = \"bar\", code = \"This is the suggested code\")]\n+    #[suggestion_short(message = \"qux\", code = \"This is the suggested code\")]\n+    #[suggestion_hidden(message = \"foobar\", code = \"This is the suggested code\")]\n+    #[suggestion_verbose(message = \"fooqux\", code = \"This is the suggested code\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithoutCode {\n-    #[suggestion(message = \"This is a suggestion\")]\n+    #[suggestion(message = \"bar\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithBadKey {\n-    #[suggestion(nonsense = \"This is nonsense\")]\n-    //~^ ERROR `nonsense` is not a valid key for `#[suggestion(...)]`\n+    #[suggestion(nonsense = \"bar\")]\n+    //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid `SessionDiagnostic` field attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithShorthandMsg {\n-    #[suggestion(msg = \"This is a suggestion\")]\n-    //~^ ERROR `msg` is not a valid key for `#[suggestion(...)]`\n+    #[suggestion(msg = \"bar\")]\n+    //~^ ERROR `#[suggestion(msg = ...)]` is not a valid `SessionDiagnostic` field attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithoutMsg {\n-    #[suggestion(code = \"This is suggested code\")]\n-    //~^ ERROR missing suggestion message\n+    #[suggestion(code = \"bar\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithTypesSwapped {\n-    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n     suggestion: (Applicability, Span),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithWrongTypeApplicabilityOnly {\n-    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n     //~^ ERROR wrong field type for suggestion\n     suggestion: Applicability,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-struct SuggestWithSpanOnly{\n-    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct SuggestWithSpanOnly {\n+    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n     suggestion: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithDuplicateSpanAndApplicability {\n-    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n-    //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one Span\n+    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n     suggestion: (Span, Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithDuplicateApplicabilityAndSpan {\n-    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n     //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one\n     suggestion: (Applicability, Applicability, Span),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct WrongKindOfAnnotation {\n-    #[label(\"wrong kind of annotation for label\")]\n-    //~^ ERROR invalid annotation list `#[label(...)]`\n+    #[label(\"bar\")]\n+    //~^ ERROR `#[label(...)]` is not a valid `SessionDiagnostic` field attribute\n     z: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"Something something else\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct OptionsInErrors {\n-    #[label = \"Label message\"]\n+    #[label = \"bar\"]\n     label: Option<Span>,\n-    #[suggestion(message = \"suggestion message\")]\n+    #[suggestion(message = \"bar\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0456\"]\n+#[error(code = \"E0456\", slug = \"foo\")]\n struct MoveOutOfBorrowError<'tcx> {\n     name: Ident,\n     ty: Ty<'tcx>,\n-    #[message = \"cannot move {ty} out of borrow\"]\n-    #[label = \"cannot move out of borrow\"]\n+    #[primary_span]\n+    #[label = \"bar\"]\n     span: Span,\n-    #[label = \"`{ty}` first borrowed here\"]\n+    #[label = \"qux\"]\n     other_span: Span,\n-    #[suggestion(message = \"consider cloning here\", code = \"{name}.clone()\")]\n+    #[suggestion(message = \"bar\", code = \"{name}.clone()\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorWithLifetime<'a> {\n-    #[message = \"Some message that references {name}\"]\n+    #[label = \"bar\"]\n     span: Span,\n     name: &'a str,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithDefaultLabelAttr<'a> {\n+    #[label]\n+    span: Span,\n+    name: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+//~^ ERROR no method named `into_diagnostic_arg` found for struct `Hello` in the current scope\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ArgFieldWithoutSkip {\n+    #[primary_span]\n+    span: Span,\n+    other: Hello,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ArgFieldWithSkip {\n+    #[primary_span]\n+    span: Span,\n+    // `Hello` does not implement `IntoDiagnosticArg` so this would result in an error if\n+    // not for `#[skip_arg]`.\n+    #[skip_arg]\n+    other: Hello,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithSpannedNote {\n+    #[note]\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithSpannedNoteCustom {\n+    #[note = \"bar\"]\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+#[note]\n+struct ErrorWithNote {\n+    val: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+#[note = \"bar\"]\n+struct ErrorWithNoteCustom {\n+    val: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithSpannedHelp {\n+    #[help]\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithSpannedHelpCustom {\n+    #[help = \"bar\"]\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+#[help]\n+struct ErrorWithHelp {\n+    val: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+#[help = \"bar\"]\n+struct ErrorWithHelpCustom {\n+    val: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[help]\n+//~^ ERROR `#[help]` must come after `#[error(..)]` or `#[warn(..)]`\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithHelpWrongOrder {\n+    val: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[help = \"bar\"]\n+//~^ ERROR `#[help = ...]` must come after `#[error(..)]` or `#[warn(..)]`\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithHelpCustomWrongOrder {\n+    val: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[note]\n+//~^ ERROR `#[note]` must come after `#[error(..)]` or `#[warn(..)]`\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithNoteWrongOrder {\n+    val: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[note = \"bar\"]\n+//~^ ERROR `#[note = ...]` must come after `#[error(..)]` or `#[warn(..)]`\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ErrorWithNoteCustomWrongOrder {\n+    val: String,\n+}"}, {"sha": "a528ae1607fbaba618d955f3cdcbf8b83435c4d5", "filename": "src/test/ui-fulldeps/session-derive-errors.stderr", "status": "modified", "additions": 226, "deletions": 73, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -1,140 +1,293 @@\n error: `#[derive(SessionDiagnostic)]` can only be used on structs\n-  --> $DIR/session-derive-errors.rs:34:1\n+  --> $DIR/session-derive-errors.rs:37:1\n    |\n-LL | / #[error = \"E0123\"]\n+LL | / #[error(code = \"E0123\", slug = \"foo\")]\n LL | |\n LL | | enum SessionDiagnosticOnEnum {\n LL | |     Foo,\n LL | |     Bar,\n LL | | }\n    | |_^\n \n-error: `#[label = ...]` is not a valid SessionDiagnostic struct attribute\n-  --> $DIR/session-derive-errors.rs:43:1\n+error: `#[error = ...]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:46:1\n    |\n-LL | #[label = \"This is in the wrong place\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error = \"E0123\"]\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: `#[nonsense(...)]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:51:1\n+   |\n+LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: diagnostic kind not specified\n+  --> $DIR/session-derive-errors.rs:51:1\n+   |\n+LL | / #[nonsense(code = \"E0123\", slug = \"foo\")]\n+LL | |\n+LL | |\n+LL | |\n+LL | | struct InvalidStructAttr {}\n+   | |___________________________^\n+   |\n+   = help: use the `#[error(...)]` attribute to create an error\n+\n+error: `#[error(\"...\")]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:58:9\n+   |\n+LL | #[error(\"E0123\")]\n+   |         ^^^^^^^\n+\n+error: `slug` not specified\n+  --> $DIR/session-derive-errors.rs:58:1\n+   |\n+LL | / #[error(\"E0123\")]\n+LL | |\n+LL | |\n+LL | | struct InvalidLitNestedAttr {}\n+   | |______________________________^\n+   |\n+   = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n+\n+error: `#[error(nonsense)]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:64:9\n+   |\n+LL | #[error(nonsense, code = \"E0123\", slug = \"foo\")]\n+   |         ^^^^^^^^\n+\n+error: `#[error(nonsense(...))]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:69:9\n+   |\n+LL | #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n+   |         ^^^^^^^^^^^^^^^\n+\n+error: `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:74:9\n+   |\n+LL | #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n+   |         ^^^^^^^^^^^^^^^^\n \n-error: `#[suggestion = ...]` is not a valid SessionDiagnostic field attribute\n-  --> $DIR/session-derive-errors.rs:50:5\n+error: `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:79:9\n    |\n-LL |     #[suggestion = \"this is the wrong kind of attribute\"]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n+   |         ^^^^^^^^^^^^\n+   |\n+   = help: value must be a string\n+\n+error: `#[suggestion = ...]` is not a valid `SessionDiagnostic` field attribute\n+  --> $DIR/session-derive-errors.rs:86:5\n+   |\n+LL |     #[suggestion = \"bar\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: `error` specified multiple times\n-  --> $DIR/session-derive-errors.rs:58:11\n+  --> $DIR/session-derive-errors.rs:93:1\n+   |\n+LL | #[error(code = \"E0456\", slug = \"bar\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/session-derive-errors.rs:92:1\n+   |\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `warning` specified when `error` was already specified\n+  --> $DIR/session-derive-errors.rs:98:1\n+   |\n+LL | #[warning(code = \"E0293\", slug = \"bar\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/session-derive-errors.rs:97:1\n+   |\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `code` specified multiple times\n+  --> $DIR/session-derive-errors.rs:103:32\n    |\n-LL | #[error = \"E0456\"]\n-   |           ^^^^^^^\n+LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n+   |                                ^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/session-derive-errors.rs:103:16\n+   |\n+LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n+   |                ^^^^^^^\n \n-error: `lint` specified when `error` was already specified\n-  --> $DIR/session-derive-errors.rs:64:10\n+error: `slug` specified multiple times\n+  --> $DIR/session-derive-errors.rs:107:46\n+   |\n+LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n+   |                                              ^^^^^\n    |\n-LL | #[lint = \"some_useful_lint\"]\n-   |          ^^^^^^^^^^^^^^^^^^\n+note: previously specified here\n+  --> $DIR/session-derive-errors.rs:107:32\n+   |\n+LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n+   |                                ^^^^^\n \n-error: `code` not specified\n-  --> $DIR/session-derive-errors.rs:73:1\n+error: diagnostic kind not specified\n+  --> $DIR/session-derive-errors.rs:111:1\n+   |\n+LL | struct KindNotProvided {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | struct ErrorCodeNotProvided {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use the `#[error(...)]` attribute to create an error\n+\n+error: `slug` not specified\n+  --> $DIR/session-derive-errors.rs:114:1\n+   |\n+LL | / #[error(code = \"E0456\")]\n+LL | | struct SlugNotProvided {}\n+   | |_________________________^\n+   |\n+   = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n+\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/session-derive-errors.rs:124:5\n    |\n-   = help: use the [code = \"...\"] attribute to set this diagnostic's error code \n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n \n-error: the `#[message = \"...\"]` attribute can only be applied to fields of type Span\n-  --> $DIR/session-derive-errors.rs:101:5\n+error: `#[nonsense]` is not a valid `SessionDiagnostic` field attribute\n+  --> $DIR/session-derive-errors.rs:132:5\n    |\n-LL |     #[message = \"this message is applied to a String field\"]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[nonsense]\n+   |     ^^^^^^^^^^^\n+\n+error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/session-derive-errors.rs:149:5\n+   |\n+LL |     #[label = \"bar\"]\n+   |     ^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/session-derive-errors.rs:108:1\n+  --> $DIR/session-derive-errors.rs:157:42\n    |\n-LL | #[message = \"This error has a field, and references {name}\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(message = \"bar\", code = \"{name}\")]\n+   |                                          ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/session-derive-errors.rs:116:1\n+  --> $DIR/session-derive-errors.rs:162:16\n    |\n LL | #[derive(SessionDiagnostic)]\n-   |          ----------------- in this derive macro expansion\n-LL | #[error = \"E0123\"]\n-   |               - because of this opening brace\n-LL | #[message = \"This is missing a closing brace: {name\"]\n-   | ^ expected `'}'` in format string\n+   |           -    ^ expected `'}'` in format string\n+   |           |\n+   |           because of this opening brace\n    |\n    = note: if you intended to print `{`, you can escape it using `{{`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/session-derive-errors.rs:125:1\n+  --> $DIR/session-derive-errors.rs:172:15\n    |\n LL | #[derive(SessionDiagnostic)]\n-   |          ----------------- in this derive macro expansion\n-LL | #[error = \"E0123\"]\n-LL | #[message = \"This is missing an opening brace: name}\"]\n-   | ^ unmatched `}` in format string\n+   |               ^ unmatched `}` in format string\n    |\n    = note: if you intended to print `}`, you can escape it using `}}`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: The `#[label = ...]` attribute can only be applied to fields of type Span\n-  --> $DIR/session-derive-errors.rs:144:5\n+error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/session-derive-errors.rs:192:5\n    |\n-LL |     #[label = \"See here\"]\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n-\n-error: `nonsense` is not a valid key for `#[suggestion(...)]`\n-  --> $DIR/session-derive-errors.rs:169:18\n-   |\n-LL |     #[suggestion(nonsense = \"This is nonsense\")]\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label = \"bar\"]\n+   |     ^^^^^^^^^^^^^^^^\n \n-error: `msg` is not a valid key for `#[suggestion(...)]`\n-  --> $DIR/session-derive-errors.rs:177:18\n+error: `#[suggestion(nonsense = ...)]` is not a valid `SessionDiagnostic` field attribute\n+  --> $DIR/session-derive-errors.rs:217:18\n    |\n-LL |     #[suggestion(msg = \"This is a suggestion\")]\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(nonsense = \"bar\")]\n+   |                  ^^^^^^^^^^^^^^^^\n \n-error: missing suggestion message\n-  --> $DIR/session-derive-errors.rs:185:7\n-   |\n-LL |     #[suggestion(code = \"This is suggested code\")]\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+error: `#[suggestion(msg = ...)]` is not a valid `SessionDiagnostic` field attribute\n+  --> $DIR/session-derive-errors.rs:225:18\n    |\n-   = help: provide a suggestion message using #[suggestion(message = \"...\")]\n+LL |     #[suggestion(msg = \"bar\")]\n+   |                  ^^^^^^^^^^^\n \n error: wrong field type for suggestion\n-  --> $DIR/session-derive-errors.rs:200:5\n+  --> $DIR/session-derive-errors.rs:247:5\n    |\n-LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: Applicability,\n    | |_____________________________^\n    |\n-   = help: #[suggestion(...)] should be applied to fields of type Span or (Span, Applicability)\n+   = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n-error: type of field annotated with `#[suggestion(...)]` contains more than one Span\n-  --> $DIR/session-derive-errors.rs:215:5\n+error: type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n+  --> $DIR/session-derive-errors.rs:262:5\n    |\n-LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Span, Span, Applicability),\n    | |___________________________________________^\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n-  --> $DIR/session-derive-errors.rs:223:5\n+  --> $DIR/session-derive-errors.rs:270:5\n    |\n-LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Applicability, Applicability, Span),\n    | |____________________________________________________^\n \n-error: invalid annotation list `#[label(...)]`\n-  --> $DIR/session-derive-errors.rs:231:7\n+error: `#[label(...)]` is not a valid `SessionDiagnostic` field attribute\n+  --> $DIR/session-derive-errors.rs:278:5\n    |\n-LL |     #[label(\"wrong kind of annotation for label\")]\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label(\"bar\")]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: `#[help]` must come after `#[error(..)]` or `#[warn(..)]`\n+  --> $DIR/session-derive-errors.rs:399:1\n+   |\n+LL | #[help]\n+   | ^^^^^^^\n+\n+error: `#[help = ...]` must come after `#[error(..)]` or `#[warn(..)]`\n+  --> $DIR/session-derive-errors.rs:407:1\n+   |\n+LL | #[help = \"bar\"]\n+   | ^^^^^^^^^^^^^^^\n+\n+error: `#[note]` must come after `#[error(..)]` or `#[warn(..)]`\n+  --> $DIR/session-derive-errors.rs:415:1\n+   |\n+LL | #[note]\n+   | ^^^^^^^\n+\n+error: `#[note = ...]` must come after `#[error(..)]` or `#[warn(..)]`\n+  --> $DIR/session-derive-errors.rs:423:1\n+   |\n+LL | #[note = \"bar\"]\n+   | ^^^^^^^^^^^^^^^\n+\n+error: cannot find attribute `nonsense` in this scope\n+  --> $DIR/session-derive-errors.rs:51:3\n+   |\n+LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n+   |   ^^^^^^^^\n+\n+error: cannot find attribute `nonsense` in this scope\n+  --> $DIR/session-derive-errors.rs:132:7\n+   |\n+LL |     #[nonsense]\n+   |       ^^^^^^^^\n+\n+error[E0599]: no method named `into_diagnostic_arg` found for struct `Hello` in the current scope\n+  --> $DIR/session-derive-errors.rs:322:10\n+   |\n+LL | struct Hello {}\n+   | ------------ method `into_diagnostic_arg` not found for this\n+...\n+LL | #[derive(SessionDiagnostic)]\n+   |          ^^^^^^^^^^^^^^^^^ method not found in `Hello`\n+   |\n+   = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 37 previous errors\n \n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "bb3017b6ec26adad6984cbc7e8d9c1fb1ec1bc79", "filename": "src/test/ui/error-codes/E0184.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Fui%2Ferror-codes%2FE0184.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Fui%2Ferror-codes%2FE0184.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0184.stderr?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -2,7 +2,7 @@ error[E0184]: the trait `Copy` may not be implemented for this type; the type ha\n   --> $DIR/E0184.rs:1:10\n    |\n LL | #[derive(Copy)]\n-   |          ^^^^ Copy not allowed on types with destructors\n+   |          ^^^^ `Copy` not allowed on types with destructors\n    |\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "8649c8abbfa7f9035ef618bb3e0d30cb88a8ebaa", "filename": "src/test/ui/exclusive-drop-and-copy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Fui%2Fexclusive-drop-and-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftest%2Fui%2Fexclusive-drop-and-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-drop-and-copy.stderr?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -2,15 +2,15 @@ error[E0184]: the trait `Copy` may not be implemented for this type; the type ha\n   --> $DIR/exclusive-drop-and-copy.rs:3:10\n    |\n LL | #[derive(Copy, Clone)]\n-   |          ^^^^ Copy not allowed on types with destructors\n+   |          ^^^^ `Copy` not allowed on types with destructors\n    |\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor\n   --> $DIR/exclusive-drop-and-copy.rs:10:10\n    |\n LL | #[derive(Copy, Clone)]\n-   |          ^^^^ Copy not allowed on types with destructors\n+   |          ^^^^ `Copy` not allowed on types with destructors\n    |\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "cc354b50afa39faa68159d1d16ae8027ff8f5658", "filename": "src/tools/clippy/clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -3,11 +3,12 @@ use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n+use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{Arm, Expr, Guard, HirId, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -129,8 +130,8 @@ fn check_arm<'tcx>(\n                 &msg,\n                 |diag| {\n                     let mut help_span = MultiSpan::from_spans(vec![binding_span, inner_then_pat.span]);\n-                    help_span.push_span_label(binding_span, \"replace this binding\".into());\n-                    help_span.push_span_label(inner_then_pat.span, \"with this pattern\".into());\n+                    help_span.push_span_label(binding_span, \"replace this binding\");\n+                    help_span.push_span_label(inner_then_pat.span, \"with this pattern\");\n                     diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n                 },\n             );"}, {"sha": "92cf82bcd6a34bf314df7c35824f6c4e8b7189ff", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::token::CommentKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::EmitterWriter;\n-use rustc_errors::{Applicability, Handler, SuggestionStyle};\n+use rustc_errors::{Applicability, Handler, MultiSpan, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AnonConst, Expr};\n@@ -25,7 +25,7 @@ use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::edition::Edition;\n-use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n+use rustc_span::source_map::{BytePos, FilePathMapping, SourceMap, Span};\n use rustc_span::{sym, FileName, Pos};\n use std::io;\n use std::ops::Range;\n@@ -621,7 +621,19 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 let filename = FileName::anon_source_code(&code);\n \n                 let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-                let emitter = EmitterWriter::new(Box::new(io::sink()), None, false, false, false, None, false);\n+                let fallback_bundle = rustc_errors::fallback_fluent_bundle(false)\n+                    .expect(\"failed to load fallback fluent bundle\");\n+                let emitter = EmitterWriter::new(\n+                    Box::new(io::sink()),\n+                    None,\n+                    None,\n+                    fallback_bundle,\n+                    false,\n+                    false,\n+                    false,\n+                    None,\n+                    false,\n+                );\n                 let handler = Handler::with_emitter(false, None, Box::new(emitter));\n                 let sess = ParseSess::with_span_handler(handler, sm);\n "}, {"sha": "ddaffc751880db30251f01d8c246af8c9d8568d6", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -6,15 +6,15 @@ use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local, path_to_local_id, CaptureKind};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::sym;\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n@@ -102,7 +102,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n \n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n                     let mut span = MultiSpan::from_span(method_name.ident.span);\n-                    span.push_span_label(iter_call.span, \"the iterator could be used here instead\".into());\n+                    span.push_span_label(iter_call.span, \"the iterator could be used here instead\");\n                     span_lint_hir_and_then(\n                         cx,\n                         super::NEEDLESS_COLLECT,"}, {"sha": "06209bfe7b08ada6cb6dc2f349d6cbe95decab2a", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n \n         if let Err((span, err)) = is_min_const_fn(cx.tcx, mir, self.msrv.as_ref()) {\n             if cx.tcx.is_const_fn_raw(def_id.to_def_id()) {\n-                cx.tcx.sess.span_err(span, &err);\n+                cx.tcx.sess.span_err(span, err.as_ref());\n             }\n         } else {\n             span_lint(cx, MISSING_CONST_FOR_FN, span, \"this could be a `const fn`\");"}, {"sha": "d29d07da7b0ffdcc8aa85a28443b6d8f1623357f", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -235,11 +235,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                 for (span, suggestion) in clone_spans {\n                                     diag.span_suggestion(\n                                         span,\n-                                        &snippet_opt(cx, span)\n+                                        snippet_opt(cx, span)\n                                             .map_or(\n                                                 \"change the call to\".into(),\n                                                 |x| Cow::from(format!(\"change `{}` to\", x)),\n-                                            ),\n+                                            )\n+                                            .as_ref(),\n                                         suggestion.into(),\n                                         Applicability::Unspecified,\n                                     );\n@@ -264,11 +265,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                 for (span, suggestion) in clone_spans {\n                                     diag.span_suggestion(\n                                         span,\n-                                        &snippet_opt(cx, span)\n+                                        snippet_opt(cx, span)\n                                             .map_or(\n                                                 \"change the call to\".into(),\n                                                 |x| Cow::from(format!(\"change `{}` to\", x))\n-                                            ),\n+                                            )\n+                                            .as_ref(),\n                                         suggestion.into(),\n                                         Applicability::Unspecified,\n                                     );"}, {"sha": "5f453dc16555874f783fd6de9d8d54e462b8edb3", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::expr_sig;\n use clippy_utils::{get_expr_use_or_unification_node, is_lint_allowed, path_def_id, path_to_local, paths};\n use if_chain::if_chain;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdMap;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n@@ -19,8 +19,8 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{sym, MultiSpan};\n use std::fmt;\n use std::iter;\n "}, {"sha": "b142397f71b9c101b6dde6564dbbe93d512624d6", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -8,10 +8,10 @@\n //! Thank you!\n //! ~The `INTERNAL_METADATA_COLLECTOR` lint\n \n-use rustc_errors::{emitter::MAX_SUGGESTION_HIGHLIGHT_LINES, Applicability, Diagnostic};\n+use rustc_errors::{emitter::MAX_SUGGESTION_HIGHLIGHT_LINES, Applicability, Diagnostic, MultiSpan};\n use rustc_hir::HirId;\n use rustc_lint::{LateContext, Lint, LintContext};\n-use rustc_span::source_map::{MultiSpan, Span};\n+use rustc_span::source_map::Span;\n use std::env;\n \n fn docs_link(diag: &mut Diagnostic, lint: &'static Lint) {\n@@ -155,7 +155,13 @@ where\n     });\n }\n \n-pub fn span_lint_hir(cx: &LateContext<'_>, lint: &'static Lint, hir_id: HirId, sp: Span, msg: &str) {\n+pub fn span_lint_hir(\n+    cx: &LateContext<'_>,\n+    lint: &'static Lint,\n+    hir_id: HirId,\n+    sp: Span,\n+    msg: &str,\n+) {\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |diag| {\n         let mut diag = diag.build(msg);\n         docs_link(&mut diag, lint);\n@@ -272,9 +278,14 @@ pub fn span_lint_and_sugg_for_edges(\n         let sugg_lines_count = sugg.lines().count();\n         if sugg_lines_count > MAX_SUGGESTION_HIGHLIGHT_LINES {\n             let sm = cx.sess().source_map();\n-            if let (Ok(line_upper), Ok(line_bottom)) = (sm.lookup_line(sp.lo()), sm.lookup_line(sp.hi())) {\n+            if let (Ok(line_upper), Ok(line_bottom)) =\n+                (sm.lookup_line(sp.lo()), sm.lookup_line(sp.hi()))\n+            {\n                 let split_idx = MAX_SUGGESTION_HIGHLIGHT_LINES / 2;\n-                let span_upper = sm.span_until_char(sp.with_hi(line_upper.sf.lines[line_upper.line + split_idx]), '\\n');\n+                let span_upper = sm.span_until_char(\n+                    sp.with_hi(line_upper.sf.lines[line_upper.line + split_idx]),\n+                    '\\n',\n+                );\n                 let span_bottom = sp.with_lo(line_bottom.sf.lines[line_bottom.line - split_idx]);\n \n                 let sugg_lines_vec = sugg.lines().collect::<Vec<&str>>();"}, {"sha": "bc1b0d7457559da68ddfdf3f964ed6f59018551e", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -165,9 +165,13 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // Separate the output with an empty line\n     eprintln!();\n \n+    let fallback_bundle = rustc_errors::fallback_fluent_bundle(false)\n+        .expect(\"failed to load fallback fluent bundle\");\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n         rustc_errors::ColorConfig::Auto,\n         None,\n+        None,\n+        fallback_bundle,\n         false,\n         false,\n         None,\n@@ -191,7 +195,7 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     ];\n \n     for note in &xs {\n-        handler.note_without_error(note);\n+        handler.note_without_error(note.as_ref());\n     }\n \n     // If backtraces are enabled, also print the query stack"}, {"sha": "7125b2ee6859bc1d06aaa3ba3e25484461d6082b", "filename": "src/tools/rustfmt/src/parse/session.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -33,6 +33,12 @@ impl Emitter for SilentEmitter {\n         None\n     }\n     fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+    fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+        panic!(\"silent emitter attempted to translate a diagnostic\");\n+    }\n }\n \n fn silent_emitter() -> Box<dyn Emitter + Send> {\n@@ -82,6 +88,14 @@ impl Emitter for SilentOnIgnoredFilesEmitter {\n         }\n         self.handle_non_ignoreable_error(db);\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        self.emitter.fluent_bundle()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+        self.emitter.fallback_fluent_bundle()\n+    }\n }\n \n fn default_handler(\n@@ -100,9 +114,13 @@ fn default_handler(\n     let emitter = if hide_parse_errors {\n         silent_emitter()\n     } else {\n+        let fallback_bundle = rustc_errors::fallback_fluent_bundle(false)\n+            .expect(\"failed to load fallback fluent bundle\");\n         Box::new(EmitterWriter::stderr(\n             color_cfg,\n             Some(source_map.clone()),\n+            None,\n+            fallback_bundle,\n             false,\n             false,\n             None,\n@@ -313,7 +331,8 @@ mod tests {\n         use super::*;\n         use crate::config::IgnoreList;\n         use crate::utils::mk_sp;\n-        use rustc_span::{FileName as SourceMapFileName, MultiSpan, RealFileName};\n+        use rustc_errors::MultiSpan;\n+        use rustc_span::{FileName as SourceMapFileName, RealFileName};\n         use std::path::PathBuf;\n         use std::sync::atomic::AtomicU32;\n \n@@ -328,6 +347,12 @@ mod tests {\n             fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n                 self.num_emitted_errors.fetch_add(1, Ordering::Release);\n             }\n+            fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+                None\n+            }\n+            fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+                panic!(\"test emitter attempted to translate a diagnostic\");\n+            }\n         }\n \n         fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {"}, {"sha": "ea6e01e577c6bfd3fa56740ce8d72c1a9a1a42ef", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4730244d7be72b2c1f0e528bb3c41a91ebdf924/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=d4730244d7be72b2c1f0e528bb3c41a91ebdf924", "patch": "@@ -38,6 +38,8 @@ const EXCEPTIONS: &[(&str, &str)] = &[\n     (\"bitmaps\", \"MPL-2.0+\"),          // cargo via im-rc\n     (\"instant\", \"BSD-3-Clause\"),      // rustc_driver/tracing-subscriber/parking_lot\n     (\"snap\", \"BSD-3-Clause\"),         // rustc\n+    (\"fluent-langneg\", \"Apache-2.0\"), // rustc (fluent translations)\n+    (\"self_cell\", \"Apache-2.0\"),      // rustc (fluent translations)\n     // FIXME: this dependency violates the documentation comment above:\n     (\"fortanix-sgx-abi\", \"MPL-2.0\"), // libstd but only for `sgx` target\n ];\n@@ -113,6 +115,9 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"filetime\",\n     \"fixedbitset\",\n     \"flate2\",\n+    \"fluent-bundle\",\n+    \"fluent-langneg\",\n+    \"fluent-syntax\",\n     \"fortanix-sgx-abi\",\n     \"generic-array\",\n     \"getopts\",\n@@ -125,6 +130,8 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"if_chain\",\n     \"indexmap\",\n     \"instant\",\n+    \"intl-memoizer\",\n+    \"intl_pluralrules\",\n     \"itertools\",\n     \"itoa\",\n     \"jobserver\",\n@@ -157,6 +164,7 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"pkg-config\",\n     \"polonius-engine\",\n     \"ppv-lite86\",\n+    \"proc-macro-hack\",\n     \"proc-macro2\",\n     \"psm\",\n     \"punycode\",\n@@ -184,6 +192,7 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"ryu\",\n     \"scoped-tls\",\n     \"scopeguard\",\n+    \"self_cell\",\n     \"semver\",\n     \"serde\",\n     \"serde_derive\",\n@@ -200,21 +209,29 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"tempfile\",\n     \"termcolor\",\n     \"termize\",\n+    \"thiserror\",\n+    \"thiserror-impl\",\n     \"thorin-dwp\",\n     \"thread_local\",\n     \"time\",\n+    \"tinystr\",\n     \"tinyvec\",\n     \"tracing\",\n     \"tracing-attributes\",\n     \"tracing-core\",\n     \"tracing-log\",\n     \"tracing-subscriber\",\n     \"tracing-tree\",\n+    \"type-map\",\n     \"typenum\",\n     \"unic-char-property\",\n     \"unic-char-range\",\n     \"unic-common\",\n     \"unic-emoji-char\",\n+    \"unic-langid\",\n+    \"unic-langid-impl\",\n+    \"unic-langid-macros\",\n+    \"unic-langid-macros-impl\",\n     \"unic-ucd-version\",\n     \"unicode-normalization\",\n     \"unicode-script\",\n@@ -228,7 +245,8 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-util\",\n     \"winapi-x86_64-pc-windows-gnu\",\n-    // this is a false-positive: it's only used by rustfmt, but because it's enabled through a feature, tidy thinks it's used by rustc as well.\n+    // this is a false-positive: it's only used by rustfmt, but because it's enabled through a\n+    // feature, tidy thinks it's used by rustc as well.\n     \"yansi-term\",\n ];\n "}]}