{"sha": "2987785df3d46d5ff144a5c67fbb8f5cca798d78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ODc3ODVkZjNkNDZkNWZmMTQ0YTVjNjdmYmI4ZjVjY2E3OThkNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-28T15:57:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-28T15:57:50Z"}, "message": "Auto merge of #80439 - Dylan-DPC:rollup-rdxcvon, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #79662 (Move some more code out of CodegenBackend::{codegen_crate,link})\n - #79815 (Update RELEASES.md for 1.49.0)\n - #80284 (Suggest fn ptr rather than fn item and suggest to use `Fn` trait bounds rather than the unique closure type in E0121)\n - #80331 (Add more comments to trait queries)\n - #80344 (use matches!() macro in more places)\n - #80353 (BTreeMap: test split_off (and append) more thoroughly)\n - #80362 (Document rustc_macros on nightly-rustc)\n - #80399 (Remove FIXME in rustc_privacy)\n - #80408 (Sync rustc_codegen_cranelift)\n - #80411 (rustc_span: Remove `Symbol::with`)\n - #80434 (bootstrap: put the component name in the tarball temp dir path)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bc371b2306dc81420d2549802d22d78510948fd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc371b2306dc81420d2549802d22d78510948fd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2987785df3d46d5ff144a5c67fbb8f5cca798d78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2987785df3d46d5ff144a5c67fbb8f5cca798d78", "html_url": "https://github.com/rust-lang/rust/commit/2987785df3d46d5ff144a5c67fbb8f5cca798d78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2987785df3d46d5ff144a5c67fbb8f5cca798d78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76aca6659a0eb3f5696541d0be518530cabdd963", "url": "https://api.github.com/repos/rust-lang/rust/commits/76aca6659a0eb3f5696541d0be518530cabdd963", "html_url": "https://github.com/rust-lang/rust/commit/76aca6659a0eb3f5696541d0be518530cabdd963"}, {"sha": "a4a59a0f17dae56b5401ff9a2385742c4add2956", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a59a0f17dae56b5401ff9a2385742c4add2956", "html_url": "https://github.com/rust-lang/rust/commit/a4a59a0f17dae56b5401ff9a2385742c4add2956"}], "stats": {"total": 1566, "additions": 943, "deletions": 623}, "files": [{"sha": "8f04980e390367dcf5bb9c187f710a00ead0d819", "filename": "RELEASES.md", "status": "modified", "additions": 131, "deletions": 3, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1,3 +1,131 @@\n+Version 1.49.0 (2020-12-31)\n+============================\n+\n+Language\n+-----------------------\n+\n+- [Unions can now implement `Drop`, and you can now have a field in a union\n+  with `ManuallyDrop<T>`.][77547]\n+- [You can now cast uninhabited enums to integers.][76199]\n+- [You can now bind by reference and by move in patterns.][76119] This\n+  allows you to selectively borrow individual components of a type. E.g.\n+  ```rust\n+  #[derive(Debug)]\n+  struct Person {\n+      name: String,\n+      age: u8,\n+  }\n+\n+  let person = Person {\n+      name: String::from(\"Alice\"),\n+      age: 20,\n+  };\n+\n+  // `name` is moved out of person, but `age` is referenced.\n+  let Person { name, ref age } = person;\n+  println!(\"{} {}\", name, age);\n+  ```\n+\n+Compiler\n+-----------------------\n+\n+- [Added tier 1\\* support for `aarch64-unknown-linux-gnu`.][78228]\n+- [Added tier 2 support for `aarch64-apple-darwin`.][75991]\n+- [Added tier 2 support for `aarch64-pc-windows-msvc`.][75914]\n+- [Added tier 3 support for `mipsel-unknown-none`.][78676]\n+- [Raised the minimum supported LLVM version to LLVM 9.][78848]\n+- [Output from threads spawned in tests is now captured.][78227]\n+- [Change os and vendor values to \"none\" and \"unknown\" for some targets][78951]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+-----------------------\n+\n+- [`RangeInclusive` now checks for exhaustion when calling `contains` and indexing.][78109]\n+- [`ToString::to_string` now no longer shrinks the internal buffer in the default implementation.][77997]\n+- [`ops::{Index, IndexMut}` are now implemented for fixed sized arrays of any length.][74989]\n+\n+Stabilized APIs\n+---------------\n+\n+- [`slice::select_nth_unstable`]\n+- [`slice::select_nth_unstable_by`]\n+- [`slice::select_nth_unstable_by_key`]\n+\n+The following previously stable methods are now `const`.\n+\n+- [`Poll::is_ready`]\n+- [`Poll::is_pending`]\n+\n+Cargo\n+-----------------------\n+- [Building a crate with `cargo-package` should now be independently reproducible.][cargo/8864]\n+- [`cargo-tree` now marks proc-macro crates.][cargo/8765]\n+- [Added `CARGO_PRIMARY_PACKAGE` build-time environment variable.][cargo/8758] This\n+  variable will be set if the crate being built is one the user selected to build, either\n+  with `-p` or through defaults.\n+- [You can now use glob patterns when specifying packages & targets.][cargo/8752]\n+\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Demoted `i686-unknown-freebsd` from host tier 2 to target tier 2 support.][78746]\n+- [Macros that end with a semi-colon are now treated as statements even if they expand to nothing.][78376]\n+- [Rustc will now check for the validity of some built-in attributes on enum variants.][77015]\n+  Previously such invalid or unused attributes could be ignored.\n+- Leading whitespace is stripped more uniformly in documentation comments, which may change behavior. You\n+  read [this post about the changes][rustdoc-ws-post] for more details.\n+- [Trait bounds are no longer inferred for associated types.][79904]\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc and\n+related tools.\n+\n+- [rustc's internal crates are now compiled using the `initial-exec` Thread\n+  Local Storage model.][78201]\n+- [Calculate visibilities once in resolve.][78077]\n+- [Added `system` to the `llvm-libunwind` bootstrap config option.][77703]\n+- [Added `--color` for configuring terminal color support to bootstrap.][79004]\n+\n+\n+[75991]: https://github.com/rust-lang/rust/pull/75991\n+[78951]: https://github.com/rust-lang/rust/pull/78951\n+[78848]: https://github.com/rust-lang/rust/pull/78848\n+[78746]: https://github.com/rust-lang/rust/pull/78746\n+[78376]: https://github.com/rust-lang/rust/pull/78376\n+[78228]: https://github.com/rust-lang/rust/pull/78228\n+[78227]: https://github.com/rust-lang/rust/pull/78227\n+[78201]: https://github.com/rust-lang/rust/pull/78201\n+[78109]: https://github.com/rust-lang/rust/pull/78109\n+[78077]: https://github.com/rust-lang/rust/pull/78077\n+[77997]: https://github.com/rust-lang/rust/pull/77997\n+[77703]: https://github.com/rust-lang/rust/pull/77703\n+[77547]: https://github.com/rust-lang/rust/pull/77547\n+[77015]: https://github.com/rust-lang/rust/pull/77015\n+[76199]: https://github.com/rust-lang/rust/pull/76199\n+[76119]: https://github.com/rust-lang/rust/pull/76119\n+[75914]: https://github.com/rust-lang/rust/pull/75914\n+[74989]: https://github.com/rust-lang/rust/pull/74989\n+[79004]: https://github.com/rust-lang/rust/pull/79004\n+[78676]: https://github.com/rust-lang/rust/pull/78676\n+[79904]: https://github.com/rust-lang/rust/issues/79904\n+[cargo/8864]: https://github.com/rust-lang/cargo/pull/8864\n+[cargo/8765]: https://github.com/rust-lang/cargo/pull/8765\n+[cargo/8758]: https://github.com/rust-lang/cargo/pull/8758\n+[cargo/8752]: https://github.com/rust-lang/cargo/pull/8752\n+[`slice::select_nth_unstable`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable\n+[`slice::select_nth_unstable_by`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable_by\n+[`slice::select_nth_unstable_by_key`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable_by_key\n+[`hint::spin_loop`]: https://doc.rust-lang.org/stable/std/hint/fn.spin_loop.html\n+[`Poll::is_ready`]: https://doc.rust-lang.org/stable/std/task/enum.Poll.html#method.is_ready\n+[`Poll::is_pending`]: https://doc.rust-lang.org/stable/std/task/enum.Poll.html#method.is_pending\n+[rustdoc-ws-post]: https://blog.guillaume-gomez.fr/articles/2020-11-11+New+doc+comment+handling+in+rustdoc\n+\n Version 1.48.0 (2020-11-19)\n ==========================\n \n@@ -10,7 +138,7 @@ Language\n Compiler\n --------\n - [Stabilised the `-C link-self-contained=<yes|no>` compiler flag.][76158] This tells\n-  `rustc` whether to link its own C runtime and libraries or to rely on a external \n+  `rustc` whether to link its own C runtime and libraries or to rely on a external\n   linker to find them. (Supported only on `windows-gnu`, `linux-musl`, and `wasi` platforms.)\n - [You can now use `-C target-feature=+crt-static` on `linux-gnu` targets.][77386]\n   Note: If you're using cargo you must explicitly pass the `--target` flag.\n@@ -82,7 +210,7 @@ Compatibility Notes\n - [Foreign exceptions are now caught by `catch_unwind` and will cause an abort.][70212]\n   Note: This behaviour is not guaranteed and is still considered undefined behaviour,\n   see the [`catch_unwind`] documentation for further information.\n-  \n+\n \n \n Internal Only\n@@ -102,7 +230,7 @@ related tools.\n [76030]: https://github.com/rust-lang/rust/pull/76030/\n [70212]: https://github.com/rust-lang/rust/pull/70212/\n [27675]: https://github.com/rust-lang/rust/issues/27675/\n-[54121]: https://github.com/rust-lang/rust/issues/54121/  \n+[54121]: https://github.com/rust-lang/rust/issues/54121/\n [71274]: https://github.com/rust-lang/rust/pull/71274/\n [77386]: https://github.com/rust-lang/rust/pull/77386/\n [77153]: https://github.com/rust-lang/rust/pull/77153/"}, {"sha": "b0d243985751a09d58f41e7973e4968240882afa", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -167,10 +167,7 @@ pub enum GenericArgs {\n \n impl GenericArgs {\n     pub fn is_angle_bracketed(&self) -> bool {\n-        match *self {\n-            AngleBracketed(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, AngleBracketed(..))\n     }\n \n     pub fn span(&self) -> Span {\n@@ -629,10 +626,7 @@ impl Pat {\n \n     /// Is this a `..` pattern?\n     pub fn is_rest(&self) -> bool {\n-        match self.kind {\n-            PatKind::Rest => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, PatKind::Rest)\n     }\n }\n \n@@ -852,10 +846,7 @@ impl BinOpKind {\n         }\n     }\n     pub fn lazy(&self) -> bool {\n-        match *self {\n-            BinOpKind::And | BinOpKind::Or => true,\n-            _ => false,\n-        }\n+        matches!(self, BinOpKind::And | BinOpKind::Or)\n     }\n \n     pub fn is_comparison(&self) -> bool {\n@@ -963,17 +954,11 @@ impl Stmt {\n     }\n \n     pub fn is_item(&self) -> bool {\n-        match self.kind {\n-            StmtKind::Item(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, StmtKind::Item(_))\n     }\n \n     pub fn is_expr(&self) -> bool {\n-        match self.kind {\n-            StmtKind::Expr(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, StmtKind::Expr(_))\n     }\n }\n \n@@ -1652,26 +1637,17 @@ pub enum LitKind {\n impl LitKind {\n     /// Returns `true` if this literal is a string.\n     pub fn is_str(&self) -> bool {\n-        match *self {\n-            LitKind::Str(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, LitKind::Str(..))\n     }\n \n     /// Returns `true` if this literal is byte literal string.\n     pub fn is_bytestr(&self) -> bool {\n-        match self {\n-            LitKind::ByteStr(_) => true,\n-            _ => false,\n-        }\n+        matches!(self, LitKind::ByteStr(_))\n     }\n \n     /// Returns `true` if this is a numeric literal.\n     pub fn is_numeric(&self) -> bool {\n-        match *self {\n-            LitKind::Int(..) | LitKind::Float(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, LitKind::Int(..) | LitKind::Float(..))\n     }\n \n     /// Returns `true` if this literal has no suffix.\n@@ -2237,10 +2213,7 @@ impl FnDecl {\n         self.inputs.get(0).map_or(false, Param::is_self)\n     }\n     pub fn c_variadic(&self) -> bool {\n-        self.inputs.last().map_or(false, |arg| match arg.ty.kind {\n-            TyKind::CVarArgs => true,\n-            _ => false,\n-        })\n+        self.inputs.last().map_or(false, |arg| matches!(arg.ty.kind, TyKind::CVarArgs))\n     }\n }\n "}, {"sha": "726ae5e51f7a668c3ccb5b45d2312ba9179295b2", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -234,10 +234,7 @@ impl MetaItem {\n     }\n \n     pub fn is_word(&self) -> bool {\n-        match self.kind {\n-            MetaItemKind::Word => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, MetaItemKind::Word)\n     }\n \n     pub fn has_name(&self, name: Symbol) -> bool {"}, {"sha": "cd1e444bcf72a37f8888535a415c4f589935d922", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -130,10 +130,7 @@ impl LitKind {\n     }\n \n     crate fn may_have_suffix(self) -> bool {\n-        match self {\n-            Integer | Float | Err => true,\n-            _ => false,\n-        }\n+        matches!(self, Integer | Float | Err)\n     }\n }\n \n@@ -305,10 +302,7 @@ impl TokenKind {\n     }\n \n     pub fn should_end_const_arg(&self) -> bool {\n-        match self {\n-            Gt | Ge | BinOp(Shr) | BinOpEq(Shr) => true,\n-            _ => false,\n-        }\n+        matches!(self, Gt | Ge | BinOp(Shr) | BinOpEq(Shr))\n     }\n }\n \n@@ -346,18 +340,21 @@ impl Token {\n     }\n \n     pub fn is_op(&self) -> bool {\n-        match self.kind {\n-            OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) | Ident(..)\n-            | Lifetime(..) | Interpolated(..) | Eof => false,\n-            _ => true,\n-        }\n+        !matches!(\n+            self.kind,\n+            OpenDelim(..)\n+                | CloseDelim(..)\n+                | Literal(..)\n+                | DocComment(..)\n+                | Ident(..)\n+                | Lifetime(..)\n+                | Interpolated(..)\n+                | Eof\n+        )\n     }\n \n     pub fn is_like_plus(&self) -> bool {\n-        match self.kind {\n-            BinOp(Plus) | BinOpEq(Plus) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, BinOp(Plus) | BinOpEq(Plus))\n     }\n \n     /// Returns `true` if the token can appear at the start of an expression.\n@@ -379,13 +376,10 @@ impl Token {\n             ModSep                            | // global path\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n-            Interpolated(ref nt) => match **nt {\n-                NtLiteral(..) |\n+            Interpolated(ref nt) => matches!(**nt, NtLiteral(..) |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n-                NtPath(..) => true,\n-                _ => false,\n-            },\n+                NtPath(..)),\n             _ => false,\n         }\n     }\n@@ -405,10 +399,7 @@ impl Token {\n             Lifetime(..)                | // lifetime bound in trait object\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n-            Interpolated(ref nt) => match **nt {\n-                NtTy(..) | NtPath(..) => true,\n-                _ => false,\n-            },\n+            Interpolated(ref nt) => matches!(**nt, NtTy(..) | NtPath(..)),\n             _ => false,\n         }\n     }\n@@ -417,10 +408,7 @@ impl Token {\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self.kind {\n             OpenDelim(Brace) => true,\n-            Interpolated(ref nt) => match **nt {\n-                NtExpr(..) | NtBlock(..) | NtLiteral(..) => true,\n-                _ => false,\n-            },\n+            Interpolated(ref nt) => matches!(**nt, NtExpr(..) | NtBlock(..) | NtLiteral(..)),\n             _ => self.can_begin_literal_maybe_minus(),\n         }\n     }\n@@ -436,10 +424,7 @@ impl Token {\n \n     /// Returns `true` if the token is any literal.\n     pub fn is_lit(&self) -> bool {\n-        match self.kind {\n-            Literal(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, Literal(..))\n     }\n \n     /// Returns `true` if the token is any literal, a minus (which can prefix a literal,"}, {"sha": "90786520fe8025d5db38773f921d704e7fa80221", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -12,14 +12,14 @@ use crate::ast;\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n-    match e.kind {\n+    !matches!(\n+        e.kind,\n         ast::ExprKind::If(..)\n-        | ast::ExprKind::Match(..)\n-        | ast::ExprKind::Block(..)\n-        | ast::ExprKind::While(..)\n-        | ast::ExprKind::Loop(..)\n-        | ast::ExprKind::ForLoop(..)\n-        | ast::ExprKind::TryBlock(..) => false,\n-        _ => true,\n-    }\n+            | ast::ExprKind::Match(..)\n+            | ast::ExprKind::Block(..)\n+            | ast::ExprKind::While(..)\n+            | ast::ExprKind::Loop(..)\n+            | ast::ExprKind::ForLoop(..)\n+            | ast::ExprKind::TryBlock(..)\n+    )\n }"}, {"sha": "542a330a031414f469f52a256793b93c311f1fc7", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -180,10 +180,8 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n             }\n             rustc_lexer::TokenKind::BlockComment { doc_style, .. } => {\n                 if doc_style.is_none() {\n-                    let code_to_the_right = match text[pos + token.len..].chars().next() {\n-                        Some('\\r' | '\\n') => false,\n-                        _ => true,\n-                    };\n+                    let code_to_the_right =\n+                        !matches!(text[pos + token.len..].chars().next(), Some('\\r' | '\\n'));\n                     let style = match (code_to_the_left, code_to_the_right) {\n                         (_, true) => CommentStyle::Mixed,\n                         (false, false) => CommentStyle::Isolated,"}, {"sha": "ca1226b445d97beb94301349c1544660ea72cc1e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -38,10 +38,9 @@ pub fn expand_deriving_clone(\n             | ItemKind::Enum(_, Generics { ref params, .. }) => {\n                 let container_id = cx.current_expansion.id.expn_data().parent;\n                 if cx.resolver.has_derive_copy(container_id)\n-                    && !params.iter().any(|param| match param.kind {\n-                        ast::GenericParamKind::Type { .. } => true,\n-                        _ => false,\n-                    })\n+                    && !params\n+                        .iter()\n+                        .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. }))\n                 {\n                     bounds = vec![];\n                     is_shallow = true;"}, {"sha": "e78d1368b357e5f0b1ff89fc34d9b71fc92bbea0", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -404,12 +404,10 @@ impl<'a> TraitDef<'a> {\n                 let has_no_type_params = match item.kind {\n                     ast::ItemKind::Struct(_, ref generics)\n                     | ast::ItemKind::Enum(_, ref generics)\n-                    | ast::ItemKind::Union(_, ref generics) => {\n-                        !generics.params.iter().any(|param| match param.kind {\n-                            ast::GenericParamKind::Type { .. } => true,\n-                            _ => false,\n-                        })\n-                    }\n+                    | ast::ItemKind::Union(_, ref generics) => !generics\n+                        .params\n+                        .iter()\n+                        .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n                     _ => unreachable!(),\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent;\n@@ -868,7 +866,7 @@ impl<'a> MethodDef<'a> {\n                 Self_ if nonstatic => {\n                     self_args.push(arg_expr);\n                 }\n-                Ptr(ref ty, _) if (if let Self_ = **ty { true } else { false }) && nonstatic => {\n+                Ptr(ref ty, _) if matches!(**ty, Self_) && nonstatic => {\n                     self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {"}, {"sha": "85ca1da6f1daa1a9eba11b5895de321657135a27", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1044,10 +1044,7 @@ pub fn expand_preparsed_format_args(\n \n     let numbered_position_args = pieces.iter().any(|arg: &parse::Piece<'_>| match *arg {\n         parse::String(_) => false,\n-        parse::NextArgument(arg) => match arg.position {\n-            parse::Position::ArgumentIs(_) => true,\n-            _ => false,\n-        },\n+        parse::NextArgument(arg) => matches!(arg.position, parse::Position::ArgumentIs(_)),\n     });\n \n     cx.build_index_map();"}, {"sha": "0496c72cb0050dfd6816e34928b256a89155612d", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -580,10 +580,7 @@ pub mod printf {\n     }\n \n     fn is_flag(c: &char) -> bool {\n-        match c {\n-            '0' | '-' | '+' | ' ' | '#' | '\\'' => true,\n-            _ => false,\n-        }\n+        matches!(c, '0' | '-' | '+' | ' ' | '#' | '\\'')\n     }\n \n     #[cfg(test)]"}, {"sha": "d203b5bc5429e155c1d726a057a50f97702e2233", "filename": "compiler/rustc_builtin_macros/src/llvm_asm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -87,9 +87,11 @@ fn parse_inline_asm<'a>(\n     // parsed as `llvm_asm!(z)` with `z = \"x\": y` which is type ascription.\n     let first_colon = tts\n         .trees()\n-        .position(|tt| match tt {\n-            tokenstream::TokenTree::Token(Token { kind: token::Colon | token::ModSep, .. }) => true,\n-            _ => false,\n+        .position(|tt| {\n+            matches!(\n+                tt,\n+                tokenstream::TokenTree::Token(Token { kind: token::Colon | token::ModSep, .. })\n+            )\n         })\n         .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(tts.trees().skip(first_colon).collect());"}, {"sha": "7582d9805390ec24295c9792a35c76bb3c0f4797", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -256,10 +256,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         // we're just not interested in this item.\n         //\n         // If we find one, try to locate a `#[proc_macro_derive]` attribute on it.\n-        let is_fn = match item.kind {\n-            ast::ItemKind::Fn(..) => true,\n-            _ => false,\n-        };\n+        let is_fn = matches!(item.kind, ast::ItemKind::Fn(..));\n \n         let mut found_attr: Option<&'a ast::Attribute> = None;\n "}, {"sha": "7618251acd5c26ae8972288cd292ed4afbe3cf89", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1,6 +1,7 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n+    \"rust-analyzer.assist.importMergeBehaviour\": \"last\",\n     \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\","}, {"sha": "0382835269d1fdef8cb38b6aeadd28282b885374", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -50,15 +50,15 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n [[package]]\n name = \"cranelift-bforest\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -76,7 +76,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-meta\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n@@ -85,28 +85,46 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-shared\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n \n [[package]]\n name = \"cranelift-entity\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n \n [[package]]\n name = \"cranelift-frontend\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n  \"smallvec\",\n  \"target-lexicon\",\n ]\n \n+[[package]]\n+name = \"cranelift-jit\"\n+version = \"0.68.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+dependencies = [\n+ \"anyhow\",\n+ \"cranelift-codegen\",\n+ \"cranelift-entity\",\n+ \"cranelift-module\",\n+ \"cranelift-native\",\n+ \"errno\",\n+ \"libc\",\n+ \"log\",\n+ \"region\",\n+ \"target-lexicon\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"cranelift-module\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -118,7 +136,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-native\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"raw-cpuid\",\n@@ -128,7 +146,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-object\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -138,23 +156,6 @@ dependencies = [\n  \"target-lexicon\",\n ]\n \n-[[package]]\n-name = \"cranelift-simplejit\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n-dependencies = [\n- \"cranelift-codegen\",\n- \"cranelift-entity\",\n- \"cranelift-module\",\n- \"cranelift-native\",\n- \"errno\",\n- \"libc\",\n- \"log\",\n- \"region\",\n- \"target-lexicon\",\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"crc32fast\"\n version = \"1.2.1\"\n@@ -325,9 +326,9 @@ dependencies = [\n  \"ar\",\n  \"cranelift-codegen\",\n  \"cranelift-frontend\",\n+ \"cranelift-jit\",\n  \"cranelift-module\",\n  \"cranelift-object\",\n- \"cranelift-simplejit\",\n  \"gimli\",\n  \"indexmap\",\n  \"libloading\","}, {"sha": "8e1933bb14e7c197fa8bb83050368c0187395c95", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -12,7 +12,7 @@ crate-type = [\"dylib\"]\n cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n-cranelift-simplejit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n+cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n target-lexicon = \"0.11.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n@@ -27,15 +27,15 @@ libloading = { version = \"0.6.0\", optional = true }\n #cranelift-codegen = { path = \"../wasmtime/cranelift/codegen\" }\n #cranelift-frontend = { path = \"../wasmtime/cranelift/frontend\" }\n #cranelift-module = { path = \"../wasmtime/cranelift/module\" }\n-#cranelift-simplejit = { path = \"../wasmtime/cranelift/simplejit\" }\n+#cranelift-jit = { path = \"../wasmtime/cranelift/jit\" }\n #cranelift-object = { path = \"../wasmtime/cranelift/object\" }\n \n #[patch.crates-io]\n #gimli = { path = \"../\" }\n \n [features]\n default = [\"jit\", \"inline_asm\"]\n-jit = [\"cranelift-simplejit\", \"libloading\"]\n+jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n \n [profile.dev]"}, {"sha": "22d9e00923f006f1711a5d6791fd8ac78ad9d827", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -2,7 +2,7 @@\n \n > \u26a0\u26a0\u26a0 Certain kinds of FFI don't work yet. \u26a0\u26a0\u26a0\n \n-The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/master/cranelift).\n+The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/main/cranelift).\n This has the potential to improve compilation times in debug mode.\n If your project doesn't use any of the things listed under \"Not yet supported\", it should work fine.\n If not please open an issue.\n@@ -68,7 +68,15 @@ $ $cg_clif_dir/build/cargo.sh jit\n or\n \n ```bash\n-$ $cg_clif_dir/build/bin/cg_clif --jit my_crate.rs\n+$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+```\n+\n+There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n+first called. It currently does not work with multi-threaded programs. When a not yet compiled\n+function is called from another thread than the main thread, you will get an ICE.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh lazy-jit\n ```\n \n ### Shell\n@@ -77,7 +85,7 @@ These are a few functions that allow you to easily run rust code from the shell\n \n ```bash\n function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - --jit\n+    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n }\n \n function jit() {"}, {"sha": "990557694ead4a4282f943a825c31d23baff9e83", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -47,9 +47,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.65\"\n+version = \"1.0.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95752358c8f7552394baf48cd82695b345628ad3f170d607de3ca03b8dacca15\"\n+checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -141,9 +141,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.80\"\n+version = \"0.2.81\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d58d1b70b004888f764dfbf6a26a3b0342a1632d33968e4a179d8011c760614\"\n+checksum = \"1482821306169ec4d07f6aca392a4681f66c75c9918aa49641a2595db64053cb\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "3dbd28c286a246f25677b2420cc6fb07410961c8", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -5,13 +5,14 @@ version = \"0.0.0\"\n \n [dependencies]\n core = { path = \"./sysroot_src/library/core\" }\n-compiler_builtins = \"0.1\"\n alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n alloc_system = { path = \"./alloc_system\" }\n \n+compiler_builtins = { version = \"=0.1.36\", default-features = false }\n+\n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }\n rustc-std-workspace-alloc = { path = \"./sysroot_src/library/rustc-std-workspace-alloc\" }"}, {"sha": "015bbdfed4648ee106cb18d47f2e7217d7f30cd9", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -15,6 +15,8 @@ fn main() {\n     let stderr = ::std::io::stderr();\n     let mut stderr = stderr.lock();\n \n+    // FIXME support lazy jit when multi threading\n+    #[cfg(not(lazy_jit))]\n     std::thread::spawn(move || {\n         println!(\"Hello from another thread!\");\n     });"}, {"sha": "d6ad24bcf26ddf48007753c231b74bb11ac38281", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1 +1 @@\n-nightly-2020-11-27\n+nightly-2020-12-23"}, {"sha": "a3d6d303057b8050ed0d51c30c00ab0cbcf9d31c", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -10,7 +10,9 @@ cmd=$1\n shift || true\n \n if [[ \"$cmd\" = \"jit\" ]]; then\n-cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- --jit\n+cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- -Cllvm-args=mode=jit -Cprefer-dynamic\n+elif [[ \"$cmd\" = \"lazy-jit\" ]]; then\n+cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- -Cllvm-args=mode=jit-lazy -Cprefer-dynamic\n else\n cargo \"+${TOOLCHAIN}\" \"$cmd\" \"$@\"\n fi"}, {"sha": "15388926ec9ec62ddb5c707cc64c926317f75f09", "filename": "compiler/rustc_codegen_cranelift/scripts/filter_profile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -4,7 +4,7 @@\n pushd $(dirname \"$0\")/../\n source build/config.sh\n popd\n-PROFILE=$1 OUTPUT=$2 exec $RUSTC $RUSTFLAGS --jit $0\n+PROFILE=$1 OUTPUT=$2 exec $RUSTC $RUSTFLAGS -Cllvm-args=mode=jit -Cprefer-dynamic $0\n #*/\n \n //! This program filters away uninteresting samples and trims uninteresting frames for stackcollapse"}, {"sha": "a61774f479ec7f9cb7ee3533042806ff61b21c05", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -15,7 +15,10 @@ function no_sysroot_tests() {\n \n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC --jit example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+\n+        echo \"[JIT-lazy] mini_core_hello_world\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] mini_core_hello_world (skipped)\"\n     fi\n@@ -37,7 +40,10 @@ function base_sysroot_tests() {\n \n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] std_example\"\n-        $MY_RUSTC --jit example/std_example.rs --target \"$HOST_TRIPLE\"\n+        $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n+\n+        echo \"[JIT-lazy] std_example\"\n+        $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --cfg lazy_jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] std_example (skipped)\"\n     fi"}, {"sha": "0ce34c904bdcc43d274263f46035c5302d5b5a78", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -162,7 +162,7 @@ impl AddConstructor for ObjectProduct {\n }\n \n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n-    let triple = crate::build_isa(sess, true).triple().clone();\n+    let triple = crate::build_isa(sess).triple().clone();\n \n     let binary_format = match triple.binary_format {\n         target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n@@ -193,7 +193,7 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n \n pub(crate) fn make_module(sess: &Session, name: String) -> ObjectModule {\n     let mut builder = ObjectBuilder::new(\n-        crate::build_isa(sess, true),\n+        crate::build_isa(sess),\n         name + \".o\",\n         cranelift_module::default_libcall_names(),\n     )"}, {"sha": "34c9561d6762287a6113ee700e4042e6041b4352", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -118,6 +118,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n     context.dce(cx.module.isa()).unwrap();\n \n+    context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n+\n     // Define function\n     let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n@@ -140,6 +142,16 @@ pub(crate) fn codegen_fn<'tcx>(\n         &clif_comments,\n     );\n \n+    if let Some(mach_compile_result) = &context.mach_compile_result {\n+        if let Some(disasm) = &mach_compile_result.disasm {\n+            crate::pretty_clif::write_ir_file(\n+                tcx,\n+                &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+                |file| file.write_all(disasm.as_bytes()),\n+            )\n+        }\n+    }\n+\n     // Define debuginfo for function\n     let isa = cx.module.isa();\n     let debug_context = &mut cx.debug_context;\n@@ -307,7 +319,9 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             } => {\n                 let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n-                if switch_ty.kind() == fx.tcx.types.bool.kind() {\n+                let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n+                    || (targets.iter().count() == 1 && targets.iter().next().unwrap().0 == 0);\n+                if use_bool_opt {\n                     assert_eq!(targets.iter().count(), 1);\n                     let (then_value, then_block) = targets.iter().next().unwrap();\n                     let then_block = fx.get_block(then_block);\n@@ -325,12 +339,22 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                     let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     let discr =\n                         crate::optimize::peephole::make_branchable_value(&mut fx.bcx, discr);\n-                    if test_zero {\n-                        fx.bcx.ins().brz(discr, then_block, &[]);\n-                        fx.bcx.ins().jump(else_block, &[]);\n+                    if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n+                        &fx.bcx, discr, test_zero,\n+                    ) {\n+                        if taken {\n+                            fx.bcx.ins().jump(then_block, &[]);\n+                        } else {\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        }\n                     } else {\n-                        fx.bcx.ins().brnz(discr, then_block, &[]);\n-                        fx.bcx.ins().jump(else_block, &[]);\n+                        if test_zero {\n+                            fx.bcx.ins().brz(discr, then_block, &[]);\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        } else {\n+                            fx.bcx.ins().brnz(discr, then_block, &[]);\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        }\n                     }\n                 } else {\n                     let mut switch = ::cranelift_frontend::Switch::new();"}, {"sha": "58e45b4e9b972fbb1adbc6bbe112015654cc4f4c", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -44,9 +44,7 @@ fn main() {\n     let mut callbacks = CraneliftPassesCallbacks::default();\n     rustc_driver::install_ice_hook();\n     let exit_code = rustc_driver::catch_with_exit_code(|| {\n-        let mut use_jit = false;\n-\n-        let mut args = std::env::args_os()\n+        let args = std::env::args_os()\n             .enumerate()\n             .map(|(i, arg)| {\n                 arg.into_string().unwrap_or_else(|arg| {\n@@ -56,23 +54,10 @@ fn main() {\n                     )\n                 })\n             })\n-            .filter(|arg| {\n-                if arg == \"--jit\" {\n-                    use_jit = true;\n-                    false\n-                } else {\n-                    true\n-                }\n-            })\n             .collect::<Vec<_>>();\n-        if use_jit {\n-            args.push(\"-Cprefer-dynamic\".to_string());\n-        }\n         let mut run_compiler = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n         run_compiler.set_make_codegen_backend(Some(Box::new(move |_| {\n-            Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend {\n-                config: rustc_codegen_cranelift::BackendConfig { use_jit },\n-            })\n+            Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend { config: None })\n         })));\n         run_compiler.run()\n     });"}, {"sha": "8ee4cd46c94e0d2f36591b39622912437b95c225", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -92,9 +92,7 @@ fn main() {\n         let mut run_compiler = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n         if use_clif {\n             run_compiler.set_make_codegen_backend(Some(Box::new(move |_| {\n-                Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend {\n-                    config: rustc_codegen_cranelift::BackendConfig { use_jit: false },\n-                })\n+                Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend { config: None })\n             })));\n         }\n         run_compiler.run()"}, {"sha": "beff84fb2e217ae04445e7979f807ddebf7b65ab", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -100,7 +100,10 @@ fn codegen_static_ref<'tcx>(\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     assert!(\n-        matches!(fx.bcx.func.global_values[local_data_id], GlobalValueData::Symbol { tls: false, ..}),\n+        matches!(\n+            fx.bcx.func.global_values[local_data_id],\n+            GlobalValueData::Symbol { tls: false, .. }\n+        ),\n         \"tls static referenced without Rvalue::ThreadLocalRef\"\n     );\n     CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n@@ -447,7 +450,8 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             data_ctx.write_data_addr(offset.bytes() as u32, global_value, addend as i64);\n         }\n \n-        module.define_data(data_id, &data_ctx).unwrap();\n+        // FIXME don't duplicate definitions in lazy jit mode\n+        let _ = module.define_data(data_id, &data_ctx);\n         cx.done.insert(data_id);\n     }\n "}, {"sha": "6160f9b78d8b3a6d9cd3cefde854f4ca60813f67", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -74,10 +74,7 @@ impl WriterRelocate {\n \n     /// Perform the collected relocations to be usable for JIT usage.\n     #[cfg(feature = \"jit\")]\n-    pub(super) fn relocate_for_jit(\n-        mut self,\n-        jit_module: &cranelift_simplejit::SimpleJITModule,\n-    ) -> Vec<u8> {\n+    pub(super) fn relocate_for_jit(mut self, jit_module: &cranelift_jit::JITModule) -> Vec<u8> {\n         use std::convert::TryInto;\n \n         for reloc in self.relocs.drain(..) {"}, {"sha": "49de927cdba059d0fd4c154bccae6737d46c916e", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -15,11 +15,11 @@ pub(crate) struct UnwindContext<'tcx> {\n }\n \n impl<'tcx> UnwindContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n         let mut frame_table = FrameTable::default();\n \n         let cie_id = if let Some(mut cie) = isa.create_systemv_cie() {\n-            if isa.flags().is_pic() {\n+            if pic_eh_frame {\n                 cie.fde_address_encoding =\n                     gimli::DwEhPe(gimli::DW_EH_PE_pcrel.0 | gimli::DW_EH_PE_sdata4.0);\n             }\n@@ -80,7 +80,7 @@ impl<'tcx> UnwindContext<'tcx> {\n     #[cfg(feature = \"jit\")]\n     pub(crate) unsafe fn register_jit(\n         self,\n-        jit_module: &cranelift_simplejit::SimpleJITModule,\n+        jit_module: &cranelift_jit::JITModule,\n     ) -> Option<UnwindRegistry> {\n         let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n             self.tcx,"}, {"sha": "16f9bfc99189f5cbe1e7f3d59b24f7cca8364b8c", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -8,7 +8,7 @@ use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::EncodedMetadata;\n-use rustc_middle::mir::mono::CodegenUnit;\n+use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n \n@@ -146,11 +146,34 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n         }\n     }\n \n-    let mut cx = crate::CodegenCx::new(tcx, module, tcx.sess.opts.debuginfo != DebugInfo::None);\n+    let mut cx = crate::CodegenCx::new(\n+        tcx,\n+        module,\n+        tcx.sess.opts.debuginfo != DebugInfo::None,\n+        true,\n+    );\n     super::predefine_mono_items(&mut cx, &mono_items);\n     for (mono_item, (linkage, visibility)) in mono_items {\n         let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-        super::codegen_mono_item(&mut cx, mono_item, linkage);\n+        match mono_item {\n+            MonoItem::Fn(inst) => {\n+                cx.tcx.sess.time(\"codegen fn\", || {\n+                    crate::base::codegen_fn(&mut cx, inst, linkage)\n+                });\n+            }\n+            MonoItem::Static(def_id) => {\n+                crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n+            }\n+            MonoItem::GlobalAsm(hir_id) => {\n+                let item = cx.tcx.hir().expect_item(hir_id);\n+                if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n+                    cx.global_asm.push_str(&*asm.as_str());\n+                    cx.global_asm.push_str(\"\\n\\n\");\n+                } else {\n+                    bug!(\"Expected GlobalAsm found {:?}\", item);\n+                }\n+            }\n+        }\n     }\n     let (mut module, global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n@@ -236,7 +259,7 @@ pub(super) fn run_aot(\n     tcx.sess.abort_if_errors();\n \n     let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n-    let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa());\n+    let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n "}, {"sha": "9a42c675cc14498a1955983ce99e799a382ea63d", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 150, "deletions": 16, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1,16 +1,23 @@\n //! The JIT driver uses [`cranelift_simplejit`] to JIT execute programs without writing any object\n //! files.\n \n+use std::cell::RefCell;\n use std::ffi::CString;\n use std::os::raw::{c_char, c_int};\n \n use rustc_codegen_ssa::CrateInfo;\n+use rustc_middle::mir::mono::MonoItem;\n \n-use cranelift_simplejit::{SimpleJITBuilder, SimpleJITModule};\n+use cranelift_jit::{JITBuilder, JITModule};\n \n use crate::prelude::*;\n+use crate::{CodegenCx, CodegenMode};\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n+thread_local! {\n+    pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n+}\n+\n+pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n@@ -35,12 +42,13 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n \n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder = SimpleJITBuilder::with_isa(\n-        crate::build_isa(tcx.sess, false),\n+    let mut jit_builder = JITBuilder::with_isa(\n+        crate::build_isa(tcx.sess),\n         cranelift_module::default_libcall_names(),\n     );\n+    jit_builder.hotswap(matches!(codegen_mode, CodegenMode::JitLazy));\n     jit_builder.symbols(imported_symbols);\n-    let mut jit_module = SimpleJITModule::new(jit_builder);\n+    let mut jit_module = JITModule::new(jit_builder);\n     assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n \n     let sig = Signature {\n@@ -66,20 +74,42 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, jit_module, false);\n+    let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n \n-    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n-        super::time(tcx, \"codegen mono items\", || {\n-            super::predefine_mono_items(&mut cx, &mono_items);\n-            for (mono_item, (linkage, visibility)) in mono_items {\n-                let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-                super::codegen_mono_item(&mut cx, mono_item, linkage);\n+    super::time(tcx, \"codegen mono items\", || {\n+        super::predefine_mono_items(&mut cx, &mono_items);\n+        for (mono_item, (linkage, visibility)) in mono_items {\n+            let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+            match mono_item {\n+                MonoItem::Fn(inst) => match codegen_mode {\n+                    CodegenMode::Aot => unreachable!(),\n+                    CodegenMode::Jit => {\n+                        cx.tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_fn(&mut cx, inst, linkage)\n+                        });\n+                    }\n+                    CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n+                },\n+                MonoItem::Static(def_id) => {\n+                    crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n+                }\n+                MonoItem::GlobalAsm(hir_id) => {\n+                    let item = cx.tcx.hir().expect_item(hir_id);\n+                    tcx.sess\n+                        .span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n+                }\n             }\n-            tcx.sess.time(\"finalize CodegenCx\", || cx.finalize())\n-        });\n+        }\n+    });\n+\n+    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n+    jit_module.finalize_definitions();\n+\n     if !global_asm.is_empty() {\n-        tcx.sess.fatal(\"Global asm is not supported in JIT mode\");\n+        tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n+\n     crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n@@ -91,7 +121,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n \n     let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n \n-    println!(\"Rustc codegen cranelift will JIT run the executable, because --jit was passed\");\n+    println!(\"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\");\n \n     let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n         unsafe { ::std::mem::transmute(finalized_main) };\n@@ -107,11 +137,50 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n+    CURRENT_MODULE\n+        .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n+\n     let ret = f(args.len() as c_int, argv.as_ptr());\n \n     std::process::exit(ret);\n }\n \n+#[no_mangle]\n+extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8 {\n+    rustc_middle::ty::tls::with(|tcx| {\n+        // lift is used to ensure the correct lifetime for instance.\n+        let instance = tcx.lift(unsafe { *instance_ptr }).unwrap();\n+\n+        CURRENT_MODULE.with(|jit_module| {\n+            let mut jit_module = jit_module.borrow_mut();\n+            let jit_module = jit_module.as_mut().unwrap();\n+            let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+\n+            let (name, sig) = crate::abi::get_function_name_and_sig(\n+                tcx,\n+                cx.module.isa().triple(),\n+                instance,\n+                true,\n+            );\n+            let func_id = cx\n+                .module\n+                .declare_function(&name, Linkage::Export, &sig)\n+                .unwrap();\n+            cx.module.prepare_for_function_redefine(func_id).unwrap();\n+\n+            tcx.sess.time(\"codegen fn\", || {\n+                crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n+            });\n+\n+            let (jit_module, global_asm, _debug_context, unwind_context) = cx.finalize();\n+            assert!(global_asm.is_empty());\n+            jit_module.finalize_definitions();\n+            std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n+            jit_module.get_finalized_function(func_id)\n+        })\n+    })\n+}\n+\n fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     use rustc_middle::middle::dependency_format::Linkage;\n \n@@ -171,3 +240,68 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n \n     imported_symbols\n }\n+\n+pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: Instance<'tcx>) {\n+    let tcx = cx.tcx;\n+\n+    let pointer_type = cx.module.target_config().pointer_type();\n+\n+    let (name, sig) =\n+        crate::abi::get_function_name_and_sig(tcx, cx.module.isa().triple(), inst, true);\n+    let func_id = cx\n+        .module\n+        .declare_function(&name, Linkage::Export, &sig)\n+        .unwrap();\n+\n+    let instance_ptr = Box::into_raw(Box::new(inst));\n+\n+    let jit_fn = cx\n+        .module\n+        .declare_function(\n+            \"__clif_jit_fn\",\n+            Linkage::Import,\n+            &Signature {\n+                call_conv: cx.module.target_config().default_call_conv,\n+                params: vec![AbiParam::new(pointer_type)],\n+                returns: vec![AbiParam::new(pointer_type)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let mut trampoline = Function::with_name_signature(ExternalName::default(), sig.clone());\n+    let mut builder_ctx = FunctionBuilderContext::new();\n+    let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n+\n+    let jit_fn = cx\n+        .module\n+        .declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let sig_ref = trampoline_builder.func.import_signature(sig);\n+\n+    let entry_block = trampoline_builder.create_block();\n+    trampoline_builder.append_block_params_for_function_params(entry_block);\n+    let fn_args = trampoline_builder\n+        .func\n+        .dfg\n+        .block_params(entry_block)\n+        .to_vec();\n+\n+    trampoline_builder.switch_to_block(entry_block);\n+    let instance_ptr = trampoline_builder\n+        .ins()\n+        .iconst(pointer_type, instance_ptr as u64 as i64);\n+    let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n+    let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n+    let call_inst = trampoline_builder\n+        .ins()\n+        .call_indirect(sig_ref, jitted_fn, &fn_args);\n+    let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n+    trampoline_builder.ins().return_(&ret_vals);\n+\n+    cx.module\n+        .define_function(\n+            func_id,\n+            &mut Context::for_function(trampoline),\n+            &mut cranelift_codegen::binemit::NullTrapSink {},\n+        )\n+        .unwrap();\n+}"}, {"sha": "9f4ea9a386551f88436198bf27214f7f6902f39a", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 17, "deletions": 39, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -7,6 +7,7 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n+use crate::CodegenMode;\n \n mod aot;\n #[cfg(feature = \"jit\")]\n@@ -20,24 +21,25 @@ pub(crate) fn codegen_crate(\n ) -> Box<dyn Any> {\n     tcx.sess.abort_if_errors();\n \n-    if config.use_jit {\n-        let is_executable = tcx\n-            .sess\n-            .crate_types()\n-            .contains(&rustc_session::config::CrateType::Executable);\n-        if !is_executable {\n-            tcx.sess.fatal(\"can't jit non-executable crate\");\n-        }\n+    match config.codegen_mode {\n+        CodegenMode::Aot => aot::run_aot(tcx, metadata, need_metadata_module),\n+        CodegenMode::Jit | CodegenMode::JitLazy => {\n+            let is_executable = tcx\n+                .sess\n+                .crate_types()\n+                .contains(&rustc_session::config::CrateType::Executable);\n+            if !is_executable {\n+                tcx.sess.fatal(\"can't jit non-executable crate\");\n+            }\n \n-        #[cfg(feature = \"jit\")]\n-        let _: ! = jit::run_jit(tcx);\n+            #[cfg(feature = \"jit\")]\n+            let _: ! = jit::run_jit(tcx, config.codegen_mode);\n \n-        #[cfg(not(feature = \"jit\"))]\n-        tcx.sess\n-            .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            #[cfg(not(feature = \"jit\"))]\n+            tcx.sess\n+                .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+        }\n     }\n-\n-    aot::run_aot(tcx, metadata, need_metadata_module)\n }\n \n fn predefine_mono_items<'tcx>(\n@@ -63,30 +65,6 @@ fn predefine_mono_items<'tcx>(\n     });\n }\n \n-fn codegen_mono_item<'tcx, M: Module>(\n-    cx: &mut crate::CodegenCx<'tcx, M>,\n-    mono_item: MonoItem<'tcx>,\n-    linkage: Linkage,\n-) {\n-    match mono_item {\n-        MonoItem::Fn(inst) => {\n-            cx.tcx\n-                .sess\n-                .time(\"codegen fn\", || crate::base::codegen_fn(cx, inst, linkage));\n-        }\n-        MonoItem::Static(def_id) => crate::constant::codegen_static(&mut cx.constants_cx, def_id),\n-        MonoItem::GlobalAsm(hir_id) => {\n-            let item = cx.tcx.hir().expect_item(hir_id);\n-            if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n-                cx.global_asm.push_str(&*asm.as_str());\n-                cx.global_asm.push_str(\"\\n\\n\");\n-            } else {\n-                bug!(\"Expected GlobalAsm found {:?}\", item);\n-            }\n-        }\n-    }\n-}\n-\n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n     if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n         .as_ref()"}, {"sha": "d58e4d499584210e78fda8527de716e4ccba5034", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -23,8 +23,8 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n \n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n         llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n-            let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, a.layout());\n-            let lane_ty = fx.clif_type(lane_layout.ty).unwrap();\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_ty = fx.clif_type(lane_ty).unwrap();\n             assert!(lane_count <= 32);\n \n             let mut res = fx.bcx.ins().iconst(types::I32, 0);"}, {"sha": "be5b247bb9f0bf7e1a4db31c2ed9c3593a78b92e", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 14, "deletions": 55, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -171,27 +171,6 @@ macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     }\n }\n \n-fn lane_type_and_count<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    layout: TyAndLayout<'tcx>,\n-) -> (TyAndLayout<'tcx>, u16) {\n-    assert!(layout.ty.is_simd());\n-    let lane_count = match layout.fields {\n-        rustc_target::abi::FieldsShape::Array { stride: _, count } => u16::try_from(count).unwrap(),\n-        _ => unreachable!(\"lane_type_and_count({:?})\", layout),\n-    };\n-    let lane_layout = layout\n-        .field(\n-            &ty::layout::LayoutCx {\n-                tcx,\n-                param_env: ParamEnv::reveal_all(),\n-            },\n-            0,\n-        )\n-        .unwrap();\n-    (lane_layout, lane_count)\n-}\n-\n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n     let (element, count) = match &layout.abi {\n         Abi::Vector { element, count } => (element.clone(), *count),\n@@ -218,8 +197,10 @@ fn simd_for_each_lane<'tcx, M: Module>(\n ) {\n     let layout = val.layout();\n \n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n+    let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane_idx in 0..lane_count {\n@@ -248,8 +229,10 @@ fn simd_pair_for_each_lane<'tcx, M: Module>(\n     assert_eq!(x.layout(), y.layout());\n     let layout = x.layout();\n \n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n+    let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane in 0..lane_count {\n@@ -269,13 +252,14 @@ fn simd_reduce<'tcx, M: Module>(\n     ret: CPlace<'tcx>,\n     f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, val.layout());\n+    let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n     let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     for lane_idx in 1..lane_count {\n         let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.into()))\n+            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n             .load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n@@ -289,14 +273,14 @@ fn simd_reduce_bool<'tcx, M: Module>(\n     ret: CPlace<'tcx>,\n     f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, Value, Value) -> Value,\n ) {\n-    let (_lane_layout, lane_count) = lane_type_and_count(fx.tcx, val.layout());\n+    let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n     let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n         let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.into()))\n+            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n             .load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n@@ -460,9 +444,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 \"abort\" => {\n                     trap_abort(fx, \"Called intrinsic::abort.\");\n                 }\n-                \"unreachable\" => {\n-                    trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n-                }\n                 \"transmute\" => {\n                     crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n                 }\n@@ -575,12 +556,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n-        discriminant_value, (c ptr) {\n-            let pointee_layout = fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), pointee_layout);\n-            let discr = crate::discriminant::codegen_get_discriminant(fx, val, ret.layout());\n-            ret.write_cvalue(fx, discr);\n-        };\n         size_of_val, <T> (c ptr) {\n             let layout = fx.layout_of(T);\n             let size = if layout.is_unsized() {\n@@ -641,22 +616,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.starts_with(\"wrapping_\"), (c x, c y) {\n-            assert_eq!(x.layout().ty, y.layout().ty);\n-            let bin_op = match intrinsic {\n-                \"wrapping_add\" => BinOp::Add,\n-                \"wrapping_sub\" => BinOp::Sub,\n-                \"wrapping_mul\" => BinOp::Mul,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n-            };\n-            let res = crate::num::codegen_int_binop(\n-                fx,\n-                bin_op,\n-                x,\n-                y,\n-            );\n-            ret.write_cvalue(fx, res);\n-        };\n         _ if intrinsic.starts_with(\"saturating_\"), <T> (c lhs, c rhs) {\n             assert_eq!(lhs.layout().ty, rhs.layout().ty);\n             let bin_op = match intrinsic {\n@@ -916,7 +875,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             dest.write_cvalue(fx, val);\n         };\n \n-        size_of | pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n+        pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n             let const_val =\n                 fx.tcx.const_eval_instance(ParamEnv::reveal_all(), instance, None).unwrap();\n             let val = crate::constant::codegen_const_value("}, {"sha": "e0eb5c59590ffba54aeffe2931d933875cf9f093", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -73,11 +73,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();\n \n-            let (lane_type, lane_count) = lane_type_and_count(fx.tcx, layout);\n-            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+            let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n \n-            assert_eq!(lane_type, ret_lane_type);\n-            assert_eq!(n, ret_lane_count);\n+            assert_eq!(lane_ty, ret_lane_ty);\n+            assert_eq!(u64::from(n), ret_lane_count);\n \n             let total_len = lane_count * 2;\n \n@@ -105,14 +105,14 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             for &idx in &indexes {\n-                assert!(idx < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n+                assert!(u64::from(idx) < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n             }\n \n             for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n-                let in_lane = if in_idx < lane_count {\n+                let in_lane = if u64::from(in_idx) < lane_count {\n                     x.value_field(fx, mir::Field::new(in_idx.into()))\n                 } else {\n-                    y.value_field(fx, mir::Field::new((in_idx - lane_count).into()))\n+                    y.value_field(fx, mir::Field::new(usize::from(in_idx) - usize::try_from(lane_count).unwrap()))\n                 };\n                 let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n                 out_lane.write_cvalue(fx, in_lane);\n@@ -131,7 +131,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fx.tcx, base.layout());\n+            let (lane_count, _lane_ty) = base.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n             }\n@@ -160,7 +160,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fx.tcx, v.layout());\n+            let (lane_count, _lane_ty) = v.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n             }\n@@ -212,12 +212,13 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             assert_eq!(a.layout(), c.layout());\n             let layout = a.layout();\n \n-            let (_lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+            let (lane_count, _lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n             assert_eq!(lane_count, ret_lane_count);\n+            let ret_lane_layout = fx.layout_of(ret_lane_ty);\n \n             for lane in 0..lane_count {\n-                let lane = mir::Field::new(lane.into());\n+                let lane = mir::Field::new(lane.try_into().unwrap());\n                 let a_lane = a.value_field(fx, lane).load_scalar(fx);\n                 let b_lane = b.value_field(fx, lane).load_scalar(fx);\n                 let c_lane = c.value_field(fx, lane).load_scalar(fx);"}, {"sha": "6e4f3bf2898d827900ec449dafd08325ea77b886", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -5,7 +5,8 @@\n     associated_type_bounds,\n     never_type,\n     try_blocks,\n-    hash_drain_filter\n+    hash_drain_filter,\n+    str_split_once\n )]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n@@ -34,6 +35,7 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n+use std::str::FromStr;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n@@ -141,8 +143,8 @@ struct CodegenCx<'tcx, M: Module> {\n }\n \n impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n-    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool) -> Self {\n-        let unwind_context = UnwindContext::new(tcx, module.isa());\n+    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool, pic_eh_frame: bool) -> Self {\n+        let unwind_context = UnwindContext::new(tcx, module.isa(), pic_eh_frame);\n         let debug_context = if debug_info {\n             Some(DebugContext::new(tcx, module.isa()))\n         } else {\n@@ -172,12 +174,55 @@ impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n }\n \n #[derive(Copy, Clone, Debug)]\n+pub enum CodegenMode {\n+    Aot,\n+    Jit,\n+    JitLazy,\n+}\n+\n+impl Default for CodegenMode {\n+    fn default() -> Self {\n+        CodegenMode::Aot\n+    }\n+}\n+\n+impl FromStr for CodegenMode {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"aot\" => Ok(CodegenMode::Aot),\n+            \"jit\" => Ok(CodegenMode::Jit),\n+            \"jit-lazy\" => Ok(CodegenMode::JitLazy),\n+            _ => Err(format!(\"Unknown codegen mode `{}`\", s)),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n pub struct BackendConfig {\n-    pub use_jit: bool,\n+    pub codegen_mode: CodegenMode,\n+}\n+\n+impl BackendConfig {\n+    fn from_opts(opts: &[String]) -> Result<Self, String> {\n+        let mut config = BackendConfig::default();\n+        for opt in opts {\n+            if let Some((name, value)) = opt.split_once('=') {\n+                match name {\n+                    \"mode\" => config.codegen_mode = value.parse()?,\n+                    _ => return Err(format!(\"Unknown option `{}`\", name)),\n+                }\n+            } else {\n+                return Err(format!(\"Invalid option `{}`\", opt));\n+            }\n+        }\n+        Ok(config)\n+    }\n }\n \n pub struct CraneliftCodegenBackend {\n-    pub config: BackendConfig,\n+    pub config: Option<BackendConfig>,\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n@@ -204,7 +249,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n-        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, self.config);\n+        let config = if let Some(config) = self.config {\n+            config\n+        } else {\n+            BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n+                .unwrap_or_else(|err| tcx.sess.fatal(&err))\n+        };\n+        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, config);\n \n         rustc_symbol_mangling::test::report_symbol_names(tcx);\n \n@@ -250,17 +301,13 @@ fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     sess.target.llvm_target.parse().unwrap()\n }\n \n-fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'static> {\n+fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     use target_lexicon::BinaryFormat;\n \n     let target_triple = crate::target_triple(sess);\n \n     let mut flags_builder = settings::builder();\n-    if enable_pic {\n-        flags_builder.enable(\"is_pic\").unwrap();\n-    } else {\n-        flags_builder.set(\"is_pic\", \"false\").unwrap();\n-    }\n+    flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     flags_builder\n         .set(\n@@ -283,8 +330,6 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n \n     flags_builder.set(\"enable_simd\", \"true\").unwrap();\n \n-    // FIXME(CraneStation/cranelift#732) fix LICM in presence of jump tables\n-    /*\n     use rustc_session::config::OptLevel;\n     match sess.opts.optimize {\n         OptLevel::No => {\n@@ -297,7 +342,7 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n         OptLevel::Size | OptLevel::SizeMin => {\n             sess.warn(\"Optimizing for size is not supported. Just ignoring the request\");\n         }\n-    }*/\n+    }\n \n     let flags = settings::Flags::new(flags_builder);\n \n@@ -311,7 +356,5 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n /// This is the entrypoint for a hot plugged rustc_codegen_cranelift\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(CraneliftCodegenBackend {\n-        config: BackendConfig { use_jit: false },\n-    })\n+    Box::new(CraneliftCodegenBackend { config: None })\n }"}, {"sha": "a575ed8dc35f80b0a3662df42cade581ab5cf672", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -73,11 +73,48 @@ pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n     })()\n     .unwrap_or_else(|| {\n         match bcx.func.dfg.value_type(arg) {\n-            types::I8 | types::I32 => {\n+            types::I8 | types::I16 => {\n                 // WORKAROUND for brz.i8 and brnz.i8 not yet being implemented\n                 bcx.ins().uextend(types::I32, arg)\n             }\n             _ => arg,\n         }\n     })\n }\n+\n+/// Returns whether the branch is statically known to be taken or `None` if it isn't statically known.\n+pub(crate) fn maybe_known_branch_taken(\n+    bcx: &FunctionBuilder<'_>,\n+    arg: Value,\n+    test_zero: bool,\n+) -> Option<bool> {\n+    let arg_inst = if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+        arg_inst\n+    } else {\n+        return None;\n+    };\n+\n+    match bcx.func.dfg[arg_inst] {\n+        InstructionData::UnaryBool {\n+            opcode: Opcode::Bconst,\n+            imm,\n+        } => {\n+            if test_zero {\n+                Some(!imm)\n+            } else {\n+                Some(imm)\n+            }\n+        }\n+        InstructionData::UnaryImm {\n+            opcode: Opcode::Iconst,\n+            imm,\n+        } => {\n+            if test_zero {\n+                Some(imm.bits() == 0)\n+            } else {\n+                Some(imm.bits() != 0)\n+            }\n+        }\n+        _ => None,\n+    }\n+}"}, {"sha": "22c94fec82fc13a61b03ff1063376ecef26f652d", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 56, "deletions": 46, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -53,6 +53,7 @@\n //! ```\n \n use std::fmt;\n+use std::io::Write;\n \n use cranelift_codegen::{\n     entity::SecondaryMap,\n@@ -200,32 +201,24 @@ impl<M: Module> FunctionCx<'_, '_, M> {\n     }\n }\n \n-pub(crate) fn write_clif_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    postfix: &str,\n-    isa: Option<&dyn cranelift_codegen::isa::TargetIsa>,\n-    instance: Instance<'tcx>,\n-    context: &cranelift_codegen::Context,\n-    mut clif_comments: &CommentWriter,\n-) {\n-    use std::io::Write;\n-\n-    if !cfg!(debug_assertions)\n-        && !tcx\n+pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n+    cfg!(debug_assertions)\n+        || tcx\n             .sess\n             .opts\n             .output_types\n             .contains_key(&OutputType::LlvmAssembly)\n-    {\n+}\n+\n+pub(crate) fn write_ir_file<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    name: &str,\n+    write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n+) {\n+    if !should_write_ir(tcx) {\n         return;\n     }\n \n-    let value_ranges = isa.map(|isa| {\n-        context\n-            .build_value_labels_ranges(isa)\n-            .expect(\"value location ranges\")\n-    });\n-\n     let clif_output_dir = tcx.output_filenames(LOCAL_CRATE).with_extension(\"clif\");\n \n     match std::fs::create_dir(&clif_output_dir) {\n@@ -234,41 +227,58 @@ pub(crate) fn write_clif_file<'tcx>(\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(format!(\n-        \"{}.{}.clif\",\n-        tcx.symbol_name(instance).name,\n-        postfix\n-    ));\n-\n-    let mut clif = String::new();\n-    cranelift_codegen::write::decorate_function(\n-        &mut clif_comments,\n-        &mut clif,\n-        &context.func,\n-        &DisplayFunctionAnnotations {\n-            isa: Some(&*crate::build_isa(\n-                tcx.sess, true, /* PIC doesn't matter here */\n-            )),\n-            value_ranges: value_ranges.as_ref(),\n-        },\n-    )\n-    .unwrap();\n+    let clif_file_name = clif_output_dir.join(name);\n \n     let res: std::io::Result<()> = try {\n         let mut file = std::fs::File::create(clif_file_name)?;\n-        let target_triple = crate::target_triple(tcx.sess);\n-        writeln!(file, \"test compile\")?;\n-        writeln!(file, \"set is_pic\")?;\n-        writeln!(file, \"set enable_simd\")?;\n-        writeln!(file, \"target {} haswell\", target_triple)?;\n-        writeln!(file)?;\n-        file.write_all(clif.as_bytes())?;\n+        write(&mut file)?;\n     };\n     if let Err(err) = res {\n-        tcx.sess.warn(&format!(\"err writing clif file: {}\", err));\n+        tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n     }\n }\n \n+pub(crate) fn write_clif_file<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    postfix: &str,\n+    isa: Option<&dyn cranelift_codegen::isa::TargetIsa>,\n+    instance: Instance<'tcx>,\n+    context: &cranelift_codegen::Context,\n+    mut clif_comments: &CommentWriter,\n+) {\n+    write_ir_file(\n+        tcx,\n+        &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n+        |file| {\n+            let value_ranges = isa.map(|isa| {\n+                context\n+                    .build_value_labels_ranges(isa)\n+                    .expect(\"value location ranges\")\n+            });\n+\n+            let mut clif = String::new();\n+            cranelift_codegen::write::decorate_function(\n+                &mut clif_comments,\n+                &mut clif,\n+                &context.func,\n+                &DisplayFunctionAnnotations {\n+                    isa: Some(&*crate::build_isa(tcx.sess)),\n+                    value_ranges: value_ranges.as_ref(),\n+                },\n+            )\n+            .unwrap();\n+\n+            writeln!(file, \"test compile\")?;\n+            writeln!(file, \"set is_pic\")?;\n+            writeln!(file, \"set enable_simd\")?;\n+            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+            writeln!(file)?;\n+            file.write_all(clif.as_bytes())?;\n+            Ok(())\n+        },\n+    );\n+}\n+\n impl<M: Module> fmt::Debug for FunctionCx<'_, '_, M> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(f, \"{:?}\", self.instance.substs)?;"}, {"sha": "8f15586a9dc06b8c2444280a3d80509cefb36552", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -158,7 +158,8 @@ fn build_vtable<'tcx>(\n         )\n         .unwrap();\n \n-    fx.cx.module.define_data(data_id, &data_ctx).unwrap();\n+    // FIXME don't duplicate definitions in lazy jit mode\n+    let _ = fx.cx.module.define_data(data_id, &data_ctx);\n \n     data_id\n }"}, {"sha": "f33464f83dad407b1dcfadf37fba781d72520896", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -298,21 +298,19 @@ impl CodegenBackend for LlvmCodegenBackend {\n         codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported> {\n+        use crate::back::archive::LlvmArchiveBuilder;\n+        use rustc_codegen_ssa::back::link::link_binary;\n+\n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        sess.time(\"link_crate\", || {\n-            use crate::back::archive::LlvmArchiveBuilder;\n-            use rustc_codegen_ssa::back::link::link_binary;\n-\n-            let target_cpu = crate::llvm_util::target_cpu(sess);\n-            link_binary::<LlvmArchiveBuilder<'_>>(\n-                sess,\n-                &codegen_results,\n-                outputs,\n-                &codegen_results.crate_name.as_str(),\n-                target_cpu,\n-            );\n-        });\n+        let target_cpu = crate::llvm_util::target_cpu(sess);\n+        link_binary::<LlvmArchiveBuilder<'_>>(\n+            sess,\n+            &codegen_results,\n+            outputs,\n+            &codegen_results.crate_name.as_str(),\n+            target_cpu,\n+        );\n \n         Ok(())\n     }"}, {"sha": "14ace02844e4304eae213f398a46e26dcdf65926", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -46,7 +46,6 @@ use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, EntryFnType};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Session;\n-use rustc_symbol_mangling::test as symbol_names_test;\n use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n use std::cmp;\n@@ -486,8 +485,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n         ongoing_codegen.codegen_finished(tcx);\n \n-        finalize_tcx(tcx);\n-\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n         return ongoing_codegen;\n@@ -688,14 +685,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         total_codegen_time.into_inner(),\n     );\n \n-    rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-\n-    symbol_names_test::report_symbol_names(tcx);\n-\n     ongoing_codegen.check_for_errors(tcx.sess);\n \n-    finalize_tcx(tcx);\n-\n     ongoing_codegen.into_inner()\n }\n \n@@ -746,18 +737,6 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n     }\n }\n \n-fn finalize_tcx(tcx: TyCtxt<'_>) {\n-    tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n-    tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n-\n-    // We assume that no queries are run past here. If there are new queries\n-    // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n-    {\n-        let _prof_timer = tcx.prof.generic_activity(\"self_profile_alloc_query_strings\");\n-        tcx.alloc_self_profile_query_strings();\n-    }\n-}\n-\n impl CrateInfo {\n     pub fn new(tcx: TyCtxt<'_>) -> CrateInfo {\n         let mut info = CrateInfo {"}, {"sha": "57e49ba8d1a56031411972aeff8e772d2c659732", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -112,12 +112,12 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n \n             // Allow uses of projections that are ZSTs or from scalar fields.\n-            let is_consume = match context {\n+            let is_consume = matches!(\n+                context,\n                 PlaceContext::NonMutatingUse(\n                     NonMutatingUseContext::Copy | NonMutatingUseContext::Move,\n-                ) => true,\n-                _ => false,\n-            };\n+                )\n+            );\n             if is_consume {\n                 let base_ty =\n                     mir::Place::ty_from(place_ref.local, proj_base, self.fx.mir, cx.tcx());"}, {"sha": "0958afa03082a22e1da445c7c44baa6e3eccbe3a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -132,10 +132,7 @@ impl Visitor<'tcx> for TypeParamSpanVisitor<'tcx> {\n                 [segment]\n                     if segment\n                         .res\n-                        .map(|res| match res {\n-                            Res::SelfTy(_, _) | Res::Def(hir::def::DefKind::TyParam, _) => true,\n-                            _ => false,\n-                        })\n+                        .map(|res| matches!(res, Res::SelfTy(_, _) | Res::Def(hir::def::DefKind::TyParam, _)))\n                         .unwrap_or(false) =>\n                 {\n                     self.types.push(path.span);"}, {"sha": "728dc2de370319897fee6eb3dff68a2e66940bd1", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -93,10 +93,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n \n     /// True for free regions other than `'static`.\n     pub fn is_free(&self, r: Region<'_>) -> bool {\n-        match *r {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n-            _ => false,\n-        }\n+        matches!(r, ty::ReEarlyBound(_) | ty::ReFree(_))\n     }\n \n     /// True if `r` is a free region or static of the sort that this"}, {"sha": "ab34cda8cc18f514edec1adcd522ea453b05d3cd", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -393,10 +393,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 if self.expand_node(a_region, b_vid, b_data) {\n                     changes.push(b_vid);\n                 }\n-                match *b_data {\n-                    VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n-                    _ => true,\n-                }\n+                !matches!(b_data, VarValue::Value(ReStatic) | VarValue::ErrorValue)\n             });\n         }\n     }\n@@ -972,11 +969,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::IsEmpty => {\n-                if let ty::ReEmpty(_) = min {\n-                    true\n-                } else {\n-                    false\n-                }\n+                matches!(min, ty::ReEmpty(_))\n             }\n \n             VerifyBound::AnyBound(bs) => {"}, {"sha": "1a2af48b38d328ec9789bcb0b2bf4b9c2ab38c90", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1013,6 +1013,23 @@ pub fn start_codegen<'tcx>(\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n \n+    // Don't run these test assertions when not doing codegen. Compiletest tries to build\n+    // build-fail tests in check mode first and expects it to not give an error in that case.\n+    if tcx.sess.opts.output_types.should_codegen() {\n+        rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n+        rustc_symbol_mangling::test::report_symbol_names(tcx);\n+    }\n+\n+    tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n+    tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n+\n+    // We assume that no queries are run past here. If there are new queries\n+    // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n+    {\n+        let _prof_timer = tcx.prof.generic_activity(\"self_profile_alloc_query_strings\");\n+        tcx.alloc_self_profile_query_strings();\n+    }\n+\n     info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {"}, {"sha": "2384927b3017a65a35efb76322d86fb55b8af8ce", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -403,6 +403,7 @@ impl Linker {\n             return Ok(());\n         }\n \n+        let _timer = sess.prof.verbose_generic_activity(\"link_crate\");\n         self.codegen_backend.link(&self.sess, codegen_results, &self.prepare_outputs)\n     }\n }"}, {"sha": "9d392c7b26bf7f7606bc8bbe96a786799e3c4dba", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -42,37 +42,25 @@ trait MaybeFnLike {\n \n impl MaybeFnLike for hir::Item<'_> {\n     fn is_fn_like(&self) -> bool {\n-        match self.kind {\n-            hir::ItemKind::Fn(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, hir::ItemKind::Fn(..))\n     }\n }\n \n impl MaybeFnLike for hir::ImplItem<'_> {\n     fn is_fn_like(&self) -> bool {\n-        match self.kind {\n-            hir::ImplItemKind::Fn(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, hir::ImplItemKind::Fn(..))\n     }\n }\n \n impl MaybeFnLike for hir::TraitItem<'_> {\n     fn is_fn_like(&self) -> bool {\n-        match self.kind {\n-            hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)))\n     }\n }\n \n impl MaybeFnLike for hir::Expr<'_> {\n     fn is_fn_like(&self) -> bool {\n-        match self.kind {\n-            hir::ExprKind::Closure(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, hir::ExprKind::Closure(..))\n     }\n }\n "}, {"sha": "95096d0fb719c314c6d8e9df8e81ce450df39a16", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -118,17 +118,11 @@ impl CoverageKind {\n     }\n \n     pub fn is_counter(&self) -> bool {\n-        match self {\n-            Self::Counter { .. } => true,\n-            _ => false,\n-        }\n+        matches!(self, Self::Counter { .. })\n     }\n \n     pub fn is_expression(&self) -> bool {\n-        match self {\n-            Self::Expression { .. } => true,\n-            _ => false,\n-        }\n+        matches!(self, Self::Expression { .. })\n     }\n \n     pub fn is_unreachable(&self) -> bool {"}, {"sha": "1e836d0a8425363e3b56ccb158fefa2a71f75920", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -576,11 +576,13 @@ rustc_queries! {\n             desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n         }\n \n-        query impl_trait_ref(key: DefId) -> Option<ty::TraitRef<'tcx>> {\n-            desc { |tcx| \"computing trait implemented by `{}`\", tcx.def_path_str(key) }\n+        /// Given an `impl_id`, return the trait it implements.\n+        /// Return `None` if this is an inherent impl.\n+        query impl_trait_ref(impl_id: DefId) -> Option<ty::TraitRef<'tcx>> {\n+            desc { |tcx| \"computing trait implemented by `{}`\", tcx.def_path_str(impl_id) }\n         }\n-        query impl_polarity(key: DefId) -> ty::ImplPolarity {\n-            desc { |tcx| \"computing implementation polarity of `{}`\", tcx.def_path_str(key) }\n+        query impl_polarity(impl_id: DefId) -> ty::ImplPolarity {\n+            desc { |tcx| \"computing implementation polarity of `{}`\", tcx.def_path_str(impl_id) }\n         }\n \n         query issue33140_self_ty(key: DefId) -> Option<ty::Ty<'tcx>> {\n@@ -917,8 +919,10 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query trait_of_item(def_id: DefId) -> Option<DefId> {\n-            desc { |tcx| \"finding trait defining `{}`\", tcx.def_path_str(def_id) }\n+        /// Given an `associated_item`, find the trait it belongs to.\n+        /// Return `None` if the `DefId` is not an associated item.\n+        query trait_of_item(associated_item: DefId) -> Option<DefId> {\n+            desc { |tcx| \"finding trait defining `{}`\", tcx.def_path_str(associated_item) }\n         }\n     }\n \n@@ -948,27 +952,37 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query all_local_trait_impls(key: CrateNum) -> &'tcx BTreeMap<DefId, Vec<hir::HirId>> {\n+        /// Return all `impl` blocks in the current crate.\n+        ///\n+        /// To allow caching this between crates, you must pass in [`LOCAL_CRATE`] as the crate number.\n+        /// Passing in any other crate will cause an ICE.\n+        ///\n+        /// [`LOCAL_CRATE`]: rustc_hir::def_id::LOCAL_CRATE\n+        query all_local_trait_impls(local_crate: CrateNum) -> &'tcx BTreeMap<DefId, Vec<hir::HirId>> {\n             desc { \"local trait impls\" }\n         }\n-        query trait_impls_of(key: DefId) -> ty::trait_def::TraitImpls {\n+\n+        /// Given a trait `trait_id`, return all known `impl` blocks.\n+        query trait_impls_of(trait_id: DefId) -> ty::trait_def::TraitImpls {\n             storage(ArenaCacheSelector<'tcx>)\n-            desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n+            desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(trait_id) }\n         }\n-        query specialization_graph_of(key: DefId) -> specialization_graph::Graph {\n+\n+        query specialization_graph_of(trait_id: DefId) -> specialization_graph::Graph {\n             storage(ArenaCacheSelector<'tcx>)\n-            desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(key) }\n+            desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(trait_id) }\n             cache_on_disk_if { true }\n         }\n-        query object_safety_violations(key: DefId) -> &'tcx [traits::ObjectSafetyViolation] {\n-            desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(key) }\n+        query object_safety_violations(trait_id: DefId) -> &'tcx [traits::ObjectSafetyViolation] {\n+            desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(trait_id) }\n         }\n \n         /// Gets the ParameterEnvironment for a given item; this environment\n         /// will be in \"user-facing\" mode, meaning that it is suitable for\n         /// type-checking etc, and it does not normalize specializable\n         /// associated types. This is almost always what you want,\n         /// unless you are doing MIR optimizations, in which case you\n+        /// might want to use `reveal_all()` method to change modes.\n         query param_env(def_id: DefId) -> ty::ParamEnv<'tcx> {\n             desc { |tcx| \"computing normalized predicates of `{}`\", tcx.def_path_str(def_id) }\n         }\n@@ -1229,10 +1243,15 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n+        /// Given a crate and a trait, look up all impls of that trait in the crate.\n+        /// Return `(impl_id, self_ty)`.\n         query implementations_of_trait(_: (CrateNum, DefId))\n             -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n             desc { \"looking up implementations of a trait in a crate\" }\n         }\n+\n+        /// Given a crate, look up all trait impls in that crate.\n+        /// Return `(impl_id, self_ty)`.\n         query all_trait_implementations(_: CrateNum)\n             -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n             desc { \"looking up all (?) trait implementations\" }"}, {"sha": "fe20925b38798b246765626fed97bac695ed403a", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -647,14 +647,11 @@ impl<T> Trait<T> for X {\n         let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n \n         // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n-        let callable_scope = match body_owner {\n-            Some(\n+        let callable_scope = matches!(body_owner, Some(\n                 hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n                 | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n                 | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n-            ) => true,\n-            _ => false,\n-        };\n+            ));\n         let impl_comparison = matches!(\n             cause_code,\n             ObligationCauseCode::CompareImplMethodObligation { .. }"}, {"sha": "09281799041eeb11ec761aede42467a7ebac201f", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -40,11 +40,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n \n-        let expr_is_block_or_scope = match expr.kind {\n-            ExprKind::Block { .. } => true,\n-            ExprKind::Scope { .. } => true,\n-            _ => false,\n-        };\n+        let expr_is_block_or_scope = matches!(expr.kind, ExprKind::Block { .. } | ExprKind::Scope { .. });\n \n         let schedule_drop = move |this: &mut Self| {\n             if let Some(drop_scope) = scope {"}, {"sha": "60a47ca12b868c4958880e84c5bb0ee0b13c84a6", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -501,10 +501,9 @@ impl<'a> Parser<'a> {\n     pub(super) fn expr_is_valid_const_arg(&self, expr: &P<rustc_ast::Expr>) -> bool {\n         match &expr.kind {\n             ast::ExprKind::Block(_, _) | ast::ExprKind::Lit(_) => true,\n-            ast::ExprKind::Unary(ast::UnOp::Neg, expr) => match &expr.kind {\n-                ast::ExprKind::Lit(_) => true,\n-                _ => false,\n-            },\n+            ast::ExprKind::Unary(ast::UnOp::Neg, expr) => {\n+                matches!(expr.kind, ast::ExprKind::Lit(_))\n+            }\n             // We can only resolve single-segment paths at the moment, because multi-segment paths\n             // require type-checking: see `visit_generic_arg` in `src/librustc_resolve/late.rs`.\n             ast::ExprKind::Path(None, path)"}, {"sha": "c4fb0cf5b28dc6bdb5bfc98eeee6ea5852034fbb", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -23,18 +23,18 @@ use rustc_span::symbol::{sym, Symbol};\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n-    match tcx.hir().find(hir_id) {\n+    matches!(\n+        tcx.hir().find(hir_id),\n         Some(\n             Node::Item(..)\n-            | Node::ImplItem(..)\n-            | Node::ForeignItem(..)\n-            | Node::TraitItem(..)\n-            | Node::Variant(..)\n-            | Node::AnonConst(..)\n-            | Node::Pat(..),\n-        ) => true,\n-        _ => false,\n-    }\n+                | Node::ImplItem(..)\n+                | Node::ForeignItem(..)\n+                | Node::TraitItem(..)\n+                | Node::Variant(..)\n+                | Node::AnonConst(..)\n+                | Node::Pat(..),\n+        )\n+    )\n }\n \n struct MarkSymbolVisitor<'tcx> {\n@@ -500,16 +500,16 @@ struct DeadVisitor<'tcx> {\n \n impl DeadVisitor<'tcx> {\n     fn should_warn_about_item(&mut self, item: &hir::Item<'_>) -> bool {\n-        let should_warn = match item.kind {\n+        let should_warn = matches!(\n+            item.kind,\n             hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Enum(..)\n-            | hir::ItemKind::Struct(..)\n-            | hir::ItemKind::Union(..) => true,\n-            _ => false,\n-        };\n+                | hir::ItemKind::Const(..)\n+                | hir::ItemKind::Fn(..)\n+                | hir::ItemKind::TyAlias(..)\n+                | hir::ItemKind::Enum(..)\n+                | hir::ItemKind::Struct(..)\n+                | hir::ItemKind::Union(..)\n+        );\n         should_warn && !self.symbol_is_live(item.hir_id)\n     }\n "}, {"sha": "54e3cc69aea9af975a9b77bfcff19a34efbcecce", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -367,10 +367,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        let is_shorthand = match param.pat.kind {\n-            rustc_hir::PatKind::Struct(..) => true,\n-            _ => false,\n-        };\n+        let is_shorthand = matches!(param.pat.kind, rustc_hir::PatKind::Struct(..));\n         param.pat.each_binding(|_bm, hir_id, _x, ident| {\n             let var = if is_shorthand {\n                 Local(LocalInfo { id: hir_id, name: ident.name, is_shorthand: true })"}, {"sha": "708563f2ee981bd2802dbdceeac59f7a2ccb1cfa", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -842,11 +842,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         let macro_module_def_id =\n             ty::DefIdTree::parent(self.tcx, self.tcx.hir().local_def_id(md.hir_id).to_def_id())\n                 .unwrap();\n-        // FIXME(#71104) Should really be using just `as_local_hir_id` but\n-        // some `DefId` do not seem to have a corresponding HirId.\n         let hir_id = macro_module_def_id\n             .as_local()\n-            .and_then(|def_id| self.tcx.hir().opt_local_def_id_to_hir_id(def_id));\n+            .map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id));\n         let mut module_id = match hir_id {\n             Some(module_id) if self.tcx.hir().is_hir_id_module(module_id) => module_id,\n             // `module_id` doesn't correspond to a `mod`, return early (#63164, #65252)."}, {"sha": "7d8f112af8a51d46696dc1bb27658d2b01746bce", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1653,17 +1653,14 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         for missing in &self.missing_named_lifetime_spots {\n             match missing {\n                 MissingLifetimeSpot::Generics(generics) => {\n-                    let (span, sugg) = if let Some(param) =\n-                        generics.params.iter().find(|p| match p.kind {\n-                            hir::GenericParamKind::Type {\n-                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                                ..\n-                            } => false,\n-                            hir::GenericParamKind::Lifetime {\n-                                kind: hir::LifetimeParamKind::Elided,\n-                            } => false,\n-                            _ => true,\n-                        }) {\n+                    let (span, sugg) = if let Some(param) = generics.params.iter().find(|p| {\n+                        !matches!(p.kind, hir::GenericParamKind::Type {\n+                            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                            ..\n+                        } | hir::GenericParamKind::Lifetime {\n+                            kind: hir::LifetimeParamKind::Elided,\n+                        })\n+                    }) {\n                         (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n                     } else {\n                         suggests_in_band = true;"}, {"sha": "1f4bd00c3e297f5191f3202b1f5eee99063cd188", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -2416,7 +2416,10 @@ impl<'a> Resolver<'a> {\n                     } else if i == 0 {\n                         if ident\n                             .name\n-                            .with(|n| n.chars().next().map_or(false, |c| c.is_ascii_uppercase()))\n+                            .as_str()\n+                            .chars()\n+                            .next()\n+                            .map_or(false, |c| c.is_ascii_uppercase())\n                         {\n                             (format!(\"use of undeclared type `{}`\", ident), None)\n                         } else {"}, {"sha": "bc57a00e31b17983a0535c748f03efdf522f81f5", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1451,12 +1451,6 @@ impl Symbol {\n         with_interner(|interner| interner.intern(string))\n     }\n \n-    /// Access the symbol's chars. This is a slowish operation because it\n-    /// requires locking the symbol interner.\n-    pub fn with<F: FnOnce(&str) -> R, R>(self, f: F) -> R {\n-        with_interner(|interner| f(interner.get(self)))\n-    }\n-\n     /// Convert to a `SymbolStr`. This is a slowish operation because it\n     /// requires locking the symbol interner.\n     pub fn as_str(self) -> SymbolStr {\n@@ -1484,19 +1478,19 @@ impl Symbol {\n \n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.with(|str| fmt::Debug::fmt(&str, f))\n+        fmt::Debug::fmt(&self.as_str(), f)\n     }\n }\n \n impl fmt::Display for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.with(|str| fmt::Display::fmt(&str, f))\n+        fmt::Display::fmt(&self.as_str(), f)\n     }\n }\n \n impl<S: Encoder> Encodable<S> for Symbol {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.with(|string| s.emit_str(string))\n+        s.emit_str(&self.as_str())\n     }\n }\n "}, {"sha": "fc6a9a7f20972ffe1fd1c4695c202ebbcfee63f7", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -35,10 +35,7 @@ pub enum AutoTraitResult<A> {\n #[allow(dead_code)]\n impl<A> AutoTraitResult<A> {\n     fn is_auto(&self) -> bool {\n-        match *self {\n-            AutoTraitResult::PositiveImpl(_) | AutoTraitResult::NegativeImpl => true,\n-            _ => false,\n-        }\n+        matches!(self, AutoTraitResult::PositiveImpl(_) | AutoTraitResult::NegativeImpl)\n     }\n }\n \n@@ -601,10 +598,7 @@ impl AutoTraitFinder<'tcx> {\n     }\n \n     fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n-        match *p.ty().skip_binder().kind() {\n-            ty::Projection(proj) if proj == p.skip_binder().projection_ty => true,\n-            _ => false,\n-        }\n+        matches!(*p.ty().skip_binder().kind(), ty::Projection(proj) if proj == p.skip_binder().projection_ty)\n     }\n \n     fn evaluate_nested_obligations("}, {"sha": "99b96f609647687bb7c4da8155a3c3aa1372e177", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -193,10 +193,8 @@ fn overlap_within_probe(\n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n \n-    let involves_placeholder = match selcx.infcx().region_constraints_added_in_snapshot(snapshot) {\n-        Some(true) => true,\n-        _ => false,\n-    };\n+    let involves_placeholder =\n+        matches!(selcx.infcx().region_constraints_added_in_snapshot(snapshot), Some(true));\n \n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }"}, {"sha": "1d82e732907ba29ee31320c39891169f885aca0f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -861,10 +861,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n             let arg_length = arguments.len();\n-            let distinct = match &other[..] {\n-                &[ArgKind::Tuple(..)] => true,\n-                _ => false,\n-            };\n+            let distinct = matches!(other, &[ArgKind::Tuple(..)]);\n             match (arg_length, arguments.get(0)) {\n                 (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n                     format!(\"a single {}-tuple as argument\", fields.len())\n@@ -1201,12 +1198,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     normalized_ty, data.ty\n                 );\n \n-                let is_normalized_ty_expected = match &obligation.cause.code {\n-                    ObligationCauseCode::ItemObligation(_)\n+                let is_normalized_ty_expected = !matches!(obligation.cause.code, ObligationCauseCode::ItemObligation(_)\n                     | ObligationCauseCode::BindingObligation(_, _)\n-                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n-                    _ => true,\n-                };\n+                    | ObligationCauseCode::ObjectCastObligation(_));\n \n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n                     is_normalized_ty_expected,"}, {"sha": "9c894e99a389a684b4106447e78cdc47f7d48205", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -323,9 +323,8 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // This works fairly well because trait matching  does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate.skip_binders() {\n-            ty::PredicateAtom::TypeOutlives(..) => true,\n-            _ => false,\n+        .drain_filter(|predicate| {\n+            matches!(predicate.skip_binders(), ty::PredicateAtom::TypeOutlives(..))\n         })\n         .collect();\n "}, {"sha": "0feac036f00265a90a5d4093ad8fdd139f5cd137", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -526,18 +526,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generics: &ty::Generics,\n     ) -> bool {\n         let explicit = !seg.infer_args;\n-        let impl_trait =\n-            generics.params.iter().any(|param| match param.kind {\n-                ty::GenericParamDefKind::Type {\n-                    synthetic:\n-                        Some(\n-                            hir::SyntheticTyParamKind::ImplTrait\n-                            | hir::SyntheticTyParamKind::FromAttr,\n-                        ),\n-                    ..\n-                } => true,\n-                _ => false,\n-            });\n+        let impl_trait = generics.params.iter().any(|param| {\n+            matches!(param.kind, ty::GenericParamDefKind::Type {\n+                synthetic:\n+                    Some(\n+                        hir::SyntheticTyParamKind::ImplTrait\n+                        | hir::SyntheticTyParamKind::FromAttr,\n+                    ),\n+                ..\n+            })\n+        });\n \n         if explicit && impl_trait {\n             let spans = seg"}, {"sha": "9c60e8933d4dbf4bf242a050f785c823a01a3714", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -543,10 +543,9 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n \n         if let Some(ty) = prohibit_opaque.break_value() {\n             let is_async = match item.kind {\n-                ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n-                    hir::OpaqueTyOrigin::AsyncFn => true,\n-                    _ => false,\n-                },\n+                ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n+                    matches!(origin, hir::OpaqueTyOrigin::AsyncFn)\n+                }\n                 _ => unreachable!(),\n             };\n \n@@ -1321,10 +1320,7 @@ pub fn check_enum<'tcx>(\n     }\n \n     if tcx.adt_def(def_id).repr.int.is_none() && tcx.features().arbitrary_enum_discriminant {\n-        let is_unit = |var: &hir::Variant<'_>| match var.data {\n-            hir::VariantData::Unit(..) => true,\n-            _ => false,\n-        };\n+        let is_unit = |var: &hir::Variant<'_>| matches!(var.data, hir::VariantData::Unit(..));\n \n         let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n         let has_non_units = vs.iter().any(|var| !is_unit(var));"}, {"sha": "3e60924d6fcf889b22af1fa83ec86956c3f8e9c6", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -325,10 +325,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n                 }\n \n-                let is_closure = match arg.kind {\n-                    ExprKind::Closure(..) => true,\n-                    _ => false,\n-                };\n+                let is_closure = matches!(arg.kind, ExprKind::Closure(..));\n \n                 if is_closure != check_closures {\n                     continue;"}, {"sha": "eca6ce1ecdb63fd347c0804d3b1bad539c37ee5b", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -354,10 +354,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n         hir_id: hir::HirId,\n     ) {\n         assert!(\n-            match fk {\n-                intravisit::FnKind::Closure(..) => true,\n-                _ => false,\n-            },\n+            matches!(fk, intravisit::FnKind::Closure(..)),\n             \"visit_fn invoked for something other than a closure\"\n         );\n "}, {"sha": "29b03d118e25ab2dc01700e951a74d336d9a7eb6", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -156,10 +156,10 @@ crate fn placeholder_type_error(\n         if let Some(span) = span {\n             sugg.push((span, format!(\"<{}>\", type_name)));\n         }\n-    } else if let Some(arg) = generics.iter().find(|arg| match arg.name {\n-        hir::ParamName::Plain(Ident { name: kw::Underscore, .. }) => true,\n-        _ => false,\n-    }) {\n+    } else if let Some(arg) = generics\n+        .iter()\n+        .find(|arg| matches!(arg.name, hir::ParamName::Plain(Ident { name: kw::Underscore, .. })))\n+    {\n         // Account for `_` already present in cases like `struct S<_>(_);` and suggest\n         // `struct S<T>(T);` instead of `struct S<_, T>(T);`.\n         sugg.push((arg.span, (*type_name).to_string()));\n@@ -1544,12 +1544,27 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     let mut diag = bad_placeholder_type(tcx, visitor.0);\n                     let ret_ty = fn_sig.output();\n                     if ret_ty != tcx.ty_error() {\n-                        diag.span_suggestion(\n-                            ty.span,\n-                            \"replace with the correct return type\",\n-                            ret_ty.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        if !ret_ty.is_closure() {\n+                            let ret_ty_str = match ret_ty.kind() {\n+                                // Suggest a function pointer return type instead of a unique function definition\n+                                // (e.g. `fn() -> i32` instead of `fn() -> i32 { f }`, the latter of which is invalid\n+                                // syntax)\n+                                ty::FnDef(..) => ret_ty.fn_sig(tcx).to_string(),\n+                                _ => ret_ty.to_string(),\n+                            };\n+                            diag.span_suggestion(\n+                                ty.span,\n+                                \"replace with the correct return type\",\n+                                ret_ty_str,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            // We're dealing with a closure, so we should suggest using `impl Fn` or trait bounds\n+                            // to prevent the user from getting a papercut while trying to use the unique closure\n+                            // syntax (e.g. `[closure@src/lib.rs:2:5: 2:9]`).\n+                            diag.help(\"consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\");\n+                            diag.note(\"for more information on `Fn` traits and closure types, see https://doc.rust-lang.org/book/ch13-01-closures.html\");\n+                        }\n                     }\n                     diag.emit();\n                     ty::Binder::bind(fn_sig)"}, {"sha": "3ce244e11bf453dd391db7aa0ae28ffb68c20eca", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -595,10 +595,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         let upvars = self.tcx().upvars_mentioned(self.body_owner);\n \n         // For purposes of this function, generator and closures are equivalent.\n-        let body_owner_is_closure = match self.tcx().type_of(self.body_owner.to_def_id()).kind() {\n-            ty::Closure(..) | ty::Generator(..) => true,\n-            _ => false,\n-        };\n+        let body_owner_is_closure = matches!(\n+            self.tcx().type_of(self.body_owner.to_def_id()).kind(),\n+            ty::Closure(..) | ty::Generator(..)\n+        );\n \n         if let Some(min_captures) = self.mc.typeck_results.closure_min_captures.get(&closure_def_id)\n         {"}, {"sha": "1d6488dd2dfe32b44de7e70f43f890d71d316862", "filename": "library/alloc/src/collections/btree/append.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -81,15 +81,18 @@ impl<K, V> Root<K, V> {\n             // the appended elements even if advancing the iterator panicks.\n             *length += 1;\n         }\n-        self.fix_right_edge();\n+        self.fix_right_border_of_plentiful();\n     }\n \n-    fn fix_right_edge(&mut self) {\n-        // Handle underfull nodes, start from the top.\n+    /// Stock up any underfull nodes on the right border of the tree.\n+    /// The other nodes, those that are not the root nor a rightmost edge,\n+    /// must have MIN_LEN elements to spare.\n+    fn fix_right_border_of_plentiful(&mut self) {\n         let mut cur_node = self.borrow_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_kv = internal.last_kv().consider_for_balancing();\n+            debug_assert!(last_kv.left_child_len() >= MIN_LEN * 2);\n             let right_child_len = last_kv.right_child_len();\n             if right_child_len < MIN_LEN {\n                 // We need to steal."}, {"sha": "f92aed8ce15bf8b10397ed9e2a77f79fbdfb5853", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -1821,7 +1821,6 @@ fn test_append_ord_chaos() {\n }\n \n fn rand_data(len: usize) -> Vec<(u32, u32)> {\n-    assert!(len * 2 <= 70029); // from that point on numbers repeat\n     let mut rng = DeterministicRng::new();\n     Vec::from_iter((0..len).map(|_| (rng.next(), rng.next())))\n }\n@@ -1886,6 +1885,25 @@ fn test_split_off_tiny_right_height_2() {\n     assert_eq!(*right.last_key_value().unwrap().0, last);\n }\n \n+#[test]\n+fn test_split_off_halfway() {\n+    let mut rng = DeterministicRng::new();\n+    for &len in &[NODE_CAPACITY, 25, 50, 75, 100] {\n+        let mut data = Vec::from_iter((0..len).map(|_| (rng.next(), ())));\n+        // Insertion in non-ascending order creates some variation in node length.\n+        let mut map = BTreeMap::from_iter(data.iter().copied());\n+        data.sort();\n+        let small_keys = data.iter().take(len / 2).map(|kv| kv.0);\n+        let large_keys = data.iter().skip(len / 2).map(|kv| kv.0);\n+        let split_key = large_keys.clone().next().unwrap();\n+        let right = map.split_off(&split_key);\n+        map.check();\n+        right.check();\n+        assert!(map.keys().copied().eq(small_keys));\n+        assert!(right.keys().copied().eq(large_keys));\n+    }\n+}\n+\n #[test]\n fn test_split_off_large_random_sorted() {\n     // Miri is too slow"}, {"sha": "cdb39104047f0db0472e7a08757e9cfe9a180ed2", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -38,6 +38,7 @@ pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n #[cfg(test)]\n /// XorShiftRng\n struct DeterministicRng {\n+    count: usize,\n     x: u32,\n     y: u32,\n     z: u32,\n@@ -47,11 +48,13 @@ struct DeterministicRng {\n #[cfg(test)]\n impl DeterministicRng {\n     fn new() -> Self {\n-        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n+        DeterministicRng { count: 0, x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n     }\n \n-    /// Guarantees that the first 70029 results are unique.\n+    /// Guarantees that each returned number is unique.\n     fn next(&mut self) -> u32 {\n+        self.count += 1;\n+        assert!(self.count <= 70029);\n         let x = self.x;\n         let t = x ^ (x << 11);\n         self.x = self.y;"}, {"sha": "fd19c0078a7487ef4af93cf9cc7287cbf97914a8", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -696,8 +696,10 @@ fn test_first_last() {\n     assert_eq!(a.pop_last(), None);\n }\n \n+// Unlike the function with the same name in map/tests, returns no values.\n+// Which also means it returns different predetermined pseudo-random keys,\n+// and the test cases using this function explore slightly different trees.\n fn rand_data(len: usize) -> Vec<u32> {\n-    assert!(len <= 70029); // from that point on numbers repeat\n     let mut rng = DeterministicRng::new();\n     Vec::from_iter((0..len).map(|_| rng.next()))\n }"}, {"sha": "4561c8eaf47fb135bea1bd4194ee5a234ac3440e", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -53,6 +53,9 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n+    /// Stock up or merge away any underfull nodes on the right border of the\n+    /// tree. The other nodes, those that are not the root nor a rightmost edge,\n+    /// must already have at least MIN_LEN elements.\n     fn fix_right_border(&mut self) {\n         self.fix_top();\n \n@@ -72,6 +75,7 @@ impl<K, V> Root<K, V> {\n                     }\n                     cur_node = last_kv.into_right_child();\n                 }\n+                debug_assert!(cur_node.len() > MIN_LEN);\n             }\n         }\n \n@@ -98,6 +102,7 @@ impl<K, V> Root<K, V> {\n                     }\n                     cur_node = first_kv.into_left_child();\n                 }\n+                debug_assert!(cur_node.len() > MIN_LEN);\n             }\n         }\n "}, {"sha": "2d60bb0a4bde23d1a0b655e771f5b0bfbb0ea4e8", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -500,18 +500,17 @@ impl Step for Rustc {\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n \n-        // This is the intended out directory for compiler documentation.\n-        let out = builder.compiler_doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-\n-        let compiler = builder.compiler(stage, builder.config.build);\n-\n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n             return;\n         }\n \n+        // This is the intended out directory for compiler documentation.\n+        let out = builder.compiler_doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+\n         // Build rustc.\n+        let compiler = builder.compiler(stage, builder.config.build);\n         builder.ensure(compile::Rustc { compiler, target });\n \n         // This uses a shared directory so that librustdoc documentation gets\n@@ -521,6 +520,10 @@ impl Step for Rustc {\n         // merging the search index, or generating local (relative) links.\n         let out_dir = builder.stage_out(compiler, Mode::Rustc).join(target.triple).join(\"doc\");\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n+        // Cargo puts proc macros in `target/doc` even if you pass `--target`\n+        // explicitly (https://github.com/rust-lang/cargo/issues/7677).\n+        let proc_macro_out_dir = builder.stage_out(compiler, Mode::Rustc).join(\"doc\");\n+        t!(symlink_dir_force(&builder.config, &out, &proc_macro_out_dir));\n \n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, SourceType::InTree, target, \"doc\");"}, {"sha": "0255f79b65929c70a1b852efdff8f368e67ac79f", "filename": "src/bootstrap/tarball.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src%2Fbootstrap%2Ftarball.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src%2Fbootstrap%2Ftarball.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftarball.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -112,7 +112,7 @@ impl<'a> Tarball<'a> {\n     fn new_inner(builder: &'a Builder<'a>, component: &str, target: Option<String>) -> Self {\n         let pkgname = crate::dist::pkgname(builder, component);\n \n-        let mut temp_dir = builder.out.join(\"tmp\").join(\"tarball\");\n+        let mut temp_dir = builder.out.join(\"tmp\").join(\"tarball\").join(component);\n         if let Some(target) = &target {\n             temp_dir = temp_dir.join(target);\n         }"}, {"sha": "7609b1525cc90a286922949b75278d6d75e2aee8", "filename": "src/test/ui/fn/issue-80179.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src%2Ftest%2Fui%2Ffn%2Fissue-80179.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src%2Ftest%2Fui%2Ffn%2Fissue-80179.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fissue-80179.rs?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -0,0 +1,27 @@\n+// Functions with a type placeholder `_` as the return type should\n+// show a function pointer suggestion when given a function item\n+// and suggest how to return closures correctly from a function.\n+// This is a regression test of #80179\n+\n+fn returns_i32() -> i32 {\n+    0\n+}\n+\n+fn returns_fn_ptr() -> _ {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures [E0121]\n+//~| NOTE not allowed in type signatures\n+//~| HELP replace with the correct return type\n+//~| SUGGESTION fn() -> i32\n+    returns_i32\n+}\n+\n+fn returns_closure() -> _ {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures [E0121]\n+//~| NOTE not allowed in type signatures\n+//~| HELP consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\n+//~| NOTE for more information on `Fn` traits and closure types, see\n+//        https://doc.rust-lang.org/book/ch13-01-closures.html\n+    || 0\n+}\n+\n+fn main() {}"}, {"sha": "63571e71b34f49415cbbe450c1123f219ef51658", "filename": "src/test/ui/fn/issue-80179.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src%2Ftest%2Fui%2Ffn%2Fissue-80179.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2987785df3d46d5ff144a5c67fbb8f5cca798d78/src%2Ftest%2Fui%2Ffn%2Fissue-80179.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fissue-80179.stderr?ref=2987785df3d46d5ff144a5c67fbb8f5cca798d78", "patch": "@@ -0,0 +1,21 @@\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-80179.rs:10:24\n+   |\n+LL | fn returns_fn_ptr() -> _ {\n+   |                        ^\n+   |                        |\n+   |                        not allowed in type signatures\n+   |                        help: replace with the correct return type: `fn() -> i32`\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-80179.rs:18:25\n+   |\n+LL | fn returns_closure() -> _ {\n+   |                         ^ not allowed in type signatures\n+   |\n+   = help: consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\n+   = note: for more information on `Fn` traits and closure types, see https://doc.rust-lang.org/book/ch13-01-closures.html\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0121`."}]}