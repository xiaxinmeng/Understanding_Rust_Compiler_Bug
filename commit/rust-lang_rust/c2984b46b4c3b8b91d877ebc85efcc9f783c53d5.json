{"sha": "c2984b46b4c3b8b91d877ebc85efcc9f783c53d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOTg0YjQ2YjRjM2I4YjkxZDg3N2ViYzg1ZWZjYzlmNzgzYzUzZDU=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-23T10:03:37Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-23T16:00:19Z"}, "message": "(core::str) comments", "tree": {"sha": "7299a62d5dd40904669c9cb210c96e6ce9027602", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7299a62d5dd40904669c9cb210c96e6ce9027602"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2984b46b4c3b8b91d877ebc85efcc9f783c53d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2984b46b4c3b8b91d877ebc85efcc9f783c53d5", "html_url": "https://github.com/rust-lang/rust/commit/c2984b46b4c3b8b91d877ebc85efcc9f783c53d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2984b46b4c3b8b91d877ebc85efcc9f783c53d5/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "961b6446b6123616b6f0b935813021e43da3ef18", "url": "https://api.github.com/repos/rust-lang/rust/commits/961b6446b6123616b6f0b935813021e43da3ef18", "html_url": "https://github.com/rust-lang/rust/commit/961b6446b6123616b6f0b935813021e43da3ef18"}], "stats": {"total": 29, "additions": 18, "deletions": 11}, "files": [{"sha": "f0f274d75d52028131e1912f2ecfd569bb5caa3f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c2984b46b4c3b8b91d877ebc85efcc9f783c53d5/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2984b46b4c3b8b91d877ebc85efcc9f783c53d5/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=c2984b46b4c3b8b91d877ebc85efcc9f783c53d5", "patch": "@@ -4,9 +4,9 @@ Module: str\n String manipulation\n \n Strings are a packed UTF-8 representation of text, stored as null terminated\n-buffers of u8 bytes.  Strings should be considered by character,\n-for correctness, but some UTF-8 unsafe functions are also provided.\n-For some heavy-duty uses, we recommend trying std::rope.\n+buffers of u8 bytes.  Strings should be indexed in bytes, for efficiency,\n+but UTF-8 unsafe operations should be avoided.\n+For some heavy-duty uses, try std::rope.\n */\n \n import option::{some, none};\n@@ -434,6 +434,7 @@ Failure:\n - If end is greater than the character length of the string\n \n FIXME: make faster by avoiding char conversion\n+FIXME: delete?\n */\n fn slice_chars(s: str, begin: uint, end: uint) -> str {\n     from_chars(vec::slice(chars(s), begin, end))\n@@ -498,7 +499,7 @@ Splits a string into a vector of the substrings separated by a given string\n Note that this has recently been changed.  For example:\n >  assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n \n-FIXME: Boyer-Moore variation\n+FIXME: Boyer-Moore should be faster\n */\n fn split_str(ss: str, sep: str) -> [str] unsafe {\n     // unsafe is justified: we are splitting\n@@ -670,7 +671,7 @@ fn to_upper(s: str) -> str {\n     map(s, char::to_upper)\n }\n \n-// FIXME: This is super-inefficient\n+// FIXME: This is super-inefficient: stop the extra slicing copies\n /*\n Function: replace\n \n@@ -894,6 +895,7 @@ fn index_from(ss: str, cc: char, start: uint, end: uint) -> option<uint> {\n //\n // Returns the char index of the first matching char\n // (as option some/none)\n+// FIXME: delete?\n fn index_chars(ss: str, cc: char) -> option<uint> {\n     let bii = 0u;\n     let cii = 0u;\n@@ -938,6 +940,7 @@ fn rindex(ss: str, cc: char) -> option<uint> {\n //\n // Returns the char index of the first matching char\n // (as option some/none)\n+// FIXME: delete?\n fn rindex_chars(ss: str, cc: char) -> option<uint> {\n     let bii = len(ss);\n     let cii = len_chars(ss);\n@@ -998,6 +1001,7 @@ fn find_from(haystack: str, needle: str, start: uint, end:uint)\n //\n // Find the char position of the first instance of one string\n // within another, or return option::none\n+// FIXME: delete?\n fn find_chars(haystack: str, needle: str) -> option<uint> {\n    alt find(haystack, needle) {\n       none { ret none; }\n@@ -1065,8 +1069,8 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn ends_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = len_chars(haystack);\n-    let needle_len: uint = len_chars(needle);\n+    let haystack_len: uint = len(haystack);\n+    let needle_len: uint = len(needle);\n     ret if needle_len == 0u {\n             true\n         } else if needle_len > haystack_len {\n@@ -1129,6 +1133,7 @@ pure fn len(s: str) -> uint unsafe {\n     }\n }\n \n+// FIXME: delete?\n fn len_chars(s: str) -> uint {\n     substr_len_chars(s, 0u, len(s))\n }\n@@ -1177,6 +1182,8 @@ Safety note:\n - This function does not check whether the substring is valid.\n - This function fails if `byte_offset` or `byte_len` do not\n  represent valid positions inside `s`\n+\n+FIXME: delete?\n */\n fn substr_len_chars(s: str, byte_start: uint, byte_len: uint) -> uint {\n     let i         = byte_start;\n@@ -1451,12 +1458,13 @@ fn reserve(&ss: str, nn: uint) {\n // These functions may create invalid UTF-8 strings and eat your baby.\n mod unsafe {\n    export\n+      // FIXME: stop exporting several of these\n       from_bytes,\n       from_byte,\n-      slice_bytes,            // FIXME: stop exporting\n-      slice_bytes_safe_range, // FIXME: stop exporting\n+      slice_bytes,\n+      slice_bytes_safe_range,\n       push_byte,\n-      push_bytes, // note: wasn't exported\n+      push_bytes,\n       pop_byte,\n       shift_byte;\n \n@@ -1489,7 +1497,6 @@ mod unsafe {\n    - If end is greater than the length of the string.\n    */\n    unsafe fn slice_bytes(s: str, begin: uint, end: uint) -> str unsafe {\n-       // FIXME: Typestate precondition\n        assert (begin <= end);\n        assert (end <= len(s));\n "}]}