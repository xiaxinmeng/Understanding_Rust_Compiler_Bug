{"sha": "2426f7c39d105fee7d5ea53ea67b8544e13c57e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MjZmN2MzOWQxMDVmZWU3ZDVlYTUzZWE2N2I4NTQ0ZTEzYzU3ZTk=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-05T22:28:38Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-21T11:16:05Z"}, "message": "Uninline some debugging code and use unlikely! macro", "tree": {"sha": "29f71570c0be1f9afec2e3e8d0307453dc6e4bd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29f71570c0be1f9afec2e3e8d0307453dc6e4bd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2426f7c39d105fee7d5ea53ea67b8544e13c57e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2426f7c39d105fee7d5ea53ea67b8544e13c57e9", "html_url": "https://github.com/rust-lang/rust/commit/2426f7c39d105fee7d5ea53ea67b8544e13c57e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2426f7c39d105fee7d5ea53ea67b8544e13c57e9/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d34ec18c7d7e574553f6347ecf08e1e1c45c13d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d34ec18c7d7e574553f6347ecf08e1e1c45c13d", "html_url": "https://github.com/rust-lang/rust/commit/6d34ec18c7d7e574553f6347ecf08e1e1c45c13d"}], "stats": {"total": 62, "additions": 39, "deletions": 23}, "files": [{"sha": "3d44fda9a5eec789e7b4c145d9c445a91b1a9054", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2426f7c39d105fee7d5ea53ea67b8544e13c57e9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2426f7c39d105fee7d5ea53ea67b8544e13c57e9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2426f7c39d105fee7d5ea53ea67b8544e13c57e9", "patch": "@@ -1926,13 +1926,15 @@ pub mod tls {\n     /// to `value` during the call to `f`. It is restored to its previous value after.\n     /// This is used to set the pointer to the new ImplicitCtxt.\n     #[cfg(parallel_queries)]\n+    #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         rayon_core::tlv::with(value, f)\n     }\n \n     /// Gets Rayon's thread local variable which is preserved for Rayon jobs.\n     /// This is used to get the pointer to the current ImplicitCtxt.\n     #[cfg(parallel_queries)]\n+    #[inline]\n     fn get_tlv() -> usize {\n         rayon_core::tlv::get()\n     }\n@@ -1945,6 +1947,7 @@ pub mod tls {\n     /// It is restored to its previous value after.\n     /// This is used to set the pointer to the new ImplicitCtxt.\n     #[cfg(not(parallel_queries))]\n+    #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         let old = get_tlv();\n         let _reset = OnDrop(move || TLV.with(|tlv| tlv.set(old)));"}, {"sha": "005a6a21394dc767057a209f157e35b2d09bc54f", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2426f7c39d105fee7d5ea53ea67b8544e13c57e9/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2426f7c39d105fee7d5ea53ea67b8544e13c57e9/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=2426f7c39d105fee7d5ea53ea67b8544e13c57e9", "patch": "@@ -499,37 +499,48 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // If -Zincremental-verify-ich is specified, re-hash results from\n         // the cache and make sure that they have the expected fingerprint.\n-        if self.sess.opts.debugging_opts.incremental_verify_ich {\n-            use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-            use ich::Fingerprint;\n+        if unlikely!(self.sess.opts.debugging_opts.incremental_verify_ich) {\n+            self.incremental_verify_ich::<Q>(&result, dep_node, dep_node_index);\n+        }\n \n-            assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n-                    self.dep_graph.prev_fingerprint_of(dep_node),\n-                    \"Fingerprint for green query instance not loaded \\\n-                     from cache: {:?}\", dep_node);\n+        if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n+            self.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n+        }\n \n-            debug!(\"BEGIN verify_ich({:?})\", dep_node);\n-            let mut hcx = self.create_stable_hashing_context();\n-            let mut hasher = StableHasher::new();\n+        job.complete(&result, dep_node_index);\n \n-            result.hash_stable(&mut hcx, &mut hasher);\n+        Ok(result)\n+    }\n \n-            let new_hash: Fingerprint = hasher.finish();\n-            debug!(\"END verify_ich({:?})\", dep_node);\n+    #[inline(never)]\n+    #[cold]\n+    fn incremental_verify_ich<Q: QueryDescription<'gcx>>(\n+        self,\n+        result: &Q::Value,\n+        dep_node: &DepNode,\n+        dep_node_index: DepNodeIndex,\n+    ) {\n+        use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+        use ich::Fingerprint;\n \n-            let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n+        assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n+                self.dep_graph.prev_fingerprint_of(dep_node),\n+                \"Fingerprint for green query instance not loaded \\\n+                    from cache: {:?}\", dep_node);\n \n-            assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n-                for {:?}\", dep_node);\n-        }\n+        debug!(\"BEGIN verify_ich({:?})\", dep_node);\n+        let mut hcx = self.create_stable_hashing_context();\n+        let mut hasher = StableHasher::new();\n \n-        if self.sess.opts.debugging_opts.query_dep_graph {\n-            self.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n-        }\n+        result.hash_stable(&mut hcx, &mut hasher);\n \n-        job.complete(&result, dep_node_index);\n+        let new_hash: Fingerprint = hasher.finish();\n+        debug!(\"END verify_ich({:?})\", dep_node);\n \n-        Ok(result)\n+        let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n+\n+        assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n+            for {:?}\", dep_node);\n     }\n \n     fn force_query_with_job<Q: QueryDescription<'gcx>>(\n@@ -574,7 +585,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let ((result, dep_node_index), diagnostics) = res;\n \n-        if self.sess.opts.debugging_opts.query_dep_graph {\n+        if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n             self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n         }\n "}, {"sha": "9d0201a9e38b11677b478a0c17f3840b50390a61", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2426f7c39d105fee7d5ea53ea67b8544e13c57e9/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2426f7c39d105fee7d5ea53ea67b8544e13c57e9/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=2426f7c39d105fee7d5ea53ea67b8544e13c57e9", "patch": "@@ -113,12 +113,14 @@ pub struct OnDrop<F: Fn()>(pub F);\n impl<F: Fn()> OnDrop<F> {\n       /// Forgets the function which prevents it from running.\n       /// Ensure that the function owns no memory, otherwise it will be leaked.\n+      #[inline]\n       pub fn disable(self) {\n             std::mem::forget(self);\n       }\n }\n \n impl<F: Fn()> Drop for OnDrop<F> {\n+      #[inline]\n       fn drop(&mut self) {\n             (self.0)();\n       }"}]}