{"sha": "28b5e4588f5d78d2dab830245bc453dd666af617", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YjVlNDU4OGY1ZDc4ZDJkYWI4MzAyNDViYzQ1M2RkNjY2YWY2MTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-13T23:11:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-13T23:11:28Z"}, "message": "auto merge of #15934 : brson/rust/dur, r=aturon\n\nCurrently, the Timer methods take an integer number of ms. This is considered a bug because a) types, b) some timers have ns precision.\r\n\r\nThis plucks the `Duration` type from [rust-chrono](https://github.com/lifthrasiir/rust-chrono), plops it into `std::time`,  and replaces the arguments to `sleep`, `oneshot`, and `periodic` timers with it. It leaves the old methods intact as `sleep_ms`, `oneshot_ms`, and `periodic_ms`, for convenience.\r\n\r\nCloses https://github.com/rust-lang/rust/issues/11189.\r\n\r\ncc @lifthrasiir @aturon @kballard @alexcrichton", "tree": {"sha": "72a65cb6a11a37106bc302c2035e7d38e854f82a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72a65cb6a11a37106bc302c2035e7d38e854f82a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28b5e4588f5d78d2dab830245bc453dd666af617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28b5e4588f5d78d2dab830245bc453dd666af617", "html_url": "https://github.com/rust-lang/rust/commit/28b5e4588f5d78d2dab830245bc453dd666af617", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28b5e4588f5d78d2dab830245bc453dd666af617/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f09f51c61f1671caa75e9797f081ab4e312b634", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f09f51c61f1671caa75e9797f081ab4e312b634", "html_url": "https://github.com/rust-lang/rust/commit/0f09f51c61f1671caa75e9797f081ab4e312b634"}, {"sha": "075256a0701e23ce56e9c09206d6c8f581c46115", "url": "https://api.github.com/repos/rust-lang/rust/commits/075256a0701e23ce56e9c09206d6c8f581c46115", "html_url": "https://github.com/rust-lang/rust/commit/075256a0701e23ce56e9c09206d6c8f581c46115"}], "stats": {"total": 946, "additions": 867, "deletions": 79}, "files": [{"sha": "318609f44fda6c03e23e4cdaea8494b370f7dbdf", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -30,6 +30,7 @@ use std::os;\n use std::str;\n use std::string::String;\n use std::task;\n+use std::time::Duration;\n use test::MetricMap;\n \n pub fn run(config: Config, testfile: String) {\n@@ -400,7 +401,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n             loop {\n                 //waiting 1 second for gdbserver start\n-                timer::sleep(1000);\n+                timer::sleep(Duration::milliseconds(1000));\n                 let result = task::try(proc() {\n                     tcp::TcpStream::connect(\"127.0.0.1\", 5039).unwrap();\n                 });"}, {"sha": "e041547082885dbfdccdcb2e27868d42571d16db", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -1029,6 +1029,7 @@ mod test {\n     use std::rt::task::TaskOpts;\n     use std::rt::task::Task;\n     use std::rt::local::Local;\n+    use std::time::Duration;\n \n     use {TaskState, PoolConfig, SchedPool};\n     use basic;\n@@ -1291,7 +1292,7 @@ mod test {\n         // doesn't exit before emptying the work queue\n         pool.spawn(TaskOpts::new(), proc() {\n             spawn(proc() {\n-                timer::sleep(10);\n+                timer::sleep(Duration::milliseconds(10));\n             });\n         });\n "}, {"sha": "5c91c48c55d5bf6123a62890a38f0c9f40dd01fe", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -27,13 +27,15 @@ use io::net::addrinfo::get_host_addresses;\n use io::net::ip::SocketAddr;\n use io::{IoError, ConnectionFailed, InvalidInput};\n use io::{Reader, Writer, Listener, Acceptor};\n+use io::{standard_error, TimedOut};\n use from_str::FromStr;\n use kinds::Send;\n use option::{None, Some, Option};\n use boxed::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n use rt::rtio;\n+use time::Duration;\n \n /// A structure which represents a TCP stream between a local socket and a\n /// remote socket.\n@@ -92,21 +94,28 @@ impl TcpStream {\n     }\n \n     /// Creates a TCP connection to a remote socket address, timing out after\n-    /// the specified number of milliseconds.\n+    /// the specified duration.\n     ///\n     /// This is the same as the `connect` method, except that if the timeout\n     /// specified (in milliseconds) elapses before a connection is made an error\n     /// will be returned. The error's kind will be `TimedOut`.\n     ///\n     /// Note that the `addr` argument may one day be split into a separate host\n     /// and port, similar to the API seen in `connect`.\n+    ///\n+    /// If a `timeout` with zero or negative duration is specified then\n+    /// the function returns `Err`, with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout(addr: SocketAddr,\n-                           timeout_ms: u64) -> IoResult<TcpStream> {\n+                           timeout: Duration) -> IoResult<TcpStream> {\n+        if timeout <= Duration::milliseconds(0) {\n+            return Err(standard_error(TimedOut));\n+        }\n+\n         let SocketAddr { ip, port } = addr;\n         let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n         LocalIo::maybe_raise(|io| {\n-            io.tcp_connect(addr, Some(timeout_ms)).map(TcpStream::new)\n+            io.tcp_connect(addr, Some(timeout.num_milliseconds() as u64)).map(TcpStream::new)\n         }).map_err(IoError::from_rtio_error)\n     }\n \n@@ -164,13 +173,14 @@ impl TcpStream {\n     /// # #![allow(unused_must_use)]\n     /// use std::io::timer;\n     /// use std::io::TcpStream;\n+    /// use std::time::Duration;\n     ///\n     /// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254).unwrap();\n     /// let stream2 = stream.clone();\n     ///\n     /// spawn(proc() {\n     ///     // close this stream after one second\n-    ///     timer::sleep(1000);\n+    ///     timer::sleep(Duration::seconds(1));\n     ///     let mut stream = stream2;\n     ///     stream.close_read();\n     /// });"}, {"sha": "d88af8dd30aa36ae4e0df1e75a820a923d87ed89", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -29,10 +29,12 @@ use prelude::*;\n use c_str::ToCStr;\n use clone::Clone;\n use io::{Listener, Acceptor, Reader, Writer, IoResult, IoError};\n+use io::{standard_error, TimedOut};\n use kinds::Send;\n use boxed::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n+use time::Duration;\n \n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n@@ -66,11 +68,18 @@ impl UnixStream {\n     ///\n     /// This function is similar to `connect`, except that if `timeout_ms`\n     /// elapses the function will return an error of kind `TimedOut`.\n+    ///\n+    /// If a `timeout` with zero or negative duration is specified then\n+    /// the function returns `Err`, with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument is likely to change types\"]\n     pub fn connect_timeout<P: ToCStr>(path: &P,\n-                                      timeout_ms: u64) -> IoResult<UnixStream> {\n+                                      timeout: Duration) -> IoResult<UnixStream> {\n+        if timeout <= Duration::milliseconds(0) {\n+            return Err(standard_error(TimedOut));\n+        }\n+\n         LocalIo::maybe_raise(|io| {\n-            let s = io.unix_connect(&path.to_c_str(), Some(timeout_ms));\n+            let s = io.unix_connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64));\n             s.map(|p| UnixStream { obj: p })\n         }).map_err(IoError::from_rtio_error)\n     }\n@@ -499,13 +508,25 @@ mod tests {\n \n     iotest!(fn connect_timeout_error() {\n         let addr = next_test_unix();\n-        assert!(UnixStream::connect_timeout(&addr, 100).is_err());\n+        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_err());\n     })\n \n     iotest!(fn connect_timeout_success() {\n         let addr = next_test_unix();\n         let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-        assert!(UnixStream::connect_timeout(&addr, 100).is_ok());\n+        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_ok());\n+    })\n+\n+    iotest!(fn connect_timeout_zero() {\n+        let addr = next_test_unix();\n+        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n+        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(0)).is_err());\n+    })\n+\n+    iotest!(fn connect_timeout_negative() {\n+        let addr = next_test_unix();\n+        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n+        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(-1)).is_err());\n     })\n \n     iotest!(fn close_readwrite_smoke() {"}, {"sha": "3dd4343c5f4fcd4070f05f720ec91f45ac0fc468", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -976,7 +976,7 @@ mod tests {\n                 assert!(!p.wait().unwrap().success());\n                 return\n             }\n-            timer::sleep(100);\n+            timer::sleep(Duration::milliseconds(100));\n         }\n         fail!(\"never saw the child go away\");\n     })"}, {"sha": "10739c70143cd3b610fafc39f32cb26af2358643", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -167,6 +167,7 @@ mod test_unix {\n     use comm::Empty;\n     use io::timer;\n     use super::{Listener, Interrupt};\n+    use time::Duration;\n \n     fn sigint() {\n         unsafe {\n@@ -179,7 +180,7 @@ mod test_unix {\n         let mut signal = Listener::new();\n         signal.register(Interrupt).unwrap();\n         sigint();\n-        timer::sleep(10);\n+        timer::sleep(Duration::milliseconds(10));\n         match signal.rx.recv() {\n             Interrupt => (),\n             s => fail!(\"Expected Interrupt, got {:?}\", s),\n@@ -193,7 +194,7 @@ mod test_unix {\n         s1.register(Interrupt).unwrap();\n         s2.register(Interrupt).unwrap();\n         sigint();\n-        timer::sleep(10);\n+        timer::sleep(Duration::milliseconds(10));\n         match s1.rx.recv() {\n             Interrupt => (),\n             s => fail!(\"Expected Interrupt, got {:?}\", s),\n@@ -212,7 +213,7 @@ mod test_unix {\n         s2.register(Interrupt).unwrap();\n         s2.unregister(Interrupt);\n         sigint();\n-        timer::sleep(10);\n+        timer::sleep(Duration::milliseconds(10));\n         assert_eq!(s2.rx.try_recv(), Err(Empty));\n     }\n }"}, {"sha": "079a9aef648aa77e7480eaf57bbfbe1d80c7959d", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -39,6 +39,7 @@ macro_rules! iotest (\n             use io::process::*;\n             use rt::running_on_valgrind;\n             use str;\n+            use time::Duration;\n \n             fn f() $b\n "}, {"sha": "39c6c74e45eef62c59028409b2f1875bd3d0d449", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 135, "deletions": 54, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -17,7 +17,10 @@ and create receivers which will receive notifications after a period of time.\n \n */\n \n+// FIXME: These functions take Durations but only pass ms to the backend impls.\n+\n use comm::{Receiver, Sender, channel};\n+use time::Duration;\n use io::{IoResult, IoError};\n use kinds::Send;\n use boxed::Box;\n@@ -35,15 +38,16 @@ use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n /// # fn main() {}\n /// # fn foo() {\n /// use std::io::Timer;\n+/// use std::time::Duration;\n ///\n /// let mut timer = Timer::new().unwrap();\n-/// timer.sleep(10); // block the task for awhile\n+/// timer.sleep(Duration::milliseconds(10)); // block the task for awhile\n ///\n-/// let timeout = timer.oneshot(10);\n+/// let timeout = timer.oneshot(Duration::milliseconds(10));\n /// // do some work\n /// timeout.recv(); // wait for the timeout to expire\n ///\n-/// let periodic = timer.periodic(10);\n+/// let periodic = timer.periodic(Duration::milliseconds(10));\n /// loop {\n ///     periodic.recv();\n ///     // this loop is only executed once every 10ms\n@@ -58,9 +62,10 @@ use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n /// # fn main() {}\n /// # fn foo() {\n /// use std::io::timer;\n+/// use std::time::Duration;\n ///\n /// // Put this task to sleep for 5 seconds\n-/// timer::sleep(5000);\n+/// timer::sleep(Duration::seconds(5));\n /// # }\n /// ```\n pub struct Timer {\n@@ -69,12 +74,15 @@ pub struct Timer {\n \n struct TimerCallback { tx: Sender<()> }\n \n-/// Sleep the current task for `msecs` milliseconds.\n-pub fn sleep(msecs: u64) {\n+/// Sleep the current task for the specified duration.\n+///\n+/// When provided a zero or negative `duration`, the function will\n+/// return immediately.\n+pub fn sleep(duration: Duration) {\n     let timer = Timer::new();\n     let mut timer = timer.ok().expect(\"timer::sleep: could not create a Timer\");\n \n-    timer.sleep(msecs)\n+    timer.sleep(duration)\n }\n \n impl Timer {\n@@ -87,16 +95,22 @@ impl Timer {\n         }).map_err(IoError::from_rtio_error)\n     }\n \n-    /// Blocks the current task for `msecs` milliseconds.\n+    /// Blocks the current task for the specified duration.\n     ///\n     /// Note that this function will cause any other receivers for this timer to\n     /// be invalidated (the other end will be closed).\n-    pub fn sleep(&mut self, msecs: u64) {\n-        self.obj.sleep(msecs);\n+    ///\n+    /// When provided a zero or negative `duration`, the function will\n+    /// return immediately.\n+    pub fn sleep(&mut self, duration: Duration) {\n+        // Short-circuit the timer backend for 0 duration\n+        let ms = in_ms_u64(duration);\n+        if ms == 0 { return }\n+        self.obj.sleep(ms);\n     }\n \n     /// Creates a oneshot receiver which will have a notification sent when\n-    /// `msecs` milliseconds has elapsed.\n+    /// the specified duration has elapsed.\n     ///\n     /// This does *not* block the current task, but instead returns immediately.\n     ///\n@@ -111,9 +125,10 @@ impl Timer {\n     ///\n     /// ```rust\n     /// use std::io::Timer;\n+    /// use std::time::Duration;\n     ///\n     /// let mut timer = Timer::new().unwrap();\n-    /// let ten_milliseconds = timer.oneshot(10);\n+    /// let ten_milliseconds = timer.oneshot(Duration::milliseconds(10));\n     ///\n     /// for _ in range(0u, 100) { /* do work */ }\n     ///\n@@ -123,24 +138,33 @@ impl Timer {\n     ///\n     /// ```rust\n     /// use std::io::Timer;\n+    /// use std::time::Duration;\n     ///\n     /// // Incorrect, method chaining-style:\n-    /// let mut five_ms = Timer::new().unwrap().oneshot(5);\n+    /// let mut five_ms = Timer::new().unwrap().oneshot(Duration::milliseconds(5));\n     /// // The timer object was destroyed, so this will always fail:\n     /// // five_ms.recv()\n     /// ```\n-    pub fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n+    ///\n+    /// When provided a zero or negative `duration`, the message will\n+    /// be sent immediately.\n+    pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> {\n         let (tx, rx) = channel();\n-        self.obj.oneshot(msecs, box TimerCallback { tx: tx });\n+        // Short-circuit the timer backend for 0 duration\n+        if in_ms_u64(duration) != 0 {\n+            self.obj.oneshot(in_ms_u64(duration), box TimerCallback { tx: tx });\n+        } else {\n+            tx.send(());\n+        }\n         return rx\n     }\n \n     /// Creates a receiver which will have a continuous stream of notifications\n-    /// being sent every `msecs` milliseconds.\n+    /// being sent each time the specified duration has elapsed.\n     ///\n     /// This does *not* block the current task, but instead returns\n     /// immediately. The first notification will not be received immediately,\n-    /// but rather after `msec` milliseconds have passed.\n+    /// but rather after the first duration.\n     ///\n     /// Note that this invalidates any previous receiver which has been created\n     /// by this timer, and that the returned receiver will be invalidated once\n@@ -153,9 +177,10 @@ impl Timer {\n     ///\n     /// ```rust\n     /// use std::io::Timer;\n+    /// use std::time::Duration;\n     ///\n     /// let mut timer = Timer::new().unwrap();\n-    /// let ten_milliseconds = timer.periodic(10);\n+    /// let ten_milliseconds = timer.periodic(Duration::milliseconds(10));\n     ///\n     /// for _ in range(0u, 100) { /* do work */ }\n     ///\n@@ -171,15 +196,24 @@ impl Timer {\n     ///\n     /// ```rust\n     /// use std::io::Timer;\n+    /// use std::time::Duration;\n     ///\n     /// // Incorrect, method chaining-style.\n-    /// let mut five_ms = Timer::new().unwrap().periodic(5);\n+    /// let mut five_ms = Timer::new().unwrap().periodic(Duration::milliseconds(5));\n     /// // The timer object was destroyed, so this will always fail:\n     /// // five_ms.recv()\n     /// ```\n-    pub fn periodic(&mut self, msecs: u64) -> Receiver<()> {\n+    ///\n+    /// When provided a zero or negative `duration`, the messages will\n+    /// be sent without delay.\n+    pub fn periodic(&mut self, duration: Duration) -> Receiver<()> {\n+        let ms = in_ms_u64(duration);\n+        // FIXME: The backend implementations don't ever send a message\n+        // if given a 0 ms duration. Temporarily using 1ms. It's\n+        // not clear what use a 0ms period is anyway...\n+        let ms = if ms == 0 { 1 } else { ms };\n         let (tx, rx) = channel();\n-        self.obj.period(msecs, box TimerCallback { tx: tx });\n+        self.obj.period(ms, box TimerCallback { tx: tx });\n         return rx\n     }\n }\n@@ -190,103 +224,109 @@ impl Callback for TimerCallback {\n     }\n }\n \n+fn in_ms_u64(d: Duration) -> u64 {\n+    let ms = d.num_milliseconds();\n+    if ms < 0 { return 0 };\n+    return ms as u64;\n+}\n+\n #[cfg(test)]\n mod test {\n     iotest!(fn test_io_timer_sleep_simple() {\n         let mut timer = Timer::new().unwrap();\n-        timer.sleep(1);\n+        timer.sleep(Duration::milliseconds(1));\n     })\n \n     iotest!(fn test_io_timer_sleep_oneshot() {\n         let mut timer = Timer::new().unwrap();\n-        timer.oneshot(1).recv();\n+        timer.oneshot(Duration::milliseconds(1)).recv();\n     })\n \n     iotest!(fn test_io_timer_sleep_oneshot_forget() {\n         let mut timer = Timer::new().unwrap();\n-        timer.oneshot(100000000000);\n+        timer.oneshot(Duration::milliseconds(100000000));\n     })\n \n     iotest!(fn oneshot_twice() {\n         let mut timer = Timer::new().unwrap();\n-        let rx1 = timer.oneshot(10000);\n-        let rx = timer.oneshot(1);\n+        let rx1 = timer.oneshot(Duration::milliseconds(10000));\n+        let rx = timer.oneshot(Duration::milliseconds(1));\n         rx.recv();\n         assert_eq!(rx1.recv_opt(), Err(()));\n     })\n \n     iotest!(fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot(100000000000);\n-        timer.sleep(1); // this should invalidate rx\n+        let rx = timer.oneshot(Duration::milliseconds(100000000));\n+        timer.sleep(Duration::milliseconds(1)); // this should invalidate rx\n \n         assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n     iotest!(fn test_io_timer_sleep_periodic() {\n         let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(1);\n+        let rx = timer.periodic(Duration::milliseconds(1));\n         rx.recv();\n         rx.recv();\n         rx.recv();\n     })\n \n     iotest!(fn test_io_timer_sleep_periodic_forget() {\n         let mut timer = Timer::new().unwrap();\n-        timer.periodic(100000000000);\n+        timer.periodic(Duration::milliseconds(100000000));\n     })\n \n     iotest!(fn test_io_timer_sleep_standalone() {\n-        sleep(1)\n+        sleep(Duration::milliseconds(1))\n     })\n \n     iotest!(fn oneshot() {\n         let mut timer = Timer::new().unwrap();\n \n-        let rx = timer.oneshot(1);\n+        let rx = timer.oneshot(Duration::milliseconds(1));\n         rx.recv();\n         assert!(rx.recv_opt().is_err());\n \n-        let rx = timer.oneshot(1);\n+        let rx = timer.oneshot(Duration::milliseconds(1));\n         rx.recv();\n         assert!(rx.recv_opt().is_err());\n     })\n \n     iotest!(fn override() {\n         let mut timer = Timer::new().unwrap();\n-        let orx = timer.oneshot(100);\n-        let prx = timer.periodic(100);\n-        timer.sleep(1);\n+        let orx = timer.oneshot(Duration::milliseconds(100));\n+        let prx = timer.periodic(Duration::milliseconds(100));\n+        timer.sleep(Duration::milliseconds(1));\n         assert_eq!(orx.recv_opt(), Err(()));\n         assert_eq!(prx.recv_opt(), Err(()));\n-        timer.oneshot(1).recv();\n+        timer.oneshot(Duration::milliseconds(1)).recv();\n     })\n \n     iotest!(fn period() {\n         let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(1);\n+        let rx = timer.periodic(Duration::milliseconds(1));\n         rx.recv();\n         rx.recv();\n-        let rx2 = timer.periodic(1);\n+        let rx2 = timer.periodic(Duration::milliseconds(1));\n         rx2.recv();\n         rx2.recv();\n     })\n \n     iotest!(fn sleep() {\n         let mut timer = Timer::new().unwrap();\n-        timer.sleep(1);\n-        timer.sleep(1);\n+        timer.sleep(Duration::milliseconds(1));\n+        timer.sleep(Duration::milliseconds(1));\n     })\n \n     iotest!(fn oneshot_fail() {\n         let mut timer = Timer::new().unwrap();\n-        let _rx = timer.oneshot(1);\n+        let _rx = timer.oneshot(Duration::milliseconds(1));\n         fail!();\n     } #[should_fail])\n \n     iotest!(fn period_fail() {\n         let mut timer = Timer::new().unwrap();\n-        let _rx = timer.periodic(1);\n+        let _rx = timer.periodic(Duration::milliseconds(1));\n         fail!();\n     } #[should_fail])\n \n@@ -298,7 +338,7 @@ mod test {\n     iotest!(fn closing_channel_during_drop_doesnt_kill_everything() {\n         // see issue #10375\n         let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(1000);\n+        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         spawn(proc() {\n             let _ = timer_rx.recv_opt();\n@@ -311,58 +351,99 @@ mod test {\n     iotest!(fn reset_doesnt_switch_tasks() {\n         // similar test to the one above.\n         let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(1000);\n+        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         spawn(proc() {\n             let _ = timer_rx.recv_opt();\n         });\n \n-        timer.oneshot(1);\n+        timer.oneshot(Duration::milliseconds(1));\n     })\n \n     iotest!(fn reset_doesnt_switch_tasks2() {\n         // similar test to the one above.\n         let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(1000);\n+        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         spawn(proc() {\n             let _ = timer_rx.recv_opt();\n         });\n \n-        timer.sleep(1);\n+        timer.sleep(Duration::milliseconds(1));\n     })\n \n     iotest!(fn sender_goes_away_oneshot() {\n         let rx = {\n             let mut timer = Timer::new().unwrap();\n-            timer.oneshot(1000)\n+            timer.oneshot(Duration::milliseconds(1000))\n         };\n         assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n     iotest!(fn sender_goes_away_period() {\n         let rx = {\n             let mut timer = Timer::new().unwrap();\n-            timer.periodic(1000)\n+            timer.periodic(Duration::milliseconds(1000))\n         };\n         assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n     iotest!(fn receiver_goes_away_oneshot() {\n         let mut timer1 = Timer::new().unwrap();\n-        timer1.oneshot(1);\n+        timer1.oneshot(Duration::milliseconds(1));\n         let mut timer2 = Timer::new().unwrap();\n         // while sleeping, the previous timer should fire and not have its\n         // callback do something terrible.\n-        timer2.sleep(2);\n+        timer2.sleep(Duration::milliseconds(2));\n     })\n \n     iotest!(fn receiver_goes_away_period() {\n         let mut timer1 = Timer::new().unwrap();\n-        timer1.periodic(1);\n+        timer1.periodic(Duration::milliseconds(1));\n         let mut timer2 = Timer::new().unwrap();\n         // while sleeping, the previous timer should fire and not have its\n         // callback do something terrible.\n-        timer2.sleep(2);\n+        timer2.sleep(Duration::milliseconds(2));\n+    })\n+\n+    iotest!(fn sleep_zero() {\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(Duration::milliseconds(0));\n+    })\n+\n+    iotest!(fn sleep_negative() {\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(Duration::milliseconds(-1000000));\n+    })\n+\n+    iotest!(fn oneshot_zero() {\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.oneshot(Duration::milliseconds(0));\n+        rx.recv();\n+    })\n+\n+    iotest!(fn oneshot_negative() {\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.oneshot(Duration::milliseconds(-1000000));\n+        rx.recv();\n+    })\n+\n+    iotest!(fn periodic_zero() {\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.periodic(Duration::milliseconds(0));\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n     })\n+\n+    iotest!(fn periodic_negative() {\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.periodic(Duration::milliseconds(-1000000));\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n+    })\n+\n }"}, {"sha": "103cd574e7381d0634b842b30c780cc02d5b2b88", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -233,6 +233,8 @@ pub mod ascii;\n #[cfg(not(test))]\n pub mod gc;\n \n+pub mod time;\n+\n /* Common traits */\n \n pub mod from_str;"}, {"sha": "9cace9c80ef5ad1a5dd60f1a7dcd923c32bb38c0", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -664,10 +664,11 @@ mod test {\n #[test]\n fn task_abort_no_kill_runtime() {\n     use std::io::timer;\n+    use time::Duration;\n     use mem;\n \n     let tb = TaskBuilder::new();\n     let rx = tb.try_future(proc() {});\n     mem::drop(rx);\n-    timer::sleep(1000);\n+    timer::sleep(Duration::milliseconds(1000));\n }"}, {"sha": "545d1f2aab44f386b67ed1813052328ee6b62b07", "filename": "src/libstd/time/duration.rs", "status": "added", "additions": 634, "deletions": 0, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -0,0 +1,634 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Temporal quantification\n+\n+#![experimental]\n+\n+use {fmt, i32};\n+use ops::{Add, Sub, Mul, Div, Neg};\n+use option::{Option, Some, None};\n+use num;\n+use num::{CheckedAdd, CheckedMul};\n+use result::{Result, Ok, Err};\n+\n+\n+/// `Duration`'s `days` component should have no more than this value.\n+static MIN_DAYS: i32 = i32::MIN;\n+/// `Duration`'s `days` component should have no less than this value.\n+static MAX_DAYS: i32 = i32::MAX;\n+\n+/// The number of nanoseconds in seconds.\n+static NANOS_PER_SEC: i32 = 1_000_000_000;\n+/// The number of (non-leap) seconds in days.\n+static SECS_PER_DAY: i32 = 86400;\n+\n+macro_rules! try_opt(\n+    ($e:expr) => (match $e { Some(v) => v, None => return None })\n+)\n+\n+\n+// FIXME #16466: This could be represented as (i64 seconds, u32 nanos)\n+/// ISO 8601 time duration with nanosecond precision.\n+/// This also allows for the negative duration; see individual methods for details.\n+#[deriving(PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Duration {\n+    days: i32,\n+    secs: u32,  // Always < SECS_PER_DAY\n+    nanos: u32, // Always < NANOS_PR_SECOND\n+}\n+\n+/// The minimum possible `Duration`.\n+pub static MIN: Duration = Duration { days: MIN_DAYS, secs: 0, nanos: 0 };\n+/// The maximum possible `Duration`.\n+pub static MAX: Duration = Duration { days: MAX_DAYS, secs: SECS_PER_DAY as u32 - 1,\n+                                      nanos: NANOS_PER_SEC as u32 - 1 };\n+\n+impl Duration {\n+    /// Makes a new `Duration` with given number of weeks.\n+    /// Equivalent to `Duration::new(weeks * 7, 0, 0)` with overflow checks.\n+    ///\n+    /// Fails when the duration is out of bounds.\n+    #[inline]\n+    pub fn weeks(weeks: i32) -> Duration {\n+        let days = weeks.checked_mul(&7).expect(\"Duration::weeks out of bounds\");\n+        Duration::days(days)\n+    }\n+\n+    /// Makes a new `Duration` with given number of days.\n+    /// Equivalent to `Duration::new(days, 0, 0)`.\n+    #[inline]\n+    pub fn days(days: i32) -> Duration {\n+        Duration { days: days, secs: 0, nanos: 0 }\n+    }\n+\n+    /// Makes a new `Duration` with given number of hours.\n+    /// Equivalent to `Duration::new(0, hours * 3600, 0)` with overflow checks.\n+    #[inline]\n+    pub fn hours(hours: i32) -> Duration {\n+        let (days, hours) = div_mod_floor(hours, (SECS_PER_DAY / 3600));\n+        let secs = hours * 3600;\n+        Duration { secs: secs as u32, ..Duration::days(days) }\n+    }\n+\n+    /// Makes a new `Duration` with given number of minutes.\n+    /// Equivalent to `Duration::new(0, mins * 60, 0)` with overflow checks.\n+    #[inline]\n+    pub fn minutes(mins: i32) -> Duration {\n+        let (days, mins) = div_mod_floor(mins, (SECS_PER_DAY / 60));\n+        let secs = mins * 60;\n+        Duration { secs: secs as u32, ..Duration::days(days) }\n+    }\n+\n+    /// Makes a new `Duration` with given number of seconds.\n+    /// Equivalent to `Duration::new(0, secs, 0)`.\n+    #[inline]\n+    pub fn seconds(secs: i32) -> Duration {\n+        let (days, secs) = div_mod_floor(secs, SECS_PER_DAY);\n+        Duration { secs: secs as u32, ..Duration::days(days) }\n+    }\n+\n+    /// Makes a new `Duration` with given number of milliseconds.\n+    /// Equivalent to `Duration::new(0, 0, millis * 1_000_000)` with overflow checks.\n+    #[inline]\n+    pub fn milliseconds(millis: i32) -> Duration {\n+        let (secs, millis) = div_mod_floor(millis, (NANOS_PER_SEC / 1_000_000));\n+        let nanos = millis * 1_000_000;\n+        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n+    }\n+\n+    /// Makes a new `Duration` with given number of microseconds.\n+    /// Equivalent to `Duration::new(0, 0, micros * 1_000)` with overflow checks.\n+    #[inline]\n+    pub fn microseconds(micros: i32) -> Duration {\n+        let (secs, micros) = div_mod_floor(micros, (NANOS_PER_SEC / 1_000));\n+        let nanos = micros * 1_000;\n+        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n+    }\n+\n+    /// Makes a new `Duration` with given number of nanoseconds.\n+    /// Equivalent to `Duration::new(0, 0, nanos)`.\n+    #[inline]\n+    pub fn nanoseconds(nanos: i32) -> Duration {\n+        let (secs, nanos) = div_mod_floor(nanos, NANOS_PER_SEC);\n+        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n+    }\n+\n+    /// Returns a tuple of the number of days, (non-leap) seconds and\n+    /// nanoseconds in the duration.  Note that the number of seconds\n+    /// and nanoseconds are always positive, so that for example\n+    /// `-Duration::seconds(3)` has -1 days and 86,397 seconds.\n+    #[inline]\n+    fn to_tuple_64(&self) -> (i64, u32, u32) {\n+        (self.days as i64, self.secs, self.nanos)\n+    }\n+\n+    /// Negates the duration and returns a tuple like `to_tuple`.\n+    /// This does not overflow and thus is internally used for several methods.\n+    fn to_negated_tuple_64(&self) -> (i64, u32, u32) {\n+        let mut days = -(self.days as i64);\n+        let mut secs = -(self.secs as i32);\n+        let mut nanos = -(self.nanos as i32);\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        if secs < 0 {\n+            secs += SECS_PER_DAY;\n+            days -= 1;\n+        }\n+        (days, secs as u32, nanos as u32)\n+    }\n+\n+    /// Returns the total number of whole weeks in the duration.\n+    #[inline]\n+    pub fn num_weeks(&self) -> i32 {\n+        self.num_days() / 7\n+    }\n+\n+    /// Returns the total number of whole days in the duration.\n+    pub fn num_days(&self) -> i32 {\n+        if self.days < 0 {\n+            let negated = -*self;\n+            -negated.days\n+        } else {\n+            self.days\n+        }\n+    }\n+\n+    /// Returns the total number of whole hours in the duration.\n+    #[inline]\n+    pub fn num_hours(&self) -> i64 {\n+        self.num_seconds() / 3600\n+    }\n+\n+    /// Returns the total number of whole minutes in the duration.\n+    #[inline]\n+    pub fn num_minutes(&self) -> i64 {\n+        self.num_seconds() / 60\n+    }\n+\n+    /// Returns the total number of whole seconds in the duration.\n+    pub fn num_seconds(&self) -> i64 {\n+        // cannot overflow, 2^32 * 86400 < 2^64\n+        fn secs((days, secs, _): (i64, u32, u32)) -> i64 {\n+            days as i64 * SECS_PER_DAY as i64 + secs as i64\n+        }\n+        if self.days < 0 {-secs(self.to_negated_tuple_64())} else {secs(self.to_tuple_64())}\n+    }\n+\n+    /// Returns the total number of whole milliseconds in the duration.\n+    pub fn num_milliseconds(&self) -> i64 {\n+        // cannot overflow, 2^32 * 86400 * 1000 < 2^64\n+        fn millis((days, secs, nanos): (i64, u32, u32)) -> i64 {\n+            static MILLIS_PER_SEC: i64 = 1_000;\n+            static NANOS_PER_MILLI: i64 = 1_000_000;\n+            (days as i64 * MILLIS_PER_SEC * SECS_PER_DAY as i64 +\n+             secs as i64 * MILLIS_PER_SEC +\n+             nanos as i64 / NANOS_PER_MILLI)\n+        }\n+        if self.days < 0 {-millis(self.to_negated_tuple_64())} else {millis(self.to_tuple_64())}\n+    }\n+\n+    /// Returns the total number of whole microseconds in the duration,\n+    /// or `None` on the overflow (exceeding 2^63 microseconds in either directions).\n+    pub fn num_microseconds(&self) -> Option<i64> {\n+        fn micros((days, secs, nanos): (i64, u32, u32)) -> Option<i64> {\n+            static MICROS_PER_SEC: i64 = 1_000_000;\n+            static MICROS_PER_DAY: i64 = MICROS_PER_SEC * SECS_PER_DAY as i64;\n+            static NANOS_PER_MICRO: i64 = 1_000;\n+            let nmicros = try_opt!((days as i64).checked_mul(&MICROS_PER_DAY));\n+            let nmicros = try_opt!(nmicros.checked_add(&(secs as i64 * MICROS_PER_SEC)));\n+            let nmicros = try_opt!(nmicros.checked_add(&(nanos as i64 / NANOS_PER_MICRO as i64)));\n+            Some(nmicros)\n+        }\n+        if self.days < 0 {\n+            // the final negation won't overflow since we start with positive numbers.\n+            micros(self.to_negated_tuple_64()).map(|micros| -micros)\n+        } else {\n+            micros(self.to_tuple_64())\n+        }\n+    }\n+\n+    /// Returns the total number of whole nanoseconds in the duration,\n+    /// or `None` on the overflow (exceeding 2^63 nanoseconds in either directions).\n+    pub fn num_nanoseconds(&self) -> Option<i64> {\n+        fn nanos((days, secs, nanos): (i64, u32, u32)) -> Option<i64> {\n+            static NANOS_PER_DAY: i64 = NANOS_PER_SEC as i64 * SECS_PER_DAY as i64;\n+            let nnanos = try_opt!((days as i64).checked_mul(&NANOS_PER_DAY));\n+            let nnanos = try_opt!(nnanos.checked_add(&(secs as i64 * NANOS_PER_SEC as i64)));\n+            let nnanos = try_opt!(nnanos.checked_add(&(nanos as i64)));\n+            Some(nnanos)\n+        }\n+        if self.days < 0 {\n+            // the final negation won't overflow since we start with positive numbers.\n+            nanos(self.to_negated_tuple_64()).map(|micros| -micros)\n+        } else {\n+            nanos(self.to_tuple_64())\n+        }\n+    }\n+}\n+\n+impl num::Bounded for Duration {\n+    #[inline] fn min_value() -> Duration { MIN }\n+    #[inline] fn max_value() -> Duration { MAX }\n+}\n+\n+impl num::Zero for Duration {\n+    #[inline]\n+    fn zero() -> Duration {\n+        Duration { days: 0, secs: 0, nanos: 0 }\n+    }\n+\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.days == 0 && self.secs == 0 && self.nanos == 0\n+    }\n+}\n+\n+impl Neg<Duration> for Duration {\n+    #[inline]\n+    fn neg(&self) -> Duration {\n+        let (days, secs, nanos) = self.to_negated_tuple_64();\n+        Duration { days: days as i32, secs: secs, nanos: nanos } // FIXME can overflow\n+    }\n+}\n+\n+impl Add<Duration,Duration> for Duration {\n+    fn add(&self, rhs: &Duration) -> Duration {\n+        let mut days = self.days + rhs.days;\n+        let mut secs = self.secs + rhs.secs;\n+        let mut nanos = self.nanos + rhs.nanos;\n+        if nanos >= NANOS_PER_SEC as u32 {\n+            nanos -= NANOS_PER_SEC as u32;\n+            secs += 1;\n+        }\n+        if secs >= SECS_PER_DAY as u32 {\n+            secs -= SECS_PER_DAY as u32;\n+            days += 1;\n+        }\n+        Duration { days: days, secs: secs, nanos: nanos }\n+    }\n+}\n+\n+impl num::CheckedAdd for Duration {\n+    fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n+        let mut days = try_opt!(self.days.checked_add(&rhs.days));\n+        let mut secs = self.secs + rhs.secs;\n+        let mut nanos = self.nanos + rhs.nanos;\n+        if nanos >= NANOS_PER_SEC as u32 {\n+            nanos -= NANOS_PER_SEC as u32;\n+            secs += 1;\n+        }\n+        if secs >= SECS_PER_DAY as u32 {\n+            secs -= SECS_PER_DAY as u32;\n+            days = try_opt!(days.checked_add(&1));\n+        }\n+        Some(Duration { days: days, secs: secs, nanos: nanos })\n+    }\n+}\n+\n+impl Sub<Duration,Duration> for Duration {\n+    fn sub(&self, rhs: &Duration) -> Duration {\n+        let mut days = self.days - rhs.days;\n+        let mut secs = self.secs as i32 - rhs.secs as i32;\n+        let mut nanos = self.nanos as i32 - rhs.nanos as i32;\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        if secs < 0 {\n+            secs += SECS_PER_DAY;\n+            days -= 1;\n+        }\n+        Duration { days: days, secs: secs as u32, nanos: nanos as u32 }\n+    }\n+}\n+\n+impl num::CheckedSub for Duration {\n+    fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n+        let mut days = try_opt!(self.days.checked_sub(&rhs.days));\n+        let mut secs = self.secs as i32 - rhs.secs as i32;\n+        let mut nanos = self.nanos as i32 - rhs.nanos as i32;\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        if secs < 0 {\n+            secs += SECS_PER_DAY;\n+            days = try_opt!(days.checked_sub(&1));\n+        }\n+        Some(Duration { days: days, secs: secs as u32, nanos: nanos as u32 })\n+    }\n+}\n+\n+impl Mul<i32,Duration> for Duration {\n+    fn mul(&self, rhs: &i32) -> Duration {\n+        /// Given `0 <= y < limit <= 2^30`,\n+        /// returns `(h,l)` such that `x * y = h * limit + l` where `0 <= l < limit`.\n+        fn mul_i64_u32_limit(x: i64, y: u32, limit: u32) -> (i64,u32) {\n+            let y = y as i64;\n+            let limit = limit as i64;\n+            let (xh, xl) = div_mod_floor_64(x, limit);\n+            let (h, l) = (xh * y, xl * y);\n+            let (h_, l) = div_rem_64(l, limit);\n+            (h + h_, l as u32)\n+        }\n+\n+        let rhs = *rhs as i64;\n+        let (secs1, nanos) = mul_i64_u32_limit(rhs, self.nanos, NANOS_PER_SEC as u32);\n+        let (days1, secs1) = div_mod_floor_64(secs1, (SECS_PER_DAY as i64));\n+        let (days2, secs2) = mul_i64_u32_limit(rhs, self.secs, SECS_PER_DAY as u32);\n+        let mut days = self.days as i64 * rhs + days1 + days2;\n+        let mut secs = secs1 as u32 + secs2;\n+        if secs >= SECS_PER_DAY as u32 {\n+            secs -= 1;\n+            days += 1;\n+        }\n+        Duration { days: days as i32, secs: secs, nanos: nanos }\n+    }\n+}\n+\n+impl Div<i32,Duration> for Duration {\n+    fn div(&self, rhs: &i32) -> Duration {\n+        let (rhs, days, secs, nanos) = if *rhs < 0 {\n+            let (days, secs, nanos) = self.to_negated_tuple_64();\n+            (-(*rhs as i64), days, secs as i64, nanos as i64)\n+        } else {\n+            (*rhs as i64, self.days as i64, self.secs as i64, self.nanos as i64)\n+        };\n+\n+        let (days, carry) = div_mod_floor_64(days, rhs);\n+        let secs = secs + carry * SECS_PER_DAY as i64;\n+        let (secs, carry) = div_mod_floor_64(secs, rhs);\n+        let nanos = nanos + carry * NANOS_PER_SEC as i64;\n+        let nanos = nanos / rhs;\n+        Duration { days: days as i32, secs: secs as u32, nanos: nanos as u32 }\n+    }\n+}\n+\n+impl fmt::Show for Duration {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let hasdate = self.days != 0;\n+        let hastime = (self.secs != 0 || self.nanos != 0) || !hasdate;\n+\n+        try!(write!(f, \"P\"));\n+        if hasdate {\n+            // technically speaking the negative part is not the valid ISO 8601,\n+            // but we need to print it anyway.\n+            try!(write!(f, \"{}D\", self.days));\n+        }\n+        if hastime {\n+            if self.nanos == 0 {\n+                try!(write!(f, \"T{}S\", self.secs));\n+            } else if self.nanos % 1_000_000 == 0 {\n+                try!(write!(f, \"T{}.{:03}S\", self.secs, self.nanos / 1_000_000));\n+            } else if self.nanos % 1_000 == 0 {\n+                try!(write!(f, \"T{}.{:06}S\", self.secs, self.nanos / 1_000));\n+            } else {\n+                try!(write!(f, \"T{}.{:09}S\", self.secs, self.nanos));\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+// Copied from libnum\n+#[inline]\n+fn div_mod_floor(this: i32, other: i32) -> (i32, i32) {\n+    (div_floor(this, other), mod_floor(this, other))\n+}\n+\n+#[inline]\n+fn div_floor(this: i32, other: i32) -> i32 {\n+    match div_rem(this, other) {\n+        (d, r) if (r > 0 && other < 0)\n+               || (r < 0 && other > 0) => d - 1,\n+        (d, _)                         => d,\n+    }\n+}\n+\n+#[inline]\n+fn mod_floor(this: i32, other: i32) -> i32 {\n+    match this % other {\n+        r if (r > 0 && other < 0)\n+          || (r < 0 && other > 0) => r + other,\n+        r                         => r,\n+    }\n+}\n+\n+#[inline]\n+fn div_rem(this: i32, other: i32) -> (i32, i32) {\n+    (this / other, this % other)\n+}\n+\n+#[inline]\n+fn div_mod_floor_64(this: i64, other: i64) -> (i64, i64) {\n+    (div_floor_64(this, other), mod_floor_64(this, other))\n+}\n+\n+#[inline]\n+fn div_floor_64(this: i64, other: i64) -> i64 {\n+    match div_rem_64(this, other) {\n+        (d, r) if (r > 0 && other < 0)\n+               || (r < 0 && other > 0) => d - 1,\n+        (d, _)                         => d,\n+    }\n+}\n+\n+#[inline]\n+fn mod_floor_64(this: i64, other: i64) -> i64 {\n+    match this % other {\n+        r if (r > 0 && other < 0)\n+          || (r < 0 && other > 0) => r + other,\n+        r                         => r,\n+    }\n+}\n+\n+#[inline]\n+fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n+    (this / other, this % other)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Duration, MIN_DAYS, MAX_DAYS, MIN, MAX};\n+    use {i32, i64};\n+    use num::{Zero, CheckedAdd, CheckedSub};\n+    use option::{Some, None};\n+    use to_string::ToString;\n+\n+    #[test]\n+    fn test_duration() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d, Zero::zero());\n+        assert!(Duration::seconds(1) != Zero::zero());\n+        assert_eq!(Duration::seconds(1) + Duration::seconds(2), Duration::seconds(3));\n+        assert_eq!(Duration::seconds(86399) + Duration::seconds(4),\n+                   Duration::days(1) + Duration::seconds(3));\n+        assert_eq!(Duration::days(10) - Duration::seconds(1000), Duration::seconds(863000));\n+        assert_eq!(Duration::days(10) - Duration::seconds(1000000), Duration::seconds(-136000));\n+        assert_eq!(Duration::days(2) + Duration::seconds(86399) + Duration::nanoseconds(1234567890),\n+                   Duration::days(3) + Duration::nanoseconds(234567890));\n+        assert_eq!(-Duration::days(3), Duration::days(-3));\n+        assert_eq!(-(Duration::days(3) + Duration::seconds(70)),\n+                   Duration::days(-4) + Duration::seconds(86400-70));\n+    }\n+\n+    #[test]\n+    fn test_duration_num_days() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_days(), 0);\n+        assert_eq!(Duration::days(1).num_days(), 1);\n+        assert_eq!(Duration::days(-1).num_days(), -1);\n+        assert_eq!(Duration::seconds(86399).num_days(), 0);\n+        assert_eq!(Duration::seconds(86401).num_days(), 1);\n+        assert_eq!(Duration::seconds(-86399).num_days(), 0);\n+        assert_eq!(Duration::seconds(-86401).num_days(), -1);\n+        assert_eq!(Duration::days(i32::MAX).num_days(), i32::MAX);\n+        assert_eq!(Duration::days(i32::MIN).num_days(), i32::MIN);\n+        assert_eq!(MAX.num_days(), MAX_DAYS);\n+        assert_eq!(MIN.num_days(), MIN_DAYS);\n+    }\n+\n+    #[test]\n+    fn test_duration_num_seconds() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_seconds(), 0);\n+        assert_eq!(Duration::seconds(1).num_seconds(), 1);\n+        assert_eq!(Duration::seconds(-1).num_seconds(), -1);\n+        assert_eq!(Duration::milliseconds(999).num_seconds(), 0);\n+        assert_eq!(Duration::milliseconds(1001).num_seconds(), 1);\n+        assert_eq!(Duration::milliseconds(-999).num_seconds(), 0);\n+        assert_eq!(Duration::milliseconds(-1001).num_seconds(), -1);\n+        assert_eq!(Duration::seconds(i32::MAX).num_seconds(), i32::MAX as i64);\n+        assert_eq!(Duration::seconds(i32::MIN).num_seconds(), i32::MIN as i64);\n+        assert_eq!(MAX.num_seconds(), (MAX_DAYS as i64 + 1) * 86400 - 1);\n+        assert_eq!(MIN.num_seconds(), MIN_DAYS as i64 * 86400);\n+    }\n+\n+    #[test]\n+    fn test_duration_num_milliseconds() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_milliseconds(), 0);\n+        assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n+        assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n+        assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n+        assert_eq!(Duration::microseconds(1001).num_milliseconds(), 1);\n+        assert_eq!(Duration::microseconds(-999).num_milliseconds(), 0);\n+        assert_eq!(Duration::microseconds(-1001).num_milliseconds(), -1);\n+        assert_eq!(Duration::milliseconds(i32::MAX).num_milliseconds(), i32::MAX as i64);\n+        assert_eq!(Duration::milliseconds(i32::MIN).num_milliseconds(), i32::MIN as i64);\n+        assert_eq!(MAX.num_milliseconds(), (MAX_DAYS as i64 + 1) * 86400_000 - 1);\n+        assert_eq!(MIN.num_milliseconds(), MIN_DAYS as i64 * 86400_000);\n+    }\n+\n+    #[test]\n+    fn test_duration_num_microseconds() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_microseconds(), Some(0));\n+        assert_eq!(Duration::microseconds(1).num_microseconds(), Some(1));\n+        assert_eq!(Duration::microseconds(-1).num_microseconds(), Some(-1));\n+        assert_eq!(Duration::nanoseconds(999).num_microseconds(), Some(0));\n+        assert_eq!(Duration::nanoseconds(1001).num_microseconds(), Some(1));\n+        assert_eq!(Duration::nanoseconds(-999).num_microseconds(), Some(0));\n+        assert_eq!(Duration::nanoseconds(-1001).num_microseconds(), Some(-1));\n+        assert_eq!(Duration::microseconds(i32::MAX).num_microseconds(), Some(i32::MAX as i64));\n+        assert_eq!(Duration::microseconds(i32::MIN).num_microseconds(), Some(i32::MIN as i64));\n+        assert_eq!(MAX.num_microseconds(), None);\n+        assert_eq!(MIN.num_microseconds(), None);\n+\n+        // overflow checks\n+        static MICROS_PER_DAY: i64 = 86400_000_000;\n+        assert_eq!(Duration::days((i64::MAX / MICROS_PER_DAY) as i32).num_microseconds(),\n+                   Some(i64::MAX / MICROS_PER_DAY * MICROS_PER_DAY));\n+        assert_eq!(Duration::days((i64::MIN / MICROS_PER_DAY) as i32).num_microseconds(),\n+                   Some(i64::MIN / MICROS_PER_DAY * MICROS_PER_DAY));\n+        assert_eq!(Duration::days((i64::MAX / MICROS_PER_DAY + 1) as i32).num_microseconds(), None);\n+        assert_eq!(Duration::days((i64::MIN / MICROS_PER_DAY - 1) as i32).num_microseconds(), None);\n+    }\n+\n+    #[test]\n+    fn test_duration_num_nanoseconds() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.num_nanoseconds(), Some(0));\n+        assert_eq!(Duration::nanoseconds(1).num_nanoseconds(), Some(1));\n+        assert_eq!(Duration::nanoseconds(-1).num_nanoseconds(), Some(-1));\n+        assert_eq!(Duration::nanoseconds(i32::MAX).num_nanoseconds(), Some(i32::MAX as i64));\n+        assert_eq!(Duration::nanoseconds(i32::MIN).num_nanoseconds(), Some(i32::MIN as i64));\n+        assert_eq!(MAX.num_nanoseconds(), None);\n+        assert_eq!(MIN.num_nanoseconds(), None);\n+\n+        // overflow checks\n+        static NANOS_PER_DAY: i64 = 86400_000_000_000;\n+        assert_eq!(Duration::days((i64::MAX / NANOS_PER_DAY) as i32).num_nanoseconds(),\n+                   Some(i64::MAX / NANOS_PER_DAY * NANOS_PER_DAY));\n+        assert_eq!(Duration::days((i64::MIN / NANOS_PER_DAY) as i32).num_nanoseconds(),\n+                   Some(i64::MIN / NANOS_PER_DAY * NANOS_PER_DAY));\n+        assert_eq!(Duration::days((i64::MAX / NANOS_PER_DAY + 1) as i32).num_nanoseconds(), None);\n+        assert_eq!(Duration::days((i64::MIN / NANOS_PER_DAY - 1) as i32).num_nanoseconds(), None);\n+    }\n+\n+    #[test]\n+    fn test_duration_checked_ops() {\n+        assert_eq!(Duration::days(MAX_DAYS).checked_add(&Duration::seconds(86399)),\n+                   Some(Duration::days(MAX_DAYS - 1) + Duration::seconds(86400+86399)));\n+        assert!(Duration::days(MAX_DAYS).checked_add(&Duration::seconds(86400)).is_none());\n+\n+        assert_eq!(Duration::days(MIN_DAYS).checked_sub(&Duration::seconds(0)),\n+                   Some(Duration::days(MIN_DAYS)));\n+        assert!(Duration::days(MIN_DAYS).checked_sub(&Duration::seconds(1)).is_none());\n+    }\n+\n+    #[test]\n+    fn test_duration_mul() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d * i32::MAX, d);\n+        assert_eq!(d * i32::MIN, d);\n+        assert_eq!(Duration::nanoseconds(1) * 0, Zero::zero());\n+        assert_eq!(Duration::nanoseconds(1) * 1, Duration::nanoseconds(1));\n+        assert_eq!(Duration::nanoseconds(1) * 1_000_000_000, Duration::seconds(1));\n+        assert_eq!(Duration::nanoseconds(1) * -1_000_000_000, -Duration::seconds(1));\n+        assert_eq!(-Duration::nanoseconds(1) * 1_000_000_000, -Duration::seconds(1));\n+        assert_eq!(Duration::nanoseconds(30) * 333_333_333,\n+                   Duration::seconds(10) - Duration::nanoseconds(10));\n+        assert_eq!((Duration::nanoseconds(1) + Duration::seconds(1) + Duration::days(1)) * 3,\n+                   Duration::nanoseconds(3) + Duration::seconds(3) + Duration::days(3));\n+    }\n+\n+    #[test]\n+    fn test_duration_div() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d / i32::MAX, d);\n+        assert_eq!(d / i32::MIN, d);\n+        assert_eq!(Duration::nanoseconds(123_456_789) / 1, Duration::nanoseconds(123_456_789));\n+        assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n+        assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n+        assert_eq!(-Duration::nanoseconds(123_456_789) / 1, -Duration::nanoseconds(123_456_789));\n+    }\n+\n+    #[test]\n+    fn test_duration_fmt() {\n+        let d: Duration = Zero::zero();\n+        assert_eq!(d.to_string(), \"PT0S\".to_string());\n+        assert_eq!(Duration::days(42).to_string(), \"P42D\".to_string());\n+        assert_eq!(Duration::days(-42).to_string(), \"P-42D\".to_string());\n+        assert_eq!(Duration::seconds(42).to_string(), \"PT42S\".to_string());\n+        assert_eq!(Duration::milliseconds(42).to_string(), \"PT0.042S\".to_string());\n+        assert_eq!(Duration::microseconds(42).to_string(), \"PT0.000042S\".to_string());\n+        assert_eq!(Duration::nanoseconds(42).to_string(), \"PT0.000000042S\".to_string());\n+        assert_eq!((Duration::days(7) + Duration::milliseconds(6543)).to_string(),\n+                   \"P7DT6.543S\".to_string());\n+\n+        // the format specifier should have no effect on `Duration`\n+        assert_eq!(format!(\"{:30}\", Duration::days(1) + Duration::milliseconds(2345)),\n+                   \"P1DT2.345S\".to_string());\n+    }\n+}"}, {"sha": "436fa5ebdea726c0111217c4b56e45eef6effce6", "filename": "src/libstd/time/mod.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Temporal quantification.\n+\n+pub use self::duration::Duration;\n+\n+pub mod duration;"}, {"sha": "e4df661b56201946dc852f7e75144b8357e12da5", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -128,10 +128,11 @@\n //!\n //! ```no_run\n //! use std::io::timer::Timer;\n+//! use std::time::Duration;\n //!\n //! let (tx, rx) = channel::<int>();\n //! let mut timer = Timer::new().unwrap();\n-//! let timeout = timer.oneshot(10000);\n+//! let timeout = timer.oneshot(Duration::seconds(10));\n //!\n //! loop {\n //!     select! {\n@@ -150,12 +151,13 @@\n //!\n //! ```no_run\n //! use std::io::timer::Timer;\n+//! use std::time::Duration;\n //!\n //! let (tx, rx) = channel::<int>();\n //! let mut timer = Timer::new().unwrap();\n //!\n //! loop {\n-//!     let timeout = timer.oneshot(5000);\n+//!     let timeout = timer.oneshot(Duration::seconds(5));\n //!\n //!     select! {\n //!         val = rx.recv() => println!(\"Received {}\", val),"}, {"sha": "9cee83a8598c752503962207f83c4dbff24e254d", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -25,6 +25,7 @@ extern crate green;\n extern crate rustuv;\n \n use std::io::{Process, Command};\n+use std::time::Duration;\n \n macro_rules! succeed( ($e:expr) => (\n     match $e { Ok(..) => {}, Err(e) => fail!(\"failure: {}\", e) }\n@@ -115,7 +116,7 @@ pub fn test_destroy_actually_kills(force: bool) {\n     // Don't let this test time out, this should be quick\n     let (tx, rx1) = channel();\n     let mut t = timer::Timer::new().unwrap();\n-    let rx2 = t.oneshot(1000);\n+    let rx2 = t.oneshot(Duration::milliseconds(1000));\n     spawn(proc() {\n         select! {\n             () = rx2.recv() => unsafe { libc::exit(1) },"}, {"sha": "e21338746be2c91ff62e99b4d1b129a1cf2776bc", "filename": "src/test/run-pass/issue-12684.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12684.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -13,6 +13,8 @@ extern crate native;\n extern crate green;\n extern crate rustuv;\n \n+use std::time::Duration;\n+\n #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n@@ -24,6 +26,6 @@ fn main() {\n \n fn customtask() {\n     let mut timer = std::io::timer::Timer::new().unwrap();\n-    let periodic = timer.periodic(10);\n+    let periodic = timer.periodic(Duration::milliseconds(10));\n     periodic.recv();\n }"}, {"sha": "6b6e770bc99a43bb802dccda18a2acca50bb1c2f", "filename": "src/test/run-pass/issue-12699.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12699.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -12,12 +12,13 @@\n extern crate native;\n \n use std::io::timer;\n+use std::time::Duration;\n \n #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n     native::start(argc, argv, main)\n }\n \n fn main() {\n-    timer::sleep(250);\n+    timer::sleep(Duration::milliseconds(250));\n }"}, {"sha": "c16319a16f2821e4b1dad17ae4a88cb8908b3b13", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -10,12 +10,13 @@\n \n use std::comm;\n use std::io::timer::Timer;\n+use std::time::Duration;\n \n pub fn main() {\n     let (tx, rx) = channel();\n     spawn(proc (){\n         let mut timer = Timer::new().unwrap();\n-        timer.sleep(10);\n+        timer.sleep(Duration::milliseconds(10));\n         tx.send(());\n     });\n     loop {"}, {"sha": "c1d93033ab6fea9ef85430d51f413c7e30c91402", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -38,6 +38,7 @@ macro_rules! iotest (\n             use std::io::net::tcp::*;\n             use std::io::test::*;\n             use std::io;\n+            use std::time::Duration;\n \n             fn f() $b\n \n@@ -72,7 +73,7 @@ iotest!(fn eventual_timeout() {\n \n     let mut v = Vec::new();\n     for _ in range(0u, 10000) {\n-        match TcpStream::connect_timeout(addr, 100) {\n+        match TcpStream::connect_timeout(addr, Duration::milliseconds(100)) {\n             Ok(e) => v.push(e),\n             Err(ref e) if e.kind == io::TimedOut => return,\n             Err(e) => fail!(\"other error: {}\", e),\n@@ -87,11 +88,22 @@ iotest!(fn timeout_success() {\n     let port = addr.port;\n     let _l = TcpListener::bind(host.as_slice(), port).unwrap().listen();\n \n-    assert!(TcpStream::connect_timeout(addr, 1000).is_ok());\n+    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(1000)).is_ok());\n })\n \n iotest!(fn timeout_error() {\n     let addr = next_test_ip4();\n \n-    assert!(TcpStream::connect_timeout(addr, 1000).is_err());\n+    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(1000)).is_err());\n })\n+\n+    iotest!(fn connect_timeout_zero() {\n+        let addr = next_test_ip4();\n+        assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(0)).is_err());\n+    })\n+\n+    iotest!(fn connect_timeout_negative() {\n+        let addr = next_test_ip4();\n+        assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(-1)).is_err());\n+    })\n+"}, {"sha": "864d005f37344a710c85e78afc514fcea1d17de5", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28b5e4588f5d78d2dab830245bc453dd666af617/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=28b5e4588f5d78d2dab830245bc453dd666af617", "patch": "@@ -23,6 +23,7 @@ extern crate debug;\n use std::io::net::tcp::{TcpListener, TcpStream};\n use std::io::{Acceptor, Listener};\n use std::task::TaskBuilder;\n+use std::time::Duration;\n \n #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n@@ -33,7 +34,7 @@ fn main() {\n     // This test has a chance to time out, try to not let it time out\n     spawn(proc() {\n         use std::io::timer;\n-        timer::sleep(30 * 1000);\n+        timer::sleep(Duration::milliseconds(30 * 1000));\n         println!(\"timed out!\");\n         unsafe { libc::exit(1) }\n     });"}]}