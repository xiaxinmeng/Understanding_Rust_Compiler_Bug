{"sha": "a15500cdf04d3809f04616239df87744166391d8", "node_id": "C_kwDOAAsO6NoAKGExNTUwMGNkZjA0ZDM4MDlmMDQ2MTYyMzlkZjg3NzQ0MTY2MzkxZDg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-02T21:07:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-02T21:07:47Z"}, "message": "Rollup merge of #100049 - lnicola:rust-analyzer-2022-08-02, r=lnicola\n\n:arrow_up: rust-analyzer\n\nr? `@ghost`", "tree": {"sha": "892d13cd327f90adb862dacd3b144ad26d9057a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/892d13cd327f90adb862dacd3b144ad26d9057a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a15500cdf04d3809f04616239df87744166391d8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi6ZIjCRBK7hj4Ov3rIwAAL6YIACO7hHspXH8Om4XxTlysw1OK\nR0MAMA14mRjXJ9k8OQYEYseFL+YcdVqV/9MfNTV9waRjtmKjMuj7N+Gj6AOeFtGP\nuRhQjU6Twd8IUqLmwTddXqBurqSkHbhl1VrvARyyubmCFzK5MP6iCLn0YSfrknfs\nOicVniJDu0ZjhfG4Sbqc4PMx9UlZtgnUcv4wdc1jjzzn3VVkJSMRo+mCN3WLH8pz\njAUDRzDAz5ChhkROLGhW/2572qeaxBztGeR5rE6GdyrkisPnz1GYy2ufr+Z3t4wl\nFN/g2+fWG4IfGqCnyMonUGWHQGubtQ0D1/TRICNG9vv3yLBo/VDIgfrfCl4BnRM=\n=o0Vq\n-----END PGP SIGNATURE-----\n", "payload": "tree 892d13cd327f90adb862dacd3b144ad26d9057a5\nparent 4fbe53f70b544a41a277c37b017a85d41ba344a0\nparent 30a370678603ce8cdc47c91a09f335533119d4dd\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1659474467 +0200\ncommitter GitHub <noreply@github.com> 1659474467 +0200\n\nRollup merge of #100049 - lnicola:rust-analyzer-2022-08-02, r=lnicola\n\n:arrow_up: rust-analyzer\n\nr? `@ghost`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a15500cdf04d3809f04616239df87744166391d8", "html_url": "https://github.com/rust-lang/rust/commit/a15500cdf04d3809f04616239df87744166391d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a15500cdf04d3809f04616239df87744166391d8/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fbe53f70b544a41a277c37b017a85d41ba344a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fbe53f70b544a41a277c37b017a85d41ba344a0", "html_url": "https://github.com/rust-lang/rust/commit/4fbe53f70b544a41a277c37b017a85d41ba344a0"}, {"sha": "30a370678603ce8cdc47c91a09f335533119d4dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a370678603ce8cdc47c91a09f335533119d4dd", "html_url": "https://github.com/rust-lang/rust/commit/30a370678603ce8cdc47c91a09f335533119d4dd"}], "stats": {"total": 1006, "additions": 765, "deletions": 241}, "files": [{"sha": "a4497f49e3c2f8c5193aea300b044251ec262463", "filename": "src/tools/rust-analyzer/.github/workflows/publish.yml", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -34,8 +34,21 @@ jobs:\n           git config --global user.email \"runner@gha.local\"\n           git config --global user.name \"Github Action\"\n           rm Cargo.lock\n+          # Fix names for crates that were published before switch to kebab-case.\n+          cargo workspaces rename --from base-db base_db\n+          cargo workspaces rename --from hir-def hir_def\n+          cargo workspaces rename --from hir-expand hir_expand\n+          cargo workspaces rename --from hir-ty hir_ty\n+          cargo workspaces rename --from ide-assists ide_assists\n+          cargo workspaces rename --from ide-completion ide_completion\n+          cargo workspaces rename --from ide-db ide_db\n+          cargo workspaces rename --from ide-diagnostics ide_diagnostics\n+          cargo workspaces rename --from ide-ssr ide_ssr\n+          cargo workspaces rename --from proc-macro-api proc_macro_api\n+          cargo workspaces rename --from proc-macro-srv proc_macro_srv\n+          cargo workspaces rename --from project-model project_model\n+          cargo workspaces rename --from test-utils test_utils\n+          cargo workspaces rename --from text-edit text_edit\n           cargo workspaces rename ra_ap_%n\n           find crates/rust-analyzer -type f -name '*.rs' -exec sed -i 's/rust_analyzer/ra_ap_rust_analyzer/g' {} +\n-          # Fix names for crates that were published before switch to kebab-case.\n-          find crates -name 'Cargo.toml' -exec sed -i \"s/ra_ap_base-db/ra_ap_base_db/g; s/ra_ap_hir-def/ra_ap_hir_def/g; s/ra_ap_hir-expand/ra_ap_hir_expand/g; s/ra_ap_hir-ty/ra_ap_hir_ty/g; s/ra_ap_ide-assists/ra_ap_ide_assists/g; s/ra_ap_ide-completion/ra_ap_ide_completion/g; s/ra_ap_ide-db/ra_ap_ide_db/g; s/ra_ap_ide-diagnostics/ra_ap_ide_diagnostics/g; s/ra_ap_ide-ssr/ra_ap_ide_ssr/g; s/ra_ap_proc-macro-api/ra_ap_proc_macro_api/g; s/ra_ap_proc-macro-srv/ra_ap_proc_macro_srv/g; s/ra_ap_project-model/ra_ap_project_model/g; s/ra_ap_test-utils/ra_ap_test_utils/g; s/ra_ap_text-edit/ra_ap_text_edit/g\" {} +\n           cargo workspaces publish --yes --force '*' --exact --no-git-commit --allow-dirty --skip-published custom 0.0.$PATCH"}, {"sha": "2b39c6f8da86bee737371f8fd86547d5ed281d11", "filename": "src/tools/rust-analyzer/crates/hir-def/src/attr.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -124,13 +124,24 @@ impl RawAttrs {\n \n     pub(crate) fn merge(&self, other: Self) -> Self {\n         // FIXME: This needs to fixup `AttrId`s\n-        match (&self.entries, &other.entries) {\n+        match (&self.entries, other.entries) {\n             (None, None) => Self::EMPTY,\n-            (Some(entries), None) | (None, Some(entries)) => {\n-                Self { entries: Some(entries.clone()) }\n-            }\n+            (None, entries @ Some(_)) => Self { entries },\n+            (Some(entries), None) => Self { entries: Some(entries.clone()) },\n             (Some(a), Some(b)) => {\n-                Self { entries: Some(a.iter().chain(b.iter()).cloned().collect()) }\n+                let last_ast_index = a.last().map_or(0, |it| it.id.ast_index + 1);\n+                Self {\n+                    entries: Some(\n+                        a.iter()\n+                            .cloned()\n+                            .chain(b.iter().map(|it| {\n+                                let mut it = it.clone();\n+                                it.id.ast_index += last_ast_index;\n+                                it\n+                            }))\n+                            .collect(),\n+                    ),\n+                }\n             }\n         }\n     }"}, {"sha": "a11a92204c15c29c788a4d134e71e681595e466c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -5,6 +5,7 @@ use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n use hir_expand::{name::Name, AstId, MacroCallId};\n+use itertools::Itertools;\n use once_cell::sync::Lazy;\n use profile::Count;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -97,15 +98,14 @@ pub(crate) enum BuiltinShadowMode {\n impl ItemScope {\n     pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n         // FIXME: shadowing\n-        let keys: FxHashSet<_> = self\n-            .types\n+        self.types\n             .keys()\n             .chain(self.values.keys())\n             .chain(self.macros.keys())\n             .chain(self.unresolved.iter())\n-            .collect();\n-\n-        keys.into_iter().map(move |name| (name, self.get(name)))\n+            .sorted()\n+            .unique()\n+            .map(move |name| (name, self.get(name)))\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {"}, {"sha": "8a6bb929c3df7bd660e2fcd5995b8e38b61bcfc0", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -1055,7 +1055,7 @@ impl DefCollector<'_> {\n         };\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|directive| {\n-            let resolver2 = |path| {\n+            let resolver = |path| {\n                 let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                     self.db,\n                     ResolveMode::Other,\n@@ -1068,7 +1068,7 @@ impl DefCollector<'_> {\n                     .take_macros()\n                     .map(|it| (it, macro_id_to_def_id(self.db, it)))\n             };\n-            let resolver = |path| resolver2(path).map(|(_, it)| it);\n+            let resolver_def_id = |path| resolver(path).map(|(_, it)| it);\n \n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n@@ -1077,7 +1077,7 @@ impl DefCollector<'_> {\n                         ast_id,\n                         *expand_to,\n                         self.def_map.krate,\n-                        &resolver,\n+                        &resolver_def_id,\n                         &mut |_err| (),\n                     );\n                     if let Ok(Ok(call_id)) = call_id {\n@@ -1093,7 +1093,7 @@ impl DefCollector<'_> {\n                         *derive_attr,\n                         *derive_pos as u32,\n                         self.def_map.krate,\n-                        &resolver2,\n+                        &resolver,\n                     );\n \n                     if let Ok((macro_id, def_id, call_id)) = id {\n@@ -1158,7 +1158,7 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n-                    let def = match resolver(path.clone()) {\n+                    let def = match resolver_def_id(path.clone()) {\n                         Some(def) if def.is_attribute() => def,\n                         _ => return true,\n                     };\n@@ -1292,7 +1292,8 @@ impl DefCollector<'_> {\n             true\n         });\n         // Attribute resolution can add unresolved macro invocations, so concatenate the lists.\n-        self.unresolved_macros.extend(macros);\n+        macros.extend(mem::take(&mut self.unresolved_macros));\n+        self.unresolved_macros = macros;\n \n         for (module_id, depth, container, macro_call_id) in resolved {\n             self.collect_macro_expansion(module_id, macro_call_id, depth, container);"}, {"sha": "a9c124b42dc2c112b3a04718f4c0d161fcb00afc", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -34,6 +34,7 @@ pub trait TyExt {\n     fn callable_sig(&self, db: &dyn HirDatabase) -> Option<CallableSig>;\n \n     fn strip_references(&self) -> &Ty;\n+    fn strip_reference(&self) -> &Ty;\n \n     /// If this is a `dyn Trait`, returns that trait.\n     fn dyn_trait(&self) -> Option<TraitId>;\n@@ -182,6 +183,10 @@ impl TyExt for Ty {\n         t\n     }\n \n+    fn strip_reference(&self) -> &Ty {\n+        self.as_reference().map_or(self, |(ty, _, _)| ty)\n+    }\n+\n     fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>> {\n         match self.kind(Interner) {\n             TyKind::OpaqueType(opaque_ty_id, subst) => {"}, {"sha": "8f984210e1176702c1ce23c865ed8aca631a4c82", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -2769,6 +2769,10 @@ impl Type {\n         self.derived(self.ty.strip_references().clone())\n     }\n \n+    pub fn strip_reference(&self) -> Type {\n+        self.derived(self.ty.strip_reference().clone())\n+    }\n+\n     pub fn is_unknown(&self) -> bool {\n         self.ty.is_unknown()\n     }"}, {"sha": "c84318b2fb8774123dbe91b69df2aae53da34547", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -324,6 +324,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_type(ty)\n     }\n \n+    pub fn resolve_trait(&self, trait_: &ast::Path) -> Option<Trait> {\n+        self.imp.resolve_trait(trait_)\n+    }\n+\n     // FIXME: Figure out a nice interface to inspect adjustments\n     pub fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n         self.imp.is_implicit_reborrow(expr)\n@@ -924,7 +928,12 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn original_ast_node<N: AstNode>(&self, node: N) -> Option<N> {\n-        self.wrap_node_infile(node).original_ast_node(self.db.upcast()).map(|it| it.value)\n+        self.wrap_node_infile(node).original_ast_node(self.db.upcast()).map(\n+            |InFile { file_id, value }| {\n+                self.cache(find_root(value.syntax()), file_id);\n+                value\n+            },\n+        )\n     }\n \n     fn diagnostics_display_range(&self, src: InFile<SyntaxNodePtr>) -> FileRange {\n@@ -1009,6 +1018,20 @@ impl<'db> SemanticsImpl<'db> {\n         Some(Type::new_with_resolver(self.db, &analyze.resolver, ty))\n     }\n \n+    fn resolve_trait(&self, path: &ast::Path) -> Option<Trait> {\n+        let analyze = self.analyze(path.syntax())?;\n+        let hygiene = hir_expand::hygiene::Hygiene::new(self.db.upcast(), analyze.file_id);\n+        let ctx = body::LowerCtx::with_hygiene(self.db.upcast(), &hygiene);\n+        let hir_path = Path::from_src(path.clone(), &ctx)?;\n+        match analyze\n+            .resolver\n+            .resolve_path_in_type_ns_fully(self.db.upcast(), hir_path.mod_path())?\n+        {\n+            TypeNs::TraitId(id) => Some(Trait { id }),\n+            _ => None,\n+        }\n+    }\n+\n     fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n         self.analyze(expr.syntax())?.is_implicit_reborrow(self.db, expr)\n     }"}, {"sha": "87f5018fb69586f44e6307cb8f2561d558d85e03", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -36,7 +36,7 @@ use crate::{\n //     pub struct Baz;\n // }\n //\n-// use foo::{Baz, Bar};\n+// use foo::{Bar, Baz};\n //\n // fn qux(bar: Bar, baz: Baz) {}\n // ```\n@@ -281,7 +281,7 @@ mod foo {\n     pub fn f() {}\n }\n \n-use foo::{Baz, Bar, f};\n+use foo::{Bar, Baz, f};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -351,7 +351,7 @@ mod foo {\n     pub fn f() {}\n }\n \n-use foo::{Baz, Bar, f};\n+use foo::{Bar, Baz, f};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -440,7 +440,7 @@ mod foo {\n     }\n }\n \n-use foo::{bar::{Baz, Bar, f}, baz::*};\n+use foo::{bar::{Bar, Baz, f}, baz::*};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -561,7 +561,7 @@ mod foo {\n \n use foo::{\n     bar::{*, f},\n-    baz::{g, qux::{q, h}}\n+    baz::{g, qux::{h, q}}\n };\n \n fn qux(bar: Bar, baz: Baz) {"}, {"sha": "80d3b925593674266776a705fadd0c4ea59f9b65", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -7,7 +7,7 @@ use ide_db::{\n     imports::insert_use::remove_path_if_in_use_stmt,\n     path_transform::PathTransform,\n     search::{FileReference, SearchScope},\n-    syntax_helpers::node_ext::expr_as_name_ref,\n+    syntax_helpers::{insert_whitespace_into_node::insert_ws_into, node_ext::expr_as_name_ref},\n     RootDatabase,\n };\n use itertools::{izip, Itertools};\n@@ -301,7 +301,16 @@ fn inline(\n     params: &[(ast::Pat, Option<ast::Type>, hir::Param)],\n     CallInfo { node, arguments, generic_arg_list }: &CallInfo,\n ) -> ast::Expr {\n-    let body = fn_body.clone_for_update();\n+    let body = if sema.hir_file_for(fn_body.syntax()).is_macro() {\n+        cov_mark::hit!(inline_call_defined_in_macro);\n+        if let Some(body) = ast::BlockExpr::cast(insert_ws_into(fn_body.syntax().clone())) {\n+            body\n+        } else {\n+            fn_body.clone_for_update()\n+        }\n+    } else {\n+        fn_body.clone_for_update()\n+    };\n     let usages_for_locals = |local| {\n         Definition::Local(local)\n             .usages(sema)\n@@ -1144,6 +1153,41 @@ fn bar() -> u32 {\n         x\n     }) + foo()\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn inline_call_defined_in_macro() {\n+        cov_mark::check!(inline_call_defined_in_macro);\n+        check_assist(\n+            inline_call,\n+            r#\"\n+macro_rules! define_foo {\n+    () => { fn foo() -> u32 {\n+        let x = 0;\n+        x\n+    } };\n+}\n+define_foo!();\n+fn bar() -> u32 {\n+    foo$0()\n+}\n+\"#,\n+            r#\"\n+macro_rules! define_foo {\n+    () => { fn foo() -> u32 {\n+        let x = 0;\n+        x\n+    } };\n+}\n+define_foo!();\n+fn bar() -> u32 {\n+    {\n+      let x = 0;\n+      x\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "6eaab48a32ba54e567f0e958f9a52d8cebbe9bbe", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -535,7 +535,7 @@ mod foo {\n     pub struct Baz;\n }\n \n-use foo::{Baz, Bar};\n+use foo::{Bar, Baz};\n \n fn qux(bar: Bar, baz: Baz) {}\n \"#####,"}, {"sha": "72579e6026aee736868f1ae64bbdc310b00b46cd", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -400,7 +400,7 @@ impl Completions {\n     ) {\n         if let PathCompletionCtx { kind: PathKind::Pat { pat_ctx }, .. } = path_ctx {\n             cov_mark::hit!(enum_variant_pattern_path);\n-            self.add_variant_pat(ctx, pat_ctx, variant, local_name);\n+            self.add_variant_pat(ctx, pat_ctx, Some(path_ctx), variant, local_name);\n             return;\n         }\n \n@@ -484,12 +484,14 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext<'_>,\n         pattern_ctx: &PatternContext,\n+        path_ctx: Option<&PathCompletionCtx>,\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n         self.add_opt(render_variant_pat(\n             RenderContext::new(ctx),\n             pattern_ctx,\n+            path_ctx,\n             variant,\n             local_name.clone(),\n             None,\n@@ -504,7 +506,14 @@ impl Completions {\n         path: hir::ModPath,\n     ) {\n         let path = Some(&path);\n-        self.add_opt(render_variant_pat(RenderContext::new(ctx), pattern_ctx, variant, None, path));\n+        self.add_opt(render_variant_pat(\n+            RenderContext::new(ctx),\n+            pattern_ctx,\n+            None,\n+            variant,\n+            None,\n+            path,\n+        ));\n     }\n \n     pub(crate) fn add_struct_pat("}, {"sha": "d9fe94cb44ee1d3d5e3d4573d5d6e696f411c67b", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -115,7 +115,7 @@ pub(crate) fn complete_attribute_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n \n     let attributes = annotated_item_kind.and_then(|kind| {"}, {"sha": "793c22630bf8959039856f2ecd9ddd126565cc1a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn complete_derive_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n }\n "}, {"sha": "5d0ddaaf2a22854e96f1029db1a14722afbe08a2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -11,7 +11,14 @@ pub(crate) fn complete_expr_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n-    &ExprCtx {\n+    expr_ctx: &ExprCtx,\n+) {\n+    let _p = profile::span(\"complete_expr_path\");\n+    if !ctx.qualifier_ctx.none() {\n+        return;\n+    }\n+\n+    let &ExprCtx {\n         in_block_expr,\n         in_loop_body,\n         after_if_expr,\n@@ -23,12 +30,7 @@ pub(crate) fn complete_expr_path(\n         ref impl_,\n         in_match_guard,\n         ..\n-    }: &ExprCtx,\n-) {\n-    let _p = profile::span(\"complete_expr_path\");\n-    if !ctx.qualifier_ctx.none() {\n-        return;\n-    }\n+    } = expr_ctx;\n \n     let wants_mut_token =\n         ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false);\n@@ -46,11 +48,32 @@ pub(crate) fn complete_expr_path(\n     };\n \n     match qualified {\n-        Qualified::Infer => ctx\n+        Qualified::TypeAnchor { ty: None, trait_: None } => ctx\n             .traits_in_scope()\n             .iter()\n             .flat_map(|&it| hir::Trait::from(it).items(ctx.sema.db))\n             .for_each(|item| add_assoc_item(acc, item)),\n+        Qualified::TypeAnchor { trait_: Some(trait_), .. } => {\n+            trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))\n+        }\n+        Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {\n+            if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                cov_mark::hit!(completes_variant_through_alias);\n+                acc.add_enum_variants(ctx, path_ctx, e);\n+            }\n+\n+            ctx.iterate_path_candidates(&ty, |item| {\n+                add_assoc_item(acc, item);\n+            });\n+\n+            // Iterate assoc types separately\n+            ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                if let hir::AssocItem::TypeAlias(ty) = item {\n+                    acc.add_type_alias(ctx, ty)\n+                }\n+                None::<()>\n+            });\n+        }\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n             // Add associated types on type parameters and `Self`.\n@@ -179,10 +202,21 @@ pub(crate) fn complete_expr_path(\n                     }\n                 }\n             }\n-            ctx.process_all_names(&mut |name, def| {\n-                if scope_def_applicable(def) {\n-                    acc.add_path_resolution(ctx, path_ctx, name, def);\n+            ctx.process_all_names(&mut |name, def| match def {\n+                ScopeDef::ModuleDef(hir::ModuleDef::Trait(t)) => {\n+                    let assocs = t.items_with_supertraits(ctx.db);\n+                    match &*assocs {\n+                        // traits with no assoc items are unusable as expressions since\n+                        // there is no associated item path that can be constructed with them\n+                        [] => (),\n+                        // FIXME: Render the assoc item with the trait qualified\n+                        &[_item] => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                        // FIXME: Append `::` to the thing here, since a trait on its own won't work\n+                        [..] => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                    }\n                 }\n+                _ if scope_def_applicable(def) => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                _ => (),\n             });\n \n             if is_func_update.is_none() {"}, {"sha": "60d05ae46b9168181d7823f660867a1b3ad36462", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -66,7 +66,7 @@ pub(crate) fn complete_item_list(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::No | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::No | Qualified::With { .. } => {}\n     }\n }\n "}, {"sha": "71d2d9d434b449f915dbad29a58c756ae591b651", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -74,7 +74,7 @@ pub(crate) fn complete_pattern(\n                 hir::ModuleDef::Variant(variant)\n                     if refutable || single_variant_enum(variant.parent_enum(ctx.db)) =>\n                 {\n-                    acc.add_variant_pat(ctx, pattern_ctx, variant, Some(name.clone()));\n+                    acc.add_variant_pat(ctx, pattern_ctx, None, variant, Some(name.clone()));\n                     true\n                 }\n                 hir::ModuleDef::Adt(hir::Adt::Enum(e)) => refutable || single_variant_enum(e),\n@@ -180,6 +180,6 @@ pub(crate) fn complete_pattern_path(\n \n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n }"}, {"sha": "8f9db2f94c204c5e78bd962c0de7e07b3a08e3f0", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -49,11 +49,27 @@ pub(crate) fn complete_type_path(\n     };\n \n     match qualified {\n-        Qualified::Infer => ctx\n+        Qualified::TypeAnchor { ty: None, trait_: None } => ctx\n             .traits_in_scope()\n             .iter()\n             .flat_map(|&it| hir::Trait::from(it).items(ctx.sema.db))\n             .for_each(|item| add_assoc_item(acc, item)),\n+        Qualified::TypeAnchor { trait_: Some(trait_), .. } => {\n+            trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))\n+        }\n+        Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {\n+            ctx.iterate_path_candidates(&ty, |item| {\n+                add_assoc_item(acc, item);\n+            });\n+\n+            // Iterate assoc types separately\n+            ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                if let hir::AssocItem::TypeAlias(ty) = item {\n+                    acc.add_type_alias(ctx, ty)\n+                }\n+                None::<()>\n+            });\n+        }\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n             // Add associated types on type parameters and `Self`."}, {"sha": "2555c34aa7477090bc7f588ae66a908990f9db34", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -115,6 +115,6 @@ pub(crate) fn complete_use_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { resolution: None, .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { resolution: None, .. } => {}\n     }\n }"}, {"sha": "5e6cf4bf9a52142d572924a5f280d5625f88f2a1", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn complete_vis_path(\n \n             acc.add_super_keyword(ctx, *super_chain_len);\n         }\n-        Qualified::Absolute | Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::Absolute | Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n         Qualified::No => {\n             if !has_in_token {\n                 cov_mark::hit!(kw_completion_in);"}, {"sha": "e35f79d2b6951e05a57c943af8eba44bb60e7f57", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -193,7 +193,10 @@ pub(super) enum Qualified {\n         super_chain_len: Option<usize>,\n     },\n     /// <_>::\n-    Infer,\n+    TypeAnchor {\n+        ty: Option<hir::Type>,\n+        trait_: Option<hir::Trait>,\n+    },\n     /// Whether the path is an absolute path\n     Absolute,\n }"}, {"sha": "22ec7cead4988cc54d33b9f8c49e6c4b34cd1d88", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 187, "deletions": 127, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -162,11 +162,52 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     /// Calculate the expected type and name of the cursor position.\n-    fn expected_type_and_name(&self) -> (Option<Type>, Option<NameOrNameRef>) {\n+    fn expected_type_and_name(\n+        &self,\n+        name_like: &ast::NameLike,\n+    ) -> (Option<Type>, Option<NameOrNameRef>) {\n         let mut node = match self.token.parent() {\n             Some(it) => it,\n             None => return (None, None),\n         };\n+\n+        let strip_refs = |mut ty: Type| match name_like {\n+            ast::NameLike::NameRef(n) => {\n+                let p = match n.syntax().parent() {\n+                    Some(it) => it,\n+                    None => return ty,\n+                };\n+                let top_syn = match_ast! {\n+                    match p {\n+                        ast::FieldExpr(e) => e\n+                            .syntax()\n+                            .ancestors()\n+                            .map_while(ast::FieldExpr::cast)\n+                            .last()\n+                            .map(|it| it.syntax().clone()),\n+                        ast::PathSegment(e) => e\n+                            .syntax()\n+                            .ancestors()\n+                            .skip(1)\n+                            .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n+                            .find_map(ast::PathExpr::cast)\n+                            .map(|it| it.syntax().clone()),\n+                        _ => None\n+                    }\n+                };\n+                let top_syn = match top_syn {\n+                    Some(it) => it,\n+                    None => return ty,\n+                };\n+                for _ in top_syn.ancestors().skip(1).map_while(ast::RefExpr::cast) {\n+                    cov_mark::hit!(expected_type_fn_param_ref);\n+                    ty = ty.strip_reference();\n+                }\n+                ty\n+            }\n+            _ => ty,\n+        };\n+\n         loop {\n             break match_ast! {\n                 match node {\n@@ -199,13 +240,9 @@ impl<'a> CompletionContext<'a> {\n                             self.token.clone(),\n                         ).map(|ap| {\n                             let name = ap.ident().map(NameOrNameRef::Name);\n-                            let ty = if has_ref(&self.token) {\n-                                cov_mark::hit!(expected_type_fn_param_ref);\n-                                ap.ty.remove_ref()\n-                            } else {\n-                                Some(ap.ty)\n-                            };\n-                            (ty, name)\n+\n+                            let ty = strip_refs(ap.ty);\n+                            (Some(ty), name)\n                         })\n                         .unwrap_or((None, None))\n                     },\n@@ -330,8 +367,6 @@ impl<'a> CompletionContext<'a> {\n             return None;\n         }\n \n-        (self.expected_type, self.expected_name) = self.expected_type_and_name();\n-\n         // Overwrite the path kind for derives\n         if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n             if let Some(ast::NameLike::NameRef(name_ref)) =\n@@ -389,6 +424,7 @@ impl<'a> CompletionContext<'a> {\n                 return Some(analysis);\n             }\n         };\n+        (self.expected_type, self.expected_name) = self.expected_type_and_name(&name_like);\n         let analysis = match name_like {\n             ast::NameLike::Lifetime(lifetime) => CompletionAnalysis::Lifetime(\n                 Self::classify_lifetime(&self.sema, original_file, lifetime)?,\n@@ -556,7 +592,7 @@ impl<'a> CompletionContext<'a> {\n             has_call_parens: false,\n             has_macro_bang: false,\n             qualified: Qualified::No,\n-            parent: path.parent_path(),\n+            parent: None,\n             path: path.clone(),\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n@@ -791,142 +827,179 @@ impl<'a> CompletionContext<'a> {\n             PathKind::Type { location: location.unwrap_or(TypeLocation::Other) }\n         };\n \n+        let mut kind_macro_call = |it: ast::MacroCall| {\n+            path_ctx.has_macro_bang = it.excl_token().is_some();\n+            let parent = it.syntax().parent()?;\n+            // Any path in an item list will be treated as a macro call by the parser\n+            let kind = match_ast! {\n+                match parent {\n+                    ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n+                    ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n+                    ast::MacroType(ty) => make_path_kind_type(ty.into()),\n+                    ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n+                    ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n+                        Some(it) => match_ast! {\n+                            match it {\n+                                ast::Trait(_) => ItemListKind::Trait,\n+                                ast::Impl(it) => if it.trait_().is_some() {\n+                                    ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n+                                } else {\n+                                    ItemListKind::Impl\n+                                },\n+                                _ => return None\n+                            }\n+                        },\n+                        None => return None,\n+                    } },\n+                    ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n+                    ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n+                    _ => return None,\n+                }\n+            };\n+            Some(kind)\n+        };\n+        let make_path_kind_attr = |meta: ast::Meta| {\n+            let attr = meta.parent_attr()?;\n+            let kind = attr.kind();\n+            let attached = attr.syntax().parent()?;\n+            let is_trailing_outer_attr = kind != AttrKind::Inner\n+                && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next)\n+                    .is_none();\n+            let annotated_item_kind =\n+                if is_trailing_outer_attr { None } else { Some(attached.kind()) };\n+            Some(PathKind::Attr { attr_ctx: AttrCtx { kind, annotated_item_kind } })\n+        };\n+\n         // Infer the path kind\n         let parent = path.syntax().parent()?;\n         let kind = match_ast! {\n-                match parent {\n-                    ast::PathType(it) => make_path_kind_type(it.into()),\n-                    ast::PathExpr(it) => {\n-                        if let Some(p) = it.syntax().parent() {\n-                            if ast::ExprStmt::can_cast(p.kind()) {\n-                                if let Some(kind) = inbetween_body_and_decl_check(p) {\n-                                    return Some(make_res(NameRefKind::Keyword(kind)));\n-                                }\n+            match parent {\n+                ast::PathType(it) => make_path_kind_type(it.into()),\n+                ast::PathExpr(it) => {\n+                    if let Some(p) = it.syntax().parent() {\n+                        if ast::ExprStmt::can_cast(p.kind()) {\n+                            if let Some(kind) = inbetween_body_and_decl_check(p) {\n+                                return Some(make_res(NameRefKind::Keyword(kind)));\n                             }\n                         }\n+                    }\n \n-                        path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+                    path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n \n-                        make_path_kind_expr(it.into())\n-                    },\n-                    ast::TupleStructPat(it) => {\n-                        path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::RecordPat(it) => {\n-                        path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::PathPat(it) => {\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::MacroCall(it) => {\n-                        // A macro call in this position is usually a result of parsing recovery, so check that\n-                        if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n-                            return Some(make_res(NameRefKind::Keyword(kind)));\n-                        }\n+                    make_path_kind_expr(it.into())\n+                },\n+                ast::TupleStructPat(it) => {\n+                    path_ctx.has_call_parens = true;\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                },\n+                ast::RecordPat(it) => {\n+                    path_ctx.has_call_parens = true;\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                },\n+                ast::PathPat(it) => {\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+                },\n+                ast::MacroCall(it) => {\n+                    // A macro call in this position is usually a result of parsing recovery, so check that\n+                    if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n+                        return Some(make_res(NameRefKind::Keyword(kind)));\n+                    }\n \n-                        path_ctx.has_macro_bang = it.excl_token().is_some();\n-                        let parent = it.syntax().parent()?;\n-                        // Any path in an item list will be treated as a macro call by the parser\n-                        match_ast! {\n-                            match parent {\n-                                ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n-                                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n-                                ast::MacroType(ty) => make_path_kind_type(ty.into()),\n-                                ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n-                                ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n-                                    Some(it) => match_ast! {\n-                                        match it {\n-                                            ast::Trait(_) => ItemListKind::Trait,\n-                                            ast::Impl(it) => if it.trait_().is_some() {\n-                                                ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n-                                            } else {\n-                                                ItemListKind::Impl\n-                                            },\n-                                            _ => return None\n-                                        }\n-                                    },\n-                                    None => return None,\n-                                } },\n-                                ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n-                                ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n-                                _ => return None,\n-                            }\n-                        }\n-                    },\n-                    ast::Meta(meta) => {\n-                        let attr = meta.parent_attr()?;\n-                        let kind = attr.kind();\n-                        let attached = attr.syntax().parent()?;\n-                        let is_trailing_outer_attr = kind != AttrKind::Inner\n-                            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n-                        let annotated_item_kind = if is_trailing_outer_attr {\n-                            None\n-                        } else {\n-                            Some(attached.kind())\n-                        };\n-                        PathKind::Attr {\n-                            attr_ctx: AttrCtx {\n-                                kind,\n-                                annotated_item_kind,\n-                            }\n+                    kind_macro_call(it)?\n+                },\n+                ast::Meta(meta) => make_path_kind_attr(meta)?,\n+                ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+                ast::UseTree(_) => PathKind::Use,\n+                // completing inside a qualifier\n+                ast::Path(parent) => {\n+                    path_ctx.parent = Some(parent.clone());\n+                    let parent = iter::successors(Some(parent), |it| it.parent_path()).last()?.syntax().parent()?;\n+                    match_ast! {\n+                        match parent {\n+                            ast::PathType(it) => make_path_kind_type(it.into()),\n+                            ast::PathExpr(it) => {\n+                                path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+\n+                                make_path_kind_expr(it.into())\n+                            },\n+                            ast::TupleStructPat(it) => {\n+                                path_ctx.has_call_parens = true;\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                            },\n+                            ast::RecordPat(it) => {\n+                                path_ctx.has_call_parens = true;\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                            },\n+                            ast::PathPat(it) => {\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+                            },\n+                            ast::MacroCall(it) => {\n+                                kind_macro_call(it)?\n+                            },\n+                            ast::Meta(meta) => make_path_kind_attr(meta)?,\n+                            ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+                            ast::UseTree(_) => PathKind::Use,\n+                            ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+                            _ => return None,\n                         }\n-                    },\n-                    ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n-                    ast::UseTree(_) => PathKind::Use,\n-                    _ => return None,\n-\n+                    }\n+                },\n+                ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+                _ => return None,\n             }\n         };\n \n         path_ctx.kind = kind;\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n         // calculate the qualifier context\n-        if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n+        if let Some((qualifier, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n             path_ctx.use_tree_parent = use_tree_parent;\n             if !use_tree_parent && segment.coloncolon_token().is_some() {\n                 path_ctx.qualified = Qualified::Absolute;\n             } else {\n-                let path = path\n+                let qualifier = qualifier\n                     .segment()\n                     .and_then(|it| find_node_in_file(original_file, &it))\n                     .map(|it| it.parent_path());\n-                if let Some(path) = path {\n-                    // `<_>::$0`\n-                    let is_infer_qualifier = path.qualifier().is_none()\n-                        && matches!(\n-                            path.segment().and_then(|it| it.kind()),\n-                            Some(ast::PathSegmentKind::Type {\n-                                type_ref: Some(ast::Type::InferType(_)),\n-                                trait_ref: None,\n-                            })\n-                        );\n+                if let Some(qualifier) = qualifier {\n+                    let type_anchor = match qualifier.segment().and_then(|it| it.kind()) {\n+                        Some(ast::PathSegmentKind::Type {\n+                            type_ref: Some(type_ref),\n+                            trait_ref,\n+                        }) if qualifier.qualifier().is_none() => Some((type_ref, trait_ref)),\n+                        _ => None,\n+                    };\n \n-                    path_ctx.qualified = if is_infer_qualifier {\n-                        Qualified::Infer\n+                    path_ctx.qualified = if let Some((ty, trait_ref)) = type_anchor {\n+                        let ty = match ty {\n+                            ast::Type::InferType(_) => None,\n+                            ty => sema.resolve_type(&ty),\n+                        };\n+                        let trait_ = trait_ref.and_then(|it| sema.resolve_trait(&it.path()?));\n+                        Qualified::TypeAnchor { ty, trait_ }\n                     } else {\n-                        let res = sema.resolve_path(&path);\n+                        let res = sema.resolve_path(&qualifier);\n \n                         // For understanding how and why super_chain_len is calculated the way it\n                         // is check the documentation at it's definition\n                         let mut segment_count = 0;\n-                        let super_count = iter::successors(Some(path.clone()), |p| p.qualifier())\n-                            .take_while(|p| {\n-                                p.segment()\n-                                    .and_then(|s| {\n-                                        segment_count += 1;\n-                                        s.super_token()\n-                                    })\n-                                    .is_some()\n-                            })\n-                            .count();\n+                        let super_count =\n+                            iter::successors(Some(qualifier.clone()), |p| p.qualifier())\n+                                .take_while(|p| {\n+                                    p.segment()\n+                                        .and_then(|s| {\n+                                            segment_count += 1;\n+                                            s.super_token()\n+                                        })\n+                                        .is_some()\n+                                })\n+                                .count();\n \n                         let super_chain_len =\n                             if segment_count > super_count { None } else { Some(super_count) };\n \n-                        Qualified::With { path, resolution: res, super_chain_len }\n+                        Qualified::With { path: qualifier, resolution: res, super_chain_len }\n                     }\n                 };\n             }\n@@ -1141,19 +1214,6 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     Some((use_tree.path()?, true))\n }\n \n-fn has_ref(token: &SyntaxToken) -> bool {\n-    let mut token = token.clone();\n-    for skip in [SyntaxKind::IDENT, SyntaxKind::WHITESPACE, T![mut]] {\n-        if token.kind() == skip {\n-            token = match token.prev_token() {\n-                Some(it) => it,\n-                None => return false,\n-            }\n-        }\n-    }\n-    token.kind() == T![&]\n-}\n-\n pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n     // oh my ...\n     (|| {"}, {"sha": "50845b3881f433953014dfa47d3ec00261806bf7", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -391,3 +391,23 @@ fn foo($0: Foo) {}\n         expect![[r#\"ty: ?, name: ?\"#]],\n     );\n }\n+\n+#[test]\n+fn expected_type_ref_prefix_on_field() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo(_: &mut i32) {}\n+struct S {\n+    field: i32,\n+}\n+\n+fn main() {\n+    let s = S {\n+        field: 100,\n+    };\n+    foo(&mut s.f$0);\n+}\n+\"#,\n+        expect![\"ty: i32, name: ?\"],\n+    );\n+}"}, {"sha": "946134b0ff95db78cb4682f847c6e4131dbf3fd4", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -1271,8 +1271,8 @@ fn main() {\n                 st S []\n                 st &mut S [type]\n                 st S []\n-                fn main() []\n                 fn foo(\u2026) []\n+                fn main() []\n             \"#]],\n         );\n         check_relevance(\n@@ -1288,8 +1288,8 @@ fn main() {\n                 lc s [type+name+local]\n                 st S [type]\n                 st S []\n-                fn main() []\n                 fn foo(\u2026) []\n+                fn main() []\n             \"#]],\n         );\n         check_relevance(\n@@ -1305,8 +1305,8 @@ fn main() {\n                 lc ssss [type+local]\n                 st S [type]\n                 st S []\n-                fn main() []\n                 fn foo(\u2026) []\n+                fn main() []\n             \"#]],\n         );\n     }\n@@ -1342,12 +1342,11 @@ fn main() {\n                 lc &t [type+local]\n                 st S []\n                 st &S [type]\n-                st T []\n                 st S []\n-                fn main() []\n+                st T []\n                 fn foo(\u2026) []\n+                fn main() []\n                 md core []\n-                tt Sized []\n             \"#]],\n         )\n     }\n@@ -1389,12 +1388,11 @@ fn main() {\n                 lc &mut t [type+local]\n                 st S []\n                 st &mut S [type]\n-                st T []\n                 st S []\n-                fn main() []\n+                st T []\n                 fn foo(\u2026) []\n+                fn main() []\n                 md core []\n-                tt Sized []\n             \"#]],\n         )\n     }\n@@ -1485,14 +1483,13 @@ fn main() {\n             expect![[r#\"\n                 st S []\n                 st &S [type]\n-                st T []\n                 st S []\n-                fn main() []\n+                st T []\n                 fn bar() []\n                 fn &bar() [type]\n                 fn foo(\u2026) []\n+                fn main() []\n                 md core []\n-                tt Sized []\n             \"#]],\n         )\n     }\n@@ -1636,8 +1633,8 @@ fn foo() {\n                 ev Foo::B [type_could_unify]\n                 fn foo() []\n                 en Foo []\n-                fn baz() []\n                 fn bar() []\n+                fn baz() []\n             \"#]],\n         );\n     }\n@@ -1727,9 +1724,9 @@ fn f() {\n }\n \"#,\n             expect![[r#\"\n-                md std []\n                 st Buffer []\n                 fn f() []\n+                md std []\n                 tt BufRead (use std::io::BufRead) [requires_import]\n                 st BufReader (use std::io::BufReader) [requires_import]\n                 st BufWriter (use std::io::BufWriter) [requires_import]"}, {"sha": "4b5535718c5dfd4027df9e1d8132db83dad9ec54", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -85,7 +85,9 @@ fn render(\n                 item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n             }\n             FuncKind::Method(DotAccess { receiver: Some(receiver), .. }, _) => {\n-                item.ref_match(ref_match, receiver.syntax().text_range().start());\n+                if let Some(original_expr) = completion.sema.original_ast_node(receiver.clone()) {\n+                    item.ref_match(ref_match, original_expr.syntax().text_range().start());\n+                }\n             }\n             _ => (),\n         }"}, {"sha": "34a384f2f7ae8cabdffbdc986101c5f71bed1936", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -6,7 +6,7 @@ use itertools::Itertools;\n use syntax::SmolStr;\n \n use crate::{\n-    context::{ParamContext, ParamKind, PatternContext},\n+    context::{ParamContext, ParamKind, PathCompletionCtx, PatternContext},\n     render::{\n         variant::{format_literal_label, visible_fields},\n         RenderContext,\n@@ -42,6 +42,7 @@ pub(crate) fn render_struct_pat(\n pub(crate) fn render_variant_pat(\n     ctx: RenderContext<'_>,\n     pattern_ctx: &PatternContext,\n+    path_ctx: Option<&PathCompletionCtx>,\n     variant: hir::Variant,\n     local_name: Option<Name>,\n     path: Option<&hir::ModPath>,\n@@ -58,9 +59,23 @@ pub(crate) fn render_variant_pat(\n             (name.to_smol_str(), name.escaped().to_smol_str())\n         }\n     };\n-    let kind = variant.kind(ctx.db());\n-    let label = format_literal_label(name.as_str(), kind);\n-    let pat = render_pat(&ctx, pattern_ctx, &escaped_name, kind, &visible_fields, fields_omitted)?;\n+\n+    let (label, pat) = match path_ctx {\n+        Some(PathCompletionCtx { has_call_parens: true, .. }) => (name, escaped_name.to_string()),\n+        _ => {\n+            let kind = variant.kind(ctx.db());\n+            let label = format_literal_label(name.as_str(), kind);\n+            let pat = render_pat(\n+                &ctx,\n+                pattern_ctx,\n+                &escaped_name,\n+                kind,\n+                &visible_fields,\n+                fields_omitted,\n+            )?;\n+            (label, pat)\n+        }\n+    };\n \n     Some(build_completion(ctx, label, pat, variant))\n }"}, {"sha": "cf826648dcf7b92426d162055248a2f7248a91c3", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -23,8 +23,6 @@ mod type_pos;\n mod use_tree;\n mod visibility;\n \n-use std::mem;\n-\n use hir::{db::DefDatabase, PrefixKind, Semantics};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n@@ -107,12 +105,9 @@ fn completion_list_with_config(\n ) -> String {\n     // filter out all but one builtintype completion for smaller test outputs\n     let items = get_all_items(config, ra_fixture, trigger_character);\n-    let mut bt_seen = false;\n     let items = items\n         .into_iter()\n-        .filter(|it| {\n-            it.kind() != CompletionItemKind::BuiltinType || !mem::replace(&mut bt_seen, true)\n-        })\n+        .filter(|it| it.kind() != CompletionItemKind::BuiltinType || it.label() == \"u32\")\n         .filter(|it| include_keywords || it.kind() != CompletionItemKind::Keyword)\n         .filter(|it| include_keywords || it.kind() != CompletionItemKind::Snippet)\n         .sorted_by_key(|it| (it.kind(), it.label().to_owned(), it.detail().map(ToOwned::to_owned)))"}, {"sha": "925081ebf66025552c5a5a1e03bbbf0c2e058176", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -44,7 +44,6 @@ fn baz() {\n             st Record\n             st Tuple\n             st Unit\n-            tt Trait\n             un Union\n             ev TupleV(\u2026)     TupleV(u32)\n             bt u32\n@@ -137,7 +136,6 @@ impl Unit {\n             st Record\n             st Tuple\n             st Unit\n-            tt Trait\n             tp TypeParam\n             un Union\n             ev TupleV(\u2026)    TupleV(u32)\n@@ -653,3 +651,22 @@ fn main() {\n         \"]],\n     );\n }\n+\n+#[test]\n+fn complete_record_expr_path() {\n+    check(\n+        r#\"\n+struct Zulu;\n+impl Zulu {\n+    fn test() -> Self { }\n+}\n+fn boi(val: Zulu) { }\n+fn main() {\n+    boi(Zulu:: $0 {});\n+}\n+\"#,\n+        expect![[r#\"\n+            fn test() fn() -> Zulu\n+        \"#]],\n+    );\n+}"}, {"sha": "30ddbe2dc6f6010caca0c48d70e718a3178c1c90", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -443,7 +443,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n-            bn TupleVariant(\u2026) TupleVariant($1)$0\n+            bn TupleVariant TupleVariant\n         \"#]],\n     );\n     check_empty(\n@@ -458,7 +458,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n-            bn RecordVariant {\u2026} RecordVariant { field$1 }$0\n+            bn RecordVariant RecordVariant\n         \"#]],\n     );\n }"}, {"sha": "f6accc68e5e80cec252e9c5c970ad819662ab81e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -167,7 +167,6 @@ fn main() {\n             st Foo\n             st Foo {\u2026}              Foo { foo1: u32, foo2: u32 }\n             tt Default\n-            tt Sized\n             bt u32\n             kw crate::\n             kw self::"}, {"sha": "033dc99c26cf0c09acfdb2efb52a073b95b2a2f2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -674,7 +674,60 @@ fn bar() -> Bar {\n         expect![[r#\"\n                 fn foo() (as Foo) fn() -> Self\n             \"#]],\n-    )\n+    );\n+}\n+\n+#[test]\n+fn type_anchor_type() {\n+    check(\n+        r#\"\n+trait Foo {\n+    fn foo() -> Self;\n+}\n+struct Bar;\n+impl Bar {\n+    fn bar() {}\n+}\n+impl Foo for Bar {\n+    fn foo() -> {\n+        Bar\n+    }\n+}\n+fn bar() -> Bar {\n+    <Bar>::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            fn bar()          fn()\n+            fn foo() (as Foo) fn() -> Self\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn type_anchor_type_trait() {\n+    check(\n+        r#\"\n+trait Foo {\n+    fn foo() -> Self;\n+}\n+struct Bar;\n+impl Bar {\n+    fn bar() {}\n+}\n+impl Foo for Bar {\n+    fn foo() -> {\n+        Bar\n+    }\n+}\n+fn bar() -> Bar {\n+    <Bar as Foo>::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            fn foo() (as Foo) fn() -> Self\n+        \"#]],\n+    );\n }\n \n #[test]"}, {"sha": "3fb49b45d9888ebb7fcac3d4e4431b3f9f596e75", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -13,7 +13,7 @@ mod html;\n #[cfg(test)]\n mod tests;\n \n-use hir::{InFile, Name, Semantics};\n+use hir::{Name, Semantics};\n use ide_db::{FxHashMap, RootDatabase};\n use syntax::{\n     ast, AstNode, AstToken, NodeOrToken, SyntaxKind::*, SyntaxNode, TextRange, WalkEvent, T,\n@@ -325,7 +325,7 @@ fn traverse(\n             Leave(NodeOrToken::Node(node)) => {\n                 // Doc comment highlighting injection, we do this when leaving the node\n                 // so that we overwrite the highlighting of the doc comment itself.\n-                inject::doc_comment(hl, sema, InFile::new(file_id.into(), &node));\n+                inject::doc_comment(hl, sema, file_id, &node);\n                 continue;\n             }\n         };"}, {"sha": "f376f9fda7a57799c0be9b774a81508a065d2893", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -5,7 +5,8 @@ use std::mem;\n use either::Either;\n use hir::{InFile, Semantics};\n use ide_db::{\n-    active_parameter::ActiveParameter, defs::Definition, rust_doc::is_rust_fence, SymbolKind,\n+    active_parameter::ActiveParameter, base_db::FileId, defs::Definition, rust_doc::is_rust_fence,\n+    SymbolKind,\n };\n use syntax::{\n     ast::{self, AstNode, IsString, QuoteOffsets},\n@@ -81,16 +82,18 @@ pub(super) fn ra_fixture(\n const RUSTDOC_FENCE_LENGTH: usize = 3;\n const RUSTDOC_FENCES: [&str; 2] = [\"```\", \"~~~\"];\n \n-/// Injection of syntax highlighting of doctests.\n+/// Injection of syntax highlighting of doctests and intra doc links.\n pub(super) fn doc_comment(\n     hl: &mut Highlights,\n     sema: &Semantics<'_, RootDatabase>,\n-    InFile { file_id: src_file_id, value: node }: InFile<&SyntaxNode>,\n+    src_file_id: FileId,\n+    node: &SyntaxNode,\n ) {\n     let (attributes, def) = match doc_attributes(sema, node) {\n         Some(it) => it,\n         None => return,\n     };\n+    let src_file_id = src_file_id.into();\n \n     // Extract intra-doc links and emit highlights for them.\n     if let Some((docs, doc_mapping)) = attributes.docs_with_rangemap(sema.db) {"}, {"sha": "8a1d69816e6882aa738d0adbd23ff062c413c454", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/test_data/highlight_module_docs_inline.html", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_inline.html", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_inline.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_inline.html?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -0,0 +1,51 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.label              { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.documentation      { color: #629755; }\n+.intra_doc_link     { font-style: italic; }\n+.injected           { opacity: 0.65 ; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.trait.unsafe       { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n+.mutable.unsafe     { color: #BC8383; text-decoration: underline; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.macro.unsafe       { color: #BC8383; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.derive             { color: #94BFF3; font-style: italic; }\n+.module             { color: #AFD8AF; }\n+.value_param        { color: #DCDCCC; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+.escape_sequence    { color: #94BFF3; }\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.control            { font-style: italic; }\n+.reference          { font-style: italic; font-weight: bold; }\n+\n+.unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n+</style>\n+<pre><code><span class=\"comment documentation\">//! </span><span class=\"struct documentation injected intra_doc_link\">[Struct]</span>\n+<span class=\"comment documentation\">//! This is an intra doc injection test for modules</span>\n+<span class=\"comment documentation\">//! </span><span class=\"struct documentation injected intra_doc_link\">[Struct]</span>\n+<span class=\"comment documentation\">//! This is an intra doc injection test for modules</span>\n+\n+<span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"struct declaration public\">Struct</span><span class=\"semicolon\">;</span>\n+</code></pre>\n\\ No newline at end of file"}, {"sha": "c4c3e3dc2606e5852b5813c76ba9c2bfb31f9b04", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/test_data/highlight_module_docs_outline.html", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_outline.html", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_outline.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_outline.html?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -0,0 +1,50 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.label              { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.documentation      { color: #629755; }\n+.intra_doc_link     { font-style: italic; }\n+.injected           { opacity: 0.65 ; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.trait.unsafe       { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n+.mutable.unsafe     { color: #BC8383; text-decoration: underline; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.macro.unsafe       { color: #BC8383; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.derive             { color: #94BFF3; font-style: italic; }\n+.module             { color: #AFD8AF; }\n+.value_param        { color: #DCDCCC; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+.escape_sequence    { color: #94BFF3; }\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.control            { font-style: italic; }\n+.reference          { font-style: italic; font-weight: bold; }\n+\n+.unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n+</style>\n+<pre><code><span class=\"comment documentation\">/// </span><span class=\"struct documentation injected intra_doc_link\">[crate::foo::Struct]</span>\n+<span class=\"comment documentation\">/// This is an intra doc injection test for modules</span>\n+<span class=\"comment documentation\">/// </span><span class=\"struct documentation injected intra_doc_link\">[crate::foo::Struct]</span>\n+<span class=\"comment documentation\">/// This is an intra doc injection test for modules</span>\n+<span class=\"keyword\">mod</span> <span class=\"module declaration\">foo</span><span class=\"semicolon\">;</span>\n+</code></pre>\n\\ No newline at end of file"}, {"sha": "99be7c6648687c7bffd7640d7a1c4736b3d8a2d6", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -915,6 +915,52 @@ fn main() {\n }\n \n #[test]\n+fn test_mod_hl_injection() {\n+    check_highlighting(\n+        r##\"\n+//- /foo.rs\n+//! [Struct]\n+//! This is an intra doc injection test for modules\n+//! [Struct]\n+//! This is an intra doc injection test for modules\n+\n+pub struct Struct;\n+//- /lib.rs crate:foo\n+/// [crate::foo::Struct]\n+/// This is an intra doc injection test for modules\n+/// [crate::foo::Struct]\n+/// This is an intra doc injection test for modules\n+mod foo;\n+\"##,\n+        expect_file![\"./test_data/highlight_module_docs_inline.html\"],\n+        false,\n+    );\n+    check_highlighting(\n+        r##\"\n+//- /lib.rs crate:foo\n+/// [crate::foo::Struct]\n+/// This is an intra doc injection test for modules\n+/// [crate::foo::Struct]\n+/// This is an intra doc injection test for modules\n+mod foo;\n+//- /foo.rs\n+//! [Struct]\n+//! This is an intra doc injection test for modules\n+//! [Struct]\n+//! This is an intra doc injection test for modules\n+\n+pub struct Struct;\n+\"##,\n+        expect_file![\"./test_data/highlight_module_docs_outline.html\"],\n+        false,\n+    );\n+}\n+\n+#[test]\n+#[cfg_attr(\n+    all(unix, not(target_pointer_width = \"64\")),\n+    ignore = \"depends on `DefaultHasher` outputs\"\n+)]\n fn test_rainbow_highlighting() {\n     check_highlighting(\n         r#\""}, {"sha": "d6a706a7cd73a82efc2dad0b97adc7ae4e9623ce", "filename": "src/tools/rust-analyzer/crates/limit/src/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -2,27 +2,36 @@\n \n #![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n \n+#[cfg(feature = \"tracking\")]\n use std::sync::atomic::AtomicUsize;\n \n /// Represents a struct used to enforce a numerical limit.\n pub struct Limit {\n     upper_bound: usize,\n-    #[allow(unused)]\n+    #[cfg(feature = \"tracking\")]\n     max: AtomicUsize,\n }\n \n impl Limit {\n     /// Creates a new limit.\n     #[inline]\n     pub const fn new(upper_bound: usize) -> Self {\n-        Self { upper_bound, max: AtomicUsize::new(0) }\n+        Self {\n+            upper_bound,\n+            #[cfg(feature = \"tracking\")]\n+            max: AtomicUsize::new(0),\n+        }\n     }\n \n     /// Creates a new limit.\n     #[inline]\n     #[cfg(feature = \"tracking\")]\n     pub const fn new_tracking(upper_bound: usize) -> Self {\n-        Self { upper_bound, max: AtomicUsize::new(1) }\n+        Self {\n+            upper_bound,\n+            #[cfg(feature = \"tracking\")]\n+            max: AtomicUsize::new(1),\n+        }\n     }\n \n     /// Gets the underlying numeric limit."}, {"sha": "8de5d33a1936d42479470854e39bee711f1916a2", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -54,7 +54,7 @@ fn path_for_qualifier(\n     mut qual: CompletedMarker,\n ) -> CompletedMarker {\n     loop {\n-        let use_tree = matches!(p.nth(2), T![*] | T!['{']);\n+        let use_tree = mode == Mode::Use && matches!(p.nth(2), T![*] | T!['{']);\n         if p.at(T![::]) && !use_tree {\n             let path = qual.precede(p);\n             p.bump(T![::]);"}, {"sha": "4c205b9cadac3abd8311f9a7c1ae4d4f113f1b63", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -39,6 +39,8 @@ pub(crate) struct ProcMacroSrv {\n     expanders: HashMap<(PathBuf, SystemTime), dylib::Expander>,\n }\n \n+const EXPANDER_STACK_SIZE: usize = 8 * 1024 * 1024;\n+\n impl ProcMacroSrv {\n     pub fn expand(&mut self, task: ExpandMacro) -> Result<FlatTree, PanicMessage> {\n         let expander = self.expander(task.lib.as_ref()).map_err(|err| {\n@@ -66,13 +68,18 @@ impl ProcMacroSrv {\n         // FIXME: replace this with std's scoped threads once they stabilize\n         // (then remove dependency on crossbeam)\n         let result = crossbeam::scope(|s| {\n-            let res = s\n+            let res = match s\n+                .builder()\n+                .stack_size(EXPANDER_STACK_SIZE)\n+                .name(task.macro_name.clone())\n                 .spawn(|_| {\n                     expander\n                         .expand(&task.macro_name, &macro_body, attributes.as_ref())\n                         .map(|it| FlatTree::new(&it))\n-                })\n-                .join();\n+                }) {\n+                Ok(handle) => handle.join(),\n+                Err(e) => std::panic::resume_unwind(Box::new(e)),\n+            };\n \n             match res {\n                 Ok(res) => res,"}, {"sha": "5d1c013c3275b2fabf86110ec16ac13dc75e0a1f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -66,7 +66,9 @@ pub fn load_workspace(\n     };\n \n     let crate_graph = ws.to_crate_graph(\n-        &mut |_, path: &AbsPath| load_proc_macro(proc_macro_client.as_ref(), path, &[]),\n+        &mut |_, path: &AbsPath| {\n+            load_proc_macro(proc_macro_client.as_ref().map_err(|e| &**e), path, &[])\n+        },\n         &mut |path: &AbsPath| {\n             let contents = loader.load_sync(path);\n             let path = vfs::VfsPath::from(path.to_path_buf());"}, {"sha": "eaab275bc68a41724f20d928d6081e2acbded763", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -303,6 +303,9 @@ impl GlobalState {\n         let files_config = self.config.files();\n         let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n+        let standalone_server_name =\n+            format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n+\n         if self.proc_macro_clients.is_empty() {\n             if let Some((path, args)) = self.config.proc_macro_srv() {\n                 self.proc_macro_clients = self\n@@ -316,10 +319,8 @@ impl GlobalState {\n                             tracing::info!(\"Found a cargo workspace...\");\n                             if let Some(sysroot) = sysroot.as_ref() {\n                                 tracing::info!(\"Found a cargo workspace with a sysroot...\");\n-                                let server_path = sysroot\n-                                    .root()\n-                                    .join(\"libexec\")\n-                                    .join(\"rust-analyzer-proc-macro-srv\");\n+                                let server_path =\n+                                    sysroot.root().join(\"libexec\").join(&standalone_server_name);\n                                 if std::fs::metadata(&server_path).is_ok() {\n                                     tracing::info!(\n                                         \"And the server exists at {}\",\n@@ -389,7 +390,10 @@ impl GlobalState {\n \n             let mut crate_graph = CrateGraph::default();\n             for (idx, ws) in self.workspaces.iter().enumerate() {\n-                let proc_macro_client = self.proc_macro_clients[idx].as_ref();\n+                let proc_macro_client = match self.proc_macro_clients.get(idx) {\n+                    Some(res) => res.as_ref().map_err(|e| &**e),\n+                    None => Err(\"Proc macros are disabled\"),\n+                };\n                 let mut load_proc_macro = move |crate_name: &str, path: &AbsPath| {\n                     load_proc_macro(\n                         proc_macro_client,\n@@ -573,7 +577,7 @@ impl SourceRootConfig {\n /// Load the proc-macros for the given lib path, replacing all expanders whose names are in `dummy_replace`\n /// with an identity dummy expander.\n pub(crate) fn load_proc_macro(\n-    server: Result<&ProcMacroServer, &String>,\n+    server: Result<&ProcMacroServer, &str>,\n     path: &AbsPath,\n     dummy_replace: &[Box<str>],\n ) -> ProcMacroLoadResult {"}, {"sha": "63309a155219e55ebec99bcfd3b416ede648df38", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -880,7 +880,6 @@ impl ForExpr {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n-    pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -890,7 +889,6 @@ pub struct IfExpr {\n impl ast::HasAttrs for IfExpr {}\n impl IfExpr {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }\n }\n \n@@ -1051,7 +1049,6 @@ pub struct WhileExpr {\n impl ast::HasAttrs for WhileExpr {}\n impl WhileExpr {\n     pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }\n-    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1170,7 +1167,6 @@ pub struct MatchGuard {\n }\n impl MatchGuard {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "bb92c51e9a90ed766bce24344f8ddeeb2337ed8c", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -806,6 +806,19 @@ impl ast::GenericParamList {\n     }\n }\n \n+impl ast::ForExpr {\n+    pub fn iterable(&self) -> Option<ast::Expr> {\n+        // If the iterable is a BlockExpr, check if the body is missing.\n+        // If it is assume the iterable is the expression that is missing instead.\n+        let mut exprs = support::children(self.syntax());\n+        let first = exprs.next();\n+        match first {\n+            Some(ast::Expr::BlockExpr(_)) => exprs.next().and(first),\n+            first => first,\n+        }\n+    }\n+}\n+\n impl ast::HasLoopBody for ast::ForExpr {\n     fn loop_body(&self) -> Option<ast::BlockExpr> {\n         let mut exprs = support::children(self.syntax());\n@@ -815,6 +828,19 @@ impl ast::HasLoopBody for ast::ForExpr {\n     }\n }\n \n+impl ast::WhileExpr {\n+    pub fn condition(&self) -> Option<ast::Expr> {\n+        // If the condition is a BlockExpr, check if the body is missing.\n+        // If it is assume the condition is the expression that is missing instead.\n+        let mut exprs = support::children(self.syntax());\n+        let first = exprs.next();\n+        match first {\n+            Some(ast::Expr::BlockExpr(_)) => exprs.next().and(first),\n+            first => first,\n+        }\n+    }\n+}\n+\n impl ast::HasLoopBody for ast::WhileExpr {\n     fn loop_body(&self) -> Option<ast::BlockExpr> {\n         let mut exprs = support::children(self.syntax());\n@@ -835,3 +861,15 @@ impl From<ast::Adt> for ast::Item {\n         }\n     }\n }\n+\n+impl ast::IfExpr {\n+    pub fn condition(&self) -> Option<ast::Expr> {\n+        support::child(&self.syntax)\n+    }\n+}\n+\n+impl ast::MatchGuard {\n+    pub fn condition(&self) -> Option<ast::Expr> {\n+        support::child(&self.syntax)\n+    }\n+}"}, {"sha": "6d2766225103f7b0aa2406a99939031a973b7274", "filename": "src/tools/rust-analyzer/crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -682,6 +682,8 @@ fn lower_rule(acc: &mut Vec<Field>, grammar: &Grammar, label: Option<&String>, r\n                     | \"value\"\n                     | \"trait\"\n                     | \"self_ty\"\n+                    | \"iterable\"\n+                    | \"condition\"\n             );\n             if manually_implemented {\n                 return;"}, {"sha": "76bbd1e91889e8267f4eb74c8fd4ed10e2ab5dd4", "filename": "src/tools/rust-analyzer/docs/dev/README.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -210,7 +210,8 @@ Release process is handled by `release`, `dist` and `promote` xtasks, `release`\n ./rust-rust-analyzer  # Note the name!\n ```\n \n-Additionally, it assumes that the remote for `rust-analyzer` is called `upstream` (I use `origin` to point to my fork).\n+The remote for `rust-analyzer` must be called `upstream` (I use `origin` to point to my fork).\n+In addition, for `xtask promote` (see below), `rust-rust-analyzer` must have a `rust-analyzer` remote pointing to this repository on GitHub.\n \n `release` calls the GitHub API calls to scrape pull request comments and categorize them in the changelog.\n This step uses the `curl` and `jq` applications, which need to be available in `PATH`.\n@@ -225,13 +226,13 @@ Release steps:\n    * push it to `upstream`. This triggers GitHub Actions which:\n      * runs `cargo xtask dist` to package binaries and VS Code extension\n      * makes a GitHub release\n-     * pushes VS Code extension to the marketplace\n+     * publishes the VS Code extension to the marketplace\n    * call the GitHub API for PR details\n    * create a new changelog in `rust-analyzer.github.io`\n 3. While the release is in progress, fill in the changelog\n 4. Commit & push the changelog\n 5. Tweet\n-6. Inside `rust-analyzer`, run `cargo xtask promote` -- this will create a PR to rust-lang/rust updating rust-analyzer's submodule.\n+6. Inside `rust-analyzer`, run `cargo xtask promote` -- this will create a PR to rust-lang/rust updating rust-analyzer's subtree.\n    Self-approve the PR.\n \n If the GitHub Actions release fails because of a transient problem like a timeout, you can re-run the job from the Actions console."}, {"sha": "17ada5156407e99b3e416303382f4b0ba0da64df", "filename": "src/tools/rust-analyzer/xtask/src/release.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15500cdf04d3809f04616239df87744166391d8/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs?ref=a15500cdf04d3809f04616239df87744166391d8", "patch": "@@ -77,18 +77,12 @@ impl flags::Promote {\n         cmd!(sh, \"git switch master\").run()?;\n         cmd!(sh, \"git fetch upstream\").run()?;\n         cmd!(sh, \"git reset --hard upstream/master\").run()?;\n-        cmd!(sh, \"git submodule update --recursive\").run()?;\n \n         let date = date_iso(sh)?;\n         let branch = format!(\"rust-analyzer-{date}\");\n         cmd!(sh, \"git switch -c {branch}\").run()?;\n-        {\n-            let _dir = sh.push_dir(\"src/tools/rust-analyzer\");\n-            cmd!(sh, \"git fetch origin\").run()?;\n-            cmd!(sh, \"git reset --hard origin/release\").run()?;\n-        }\n-        cmd!(sh, \"git add src/tools/rust-analyzer\").run()?;\n-        cmd!(sh, \"git commit -m':arrow_up: rust-analyzer'\").run()?;\n+        cmd!(sh, \"git subtree pull -P src/tools/rust-analyzer rust-analyzer master\").run()?;\n+\n         if !self.dry_run {\n             cmd!(sh, \"git push -u origin {branch}\").run()?;\n             cmd!("}]}