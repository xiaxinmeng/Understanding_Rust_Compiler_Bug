{"sha": "b6f9705804dd590ef9fa2842bae59ec7d9130f10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2Zjk3MDU4MDRkZDU5MGVmOWZhMjg0MmJhZTU5ZWM3ZDkxMzBmMTA=", "commit": {"author": {"name": "Havvy (Ryan Scheel)", "email": "ryan.havvy@gmail.com", "date": "2020-11-22T10:48:14Z"}, "committer": {"name": "Havvy (Ryan Scheel)", "email": "ryan.havvy@gmail.com", "date": "2020-11-22T11:13:27Z"}, "message": "Add test for eval order for a+=b\n\nYes, the order of evaluation *does* change depending on the types of\nthe operands. Cursed, I know.\n\nI've elected to place this test into `expr/compound-assignment` creating\nboth the `expr` directory and the `compound-assignment` directory. I\nplan in a future PR to also move the `if` directory and the loose `if`\ntests into `expr/if` and other similar cleanups of the `test/ui`\ndirectory.\n\nFuture work: Test more than just `+=`, but all operators. I don't know\nif using a macro to generate these tests cases would be okay or not,\nbut it'd be boilerplatey without it. I'm also confident you cannot\nchange the evaluation order of one operator without changing all of\nthem.\n\nFuture work: Additionally, test more than just `i32 += i32` for the\nprimitive version. I don't actually know the full set of primitive\nimplementations, but I imagine there's enough to cause a combinatorial\nexplosion with the previous future work item. Somewhere on the order of\none to two hundred individual functions.", "tree": {"sha": "ef9947aa0c55ee861677afd8cc7ebfa96f11eb78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef9947aa0c55ee861677afd8cc7ebfa96f11eb78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6f9705804dd590ef9fa2842bae59ec7d9130f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f9705804dd590ef9fa2842bae59ec7d9130f10", "html_url": "https://github.com/rust-lang/rust/commit/b6f9705804dd590ef9fa2842bae59ec7d9130f10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6f9705804dd590ef9fa2842bae59ec7d9130f10/comments", "author": {"login": "Havvy", "id": 731722, "node_id": "MDQ6VXNlcjczMTcyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/731722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Havvy", "html_url": "https://github.com/Havvy", "followers_url": "https://api.github.com/users/Havvy/followers", "following_url": "https://api.github.com/users/Havvy/following{/other_user}", "gists_url": "https://api.github.com/users/Havvy/gists{/gist_id}", "starred_url": "https://api.github.com/users/Havvy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Havvy/subscriptions", "organizations_url": "https://api.github.com/users/Havvy/orgs", "repos_url": "https://api.github.com/users/Havvy/repos", "events_url": "https://api.github.com/users/Havvy/events{/privacy}", "received_events_url": "https://api.github.com/users/Havvy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Havvy", "id": 731722, "node_id": "MDQ6VXNlcjczMTcyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/731722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Havvy", "html_url": "https://github.com/Havvy", "followers_url": "https://api.github.com/users/Havvy/followers", "following_url": "https://api.github.com/users/Havvy/following{/other_user}", "gists_url": "https://api.github.com/users/Havvy/gists{/gist_id}", "starred_url": "https://api.github.com/users/Havvy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Havvy/subscriptions", "organizations_url": "https://api.github.com/users/Havvy/orgs", "repos_url": "https://api.github.com/users/Havvy/repos", "events_url": "https://api.github.com/users/Havvy/events{/privacy}", "received_events_url": "https://api.github.com/users/Havvy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70090118c281ea7dba2e6093462d8ae0e1fa7195", "url": "https://api.github.com/repos/rust-lang/rust/commits/70090118c281ea7dba2e6093462d8ae0e1fa7195", "html_url": "https://github.com/rust-lang/rust/commit/70090118c281ea7dba2e6093462d8ae0e1fa7195"}], "stats": {"total": 76, "additions": 76, "deletions": 0}, "files": [{"sha": "658adae193e1453ac5424cb3b02c716383039f25", "filename": "src/test/ui/expr/compound-assignment/eval-order.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b6f9705804dd590ef9fa2842bae59ec7d9130f10/src%2Ftest%2Fui%2Fexpr%2Fcompound-assignment%2Feval-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f9705804dd590ef9fa2842bae59ec7d9130f10/src%2Ftest%2Fui%2Fexpr%2Fcompound-assignment%2Feval-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fcompound-assignment%2Feval-order.rs?ref=b6f9705804dd590ef9fa2842bae59ec7d9130f10", "patch": "@@ -0,0 +1,76 @@\n+// Test evaluation order of operands of the compound assignment operators\n+\n+// run-pass\n+\n+use std::ops::AddAssign;\n+\n+enum Side {\n+    Lhs,\n+    Rhs,\n+}\n+\n+// In the following tests, we place our value into a wrapper type so that we\n+// can do an element access as the outer place expression. If we just had the\n+// block expression, it'd be a value expression and not compile.\n+struct Wrapper<T>(T);\n+\n+// Evaluation order for `a op= b` where typeof(a) and typeof(b) are primitives\n+// is first `b` then `a`.\n+fn primitive_compound() {\n+    let mut side_order = vec![];\n+    let mut int = Wrapper(0);\n+\n+    {\n+        side_order.push(Side::Lhs);\n+        int\n+    }.0 += {\n+        side_order.push(Side::Rhs);\n+        0\n+    };\n+\n+    assert!(matches!(side_order[..], [Side::Rhs, Side::Lhs]));\n+}\n+\n+// Evaluation order for `a op=b` otherwise is first `a` then `b`.\n+fn generic_compound<T: AddAssign<T> + Default>() {\n+    let mut side_order = vec![];\n+    let mut add_assignable: Wrapper<T> = Wrapper(Default::default());\n+\n+    {\n+        side_order.push(Side::Lhs);\n+        add_assignable\n+    }.0 += {\n+        side_order.push(Side::Rhs);\n+        Default::default()\n+    };\n+\n+    assert!(matches!(side_order[..], [Side::Lhs, Side::Rhs]));\n+}\n+\n+fn custom_compound() {\n+    struct Custom;\n+\n+    impl AddAssign<()> for Custom {\n+        fn add_assign(&mut self, _: ()) {\n+            // this block purposely left blank\n+        }\n+    }\n+\n+    let mut side_order = vec![];\n+    let mut custom = Wrapper(Custom);\n+\n+    {\n+        side_order.push(Side::Lhs);\n+        custom\n+    }.0 += {\n+        side_order.push(Side::Rhs);\n+    };\n+\n+    assert!(matches!(side_order[..], [Side::Lhs, Side::Rhs]));\n+}\n+\n+fn main() {\n+    primitive_compound();\n+    generic_compound::<i32>();\n+    custom_compound();\n+}"}]}