{"sha": "d724d03389706e4efc72ea3865d9c2c185003fd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MjRkMDMzODk3MDZlNGVmYzcyZWEzODY1ZDljMmMxODUwMDNmZDI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-07T19:35:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-10T04:11:25Z"}, "message": "rustc: Remove `DepGraph` handling from rustc_metadata\n\nThis should now be entirely tracked through queries, so no need to have a\n`DepGraph` in the `CStore` object any more!", "tree": {"sha": "2747da3338bcde2aa4de46d03d53141052d5498e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2747da3338bcde2aa4de46d03d53141052d5498e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d724d03389706e4efc72ea3865d9c2c185003fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d724d03389706e4efc72ea3865d9c2c185003fd2", "html_url": "https://github.com/rust-lang/rust/commit/d724d03389706e4efc72ea3865d9c2c185003fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d724d03389706e4efc72ea3865d9c2c185003fd2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dead08cb331343b84564628b139b657f93548320", "url": "https://api.github.com/repos/rust-lang/rust/commits/dead08cb331343b84564628b139b657f93548320", "html_url": "https://github.com/rust-lang/rust/commit/dead08cb331343b84564628b139b657f93548320"}], "stats": {"total": 347, "additions": 102, "deletions": 245}, "files": [{"sha": "78b20a73b83c31107d09bf4592f920039c8d1197", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -294,7 +294,7 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n+    let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n@@ -574,7 +574,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n+                let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n                 let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,"}, {"sha": "8038045f762d5ea05f0fe7403c4340db41296180", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -104,7 +104,7 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n+    let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n     let sess = session::build_session_(options,\n                                        &dep_graph,\n                                        None,"}, {"sha": "603c74c2ae4c6f659a549b9f0905f5467af6df9a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -13,7 +13,7 @@\n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n use native_libs::relevant_lib;\n-use schema::{CrateRoot, Tracked};\n+use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n@@ -261,16 +261,13 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode(&metadata)\n         });\n \n-        let exported_symbols = crate_root.exported_symbols\n-                                         .map(|x| x.decode(&metadata).collect());\n+        let exported_symbols = crate_root.exported_symbols.decode(&metadata).collect();\n \n         let trait_impls = crate_root\n             .impls\n-            .map(|impls| {\n-                impls.decode(&metadata)\n-                     .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n-                     .collect()\n-            });\n+            .decode(&metadata)\n+            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n+            .collect();\n \n         let mut cmeta = cstore::CrateMetadata {\n             name,\n@@ -295,23 +292,17 @@ impl<'a> CrateLoader<'a> {\n             },\n             // Initialize this with an empty set. The field is populated below\n             // after we were able to deserialize its contents.\n-            dllimport_foreign_items: Tracked::new(FxHashSet()),\n+            dllimport_foreign_items: FxHashSet(),\n         };\n \n-        let dllimports: Tracked<FxHashSet<_>> = cmeta\n+        let dllimports: FxHashSet<_> = cmeta\n             .root\n             .native_libraries\n-            .map(|native_libraries| {\n-                let native_libraries: Vec<_> = native_libraries.decode(&cmeta)\n-                                                               .collect();\n-                native_libraries\n-                    .iter()\n-                    .filter(|lib| relevant_lib(self.sess, lib) &&\n-                                  lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n-                    .flat_map(|lib| lib.foreign_items.iter())\n-                    .map(|id| *id)\n-                    .collect()\n-            });\n+            .decode(&cmeta)\n+            .filter(|lib| relevant_lib(self.sess, lib) &&\n+                          lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n+            .flat_map(|lib| lib.foreign_items.into_iter())\n+            .collect();\n \n         cmeta.dllimport_foreign_items = dllimports;\n \n@@ -469,7 +460,6 @@ impl<'a> CrateLoader<'a> {\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n         ::std::iter::once(krate).chain(crate_root.crate_deps\n-                                                 .get_untracked()\n                                                  .decode(metadata)\n                                                  .map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n@@ -692,16 +682,14 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");\n \n-        let dep_graph = &self.sess.dep_graph;\n-\n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n-                                  data.needs_panic_runtime(dep_graph);\n-            if data.is_panic_runtime(dep_graph) {\n+                                  data.needs_panic_runtime();\n+            if data.is_panic_runtime() {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.needs_panic_runtime(dep_graph));\n+                                          &|data| data.needs_panic_runtime());\n                 runtime_found = runtime_found || data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n@@ -737,19 +725,19 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.is_panic_runtime(dep_graph) {\n+        if !data.is_panic_runtime() {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n-        if data.panic_strategy(dep_graph) != desired_strategy {\n+        if data.panic_strategy() != desired_strategy {\n             self.sess.err(&format!(\"the crate `{}` does not have the panic \\\n                                     strategy `{}`\",\n                                    name, desired_strategy.desc()));\n         }\n \n         self.sess.injected_panic_runtime.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.needs_panic_runtime(dep_graph));\n+                                  &|data| data.needs_panic_runtime());\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -844,7 +832,7 @@ impl<'a> CrateLoader<'a> {\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.is_sanitizer_runtime(&self.sess.dep_graph) {\n+                if !data.is_sanitizer_runtime() {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -865,7 +853,7 @@ impl<'a> CrateLoader<'a> {\n                                    PathKind::Crate, dep_kind);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n-            if !data.is_profiler_runtime(&self.sess.dep_graph) {\n+            if !data.is_profiler_runtime() {\n                 self.sess.err(&format!(\"the crate `profiler_builtins` is not \\\n                                         a profiler runtime\"));\n             }\n@@ -883,9 +871,8 @@ impl<'a> CrateLoader<'a> {\n         // written down in liballoc.\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n                                                       \"needs_allocator\");\n-        let dep_graph = &self.sess.dep_graph;\n         self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator(dep_graph);\n+            needs_allocator = needs_allocator || data.needs_allocator();\n         });\n         if !needs_allocator {\n             return\n@@ -917,14 +904,13 @@ impl<'a> CrateLoader<'a> {\n         // First up we check for global allocators. Look at the crate graph here\n         // and see what's a global allocator, including if we ourselves are a\n         // global allocator.\n-        let dep_graph = &self.sess.dep_graph;\n         let mut global_allocator = if has_global_allocator {\n             Some(None)\n         } else {\n             None\n         };\n         self.cstore.iter_crate_data(|_, data| {\n-            if !data.has_global_allocator(dep_graph) {\n+            if !data.has_global_allocator() {\n                 return\n             }\n             match global_allocator {\n@@ -983,12 +969,6 @@ impl<'a> CrateLoader<'a> {\n                                        DUMMY_SP,\n                                        PathKind::Crate, dep_kind);\n                 self.sess.injected_allocator.set(Some(cnum));\n-            //     self.cstore.iter_crate_data(|_, data| {\n-            //         if !data.needs_allocator(dep_graph) {\n-            //             return\n-            //         }\n-            //         data.cnum_map.borrow_mut().push(cnum);\n-            //     });\n             }\n \n             // We're not actually going to inject an allocator, we're going to\n@@ -1001,7 +981,7 @@ impl<'a> CrateLoader<'a> {\n                     attr::contains_name(&krate.attrs, \"default_lib_allocator\");\n                 self.cstore.iter_crate_data(|_, data| {\n                     if !found_lib_allocator {\n-                        if data.has_default_lib_allocator(dep_graph) {\n+                        if data.has_default_lib_allocator() {\n                             found_lib_allocator = true;\n                         }\n                     }"}, {"sha": "83a468171ccfef82b571d701757744e79787affd", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -11,11 +11,10 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use schema::{self, Tracked};\n+use schema;\n \n-use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n-use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n use rustc_back::PanicStrategy;\n@@ -78,30 +77,28 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: Rc<DefPathTable>,\n \n-    pub exported_symbols: Tracked<FxHashSet<DefIndex>>,\n+    pub exported_symbols: FxHashSet<DefIndex>,\n \n-    pub trait_impls: Tracked<FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>>,\n+    pub trait_impls: FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>,\n \n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n \n     pub proc_macros: Option<Vec<(ast::Name, Rc<SyntaxExtension>)>>,\n     // Foreign items imported from a dylib (Windows only)\n-    pub dllimport_foreign_items: Tracked<FxHashSet<DefIndex>>,\n+    pub dllimport_foreign_items: FxHashSet<DefIndex>,\n }\n \n pub struct CStore {\n-    pub dep_graph: DepGraph,\n     metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n     pub metadata_loader: Box<MetadataLoader>,\n }\n \n impl CStore {\n-    pub fn new(dep_graph: &DepGraph, metadata_loader: Box<MetadataLoader>) -> CStore {\n+    pub fn new(metadata_loader: Box<MetadataLoader>) -> CStore {\n         CStore {\n-            dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FxHashMap()),\n             extern_mod_crate_map: RefCell::new(FxHashMap()),\n             metadata_loader,\n@@ -165,13 +162,6 @@ impl CStore {\n     pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n-\n-    pub fn read_dep_node(&self, def_id: DefId) {\n-        use rustc::middle::cstore::CrateStore;\n-        let def_path_hash = self.def_path_hash(def_id);\n-        let dep_node = def_path_hash.to_dep_node(::rustc::dep_graph::DepKind::MetaData);\n-        self.dep_graph.read(dep_node);\n-    }\n }\n \n impl CrateMetadata {\n@@ -185,62 +175,50 @@ impl CrateMetadata {\n         self.root.disambiguator\n     }\n \n-    pub fn needs_allocator(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn needs_allocator(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n-    pub fn has_global_allocator(&self, dep_graph: &DepGraph) -> bool {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n-        self.root\n-            .has_global_allocator\n-            .get(dep_graph, dep_node)\n-            .clone()\n+    pub fn has_global_allocator(&self) -> bool {\n+        self.root.has_global_allocator.clone()\n     }\n \n-    pub fn has_default_lib_allocator(&self, dep_graph: &DepGraph) -> bool {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n-        self.root\n-            .has_default_lib_allocator\n-            .get(dep_graph, dep_node)\n-            .clone()\n+    pub fn has_default_lib_allocator(&self) -> bool {\n+        self.root.has_default_lib_allocator.clone()\n     }\n \n-    pub fn is_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_panic_runtime(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n-    pub fn needs_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn needs_panic_runtime(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n \n-    pub fn is_compiler_builtins(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_compiler_builtins(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"compiler_builtins\")\n     }\n \n-    pub fn is_sanitizer_runtime(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_sanitizer_runtime(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"sanitizer_runtime\")\n     }\n \n-    pub fn is_profiler_runtime(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_profiler_runtime(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"profiler_runtime\")\n     }\n \n-    pub fn is_no_builtins(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_no_builtins(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"no_builtins\")\n     }\n \n-    pub fn panic_strategy(&self, dep_graph: &DepGraph) -> PanicStrategy {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n-        self.root\n-            .panic_strategy\n-            .get(dep_graph, dep_node)\n-            .clone()\n+    pub fn panic_strategy(&self) -> PanicStrategy {\n+        self.root.panic_strategy.clone()\n     }\n }"}, {"sha": "c3742fc1d03d8fbd45b36616dc4479fddebe0116", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -27,7 +27,7 @@ use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n \n use std::any::Any;\n@@ -148,7 +148,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     lookup_deprecation_entry => {\n         cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n     }\n-    item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n+    item_attrs => { cdata.get_item_attrs(def_id.index) }\n     // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n     // This is only used by rustdoc anyway, which shouldn't have\n@@ -157,27 +157,26 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n     is_exported_symbol => {\n-        let dep_node = cdata.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n-        cdata.exported_symbols.get(&tcx.dep_graph, dep_node).contains(&def_id.index)\n+        cdata.exported_symbols.contains(&def_id.index)\n     }\n     item_body_nested_bodies => { Rc::new(cdata.item_body_nested_bodies(def_id.index)) }\n     const_is_rvalue_promotable_to_static => {\n         cdata.const_is_rvalue_promotable_to_static(def_id.index)\n     }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n-    dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats(&tcx.dep_graph)) }\n-    is_panic_runtime => { cdata.is_panic_runtime(&tcx.dep_graph) }\n-    is_compiler_builtins => { cdata.is_compiler_builtins(&tcx.dep_graph) }\n-    has_global_allocator => { cdata.has_global_allocator(&tcx.dep_graph) }\n-    is_sanitizer_runtime => { cdata.is_sanitizer_runtime(&tcx.dep_graph) }\n-    is_profiler_runtime => { cdata.is_profiler_runtime(&tcx.dep_graph) }\n-    panic_strategy => { cdata.panic_strategy(&tcx.dep_graph) }\n+    dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats()) }\n+    is_panic_runtime => { cdata.is_panic_runtime() }\n+    is_compiler_builtins => { cdata.is_compiler_builtins() }\n+    has_global_allocator => { cdata.has_global_allocator() }\n+    is_sanitizer_runtime => { cdata.is_sanitizer_runtime() }\n+    is_profiler_runtime => { cdata.is_profiler_runtime() }\n+    panic_strategy => { cdata.panic_strategy() }\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n-    is_no_builtins => { cdata.is_no_builtins(&tcx.dep_graph) }\n+    is_no_builtins => { cdata.is_no_builtins() }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n-    exported_symbols => { Rc::new(cdata.get_exported_symbols(&tcx.dep_graph)) }\n-    native_libraries => { Rc::new(cdata.get_native_libraries(&tcx.dep_graph)) }\n+    exported_symbols => { Rc::new(cdata.get_exported_symbols()) }\n+    native_libraries => { Rc::new(cdata.get_native_libraries()) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {\n             DefId { krate: def_id.krate, index }\n@@ -195,18 +194,18 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     implementations_of_trait => {\n         let mut result = vec![];\n         let filter = Some(other);\n-        cdata.get_implementations_for_trait(filter, &tcx.dep_graph, &mut result);\n+        cdata.get_implementations_for_trait(filter, &mut result);\n         Rc::new(result)\n     }\n \n     all_trait_implementations => {\n         let mut result = vec![];\n-        cdata.get_implementations_for_trait(None, &tcx.dep_graph, &mut result);\n+        cdata.get_implementations_for_trait(None, &mut result);\n         Rc::new(result)\n     }\n \n     is_dllimport_foreign_item => {\n-        cdata.is_dllimport_foreign_item(def_id.index, &tcx.dep_graph)\n+        cdata.is_dllimport_foreign_item(def_id.index)\n     }\n     visibility => { cdata.get_visibility(def_id.index) }\n     dep_kind => { cdata.dep_kind.get() }\n@@ -216,8 +215,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n         Rc::new(result)\n     }\n-    defined_lang_items => { Rc::new(cdata.get_lang_items(&tcx.dep_graph)) }\n-    missing_lang_items => { Rc::new(cdata.get_missing_lang_items(&tcx.dep_graph)) }\n+    defined_lang_items => { Rc::new(cdata.get_lang_items()) }\n+    missing_lang_items => { Rc::new(cdata.get_missing_lang_items()) }\n \n     extern_const_body => {\n         debug!(\"item_body({:?}): inlining item\", def_id);\n@@ -362,34 +361,25 @@ impl CrateStore for cstore::CStore {\n     }\n \n     fn visibility_untracked(&self, def: DefId) -> ty::Visibility {\n-        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n     fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics {\n-        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_generics(def.index)\n     }\n \n     fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem\n     {\n-        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n     fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind\n     {\n-        let data = self.get_crate_data(cnum);\n-        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n-        self.dep_graph.read(dep_node);\n-        data.dep_kind.get()\n+        self.get_crate_data(cnum).dep_kind.get()\n     }\n \n     fn export_macros_untracked(&self, cnum: CrateNum) {\n         let data = self.get_crate_data(cnum);\n-        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n-\n-        self.dep_graph.read(dep_node);\n         if data.dep_kind.get() == DepKind::UnexportedMacrosOnly {\n             data.dep_kind.set(DepKind::MacrosOnly)\n         }\n@@ -431,13 +421,11 @@ impl CrateStore for cstore::CStore {\n \n     fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>\n     {\n-        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n     fn item_children_untracked(&self, def_id: DefId, sess: &Session) -> Vec<def::Export>\n     {\n-        self.read_dep_node(def_id);\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)\n             .each_child_of_item(def_id.index, |child| result.push(child), sess);\n@@ -462,7 +450,7 @@ impl CrateStore for cstore::CStore {\n         let body = filemap_to_stream(&sess.parse_sess, filemap, None);\n \n         // Mark the attrs as used\n-        let attrs = data.get_item_attrs(id.index, &self.dep_graph);\n+        let attrs = data.get_item_attrs(id.index);\n         for attr in attrs.iter() {\n             attr::mark_used(attr);\n         }"}, {"sha": "73f1ae253cd298988588fe13934184b7ddf316a9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 49, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -13,9 +13,7 @@\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n-use rustc::dep_graph::{DepGraph, DepNode, DepKind};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n-use rustc::hir::map::definitions::GlobalMetaDataKind;\n use rustc::hir;\n \n use rustc::middle::cstore::LinkagePreference;\n@@ -402,7 +400,6 @@ impl<'a, 'tcx> MetadataBlob {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n         for (i, dep) in root.crate_deps\n-                            .get_untracked()\n                             .decode(self)\n                             .enumerate() {\n             write!(out, \"{} {}-{}\\n\", i + 1, dep.name, dep.hash)?;\n@@ -646,11 +643,9 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self, dep_graph: &DepGraph) -> Vec<(DefIndex, usize)> {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::LangItems);\n+    pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n         self.root\n             .lang_items\n-            .get(dep_graph, dep_node)\n             .decode(self)\n             .collect()\n     }\n@@ -869,18 +864,13 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self,\n-                          node_id: DefIndex,\n-                          dep_graph: &DepGraph) -> Rc<[ast::Attribute]> {\n+    pub fn get_item_attrs(&self, node_id: DefIndex) -> Rc<[ast::Attribute]> {\n         let (node_as, node_index) =\n             (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n             return Rc::new([]);\n         }\n \n-        let dep_node = self.def_path_hash(node_id).to_dep_node(DepKind::MetaData);\n-        dep_graph.read(dep_node);\n-\n         if let Some(&Some(ref val)) =\n             self.attribute_cache.borrow()[node_as].get(node_index) {\n             return val.clone();\n@@ -947,7 +937,6 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_implementations_for_trait(&self,\n                                          filter: Option<DefId>,\n-                                         dep_graph: &DepGraph,\n                                          result: &mut Vec<DefId>) {\n         // Do a reverse lookup beforehand to avoid touching the crate_num\n         // hash map in the loop below.\n@@ -958,16 +947,13 @@ impl<'a, 'tcx> CrateMetadata {\n             None => None,\n         };\n \n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Impls);\n-\n         if let Some(filter) = filter {\n             if let Some(impls) = self.trait_impls\n-                                     .get(dep_graph, dep_node)\n                                      .get(&filter) {\n                 result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n             }\n         } else {\n-            for impls in self.trait_impls.get(dep_graph, dep_node).values() {\n+            for impls in self.trait_impls.values() {\n                 result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n             }\n         }\n@@ -983,25 +969,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self,\n-                                dep_graph: &DepGraph)\n-                                -> Vec<NativeLibrary> {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::NativeLibraries);\n-        self.root\n-            .native_libraries\n-            .get(dep_graph, dep_node)\n-            .decode(self)\n-            .collect()\n+    pub fn get_native_libraries(&self) -> Vec<NativeLibrary> {\n+        self.root.native_libraries.decode(self).collect()\n     }\n \n-    pub fn get_dylib_dependency_formats(&self,\n-                                        dep_graph: &DepGraph)\n-                                        -> Vec<(CrateNum, LinkagePreference)> {\n-        let dep_node =\n-            self.metadata_dep_node(GlobalMetaDataKind::DylibDependencyFormats);\n+    pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n         self.root\n             .dylib_dependency_formats\n-            .get(dep_graph, dep_node)\n             .decode(self)\n             .enumerate()\n             .flat_map(|(i, link)| {\n@@ -1011,11 +985,9 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    pub fn get_missing_lang_items(&self, dep_graph: &DepGraph) -> Vec<lang_items::LangItem> {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::LangItemsMissing);\n+    pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n         self.root\n             .lang_items_missing\n-            .get(dep_graph, dep_node)\n             .decode(self)\n             .collect()\n     }\n@@ -1030,10 +1002,8 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_exported_symbols(&self, dep_graph: &DepGraph) -> Vec<DefId> {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n+    pub fn get_exported_symbols(&self) -> Vec<DefId> {\n         self.exported_symbols\n-            .get(dep_graph, dep_node)\n             .iter()\n             .map(|&index| self.local_def_id(index))\n             .collect()\n@@ -1065,11 +1035,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_dllimport_foreign_item(&self, id: DefIndex, dep_graph: &DepGraph) -> bool {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::NativeLibraries);\n-        self.dllimport_foreign_items\n-            .get(dep_graph, dep_node)\n-            .contains(&id)\n+    pub fn is_dllimport_foreign_item(&self, id: DefIndex) -> bool {\n+        self.dllimport_foreign_items.contains(&id)\n     }\n \n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n@@ -1221,10 +1188,4 @@ impl<'a, 'tcx> CrateMetadata {\n         *self.codemap_import_info.borrow_mut() = imported_filemaps;\n         self.codemap_import_info.borrow()\n     }\n-\n-    pub fn metadata_dep_node(&self, kind: GlobalMetaDataKind) -> DepNode {\n-        let def_index = kind.def_index(&self.def_path_table);\n-        let def_path_hash = self.def_path_table.def_path_hash(def_index);\n-        def_path_hash.to_dep_node(DepKind::MetaData)\n-    }\n }"}, {"sha": "3b07177b1b5c8b5bec3cf7488364a755a2cf9d35", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                                 def_index: DefIndex,\n                                 op: fn(&mut IsolatedEncoder<'x, 'a, 'tcx>, DATA) -> R,\n                                 data: DATA)\n-                                -> Tracked<R> {\n+                                -> R {\n         let mut entry_builder = IsolatedEncoder::new(self);\n         let ret = op(&mut entry_builder, data);\n         let (fingerprint, this) = entry_builder.finish();\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n         }\n \n-        Tracked::new(ret)\n+        ret\n     }\n \n     fn encode_info_for_items(&mut self) -> Index {\n@@ -408,9 +408,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator(),\n-            panic_strategy: Tracked::new(tcx.sess.panic_strategy()),\n-            has_global_allocator: Tracked::new(has_global_allocator),\n-            has_default_lib_allocator: Tracked::new(has_default_lib_allocator),\n+            panic_strategy: tcx.sess.panic_strategy(),\n+            has_global_allocator: has_global_allocator,\n+            has_default_lib_allocator: has_default_lib_allocator,\n             plugin_registrar_fn: tcx.sess\n                 .plugin_registrar_fn\n                 .get()"}, {"sha": "ee196d74bb8143cf19d7407262eb9f4b5d39da9c", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 10, "deletions": 60, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -32,8 +32,6 @@ use std::mem;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n                                            StableHasherResult};\n \n-use rustc::dep_graph::{DepGraph, DepNode};\n-\n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -188,75 +186,27 @@ pub enum LazyState {\n     Previous(usize),\n }\n \n-/// A `Tracked<T>` wraps a value so that one can only access it when specifying\n-/// the `DepNode` for that value. This makes it harder to forget registering\n-/// reads.\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct Tracked<T> {\n-    state: T,\n-}\n-\n-impl<T> Tracked<T> {\n-    pub fn new(state: T) -> Tracked<T> {\n-        Tracked {\n-            state,\n-        }\n-    }\n-\n-    pub fn get(&self, dep_graph: &DepGraph, dep_node: DepNode) -> &T {\n-        dep_graph.read(dep_node);\n-        &self.state\n-    }\n-\n-    pub fn get_untracked(&self) -> &T {\n-        &self.state\n-    }\n-\n-    pub fn map<F, R>(&self, f: F) -> Tracked<R>\n-        where F: FnOnce(&T) -> R\n-    {\n-        Tracked {\n-            state: f(&self.state),\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Tracked<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let Tracked {\n-            ref state\n-        } = *self;\n-\n-        state.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {\n     pub name: Symbol,\n     pub triple: String,\n     pub hash: hir::svh::Svh,\n     pub disambiguator: Symbol,\n-    pub panic_strategy: Tracked<PanicStrategy>,\n-    pub has_global_allocator: Tracked<bool>,\n-    pub has_default_lib_allocator: Tracked<bool>,\n+    pub panic_strategy: PanicStrategy,\n+    pub has_global_allocator: bool,\n+    pub has_default_lib_allocator: bool,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,\n \n-    pub crate_deps: Tracked<LazySeq<CrateDep>>,\n-    pub dylib_dependency_formats: Tracked<LazySeq<Option<LinkagePreference>>>,\n-    pub lang_items: Tracked<LazySeq<(DefIndex, usize)>>,\n-    pub lang_items_missing: Tracked<LazySeq<lang_items::LangItem>>,\n-    pub native_libraries: Tracked<LazySeq<NativeLibrary>>,\n+    pub crate_deps: LazySeq<CrateDep>,\n+    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n+    pub lang_items: LazySeq<(DefIndex, usize)>,\n+    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n+    pub native_libraries: LazySeq<NativeLibrary>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: Tracked<LazySeq<TraitImpls>>,\n-    pub exported_symbols: Tracked<LazySeq<DefIndex>>,\n+    pub impls: LazySeq<TraitImpls>,\n+    pub exported_symbols: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n }\n "}, {"sha": "742d4bf197ee25d9aa601f008156495739058ff6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -146,7 +146,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, cpath, diagnostic_handler, codemap, cstore.clone()\n     );"}, {"sha": "700bbe23bab72d5454d5e58be73dc89f3ddd8166", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -85,7 +85,7 @@ pub fn run(input: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, Some(input_path.clone()), handler, codemap.clone(), cstore.clone(),\n     );\n@@ -238,7 +238,7 @@ fn run_test(test: &str, cratename: &str, filename: &str, cfgs: Vec<String>, libs\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let dep_graph = DepGraph::new(false);\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, None, diagnostic_handler, codemap, cstore.clone(),\n     );"}, {"sha": "9caf83d995444aa81c20502c785f2f54b365387e", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d724d03389706e4efc72ea3865d9c2c185003fd2/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=d724d03389706e4efc72ea3865d9c2c185003fd2", "patch": "@@ -59,7 +59,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let dep_graph = DepGraph::new(opts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, Box::new(rustc_trans::LlvmMetadataLoader)));\n+    let cstore = Rc::new(CStore::new(Box::new(rustc_trans::LlvmMetadataLoader)));\n     let sess = build_session(opts, &dep_graph, None, descriptions, cstore.clone());\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));"}]}