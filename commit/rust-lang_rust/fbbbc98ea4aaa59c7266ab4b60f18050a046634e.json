{"sha": "fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYmJjOThlYTRhYWE1OWM3MjY2YWI0YjYwZjE4MDUwYTA0NjYzNGU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-19T00:20:58Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-24T00:06:32Z"}, "message": "Refactor a bunch of lookup_vtable to reduce rightward drift and clean things up.", "tree": {"sha": "1a86ae54f1eaa9e69230a0233d4c0e9fb91fef28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a86ae54f1eaa9e69230a0233d4c0e9fb91fef28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "html_url": "https://github.com/rust-lang/rust/commit/fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbbbc98ea4aaa59c7266ab4b60f18050a046634e/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9759e20fc8a23b3d87765ebb8943adc357ce33", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9759e20fc8a23b3d87765ebb8943adc357ce33", "html_url": "https://github.com/rust-lang/rust/commit/4b9759e20fc8a23b3d87765ebb8943adc357ce33"}], "stats": {"total": 462, "additions": 241, "deletions": 221}, "files": [{"sha": "e3a661b4b00cbf43f7050f9a8adf7428fc804496", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbbc98ea4aaa59c7266ab4b60f18050a046634e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbbc98ea4aaa59c7266ab4b60f18050a046634e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "patch": "@@ -1109,7 +1109,9 @@ pub fn find_vtable(tcx: ty::ctxt,\n     debug!(\"find_vtable(n_param=%u, n_bound=%u, ps=%s)\",\n            n_param, n_bound, ps.repr(tcx));\n \n-    ps.vtables.get()[n_param][n_bound].clone()\n+    let tables = ps.vtables.expect(\"vtables missing where they are needed\");\n+    let param_bounds = tables[n_param];\n+    param_bounds[n_bound].clone()\n }\n \n pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {"}, {"sha": "0052629cd2df65b9abfe08e5e7f54aa7c9576ab3", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 233, "deletions": 220, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/fbbbc98ea4aaa59c7266ab4b60f18050a046634e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbbc98ea4aaa59c7266ab4b60f18050a046634e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "patch": "@@ -16,11 +16,10 @@ use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::infer::fixup_err_to_str;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n-use middle::typeck::{CrateCtxt, vtable_origin, vtable_res};\n+use middle::typeck::{CrateCtxt, vtable_origin, vtable_res, vtable_param_res};\n use middle::typeck::{vtable_static, vtable_param, vtable_self};\n use middle::subst::Subst;\n use util::common::indenter;\n-use util::ppaux::tys_to_str;\n use util::ppaux;\n \n use std::hashmap::HashSet;\n@@ -84,41 +83,10 @@ fn lookup_vtables(vcx: &VtableContext,\n            substs.repr(vcx.tcx()));\n     let _i = indenter();\n \n-    let tcx = vcx.tcx();\n     let mut result = ~[];\n-    let mut i = 0u;\n-    for substs.tps.iter().advance |ty| {\n-        // ty is the value supplied for the type parameter A...\n-        let mut param_result = ~[];\n-\n-        for ty::each_bound_trait_and_supertraits(\n-            tcx, type_param_defs[i].bounds) |trait_ref|\n-        {\n-            // ...and here trait_ref is each bound that was declared on A,\n-            // expressed in terms of the type parameters.\n-\n-            debug!(\"about to subst: %s, %s\", trait_ref.repr(tcx), substs.repr(tcx));\n-\n-            // Substitute the values of the type parameters that may\n-            // appear in the bound.\n-            let trait_ref = trait_ref.subst(tcx, substs);\n-\n-            debug!(\"after subst: %s\", trait_ref.repr(tcx));\n-\n-            match lookup_vtable(vcx, location_info, *ty, trait_ref, is_early) {\n-                Some(vtable) => param_result.push(vtable),\n-                None => {\n-                    vcx.tcx().sess.span_fatal(\n-                        location_info.span,\n-                        fmt!(\"failed to find an implementation of \\\n-                              trait %s for %s\",\n-                             vcx.infcx.trait_ref_to_str(trait_ref),\n-                             vcx.infcx.ty_to_str(*ty)));\n-                }\n-            }\n-        }\n-        result.push(@param_result);\n-        i += 1u;\n+    for substs.tps.iter().zip(type_param_defs.iter()).advance |(ty, def)| {\n+        result.push(lookup_vtables_for_param(vcx, location_info, Some(substs),\n+                                             &*def.bounds, *ty, is_early));\n     }\n     debug!(\"lookup_vtables result(\\\n             location_info=%?, \\\n@@ -132,25 +100,58 @@ fn lookup_vtables(vcx: &VtableContext,\n     @result\n }\n \n-fn fixup_substs(vcx: &VtableContext,\n-                location_info: &LocationInfo,\n-                id: ast::def_id,\n-                substs: ty::substs,\n-                is_early: bool)\n-                -> Option<ty::substs> {\n+fn lookup_vtables_for_param(vcx: &VtableContext,\n+                            location_info: &LocationInfo,\n+                            // None for substs means the identity\n+                            substs: Option<&ty::substs>,\n+                            type_param_bounds: &ty::ParamBounds,\n+                            ty: ty::t,\n+                            is_early: bool) -> vtable_param_res {\n     let tcx = vcx.tcx();\n-    // use a dummy type just to package up the substs that need fixing up\n-    let t = ty::mk_trait(tcx,\n-                         id, substs,\n-                         ty::RegionTraitStore(ty::re_static),\n-                         ast::m_imm,\n-                         ty::EmptyBuiltinBounds());\n-    do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n-        match ty::get(*t_f).sty {\n-          ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n-          _ => fail!(\"t_f should be a trait\")\n+\n+    // ty is the value supplied for the type parameter A...\n+    let mut param_result = ~[];\n+\n+    for ty::each_bound_trait_and_supertraits(\n+        tcx, type_param_bounds) |trait_ref|\n+    {\n+        // ...and here trait_ref is each bound that was declared on A,\n+        // expressed in terms of the type parameters.\n+\n+        // Substitute the values of the type parameters that may\n+        // appear in the bound.\n+        let trait_ref = substs.map_default(trait_ref, |substs| {\n+            debug!(\"about to subst: %s, %s\",\n+                   trait_ref.repr(tcx), substs.repr(tcx));\n+            trait_ref.subst(tcx, *substs)\n+        });\n+\n+        debug!(\"after subst: %s\", trait_ref.repr(tcx));\n+\n+        match lookup_vtable(vcx, location_info, ty, trait_ref, is_early) {\n+            Some(vtable) => param_result.push(vtable),\n+            None => {\n+                vcx.tcx().sess.span_fatal(\n+                    location_info.span,\n+                    fmt!(\"failed to find an implementation of \\\n+                          trait %s for %s\",\n+                         vcx.infcx.trait_ref_to_str(trait_ref),\n+                         vcx.infcx.ty_to_str(ty)));\n+            }\n         }\n     }\n+\n+    debug!(\"lookup_vtables_for_param result(\\\n+            location_info=%?, \\\n+            type_param_bounds=%s, \\\n+            ty=%s, \\\n+            result=%s)\",\n+           location_info,\n+           type_param_bounds.repr(vcx.tcx()),\n+           ty.repr(vcx.tcx()),\n+           param_result.repr(vcx.tcx()));\n+\n+    return @param_result;\n }\n \n fn relate_trait_refs(vcx: &VtableContext,\n@@ -173,10 +174,15 @@ fn relate_trait_refs(vcx: &VtableContext,\n     {\n         result::Ok(()) => {} // Ok.\n         result::Err(ref err) => {\n+            // There is an error, but we need to do some work to make\n+            // the message good.\n+            // Resolve any type vars in the trait refs\n             let r_act_trait_ref =\n                 vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(act_trait_ref);\n             let r_exp_trait_ref =\n                 vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(exp_trait_ref);\n+            // Only print the message if there aren't any previous type errors\n+            // inside the types.\n             if !ty::trait_ref_contains_error(&r_act_trait_ref) &&\n                 !ty::trait_ref_contains_error(&r_exp_trait_ref)\n             {\n@@ -256,180 +262,184 @@ fn lookup_vtable(vcx: &VtableContext,\n         }\n \n         _ => {\n-            let mut found = ~[];\n+            return search_for_vtable(vcx, location_info,\n+                                     ty, trait_ref, is_early)\n+        }\n+    }\n \n-            let mut impls_seen = HashSet::new();\n+    return None;\n+}\n \n-            match tcx.trait_impls.find(&trait_ref.def_id) {\n-                None => {\n-                    // Nothing found. Continue.\n-                }\n-                Some(implementations) => {\n-                    // implementations is the list of all impls in scope for\n-                    // trait_ref. (Usually, there's just one.)\n-                    for implementations.iter().advance |im| {\n-                        // im is one specific impl of trait_ref.\n-\n-                        // First, ensure we haven't processed this impl yet.\n-                        if impls_seen.contains(&im.did) {\n-                            loop;\n-                        }\n-                        impls_seen.insert(im.did);\n-\n-                        // ty::impl_traits gives us the trait im implements,\n-                        // if there is one (there's either zero or one).\n-                        //\n-                        // If foo implements a trait t, and if t is the\n-                        // same trait as trait_ref, we need to\n-                        // unify it with trait_ref in order to get all\n-                        // the ty vars sorted out.\n-                        let r = ty::impl_trait_ref(tcx, im.did);\n-                        for r.iter().advance |&of_trait_ref| {\n-                            if of_trait_ref.def_id != trait_ref.def_id { loop; }\n-\n-                            // At this point, we know that of_trait_ref is\n-                            // the same trait as trait_ref, but\n-                            // possibly applied to different substs.\n-                            //\n-                            // Next, we check whether the \"for\" ty in\n-                            // the impl is compatible with the type\n-                            // that we're casting to a trait. That is,\n-                            // if im is:\n-                            //\n-                            // impl<T> self_ty<T>: some_trait<T> { ... }\n-                            //\n-                            // we check whether self_ty<T> is the type\n-                            // of the thing that we're trying to cast\n-                            // to some_trait.  If not, then we try the next\n-                            // impl.\n-                            //\n-                            // FIXME(#5781) this should be mk_eqty not mk_subty\n-                            let ty::ty_param_substs_and_ty {\n-                                substs: substs,\n-                                ty: for_ty\n-                            } = impl_self_ty(vcx, location_info, im.did);\n-                            match infer::mk_subty(vcx.infcx,\n-                                                  false,\n-                                                  infer::RelateSelfType(\n-                                                      location_info.span),\n-                                                  ty,\n-                                                  for_ty) {\n-                                result::Err(_) => loop,\n-                                result::Ok(()) => ()\n-                            }\n-\n-                            // Now, in the previous example, for_ty is\n-                            // bound to the type self_ty, and substs\n-                            // is bound to [T].\n-                            debug!(\"The self ty is %s and its substs are %s\",\n-                                   vcx.infcx.ty_to_str(for_ty),\n-                                   tys_to_str(vcx.tcx(), substs.tps));\n-\n-                            // Next, we unify trait_ref -- the type\n-                            // that we want to cast to -- with of_trait_ref\n-                            // -- the trait that im implements. At\n-                            // this point, we require that they be\n-                            // unifiable with each other -- that's\n-                            // what relate_trait_refs does.\n-                            //\n-                            // For example, in the above example,\n-                            // of_trait_ref would be some_trait<T>, so we\n-                            // would be unifying trait_ref<U> (for some\n-                            // value of U) with some_trait<T>. This\n-                            // would fail if T and U weren't\n-                            // compatible.\n-\n-                            debug!(\"(checking vtable) @2 relating trait \\\n-                                    ty %s to of_trait_ref %s\",\n-                                   vcx.infcx.trait_ref_to_str(trait_ref),\n-                                   vcx.infcx.trait_ref_to_str(of_trait_ref));\n-\n-                            let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n-                            relate_trait_refs(\n-                                vcx, location_info,\n-                                of_trait_ref, trait_ref);\n-\n-                            // Recall that trait_ref -- the trait type\n-                            // we're casting to -- is the trait with\n-                            // id trait_ref.def_id applied to the substs\n-                            // trait_ref.substs. Now we extract out the\n-                            // types themselves from trait_ref.substs.\n-\n-                            // Recall that substs is the impl self\n-                            // type's list of substitutions. That is,\n-                            // if this is an impl of some trait for\n-                            // foo<T, U>, then substs is [T,\n-                            // U]. substs might contain type\n-                            // variables, so we call fixup_substs to\n-                            // resolve them.\n-\n-                            let substs_f = match fixup_substs(vcx,\n-                                                              location_info,\n-                                                              trait_ref.def_id,\n-                                                              substs,\n-                                                              is_early) {\n-                                Some(ref substs) => (*substs).clone(),\n-                                None => {\n-                                    assert!(is_early);\n-                                    // Bail out with a bogus answer\n-                                    return Some(vtable_param(0, 0));\n-                                }\n-                            };\n-\n-                            debug!(\"The fixed-up substs are %s - \\\n-                                    they will be unified with the bounds for \\\n-                                    the target ty, %s\",\n-                                   tys_to_str(vcx.tcx(), substs_f.tps),\n-                                   vcx.infcx.trait_ref_to_str(trait_ref));\n-\n-                            // Next, we unify the fixed-up\n-                            // substitutions for the impl self ty with\n-                            // the substitutions from the trait type\n-                            // that we're trying to cast\n-                            // to. connect_trait_tps requires these\n-                            // lists of types to unify pairwise.\n-\n-                            let im_generics =\n-                                ty::lookup_item_type(tcx, im.did).generics;\n-                            connect_trait_tps(vcx,\n-                                              location_info,\n-                                              &substs_f,\n-                                              trait_ref,\n-                                              im.did);\n-                            let subres = lookup_vtables(\n-                                vcx, location_info,\n-                                *im_generics.type_param_defs, &substs_f,\n-                                is_early);\n-\n-                            // Finally, we register that we found a\n-                            // matching impl, and record the def ID of\n-                            // the impl as well as the resolved list\n-                            // of type substitutions for the target\n-                            // trait.\n-                            found.push(vtable_static(im.did,\n-                                                     substs_f.tps.clone(),\n-                                                     subres));\n-                        }\n-                    }\n-                }\n+fn search_for_vtable(vcx: &VtableContext,\n+                     location_info: &LocationInfo,\n+                     ty: ty::t,\n+                     trait_ref: @ty::TraitRef,\n+                     is_early: bool)\n+    -> Option<vtable_origin>\n+{\n+    let tcx = vcx.tcx();\n+\n+    let mut found = ~[];\n+    let mut impls_seen = HashSet::new();\n+\n+    // XXX: this is a bad way to do this, since we do\n+    // pointless allocations.\n+    let impls = tcx.trait_impls.find(&trait_ref.def_id)\n+        .map_default(@mut ~[], |x| **x);\n+    // impls is the list of all impls in scope for trait_ref.\n+    for impls.iter().advance |im| {\n+        // im is one specific impl of trait_ref.\n+\n+        // First, ensure we haven't processed this impl yet.\n+        if impls_seen.contains(&im.did) {\n+            loop;\n+        }\n+        impls_seen.insert(im.did);\n+\n+        // ty::impl_traits gives us the trait im implements.\n+        //\n+        // If foo implements a trait t, and if t is the same trait as\n+        // trait_ref, we need to unify it with trait_ref in order to\n+        // get all the ty vars sorted out.\n+        let r = ty::impl_trait_ref(tcx, im.did);\n+        let of_trait_ref = r.expect(\"trait_ref missing on trait impl\");\n+        if of_trait_ref.def_id != trait_ref.def_id { loop; }\n+\n+        // At this point, we know that of_trait_ref is the same trait\n+        // as trait_ref, but possibly applied to different substs.\n+        //\n+        // Next, we check whether the \"for\" ty in the impl is\n+        // compatible with the type that we're casting to a\n+        // trait. That is, if im is:\n+        //\n+        // impl<T> some_trait<T> for self_ty<T> { ... }\n+        //\n+        // we check whether self_ty<T> is the type of the thing that\n+        // we're trying to cast to some_trait.  If not, then we try\n+        // the next impl.\n+        //\n+        // XXX: document a bit more what this means\n+        //\n+        // FIXME(#5781) this should be mk_eqty not mk_subty\n+        let ty::ty_param_substs_and_ty {\n+            substs: substs,\n+            ty: for_ty\n+        } = impl_self_ty(vcx, location_info, im.did);\n+        match infer::mk_subty(vcx.infcx,\n+                              false,\n+                              infer::RelateSelfType(\n+                                  location_info.span),\n+                              ty,\n+                              for_ty) {\n+            result::Err(_) => loop,\n+            result::Ok(()) => ()\n+        }\n+\n+        // Now, in the previous example, for_ty is bound to\n+        // the type self_ty, and substs is bound to [T].\n+        debug!(\"The self ty is %s and its substs are %s\",\n+               vcx.infcx.ty_to_str(for_ty),\n+               vcx.infcx.tys_to_str(substs.tps));\n+\n+        // Next, we unify trait_ref -- the type that we want to cast\n+        // to -- with of_trait_ref -- the trait that im implements. At\n+        // this point, we require that they be unifiable with each\n+        // other -- that's what relate_trait_refs does.\n+        //\n+        // For example, in the above example, of_trait_ref would be\n+        // some_trait<T>, so we would be unifying trait_ref<U> (for\n+        // some value of U) with some_trait<T>. This would fail if T\n+        // and U weren't compatible.\n+\n+        debug!(\"(checking vtable) @2 relating trait \\\n+                ty %s to of_trait_ref %s\",\n+               vcx.infcx.trait_ref_to_str(trait_ref),\n+               vcx.infcx.trait_ref_to_str(of_trait_ref));\n+\n+        let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n+        relate_trait_refs(vcx, location_info, of_trait_ref, trait_ref);\n+\n+        // Recall that trait_ref -- the trait type we're casting to --\n+        // is the trait with id trait_ref.def_id applied to the substs\n+        // trait_ref.substs. Now we extract out the types themselves\n+        // from trait_ref.substs.\n+\n+        // Recall that substs is the impl self type's list of\n+        // substitutions. That is, if this is an impl of some trait\n+        // for foo<T, U>, then substs is [T, U]. substs might contain\n+        // type variables, so we call fixup_substs to resolve them.\n+\n+        let substs_f = match fixup_substs(vcx,\n+                                          location_info,\n+                                          trait_ref.def_id,\n+                                          substs,\n+                                          is_early) {\n+            Some(ref substs) => (*substs).clone(),\n+            None => {\n+                assert!(is_early);\n+                // Bail out with a bogus answer\n+                return Some(vtable_param(0, 0));\n             }\n+        };\n+\n+        debug!(\"The fixed-up substs are %s - \\\n+                they will be unified with the bounds for \\\n+                the target ty, %s\",\n+               vcx.infcx.tys_to_str(substs_f.tps),\n+               vcx.infcx.trait_ref_to_str(trait_ref));\n+\n+        // Next, we unify the fixed-up substitutions for the impl self\n+        // ty with the substitutions from the trait type that we're\n+        // trying to cast to. connect_trait_tps requires these lists\n+        // of types to unify pairwise.\n+\n+        let im_generics =\n+            ty::lookup_item_type(tcx, im.did).generics;\n+        connect_trait_tps(vcx, location_info, &substs_f, trait_ref, im.did);\n+        let subres = lookup_vtables(vcx, location_info,\n+                                    *im_generics.type_param_defs, &substs_f,\n+                                    is_early);\n+\n+        // Finally, we register that we found a matching impl, and\n+        // record the def ID of the impl as well as the resolved list\n+        // of type substitutions for the target trait.\n+        found.push(vtable_static(im.did, substs_f.tps.clone(), subres));\n+    }\n \n-            match found.len() {\n-                0 => { /* fallthrough */ }\n-                1 => return Some(found[0].clone()),\n-                _ => {\n-                    if !is_early {\n-                        vcx.tcx().sess.span_err(\n-                            location_info.span,\n-                            \"multiple applicable methods in scope\");\n-                    }\n-                    return Some(found[0].clone());\n-                }\n+    match found.len() {\n+        0 => { return None }\n+        1 => return Some(found[0].clone()),\n+        _ => {\n+            if !is_early {\n+                vcx.tcx().sess.span_err(\n+                    location_info.span,\n+                    \"multiple applicable methods in scope\");\n             }\n+            return Some(found[0].clone());\n         }\n     }\n+}\n \n-    return None;\n+\n+fn fixup_substs(vcx: &VtableContext,\n+                location_info: &LocationInfo,\n+                id: ast::def_id,\n+                substs: ty::substs,\n+                is_early: bool)\n+                -> Option<ty::substs> {\n+    let tcx = vcx.tcx();\n+    // use a dummy type just to package up the substs that need fixing up\n+    let t = ty::mk_trait(tcx,\n+                         id, substs,\n+                         ty::RegionTraitStore(ty::re_static),\n+                         ast::m_imm,\n+                         ty::EmptyBuiltinBounds());\n+    do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n+        match ty::get(*t_f).sty {\n+          ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n+          _ => fail!(\"t_f should be a trait\")\n+        }\n+    }\n }\n \n fn fixup_ty(vcx: &VtableContext,\n@@ -682,10 +692,13 @@ pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n         Some(trait_ref) => {\n             let infcx = infer::new_infer_ctxt(ccx.tcx);\n             let vcx = VtableContext { ccx: ccx, infcx: infcx };\n-            let trait_def = ty::lookup_trait_def(ccx.tcx, trait_ref.def_id);\n+            let loc_info = location_info_for_item(impl_item);\n \n+            // First, check that the impl implements any trait bounds\n+            // on the trait.\n+            let trait_def = ty::lookup_trait_def(ccx.tcx, trait_ref.def_id);\n             let vtbls = lookup_vtables(&vcx,\n-                                       &location_info_for_item(impl_item),\n+                                       &loc_info,\n                                        *trait_def.generics.type_param_defs,\n                                        &trait_ref.substs,\n                                        false);"}, {"sha": "eb32f4e59f002a1673201a9e3a36add28022329f", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbbbc98ea4aaa59c7266ab4b60f18050a046634e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbbc98ea4aaa59c7266ab4b60f18050a046634e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "patch": "@@ -653,6 +653,11 @@ impl InferCtxt {\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n+    pub fn tys_to_str(@mut self, ts: &[ty::t]) -> ~str {\n+        let tstrs = ts.map(|t| self.ty_to_str(*t));\n+        fmt!(\"(%s)\", tstrs.connect(\", \"))\n+    }\n+\n     pub fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n         trait_ref_to_str(self.tcx, &t)"}]}