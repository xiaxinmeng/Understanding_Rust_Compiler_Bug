{"sha": "8f2ce3d8391f411fb7f1264fef2639702f4cc44e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMmNlM2Q4MzkxZjQxMWZiN2YxMjY0ZmVmMjYzOTcwMmY0Y2M0NGU=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-07T17:56:05Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-10T15:34:44Z"}, "message": "Document and simplify pattern matching with constants as patterns", "tree": {"sha": "f596dcc3944f85b83b1fc69018c66cea7ed4559b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f596dcc3944f85b83b1fc69018c66cea7ed4559b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f2ce3d8391f411fb7f1264fef2639702f4cc44e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2ce3d8391f411fb7f1264fef2639702f4cc44e", "html_url": "https://github.com/rust-lang/rust/commit/8f2ce3d8391f411fb7f1264fef2639702f4cc44e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f2ce3d8391f411fb7f1264fef2639702f4cc44e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5a7fcbde390ce3545613d7deeba25d0d400d818", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5a7fcbde390ce3545613d7deeba25d0d400d818", "html_url": "https://github.com/rust-lang/rust/commit/a5a7fcbde390ce3545613d7deeba25d0d400d818"}], "stats": {"total": 93, "additions": 51, "deletions": 42}, "files": [{"sha": "2880ffa5891a51dc6c68d055ce8b5819d8894196", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8f2ce3d8391f411fb7f1264fef2639702f4cc44e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f2ce3d8391f411fb7f1264fef2639702f4cc44e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=8f2ce3d8391f411fb7f1264fef2639702f4cc44e", "patch": "@@ -209,10 +209,16 @@ struct LiteralExpander<'a, 'tcx> {\n \n impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n     /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice\n+    ///\n+    /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n+    /// patterns. So the pattern may end up being a slice, but the constant is an array. We convert\n+    /// the array to a slice in that case\n     fn fold_const_value_deref(\n         &mut self,\n         val: ConstValue<'tcx>,\n+        // the pattern's pointee type\n         rty: Ty<'tcx>,\n+        // the constant's pointee type\n         crty: Ty<'tcx>,\n     ) -> ConstValue<'tcx> {\n         match (val, &crty.sty, &rty.sty) {\n@@ -776,6 +782,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     for row in patterns {\n         match *row.kind {\n             PatternKind::Constant { value } => {\n+                // extract the length of an array/slice from a constant\n                 match (value.val, &value.ty.sty) {\n                     (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n                         max_fixed_len,\n@@ -1393,53 +1400,55 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn slice_pat_covered_by_constructor<'tcx>(\n+// checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n+// meaning all other types will compare unequal and thus equal patterns often do not cause the\n+// second pattern to lint about unreachable match arms.\n+fn slice_pat_covered_by_const<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, '_>,\n     _span: Span,\n-    ctor: &Constructor,\n+    const_val: &ty::Const<'tcx>,\n     prefix: &[Pattern<'tcx>],\n     slice: &Option<Pattern<'tcx>>,\n     suffix: &[Pattern<'tcx>]\n ) -> Result<bool, ErrorReported> {\n-    let data: &[u8] = match *ctor {\n-        ConstantValue(const_val) => {\n-            match (const_val.val, &const_val.ty.sty) {\n-                (ConstValue::ByRef(id, alloc, offset), ty::Array(t, n)) => {\n-                    if *t != tcx.types.u8 {\n-                        // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n-                        // any sort of exhaustiveness/unreachable check yet\n-                        return Ok(false);\n-                    }\n-                    let ptr = Pointer::new(id, offset);\n-                    let n = n.assert_usize(tcx).unwrap();\n-                    alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n-                },\n-                (ConstValue::ScalarPair(Scalar::Bits { .. }, n), ty::Slice(_)) => {\n-                    assert_eq!(n.to_usize(&tcx).unwrap(), 0);\n-                    &[]\n-                },\n-                (ConstValue::ScalarPair(Scalar::Ptr(ptr), n), ty::Slice(t)) => {\n-                    if *t != tcx.types.u8 {\n-                        // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n-                        // any sort of exhaustiveness/unreachable check yet\n-                        return Ok(false);\n-                    }\n-                    let n = n.to_usize(&tcx).unwrap();\n-                    tcx.alloc_map\n-                        .lock()\n-                        .unwrap_memory(ptr.alloc_id)\n-                        .get_bytes(&tcx, ptr, Size::from_bytes(n))\n-                        .unwrap()\n-                },\n-                _ => bug!(\n-                    \"slice_pat_covered_by_constructor: {:#?}, {:#?}, {:#?}, {:#?}\",\n-                    ctor, prefix, slice, suffix,\n-                ),\n+    let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n+        (ConstValue::ByRef(id, alloc, offset), ty::Array(t, n)) => {\n+            if *t != tcx.types.u8 {\n+                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n+                // any sort of exhaustiveness/unreachable check yet\n+                return Ok(false);\n             }\n-        }\n+            let ptr = Pointer::new(id, offset);\n+            let n = n.assert_usize(tcx).unwrap();\n+            alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n+        },\n+        // a slice fat pointer to a zero length slice\n+        (ConstValue::ScalarPair(Scalar::Bits { .. }, n), ty::Slice(t)) => {\n+            if *t != tcx.types.u8 {\n+                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n+                // any sort of exhaustiveness/unreachable check yet\n+                return Ok(false);\n+            }\n+            assert_eq!(n.to_usize(&tcx).unwrap(), 0);\n+            &[]\n+        },\n+        //\n+        (ConstValue::ScalarPair(Scalar::Ptr(ptr), n), ty::Slice(t)) => {\n+            if *t != tcx.types.u8 {\n+                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n+                // any sort of exhaustiveness/unreachable check yet\n+                return Ok(false);\n+            }\n+            let n = n.to_usize(&tcx).unwrap();\n+            tcx.alloc_map\n+                .lock()\n+                .unwrap_memory(ptr.alloc_id)\n+                .get_bytes(&tcx, ptr, Size::from_bytes(n))\n+                .unwrap()\n+        },\n         _ => bug!(\n-            \"slice_pat_covered_by_constructor not ConstValue: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            ctor, prefix, slice, suffix,\n+            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n+            const_val, prefix, slice, suffix,\n         ),\n     };\n \n@@ -1837,9 +1846,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         None\n                     }\n                 }\n-                ConstantValue(..) => {\n-                    match slice_pat_covered_by_constructor(\n-                        cx.tcx, pat.span, constructor, prefix, slice, suffix\n+                ConstantValue(cv) => {\n+                    match slice_pat_covered_by_const(\n+                        cx.tcx, pat.span, cv, prefix, slice, suffix\n                             ) {\n                         Ok(true) => Some(smallvec![]),\n                         Ok(false) => None,"}]}