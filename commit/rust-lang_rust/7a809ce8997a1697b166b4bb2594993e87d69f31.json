{"sha": "7a809ce8997a1697b166b4bb2594993e87d69f31", "node_id": "C_kwDOAAsO6NoAKDdhODA5Y2U4OTk3YTE2OTdiMTY2YjRiYjI1OTQ5OTNlODdkNjlmMzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T16:02:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T16:02:37Z"}, "message": "Auto merge of #108677 - matthiaskrgr:rollup-i91cxuf, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #108022 (Support allocations with non-Box<[u8]> bytes)\n - #108367 (Re-apply \"switch to the macos-12-xl builder\")\n - #108557 (Point error span at Some constructor argument when trait resolution fails)\n - #108573 (Explain compile-time vs run-time difference in env!() error message)\n - #108584 (Put backtick content from rustdoc search errors into a `<code>` elements)\n - #108624 (Make `ExprKind` the first field in `thir::Expr`)\n - #108644 (Allow setting hashmap toml values in `./configure`)\n - #108672 (Feed queries on impl side for RPITITs when using lower_impl_trait_in_trait_to_assoc_ty)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5510959c6bc814d01b5f71f70a733a3f48351a8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5510959c6bc814d01b5f71f70a733a3f48351a8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a809ce8997a1697b166b4bb2594993e87d69f31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a809ce8997a1697b166b4bb2594993e87d69f31", "html_url": "https://github.com/rust-lang/rust/commit/7a809ce8997a1697b166b4bb2594993e87d69f31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a809ce8997a1697b166b4bb2594993e87d69f31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13471d3b2046cce78181dde6cfc146c09f55e29e", "url": "https://api.github.com/repos/rust-lang/rust/commits/13471d3b2046cce78181dde6cfc146c09f55e29e", "html_url": "https://github.com/rust-lang/rust/commit/13471d3b2046cce78181dde6cfc146c09f55e29e"}, {"sha": "e85df8d0fe169f8c9b25f2dfe775b62e22ccd20f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e85df8d0fe169f8c9b25f2dfe775b62e22ccd20f", "html_url": "https://github.com/rust-lang/rust/commit/e85df8d0fe169f8c9b25f2dfe775b62e22ccd20f"}], "stats": {"total": 1029, "additions": 884, "deletions": 145}, "files": [{"sha": "44f789c592ba27822f561806ece1f5f5b3404a11", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -322,7 +322,7 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-apple-various\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n@@ -333,7 +333,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-x86_64-apple-alt\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n@@ -344,7 +344,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-apple-1\n             env:\n               SCRIPT: \"./x.py --stage 2 test --exclude tests/ui --exclude tests/rustdoc --exclude tests/run-make-fulldeps\"\n@@ -355,7 +355,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-apple-2\n             env:\n               SCRIPT: \"./x.py --stage 2 test tests/ui tests/rustdoc tests/run-make-fulldeps\"\n@@ -366,7 +366,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-aarch64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n@@ -381,7 +381,7 @@ jobs:\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n               JEMALLOC_SYS_WITH_LG_PAGE: 14\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\""}, {"sha": "f011cb754cb4a7f93ea0d5d9944410d7318f77d0", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -53,7 +53,7 @@ pub fn expand_env<'cx>(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, tts) {\n-        Some(exprs) if exprs.is_empty() => {\n+        Some(exprs) if exprs.is_empty() || exprs.len() > 2 => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);\n         }\n@@ -64,28 +64,48 @@ pub fn expand_env<'cx>(\n     let Some((var, _style)) = expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") else {\n         return DummyResult::any(sp);\n     };\n-    let msg = match exprs.next() {\n-        None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),\n+\n+    let custom_msg = match exprs.next() {\n+        None => None,\n         Some(second) => match expr_to_string(cx, second, \"expected string literal\") {\n             None => return DummyResult::any(sp),\n-            Some((s, _style)) => s,\n+            Some((s, _style)) => Some(s),\n         },\n     };\n \n-    if exprs.next().is_some() {\n-        cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-        return DummyResult::any(sp);\n-    }\n-\n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(var.as_str()).ok().as_deref().map(Symbol::intern);\n     cx.sess.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n     let e = match value {\n         None => {\n-            cx.span_err(sp, msg.as_str());\n+            let (msg, help) = match custom_msg {\n+                None => (\n+                    format!(\"environment variable `{var}` not defined at compile time\"),\n+                    Some(help_for_missing_env_var(var.as_str())),\n+                ),\n+                Some(s) => (s.to_string(), None),\n+            };\n+            let mut diag = cx.struct_span_err(sp, &msg);\n+            if let Some(help) = help {\n+                diag.help(help);\n+            }\n+            diag.emit();\n             return DummyResult::any(sp);\n         }\n         Some(value) => cx.expr_str(sp, value),\n     };\n     MacEager::expr(e)\n }\n+\n+fn help_for_missing_env_var(var: &str) -> String {\n+    if var.starts_with(\"CARGO_\")\n+        || var.starts_with(\"DEP_\")\n+        || matches!(var, \"OUT_DIR\" | \"OPT_LEVEL\" | \"PROFILE\" | \"HOST\" | \"TARGET\")\n+    {\n+        format!(\n+            \"Cargo sets build script variables at run time. Use `std::env::var(\\\"{var}\\\")` instead\"\n+        )\n+    } else {\n+        format!(\"Use `std::env::var(\\\"{var}\\\")` to read the variable at run time\")\n+    }\n+}"}, {"sha": "92fa59aec6e5f0fc462beb0babf219d53f5026ee", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -16,8 +16,8 @@ use rustc_target::spec::abi::Abi as CallAbi;\n use crate::const_eval::CheckAlignment;\n \n use super::{\n-    AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n+    AllocBytes, AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx,\n+    InterpResult, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -105,10 +105,16 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Extra data stored in every allocation.\n     type AllocExtra: Debug + Clone + 'static;\n \n+    /// Type for the bytes of the allocation.\n+    type Bytes: AllocBytes + 'static;\n+\n     /// Memory's allocation map\n     type MemoryMap: AllocMap<\n             AllocId,\n-            (MemoryKind<Self::MemoryKind>, Allocation<Self::Provenance, Self::AllocExtra>),\n+            (\n+                MemoryKind<Self::MemoryKind>,\n+                Allocation<Self::Provenance, Self::AllocExtra, Self::Bytes>,\n+            ),\n         > + Default\n         + Clone;\n \n@@ -338,7 +344,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>>;\n+    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra, Self::Bytes>>>;\n \n     fn eval_inline_asm(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -459,6 +465,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n \n     type AllocExtra = ();\n     type FrameExtra = ();\n+    type Bytes = Box<[u8]>;\n \n     #[inline(always)]\n     fn use_addr_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {"}, {"sha": "a3764a7d142663d454030eac69b3a3eda82768cd", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -21,8 +21,9 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n use crate::const_eval::CheckAlignment;\n \n use super::{\n-    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n-    InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n+    alloc_range, AllocBytes, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg,\n+    GlobalAlloc, InterpCx, InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance,\n+    Scalar,\n };\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -114,16 +115,16 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n #[derive(Copy, Clone)]\n-pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra> {\n-    alloc: &'a Allocation<Prov, Extra>,\n+pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes = Box<[u8]>> {\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n }\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n-pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra> {\n-    alloc: &'a mut Allocation<Prov, Extra>,\n+pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes = Box<[u8]>> {\n+    alloc: &'a mut Allocation<Prov, Extra, Bytes>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -483,7 +484,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n         is_write: bool,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra, M::Bytes>>> {\n         let (alloc, def_id) = match self.tcx.try_get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n@@ -526,14 +527,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         )\n     }\n \n+    /// Get the base address for the bytes in an `Allocation` specified by the\n+    /// `AllocID` passed in; error if no such allocation exists.\n+    ///\n+    /// It is up to the caller to take sufficient care when using this address:\n+    /// there could be provenance or uninit memory in there, and other memory\n+    /// accesses could invalidate the exposed pointer.\n+    pub fn alloc_base_addr(&self, id: AllocId) -> InterpResult<'tcx, *const u8> {\n+        let alloc = self.get_alloc_raw(id)?;\n+        Ok(alloc.base_addr())\n+    }\n+\n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n     ///\n     /// You almost certainly want to use `get_ptr_alloc`/`get_ptr_alloc_mut` instead.\n     fn get_alloc_raw(\n         &self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra>> {\n+    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra, M::Bytes>> {\n         // The error type of the inner closure here is somewhat funny. We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -569,7 +581,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n@@ -612,7 +625,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn get_alloc_raw_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra>, &mut M)> {\n+    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra, M::Bytes>, &mut M)> {\n         // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n         // efficiency even for the common case where the key is in the map.\n         // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n@@ -641,7 +654,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n         if let Some((alloc_id, offset, prov)) = parts {\n             let tcx = *self.tcx;\n@@ -840,11 +854,11 @@ pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Cannot be a closure because it is generic in `Prov`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra>(\n+        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n             fmt: &mut std::fmt::Formatter<'_>,\n             tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n-            alloc: &Allocation<Prov, Extra>,\n+            alloc: &Allocation<Prov, Extra, Bytes>,\n         ) -> std::fmt::Result {\n             for alloc_id in alloc.provenance().provenances().filter_map(|prov| prov.get_alloc_id())\n             {\n@@ -912,7 +926,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n }\n \n /// Reading and writing.\n-impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra, Bytes: AllocBytes>\n+    AllocRefMut<'a, 'tcx, Prov, Extra, Bytes>\n+{\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_scalar(&mut self, range: AllocRange, val: Scalar<Prov>) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n@@ -937,7 +953,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     }\n }\n \n-impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra, Bytes: AllocBytes> AllocRef<'a, 'tcx, Prov, Extra, Bytes> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_scalar(\n         &self,"}, {"sha": "3c463500a609e1f7c12cd3a9cad823144f8c4c32", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -353,7 +353,8 @@ where\n     pub(super) fn get_place_alloc(\n         &self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n@@ -364,7 +365,8 @@ where\n     pub(super) fn get_place_alloc_mut(\n         &mut self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;"}, {"sha": "b09886fe3a96a29af515da35685ea2b9dd6d4442", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -714,12 +714,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.tcx.parent(expr_ctor_def_id)\n                 }\n                 hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, hir::def::CtorKind::Fn) => {\n-                    // If this is a variant, its parent is the type definition.\n-                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                    // For a typical enum like\n+                    // `enum Blah<T> { Variant(T) }`\n+                    // we get the following resolutions:\n+                    // - expr_ctor_def_id :::                                   DefId(0:29 ~ source_file[b442]::Blah::Variant::{constructor#0})\n+                    // - self.tcx.parent(expr_ctor_def_id) :::                  DefId(0:28 ~ source_file[b442]::Blah::Variant)\n+                    // - self.tcx.parent(self.tcx.parent(expr_ctor_def_id)) ::: DefId(0:26 ~ source_file[b442]::Blah)\n+\n+                    // Therefore, we need to go up once to obtain the variant and up twice to obtain the type.\n+                    // Note that this pattern still holds even when we `use` a variant or `use` an enum type to rename it, or chain `use` expressions\n+                    // together; this resolution is handled automatically by `qpath_res`.\n+\n+                    // FIXME: Deal with type aliases?\n+                    if in_ty_adt.did() == self.tcx.parent(self.tcx.parent(expr_ctor_def_id)) {\n+                        // The constructor definition refers to the \"constructor\" of the variant:\n+                        // For example, `Some(5)` triggers this case.\n+                        self.tcx.parent(expr_ctor_def_id)\n+                    } else {\n                         // FIXME: Deal with type aliases?\n                         return Err(expr);\n                     }\n-                    expr_ctor_def_id\n                 }\n                 _ => {\n                     return Err(expr);"}, {"sha": "48375ed301d22cd3331e88e91ed05787b88e2087", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 67, "deletions": 15, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -8,7 +8,8 @@ mod tests;\n use std::borrow::Cow;\n use std::fmt;\n use std::hash;\n-use std::ops::Range;\n+use std::hash::Hash;\n+use std::ops::{Deref, DerefMut, Range};\n use std::ptr;\n \n use either::{Left, Right};\n@@ -29,6 +30,39 @@ use provenance_map::*;\n \n pub use init_mask::{InitChunk, InitChunkIter};\n \n+/// Functionality required for the bytes of an `Allocation`.\n+pub trait AllocBytes:\n+    Clone + fmt::Debug + Eq + PartialEq + Hash + Deref<Target = [u8]> + DerefMut<Target = [u8]>\n+{\n+    /// Adjust the bytes to the specified alignment -- by default, this is a no-op.\n+    fn adjust_to_align(self, _align: Align) -> Self;\n+\n+    /// Create an `AllocBytes` from a slice of `u8`.\n+    fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, _align: Align) -> Self;\n+\n+    /// Create a zeroed `AllocBytes` of the specified size and alignment;\n+    /// call the callback error handler if there is an error in allocating the memory.\n+    fn zeroed(size: Size, _align: Align) -> Option<Self>;\n+}\n+\n+// Default `bytes` for `Allocation` is a `Box<[u8]>`.\n+impl AllocBytes for Box<[u8]> {\n+    fn adjust_to_align(self, _align: Align) -> Self {\n+        self\n+    }\n+\n+    fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, _align: Align) -> Self {\n+        Box::<[u8]>::from(slice.into())\n+    }\n+\n+    fn zeroed(size: Size, _align: Align) -> Option<Self> {\n+        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).ok()?;\n+        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n+        let bytes = unsafe { bytes.assume_init() };\n+        Some(bytes)\n+    }\n+}\n+\n /// This type represents an Allocation in the Miri/CTFE core engine.\n ///\n /// Its public API is rather low-level, working directly with allocation offsets and a custom error\n@@ -38,10 +72,10 @@ pub use init_mask::{InitChunk, InitChunkIter};\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n #[derive(Clone, Eq, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n-pub struct Allocation<Prov: Provenance = AllocId, Extra = ()> {\n+pub struct Allocation<Prov: Provenance = AllocId, Extra = (), Bytes = Box<[u8]>> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n-    bytes: Box<[u8]>,\n+    bytes: Bytes,\n     /// Maps from byte addresses to extra provenance data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n@@ -220,14 +254,27 @@ impl AllocRange {\n }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n-impl<Prov: Provenance> Allocation<Prov> {\n+impl<Prov: Provenance, Bytes: AllocBytes> Allocation<Prov, (), Bytes> {\n+    /// Creates an allocation from an existing `Bytes` value - this is needed for miri FFI support\n+    pub fn from_raw_bytes(bytes: Bytes, align: Align, mutability: Mutability) -> Self {\n+        let size = Size::from_bytes(bytes.len());\n+        Self {\n+            bytes,\n+            provenance: ProvenanceMap::new(),\n+            init_mask: InitMask::new(size, true),\n+            align,\n+            mutability,\n+            extra: (),\n+        }\n+    }\n+\n     /// Creates an allocation initialized by the given bytes\n     pub fn from_bytes<'a>(\n         slice: impl Into<Cow<'a, [u8]>>,\n         align: Align,\n         mutability: Mutability,\n     ) -> Self {\n-        let bytes = Box::<[u8]>::from(slice.into());\n+        let bytes = Bytes::from_bytes(slice, align);\n         let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n@@ -248,7 +295,7 @@ impl<Prov: Provenance> Allocation<Prov> {\n     ///\n     /// If `panic_on_fail` is true, this will never return `Err`.\n     pub fn uninit<'tcx>(size: Size, align: Align, panic_on_fail: bool) -> InterpResult<'tcx, Self> {\n-        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).map_err(|_| {\n+        let bytes = Bytes::zeroed(size, align).ok_or_else(|| {\n             // This results in an error that can happen non-deterministically, since the memory\n             // available to the compiler can change between runs. Normally queries are always\n             // deterministic. However, we can be non-deterministic here because all uses of const\n@@ -262,8 +309,7 @@ impl<Prov: Provenance> Allocation<Prov> {\n             });\n             InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n         })?;\n-        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n-        let bytes = unsafe { bytes.assume_init() };\n+\n         Ok(Allocation {\n             bytes,\n             provenance: ProvenanceMap::new(),\n@@ -275,17 +321,19 @@ impl<Prov: Provenance> Allocation<Prov> {\n     }\n }\n \n-impl Allocation {\n+impl<Bytes: AllocBytes> Allocation<AllocId, (), Bytes> {\n     /// Adjust allocation from the ones in tcx to a custom Machine instance\n     /// with a different Provenance and Extra type.\n     pub fn adjust_from_tcx<Prov: Provenance, Extra, Err>(\n         self,\n         cx: &impl HasDataLayout,\n         extra: Extra,\n         mut adjust_ptr: impl FnMut(Pointer<AllocId>) -> Result<Pointer<Prov>, Err>,\n-    ) -> Result<Allocation<Prov, Extra>, Err> {\n-        // Compute new pointer provenance, which also adjusts the bytes.\n-        let mut bytes = self.bytes;\n+    ) -> Result<Allocation<Prov, Extra, Bytes>, Err> {\n+        // Compute new pointer provenance, which also adjusts the bytes, and realign the pointer if\n+        // necessary.\n+        let mut bytes = self.bytes.adjust_to_align(self.align);\n+\n         let mut new_provenance = Vec::with_capacity(self.provenance.ptrs().len());\n         let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n         let endian = cx.data_layout().endian;\n@@ -311,7 +359,7 @@ impl Allocation {\n }\n \n /// Raw accessors. Provide access to otherwise private bytes.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n     pub fn len(&self) -> usize {\n         self.bytes.len()\n     }\n@@ -340,7 +388,11 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n }\n \n /// Byte accessors.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n+    pub fn base_addr(&self) -> *const u8 {\n+        self.bytes.as_ptr()\n+    }\n+\n     /// This is the entirely abstraction-violating way to just grab the raw bytes without\n     /// caring about provenance or initialization.\n     ///\n@@ -412,7 +464,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n }\n \n /// Reading and writing.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n     /// Sets the init bit for the given range.\n     fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n         if range.size.bytes() == 0 {"}, {"sha": "1766d7a66980461e51b54de99105b39dd89b74f9", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -127,8 +127,8 @@ pub use self::error::{\n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};\n \n pub use self::allocation::{\n-    alloc_range, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation, InitChunk,\n-    InitChunkIter,\n+    alloc_range, AllocBytes, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation,\n+    InitChunk, InitChunkIter,\n };\n \n pub use self::pointer::{Pointer, PointerArithmetic, Provenance};"}, {"sha": "d8829e3e782c5c40b931714cfa30d717cc9f9f55", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -12,8 +12,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{\n-    alloc_range, read_target_uint, AllocId, Allocation, ConstAllocation, ConstValue, GlobalAlloc,\n-    Pointer, Provenance,\n+    alloc_range, read_target_uint, AllocBytes, AllocId, Allocation, ConstAllocation, ConstValue,\n+    GlobalAlloc, Pointer, Provenance,\n };\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -787,21 +787,21 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints provenance adequately.\n-pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra>(\n+pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Prov, Extra>,\n-) -> RenderAllocation<'a, 'tcx, Prov, Extra> {\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n+) -> RenderAllocation<'a, 'tcx, Prov, Extra, Bytes> {\n     RenderAllocation { tcx, alloc }\n }\n \n #[doc(hidden)]\n-pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra> {\n+pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes> {\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Prov, Extra>,\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n }\n \n-impl<'a, 'tcx, Prov: Provenance, Extra> std::fmt::Display\n-    for RenderAllocation<'a, 'tcx, Prov, Extra>\n+impl<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes> std::fmt::Display\n+    for RenderAllocation<'a, 'tcx, Prov, Extra, Bytes>\n {\n     fn fmt(&self, w: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let RenderAllocation { tcx, alloc } = *self;\n@@ -845,9 +845,9 @@ fn write_allocation_newline(\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n+fn write_allocation_bytes<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &Allocation<Prov, Extra>,\n+    alloc: &Allocation<Prov, Extra, Bytes>,\n     w: &mut dyn std::fmt::Write,\n     prefix: &str,\n ) -> std::fmt::Result {"}, {"sha": "3b11fab8cdf57c575d302e531129fcfd431762a0", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -237,6 +237,9 @@ pub struct LocalVarId(pub hir::HirId);\n /// A THIR expression.\n #[derive(Clone, Debug, HashStable)]\n pub struct Expr<'tcx> {\n+    /// kind of expression\n+    pub kind: ExprKind<'tcx>,\n+\n     /// The type of this expression\n     pub ty: Ty<'tcx>,\n \n@@ -246,9 +249,6 @@ pub struct Expr<'tcx> {\n \n     /// span of the expression in the source\n     pub span: Span,\n-\n-    /// kind of expression\n-    pub kind: ExprKind<'tcx>,\n }\n \n #[derive(Clone, Debug, HashStable)]"}, {"sha": "0648784b265709d4eb8cd41b5102c7e0da6c44ce", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -53,9 +53,37 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n                 )\n             }\n         }\n-        hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n-            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id()),\n-        ),\n+        hir::ItemKind::Impl(ref impl_) => {\n+            if tcx.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty {\n+                // We collect RPITITs for each trait method's return type, on the impl side too and\n+                // create a corresponding associated item using\n+                // associated_items_for_impl_trait_in_trait query.\n+                tcx.arena.alloc_from_iter(\n+                    impl_\n+                        .items\n+                        .iter()\n+                        .map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id())\n+                        .chain(impl_.of_trait.iter().flat_map(|_| {\n+                            impl_\n+                                .items\n+                                .iter()\n+                                .filter(|impl_item_ref| {\n+                                    matches!(impl_item_ref.kind, hir::AssocItemKind::Fn { .. })\n+                                })\n+                                .flat_map(|impl_item_ref| {\n+                                    let impl_fn_def_id =\n+                                        impl_item_ref.id.owner_id.def_id.to_def_id();\n+                                    tcx.associated_items_for_impl_trait_in_trait(impl_fn_def_id)\n+                                })\n+                                .map(|def_id| *def_id)\n+                        })),\n+                )\n+            } else {\n+                tcx.arena.alloc_from_iter(\n+                    impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id()),\n+                )\n+            }\n+        }\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n     }\n }\n@@ -290,8 +318,40 @@ fn impl_associated_item_for_impl_trait_in_trait(\n ) -> LocalDefId {\n     let impl_def_id = tcx.local_parent(impl_fn_def_id);\n \n-    let span = tcx.def_span(trait_assoc_def_id);\n+    // FIXME fix the span, we probably want the def_id of the return type of the function\n+    let span = tcx.def_span(impl_fn_def_id);\n     let impl_assoc_ty = tcx.at(span).create_def(impl_def_id, DefPathData::ImplTraitAssocTy);\n \n-    impl_assoc_ty.def_id()\n+    let local_def_id = impl_assoc_ty.def_id();\n+    let def_id = local_def_id.to_def_id();\n+\n+    impl_assoc_ty.opt_def_kind(Some(DefKind::AssocTy));\n+\n+    // There's no HIR associated with this new synthesized `def_id`, so feed\n+    // `opt_local_def_id_to_hir_id` with `None`.\n+    impl_assoc_ty.opt_local_def_id_to_hir_id(None);\n+\n+    // Add the def_id of the function that generated this synthesized associated type.\n+    impl_assoc_ty.opt_rpitit_info(Some(ImplTraitInTraitData::Impl {\n+        fn_def_id: impl_fn_def_id.to_def_id(),\n+    }));\n+\n+    impl_assoc_ty.associated_item(ty::AssocItem {\n+        name: kw::Empty,\n+        kind: ty::AssocKind::Type,\n+        def_id,\n+        trait_item_def_id: Some(trait_assoc_def_id.to_def_id()),\n+        container: ty::ImplContainer,\n+        fn_has_self_parameter: false,\n+    });\n+\n+    // Copy impl_defaultness of the containing function.\n+    impl_assoc_ty.impl_defaultness(tcx.impl_defaultness(impl_fn_def_id));\n+\n+    // Copy generics_of the trait's associated item.\n+    // FIXME: This is not correct, in particular the parent is going to be wrong. So we would need\n+    // to copy from trait_assoc_def_id and adjust things.\n+    impl_assoc_ty.generics_of(tcx.generics_of(trait_assoc_def_id).clone());\n+\n+    local_def_id\n }"}, {"sha": "ab3d08292961f34ac3ebff888c225cba65e6d1cb", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -442,6 +442,8 @@ def to_toml(value):\n             return value\n         else:\n             return \"'\" + value + \"'\"\n+    elif isinstance(value, dict):\n+        return \"{\" + \", \".join(map(lambda a: \"{} = {}\".format(to_toml(a[0]), to_toml(a[1])), value.items())) + \"}\"\n     else:\n         raise RuntimeError('no toml')\n "}, {"sha": "11f1532bef59494c921d9285f3f49e2a6fceba53", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -78,7 +78,7 @@ x--expand-yaml-anchors--remove:\n     <<: *base-job\n \n   - &job-macos-xl\n-    os: macos-latest  # We don't have an XL builder for this\n+    os: macos-12-xl\n     <<: *base-job\n \n   - &job-windows-xl"}, {"sha": "1a34530c2d16ebf32210af00282533485659722c", "filename": "src/librustdoc/html/static/.eslintrc.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -90,7 +90,6 @@ module.exports = {\n         \"no-return-assign\": \"error\",\n         \"no-script-url\": \"error\",\n         \"no-sequences\": \"error\",\n-        \"no-throw-literal\": \"error\",\n         \"no-div-regex\": \"error\",\n     }\n };"}, {"sha": "95528e70e3519ef1d2821767e7f9da889aa561d7", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -1260,6 +1260,11 @@ a.tooltip:hover::after {\n \tcolor: var(--search-tab-title-count-color);\n }\n \n+#search .error code {\n+\tborder-radius: 3px;\n+\tbackground-color: var(--search-error-code-background-color);\n+}\n+\n #src-sidebar-toggle {\n \tposition: sticky;\n \ttop: 0;"}, {"sha": "90cf689ad3372923389378865e9216793a514e01", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -43,6 +43,7 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--search-result-link-focus-background-color: #3c3c3c;\n \t--search-result-border-color: #aaa3;\n \t--search-color: #fff;\n+\t--search-error-code-background-color: #4f4c4c;\n \t--search-results-alias-color: #c5c5c5;\n \t--search-results-grey-color: #999;\n \t--search-tab-title-count-color: #888;"}, {"sha": "e8cd06931392088859d1e0c4e8b41fff99108ec0", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -38,6 +38,7 @@\n \t--search-result-link-focus-background-color: #616161;\n \t--search-result-border-color: #aaa3;\n \t--search-color: #111;\n+\t--search-error-code-background-color: #484848;\n \t--search-results-alias-color: #fff;\n \t--search-results-grey-color: #ccc;\n \t--search-tab-title-count-color: #888;"}, {"sha": "5e3f14e483faed6884b4a01d54f9c19e204dd7d6", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -38,6 +38,7 @@\n \t--search-result-link-focus-background-color: #ccc;\n \t--search-result-border-color: #aaa3;\n \t--search-color: #000;\n+\t--search-error-code-background-color: #d0cccc;\n \t--search-results-alias-color: #000;\n \t--search-results-grey-color: #999;\n \t--search-tab-title-count-color: #888;"}, {"sha": "5a46729156d19353c7b10b666843e96836c7f45c", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 91, "deletions": 39, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -144,7 +144,7 @@ function initSearch(rawSearchIndex) {\n     function itemTypeFromName(typename) {\n         const index = itemTypes.findIndex(i => i === typename);\n         if (index < 0) {\n-            throw new Error(\"Unknown type filter `\" + typename + \"`\");\n+            throw [\"Unknown type filter \", typename];\n         }\n         return index;\n     }\n@@ -164,21 +164,21 @@ function initSearch(rawSearchIndex) {\n      */\n     function getStringElem(query, parserState, isInGenerics) {\n         if (isInGenerics) {\n-            throw new Error(\"`\\\"` cannot be used in generics\");\n+            throw [\"Unexpected \", \"\\\"\", \" in generics\"];\n         } else if (query.literalSearch) {\n-            throw new Error(\"Cannot have more than one literal search element\");\n+            throw [\"Cannot have more than one literal search element\"];\n         } else if (parserState.totalElems - parserState.genericsElems > 0) {\n-            throw new Error(\"Cannot use literal search when there is more than one element\");\n+            throw [\"Cannot use literal search when there is more than one element\"];\n         }\n         parserState.pos += 1;\n         const start = parserState.pos;\n         const end = getIdentEndPosition(parserState);\n         if (parserState.pos >= parserState.length) {\n-            throw new Error(\"Unclosed `\\\"`\");\n+            throw [\"Unclosed \", \"\\\"\"];\n         } else if (parserState.userQuery[end] !== \"\\\"\") {\n-            throw new Error(`Unexpected \\`${parserState.userQuery[end]}\\` in a string element`);\n+            throw [\"Unexpected \", parserState.userQuery[end], \" in a string element\"];\n         } else if (start === end) {\n-            throw new Error(\"Cannot have empty string element\");\n+            throw [\"Cannot have empty string element\"];\n         }\n         // To skip the quote at the end.\n         parserState.pos += 1;\n@@ -257,7 +257,7 @@ function initSearch(rawSearchIndex) {\n             return;\n         }\n         if (query.literalSearch && parserState.totalElems - parserState.genericsElems > 0) {\n-            throw new Error(\"You cannot have more than one element if you use quotes\");\n+            throw [\"You cannot have more than one element if you use quotes\"];\n         }\n         const pathSegments = name.split(\"::\");\n         if (pathSegments.length > 1) {\n@@ -266,17 +266,17 @@ function initSearch(rawSearchIndex) {\n \n                 if (pathSegment.length === 0) {\n                     if (i === 0) {\n-                        throw new Error(\"Paths cannot start with `::`\");\n+                        throw [\"Paths cannot start with \", \"::\"];\n                     } else if (i + 1 === len) {\n-                        throw new Error(\"Paths cannot end with `::`\");\n+                        throw [\"Paths cannot end with \", \"::\"];\n                     }\n-                    throw new Error(\"Unexpected `::::`\");\n+                    throw [\"Unexpected \", \"::::\"];\n                 }\n             }\n         }\n         // In case we only have something like `<p>`, there is no name.\n         if (pathSegments.length === 0 || (pathSegments.length === 1 && pathSegments[0] === \"\")) {\n-            throw new Error(\"Found generics without a path\");\n+            throw [\"Found generics without a path\"];\n         }\n         parserState.totalElems += 1;\n         if (isInGenerics) {\n@@ -308,15 +308,15 @@ function initSearch(rawSearchIndex) {\n             if (!isIdentCharacter(c)) {\n                 if (c === \"!\") {\n                     if (foundExclamation !== -1) {\n-                        throw new Error(\"Cannot have more than one `!` in an ident\");\n+                        throw [\"Cannot have more than one \", \"!\", \" in an ident\"];\n                     } else if (parserState.pos + 1 < parserState.length &&\n                         isIdentCharacter(parserState.userQuery[parserState.pos + 1])\n                     ) {\n-                        throw new Error(\"`!` can only be at the end of an ident\");\n+                        throw [\"Unexpected \", \"!\", \": it can only be at the end of an ident\"];\n                     }\n                     foundExclamation = parserState.pos;\n                 } else if (isErrorCharacter(c)) {\n-                    throw new Error(`Unexpected \\`${c}\\``);\n+                    throw [\"Unexpected \", c];\n                 } else if (\n                     isStopCharacter(c) ||\n                     isSpecialStartCharacter(c) ||\n@@ -329,7 +329,7 @@ function initSearch(rawSearchIndex) {\n                     }\n                     if (foundExclamation !== -1) {\n                         if (start <= (end - 2)) {\n-                            throw new Error(\"Cannot have associated items in macros\");\n+                            throw [\"Cannot have associated items in macros\"];\n                         } else {\n                             // if start == end - 1, we got the never type\n                             // while the never type has no associated macros, we still\n@@ -340,7 +340,7 @@ function initSearch(rawSearchIndex) {\n                     // Skip current \":\".\n                     parserState.pos += 1;\n                 } else {\n-                    throw new Error(`Unexpected \\`${c}\\``);\n+                    throw [\"Unexpected \", c];\n                 }\n             }\n             parserState.pos += 1;\n@@ -351,8 +351,13 @@ function initSearch(rawSearchIndex) {\n             if (parserState.typeFilter === null) {\n                 parserState.typeFilter = \"macro\";\n             } else if (parserState.typeFilter !== \"macro\") {\n-                throw new Error(\"Invalid search type: macro `!` and \" +\n-                    `\\`${parserState.typeFilter}\\` both specified`);\n+                throw [\n+                    \"Invalid search type: macro \",\n+                    \"!\",\n+                    \" and \",\n+                    parserState.typeFilter,\n+                    \" both specified\",\n+                ];\n             }\n             end = foundExclamation;\n         }\n@@ -382,9 +387,9 @@ function initSearch(rawSearchIndex) {\n             parserState.userQuery[parserState.pos] === \"<\"\n         ) {\n             if (isInGenerics) {\n-                throw new Error(\"Unexpected `<` after `<`\");\n+                throw [\"Unexpected \", \"<\", \" after \", \"<\"];\n             } else if (start >= end) {\n-                throw new Error(\"Found generics without a path\");\n+                throw [\"Found generics without a path\"];\n             }\n             parserState.pos += 1;\n             getItemsBefore(query, parserState, generics, \">\");\n@@ -428,21 +433,39 @@ function initSearch(rawSearchIndex) {\n                 foundStopChar = true;\n                 continue;\n             } else if (c === \":\" && isPathStart(parserState)) {\n-                throw new Error(\"Unexpected `::`: paths cannot start with `::`\");\n+                throw [\"Unexpected \", \"::\", \": paths cannot start with \", \"::\"];\n             } else if (c === \":\" || isEndCharacter(c)) {\n                 let extra = \"\";\n                 if (endChar === \">\") {\n-                    extra = \"`<`\";\n+                    extra = \"<\";\n                 } else if (endChar === \"\") {\n-                    extra = \"`->`\";\n+                    extra = \"->\";\n+                } else {\n+                    extra = endChar;\n                 }\n-                throw new Error(\"Unexpected `\" + c + \"` after \" + extra);\n+                throw [\"Unexpected \", c, \" after \", extra];\n             }\n             if (!foundStopChar) {\n                 if (endChar !== \"\") {\n-                    throw new Error(`Expected \\`,\\`, \\` \\` or \\`${endChar}\\`, found \\`${c}\\``);\n+                    throw [\n+                        \"Expected \",\n+                        \",\", // comma\n+                        \", \",\n+                        \"&nbsp;\", // whitespace\n+                        \" or \",\n+                        endChar,\n+                        \", found \",\n+                        c,\n+                    ];\n                 }\n-                throw new Error(`Expected \\`,\\` or \\` \\`, found \\`${c}\\``);\n+                throw [\n+                    \"Expected \",\n+                    \",\", // comma\n+                    \" or \",\n+                    \"&nbsp;\", // whitespace\n+                    \", found \",\n+                    c,\n+                ];\n             }\n             const posBefore = parserState.pos;\n             getNextElem(query, parserState, elems, endChar === \">\");\n@@ -470,7 +493,7 @@ function initSearch(rawSearchIndex) {\n \n         for (let pos = 0; pos < parserState.pos; ++pos) {\n             if (!isIdentCharacter(query[pos]) && !isWhitespaceCharacter(query[pos])) {\n-                throw new Error(`Unexpected \\`${query[pos]}\\` in type filter`);\n+                throw [\"Unexpected \", query[pos], \" in type filter\"];\n             }\n         }\n     }\n@@ -496,19 +519,19 @@ function initSearch(rawSearchIndex) {\n                     if (isReturnArrow(parserState)) {\n                         break;\n                     }\n-                    throw new Error(`Unexpected \\`${c}\\` (did you mean \\`->\\`?)`);\n+                    throw [\"Unexpected \", c, \" (did you mean \", \"->\", \"?)\"];\n                 }\n-                throw new Error(`Unexpected \\`${c}\\``);\n+                throw [\"Unexpected \", c];\n             } else if (c === \":\" && !isPathStart(parserState)) {\n                 if (parserState.typeFilter !== null) {\n-                    throw new Error(\"Unexpected `:`\");\n+                    throw [\"Unexpected \", \":\"];\n                 }\n                 if (query.elems.length === 0) {\n-                    throw new Error(\"Expected type filter before `:`\");\n+                    throw [\"Expected type filter before \", \":\"];\n                 } else if (query.elems.length !== 1 || parserState.totalElems !== 1) {\n-                    throw new Error(\"Unexpected `:`\");\n+                    throw [\"Unexpected \", \":\"];\n                 } else if (query.literalSearch) {\n-                    throw new Error(\"You cannot use quotes on type filter\");\n+                    throw [\"You cannot use quotes on type filter\"];\n                 }\n                 checkExtraTypeFilterCharacters(parserState);\n                 // The type filter doesn't count as an element since it's a modifier.\n@@ -521,9 +544,29 @@ function initSearch(rawSearchIndex) {\n             }\n             if (!foundStopChar) {\n                 if (parserState.typeFilter !== null) {\n-                    throw new Error(`Expected \\`,\\`, \\` \\` or \\`->\\`, found \\`${c}\\``);\n+                    throw [\n+                        \"Expected \",\n+                        \",\", // comma\n+                        \", \",\n+                        \"&nbsp;\", // whitespace\n+                        \" or \",\n+                        \"->\", // arrow\n+                        \", found \",\n+                        c,\n+                    ];\n                 }\n-                throw new Error(`Expected \\`,\\`, \\` \\`, \\`:\\` or \\`->\\`, found \\`${c}\\``);\n+                throw [\n+                    \"Expected \",\n+                    \",\", // comma\n+                    \", \",\n+                    \"&nbsp;\", // whitespace\n+                    \", \",\n+                    \":\", // colon\n+                    \" or \",\n+                    \"->\", // arrow\n+                    \", found \",\n+                    c,\n+                ];\n             }\n             const before = query.elems.length;\n             getNextElem(query, parserState, query.elems, false);\n@@ -540,7 +583,7 @@ function initSearch(rawSearchIndex) {\n                 getItemsBefore(query, parserState, query.returned, \"\");\n                 // Nothing can come afterward!\n                 if (query.returned.length === 0) {\n-                    throw new Error(\"Expected at least one item after `->`\");\n+                    throw [\"Expected at least one item after \", \"->\"];\n                 }\n                 break;\n             } else {\n@@ -694,7 +737,7 @@ function initSearch(rawSearchIndex) {\n             }\n         } catch (err) {\n             query = newParsedQuery(userQuery);\n-            query.error = err.message;\n+            query.error = err;\n             query.typeFilter = -1;\n             return query;\n         }\n@@ -1760,7 +1803,16 @@ function initSearch(rawSearchIndex) {\n \n         let output = `<h1 class=\"search-results-title\">Results${crates}</h1>`;\n         if (results.query.error !== null) {\n-            output += `<h3>Query parser error: \"${results.query.error}\".</h3>`;\n+            const error = results.query.error;\n+            error.forEach((value, index) => {\n+                value = value.split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n+                if (index % 2 !== 0) {\n+                    error[index] = `<code>${value}</code>`;\n+                } else {\n+                    error[index] = value;\n+                }\n+            });\n+            output += `<h3 class=\"error\">Query parser error: \"${error.join(\"\")}\".</h3>`;\n             output += \"<div id=\\\"search-tabs\\\">\" +\n                 makeTabHeader(0, \"In Names\", ret_others[1]) +\n                 \"</div>\";"}, {"sha": "969c81f7e32beefca931171b4758a32255bdd59f", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -777,10 +777,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n     type Provenance = Provenance;\n     type ProvenanceExtra = ProvenanceExtra;\n+    type Bytes = Box<[u8]>;\n \n     type MemoryMap = MonoHashMap<\n         AllocId,\n-        (MemoryKind<MiriMemoryKind>, Allocation<Provenance, Self::AllocExtra>),\n+        (MemoryKind<MiriMemoryKind>, Allocation<Provenance, Self::AllocExtra, Self::Bytes>),\n     >;\n \n     const GLOBAL_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Global);"}, {"sha": "ea5780f66d7f71356c1b8a68ce8a9ec4a3988a18", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -138,8 +138,20 @@ function valueCheck(fullPath, expected, result, error_text, queryName) {\n                 error_text.push('==> Unknown key \"' + key + '\"');\n                 break;\n             }\n+            let result_v = result[key];\n+            if (result_v !== null && key === \"error\") {\n+                result_v.forEach((value, index) => {\n+                    value = value.split(\"&nbsp;\").join(\" \");\n+                    if (index % 2 === 1) {\n+                        result_v[index] = \"`\" + value + \"`\";\n+                    } else {\n+                        result_v[index] = value;\n+                    }\n+                });\n+                result_v = result_v.join(\"\");\n+            }\n             const obj_path = fullPath + (fullPath.length > 0 ? '.' : '') + key;\n-            valueCheck(obj_path, expected[key], result[key], error_text, queryName);\n+            valueCheck(obj_path, expected[key], result_v, error_text, queryName);\n         }\n     } else {\n         expectedValue = JSON.stringify(expected);"}, {"sha": "2a10a647b53c3dd8ef5a585c231f16788ff8bd3c", "filename": "tests/rustdoc-gui/search-error.goml", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Frustdoc-gui%2Fsearch-error.goml", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Frustdoc-gui%2Fsearch-error.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsearch-error.goml?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -0,0 +1,39 @@\n+// Checks that the crate search filtering is handled correctly and changes the results.\n+goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html?search=sa'%3Bda'%3Bds\"\n+show-text: true\n+\n+define-function: (\n+    \"check-colors\",\n+    (theme, error_background),\n+    block {\n+        // Setting the theme.\n+        local-storage: {\"rustdoc-theme\": |theme|, \"rustdoc-use-system-theme\": \"false\"}\n+        // We reload the page so the local storage settings are being used.\n+        reload:\n+\n+        wait-for: \"#search .error code\"\n+        assert-css: (\"#search .error code\", {\"background-color\": |error_background|})\n+    }\n+)\n+\n+call-function: (\n+    \"check-colors\",\n+    {\n+        \"theme\": \"ayu\",\n+        \"error_background\": \"rgb(79, 76, 76)\",\n+    },\n+)\n+call-function: (\n+    \"check-colors\",\n+    {\n+        \"theme\": \"dark\",\n+        \"error_background\": \"rgb(72, 72, 72)\",\n+    },\n+)\n+call-function: (\n+    \"check-colors\",\n+    {\n+        \"theme\": \"light\",\n+        \"error_background\": \"rgb(208, 204, 204)\",\n+    },\n+)"}, {"sha": "6c5a777028335a66615944124889dca8ea86e64f", "filename": "tests/rustdoc-js-std/parser-errors.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Frustdoc-js-std%2Fparser-errors.js", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Frustdoc-js-std%2Fparser-errors.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-errors.js?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -67,7 +67,7 @@ const PARSED = [\n         returned: [],\n         typeFilter: -1,\n         userQuery: \"a<\\\"p\\\">\",\n-        error: \"`\\\"` cannot be used in generics\",\n+        error: \"Unexpected `\\\"` in generics\",\n     },\n     {\n         elems: [],\n@@ -373,7 +373,7 @@ const PARSED = [\n         returned: [],\n         typeFilter: -1,\n         userQuery: \"a!a\",\n-        error: '`!` can only be at the end of an ident',\n+        error: 'Unexpected `!`: it can only be at the end of an ident',\n     },\n     {\n         elems: [],"}, {"sha": "0fbd851431ea6c6fa9959856fa3e558a1f0c6f1a", "filename": "tests/ui/errors/trait-bound-error-spans/blame-trait-error.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -18,11 +18,85 @@ struct Burrito<F> {\n     filling: F,\n }\n \n+impl<It: Iterator> T1 for Option<It> {}\n+\n+impl<'a, A: T1> T1 for &'a A {}\n+\n fn want<V: T1>(_x: V) {}\n \n+enum ExampleTuple<T> {\n+    ExampleTupleVariant(T),\n+}\n+use ExampleDifferentTupleVariantName as ExampleYetAnotherTupleVariantName;\n+use ExampleTuple as ExampleOtherTuple;\n+use ExampleTuple::ExampleTupleVariant as ExampleDifferentTupleVariantName;\n+use ExampleTuple::*;\n+\n+impl<A> T1 for ExampleTuple<A> where A: T3 {}\n+\n+enum ExampleStruct<T> {\n+    ExampleStructVariant { field: T },\n+}\n+use ExampleDifferentStructVariantName as ExampleYetAnotherStructVariantName;\n+use ExampleStruct as ExampleOtherStruct;\n+use ExampleStruct::ExampleStructVariant as ExampleDifferentStructVariantName;\n+use ExampleStruct::*;\n+\n+impl<A> T1 for ExampleStruct<A> where A: T3 {}\n+\n+struct ExampleActuallyTupleStruct<T>(T, i32);\n+use ExampleActuallyTupleStruct as ExampleActuallyTupleStructOther;\n+\n+impl<A> T1 for ExampleActuallyTupleStruct<A> where A: T3 {}\n+\n fn example<Q>(q: Q) {\n     want(Wrapper { value: Burrito { filling: q } });\n     //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    want(Some(()));\n+    //~^ ERROR `()` is not an iterator [E0277]\n+\n+    want(Some(q));\n+    //~^ ERROR `Q` is not an iterator [E0277]\n+\n+    want(&Some(q));\n+    //~^ ERROR `Q` is not an iterator [E0277]\n+\n+    want(&ExampleTuple::ExampleTupleVariant(q));\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleTupleVariant(q));\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleOtherTuple::ExampleTupleVariant(q));\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleDifferentTupleVariantName(q));\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleYetAnotherTupleVariantName(q));\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleStruct::ExampleStructVariant { field: q });\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleStructVariant { field: q });\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleOtherStruct::ExampleStructVariant { field: q });\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleDifferentStructVariantName { field: q });\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleYetAnotherStructVariantName { field: q });\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleActuallyTupleStruct(q, 0));\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n+\n+    want(&ExampleActuallyTupleStructOther(q, 0));\n+    //~^ ERROR `Q: T3` is not satisfied [E0277]\n }\n \n fn main() {}"}, {"sha": "9228a047e8785c0930d45b5e40ec2a435f744552", "filename": "tests/ui/errors/trait-bound-error-spans/blame-trait-error.stderr", "status": "modified", "additions": 370, "deletions": 3, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error.rs:24:46\n+  --> $DIR/blame-trait-error.rs:53:46\n    |\n LL |     want(Wrapper { value: Burrito { filling: q } });\n    |     ----                                     ^ the trait `T3` is not implemented for `Q`\n@@ -21,7 +21,7 @@ LL | impl<B: T2> T1 for Wrapper<B> {}\n    |         |\n    |         unsatisfied trait bound introduced here\n note: required by a bound in `want`\n-  --> $DIR/blame-trait-error.rs:21:12\n+  --> $DIR/blame-trait-error.rs:25:12\n    |\n LL | fn want<V: T1>(_x: V) {}\n    |            ^^ required by this bound in `want`\n@@ -30,6 +30,373 @@ help: consider restricting type parameter `Q`\n LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n-error: aborting due to previous error\n+error[E0277]: `()` is not an iterator\n+  --> $DIR/blame-trait-error.rs:56:15\n+   |\n+LL |     want(Some(()));\n+   |     ----      ^^ `()` is not an iterator\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Iterator` is not implemented for `()`\n+   = help: the trait `T1` is implemented for `Option<It>`\n+note: required for `Option<()>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:21:20\n+   |\n+LL | impl<It: Iterator> T1 for Option<It> {}\n+   |          --------  ^^     ^^^^^^^^^^\n+   |          |\n+   |          unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+\n+error[E0277]: `Q` is not an iterator\n+  --> $DIR/blame-trait-error.rs:59:15\n+   |\n+LL |     want(Some(q));\n+   |     ----      ^ `Q` is not an iterator\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Option<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:21:20\n+   |\n+LL | impl<It: Iterator> T1 for Option<It> {}\n+   |          --------  ^^     ^^^^^^^^^^\n+   |          |\n+   |          unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: std::iter::Iterator>(q: Q) {\n+   |             +++++++++++++++++++++\n+\n+error[E0277]: `Q` is not an iterator\n+  --> $DIR/blame-trait-error.rs:62:16\n+   |\n+LL |     want(&Some(q));\n+   |     ----       ^ `Q` is not an iterator\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Option<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:21:20\n+   |\n+LL | impl<It: Iterator> T1 for Option<It> {}\n+   |          --------  ^^     ^^^^^^^^^^\n+   |          |\n+   |          unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&Option<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: std::iter::Iterator>(q: Q) {\n+   |             +++++++++++++++++++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:65:45\n+   |\n+LL |     want(&ExampleTuple::ExampleTupleVariant(q));\n+   |     ----                                    ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `ExampleTuple<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:35:9\n+   |\n+LL | impl<A> T1 for ExampleTuple<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleTuple<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:68:31\n+   |\n+LL |     want(&ExampleTupleVariant(q));\n+   |     ----                      ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `ExampleTuple<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:35:9\n+   |\n+LL | impl<A> T1 for ExampleTuple<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleTuple<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:71:50\n+   |\n+LL |     want(&ExampleOtherTuple::ExampleTupleVariant(q));\n+   |     ----                                         ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `ExampleTuple<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:35:9\n+   |\n+LL | impl<A> T1 for ExampleTuple<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleTuple<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:74:44\n+   |\n+LL |     want(&ExampleDifferentTupleVariantName(q));\n+   |     ----                                   ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `ExampleTuple<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:35:9\n+   |\n+LL | impl<A> T1 for ExampleTuple<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleTuple<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:77:45\n+   |\n+LL |     want(&ExampleYetAnotherTupleVariantName(q));\n+   |     ----                                    ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `ExampleTuple<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:35:9\n+   |\n+LL | impl<A> T1 for ExampleTuple<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleTuple<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:80:56\n+   |\n+LL |     want(&ExampleStruct::ExampleStructVariant { field: q });\n+   |     ---- required by a bound introduced by this call   ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `ExampleStruct<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:45:9\n+   |\n+LL | impl<A> T1 for ExampleStruct<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleStruct<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:83:41\n+   |\n+LL |     want(&ExampleStructVariant { field: q });\n+   |     ----                                ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `ExampleStruct<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:45:9\n+   |\n+LL | impl<A> T1 for ExampleStruct<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleStruct<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:86:61\n+   |\n+LL |     want(&ExampleOtherStruct::ExampleStructVariant { field: q });\n+   |     ---- required by a bound introduced by this call        ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `ExampleStruct<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:45:9\n+   |\n+LL | impl<A> T1 for ExampleStruct<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleStruct<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:89:54\n+   |\n+LL |     want(&ExampleDifferentStructVariantName { field: q });\n+   |     ---- required by a bound introduced by this call ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `ExampleStruct<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:45:9\n+   |\n+LL | impl<A> T1 for ExampleStruct<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleStruct<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:92:55\n+   |\n+LL |     want(&ExampleYetAnotherStructVariantName { field: q });\n+   |     ---- required by a bound introduced by this call  ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `ExampleStruct<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:45:9\n+   |\n+LL | impl<A> T1 for ExampleStruct<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleStruct<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:95:38\n+   |\n+LL |     want(&ExampleActuallyTupleStruct(q, 0));\n+   |     ----                             ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `ExampleActuallyTupleStruct<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:50:9\n+   |\n+LL | impl<A> T1 for ExampleActuallyTupleStruct<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleActuallyTupleStruct<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:98:43\n+   |\n+LL |     want(&ExampleActuallyTupleStructOther(q, 0));\n+   |     ----                                  ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `ExampleActuallyTupleStruct<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:50:9\n+   |\n+LL | impl<A> T1 for ExampleActuallyTupleStruct<A> where A: T3 {}\n+   |         ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^          -- unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `&ExampleActuallyTupleStruct<Q>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:25:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to 16 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "b6a24e12bcc76819f531e74644e226a341d2474b", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -91,10 +91,10 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:93:27\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:93:53\n    |\n LL |     want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n-   |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n+   |     ----                                            ^ the trait `T3` is not implemented for `Q`\n    |     |\n    |     required by a bound introduced by this call\n    |"}, {"sha": "1fb046c78f2a071f249953187a79906080e75a2d", "filename": "tests/ui/extenv/extenv-not-defined-default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fextenv%2Fextenv-not-defined-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fextenv%2Fextenv-not-defined-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextenv%2Fextenv-not-defined-default.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    env!(\"__HOPEFULLY_NOT_DEFINED__\");\n-    //~^ ERROR: environment variable `__HOPEFULLY_NOT_DEFINED__` not defined\n+    env!(\"CARGO__HOPEFULLY_NOT_DEFINED__\");\n+    //~^ ERROR: environment variable `CARGO__HOPEFULLY_NOT_DEFINED__` not defined\n }"}, {"sha": "e3dce000530ae336d9d4d3f4c484c3584e1cc2f9", "filename": "tests/ui/extenv/extenv-not-defined-default.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fextenv%2Fextenv-not-defined-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fextenv%2Fextenv-not-defined-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextenv%2Fextenv-not-defined-default.stderr?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -1,9 +1,10 @@\n-error: environment variable `__HOPEFULLY_NOT_DEFINED__` not defined\n+error: environment variable `CARGO__HOPEFULLY_NOT_DEFINED__` not defined at compile time\n   --> $DIR/extenv-not-defined-default.rs:2:5\n    |\n-LL |     env!(\"__HOPEFULLY_NOT_DEFINED__\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     env!(\"CARGO__HOPEFULLY_NOT_DEFINED__\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = help: Cargo sets build script variables at run time. Use `std::env::var(\"CARGO__HOPEFULLY_NOT_DEFINED__\")` instead\n    = note: this error originates in the macro `env` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "5752a965e3518cb5242407176f1b90296ac223eb", "filename": "tests/ui/extenv/issue-55897.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fextenv%2Fissue-55897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fextenv%2Fissue-55897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextenv%2Fissue-55897.stderr?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -1,9 +1,10 @@\n-error: environment variable `NON_EXISTENT` not defined\n+error: environment variable `NON_EXISTENT` not defined at compile time\n   --> $DIR/issue-55897.rs:11:22\n    |\n LL |     include!(concat!(env!(\"NON_EXISTENT\"), \"/data.rs\"));\n    |                      ^^^^^^^^^^^^^^^^^^^^\n    |\n+   = help: Use `std::env::var(\"NON_EXISTENT\")` to read the variable at run time\n    = note: this error originates in the macro `env` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: suffixes on string literals are invalid"}, {"sha": "dfce973d770b906b4449ca539625ba9699b9a10d", "filename": "tests/ui/impl-trait/in-trait/new-lowering-strategy/simple-trait.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-trait.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait Foo {\n+    fn foo() -> impl Sized;\n+}\n+\n+fn main() {}"}, {"sha": "93fbc9c8a447ee1cf33e5eb8986337160a9286b3", "filename": "tests/ui/macros/macros-nonfatal-errors.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -150,18 +150,19 @@ error: expected string literal\n LL |     env!(invalid);\n    |          ^^^^^^^\n \n-error: expected string literal\n-  --> $DIR/macros-nonfatal-errors.rs:105:10\n+error: env! takes 1 or 2 arguments\n+  --> $DIR/macros-nonfatal-errors.rs:105:5\n    |\n LL |     env!(foo, abr, baz);\n-   |          ^^^\n+   |     ^^^^^^^^^^^^^^^^^^^\n \n-error: environment variable `RUST_HOPEFULLY_THIS_DOESNT_EXIST` not defined\n+error: environment variable `RUST_HOPEFULLY_THIS_DOESNT_EXIST` not defined at compile time\n   --> $DIR/macros-nonfatal-errors.rs:106:5\n    |\n LL |     env!(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = help: Use `std::env::var(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\")` to read the variable at run time\n    = note: this error originates in the macro `env` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: format argument must be a string literal"}, {"sha": "910c0da27378a411c025ba0537932c734b685a4d", "filename": "tests/ui/thir-print/thir-flat.stdout", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fthir-print%2Fthir-flat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/tests%2Fui%2Fthir-print%2Fthir-flat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthir-print%2Fthir-flat.stdout?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -17,40 +17,40 @@ Thir {\n     ],\n     exprs: [\n         Expr {\n-            ty: (),\n-            temp_lifetime: Some(\n-                Node(2),\n-            ),\n-            span: $DIR/thir-flat.rs:4:15: 4:17 (#0),\n             kind: Block {\n                 block: b0,\n             },\n-        },\n-        Expr {\n             ty: (),\n             temp_lifetime: Some(\n                 Node(2),\n             ),\n             span: $DIR/thir-flat.rs:4:15: 4:17 (#0),\n+        },\n+        Expr {\n             kind: Scope {\n                 region_scope: Node(2),\n                 lint_level: Explicit(\n                     HirId(DefId(0:3 ~ thir_flat[45a6]::main).2),\n                 ),\n                 value: e0,\n             },\n-        },\n-        Expr {\n             ty: (),\n             temp_lifetime: Some(\n                 Node(2),\n             ),\n             span: $DIR/thir-flat.rs:4:15: 4:17 (#0),\n+        },\n+        Expr {\n             kind: Scope {\n                 region_scope: Destruction(2),\n                 lint_level: Inherited,\n                 value: e1,\n             },\n+            ty: (),\n+            temp_lifetime: Some(\n+                Node(2),\n+            ),\n+            span: $DIR/thir-flat.rs:4:15: 4:17 (#0),\n         },\n     ],\n     stmts: [],"}]}