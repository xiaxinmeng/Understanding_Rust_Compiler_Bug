{"sha": "9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMGFlNThkMzA1MjMxOThkZWM2MGE5Y2Q4NDBjMzBjMmJkOWM0YzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T06:14:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T06:14:41Z"}, "message": "Auto merge of #70351 - Centril:rollup-tveoq3w, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #68884 (Make the `type_of` return a generic type for generators)\n - #69788 (Fix sequence of Type and Trait in optin-builtin-traits in Unstable Book)\n - #70074 (Expand: nix all fatal errors)\n - #70077 (Store idents for `DefPathData` into crate metadata)\n - #70213 (traits/fulfill: allow `stalled_on` to track `ty::Const::Infer(_)` (unused yet).)\n - #70259 (Use Reveal::All in MIR optimizations)\n - #70284 (correctly handle const params in type_of)\n - #70289 (Refactor `codegen`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0ec28589d74b37976a4d11ffce40912d4c490270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ec28589d74b37976a4d11ffce40912d4c490270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "html_url": "https://github.com/rust-lang/rust/commit/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "url": "https://api.github.com/repos/rust-lang/rust/commits/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "html_url": "https://github.com/rust-lang/rust/commit/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60"}, {"sha": "170112cd1503aa6c220ba108441ee1d384beb9bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/170112cd1503aa6c220ba108441ee1d384beb9bc", "html_url": "https://github.com/rust-lang/rust/commit/170112cd1503aa6c220ba108441ee1d384beb9bc"}], "stats": {"total": 2181, "additions": 1527, "deletions": 654}, "files": [{"sha": "1ec8b8bf8ddbded7e89b020db55db2e0edd453db", "filename": "src/doc/unstable-book/src/language-features/optin-builtin-traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -16,7 +16,7 @@ has explicitly opted out via a negative impl.\n [`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n \n ```rust,ignore\n-impl !Type for Trait\n+impl !Trait for Type\n ```\n \n Example:"}, {"sha": "093815dbbcd4f1c1dfb9821119f9a305fbdf2b48", "filename": "src/librustc_builtin_macros/cmdline_attrs.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_builtin_macros%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_builtin_macros%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fcmdline_attrs.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -3,7 +3,6 @@\n use rustc_ast::ast::{self, AttrItem, AttrStyle};\n use rustc_ast::attr::mk_attr;\n use rustc_ast::token;\n-use rustc_expand::panictry;\n use rustc_session::parse::ParseSess;\n use rustc_span::FileName;\n \n@@ -16,7 +15,13 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n         );\n \n         let start_span = parser.token.span;\n-        let AttrItem { path, args } = panictry!(parser.parse_attr_item());\n+        let AttrItem { path, args } = match parser.parse_attr_item() {\n+            Ok(ai) => ai,\n+            Err(mut err) => {\n+                err.emit();\n+                continue;\n+            }\n+        };\n         let end_span = parser.token.span;\n         if parser.token != token::Eof {\n             parse_sess.span_diagnostic.span_err(start_span.to(end_span), \"invalid crate attribute\");"}, {"sha": "67145c6bf433be3c2c950ccfc6b5f6197ffd6891", "filename": "src/librustc_builtin_macros/source_util.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fsource_util.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -5,7 +5,6 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n use rustc_expand::module::DirectoryOwnership;\n-use rustc_expand::panictry;\n use rustc_parse::{self, new_parser_from_file, parser::Parser};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n use rustc_span::symbol::Symbol;\n@@ -126,7 +125,7 @@ pub fn expand_include<'cx>(\n     }\n     impl<'a> base::MacResult for ExpandResult<'a> {\n         fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> {\n-            let r = panictry!(self.p.parse_expr());\n+            let r = base::parse_expr(&mut self.p)?;\n             if self.p.token != token::Eof {\n                 self.p.sess.buffer_lint(\n                     &INCOMPLETE_INCLUDE,\n@@ -141,18 +140,17 @@ pub fn expand_include<'cx>(\n         fn make_items(mut self: Box<ExpandResult<'a>>) -> Option<SmallVec<[P<ast::Item>; 1]>> {\n             let mut ret = SmallVec::new();\n             while self.p.token != token::Eof {\n-                match panictry!(self.p.parse_item()) {\n-                    Some(item) => ret.push(item),\n-                    None => {\n+                match self.p.parse_item() {\n+                    Err(mut err) => {\n+                        err.emit();\n+                        break;\n+                    }\n+                    Ok(Some(item)) => ret.push(item),\n+                    Ok(None) => {\n                         let token = pprust::token_to_string(&self.p.token);\n-                        self.p\n-                            .sess\n-                            .span_diagnostic\n-                            .span_fatal(\n-                                self.p.token.span,\n-                                &format!(\"expected item, found `{}`\", token),\n-                            )\n-                            .raise();\n+                        let msg = format!(\"expected item, found `{}`\", token);\n+                        self.p.struct_span_err(self.p.token.span, &msg).emit();\n+                        break;\n                     }\n                 }\n             }"}, {"sha": "bdc4ae2fe274b9598ef2cca04a10e1b578714b11", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -74,16 +74,16 @@ pub fn expand_test_or_bench(\n         return vec![];\n     }\n \n-    let item = if let Annotatable::Item(i) = item {\n-        i\n-    } else {\n-        cx.parse_sess\n-            .span_diagnostic\n-            .span_fatal(\n-                item.span(),\n+    let item = match item {\n+        Annotatable::Item(i) => i,\n+        other => {\n+            cx.struct_span_err(\n+                other.span(),\n                 \"`#[test]` attribute is only allowed on non associated functions\",\n             )\n-            .raise();\n+            .emit();\n+            return vec![other];\n+        }\n     };\n \n     if let ast::ItemKind::MacCall(_) = item.kind {"}, {"sha": "160a5204eaf703d3352e6d6676ac4a3422d18e6b", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -345,14 +345,14 @@ fn is_test_case(i: &ast::Item) -> bool {\n \n fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n     let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n-    test_attr.meta_item_list().map(|meta_list| {\n-        if meta_list.len() != 1 {\n-            sd.span_fatal(test_attr.span, \"`#![test_runner(..)]` accepts exactly 1 argument\")\n-                .raise()\n-        }\n-        match meta_list[0].meta_item() {\n-            Some(meta_item) if meta_item.is_word() => meta_item.path.clone(),\n-            _ => sd.span_fatal(test_attr.span, \"`test_runner` argument must be a path\").raise(),\n-        }\n-    })\n+    let meta_list = test_attr.meta_item_list()?;\n+    let span = test_attr.span;\n+    match &*meta_list {\n+        [single] => match single.meta_item() {\n+            Some(meta_item) if meta_item.is_word() => return Some(meta_item.path.clone()),\n+            _ => sd.struct_span_err(span, \"`test_runner` argument must be a path\").emit(),\n+        },\n+        _ => sd.struct_span_err(span, \"`#![test_runner(..)]` accepts exactly 1 argument\").emit(),\n+    }\n+    None\n }"}, {"sha": "5759eb2991a817d02781e84c1992aa4d21b2abdc", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 82, "deletions": 92, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -16,7 +16,7 @@ use crate::ModuleLlvm;\n use log::debug;\n use rustc::bug;\n use rustc::ty::TyCtxt;\n-use rustc_codegen_ssa::back::write::{run_assembler, CodegenContext, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{run_assembler, CodegenContext, EmbedBitcode, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen, RLIB_BYTECODE_EXTENSION};\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -634,30 +634,24 @@ pub(crate) unsafe fn codegen(\n             f(cpm)\n         }\n \n-        // If we don't have the integrated assembler, then we need to emit asm\n-        // from LLVM and use `gcc` to create the object file.\n-        let asm_to_obj = config.emit_obj && config.no_integrated_as;\n-\n-        // Change what we write and cleanup based on whether obj files are\n-        // just llvm bitcode. In that case write bitcode, and possibly\n-        // delete the bitcode if it wasn't requested. Don't generate the\n-        // machine code, instead copy the .o file from the .bc\n-        let write_bc = config.emit_bc || config.obj_is_bitcode;\n-        let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n-        let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm_to_obj;\n-        let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n+        // Two things to note:\n+        // - If object files are just LLVM bitcode we write bitcode, copy it to\n+        //   the .o file, and delete the bitcode if it wasn't otherwise\n+        //   requested.\n+        // - If we don't have the integrated assembler then we need to emit\n+        //   asm from LLVM and use `gcc` to create the object file.\n \n         let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n         let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n \n-        if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n+        if config.bitcode_needed() {\n             let _timer = cgcx\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_module_codegen_make_bitcode\", &module.name[..]);\n             let thin = ThinBuffer::new(llmod);\n             let data = thin.data();\n \n-            if write_bc {\n+            if config.emit_bc || config.obj_is_bitcode {\n                 let _timer = cgcx.prof.generic_activity_with_arg(\n                     \"LLVM_module_codegen_emit_bitcode\",\n                     &module.name[..],\n@@ -668,7 +662,7 @@ pub(crate) unsafe fn codegen(\n                 }\n             }\n \n-            if config.embed_bitcode {\n+            if config.embed_bitcode == EmbedBitcode::Full {\n                 let _timer = cgcx.prof.generic_activity_with_arg(\n                     \"LLVM_module_codegen_embed_bitcode\",\n                     &module.name[..],\n@@ -688,81 +682,75 @@ pub(crate) unsafe fn codegen(\n                     diag_handler.err(&msg);\n                 }\n             }\n-        } else if config.embed_bitcode_marker {\n+        } else if config.embed_bitcode == EmbedBitcode::Marker {\n             embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n-        {\n-            if config.emit_ir {\n-                let _timer = cgcx\n-                    .prof\n-                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_ir\", &module.name[..]);\n-                let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n-                let out_c = path_to_c_string(&out);\n-\n-                extern \"C\" fn demangle_callback(\n-                    input_ptr: *const c_char,\n-                    input_len: size_t,\n-                    output_ptr: *mut c_char,\n-                    output_len: size_t,\n-                ) -> size_t {\n-                    let input = unsafe {\n-                        slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n-                    };\n-\n-                    let input = match str::from_utf8(input) {\n-                        Ok(s) => s,\n-                        Err(_) => return 0,\n-                    };\n-\n-                    let output = unsafe {\n-                        slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n-                    };\n-                    let mut cursor = io::Cursor::new(output);\n-\n-                    let demangled = match rustc_demangle::try_demangle(input) {\n-                        Ok(d) => d,\n-                        Err(_) => return 0,\n-                    };\n-\n-                    if write!(cursor, \"{:#}\", demangled).is_err() {\n-                        // Possible only if provided buffer is not big enough\n-                        return 0;\n-                    }\n-\n-                    cursor.position() as size_t\n+        if config.emit_ir {\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_module_codegen_emit_ir\", &module.name[..]);\n+            let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n+            let out_c = path_to_c_string(&out);\n+\n+            extern \"C\" fn demangle_callback(\n+                input_ptr: *const c_char,\n+                input_len: size_t,\n+                output_ptr: *mut c_char,\n+                output_len: size_t,\n+            ) -> size_t {\n+                let input =\n+                    unsafe { slice::from_raw_parts(input_ptr as *const u8, input_len as usize) };\n+\n+                let input = match str::from_utf8(input) {\n+                    Ok(s) => s,\n+                    Err(_) => return 0,\n+                };\n+\n+                let output = unsafe {\n+                    slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n+                };\n+                let mut cursor = io::Cursor::new(output);\n+\n+                let demangled = match rustc_demangle::try_demangle(input) {\n+                    Ok(d) => d,\n+                    Err(_) => return 0,\n+                };\n+\n+                if write!(cursor, \"{:#}\", demangled).is_err() {\n+                    // Possible only if provided buffer is not big enough\n+                    return 0;\n                 }\n \n-                let result = llvm::LLVMRustPrintModule(llmod, out_c.as_ptr(), demangle_callback);\n-                result.into_result().map_err(|()| {\n-                    let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n-                    llvm_err(diag_handler, &msg)\n-                })?;\n+                cursor.position() as size_t\n             }\n \n-            if config.emit_asm || asm_to_obj {\n-                let _timer = cgcx\n-                    .prof\n-                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n-                let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+            let result = llvm::LLVMRustPrintModule(llmod, out_c.as_ptr(), demangle_callback);\n+            result.into_result().map_err(|()| {\n+                let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n+                llvm_err(diag_handler, &msg)\n+            })?;\n+        }\n \n-                // We can't use the same module for asm and binary output, because that triggers\n-                // various errors like invalid IR or broken binaries, so we might have to clone the\n-                // module to produce the asm output\n-                let llmod = if config.emit_obj { llvm::LLVMCloneModule(llmod) } else { llmod };\n-                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                    write_output_file(\n-                        diag_handler,\n-                        tm,\n-                        cpm,\n-                        llmod,\n-                        &path,\n-                        llvm::FileType::AssemblyFile,\n-                    )\n-                })?;\n-            }\n+        let config_emit_normal_obj = config.emit_obj && !config.obj_is_bitcode;\n \n-            if write_obj {\n+        if config.emit_asm || (config_emit_normal_obj && config.no_integrated_as) {\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n+            let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+\n+            // We can't use the same module for asm and binary output, because that triggers\n+            // various errors like invalid IR or broken binaries, so we might have to clone the\n+            // module to produce the asm output\n+            let llmod = if config.emit_obj { llvm::LLVMCloneModule(llmod) } else { llmod };\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                write_output_file(diag_handler, tm, cpm, llmod, &path, llvm::FileType::AssemblyFile)\n+            })?;\n+        }\n+\n+        if config_emit_normal_obj {\n+            if !config.no_integrated_as {\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n@@ -776,7 +764,7 @@ pub(crate) unsafe fn codegen(\n                         llvm::FileType::ObjectFile,\n                     )\n                 })?;\n-            } else if asm_to_obj {\n+            } else {\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_asm_to_obj\", &module.name[..]);\n@@ -789,17 +777,19 @@ pub(crate) unsafe fn codegen(\n             }\n         }\n \n-        if copy_bc_to_obj {\n-            debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n-            if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n-                diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+        if config.obj_is_bitcode {\n+            if config.emit_obj {\n+                debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n+                if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n+                    diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+                }\n             }\n-        }\n \n-        if rm_bc {\n-            debug!(\"removing_bitcode {:?}\", bc_out);\n-            if let Err(e) = fs::remove_file(&bc_out) {\n-                diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+            if !config.emit_bc {\n+                debug!(\"removing_bitcode {:?}\", bc_out);\n+                if let Err(e) = fs::remove_file(&bc_out) {\n+                    diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+                }\n             }\n         }\n "}, {"sha": "a4b5acdcd18a2123a2bfbdb1cdf4cff3cae5898d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -51,6 +51,14 @@ use std::thread;\n \n const PRE_LTO_BC_EXT: &str = \"pre-lto.bc\";\n \n+/// The kind of bitcode to embed in object files.\n+#[derive(PartialEq)]\n+pub enum EmbedBitcode {\n+    None,\n+    Marker,\n+    Full,\n+}\n+\n /// Module-specific configuration for `optimize_and_codegen`.\n pub struct ModuleConfig {\n     /// Names of additional optimization passes to run.\n@@ -74,7 +82,6 @@ pub struct ModuleConfig {\n     pub emit_no_opt_bc: bool,\n     pub emit_bc: bool,\n     pub emit_bc_compressed: bool,\n-    pub emit_lto_bc: bool,\n     pub emit_ir: bool,\n     pub emit_asm: bool,\n     pub emit_obj: bool,\n@@ -94,8 +101,7 @@ pub struct ModuleConfig {\n     // emscripten's ecc compiler, when used as the linker.\n     pub obj_is_bitcode: bool,\n     pub no_integrated_as: bool,\n-    pub embed_bitcode: bool,\n-    pub embed_bitcode_marker: bool,\n+    pub embed_bitcode: EmbedBitcode,\n }\n \n impl ModuleConfig {\n@@ -116,13 +122,11 @@ impl ModuleConfig {\n             emit_pre_lto_bc: false,\n             emit_bc: false,\n             emit_bc_compressed: false,\n-            emit_lto_bc: false,\n             emit_ir: false,\n             emit_asm: false,\n             emit_obj: false,\n             obj_is_bitcode: false,\n-            embed_bitcode: false,\n-            embed_bitcode_marker: false,\n+            embed_bitcode: EmbedBitcode::None,\n             no_integrated_as: false,\n \n             verify_llvm_ir: false,\n@@ -145,16 +149,15 @@ impl ModuleConfig {\n         self.new_llvm_pass_manager = sess.opts.debugging_opts.new_llvm_pass_manager;\n         self.obj_is_bitcode =\n             sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled();\n-        let embed_bitcode =\n-            sess.target.target.options.embed_bitcode || sess.opts.debugging_opts.embed_bitcode;\n-        if embed_bitcode {\n-            match sess.opts.optimize {\n-                config::OptLevel::No | config::OptLevel::Less => {\n-                    self.embed_bitcode_marker = embed_bitcode;\n+        self.embed_bitcode =\n+            if sess.target.target.options.embed_bitcode || sess.opts.debugging_opts.embed_bitcode {\n+                match sess.opts.optimize {\n+                    config::OptLevel::No | config::OptLevel::Less => EmbedBitcode::Marker,\n+                    _ => EmbedBitcode::Full,\n                 }\n-                _ => self.embed_bitcode = embed_bitcode,\n-            }\n-        }\n+            } else {\n+                EmbedBitcode::None\n+            };\n \n         // Copy what clang does by turning on loop vectorization at O2 and\n         // slp vectorization at O3. Otherwise configure other optimization aspects\n@@ -190,7 +193,10 @@ impl ModuleConfig {\n     }\n \n     pub fn bitcode_needed(&self) -> bool {\n-        self.emit_bc || self.obj_is_bitcode || self.emit_bc_compressed || self.embed_bitcode\n+        self.emit_bc\n+            || self.obj_is_bitcode\n+            || self.emit_bc_compressed\n+            || self.embed_bitcode == EmbedBitcode::Full\n     }\n }\n \n@@ -379,7 +385,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         modules_config.emit_no_opt_bc = true;\n         modules_config.emit_pre_lto_bc = true;\n         modules_config.emit_bc = true;\n-        modules_config.emit_lto_bc = true;\n         metadata_config.emit_bc = true;\n         allocator_config.emit_bc = true;\n     }"}, {"sha": "59c1a5468f100caf5771584f451cec1c3a4c9a75", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -10,7 +10,7 @@ use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n@@ -296,16 +296,26 @@ where\n }\n \n pub trait ProcMacro {\n-    fn expand<'cx>(&self, ecx: &'cx mut ExtCtxt<'_>, span: Span, ts: TokenStream) -> TokenStream;\n+    fn expand<'cx>(\n+        &self,\n+        ecx: &'cx mut ExtCtxt<'_>,\n+        span: Span,\n+        ts: TokenStream,\n+    ) -> Result<TokenStream, ErrorReported>;\n }\n \n impl<F> ProcMacro for F\n where\n     F: Fn(TokenStream) -> TokenStream,\n {\n-    fn expand<'cx>(&self, _ecx: &'cx mut ExtCtxt<'_>, _span: Span, ts: TokenStream) -> TokenStream {\n+    fn expand<'cx>(\n+        &self,\n+        _ecx: &'cx mut ExtCtxt<'_>,\n+        _span: Span,\n+        ts: TokenStream,\n+    ) -> Result<TokenStream, ErrorReported> {\n         // FIXME setup implicit context in TLS before calling self.\n-        (*self)(ts)\n+        Ok((*self)(ts))\n     }\n }\n \n@@ -316,7 +326,7 @@ pub trait AttrProcMacro {\n         span: Span,\n         annotation: TokenStream,\n         annotated: TokenStream,\n-    ) -> TokenStream;\n+    ) -> Result<TokenStream, ErrorReported>;\n }\n \n impl<F> AttrProcMacro for F\n@@ -329,9 +339,9 @@ where\n         _span: Span,\n         annotation: TokenStream,\n         annotated: TokenStream,\n-    ) -> TokenStream {\n+    ) -> Result<TokenStream, ErrorReported> {\n         // FIXME setup implicit context in TLS before calling self.\n-        (*self)(annotation, annotated)\n+        Ok((*self)(annotation, annotated))\n     }\n }\n \n@@ -1004,31 +1014,9 @@ impl<'a> ExtCtxt<'a> {\n         self.current_expansion.id.expansion_cause()\n     }\n \n-    pub fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.struct_span_warn(sp, msg)\n-    }\n     pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n         self.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n     }\n-    pub fn struct_span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.struct_span_fatal(sp, msg)\n-    }\n-\n-    /// Emit `msg` attached to `sp`, and stop compilation immediately.\n-    ///\n-    /// `span_err` should be strongly preferred where-ever possible:\n-    /// this should *only* be used when:\n-    ///\n-    /// - continuing has a high risk of flow-on errors (e.g., errors in\n-    ///   declaring a macro would cause all uses of that macro to\n-    ///   complain about \"undefined macro\"), or\n-    /// - there is literally nothing else that can be done (however,\n-    ///   in most cases one can construct a dummy expression/item to\n-    ///   substitute; we never hit resolve/type-checking so the dummy\n-    ///   value doesn't have to match anything)\n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.span_fatal(sp, msg).raise();\n-    }\n \n     /// Emit `msg` attached to `sp`, without immediately stopping\n     /// compilation.\n@@ -1038,9 +1026,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.parse_sess.span_diagnostic.span_err_with_code(sp, msg, code);\n-    }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }\n@@ -1168,6 +1153,18 @@ pub fn check_zero_tts(cx: &ExtCtxt<'_>, sp: Span, tts: TokenStream, name: &str)\n     }\n }\n \n+/// Parse an expression. On error, emit it, advancing to `Eof`, and return `None`.\n+pub fn parse_expr(p: &mut parser::Parser<'_>) -> Option<P<ast::Expr>> {\n+    match p.parse_expr() {\n+        Ok(e) => return Some(e),\n+        Err(mut err) => err.emit(),\n+    }\n+    while p.token != token::Eof {\n+        p.bump();\n+    }\n+    None\n+}\n+\n /// Interpreting `tts` as a comma-separated sequence of expressions,\n /// expect exactly one string literal, or emit an error and return `None`.\n pub fn get_single_str_from_tts(\n@@ -1181,7 +1178,7 @@ pub fn get_single_str_from_tts(\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None;\n     }\n-    let ret = panictry!(p.parse_expr());\n+    let ret = parse_expr(&mut p)?;\n     let _ = p.eat(&token::Comma);\n \n     if p.token != token::Eof {\n@@ -1190,8 +1187,8 @@ pub fn get_single_str_from_tts(\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| s.to_string())\n }\n \n-/// Extracts comma-separated expressions from `tts`. If there is a\n-/// parsing error, emit a non-fatal error and return `None`.\n+/// Extracts comma-separated expressions from `tts`.\n+/// On error, emit it, and return `None`.\n pub fn get_exprs_from_tts(\n     cx: &mut ExtCtxt<'_>,\n     sp: Span,\n@@ -1200,7 +1197,7 @@ pub fn get_exprs_from_tts(\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n-        let expr = panictry!(p.parse_expr());\n+        let expr = parse_expr(&mut p)?;\n \n         // Perform eager expansion on the expression.\n         // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`."}, {"sha": "51208906c2f2d97e221219e10ca1930a1b700adb", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -204,7 +204,7 @@ ast_fragments! {\n }\n \n impl AstFragmentKind {\n-    fn dummy(self, span: Span) -> AstFragment {\n+    crate fn dummy(self, span: Span) -> AstFragment {\n         self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n \n@@ -682,7 +682,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n-                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n+                    let tok_result = match expander.expand(self.cx, span, mac.args.inner_tokens()) {\n+                        Err(_) => return ExpandResult::Ready(fragment_kind.dummy(span)),\n+                        Ok(ts) => ts,\n+                    };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n@@ -709,8 +712,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     if let MacArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n                     }\n-                    let tok_result =\n-                        expander.expand(self.cx, span, attr_item.args.inner_tokens(), tokens);\n+                    let inner_tokens = attr_item.args.inner_tokens();\n+                    let tok_result = match expander.expand(self.cx, span, inner_tokens, tokens) {\n+                        Err(_) => return ExpandResult::Ready(fragment_kind.dummy(span)),\n+                        Ok(ts) => ts,\n+                    };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &attr_item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n@@ -1139,6 +1145,8 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             // macros are expanded before any lint passes so this warning has to be hardcoded\n             if attr.has_name(sym::derive) {\n                 self.cx\n+                    .parse_sess()\n+                    .span_diagnostic\n                     .struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n                     .note(\"this may become a hard error in a future release\")\n                     .emit();"}, {"sha": "876a26de3fb7e86c8fe355c585d6f8dd3490c840", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -9,25 +9,6 @@\n \n extern crate proc_macro as pm;\n \n-// A variant of 'try!' that panics on an Err. This is used as a crutch on the\n-// way towards a non-panic!-prone parser. It should be used for fatal parsing\n-// errors; eventually we plan to convert all code using panictry to just use\n-// normal try.\n-#[macro_export]\n-macro_rules! panictry {\n-    ($e:expr) => {{\n-        use rustc_errors::FatalError;\n-        use std::result::Result::{Err, Ok};\n-        match $e {\n-            Ok(e) => e,\n-            Err(mut e) => {\n-                e.emit();\n-                FatalError.raise()\n-            }\n-        }\n-    }};\n-}\n-\n mod placeholders;\n mod proc_macro_server;\n "}, {"sha": "e868b7e36aac5008d03236d7ab8012c30fb0dce5", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -84,7 +84,7 @@ use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n \n-use rustc_errors::{FatalError, PResult};\n+use rustc_errors::PResult;\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n@@ -271,6 +271,7 @@ crate enum ParseResult<T> {\n     Failure(Token, &'static str),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n+    ErrorReported,\n }\n \n /// A `ParseResult` where the `Success` variant contains a mapping of\n@@ -652,6 +653,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             Success(_) => {}\n             Failure(token, msg) => return Failure(token, msg),\n             Error(sp, msg) => return Error(sp, msg),\n+            ErrorReported => return ErrorReported,\n         }\n \n         // inner parse loop handled all cur_items, so it's empty\n@@ -735,10 +737,11 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let mut item = bb_items.pop().unwrap();\n             if let TokenTree::MetaVarDecl(span, _, ident) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n-                item.push_match(\n-                    match_cur,\n-                    MatchedNonterminal(Lrc::new(parse_nt(parser.to_mut(), span, ident.name))),\n-                );\n+                let nt = match parse_nt(parser.to_mut(), span, ident.name) {\n+                    Err(()) => return ErrorReported,\n+                    Ok(nt) => nt,\n+                };\n+                item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n                 item.idx += 1;\n                 item.match_cur += 1;\n             } else {\n@@ -849,20 +852,16 @@ fn may_begin_with(token: &Token, name: Name) -> bool {\n /// # Returns\n ///\n /// The parsed non-terminal.\n-fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Nonterminal {\n+fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Result<Nonterminal, ()> {\n     // FIXME(Centril): Consider moving this to `parser.rs` to make\n     // the visibilities of the methods used below `pub(super)` at most.\n-\n     if name == sym::tt {\n-        return token::NtTT(p.parse_token_tree());\n-    }\n-    match parse_nt_inner(p, sp, name) {\n-        Ok(nt) => nt,\n-        Err(mut err) => {\n-            err.emit();\n-            FatalError.raise();\n-        }\n+        return Ok(token::NtTT(p.parse_token_tree()));\n     }\n+    parse_nt_inner(p, sp, name).map_err(|mut err| {\n+        err.span_label(sp, format!(\"while parsing argument for this `{}` macro fragment\", name))\n+            .emit()\n+    })\n }\n \n fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a, Nonterminal> {"}, {"sha": "859362b5e29d391cd269ff8fe344fd4d6c82d5a5", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 91, "deletions": 53, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -4,7 +4,7 @@ use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstF\n use crate::mbe;\n use crate::mbe::macro_check;\n use crate::mbe::macro_parser::parse_tt;\n-use crate::mbe::macro_parser::{Error, Failure, Success};\n+use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success};\n use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n@@ -15,7 +15,7 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, DiagnosticBuilder, FatalError};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::Features;\n use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n@@ -83,41 +83,56 @@ fn suggest_slice_pat(e: &mut DiagnosticBuilder<'_>, site_span: Span, parser: &Pa\n     );\n }\n \n+fn emit_frag_parse_err(\n+    mut e: DiagnosticBuilder<'_>,\n+    parser: &Parser<'_>,\n+    site_span: Span,\n+    macro_ident: ast::Ident,\n+    arm_span: Span,\n+    kind: AstFragmentKind,\n+) {\n+    if parser.token == token::Eof && e.message().ends_with(\", found `<eof>`\") {\n+        if !e.span.is_dummy() {\n+            // early end of macro arm (#52866)\n+            e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n+        }\n+        let msg = &e.message[0];\n+        e.message[0] = (\n+            format!(\n+                \"macro expansion ends with an incomplete expression: {}\",\n+                msg.0.replace(\", found `<eof>`\", \"\"),\n+            ),\n+            msg.1,\n+        );\n+    }\n+    if e.span.is_dummy() {\n+        // Get around lack of span in error (#30128)\n+        e.replace_span_with(site_span);\n+        if !parser.sess.source_map().is_imported(arm_span) {\n+            e.span_label(arm_span, \"in this macro arm\");\n+        }\n+    } else if parser.sess.source_map().is_imported(parser.token.span) {\n+        e.span_label(site_span, \"in this macro invocation\");\n+    }\n+    match kind {\n+        AstFragmentKind::Pat if macro_ident.name == sym::vec => {\n+            suggest_slice_pat(&mut e, site_span, parser);\n+        }\n+        _ => annotate_err_with_kind(&mut e, kind, site_span),\n+    };\n+    e.emit();\n+}\n+\n impl<'a> ParserAnyMacro<'a> {\n     crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser, arm_span } = *self;\n-        let fragment = panictry!(parse_ast_fragment(parser, kind).map_err(|mut e| {\n-            if parser.token == token::Eof && e.message().ends_with(\", found `<eof>`\") {\n-                if !e.span.is_dummy() {\n-                    // early end of macro arm (#52866)\n-                    e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n-                }\n-                let msg = &e.message[0];\n-                e.message[0] = (\n-                    format!(\n-                        \"macro expansion ends with an incomplete expression: {}\",\n-                        msg.0.replace(\", found `<eof>`\", \"\"),\n-                    ),\n-                    msg.1,\n-                );\n+        let fragment = match parse_ast_fragment(parser, kind) {\n+            Ok(f) => f,\n+            Err(err) => {\n+                emit_frag_parse_err(err, parser, site_span, macro_ident, arm_span, kind);\n+                return kind.dummy(site_span);\n             }\n-            if e.span.is_dummy() {\n-                // Get around lack of span in error (#30128)\n-                e.replace_span_with(site_span);\n-                if !parser.sess.source_map().is_imported(arm_span) {\n-                    e.span_label(arm_span, \"in this macro arm\");\n-                }\n-            } else if parser.sess.source_map().is_imported(parser.token.span) {\n-                e.span_label(site_span, \"in this macro invocation\");\n-            }\n-            match kind {\n-                AstFragmentKind::Pat if macro_ident.name == sym::vec => {\n-                    suggest_slice_pat(&mut e, site_span, parser);\n-                }\n-                _ => annotate_err_with_kind(&mut e, kind, site_span),\n-            };\n-            e\n-        }));\n+        };\n \n         // We allow semicolons at the end of expressions -- e.g., the semicolon in\n         // `macro_rules! m { () => { panic!(); } }` isn't parsed by `.parse_expr()`,\n@@ -165,6 +180,14 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n     }\n }\n \n+fn macro_rules_dummy_expander<'cx>(\n+    _: &'cx mut ExtCtxt<'_>,\n+    span: Span,\n+    _: TokenStream,\n+) -> Box<dyn MacResult + 'cx> {\n+    DummyResult::any(span)\n+}\n+\n fn trace_macros_note(cx_expansions: &mut FxHashMap<Span, Vec<String>>, sp: Span, message: String) {\n     let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n     cx_expansions.entry(sp).or_default().push(message);\n@@ -240,7 +263,13 @@ fn generic_extension<'cx>(\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = transcribe(cx, &named_matches, rhs, transparency);\n+                let mut tts = match transcribe(cx, &named_matches, rhs, transparency) {\n+                    Ok(tts) => tts,\n+                    Err(mut err) => {\n+                        err.emit();\n+                        return DummyResult::any(arm_span);\n+                    }\n+                };\n \n                 // Replace all the tokens for the corresponding positions in the macro, to maintain\n                 // proper positions in error reporting, while maintaining the macro_backtrace.\n@@ -278,7 +307,12 @@ fn generic_extension<'cx>(\n                 Some((ref best_token, _)) if best_token.span.lo() >= token.span.lo() => {}\n                 _ => best_failure = Some((token, msg)),\n             },\n-            Error(err_sp, ref msg) => cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..]),\n+            Error(err_sp, ref msg) => {\n+                let span = err_sp.substitute_dummy(sp);\n+                cx.struct_span_err(span, &msg).emit();\n+                return DummyResult::any(span);\n+            }\n+            ErrorReported => return DummyResult::any(sp),\n         }\n \n         // The matcher was not `Success(..)`ful.\n@@ -337,6 +371,18 @@ pub fn compile_declarative_macro(\n     def: &ast::Item,\n     edition: Edition,\n ) -> SyntaxExtension {\n+    let mk_syn_ext = |expander| {\n+        SyntaxExtension::new(\n+            sess,\n+            SyntaxExtensionKind::LegacyBang(expander),\n+            def.span,\n+            Vec::new(),\n+            edition,\n+            def.ident.name,\n+            &def.attrs,\n+        )\n+    };\n+\n     let diag = &sess.span_diagnostic;\n     let lhs_nm = ast::Ident::new(sym::lhs, def.span);\n     let rhs_nm = ast::Ident::new(sym::rhs, def.span);\n@@ -391,13 +437,15 @@ pub fn compile_declarative_macro(\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n             let sp = token.span.substitute_dummy(def.span);\n-            let mut err = sess.span_diagnostic.struct_span_fatal(sp, &s);\n-            err.span_label(sp, msg);\n-            err.emit();\n-            FatalError.raise();\n+            sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n+        }\n+        Error(sp, msg) => {\n+            sess.span_diagnostic.struct_span_err(sp.substitute_dummy(def.span), &msg).emit();\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n         }\n-        Error(sp, s) => {\n-            sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &s).raise();\n+        ErrorReported => {\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n         }\n     };\n \n@@ -460,24 +508,14 @@ pub fn compile_declarative_macro(\n         None => {}\n     }\n \n-    let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n+    mk_syn_ext(Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         span: def.span,\n         transparency,\n         lhses,\n         rhses,\n         valid,\n-    });\n-\n-    SyntaxExtension::new(\n-        sess,\n-        SyntaxExtensionKind::LegacyBang(expander),\n-        def.span,\n-        Vec::new(),\n-        edition,\n-        def.ident.name,\n-        &def.attrs,\n-    )\n+    }))\n }\n \n fn check_lhs_nt_follows("}, {"sha": "e2d3d5c4d644e04076ac1fbb31ac672bdfa7f29e", "filename": "src/librustc_expand/mbe/transcribe.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::token::{self, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::pluralize;\n+use rustc_errors::{pluralize, PResult};\n use rustc_span::hygiene::{ExpnId, Transparency};\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n@@ -80,15 +80,15 @@ impl Iterator for Frame {\n /// `transcribe` would return a `TokenStream` containing `println!(\"{}\", stringify!(bar));`.\n ///\n /// Along the way, we do some additional error checking.\n-pub(super) fn transcribe(\n-    cx: &ExtCtxt<'_>,\n+pub(super) fn transcribe<'a>(\n+    cx: &ExtCtxt<'a>,\n     interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     src: Vec<mbe::TokenTree>,\n     transparency: Transparency,\n-) -> TokenStream {\n+) -> PResult<'a, TokenStream> {\n     // Nothing for us to transcribe...\n     if src.is_empty() {\n-        return TokenStream::default();\n+        return Ok(TokenStream::default());\n     }\n \n     // We descend into the RHS (`src`), expanding things as we go. This stack contains the things\n@@ -152,7 +152,7 @@ pub(super) fn transcribe(\n                 Frame::Delimited { forest, span, .. } => {\n                     if result_stack.is_empty() {\n                         // No results left to compute! We are back at the top-level.\n-                        return TokenStream::new(result);\n+                        return Ok(TokenStream::new(result));\n                     }\n \n                     // Step back into the parent Delimited.\n@@ -173,19 +173,19 @@ pub(super) fn transcribe(\n             seq @ mbe::TokenTree::Sequence(..) => {\n                 match lockstep_iter_size(&seq, interp, &repeats) {\n                     LockstepIterSize::Unconstrained => {\n-                        cx.span_fatal(\n+                        return Err(cx.struct_span_err(\n                             seq.span(), /* blame macro writer */\n                             \"attempted to repeat an expression containing no syntax variables \\\n                              matched as repeating at this depth\",\n-                        );\n+                        ));\n                     }\n \n                     LockstepIterSize::Contradiction(ref msg) => {\n                         // FIXME: this really ought to be caught at macro definition time... It\n                         // happens when two meta-variables are used in the same repetition in a\n                         // sequence, but they come from different sequence matchers and repeat\n                         // different amounts.\n-                        cx.span_fatal(seq.span(), &msg[..]);\n+                        return Err(cx.struct_span_err(seq.span(), &msg[..]));\n                     }\n \n                     LockstepIterSize::Constraint(len, _) => {\n@@ -203,7 +203,10 @@ pub(super) fn transcribe(\n                                 // FIXME: this really ought to be caught at macro definition\n                                 // time... It happens when the Kleene operator in the matcher and\n                                 // the body for the same meta-variable do not match.\n-                                cx.span_fatal(sp.entire(), \"this must repeat at least once\");\n+                                return Err(cx.struct_span_err(\n+                                    sp.entire(),\n+                                    \"this must repeat at least once\",\n+                                ));\n                             }\n                         } else {\n                             // 0 is the initial counter (we have done 0 repretitions so far). `len`\n@@ -242,10 +245,10 @@ pub(super) fn transcribe(\n                         }\n                     } else {\n                         // We were unable to descend far enough. This is an error.\n-                        cx.span_fatal(\n+                        return Err(cx.struct_span_err(\n                             sp, /* blame the macro writer */\n                             &format!(\"variable '{}' is still repeating at this depth\", ident),\n-                        );\n+                        ));\n                     }\n                 } else {\n                     // If we aren't able to match the meta-var, we push it back into the result but"}, {"sha": "df7bf9438c3d03c2d175105b4b88175506c0b74e", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 24, "deletions": 43, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::ast::{self, ItemKind, MetaItemKind, NestedMetaItem};\n use rustc_ast::token;\n use rustc_ast::tokenstream::{self, TokenStream};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, FatalError};\n+use rustc_errors::{Applicability, ErrorReported};\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -21,21 +21,16 @@ impl base::ProcMacro for BangProcMacro {\n         ecx: &'cx mut ExtCtxt<'_>,\n         span: Span,\n         input: TokenStream,\n-    ) -> TokenStream {\n+    ) -> Result<TokenStream, ErrorReported> {\n         let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, input) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"proc macro panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n+        self.client.run(&EXEC_STRATEGY, server, input).map_err(|e| {\n+            let mut err = ecx.struct_span_err(span, \"proc macro panicked\");\n+            if let Some(s) = e.as_str() {\n+                err.help(&format!(\"message: {}\", s));\n             }\n-        }\n+            err.emit();\n+            ErrorReported\n+        })\n     }\n }\n \n@@ -50,21 +45,16 @@ impl base::AttrProcMacro for AttrProcMacro {\n         span: Span,\n         annotation: TokenStream,\n         annotated: TokenStream,\n-    ) -> TokenStream {\n+    ) -> Result<TokenStream, ErrorReported> {\n         let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"custom attribute panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n+        self.client.run(&EXEC_STRATEGY, server, annotation, annotated).map_err(|e| {\n+            let mut err = ecx.struct_span_err(span, \"custom attribute panicked\");\n+            if let Some(s) = e.as_str() {\n+                err.help(&format!(\"message: {}\", s));\n             }\n-        }\n+            err.emit();\n+            ErrorReported\n+        })\n     }\n }\n \n@@ -96,8 +86,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             | Annotatable::Expr(_) => {\n                 ecx.span_err(\n                     span,\n-                    \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\",\n+                    \"proc-macro derives may only be applied to a struct, enum, or union\",\n                 );\n                 return ExpandResult::Ready(Vec::new());\n             }\n@@ -107,8 +96,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             _ => {\n                 ecx.span_err(\n                     span,\n-                    \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\",\n+                    \"proc-macro derives may only be applied to a struct, enum, or union\",\n                 );\n                 return ExpandResult::Ready(Vec::new());\n             }\n@@ -121,20 +109,16 @@ impl MultiItemModifier for ProcMacroDerive {\n         let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n             Ok(stream) => stream,\n             Err(e) => {\n-                let msg = \"proc-macro derive panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n+                let mut err = ecx.struct_span_err(span, \"proc-macro derive panicked\");\n                 if let Some(s) = e.as_str() {\n                     err.help(&format!(\"message: {}\", s));\n                 }\n-\n                 err.emit();\n-                FatalError.raise();\n+                return ExpandResult::Ready(vec![]);\n             }\n         };\n \n         let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n-        let msg = \"proc-macro derive produced unparseable tokens\";\n-\n         let mut parser =\n             rustc_parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n         let mut items = vec![];\n@@ -144,18 +128,15 @@ impl MultiItemModifier for ProcMacroDerive {\n                 Ok(None) => break,\n                 Ok(Some(item)) => items.push(Annotatable::Item(item)),\n                 Err(mut err) => {\n-                    // FIXME: handle this better\n-                    err.cancel();\n-                    ecx.struct_span_fatal(span, msg).emit();\n-                    FatalError.raise();\n+                    err.emit();\n+                    break;\n                 }\n             }\n         }\n \n         // fail if there have been errors emitted\n         if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n-            ecx.struct_span_fatal(span, msg).emit();\n-            FatalError.raise();\n+            ecx.struct_span_err(span, \"proc-macro derive produced unparseable tokens\").emit();\n         }\n \n         ExpandResult::Ready(items)"}, {"sha": "3334cc32a52f709fe659304c1bfde6f03b615157", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -159,6 +159,7 @@ impl DefKind {\n     }\n }\n \n+/// The resolution of a path or export.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Res<Id = hir::HirId> {"}, {"sha": "dc494b8e413700dbb0c2a5ca493ebfc24e0b6501", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 94, "deletions": 40, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -19,7 +19,7 @@ use rustc::traits::select;\n use rustc::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::relate::RelateResult;\n-use rustc::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n pub use rustc::ty::IntVarValue;\n use rustc::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n use rustc::ty::{ConstVid, FloatVid, IntVid, TyVid};\n@@ -501,6 +501,7 @@ impl NLLRegionVariableOrigin {\n     }\n }\n \n+// FIXME(eddyb) investigate overlap between this and `TyOrConstInferVar`.\n #[derive(Copy, Clone, Debug)]\n pub enum FixupError<'tcx> {\n     UnresolvedIntTy(IntVid),\n@@ -1347,8 +1348,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        let mut r = ShallowResolver::new(self);\n-        value.fold_with(&mut r)\n+        value.fold_with(&mut ShallowResolver { infcx: self })\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1551,22 +1551,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // variables, thus we don't need to substitute back the original values.\n         self.tcx.const_eval_resolve(param_env, def_id, substs, promoted, span)\n     }\n-}\n-\n-pub struct ShallowResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n-    #[inline(always)]\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n-        ShallowResolver { infcx }\n-    }\n \n     /// If `typ` is a type variable of some kind, resolve it one level\n     /// (but do not resolve types found in the result). If `typ` is\n     /// not a type variable, just return it unmodified.\n-    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+    // FIXME(eddyb) inline into `ShallowResolver::visit_ty`.\n+    fn shallow_resolve_ty(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.kind {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n@@ -1580,69 +1570,133 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // depth.\n                 //\n                 // Note: if these two lines are combined into one we get\n-                // dynamic borrow errors on `self.infcx.inner`.\n-                let known = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n-                known.map(|t| self.fold_ty(t)).unwrap_or(typ)\n+                // dynamic borrow errors on `self.inner`.\n+                let known = self.inner.borrow_mut().type_variables.probe(v).known();\n+                known.map(|t| self.shallow_resolve_ty(t)).unwrap_or(typ)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self\n-                .infcx\n                 .inner\n                 .borrow_mut()\n                 .int_unification_table\n                 .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n+                .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n \n             ty::Infer(ty::FloatVar(v)) => self\n-                .infcx\n                 .inner\n                 .borrow_mut()\n                 .float_unification_table\n                 .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n+                .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n \n             _ => typ,\n         }\n     }\n \n-    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n-    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n-    // inlined, despite being large, because it has only two call sites that\n-    // are extremely hot.\n+    /// `ty_or_const_infer_var_changed` is equivalent to one of these two:\n+    ///   * `shallow_resolve(ty) != ty` (where `ty.kind = ty::Infer(_)`)\n+    ///   * `shallow_resolve(ct) != ct` (where `ct.kind = ty::ConstKind::Infer(_)`)\n+    ///\n+    /// However, `ty_or_const_infer_var_changed` is more efficient. It's always\n+    /// inlined, despite being large, because it has only two call sites that\n+    /// are extremely hot (both in `traits::fulfill`'s checking of `stalled_on`\n+    /// inference variables), and it handles both `Ty` and `ty::Const` without\n+    /// having to resort to storing full `GenericArg`s in `stalled_on`.\n     #[inline(always)]\n-    pub fn shallow_resolve_changed(&self, infer: ty::InferTy) -> bool {\n-        match infer {\n-            ty::TyVar(v) => {\n+    pub fn ty_or_const_infer_var_changed(&self, infer_var: TyOrConstInferVar<'tcx>) -> bool {\n+        match infer_var {\n+            TyOrConstInferVar::Ty(v) => {\n                 use self::type_variable::TypeVariableValue;\n \n-                // If `inlined_probe` returns a `Known` value its `kind` never\n-                // matches `infer`.\n-                match self.infcx.inner.borrow_mut().type_variables.inlined_probe(v) {\n+                // If `inlined_probe` returns a `Known` value, it never equals\n+                // `ty::Infer(ty::TyVar(v))`.\n+                match self.inner.borrow_mut().type_variables.inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n             }\n \n-            ty::IntVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n+            TyOrConstInferVar::TyInt(v) => {\n+                // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which never matches a\n                 // `ty::Infer(_)`.\n-                self.infcx.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n+                self.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n             }\n \n-            ty::FloatVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n+            TyOrConstInferVar::TyFloat(v) => {\n+                // If `probe_value` returns a value it's always a\n                 // `ty::Float(_)`, which never matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.infcx.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n+                self.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n             }\n \n-            _ => unreachable!(),\n+            TyOrConstInferVar::Const(v) => {\n+                // If `probe_value` returns a `Known` value, it never equals\n+                // `ty::ConstKind::Infer(ty::InferConst::Var(v))`.\n+                //\n+                // Not `inlined_probe_value(v)` because this call site is colder.\n+                match self.inner.borrow_mut().const_unification_table.probe_value(v).val {\n+                    ConstVariableValue::Unknown { .. } => false,\n+                    ConstVariableValue::Known { .. } => true,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Helper for `ty_or_const_infer_var_changed` (see comment on that), currently\n+/// used only for `traits::fulfill`'s list of `stalled_on` inference variables.\n+#[derive(Copy, Clone, Debug)]\n+pub enum TyOrConstInferVar<'tcx> {\n+    /// Equivalent to `ty::Infer(ty::TyVar(_))`.\n+    Ty(TyVid),\n+    /// Equivalent to `ty::Infer(ty::IntVar(_))`.\n+    TyInt(IntVid),\n+    /// Equivalent to `ty::Infer(ty::FloatVar(_))`.\n+    TyFloat(FloatVid),\n+\n+    /// Equivalent to `ty::ConstKind::Infer(ty::InferConst::Var(_))`.\n+    Const(ConstVid<'tcx>),\n+}\n+\n+impl TyOrConstInferVar<'tcx> {\n+    /// Tries to extract an inference variable from a type or a constant, returns `None`\n+    /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`) and\n+    /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).\n+    pub fn maybe_from_generic_arg(arg: GenericArg<'tcx>) -> Option<Self> {\n+        match arg.unpack() {\n+            GenericArgKind::Type(ty) => Self::maybe_from_ty(ty),\n+            GenericArgKind::Const(ct) => Self::maybe_from_const(ct),\n+            GenericArgKind::Lifetime(_) => None,\n         }\n     }\n+\n+    /// Tries to extract an inference variable from a type, returns `None`\n+    /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`).\n+    pub fn maybe_from_ty(ty: Ty<'tcx>) -> Option<Self> {\n+        match ty.kind {\n+            ty::Infer(ty::TyVar(v)) => Some(TyOrConstInferVar::Ty(v)),\n+            ty::Infer(ty::IntVar(v)) => Some(TyOrConstInferVar::TyInt(v)),\n+            ty::Infer(ty::FloatVar(v)) => Some(TyOrConstInferVar::TyFloat(v)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Tries to extract an inference variable from a constant, returns `None`\n+    /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).\n+    pub fn maybe_from_const(ct: &'tcx ty::Const<'tcx>) -> Option<Self> {\n+        match ct.val {\n+            ty::ConstKind::Infer(InferConst::Var(v)) => Some(TyOrConstInferVar::Const(v)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+struct ShallowResolver<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n@@ -1651,7 +1705,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.shallow_resolve(ty)\n+        self.infcx.shallow_resolve_ty(ty)\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {"}, {"sha": "4520df588996e7a7dfec470e41088d05481731ef", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -509,14 +509,6 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl SpecializedDecoder<Ident> for DecodeContext<'_, '_> {\n-    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n-        // FIXME(jseyfried): intercrate hygiene\n-\n-        Ok(Ident::with_dummy_span(Symbol::decode(self)?))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n         Fingerprint::decode_opaque(&mut self.opaque)\n@@ -663,15 +655,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    fn item_ident(&self, item_index: DefIndex, sess: &Session) -> Ident {\n         if !self.is_proc_macro(item_index) {\n-            self.def_key(item_index)\n+            let name = self\n+                .def_key(item_index)\n                 .disambiguated_data\n                 .data\n                 .get_opt_name()\n-                .expect(\"no name in item_name\")\n+                .expect(\"no name in item_ident\");\n+            let span = self\n+                .root\n+                .per_def\n+                .ident_span\n+                .get(self, item_index)\n+                .map(|data| data.decode((self, sess)))\n+                .unwrap_or_else(|| panic!(\"Missing ident span for {:?} ({:?})\", name, item_index));\n+            Ident::new(name, span)\n         } else {\n-            Symbol::intern(self.raw_proc_macro(item_index).name())\n+            Ident::new(\n+                Symbol::intern(self.raw_proc_macro(item_index).name()),\n+                self.get_span(item_index, sess),\n+            )\n         }\n     }\n \n@@ -750,6 +754,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         kind: &EntryKind,\n         index: DefIndex,\n         parent_did: DefId,\n+        sess: &Session,\n     ) -> ty::VariantDef {\n         let data = match kind {\n             EntryKind::Variant(data) | EntryKind::Struct(data, _) | EntryKind::Union(data, _) => {\n@@ -771,7 +776,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         ty::VariantDef::new(\n             tcx,\n-            Ident::with_dummy_span(self.item_name(index)),\n+            self.item_ident(index, sess),\n             variant_did,\n             ctor_did,\n             data.discr,\n@@ -783,7 +788,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .decode(self)\n                 .map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    ident: Ident::with_dummy_span(self.item_name(index)),\n+                    ident: self.item_ident(index, sess),\n                     vis: self.get_visibility(index),\n                 })\n                 .collect(),\n@@ -812,10 +817,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or(Lazy::empty())\n                 .decode(self)\n-                .map(|index| self.get_variant(tcx, &self.kind(index), index, did))\n+                .map(|index| self.get_variant(tcx, &self.kind(index), index, did, tcx.sess))\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &kind, item_id, did)).collect()\n+            std::iter::once(self.get_variant(tcx, &kind, item_id, did, tcx.sess)).collect()\n         };\n \n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n@@ -1007,7 +1012,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n-                                    ident: Ident::with_dummy_span(self.item_name(child_index)),\n+                                    ident: self.item_ident(child_index, sess),\n                                     vis: self.get_visibility(child_index),\n                                     span: self\n                                         .root\n@@ -1028,10 +1033,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                 let def_key = self.def_key(child_index);\n                 let span = self.get_span(child_index, sess);\n-                if let (Some(kind), Some(name)) =\n-                    (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name())\n-                {\n-                    let ident = Ident::with_dummy_span(name);\n+                if let (Some(kind), true) = (\n+                    self.def_kind(child_index),\n+                    def_key.disambiguated_data.data.get_opt_name().is_some(),\n+                ) {\n+                    let ident = self.item_ident(child_index, sess);\n                     let vis = self.get_visibility(child_index);\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n@@ -1138,10 +1144,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n+    fn get_associated_item(&self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n-        let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n+        let ident = self.item_ident(id, sess);\n \n         let (kind, container, has_self) = match self.kind(id) {\n             EntryKind::AssocConst(container, _, _) => (ty::AssocKind::Const, container, false),\n@@ -1155,7 +1161,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         };\n \n         ty::AssocItem {\n-            ident: Ident::with_dummy_span(name),\n+            ident,\n             kind,\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n@@ -1219,7 +1225,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .get(self, id)\n             .unwrap_or(Lazy::empty())\n             .decode(self)\n-            .map(|index| respan(self.get_span(index, sess), self.item_name(index)))\n+            .map(|index| respan(self.get_span(index, sess), self.item_ident(index, sess).name))\n             .collect()\n     }\n "}, {"sha": "b9f1dd1663eee4de658b95efab064ad54e36776b", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -110,7 +110,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n           |child| result.push(child.res.def_id()), tcx.sess);\n         tcx.arena.alloc_slice(&result)\n     }\n-    associated_item => { cdata.get_associated_item(def_id.index) }\n+    associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n     impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n     coerce_unsized_info => {\n@@ -442,8 +442,8 @@ impl CStore {\n         )\n     }\n \n-    pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n-        self.get_crate_data(def.krate).get_associated_item(def.index)\n+    pub fn associated_item_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::AssocItem {\n+        self.get_crate_data(def.krate).get_associated_item(def.index, sess)\n     }\n \n     pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {"}, {"sha": "9718d192816207c8887e43910d1dda21e90bff7e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -12,7 +12,7 @@ use rustc::traits::specialization_graph;\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_ast::ast;\n+use rustc_ast::ast::{self, Ident};\n use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -30,7 +30,7 @@ use rustc_index::vec::Idx;\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n use rustc_session::config::{self, CrateType};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n@@ -220,13 +220,6 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n     }\n }\n \n-impl SpecializedEncoder<Ident> for EncodeContext<'tcx> {\n-    fn specialized_encode(&mut self, ident: &Ident) -> Result<(), Self::Error> {\n-        // FIXME(jseyfried): intercrate hygiene\n-        ident.name.encode(self)\n-    }\n-}\n-\n impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -633,6 +626,7 @@ impl EncodeContext<'tcx> {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n+        self.encode_ident_span(def_id, variant.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n@@ -735,6 +729,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- field.vis);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.per_def.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n+        self.encode_ident_span(def_id, field.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n@@ -869,6 +864,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- trait_item.vis);\n         record!(self.per_def.span[def_id] <- ast_item.span);\n         record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        self.encode_ident_span(def_id, ast_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -952,6 +948,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- impl_item.vis);\n         record!(self.per_def.span[def_id] <- ast_item.span);\n         record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        self.encode_ident_span(def_id, impl_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1058,6 +1055,8 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n+        self.encode_ident_span(def_id, item.ident);\n+\n         record!(self.per_def.kind[def_id] <- match item.kind {\n             hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n@@ -1284,6 +1283,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- macro_def.span);\n         record!(self.per_def.attributes[def_id] <- macro_def.attrs);\n+        self.encode_ident_span(def_id, macro_def.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n@@ -1528,6 +1528,7 @@ impl EncodeContext<'tcx> {\n             ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n         record!(self.per_def.span[def_id] <- nitem.span);\n         record!(self.per_def.attributes[def_id] <- nitem.attrs);\n+        self.encode_ident_span(def_id, nitem.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1622,6 +1623,10 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n+    fn encode_ident_span(&mut self, def_id: DefId, ident: Ident) {\n+        record!(self.per_def.ident_span[def_id] <- ident.span);\n+    }\n+\n     /// In some cases, along with the item itself, we also\n     /// encode some sub-items. Usually we want some info from the item\n     /// so it's easier to do that here then to wait until we would encounter"}, {"sha": "3a4214e916acb2c0156997afb777382848bd6680", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -256,6 +256,7 @@ define_per_def_tables! {\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n     visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n     span: Table<DefIndex, Lazy<Span>>,\n+    ident_span: Table<DefIndex, Lazy<Span>>,\n     attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n     children: Table<DefIndex, Lazy<[DefIndex]>>,\n     stability: Table<DefIndex, Lazy<attr::Stability>>,"}, {"sha": "548c637efb260435f07855f64f33735f9c3e32f3", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -337,14 +337,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     ) -> ConstPropagator<'mir, 'tcx> {\n         let def_id = source.def_id();\n         let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n-        let mut param_env = tcx.param_env(def_id);\n-\n-        // If we're evaluating inside a monomorphic function, then use `Reveal::All` because\n-        // we want to see the same instances that codegen will see. This allows us to `resolve()`\n-        // specializations.\n-        if !substs.needs_subst() {\n-            param_env = param_env.with_reveal_all();\n-        }\n+        let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n         let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());"}, {"sha": "16c32e138fdf04101ac2565e16e81fb2396d4300", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -3,8 +3,8 @@\n use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::mir::visit::*;\n use rustc::mir::*;\n-use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::subst::{Subst, SubstsRef};\n+use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_attr as attr;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n@@ -66,14 +66,7 @@ impl Inliner<'tcx> {\n \n         let mut callsites = VecDeque::new();\n \n-        let mut param_env = self.tcx.param_env(self.source.def_id());\n-\n-        let substs = &InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-\n-        // For monomorphic functions, we can use `Reveal::All` to resolve specialized instances.\n-        if !substs.needs_subst() {\n-            param_env = param_env.with_reveal_all();\n-        }\n+        let param_env = self.tcx.param_env(self.source.def_id()).with_reveal_all();\n \n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();"}, {"sha": "a7ec4f501ae7672afc183eabd4af0fd6139f7c0a", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -139,7 +139,8 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n \n             let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n-                let gen_sig = match ty.kind {\n+                let gen_ty = tcx.body_tables(body_id).node_type(id);\n+                let gen_sig = match gen_ty.kind {\n                     ty::Generator(_, gen_substs, ..) => gen_substs.as_generator().sig(),\n                     _ => span_bug!(tcx.hir().span(id), \"generator w/o generator type: {:?}\", ty),\n                 };"}, {"sha": "5408c85a4d00677592405ac470641078f131e034", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -904,7 +904,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::AssocFn, def_id) => {\n-                if cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                if cstore\n+                    .associated_item_cloned_untracked(def_id, self.r.session)\n+                    .method_has_self_argument\n+                {\n                     self.r.has_self.insert(def_id);\n                 }\n             }"}, {"sha": "0578c00fefb17e3f8e9100fc963e7cc390a74182", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::{InferCtxt, ShallowResolver};\n+use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc::ty::error::ExpectedFound;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::ProcessResult;\n@@ -73,7 +73,10 @@ pub struct FulfillmentContext<'tcx> {\n #[derive(Clone, Debug)]\n pub struct PendingPredicateObligation<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n-    pub stalled_on: Vec<ty::InferTy>,\n+    // FIXME(eddyb) look into whether this could be a `SmallVec`.\n+    // Judging by the comment in `process_obligation`, the 1-element case\n+    // is common so this could be a `SmallVec<[TyOrConstInferVar<'tcx>; 1]>`.\n+    pub stalled_on: Vec<TyOrConstInferVar<'tcx>>,\n }\n \n // `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -266,8 +269,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             // Match arms are in order of frequency, which matters because this\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n-                let infer = pending_obligation.stalled_on[0];\n-                ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(infer)\n+                let infer_var = pending_obligation.stalled_on[0];\n+                self.selcx.infcx().ty_or_const_infer_var_changed(infer_var)\n             }\n             0 => {\n                 // In this case we haven't changed, but wish to make a change.\n@@ -277,8 +280,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 // This `for` loop was once a call to `all()`, but this lower-level\n                 // form was a perf win. See #64545 for details.\n                 (|| {\n-                    for &infer in &pending_obligation.stalled_on {\n-                        if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(infer) {\n+                    for &infer_var in &pending_obligation.stalled_on {\n+                        if self.selcx.infcx().ty_or_const_infer_var_changed(infer_var) {\n                             return true;\n                         }\n                     }\n@@ -309,13 +312,6 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n-        fn infer_ty(ty: Ty<'tcx>) -> ty::InferTy {\n-            match ty.kind {\n-                ty::Infer(infer) => infer,\n-                _ => panic!(),\n-            }\n-        }\n-\n         match obligation.predicate {\n             ty::Predicate::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(data.clone());\n@@ -467,7 +463,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     obligation.cause.span,\n                 ) {\n                     None => {\n-                        pending_obligation.stalled_on = vec![infer_ty(ty)];\n+                        pending_obligation.stalled_on =\n+                            vec![TyOrConstInferVar::maybe_from_ty(ty).unwrap()];\n                         ProcessResult::Unchanged\n                     }\n                     Some(os) => ProcessResult::Changed(mk_pending(os)),\n@@ -483,8 +480,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     None => {\n                         // None means that both are unresolved.\n                         pending_obligation.stalled_on = vec![\n-                            infer_ty(subtype.skip_binder().a),\n-                            infer_ty(subtype.skip_binder().b),\n+                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().a).unwrap(),\n+                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().b).unwrap(),\n                         ];\n                         ProcessResult::Unchanged\n                     }\n@@ -534,20 +531,23 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n-/// Returns the set of type variables contained in a trait ref\n+/// Returns the set of type inference variables contained in a trait ref.\n fn trait_ref_type_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    t: ty::PolyTraitRef<'tcx>,\n-) -> Vec<ty::InferTy> {\n-    t.skip_binder() // ok b/c this check doesn't care about regions\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Vec<TyOrConstInferVar<'tcx>> {\n+    trait_ref\n+        .skip_binder() // ok b/c this check doesn't care about regions\n+        // FIXME(eddyb) walk over `GenericArg` to support const infer vars.\n         .input_types()\n-        .map(|t| selcx.infcx().resolve_vars_if_possible(&t))\n-        .filter(|t| t.has_infer_types())\n-        .flat_map(|t| t.walk())\n-        .filter_map(|t| match t.kind {\n-            ty::Infer(infer) => Some(infer),\n-            _ => None,\n-        })\n+        .map(|ty| selcx.infcx().resolve_vars_if_possible(&ty))\n+        // FIXME(eddyb) try using `maybe_walk` to skip *all* subtrees that\n+        // don't contain inference variables, not just the outermost level.\n+        // FIXME(eddyb) use `has_infer_types_or_const`.\n+        .filter(|ty| ty.has_infer_types())\n+        .flat_map(|ty| ty.walk())\n+        // FIXME(eddyb) use `TyOrConstInferVar::maybe_from_generic_arg`.\n+        .filter_map(TyOrConstInferVar::maybe_from_ty)\n         .collect()\n }\n "}, {"sha": "30741ed53b58b43dd47a91bab8645f63a6176de9", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -188,12 +188,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         Node::Field(field) => icx.to_ty(&field.ty),\n \n         Node::Expr(&Expr { kind: ExprKind::Closure(.., gen), .. }) => {\n-            if gen.is_some() {\n-                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n-            }\n-\n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-            tcx.mk_closure(def_id, substs)\n+            if let Some(movability) = gen {\n+                tcx.mk_generator(def_id, substs, movability)\n+            } else {\n+                tcx.mk_closure(def_id, substs)\n+            }\n         }\n \n         Node::AnonConst(_) => {\n@@ -235,38 +235,40 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     };\n \n                     if let Some(path) = path {\n-                        let arg_index = path\n+                        // We've encountered an `AnonConst` in some path, so we need to\n+                        // figure out which generic parameter it corresponds to and return\n+                        // the relevant type.\n+\n+                        let (arg_index, segment) = path\n                             .segments\n                             .iter()\n-                            .filter_map(|seg| seg.args.as_ref())\n-                            .map(|generic_args| generic_args.args)\n-                            .find_map(|args| {\n+                            .filter_map(|seg| seg.args.as_ref().map(|args| (args.args, seg)))\n+                            .find_map(|(args, seg)| {\n                                 args.iter()\n                                     .filter(|arg| arg.is_const())\n                                     .enumerate()\n                                     .filter(|(_, arg)| arg.id() == hir_id)\n-                                    .map(|(index, _)| index)\n+                                    .map(|(index, _)| (index, seg))\n                                     .next()\n                             })\n                             .unwrap_or_else(|| {\n                                 bug!(\"no arg matching AnonConst in path\");\n                             });\n \n-                        // We've encountered an `AnonConst` in some path, so we need to\n-                        // figure out which generic parameter it corresponds to and return\n-                        // the relevant type.\n-                        let generics = match path.res {\n-                            Res::Def(DefKind::Ctor(..), def_id)\n-                            | Res::Def(DefKind::AssocTy, def_id) => {\n+                        // Try to use the segment resolution if it is valid, otherwise we\n+                        // default to the path resolution.\n+                        let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n+                        let generics = match res {\n+                            Res::Def(DefKind::Ctor(..), def_id) => {\n                                 tcx.generics_of(tcx.parent(def_id).unwrap())\n                             }\n                             Res::Def(_, def_id) => tcx.generics_of(def_id),\n                             res => {\n                                 tcx.sess.delay_span_bug(\n                                     DUMMY_SP,\n                                     &format!(\n-                                        \"unexpected const parent path def, parent: {:?}, def: {:?}\",\n-                                        parent_node, res\n+                                        \"unexpected anon const res {:?} in path: {:?}\",\n+                                        res, path,\n                                     ),\n                                 );\n                                 return tcx.types.err;\n@@ -291,8 +293,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 tcx.sess.delay_span_bug(\n                                     DUMMY_SP,\n                                     &format!(\n-                                        \"missing generic parameter for `AnonConst`, parent {:?}\",\n-                                        parent_node\n+                                        \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n+                                        parent_node, res\n                                     ),\n                                 );\n                                 tcx.types.err"}, {"sha": "fd854c750184ea2907a99b0139a05ff7d3f1d24a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -62,6 +62,7 @@ This API is completely unstable and subject to change.\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(or_patterns)]\n #![feature(try_blocks)]\n #![feature(never_type)]\n #![feature(slice_partition_dedup)]"}, {"sha": "0e9f33b15e2cc1d68f09fcc3321f3df190139521", "filename": "src/test/mir-opt/const_prop/control-flow-simplification.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,64 @@\n+// compile-flags: -Zmir-opt-level=1\n+\n+trait NeedsDrop:Sized{\n+    const NEEDS:bool=std::mem::needs_drop::<Self>();\n+}\n+\n+impl<This> NeedsDrop for This{}\n+\n+fn hello<T>(){\n+    if <bool>::NEEDS {\n+        panic!()\n+    }\n+}\n+\n+pub fn main() {\n+    hello::<()>();\n+    hello::<Vec<()>>();\n+}\n+\n+// END RUST SOURCE\n+// START rustc.hello.ConstProp.before.mir\n+// let mut _0: ();\n+// let mut _1: bool;\n+// let mut _2: !;\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const <bool as NeedsDrop>::NEEDS;\n+//   switchInt(_1) -> [false: bb1, otherwise: bb2];\n+// }\n+// bb1: {\n+//   _0 = ();\n+//   StorageDead(_1);\n+//   return;\n+// }\n+// bb2: {\n+//   StorageLive(_2);\n+//   const std::rt::begin_panic::<&str>(const \"explicit panic\");\n+// }\n+// END rustc.hello.ConstProp.before.mir\n+// START rustc.hello.ConstProp.after.mir\n+// let mut _0: ();\n+// let mut _1: bool;\n+// let mut _2: !;\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const false;\n+//   switchInt(const false) -> [false: bb1, otherwise: bb2];\n+// }\n+// bb1: {\n+//   _0 = ();\n+//   StorageDead(_1);\n+//   return;\n+// }\n+// bb2: {\n+//   StorageLive(_2);\n+//   const std::rt::begin_panic::<&str>(const \"explicit panic\");\n+// }\n+// END rustc.hello.ConstProp.after.mir\n+// START rustc.hello.PreCodegen.before.mir\n+// let mut _0: ();\n+// bb0: {\n+//   return;\n+// }\n+// END rustc.hello.PreCodegen.before.mir"}, {"sha": "46a132da309bba541da8a8d8056311de7e0128b0", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -18,22 +18,6 @@ LL | |             break 0u8;\n LL | |         };\n    | |_________- enclosing `async` block\n \n-error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:13:43\n-   |\n-LL | fn return_targets_async_block_not_fn() -> u8 {\n-   |    ---------------------------------      ^^ expected `u8`, found `()`\n-   |    |\n-   |    implicitly returns `()` as its body has no tail or `return` expression\n-\n-error[E0271]: type mismatch resolving `<impl std::future::Future as std::future::Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:18:39\n-   |\n-LL |     let _: &dyn Future<Output = ()> = &block;\n-   |                                       ^^^^^^ expected `()`, found `u8`\n-   |\n-   = note: required for the cast to the object type `dyn std::future::Future<Output = ()>`\n-\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:22:58\n    |\n@@ -55,6 +39,22 @@ LL |     let _: &dyn Future<Output = ()> = &block;\n    |\n    = note: required for the cast to the object type `dyn std::future::Future<Output = ()>`\n \n+error[E0308]: mismatched types\n+  --> $DIR/async-block-control-flow-static-semantics.rs:13:43\n+   |\n+LL | fn return_targets_async_block_not_fn() -> u8 {\n+   |    ---------------------------------      ^^ expected `u8`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+\n+error[E0271]: type mismatch resolving `<impl std::future::Future as std::future::Future>::Output == ()`\n+  --> $DIR/async-block-control-flow-static-semantics.rs:18:39\n+   |\n+LL |     let _: &dyn Future<Output = ()> = &block;\n+   |                                       ^^^^^^ expected `()`, found `u8`\n+   |\n+   = note: required for the cast to the object type `dyn std::future::Future<Output = ()>`\n+\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:48:44\n    |"}, {"sha": "cf10ebfeca9399cc7db1dc9b95362339f9f2849f", "filename": "src/test/ui/async-await/async-error-span.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -5,6 +5,7 @@\n use std::future::Future;\n \n fn get_future() -> impl Future<Output = ()> {\n+//~^ ERROR the trait bound `(): std::future::Future` is not satisfied\n     panic!()\n }\n "}, {"sha": "4054e739c483d58e0dce7cedd73aa7e913271fa7", "filename": "src/test/ui/async-await/async-error-span.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,15 +1,27 @@\n+error[E0277]: the trait bound `(): std::future::Future` is not satisfied\n+  --> $DIR/async-error-span.rs:7:20\n+   |\n+LL | fn get_future() -> impl Future<Output = ()> {\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `()`\n+LL |\n+LL |     panic!()\n+   |     -------- this returned value is of type `!`\n+   |\n+   = note: the return type of a function must have a statically known size\n+\n error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/async-error-span.rs:12:9\n+  --> $DIR/async-error-span.rs:13:9\n    |\n LL |     let a;\n    |         ^ cannot infer type\n    |\n note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/async-error-span.rs:13:5\n+  --> $DIR/async-error-span.rs:14:5\n    |\n LL |     get_future().await;\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0698`.\n+Some errors have detailed explanations: E0277, E0698.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "cebff3be6b059299f47d7548fa38b0d56fb1c771", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -62,6 +62,7 @@ fn foo10() -> Result<(), ()> {\n fn foo11() -> Result<(), ()> {\n     let _ = await bar()?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n     //~^ ERROR incorrect use of `await`\n+    //~| ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n     Ok(())\n }\n fn foo12() -> Result<(), ()> {"}, {"sha": "61f2570b2ff934a42fbd2982988ce545ebada08b", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.stderr", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -71,63 +71,63 @@ LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:68:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:69:14\n    |\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:73:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:74:24\n    |\n LL |     let _ = bar().await();\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:78:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:79:24\n    |\n LL |     let _ = bar().await()?;\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:106:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:107:13\n    |\n LL |     let _ = await!(bar());\n    |             ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:110:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:111:13\n    |\n LL |     let _ = await!(bar())?;\n    |             ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:115:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:116:17\n    |\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:123:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:124:17\n    |\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: expected expression, found `=>`\n-  --> $DIR/incorrect-syntax-suggestions.rs:131:25\n+  --> $DIR/incorrect-syntax-suggestions.rs:132:25\n    |\n LL |     match await { await => () }\n    |                   ----- ^^ expected expression\n    |                   |\n    |                   while parsing this incorrect await expression\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:131:11\n+  --> $DIR/incorrect-syntax-suggestions.rs:132:11\n    |\n LL |     match await { await => () }\n    |           ^^^^^^^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ await => () }.await`\n \n error: expected one of `.`, `?`, `{`, or an operator, found `}`\n-  --> $DIR/incorrect-syntax-suggestions.rs:134:1\n+  --> $DIR/incorrect-syntax-suggestions.rs:135:1\n    |\n LL |     match await { await => () }\n    |     -----                      - expected one of `.`, `?`, `{`, or an operator\n@@ -162,71 +162,71 @@ LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:68:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:69:14\n    |\n LL | fn foo12() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:73:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:74:13\n    |\n LL | fn foo13() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await();\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:78:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:79:13\n    |\n LL | fn foo14() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await()?;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:83:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:84:13\n    |\n LL | fn foo15() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:87:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:88:13\n    |\n LL | fn foo16() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await?;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:92:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:93:17\n    |\n LL |     fn foo() -> Result<(), ()> {\n    |        --- this is not `async`\n LL |         let _ = bar().await?;\n    |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:99:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:100:17\n    |\n LL |     let foo = || {\n    |               -- this is not `async`\n LL |         let _ = bar().await?;\n    |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:115:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:116:17\n    |\n LL |     fn foo() -> Result<(), ()> {\n    |        --- this is not `async`\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:123:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:124:17\n    |\n LL |     let foo = || {\n    |               -- this is not `async`\n@@ -242,7 +242,16 @@ LL |     let _ = await bar()?;\n    = help: the trait `std::ops::Try` is not implemented for `impl std::future::Future`\n    = note: required by `std::ops::Try::into_result`\n \n-error: aborting due to 35 previous errors\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/incorrect-syntax-suggestions.rs:63:19\n+   |\n+LL |     let _ = await bar()?;\n+   |                   ^^^^^^ the `?` operator cannot be applied to type `impl std::future::Future`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `impl std::future::Future`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error: aborting due to 36 previous errors\n \n Some errors have detailed explanations: E0277, E0728.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "bd96a3b709baea3a6a44959bcd6d55b940011087", "filename": "src/test/ui/async-await/issue-67651.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissue-67651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissue-67651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67651.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,20 @@\n+// edition:2018\n+\n+trait From {\n+    fn from();\n+}\n+\n+impl From for () {\n+    fn from() {}\n+}\n+\n+impl From for () {\n+//~^ ERROR conflicting implementations of trait\n+    fn from() {}\n+}\n+\n+fn bar() -> impl core::future::Future<Output = ()> {\n+    async move { From::from() }\n+}\n+\n+fn main() {}"}, {"sha": "99857c215eb8f483024918ff5c9bdac8ff599d3b", "filename": "src/test/ui/async-await/issue-67651.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissue-67651.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissue-67651.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67651.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `From` for type `()`:\n+  --> $DIR/issue-67651.rs:11:1\n+   |\n+LL | impl From for () {\n+   | ---------------- first implementation here\n+...\n+LL | impl From for () {\n+   | ^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "6edb9e63d480a6ebc45f38b122b87885793e659b", "filename": "src/test/ui/async-await/issues/issue-63388-2.nll.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.nll.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,13 +0,0 @@\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-63388-2.rs:12:10\n-   |\n-LL |         foo: &dyn Foo, bar: &'a dyn Foo\n-   |              --------       -----------\n-LL |     ) -> &dyn Foo\n-   |          ^ help: consider using the named lifetime: `&'a`\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `foo` or `bar`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0106`."}, {"sha": "458bc9faeaf272bfb2d879edd699b31bcf054718", "filename": "src/test/ui/async-await/issues/issue-63388-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -8,7 +8,7 @@ trait Foo {}\n \n impl Xyz {\n     async fn do_sth<'a>(\n-        foo: &dyn Foo, bar: &'a dyn Foo //~ ERROR cannot infer\n+        foo: &dyn Foo, bar: &'a dyn Foo\n     ) -> &dyn Foo //~ ERROR missing lifetime specifier\n     {\n         foo"}, {"sha": "6edb9e63d480a6ebc45f38b122b87885793e659b", "filename": "src/test/ui/async-await/issues/issue-63388-2.stderr", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-2.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -8,21 +8,6 @@ LL |     ) -> &dyn Foo\n    |\n    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `foo` or `bar`\n \n-error: cannot infer an appropriate lifetime\n-  --> $DIR/issue-63388-2.rs:11:9\n-   |\n-LL |         foo: &dyn Foo, bar: &'a dyn Foo\n-   |         ^^^ ...but this borrow...\n-...\n-LL |         foo\n-   |         --- this return type evaluates to the `'static` lifetime...\n-   |\n-note: ...can't outlive the lifetime `'_` as defined on the method body at 11:14\n-  --> $DIR/issue-63388-2.rs:11:14\n-   |\n-LL |         foo: &dyn Foo, bar: &'a dyn Foo\n-   |              ^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0106`."}, {"sha": "2f80435046bdf5d2434000338251e27ed47d52ca", "filename": "src/test/ui/async-await/issues/issue-65159.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -5,6 +5,7 @@\n async fn copy() -> Result<()> //~ ERROR wrong number of type arguments\n {\n     Ok(())\n+    //~^ type annotations needed\n }\n \n fn main() { }"}, {"sha": "04cfa5249982e144659df44ee10a52fcfb025de8", "filename": "src/test/ui/async-await/issues/issue-65159.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -4,6 +4,13 @@ error[E0107]: wrong number of type arguments: expected 2, found 1\n LL | async fn copy() -> Result<()>\n    |                    ^^^^^^^^^^ expected 2 type arguments\n \n-error: aborting due to previous error\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-65159.rs:7:5\n+   |\n+LL |     Ok(())\n+   |     ^^ cannot infer type for type parameter `E` declared on the enum `Result`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0107`.\n+Some errors have detailed explanations: E0107, E0282.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "05960c0c7f6364f472a245023e9cead0afddc0e2", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-no-fg.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -9,6 +9,9 @@ impl<T> Trait<'_, '_> for T { }\n async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n     //~^ ERROR ambiguous lifetime bound\n     //~| ERROR ambiguous lifetime bound\n+    //~| ERROR ambiguous lifetime bound\n+    //~| ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+    //~| ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n     (a, b)\n }\n "}, {"sha": "c69595a3f4d01dfae6601b378d0a525a0f09e9e6", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-no-fg.stderr", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -14,5 +14,42 @@ LL | async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'\n    |\n    = help: add #![feature(member_constraints)] to the crate attributes to enable\n \n-error: aborting due to 2 previous errors\n+error: ambiguous lifetime bound in `impl Trait`\n+  --> $DIR/ret-impl-trait-no-fg.rs:9:64\n+   |\n+LL | async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                                                                ^^^^^^^^^^^^^^^^^^ the elided lifetimes here do not outlive one another\n+   |\n+   = help: add #![feature(member_constraints)] to the crate attributes to enable\n+\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ret-impl-trait-no-fg.rs:9:1\n+   |\n+LL | / async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^\n+   |\n+   = note: hidden type `(&u8, &u8)` captures lifetime '_#4r\n+\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ret-impl-trait-no-fg.rs:9:1\n+   |\n+LL | / async fn async_ret_impl_trait<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^\n+   |\n+   = note: hidden type `(&u8, &u8)` captures lifetime '_#5r\n+\n+error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "a192ddea9c6abb3145ee60defaf7bdfed65a1956", "filename": "src/test/ui/const-generics/issues/issue70273-assoc-fn.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue70273-assoc-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue70273-assoc-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue70273-assoc-fn.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+trait T<const A: usize> {\n+    fn f();\n+}\n+struct S;\n+\n+impl T<0usize> for S {\n+    fn f() {}\n+}\n+\n+fn main() {\n+    let _err = <S as T<0usize>>::f();\n+}"}, {"sha": "64007ade0f2edff77cf228229013d55e78a215d8", "filename": "src/test/ui/const-generics/issues/issue70273-assoc-fn.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue70273-assoc-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue70273-assoc-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue70273-assoc-fn.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue70273-assoc-fn.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "776084b77a5770c8193cb24680604fb93cdf1185", "filename": "src/test/ui/const-generics/type_of_anon_const.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fconst-generics%2Ftype_of_anon_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fconst-generics%2Ftype_of_anon_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftype_of_anon_const.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,21 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+trait T<const A: usize> {\n+    fn l<const N: bool>() -> usize;\n+    fn r<const N: bool>() -> bool;\n+}\n+\n+struct S;\n+\n+impl<const N: usize> T<N> for S {\n+    fn l<const M: bool>() -> usize { N }\n+    fn r<const M: bool>() -> bool { M }\n+}\n+\n+fn main() {\n+   assert_eq!(<S as T<123>>::l::<true>(), 123);\n+   assert!(<S as T<123>>::r::<true>());\n+}"}, {"sha": "495d34ce09b8172f8b39d2d78e8d084ef331e594", "filename": "src/test/ui/const-generics/type_of_anon_const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fconst-generics%2Ftype_of_anon_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fconst-generics%2Ftype_of_anon_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftype_of_anon_const.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/type_of_anon_const.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "1a647692018e58c78c6caf046c96d68f73e31227", "filename": "src/test/ui/copy-a-resource.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #[derive(Debug)]\n struct Foo {\n   i: isize,"}, {"sha": "71d2eead3554cd9fee40761adf0b716abb7a04b3", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,11 +1,19 @@\n error[E0599]: no method named `clone` found for struct `Foo` in the current scope\n-  --> $DIR/copy-a-resource.rs:18:16\n+  --> $DIR/copy-a-resource.rs:23:16\n    |\n LL | struct Foo {\n    | ---------- method `clone` not found for this\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Foo>` here\n+   |        the method is available for `std::rc::Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "fa5afd24192611d8f552195f0773b801c1265c39", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n trait Foo {\n     type X;\n     fn method(&self) {}"}, {"sha": "f15aba97ded8110c7f5380a7d352edcd62814885", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,5 @@\n error[E0599]: no method named `clone` found for struct `Bar<NotClone>` in the current scope\n-  --> $DIR/derive-assoc-type-not-impl.rs:18:30\n+  --> $DIR/derive-assoc-type-not-impl.rs:23:30\n    |\n LL | struct Bar<T: Foo> {\n    | ------------------\n@@ -12,6 +12,14 @@ LL | struct NotClone;\n ...\n LL |     Bar::<NotClone> { x: 1 }.clone();\n    |                              ^^^^^ method not found in `Bar<NotClone>`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Bar<NotClone>>` here\n+   |        the method is available for `std::rc::Rc<Bar<NotClone>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `NotClone: std::clone::Clone`"}, {"sha": "d5ed9fb9a285efd885f5f40527eaf4ed7a1a6b48", "filename": "src/test/ui/editions/edition-keywords-2018-2015-parsing.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,9 +1,17 @@\n // edition:2018\n // aux-build:edition-kw-macro-2015.rs\n \n+#![feature(async_closure)]\n+\n+fn main() {}\n+\n #[macro_use]\n extern crate edition_kw_macro_2015;\n \n+mod module {\n+    pub fn r#async() {}\n+}\n+\n pub fn check_async() {\n     let mut async = 1; //~ ERROR expected identifier, found keyword `async`\n     let mut r#async = 1; // OK\n@@ -17,4 +25,6 @@ pub fn check_async() {\n     if passes_ident!(r#async) == 1 {} // OK\n     module::async(); //~ ERROR expected identifier, found keyword `async`\n     module::r#async(); // OK\n+\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n }"}, {"sha": "28663563c6ccdf1079aea69293ca1398d0613f09", "filename": "src/test/ui/editions/edition-keywords-2018-2015-parsing.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,5 @@\n error: expected identifier, found keyword `async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:8:13\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:16:13\n    |\n LL |     let mut async = 1;\n    |             ^^^^^ expected identifier, found keyword\n@@ -10,7 +10,7 @@ LL |     let mut r#async = 1;\n    |             ^^^^^^^\n \n error: expected identifier, found keyword `async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:18:13\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:26:13\n    |\n LL |     module::async();\n    |             ^^^^^ expected identifier, found keyword\n@@ -21,13 +21,13 @@ LL |     module::r#async();\n    |             ^^^^^^^\n \n error: no rules expected the token `r#async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:12:31\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:20:31\n    |\n LL |     r#async = consumes_async!(r#async);\n    |                               ^^^^^^^ no rules expected this token in macro call\n \n error: no rules expected the token `async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:13:35\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:21:35\n    |\n LL |     r#async = consumes_async_raw!(async);\n    |                                   ^^^^^ no rules expected this token in macro call\n@@ -38,10 +38,19 @@ error: macro expansion ends with an incomplete expression: expected one of `move\n LL |     ($i: ident) => ($i)\n    |                       ^ expected one of `move`, `|`, or `||`\n    | \n-  ::: $DIR/edition-keywords-2018-2015-parsing.rs:16:8\n+  ::: $DIR/edition-keywords-2018-2015-parsing.rs:24:8\n    |\n LL |     if passes_ident!(async) == 1 {}\n    |        -------------------- in this macro invocation\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:29:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "044ab249f2c2660f61ae510d4c9e798fd0af578e", "filename": "src/test/ui/editions/edition-keywords-2018-2018-parsing.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,9 +1,17 @@\n // edition:2018\n // aux-build:edition-kw-macro-2018.rs\n \n+#![feature(async_closure)]\n+\n+fn main() {}\n+\n #[macro_use]\n extern crate edition_kw_macro_2018;\n \n+mod module {\n+    pub fn r#async() {}\n+}\n+\n pub fn check_async() {\n     let mut async = 1; //~ ERROR expected identifier, found keyword `async`\n     let mut r#async = 1; // OK\n@@ -17,4 +25,6 @@ pub fn check_async() {\n     if passes_ident!(r#async) == 1 {} // OK\n     module::async(); //~ ERROR expected identifier, found keyword `async`\n     module::r#async(); // OK\n+\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n }"}, {"sha": "cda7e65e437e85e1f31803096da47d7d1b4fd710", "filename": "src/test/ui/editions/edition-keywords-2018-2018-parsing.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,5 @@\n error: expected identifier, found keyword `async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:8:13\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:16:13\n    |\n LL |     let mut async = 1;\n    |             ^^^^^ expected identifier, found keyword\n@@ -10,7 +10,7 @@ LL |     let mut r#async = 1;\n    |             ^^^^^^^\n \n error: expected identifier, found keyword `async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:18:13\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:26:13\n    |\n LL |     module::async();\n    |             ^^^^^ expected identifier, found keyword\n@@ -21,13 +21,13 @@ LL |     module::r#async();\n    |             ^^^^^^^\n \n error: no rules expected the token `r#async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:12:31\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:20:31\n    |\n LL |     r#async = consumes_async!(r#async);\n    |                               ^^^^^^^ no rules expected this token in macro call\n \n error: no rules expected the token `async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:13:35\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:21:35\n    |\n LL |     r#async = consumes_async_raw!(async);\n    |                                   ^^^^^ no rules expected this token in macro call\n@@ -38,10 +38,19 @@ error: macro expansion ends with an incomplete expression: expected one of `move\n LL |     ($i: ident) => ($i)\n    |                       ^ expected one of `move`, `|`, or `||`\n    | \n-  ::: $DIR/edition-keywords-2018-2018-parsing.rs:16:8\n+  ::: $DIR/edition-keywords-2018-2018-parsing.rs:24:8\n    |\n LL |     if passes_ident!(async) == 1 {}\n    |        -------------------- in this macro invocation\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:29:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "7f1d064cf3f5037e54189471f8997f26a2f4af3d", "filename": "src/test/ui/error-codes/E0004-2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n fn main() {\n     let x = Some(1);\n "}, {"sha": "e47a4fa755cacd235cb15372ce977b671359a37b", "filename": "src/test/ui/error-codes/E0004-2.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,8 +1,16 @@\n error[E0004]: non-exhaustive patterns: `None` and `Some(_)` not covered\n-  --> $DIR/E0004-2.rs:4:11\n+  --> $DIR/E0004-2.rs:9:11\n    |\n LL |     match x { }\n    |           ^ patterns `None` and `Some(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n+...\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "75faad80579c67b05e71156b1eff27a55608cb84", "filename": "src/test/ui/error-codes/E0005.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0005.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0005.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n fn main() {\n     let x = Some(1);\n     let Some(y) = x; //~ ERROR E0005"}, {"sha": "192b99440319117ad4afc4adae190144a2fc7bfb", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,8 +1,13 @@\n error[E0005]: refutable pattern in local binding: `None` not covered\n-  --> $DIR/E0005.rs:3:9\n+  --> $DIR/E0005.rs:8:9\n    |\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "b26ede9c8e2190451f0aa9bad784951295d2c675", "filename": "src/test/ui/error-codes/E0297.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0297.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0297.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n fn main() {\n     let xs : Vec<Option<i32>> = vec![Some(1), None];\n "}, {"sha": "4a75e9d1771f3b6ec8ec1e92f10849160580f120", "filename": "src/test/ui/error-codes/E0297.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,8 +1,13 @@\n error[E0005]: refutable pattern in `for` loop binding: `None` not covered\n-  --> $DIR/E0297.rs:4:9\n+  --> $DIR/E0297.rs:9:9\n    |\n LL |     for Some(x) in xs {}\n    |         ^^^^^^^ pattern `None` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n \n error: aborting due to previous error\n "}, {"sha": "d2e52299c0d869981f19104c65ee357d2e0d389d", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![feature(never_type)]\n \n fn foo() -> Result<u32, !> {"}, {"sha": "c2dd90b91e700eff7ed17aa112da6ed630dda824", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,8 +1,13 @@\n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/feature-gate-exhaustive-patterns.rs:8:9\n+  --> $DIR/feature-gate-exhaustive-patterns.rs:13:9\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "616421112db672a99459f4f3d15be47b3107ccf9", "filename": "src/test/ui/generic-associated-types/iterable.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![allow(incomplete_features)]\n #![feature(generic_associated_types)]\n "}, {"sha": "e18c6cec64e71d4ac6d647efe46e0f4990a13e63", "filename": "src/test/ui/generic-associated-types/iterable.stderr", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,31 +1,41 @@\n error[E0271]: type mismatch resolving `for<'a> <<std::vec::Vec<T> as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <std::vec::Vec<T> as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:15:5\n+  --> $DIR/iterable.rs:20:5\n    |\n LL | impl<T> Iterable for Vec<T> {\n    | --------------------------- in this `impl` item\n LL |     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found associated type\n+   | \n+  ::: $SRC_DIR/libcore/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     type Item;\n+   |          ---- associated type defined here\n    |\n    = note:    expected reference `&T`\n            found associated type `<std::vec::Vec<T> as Iterable>::Item<'_>`\n    = note: consider constraining the associated type `<std::vec::Vec<T> as Iterable>::Item<'_>` to `&_`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error[E0271]: type mismatch resolving `for<'a> <<[T] as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <[T] as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:27:5\n+  --> $DIR/iterable.rs:32:5\n    |\n LL | impl<T> Iterable for [T] {\n    | ------------------------ in this `impl` item\n LL |     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found associated type\n+   | \n+  ::: $SRC_DIR/libcore/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     type Item;\n+   |          ---- associated type defined here\n    |\n    = note:    expected reference `&T`\n            found associated type `<[T] as Iterable>::Item<'_>`\n    = note: consider constraining the associated type `<[T] as Iterable>::Item<'_>` to `&_`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error[E0271]: type mismatch resolving `for<'a> <<std::vec::Vec<T> as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <std::vec::Vec<T> as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:19:30\n+  --> $DIR/iterable.rs:24:30\n    |\n LL | trait Iterable {\n    | -------------- required by `Iterable`\n@@ -39,7 +49,7 @@ LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error[E0271]: type mismatch resolving `for<'a> <<[T] as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <[T] as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:31:30\n+  --> $DIR/iterable.rs:36:30\n    |\n LL | trait Iterable {\n    | -------------- required by `Iterable`"}, {"sha": "b5135b53e18905852274a53c42caccbab77c6173", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -83,6 +83,16 @@ error[E0599]: no method named `method` found for struct `std::rc::Rc<&mut std::b\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&1i32)).method();\n    |                                            ^^^^^^ method not found in `std::rc::Rc<&mut std::boxed::Box<&i32>>`\n+   | \n+  ::: $DIR/auxiliary/no_method_suggested_traits.rs:8:12\n+   |\n+LL |         fn method(&self) {}\n+   |            ------\n+   |            |\n+   |            the method is available for `std::boxed::Box<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::pin::Pin<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::sync::Arc<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::rc::Rc<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\n help: the following trait is implemented but not in scope; perhaps add a `use` for it:"}, {"sha": "f00c2304733cafeeb4b61c444fe90cfff0a92ed6", "filename": "src/test/ui/issues/issue-2823.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fissues%2Fissue-2823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fissues%2Fissue-2823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n struct C {\n     x: isize,\n }"}, {"sha": "6e11dd4028836b4b6df202304f78e70aadb29353", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,11 +1,19 @@\n error[E0599]: no method named `clone` found for struct `C` in the current scope\n-  --> $DIR/issue-2823.rs:13:16\n+  --> $DIR/issue-2823.rs:18:16\n    |\n LL | struct C {\n    | -------- method `clone` not found for this\n ...\n LL |     let _d = c.clone();\n    |                ^^^^^ method not found in `C`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<C>` here\n+   |        the method is available for `std::rc::Rc<C>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "a8e72e9459e339084e07513b755bc3782959b8e7", "filename": "src/test/ui/issues/issue-69725.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n // aux-build:issue-69725.rs\n \n extern crate issue_69725;"}, {"sha": "439fae9511167d08806b66d620e3cbd486697069", "filename": "src/test/ui/issues/issue-69725.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,5 @@\n error[E0599]: no method named `clone` found for struct `issue_69725::Struct<A>` in the current scope\n-  --> $DIR/issue-69725.rs:7:32\n+  --> $DIR/issue-69725.rs:12:32\n    |\n LL |     let _ = Struct::<A>::new().clone();\n    |                                ^^^^^ method not found in `issue_69725::Struct<A>`\n@@ -8,6 +8,14 @@ LL |     let _ = Struct::<A>::new().clone();\n    |\n LL | pub struct Struct<A>(A);\n    | ------------------------ doesn't satisfy `issue_69725::Struct<A>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<issue_69725::Struct<A>>` here\n+   |        the method is available for `std::rc::Rc<issue_69725::Struct<A>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `A: std::clone::Clone`"}, {"sha": "18df3f6ee94c1e173e46509f9d35d0ebf0971762", "filename": "src/test/ui/macros/issue-61033-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,9 +1,10 @@\n // Regression test for issue #61033.\n \n macro_rules! test1 {\n-    ($x:ident, $($tt:tt)*) => { $($tt)+ } //~ERROR this must repeat at least once\n+    ($x:ident, $($tt:tt)*) => { $($tt)+ } //~ ERROR this must repeat at least once\n }\n \n fn main() {\n     test1!(x,);\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n }"}, {"sha": "18205c3436b0b4f8ca9571dd03c176934b1e3d56", "filename": "src/test/ui/macros/issue-61033-1.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -4,5 +4,14 @@ error: this must repeat at least once\n LL |     ($x:ident, $($tt:tt)*) => { $($tt)+ }\n    |                                  ^^^^^\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-61033-1.rs:9:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1760ba1584d0b2e495346e3176d35fc6bdc9d826", "filename": "src/test/ui/macros/issue-61033-2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -5,7 +5,9 @@ macro_rules! test2 {\n         $(* $id1:ident)*\n         $(+ $id2:ident)*\n     ) => {\n-        $( //~ERROR meta-variable `id1` repeats 2 times\n+        $(\n+        //~^ ERROR meta-variable `id1` repeats 2 times\n+        //~| ERROR meta-variable `id1` repeats 2 times\n             $id1 + $id2 // $id1 and $id2 may repeat different numbers of times\n         )*\n     }\n@@ -16,4 +18,8 @@ fn main() {\n         * a * b\n         + a + b + c\n     }\n+    test2! {\n+        * a * b\n+        + a + b + c + d\n+    }\n }"}, {"sha": "cdfe7934a0cac26af019674778b0c16718d1fcd4", "filename": "src/test/ui/macros/issue-61033-2.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -3,9 +3,22 @@ error: meta-variable `id1` repeats 2 times, but `id2` repeats 3 times\n    |\n LL |           $(\n    |  __________^\n+LL | |\n+LL | |\n LL | |             $id1 + $id2 // $id1 and $id2 may repeat different numbers of times\n LL | |         )*\n    | |_________^\n \n-error: aborting due to previous error\n+error: meta-variable `id1` repeats 2 times, but `id2` repeats 4 times\n+  --> $DIR/issue-61033-2.rs:8:10\n+   |\n+LL |           $(\n+   |  __________^\n+LL | |\n+LL | |\n+LL | |             $id1 + $id2 // $id1 and $id2 may repeat different numbers of times\n+LL | |         )*\n+   | |_________^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "3967481098cff05cf1e45789b9d40462b5007b4d", "filename": "src/test/ui/macros/local-ambiguity-multiple-parsing-options.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,8 @@\n+fn main() {}\n+\n+macro_rules! ambiguity {\n+    ($($i:ident)* $j:ident) => {};\n+}\n+\n+ambiguity!(error); //~ ERROR local ambiguity\n+ambiguity!(error); //~ ERROR local ambiguity"}, {"sha": "0ae56c422213cbfc7fbe1b5d12e520b4c9f82b1b", "filename": "src/test/ui/macros/local-ambiguity-multiple-parsing-options.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,14 @@\n+error: local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('j').\n+  --> $DIR/local-ambiguity-multiple-parsing-options.rs:7:12\n+   |\n+LL | ambiguity!(error);\n+   |            ^^^^^\n+\n+error: local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('j').\n+  --> $DIR/local-ambiguity-multiple-parsing-options.rs:8:12\n+   |\n+LL | ambiguity!(error);\n+   |            ^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "13e179578ad012d22f73348cc7d7b65692d960ab", "filename": "src/test/ui/macros/macro-context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -4,6 +4,8 @@ macro_rules! m {\n                             //~| ERROR macro expansion ignores token `typeof`\n                             //~| ERROR macro expansion ignores token `;`\n                             //~| ERROR macro expansion ignores token `;`\n+                            //~| ERROR cannot find type `i` in this scope\n+                            //~| ERROR cannot find value `i` in this scope\n }\n \n fn main() {"}, {"sha": "17c7389812475ac0a8eb48aff453d1adc6246cbd", "filename": "src/test/ui/macros/macro-context.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -42,5 +42,29 @@ LL |     m!();\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error[E0412]: cannot find type `i` in this scope\n+  --> $DIR/macro-context.rs:3:13\n+   |\n+LL |     () => ( i ; typeof );\n+   |             ^ help: a builtin type with a similar name exists: `i8`\n+...\n+LL |     let a: m!();\n+   |            ---- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0425]: cannot find value `i` in this scope\n+  --> $DIR/macro-context.rs:3:13\n+   |\n+LL |     () => ( i ; typeof );\n+   |             ^ help: a local variable with a similar name exists: `a`\n+...\n+LL |     let i = m!();\n+   |             ---- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 6 previous errors\n \n+Some errors have detailed explanations: E0412, E0425.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "b23e5c71c03f06e29245481dbfa775b0b3c57874", "filename": "src/test/ui/macros/macro-match-nonterminal.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,4 +1,11 @@\n-macro_rules! test { ($a, $b) => (()); } //~ ERROR missing fragment\n+macro_rules! test {\n+    ($a, $b) => {\n+        //~^ ERROR missing fragment\n+        //~| ERROR missing fragment\n+        //~| WARN this was previously accepted\n+        ()\n+    };\n+}\n \n fn main() {\n     test!()"}, {"sha": "674ce3434aac63fd9446e23a30c91f34fe2c3271", "filename": "src/test/ui/macros/macro-match-nonterminal.stderr", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,8 +1,18 @@\n error: missing fragment specifier\n-  --> $DIR/macro-match-nonterminal.rs:1:24\n+  --> $DIR/macro-match-nonterminal.rs:2:8\n    |\n-LL | macro_rules! test { ($a, $b) => (()); }\n-   |                        ^\n+LL |     ($a, $b) => {\n+   |        ^\n \n-error: aborting due to previous error\n+error: missing fragment specifier\n+  --> $DIR/macro-match-nonterminal.rs:2:10\n+   |\n+LL |     ($a, $b) => {\n+   |          ^^\n+   |\n+   = note: `#[deny(missing_fragment_specifier)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "5a8e2f50ce33d2fbca03f7f73da240fbe2c3e520", "filename": "src/test/ui/macros/trace_faulty_macros.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,6 +1,6 @@\n // compile-flags: -Z trace-macros\n \n-#![recursion_limit=\"4\"]\n+#![recursion_limit = \"4\"]\n \n macro_rules! my_faulty_macro {\n     () => {\n@@ -24,9 +24,7 @@ macro_rules! my_recursive_macro {\n }\n \n macro_rules! my_macro {\n-    () => {\n-\n-    };\n+    () => {};\n }\n \n fn main() {\n@@ -39,7 +37,7 @@ fn main() {\n }\n \n #[my_macro]\n-fn use_bang_macro_as_attr(){}\n+fn use_bang_macro_as_attr() {}\n \n-#[derive(Debug)]\n-fn use_derive_macro_as_attr(){}\n+#[derive(Debug)] //~ ERROR `derive` may only be applied to structs\n+fn use_derive_macro_as_attr() {}"}, {"sha": "aec9d1ab191af20ae77acd5b4e61b93fa486a245", "filename": "src/test/ui/macros/trace_faulty_macros.stderr", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -13,7 +13,7 @@ LL |     my_faulty_macro!();\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: trace_macro\n-  --> $DIR/trace_faulty_macros.rs:33:5\n+  --> $DIR/trace_faulty_macros.rs:31:5\n    |\n LL |     my_faulty_macro!();\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -35,7 +35,7 @@ LL |     my_recursive_macro!();\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: trace_macro\n-  --> $DIR/trace_faulty_macros.rs:34:5\n+  --> $DIR/trace_faulty_macros.rs:32:5\n    |\n LL |     my_recursive_macro!();\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n@@ -60,5 +60,22 @@ LL |     let a = pat_macro!();\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 3 previous errors\n+error: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/trace_faulty_macros.rs:42:1\n+   |\n+LL | #[derive(Debug)]\n+   | ^^^^^^^^^^^^^^^^\n+\n+note: trace_macro\n+  --> $DIR/trace_faulty_macros.rs:36:13\n+   |\n+LL |     let a = pat_macro!();\n+   |             ^^^^^^^^^^^^\n+   |\n+   = note: expanding `pat_macro! {  }`\n+   = note: to `pat_macro ! (A { a : a, b : 0, c : _, .. }) ;`\n+   = note: expanding `pat_macro! { A { a : a, b : 0, c : _, .. } }`\n+   = note: to `A { a: a, b: 0, c: _, .. }`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "186731f2e7233ef010157be1ca968ebae35bb78d", "filename": "src/test/ui/non-copyable-void.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-copyable-void.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n // ignore-wasm32-bare no libc to test ffi with\n \n #![feature(rustc_private)]"}, {"sha": "dd67a110d2218c11d79c5ebaddd3203dbc5af32e", "filename": "src/test/ui/non-copyable-void.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-copyable-void.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,8 +1,16 @@\n error[E0599]: no method named `clone` found for enum `libc::c_void` in the current scope\n-  --> $DIR/non-copyable-void.rs:11:23\n+  --> $DIR/non-copyable-void.rs:16:23\n    |\n LL |         let _z = (*y).clone();\n    |                       ^^^^^ method not found in `libc::c_void`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<libc::c_void>` here\n+   |        the method is available for `std::rc::Rc<libc::c_void>` here\n \n error: aborting due to previous error\n "}, {"sha": "731f4ab9c784a59c6881578c10fc0c47e63018c8", "filename": "src/test/ui/noncopyable-class.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n // Test that a class with a non-copyable field can't be\n // copied\n "}, {"sha": "472ce34870a0a71e710fd23802e6416732acd74e", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,11 +1,19 @@\n error[E0599]: no method named `clone` found for struct `Foo` in the current scope\n-  --> $DIR/noncopyable-class.rs:34:16\n+  --> $DIR/noncopyable-class.rs:39:16\n    |\n LL | struct Foo {\n    | ---------- method `clone` not found for this\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Foo>` here\n+   |        the method is available for `std::rc::Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "e38b7b65089372fbcdc9858503f164a9ab7d4b14", "filename": "src/test/ui/parser/issue-62894.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n // Regression test for #62894, shouldn't crash.\n // error-pattern: this file contains an unclosed delimiter\n // error-pattern: expected one of `(`, `[`, or `{`, found keyword `fn`"}, {"sha": "4a1d7e275bed86a90f440a80d8644c82b4bd900a", "filename": "src/test/ui/parser/issue-62894.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,5 @@\n error: this file contains an unclosed delimiter\n-  --> $DIR/issue-62894.rs:7:14\n+  --> $DIR/issue-62894.rs:12:14\n    |\n LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n    |        -           -                   - unclosed delimiter\n@@ -11,7 +11,7 @@ LL | fn main() {}\n    |              ^\n \n error: this file contains an unclosed delimiter\n-  --> $DIR/issue-62894.rs:7:14\n+  --> $DIR/issue-62894.rs:12:14\n    |\n LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n    |        -           -                   - unclosed delimiter\n@@ -23,7 +23,7 @@ LL | fn main() {}\n    |              ^\n \n error: this file contains an unclosed delimiter\n-  --> $DIR/issue-62894.rs:7:14\n+  --> $DIR/issue-62894.rs:12:14\n    |\n LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n    |        -           -                   - unclosed delimiter\n@@ -35,13 +35,18 @@ LL | fn main() {}\n    |              ^\n \n error: expected one of `(`, `[`, or `{`, found keyword `fn`\n-  --> $DIR/issue-62894.rs:7:1\n+  --> $DIR/issue-62894.rs:12:1\n    |\n LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n    |                                                   - expected one of `(`, `[`, or `{`\n LL | \n LL | fn main() {}\n    | ^^ unexpected token\n+   | \n+  ::: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+   |\n+LL |     ($left:expr, $right:expr) => ({\n+   |      ---------- while parsing argument for this `expr` macro fragment\n \n error: aborting due to 4 previous errors\n "}, {"sha": "80e2d7c6545ba277512e0c9c2ad7ee0a0c70be40", "filename": "src/test/ui/parser/macro/issue-33569.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -6,3 +6,5 @@ macro_rules! foo {\n }\n \n foo!();\n+\n+fn main() {}"}, {"sha": "3ffbea217e79ebf9de92687367079a543f79239b", "filename": "src/test/ui/parser/macro/macro-repeat.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,9 +1,12 @@\n macro_rules! mac {\n-    ( $($v:tt)* ) => (\n-        $v  //~ ERROR still repeating at this depth\n-    )\n+    ( $($v:tt)* ) => {\n+        $v\n+        //~^ ERROR still repeating at this depth\n+        //~| ERROR still repeating at this depth\n+    };\n }\n \n fn main() {\n     mac!(0);\n+    mac!(1);\n }"}, {"sha": "63554b197b91c19082cd28b8b9010a7e606b32cf", "filename": "src/test/ui/parser/macro/macro-repeat.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -4,5 +4,11 @@ error: variable 'v' is still repeating at this depth\n LL |         $v\n    |         ^^\n \n-error: aborting due to previous error\n+error: variable 'v' is still repeating at this depth\n+  --> $DIR/macro-repeat.rs:3:9\n+   |\n+LL |         $v\n+   |         ^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "ccbeb398af5baee5f87050f40c4dd01758b2c2c8", "filename": "src/test/ui/parser/nt-parsing-has-recovery.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! foo {\n+    ($e:expr) => {}\n+}\n+\n+foo!(1 + @); //~ ERROR expected expression, found `@`\n+foo!(1 + @); //~ ERROR expected expression, found `@`\n+\n+fn main() {\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "263c4ad53612ee98f7c90a3ff2055b6aec2a5eac", "filename": "src/test/ui/parser/nt-parsing-has-recovery.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -0,0 +1,29 @@\n+error: expected expression, found `@`\n+  --> $DIR/nt-parsing-has-recovery.rs:5:10\n+   |\n+LL |     ($e:expr) => {}\n+   |      ------- while parsing argument for this `expr` macro fragment\n+...\n+LL | foo!(1 + @);\n+   |          ^ expected expression\n+\n+error: expected expression, found `@`\n+  --> $DIR/nt-parsing-has-recovery.rs:6:10\n+   |\n+LL |     ($e:expr) => {}\n+   |      ------- while parsing argument for this `expr` macro fragment\n+...\n+LL | foo!(1 + @);\n+   |          ^ expected expression\n+\n+error[E0308]: mismatched types\n+  --> $DIR/nt-parsing-has-recovery.rs:9:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "728d4a64495b162ebe7f723063baa368434f6b52", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n use self::Direction::{North, East, South, West};\n \n #[derive(PartialEq, Eq)]"}, {"sha": "7bb6a700a3717d98b56d7575f7e48179094852bf", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,21 +1,29 @@\n error[E0004]: non-exhaustive patterns: `(true, false)` not covered\n-  --> $DIR/match-arm-statics-2.rs:17:11\n+  --> $DIR/match-arm-statics-2.rs:22:11\n    |\n LL |     match (true, false) {\n    |           ^^^^^^^^^^^^^ pattern `(true, false)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Some(Some(West))` not covered\n-  --> $DIR/match-arm-statics-2.rs:29:11\n+  --> $DIR/match-arm-statics-2.rs:34:11\n    |\n LL |     match Some(Some(North)) {\n    |           ^^^^^^^^^^^^^^^^^ pattern `Some(Some(West))` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ----\n+   |     |\n+   |     not covered\n+   |     not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n-  --> $DIR/match-arm-statics-2.rs:48:11\n+  --> $DIR/match-arm-statics-2.rs:53:11\n    |\n LL | / struct Foo {\n LL | |     bar: Option<Direction>,"}, {"sha": "c7cde468bb9bfc5c8edc95e4b383450de194ecf8", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]\n "}, {"sha": "4dcbf05ecce2ba675f6f42c122a48b70e1140508", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,8 +1,13 @@\n error[E0004]: non-exhaustive patterns: `Some(Private { misc: true, .. })` not covered\n-  --> $DIR/match-privately-empty.rs:13:11\n+  --> $DIR/match-privately-empty.rs:18:11\n    |\n LL |     match private::DATA {\n    |           ^^^^^^^^^^^^^ pattern `Some(Private { misc: true, .. })` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "59f7bb892c68c03f0946e2b53e1cfc311a965373", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![allow(illegal_floating_point_literal_pattern)]\n \n enum T { A, B }"}, {"sha": "dff2c8d9424c365746f068de3b153e81b3f1cf1f", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: `A` not covered\n-  --> $DIR/non-exhaustive-match.rs:7:11\n+  --> $DIR/non-exhaustive-match.rs:12:11\n    |\n LL | enum T { A, B }\n    | ---------------\n@@ -13,39 +13,44 @@ LL |     match x { T::B => { } }\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `false` not covered\n-  --> $DIR/non-exhaustive-match.rs:8:11\n+  --> $DIR/non-exhaustive-match.rs:13:11\n    |\n LL |     match true {\n    |           ^^^^ pattern `false` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Some(_)` not covered\n-  --> $DIR/non-exhaustive-match.rs:11:11\n+  --> $DIR/non-exhaustive-match.rs:16:11\n    |\n LL |     match Some(10) {\n    |           ^^^^^^^^ pattern `Some(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n-  --> $DIR/non-exhaustive-match.rs:14:11\n+  --> $DIR/non-exhaustive-match.rs:19:11\n    |\n LL |     match (2, 3, 4) {\n    |           ^^^^^^^^^ patterns `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(A, A)` not covered\n-  --> $DIR/non-exhaustive-match.rs:18:11\n+  --> $DIR/non-exhaustive-match.rs:23:11\n    |\n LL |     match (T::A, T::A) {\n    |           ^^^^^^^^^^^^ pattern `(A, A)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `B` not covered\n-  --> $DIR/non-exhaustive-match.rs:22:11\n+  --> $DIR/non-exhaustive-match.rs:27:11\n    |\n LL | enum T { A, B }\n    | ---------------\n@@ -59,15 +64,15 @@ LL |     match T::A {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `[]` not covered\n-  --> $DIR/non-exhaustive-match.rs:33:11\n+  --> $DIR/non-exhaustive-match.rs:38:11\n    |\n LL |     match *vec {\n    |           ^^^^ pattern `[]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `[_, _, _, _, ..]` not covered\n-  --> $DIR/non-exhaustive-match.rs:46:11\n+  --> $DIR/non-exhaustive-match.rs:51:11\n    |\n LL |     match *vec {\n    |           ^^^^ pattern `[_, _, _, _, ..]` not covered"}, {"sha": "cb5188b5fb43fd4c0e374a7e3fb58a8b3d0fdb78", "filename": "src/test/ui/proc-macro/derive-bad.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -3,11 +3,9 @@\n #[macro_use]\n extern crate derive_bad;\n \n-#[derive(\n-    A\n-)]\n-//~^^ ERROR proc-macro derive produced unparseable tokens\n+#[derive(A)]\n+//~^ ERROR proc-macro derive produced unparseable tokens\n //~| ERROR expected `:`, found `}`\n-struct A;\n+struct A; //~ ERROR the name `A` is defined multiple times\n \n fn main() {}"}, {"sha": "bc5ed9815238adf026d3e4d5130641585feda6f4", "filename": "src/test/ui/proc-macro/derive-bad.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,16 +1,28 @@\n error: expected `:`, found `}`\n-  --> $DIR/derive-bad.rs:7:5\n+  --> $DIR/derive-bad.rs:6:10\n    |\n-LL |     A\n-   |     ^ expected `:`\n+LL | #[derive(A)]\n+   |          ^ expected `:`\n    |\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: proc-macro derive produced unparseable tokens\n-  --> $DIR/derive-bad.rs:7:5\n+  --> $DIR/derive-bad.rs:6:10\n    |\n-LL |     A\n-   |     ^\n+LL | #[derive(A)]\n+   |          ^\n \n-error: aborting due to 2 previous errors\n+error[E0428]: the name `A` is defined multiple times\n+  --> $DIR/derive-bad.rs:9:1\n+   |\n+LL | #[derive(A)]\n+   |          - previous definition of the type `A` here\n+...\n+LL | struct A;\n+   | ^^^^^^^^^ `A` redefined here\n+   |\n+   = note: `A` must be defined only once in the type namespace of this module\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "3f78dea917b1960b7910b42ad918718163d06359", "filename": "src/test/ui/proc-macro/invalid-punct-ident-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -14,3 +14,5 @@\n extern crate invalid_punct_ident;\n \n invalid_punct!(); //~ ERROR proc macro panicked\n+\n+fn main() {}"}, {"sha": "4e89e80ae7c412c68fc752a2306351d25e6ca843", "filename": "src/test/ui/proc-macro/invalid-punct-ident-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -14,3 +14,5 @@\n extern crate invalid_punct_ident;\n \n invalid_ident!(); //~ ERROR proc macro panicked\n+\n+fn main() {}"}, {"sha": "8d8ce8f932e7118fb27b0557ea1084882ea0ead8", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -14,3 +14,5 @@\n extern crate invalid_punct_ident;\n \n invalid_raw_ident!(); //~ ERROR proc macro panicked\n+\n+fn main() {}"}, {"sha": "59b347dac679c252dd44fccd83acda84ffa59d5e", "filename": "src/test/ui/proc-macro/invalid-punct-ident-4.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -3,5 +3,10 @@\n #[macro_use]\n extern crate invalid_punct_ident;\n \n-lexer_failure!(); //~ ERROR proc macro panicked\n-                  //~| ERROR unexpected closing delimiter: `)`\n+lexer_failure!();\n+//~^ ERROR proc macro panicked\n+//~| ERROR unexpected closing delimiter: `)`\n+\n+fn main() {\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "3b357aecea864d685397256279ec1cb31f317979", "filename": "src/test/ui/proc-macro/invalid-punct-ident-4.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -12,5 +12,14 @@ error: proc macro panicked\n LL | lexer_failure!();\n    | ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-punct-ident-4.rs:11:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5c43a564c00c2a3b502d4980cc3e74d1d15b384e", "filename": "src/test/ui/proc-macro/issue-36935.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -5,6 +5,7 @@ extern crate test_macros;\n \n #[derive(Identity, Panic)] //~ ERROR proc-macro derive panicked\n struct Baz {\n+    //~^ ERROR the name `Baz` is defined multiple times\n     a: i32,\n     b: i32,\n }"}, {"sha": "2b2e28fdb2fda4ecd081b957bda9c7eb2e2274fa", "filename": "src/test/ui/proc-macro/issue-36935.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -6,5 +6,17 @@ LL | #[derive(Identity, Panic)]\n    |\n    = help: message: panic-derive\n \n-error: aborting due to previous error\n+error[E0428]: the name `Baz` is defined multiple times\n+  --> $DIR/issue-36935.rs:7:1\n+   |\n+LL | struct Baz {\n+   | ^^^^^^^^^^\n+   | |\n+   | `Baz` redefined here\n+   | previous definition of the type `Baz` here\n+   |\n+   = note: `Baz` must be defined only once in the type namespace of this module\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "5be426eb38278be39a7d32b42efd6a83a02cd975", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n struct R<'a> {\n     r: &'a R<'a>,\n }"}, {"sha": "f371d460cf733ceaa8031ce0b77c7e0a929660cc", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,8 +1,13 @@\n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/recursive-types-are-not-uninhabited.rs:6:9\n+  --> $DIR/recursive-types-are-not-uninhabited.rs:11:9\n    |\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "bd6e9d5950272dfe941c34b11ca83d5351101062", "filename": "src/test/ui/resolve/issue-3907-2.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -3,8 +3,11 @@ error[E0038]: the trait `issue_3907::Foo` cannot be made into an object\n    |\n LL | fn bar(_x: Foo) {}\n    |            ^^^ the trait `issue_3907::Foo` cannot be made into an object\n+   | \n+  ::: $DIR/auxiliary/issue-3907.rs:2:8\n    |\n-   = note: the trait cannot be made into an object because associated function `bar` has no `self` parameter\n+LL |     fn bar();\n+   |        --- the trait cannot be made into an object because associated function `bar` has no `self` parameter\n \n error: aborting due to previous error\n "}, {"sha": "a214a652a387fcb4348daff59dbbeb9071499167", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -27,6 +27,13 @@ error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covere\n    |\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   | \n+  ::: $DIR/auxiliary/uninhabited.rs:17:23\n+   |\n+LL |     #[non_exhaustive] Tuple(!),\n+   |                       ----- not covered\n+LL |     #[non_exhaustive] Struct { x: ! }\n+   |                       ------ not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "63564e9c3cc8c097b82f9532f14952829bd7c570", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -27,6 +27,13 @@ error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covere\n    |\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   | \n+  ::: $DIR/auxiliary/uninhabited.rs:17:23\n+   |\n+LL |     #[non_exhaustive] Tuple(!),\n+   |                       ----- not covered\n+LL |     #[non_exhaustive] Struct { x: ! }\n+   |                       ------ not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "bd1f80811b5425748ffe18cf90ff1e3c70f5136a", "filename": "src/test/ui/self/elision/ref-self-async.nll.stderr", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,13 +1,72 @@\n-error[E0658]: `Wrap<&Struct, Struct>` cannot be used as the type of `self` without the `arbitrary_self_types` feature\n-  --> $DIR/ref-self-async.rs:47:39\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self-async.rs:23:9\n    |\n-LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n-   |                                       ^^^^^^^^^^^^^^^^^\n+LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n+   |                       -         - let's call the lifetime of this reference `'1`\n+   |                       |\n+   |                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self-async.rs:29:9\n+   |\n+LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n+   |                             -         - let's call the lifetime of this reference `'1`\n+   |                             |\n+   |                             let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self-async.rs:33:9\n    |\n-   = note: see issue #44874 <https://github.com/rust-lang/rust/issues/44874> for more information\n-   = help: add `#![feature(arbitrary_self_types)]` to the crate attributes to enable\n-   = help: consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one of the previous types except `Self`)\n+LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n+   |                                     -          - let's call the lifetime of this reference `'1`\n+   |                                     |\n+   |                                     let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self-async.rs:37:9\n+   |\n+LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n+   |                                     -          - let's call the lifetime of this reference `'1`\n+   |                                     |\n+   |                                     let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self-async.rs:41:9\n+   |\n+LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n+   |                                             -           - let's call the lifetime of this reference `'1`\n+   |                                             |\n+   |                                             let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self-async.rs:45:9\n+   |\n+LL |     async fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n+   |                                             -           - let's call the lifetime of this reference `'1`\n+   |                                             |\n+   |                                             let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self-async.rs:49:9\n+   |\n+LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n+   |                                            -                - let's call the lifetime of this reference `'1`\n+   |                                            |\n+   |                                            let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error: aborting due to previous error\n+error: aborting due to 7 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "0fbbd95c975d6afb2ea35b35033a5480eabeba99", "filename": "src/test/ui/self/elision/ref-self-async.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,6 +1,7 @@\n // edition:2018\n \n #![allow(non_snake_case)]\n+#![feature(arbitrary_self_types)]\n \n use std::marker::PhantomData;\n use std::ops::Deref;"}, {"sha": "bda958241b67b6564df1b8d6e7b8ee6a02ab8c04", "filename": "src/test/ui/self/elision/ref-self-async.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,5 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/ref-self-async.rs:22:9\n+  --> $DIR/ref-self-async.rs:23:9\n    |\n LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                       -----              ----\n@@ -9,7 +9,7 @@ LL |         f\n    |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ref-self-async.rs:28:9\n+  --> $DIR/ref-self-async.rs:29:9\n    |\n LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                             -----              ----\n@@ -19,7 +19,7 @@ LL |         f\n    |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ref-self-async.rs:32:9\n+  --> $DIR/ref-self-async.rs:33:9\n    |\n LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                     -----               ----\n@@ -29,7 +29,7 @@ LL |         f\n    |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ref-self-async.rs:36:9\n+  --> $DIR/ref-self-async.rs:37:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                     -----               ----\n@@ -39,7 +39,7 @@ LL |         f\n    |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ref-self-async.rs:40:9\n+  --> $DIR/ref-self-async.rs:41:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                             -----                ----\n@@ -49,7 +49,7 @@ LL |         f\n    |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ref-self-async.rs:44:9\n+  --> $DIR/ref-self-async.rs:45:9\n    |\n LL |     async fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                             -----                ----\n@@ -59,7 +59,7 @@ LL |         f\n    |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ref-self-async.rs:48:9\n+  --> $DIR/ref-self-async.rs:49:9\n    |\n LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n    |                                            -----                    ---"}, {"sha": "2d46f74ad9bc902ca80c1e7c93b61c558cf03ae4", "filename": "src/test/ui/span/transitive-dep-span.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -11,3 +11,5 @@\n extern crate transitive_dep_two;\n \n transitive_dep_two::parse_error!(); //~ ERROR expected one of\n+\n+fn main() {}"}, {"sha": "31e567c396067495eb1e8c9b55d7cda283faa659", "filename": "src/test/ui/test-attrs/test-attr-non-associated-functions.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -6,7 +6,13 @@ struct A {}\n \n impl A {\n     #[test]\n-    fn new() -> A { //~ ERROR `#[test]` attribute is only allowed on non associated functions\n+    fn new() -> A {\n+        //~^ ERROR `#[test]` attribute is only allowed on non associated functions\n+        A {}\n+    }\n+    #[test]\n+    fn recovery_witness() -> A {\n+        //~^ ERROR `#[test]` attribute is only allowed on non associated functions\n         A {}\n     }\n }"}, {"sha": "a81b8f3980c374c7bc7c1112fc2a260d5a03f813", "filename": "src/test/ui/test-attrs/test-attr-non-associated-functions.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -2,9 +2,19 @@ error: `#[test]` attribute is only allowed on non associated functions\n   --> $DIR/test-attr-non-associated-functions.rs:9:5\n    |\n LL | /     fn new() -> A {\n+LL | |\n LL | |         A {}\n LL | |     }\n    | |_____^\n \n-error: aborting due to previous error\n+error: `#[test]` attribute is only allowed on non associated functions\n+  --> $DIR/test-attr-non-associated-functions.rs:14:5\n+   |\n+LL | /     fn recovery_witness() -> A {\n+LL | |\n+LL | |         A {}\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "8035de4a48a92ceb16c26e4a4e742243b27b47ad", "filename": "src/test/ui/type/ascription/issue-47666.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,7 @@\n fn main() {\n     let _ = Option:Some(vec![0, 1]); //~ ERROR expected type, found\n+    //~^ ERROR expected value, found enum `Option`\n+    //~| ERROR expected type, found variant `Some`\n }\n \n // This case isn't currently being handled gracefully due to the macro invocation."}, {"sha": "3cd3be70aa75b4163ac0ad6cf7599bf912ccd038", "filename": "src/test/ui/type/ascription/issue-47666.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -13,5 +13,35 @@ LL |     let _ = Option:Some(vec![0, 1]);\n    = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error[E0423]: expected value, found enum `Option`\n+  --> $DIR/issue-47666.rs:2:13\n+   |\n+LL |     let _ = Option:Some(vec![0, 1]);\n+   |             ^^^^^^\n+   |\n+help: try using one of the enum's variants\n+   |\n+LL |     let _ = std::option::Option::None:Some(vec![0, 1]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = std::option::Option::Some:Some(vec![0, 1]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0573]: expected type, found variant `Some`\n+  --> $DIR/issue-47666.rs:2:20\n+   |\n+LL |     let _ = Option:Some(vec![0, 1]);\n+   |                    ^^^^^^^^^^^^^^^^ not a type\n+   |\n+help: try using the variant's enum\n+   |\n+LL |     let _ = Option:std::option::Option;\n+   |                    ^^^^^^^^^^^^^^^^^^^\n+help: maybe you meant to write a path separator here\n+   |\n+LL |     let _ = Option::Some(vec![0, 1]);\n+   |                   ^^\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0423, E0573.\n+For more information about an error, try `rustc --explain E0423`."}, {"sha": "a959aaae05568916576c4b88c3c0624c9763e0d6", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n use std::mem::zeroed;\n enum Void {}\n "}, {"sha": "9245e293caa853074c9bc657eae71483e166b37b", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,13 +1,18 @@\n error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:6:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:11:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `&Void` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:15:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:20:19\n    |\n LL | enum Void {}\n    | ------------ `Void` defined here\n@@ -18,42 +23,52 @@ LL |     let _ = match x {};\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `(Void,)` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:18:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:23:19\n    |\n LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `[Void; 1]` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:21:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:26:19\n    |\n LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:24:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:29:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `&[_, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:32:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:37:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:37:9\n+  --> $DIR/uninhabited-matches-feature-gated.rs:42:9\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "4b92475f1e4cd07f388ee089b2bfe74c8a075019", "filename": "src/test/ui/union/union-derive-clone.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![feature(untagged_unions)]\n \n use std::mem::ManuallyDrop;"}, {"sha": "d0a82a96c165c88b28dbe4ca8650238e0ea409c8", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `U1: std::marker::Copy` is not satisfied\n-  --> $DIR/union-derive-clone.rs:5:10\n+  --> $DIR/union-derive-clone.rs:10:10\n    |\n LL | #[derive(Clone)]\n    |          ^^^^^ the trait `std::marker::Copy` is not implemented for `U1`\n@@ -8,7 +8,7 @@ LL | #[derive(Clone)]\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0599]: no method named `clone` found for union `U5<CloneNoCopy>` in the current scope\n-  --> $DIR/union-derive-clone.rs:37:15\n+  --> $DIR/union-derive-clone.rs:42:15\n    |\n LL | union U5<T> {\n    | -----------\n@@ -21,6 +21,14 @@ LL | struct CloneNoCopy;\n ...\n LL |     let w = u.clone();\n    |               ^^^^^ method not found in `U5<CloneNoCopy>`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<U5<CloneNoCopy>>` here\n+   |        the method is available for `std::rc::Rc<U5<CloneNoCopy>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `CloneNoCopy: std::marker::Copy`"}, {"sha": "2e81e7cf8320011e744bce625109f99450f4642b", "filename": "src/test/ui/unique-object-noncopyable.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -14,6 +14,14 @@ LL |     let _z = y.clone();\n    |\n LL | pub struct Box<T: ?Sized>(Unique<T>);\n    | ------------------------------------- doesn't satisfy `std::boxed::Box<dyn Foo>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<std::boxed::Box<dyn Foo>>` here\n+   |        the method is available for `std::rc::Rc<std::boxed::Box<dyn Foo>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `dyn Foo: std::marker::Sized`"}, {"sha": "06c4b95baef565c73632127734f4a80d38482f38", "filename": "src/test/ui/unique-pinned-nocopy.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d0ae58d30523198dec60a9cd840c30c2bd9c4c0/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr?ref=9d0ae58d30523198dec60a9cd840c30c2bd9c4c0", "patch": "@@ -11,6 +11,14 @@ LL |     let _j = i.clone();\n    |\n LL | pub struct Box<T: ?Sized>(Unique<T>);\n    | ------------------------------------- doesn't satisfy `std::boxed::Box<R>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<std::boxed::Box<R>>` here\n+   |        the method is available for `std::rc::Rc<std::boxed::Box<R>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `R: std::clone::Clone`"}]}