{"sha": "81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYmZiZDI2YmVmMWE2M2NjYmViYTMzNDMwZTZiMDdhNTNjOGU3ZDk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-22T20:12:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-22T20:12:07Z"}, "message": "Merge #2363\n\n2363: More principled sources for enums and fields r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "908faccf9e77fcb1d2804da3289ebc4d026ce339", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/908faccf9e77fcb1d2804da3289ebc4d026ce339"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd2EEXCRBK7hj4Ov3rIwAAdHIIAKjT7oouKoVsCFaXuDJiHkZt\nKIH5RwavtKG6apJAAXFc9YT+vNMQSm7Rxije6OSzbJcjjox1HHcGPoNQ0GBNND8J\nNTv2uU6FHv6qIA/CTz9xykl9Rh/wRiI3Od8tRl5o5z3QDMrNK9sxsMWHCDWfZ7T8\n2ZiY1j1Lq0Rj7Q+PZAkWxi7W/ssG6WbCXL/JPZzvHzNxGepl7uV5J4Vsh2vfRMqI\ndQ9uIuTKStX7POPpofDe0uoodsf0LEQeDmDnN7JqlmsrjwyfseI/iZZWka9pybC5\nLkFR4uJ/yJJCxI1lVuLz9KLo6OCphZFgIYxw+8kmsnLlrb4ri4HX33rArVqe6Xs=\n=AI6u\n-----END PGP SIGNATURE-----\n", "payload": "tree 908faccf9e77fcb1d2804da3289ebc4d026ce339\nparent 5b19202e00fffe62a1a9c07f4b974f0affdd0c66\nparent 0f415dd4b30289117fe76d071293e9bdd3556336\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574453527 +0000\ncommitter GitHub <noreply@github.com> 1574453527 +0000\n\nMerge #2363\n\n2363: More principled sources for enums and fields r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "html_url": "https://github.com/rust-lang/rust/commit/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b19202e00fffe62a1a9c07f4b974f0affdd0c66", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b19202e00fffe62a1a9c07f4b974f0affdd0c66", "html_url": "https://github.com/rust-lang/rust/commit/5b19202e00fffe62a1a9c07f4b974f0affdd0c66"}, {"sha": "0f415dd4b30289117fe76d071293e9bdd3556336", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f415dd4b30289117fe76d071293e9bdd3556336", "html_url": "https://github.com/rust-lang/rust/commit/0f415dd4b30289117fe76d071293e9bdd3556336"}], "stats": {"total": 276, "additions": 193, "deletions": 83}, "files": [{"sha": "a45c062bf4c2bca6258ff154ed53cab506124db5", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 9, "deletions": 41, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "patch": "@@ -1,13 +1,13 @@\n //! FIXME: write short doc here\n \n-use hir_def::{HasSource as _, Lookup};\n+use hir_def::{HasChildSource, HasSource as _, Lookup, VariantId};\n use ra_syntax::ast::{self, AstNode};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::AstItemDef,\n     Const, Either, Enum, EnumVariant, FieldSource, Function, HasBody, HirFileId, MacroDef, Module,\n-    ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n+    ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n };\n \n pub use hir_expand::Source;\n@@ -46,33 +46,12 @@ impl Module {\n impl HasSource for StructField {\n     type Ast = FieldSource;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<FieldSource> {\n-        let var_data = self.parent.variant_data(db);\n-        let fields = var_data.fields().unwrap();\n-        let ss;\n-        let es;\n-        let (file_id, struct_kind) = match self.parent {\n-            VariantDef::Struct(s) => {\n-                ss = s.source(db);\n-                (ss.file_id, ss.value.kind())\n-            }\n-            VariantDef::EnumVariant(e) => {\n-                es = e.source(db);\n-                (es.file_id, es.value.kind())\n-            }\n-        };\n-\n-        let field_sources = match struct_kind {\n-            ast::StructKind::Tuple(fl) => fl.fields().map(|it| FieldSource::Pos(it)).collect(),\n-            ast::StructKind::Record(fl) => fl.fields().map(|it| FieldSource::Named(it)).collect(),\n-            ast::StructKind::Unit => Vec::new(),\n-        };\n-        let value = field_sources\n-            .into_iter()\n-            .zip(fields.iter())\n-            .find(|(_syntax, (id, _))| *id == self.id)\n-            .unwrap()\n-            .0;\n-        Source { file_id, value }\n+        let var = VariantId::from(self.parent);\n+        let src = var.child_source(db);\n+        src.map(|it| match it[self.id].clone() {\n+            Either::A(it) => FieldSource::Pos(it),\n+            Either::B(it) => FieldSource::Named(it),\n+        })\n     }\n }\n impl HasSource for Struct {\n@@ -96,18 +75,7 @@ impl HasSource for Enum {\n impl HasSource for EnumVariant {\n     type Ast = ast::EnumVariant;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::EnumVariant> {\n-        let enum_data = db.enum_data(self.parent.id);\n-        let src = self.parent.id.source(db);\n-        let value = src\n-            .value\n-            .variant_list()\n-            .into_iter()\n-            .flat_map(|it| it.variants())\n-            .zip(enum_data.variants.iter())\n-            .find(|(_syntax, (id, _))| *id == self.id)\n-            .unwrap()\n-            .0;\n-        Source { file_id: src.file_id, value }\n+        self.parent.id.child_source(db).map(|map| map[self.id].clone())\n     }\n }\n impl HasSource for Function {"}, {"sha": "8900fc1f240de56bd6822a74b54cf569cce8a7c9", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "patch": "@@ -5,13 +5,13 @@\n \n use hir_def::{\n     AdtId, AssocItemId, ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n-    ModuleDefId, StaticId, StructId, TypeAliasId, UnionId,\n+    ModuleDefId, StaticId, StructId, TypeAliasId, UnionId, VariantId,\n };\n \n use crate::{\n     ty::{CallableDef, TypableDef},\n     Adt, AssocItem, Const, Crate, DefWithBody, EnumVariant, Function, GenericDef, ModuleDef,\n-    Static, TypeAlias,\n+    Static, TypeAlias, VariantDef,\n };\n \n impl From<ra_db::CrateId> for Crate {\n@@ -70,6 +70,12 @@ impl From<EnumVariantId> for EnumVariant {\n     }\n }\n \n+impl From<EnumVariant> for EnumVariantId {\n+    fn from(def: EnumVariant) -> Self {\n+        EnumVariantId { parent: def.parent.id, local_id: def.id }\n+    }\n+}\n+\n impl From<ModuleDefId> for ModuleDef {\n     fn from(id: ModuleDefId) -> Self {\n         match id {\n@@ -219,3 +225,12 @@ impl From<CallableDef> for GenericDefId {\n         }\n     }\n }\n+\n+impl From<VariantDef> for VariantId {\n+    fn from(def: VariantDef) -> Self {\n+        match def {\n+            VariantDef::Struct(it) => VariantId::StructId(it.id),\n+            VariantDef::EnumVariant(it) => VariantId::EnumVariantId(it.into()),\n+        }\n+    }\n+}"}, {"sha": "ae99afe396a869a0078f6cfa5387ea14a944eec6", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 106, "deletions": 39, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "patch": "@@ -2,13 +2,17 @@\n \n use std::sync::Arc;\n \n-use hir_expand::name::{AsName, Name};\n-use ra_arena::Arena;\n+use hir_expand::{\n+    either::Either,\n+    name::{AsName, Name},\n+    Source,\n+};\n+use ra_arena::{map::ArenaMap, Arena};\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n-    db::DefDatabase2, type_ref::TypeRef, AstItemDef, EnumId, LocalEnumVariantId,\n-    LocalStructFieldId, StructOrUnionId,\n+    db::DefDatabase2, trace::Trace, type_ref::TypeRef, AstItemDef, EnumId, HasChildSource,\n+    LocalEnumVariantId, LocalStructFieldId, StructOrUnionId, VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -61,17 +65,9 @@ impl EnumData {\n     pub(crate) fn enum_data_query(db: &impl DefDatabase2, e: EnumId) -> Arc<EnumData> {\n         let src = e.source(db);\n         let name = src.value.name().map(|n| n.as_name());\n-        let variants = src\n-            .value\n-            .variant_list()\n-            .into_iter()\n-            .flat_map(|it| it.variants())\n-            .map(|var| EnumVariantData {\n-                name: var.name().map(|it| it.as_name()),\n-                variant_data: Arc::new(VariantData::new(var.kind())),\n-            })\n-            .collect();\n-        Arc::new(EnumData { name, variants })\n+        let mut trace = Trace::new_for_arena();\n+        lower_enum(&mut trace, &src.value);\n+        Arc::new(EnumData { name, variants: trace.into_arena() })\n     }\n \n     pub(crate) fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n@@ -80,38 +76,109 @@ impl EnumData {\n     }\n }\n \n+impl HasChildSource for EnumId {\n+    type ChildId = LocalEnumVariantId;\n+    type Value = ast::EnumVariant;\n+    fn child_source(&self, db: &impl DefDatabase2) -> Source<ArenaMap<Self::ChildId, Self::Value>> {\n+        let src = self.source(db);\n+        let mut trace = Trace::new_for_map();\n+        lower_enum(&mut trace, &src.value);\n+        src.with_value(trace.into_map())\n+    }\n+}\n+\n+fn lower_enum(\n+    trace: &mut Trace<LocalEnumVariantId, EnumVariantData, ast::EnumVariant>,\n+    ast: &ast::EnumDef,\n+) {\n+    for var in ast.variant_list().into_iter().flat_map(|it| it.variants()) {\n+        trace.alloc(\n+            || var.clone(),\n+            || EnumVariantData {\n+                name: var.name().map(|it| it.as_name()),\n+                variant_data: Arc::new(VariantData::new(var.kind())),\n+            },\n+        )\n+    }\n+}\n+\n impl VariantData {\n     fn new(flavor: ast::StructKind) -> Self {\n-        match flavor {\n-            ast::StructKind::Tuple(fl) => {\n-                let fields = fl\n-                    .fields()\n-                    .enumerate()\n-                    .map(|(i, fd)| StructFieldData {\n-                        name: Name::new_tuple_field(i),\n-                        type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n-                    })\n-                    .collect();\n-                VariantData::Tuple(fields)\n-            }\n-            ast::StructKind::Record(fl) => {\n-                let fields = fl\n-                    .fields()\n-                    .map(|fd| StructFieldData {\n-                        name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n-                        type_ref: TypeRef::from_ast_opt(fd.ascribed_type()),\n-                    })\n-                    .collect();\n-                VariantData::Record(fields)\n-            }\n-            ast::StructKind::Unit => VariantData::Unit,\n+        let mut trace = Trace::new_for_arena();\n+        match lower_struct(&mut trace, &flavor) {\n+            StructKind::Tuple => VariantData::Tuple(trace.into_arena()),\n+            StructKind::Record => VariantData::Record(trace.into_arena()),\n+            StructKind::Unit => VariantData::Unit,\n         }\n     }\n \n     pub fn fields(&self) -> Option<&Arena<LocalStructFieldId, StructFieldData>> {\n-        match self {\n+        match &self {\n             VariantData::Record(fields) | VariantData::Tuple(fields) => Some(fields),\n             _ => None,\n         }\n     }\n }\n+\n+impl HasChildSource for VariantId {\n+    type ChildId = LocalStructFieldId;\n+    type Value = Either<ast::TupleFieldDef, ast::RecordFieldDef>;\n+\n+    fn child_source(&self, db: &impl DefDatabase2) -> Source<ArenaMap<Self::ChildId, Self::Value>> {\n+        let src = match self {\n+            VariantId::EnumVariantId(it) => {\n+                // I don't really like the fact that we call into parent source\n+                // here, this might add to more queries then necessary.\n+                let src = it.parent.child_source(db);\n+                src.map(|map| map[it.local_id].kind())\n+            }\n+            VariantId::StructId(it) => it.0.source(db).map(|it| it.kind()),\n+        };\n+        let mut trace = Trace::new_for_map();\n+        lower_struct(&mut trace, &src.value);\n+        src.with_value(trace.into_map())\n+    }\n+}\n+\n+enum StructKind {\n+    Tuple,\n+    Record,\n+    Unit,\n+}\n+\n+fn lower_struct(\n+    trace: &mut Trace<\n+        LocalStructFieldId,\n+        StructFieldData,\n+        Either<ast::TupleFieldDef, ast::RecordFieldDef>,\n+    >,\n+    ast: &ast::StructKind,\n+) -> StructKind {\n+    match ast {\n+        ast::StructKind::Tuple(fl) => {\n+            for (i, fd) in fl.fields().enumerate() {\n+                trace.alloc(\n+                    || Either::A(fd.clone()),\n+                    || StructFieldData {\n+                        name: Name::new_tuple_field(i),\n+                        type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n+                    },\n+                )\n+            }\n+            StructKind::Tuple\n+        }\n+        ast::StructKind::Record(fl) => {\n+            for fd in fl.fields() {\n+                trace.alloc(\n+                    || Either::B(fd.clone()),\n+                    || StructFieldData {\n+                        name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n+                        type_ref: TypeRef::from_ast_opt(fd.ascribed_type()),\n+                    },\n+                )\n+            }\n+            StructKind::Record\n+        }\n+        ast::StructKind::Unit => StructKind::Unit,\n+    }\n+}"}, {"sha": "2edf743abba781b15717f440ca85d929ae21af64", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "patch": "@@ -20,6 +20,8 @@ pub mod generics;\n pub mod resolver;\n pub mod data;\n \n+mod trace;\n+\n #[cfg(test)]\n mod test_db;\n #[cfg(test)]\n@@ -31,7 +33,7 @@ pub mod nameres;\n use std::hash::{Hash, Hasher};\n \n use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId, Source};\n-use ra_arena::{impl_arena_id, RawId};\n+use ra_arena::{impl_arena_id, map::ArenaMap, RawId};\n use ra_db::{salsa, CrateId, FileId};\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n@@ -550,3 +552,12 @@ impl HasSource for ConstLoc {\n         Source::new(self.ast_id.file_id(), node)\n     }\n }\n+\n+pub trait HasChildSource {\n+    type ChildId;\n+    type Value;\n+    fn child_source(\n+        &self,\n+        db: &impl db::DefDatabase2,\n+    ) -> Source<ArenaMap<Self::ChildId, Self::Value>>;\n+}"}, {"sha": "fc26f5a48653f202bb12a272c8a84543aa0d898c", "filename": "crates/ra_hir_def/src/trace.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs?ref=81bfbd26bef1a63ccbeba33430e6b07a53c8e7d9", "patch": "@@ -0,0 +1,49 @@\n+//! Trace is a pretty niche data structure which is used when lowering a CST\n+//! into HIR.\n+//!\n+//! Lowering process calculates two bits of information:\n+//! * the lowered syntax itself\n+//! * a mapping between lowered syntax and original syntax\n+//!\n+//! Due to the way salsa works, the mapping is usually hot lava, as it contains\n+//! absolute offsets. The `Trace` structure (inspired, at least in name, by\n+//! Kotlin's `BindingTrace`) allows use the same code to compute both\n+//! projections.\n+use ra_arena::{map::ArenaMap, Arena, ArenaId, RawId};\n+\n+pub(crate) struct Trace<ID: ArenaId, T, V> {\n+    for_arena: bool,\n+    arena: Arena<ID, T>,\n+    map: ArenaMap<ID, V>,\n+    len: u32,\n+}\n+\n+impl<ID: ra_arena::ArenaId, T, V> Trace<ID, T, V> {\n+    pub(crate) fn new_for_arena() -> Trace<ID, T, V> {\n+        Trace { for_arena: true, arena: Arena::default(), map: ArenaMap::default(), len: 0 }\n+    }\n+\n+    pub(crate) fn new_for_map() -> Trace<ID, T, V> {\n+        Trace { for_arena: false, arena: Arena::default(), map: ArenaMap::default(), len: 0 }\n+    }\n+\n+    pub(crate) fn alloc(&mut self, value: impl Fn() -> V, data: impl Fn() -> T) {\n+        if self.for_arena {\n+            self.arena.alloc(data());\n+        } else {\n+            let id = ID::from_raw(RawId::from(self.len));\n+            self.len += 1;\n+            self.map.insert(id, value());\n+        }\n+    }\n+\n+    pub(crate) fn into_arena(self) -> Arena<ID, T> {\n+        assert!(self.for_arena);\n+        self.arena\n+    }\n+\n+    pub(crate) fn into_map(self) -> ArenaMap<ID, V> {\n+        assert!(!self.for_arena);\n+        self.map\n+    }\n+}"}]}