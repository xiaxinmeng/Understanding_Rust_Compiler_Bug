{"sha": "50c952b5b796828a9a774c2249e7d08056393464", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYzk1MmI1Yjc5NjgyOGE5YTc3NGMyMjQ5ZTdkMDgwNTYzOTM0NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-04T00:23:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-04T00:23:30Z"}, "message": "Auto merge of #26370 - nikomatsakis:better-object-defaults-warn, r=nikomatsakis\n\nThis is an implementation of RFC rust-lang/rfcs#1156. It includes the code to implement the new rules, but that code is currently disabled. It also includes code to issue warnings when the change will cause breakage. These warnings try hard to be targeted but are also somewhat approximate. They could, with some effort, be made *more* targeted by adjusting the code in ty_relate that propagates the \"will change\" flag to consider the specific operation. Might be worth doing.\r\n\r\nr? @pnkfelix (I think you understand region inference best)", "tree": {"sha": "c3c4cd297366df5eb161f7585ee6706dff752041", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c4cd297366df5eb161f7585ee6706dff752041"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50c952b5b796828a9a774c2249e7d08056393464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50c952b5b796828a9a774c2249e7d08056393464", "html_url": "https://github.com/rust-lang/rust/commit/50c952b5b796828a9a774c2249e7d08056393464", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50c952b5b796828a9a774c2249e7d08056393464/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f027bdc1c8a133693651f333624b756abe21960f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f027bdc1c8a133693651f333624b756abe21960f", "html_url": "https://github.com/rust-lang/rust/commit/f027bdc1c8a133693651f333624b756abe21960f"}, {"sha": "db5f3bc65c5f67806df531eadafdc86f8bf7f5e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/db5f3bc65c5f67806df531eadafdc86f8bf7f5e0", "html_url": "https://github.com/rust-lang/rust/commit/db5f3bc65c5f67806df531eadafdc86f8bf7f5e0"}], "stats": {"total": 568, "additions": 479, "deletions": 89}, "files": [{"sha": "38df0284371d073ea8bab1ea90767bcead57d0ff", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -1160,6 +1160,42 @@ static mut FOO: Option<Box<usize>> = None;\n // error: mutable statics are not allowed to have destructors\n static mut BAR: Option<Vec<i32>> = None;\n ```\n+\"##,\n+\n+E0398: r##\"\n+In Rust 1.3, the default object lifetime bounds are expected to\n+change, as described in RFC #1156 [1]. You are getting a warning\n+because the compiler thinks it is possible that this change will cause\n+a compilation error in your code. It is possible, though unlikely,\n+that this is a false alarm.\n+\n+The heart of the change is that where `&'a Box<SomeTrait>` used to\n+default to `&'a Box<SomeTrait+'a>`, it now defaults to `&'a\n+Box<SomeTrait+'static>` (here, `SomeTrait` is the name of some trait\n+type). Note that the only types which are affected are references to\n+boxes, like `&Box<SomeTrait>` or `&[Box<SomeTrait>]`.  More common\n+types like `&SomeTrait` or `Box<SomeTrait>` are unaffected.\n+\n+To silence this warning, edit your code to use an explicit bound.\n+Most of the time, this means that you will want to change the\n+signature of a function that you are calling. For example, if\n+the error is reported on a call like `foo(x)`, and `foo` is\n+defined as follows:\n+\n+```\n+fn foo(arg: &Box<SomeTrait>) { ... }\n+```\n+\n+you might change it to:\n+\n+```\n+fn foo<'a>(arg: &Box<SomeTrait+'a>) { ... }\n+```\n+\n+This explicitly states that you expect the trait object `SomeTrait` to\n+contain references (with a maximum lifetime of `'a`).\n+\n+[1]: https://github.com/rust-lang/rfcs/pull/1156\n \"##\n \n }"}, {"sha": "61fce699dd555285c6dd5b4235a355deac284fe3", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -843,15 +843,15 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n \n fn parse_object_lifetime_default<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n                                              conv: &mut F)\n-                                             -> Option<ty::ObjectLifetimeDefault>\n+                                             -> ty::ObjectLifetimeDefault\n     where F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     match next(st) {\n-        'n' => None,\n-        'a' => Some(ty::ObjectLifetimeDefault::Ambiguous),\n+        'a' => ty::ObjectLifetimeDefault::Ambiguous,\n+        'b' => ty::ObjectLifetimeDefault::BaseDefault,\n         's' => {\n             let region = parse_region_(st, conv);\n-            Some(ty::ObjectLifetimeDefault::Specific(region))\n+            ty::ObjectLifetimeDefault::Specific(region)\n         }\n         _ => panic!(\"parse_object_lifetime_default: bad input\")\n     }\n@@ -887,9 +887,16 @@ fn parse_existential_bounds_<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n         }\n     }\n \n+    let region_bound_will_change = match next(st) {\n+        'y' => true,\n+        'n' => false,\n+        c => panic!(\"parse_ty: expected y/n not '{}'\", c)\n+    };\n+\n     return ty::ExistentialBounds { region_bound: region_bound,\n                                    builtin_bounds: builtin_bounds,\n-                                   projection_bounds: projection_bounds };\n+                                   projection_bounds: projection_bounds,\n+                                   region_bound_will_change: region_bound_will_change };\n }\n \n fn parse_builtin_bounds<F>(st: &mut PState, mut _conv: F) -> ty::BuiltinBounds where"}, {"sha": "441f9f102aea911e4fa67b7f1ffcc2f606f68ff5", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -390,6 +390,8 @@ pub fn enc_existential_bounds<'a,'tcx>(w: &mut Encoder,\n     }\n \n     mywrite!(w, \".\");\n+\n+    mywrite!(w, \"{}\", if bs.region_bound_will_change {'y'} else {'n'});\n }\n \n pub fn enc_region_bounds<'a, 'tcx>(w: &mut Encoder,\n@@ -414,12 +416,12 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n \n fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Encoder,\n                                          cx: &ctxt<'a, 'tcx>,\n-                                         default: Option<ty::ObjectLifetimeDefault>)\n+                                         default: ty::ObjectLifetimeDefault)\n {\n     match default {\n-        None => mywrite!(w, \"n\"),\n-        Some(ty::ObjectLifetimeDefault::Ambiguous) => mywrite!(w, \"a\"),\n-        Some(ty::ObjectLifetimeDefault::Specific(r)) => {\n+        ty::ObjectLifetimeDefault::Ambiguous => mywrite!(w, \"a\"),\n+        ty::ObjectLifetimeDefault::BaseDefault => mywrite!(w, \"b\"),\n+        ty::ObjectLifetimeDefault::Specific(r) => {\n             mywrite!(w, \"s\");\n             enc_region(w, cx, r);\n         }"}, {"sha": "ad53fb4a8a2701f2f69cf2e35902aa38d29655df", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -49,6 +49,11 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n+    fn will_change(&mut self, _: bool, _: bool) -> bool {\n+        // since we are not comparing regions, we don't care\n+        false\n+    }\n+\n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n                                                variance: ty::Variance,\n                                                a: &T,"}, {"sha": "0d081cfeee0410ea7f74065020b79abc94534619", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -56,6 +56,7 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n+    pub cause: Option<ty_relate::Cause>,\n }\n \n pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,"}, {"sha": "c0dcda1792be526426dfaabb383f8c43e8b2466c", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -34,6 +34,11 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n+    fn will_change(&mut self, a: bool, b: bool) -> bool {\n+        // if either side changed from what it was, that could cause equality to fail\n+        a || b\n+    }\n+\n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n                                                _: ty::Variance,\n                                                a: &T,"}, {"sha": "8d226739e1688cdb4bbf82822a43098900e342b3", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -593,7 +593,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sub: Region,\n                                sup: Region) {\n         match origin {\n-            infer::Subtype(trace) => {\n+            infer::Subtype(trace) |\n+            infer::DefaultExistentialBound(trace) => {\n                 let terr = ty::terr_regions_does_not_outlive(sup, sub);\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n@@ -1569,7 +1570,8 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n-            infer::Subtype(ref trace) => {\n+            infer::Subtype(ref trace) |\n+            infer::DefaultExistentialBound(ref trace) => {\n                 let desc = match trace.origin {\n                     infer::Misc(_) => {\n                         \"types are compatible\""}, {"sha": "adfd1a8a7d7945abf088ad564ae2d0836be68604", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -35,6 +35,16 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n+    fn will_change(&mut self, a: bool, b: bool) -> bool {\n+        // Hmm, so the result of GLB will still be a LB if one or both\n+        // sides change to 'static, but it may no longer be the GLB.\n+        // I'm going to go with `a || b` here to be conservative,\n+        // since the result of this operation may be affected, though\n+        // I think it would mostly be more accepting than before (since the result\n+        // would be a bigger region).\n+        a || b\n+    }\n+\n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n                                                variance: ty::Variance,\n                                                a: &T,"}, {"sha": "f10d4adc8e5f2df62032133480d7b3aac5642fbf", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -35,6 +35,11 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n+    fn will_change(&mut self, a: bool, b: bool) -> bool {\n+        // result will be 'static if a || b\n+        a || b\n+    }\n+\n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n                                                variance: ty::Variance,\n                                                a: &T,"}, {"sha": "34726436ff755acd1a888b8f5e0086e064cb68ea", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -194,6 +194,9 @@ pub enum SubregionOrigin<'tcx> {\n     // Arose from a subtyping relation\n     Subtype(TypeTrace<'tcx>),\n \n+    // Arose from a subtyping relation\n+    DefaultExistentialBound(TypeTrace<'tcx>),\n+\n     // Stack-allocated closures cannot outlive innermost loop\n     // or function so as to ensure we only require finite stack\n     InfStackClosure(Span),\n@@ -658,7 +661,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                       -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n-                       trace: trace}\n+                       trace: trace,\n+                       cause: None}\n     }\n \n     // public so that it can be used from the rustc_driver unit tests\n@@ -1464,6 +1468,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n             Subtype(ref a) => a.span(),\n+            DefaultExistentialBound(ref a) => a.span(),\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,"}, {"sha": "891a39e723a62357ea34bc8a5c2aade37b3b3550", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -1358,9 +1358,56 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n+        // Check for future hostile edges tied to a bad default\n+        self.report_future_hostility(&graph);\n+\n         (0..self.num_vars() as usize).map(|idx| var_data[idx].value).collect()\n     }\n \n+    fn report_future_hostility(&self, graph: &RegionGraph) {\n+        let constraints = self.constraints.borrow();\n+        for edge in graph.all_edges() {\n+            match constraints[&edge.data] {\n+                SubregionOrigin::DefaultExistentialBound(_) => {\n+                    // this will become 'static in the future\n+                }\n+                _ => { continue; }\n+            }\n+\n+            // this constraint will become a 'static constraint in the\n+            // future, so walk outward and see if we have any hard\n+            // bounds that could not be inferred to 'static\n+            for nid in graph.depth_traverse(edge.target()) {\n+                for (_, succ) in graph.outgoing_edges(nid) {\n+                    match succ.data {\n+                        ConstrainVarSubReg(_, r) => {\n+                            match r {\n+                                ty::ReStatic | ty::ReInfer(_) => {\n+                                    /* OK */\n+                                }\n+                                ty::ReFree(_) | ty::ReScope(_) | ty::ReEmpty => {\n+                                    span_warn!(\n+                                        self.tcx.sess,\n+                                        constraints[&edge.data].span(),\n+                                        E0398,\n+                                        \"this code may fail to compile in Rust 1.3 due to \\\n+                                         the proposed change in object lifetime bound defaults\");\n+                                    return; // only issue the warning once per fn\n+                                }\n+                                ty::ReEarlyBound(..) | ty::ReLateBound(..) => {\n+                                    self.tcx.sess.span_bug(\n+                                        constraints[&succ.data].span(),\n+                                        \"relation to bound region\");\n+                                }\n+                            }\n+                        }\n+                        _ => { }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn construct_graph(&self) -> RegionGraph {\n         let num_vars = self.num_vars();\n "}, {"sha": "7c40e96a2f7a5c8e43eb922c7b6fcd0cb7aae133", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -10,16 +10,17 @@\n \n use super::combine::{self, CombineFields};\n use super::higher_ranked::HigherRankedRelations;\n-use super::Subtype;\n+use super::SubregionOrigin;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use middle::ty_relate::{Cause, Relate, RelateResult, TypeRelation};\n+use std::mem;\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Sub<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+    fields: CombineFields<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> Sub<'a, 'tcx> {\n@@ -33,6 +34,25 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n+    fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R\n+    {\n+        debug!(\"sub with_cause={:?}\", cause);\n+        let old_cause = mem::replace(&mut self.fields.cause, Some(cause));\n+        let r = f(self);\n+        debug!(\"sub old_cause={:?}\", old_cause);\n+        self.fields.cause = old_cause;\n+        r\n+    }\n+\n+    fn will_change(&mut self, a: bool, b: bool) -> bool {\n+        // if we have (Foo+'a) <: (Foo+'b), this requires that 'a:'b.\n+        // So if 'a becomes 'static, no additional errors can occur.\n+        // OTOH, if 'a stays the same, but 'b becomes 'static, we\n+        // could have a problem.\n+        !a && b\n+    }\n+\n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n                                                variance: ty::Variance,\n                                                a: &T,\n@@ -84,11 +104,14 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({:?}, {:?})\",\n-               self.tag(),\n-               a,\n-               b);\n-        let origin = Subtype(self.fields.trace.clone());\n+        debug!(\"{}.regions({:?}, {:?}) self.cause={:?}\",\n+               self.tag(), a, b, self.fields.cause);\n+        let origin = match self.fields.cause {\n+            Some(Cause::ExistentialRegionBound(true)) =>\n+                SubregionOrigin::DefaultExistentialBound(self.fields.trace.clone()),\n+            _ =>\n+                SubregionOrigin::Subtype(self.fields.trace.clone()),\n+        };\n         self.fields.infcx.region_vars.make_subregion(origin, a, b);\n         Ok(a)\n     }"}, {"sha": "abc300869adcafb61e329c21de4aecb4e67510b5", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -2445,6 +2445,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     region_bound: data_b.bounds.region_bound,\n                     builtin_bounds: data_b.bounds.builtin_bounds,\n                     projection_bounds: data_a.bounds.projection_bounds.clone(),\n+                    region_bound_will_change: data_b.bounds.region_bound_will_change,\n                 };\n \n                 let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);"}, {"sha": "544e594dd21b0f42c8b3c39cebe1def4e3b4fcd9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -2055,6 +2055,11 @@ pub struct ExistentialBounds<'tcx> {\n     pub region_bound: ty::Region,\n     pub builtin_bounds: BuiltinBounds,\n     pub projection_bounds: Vec<PolyProjectionPredicate<'tcx>>,\n+\n+    // If true, this TyTrait used a \"default bound\" in the surface\n+    // syntax.  This makes no difference to the type system but is\n+    // handy for error reporting.\n+    pub region_bound_will_change: bool,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -2245,6 +2250,9 @@ pub enum ObjectLifetimeDefault {\n     /// `T:'a` constraints are found.\n     Ambiguous,\n \n+    /// Use the base default, typically 'static, but in a fn body it is a fresh variable\n+    BaseDefault,\n+\n     /// Use the given region as the default.\n     Specific(Region),\n }\n@@ -2256,7 +2264,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub space: subst::ParamSpace,\n     pub index: u32,\n     pub default: Option<Ty<'tcx>>,\n-    pub object_lifetime_default: Option<ObjectLifetimeDefault>,\n+    pub object_lifetime_default: ObjectLifetimeDefault,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n@@ -7328,6 +7336,7 @@ impl<'tcx> fmt::Debug for ObjectLifetimeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n+            ObjectLifetimeDefault::BaseDefault => write!(f, \"BaseDefault\"),\n             ObjectLifetimeDefault::Specific(ref r) => write!(f, \"{:?}\", r),\n         }\n     }"}, {"sha": "5e88a0aefd3ab409a4b36c4eb59a957040083be8", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -369,6 +369,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n             ty::ObjectLifetimeDefault::Ambiguous =>\n                 ty::ObjectLifetimeDefault::Ambiguous,\n \n+            ty::ObjectLifetimeDefault::BaseDefault =>\n+                ty::ObjectLifetimeDefault::BaseDefault,\n+\n             ty::ObjectLifetimeDefault::Specific(r) =>\n                 ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n         }\n@@ -725,6 +728,7 @@ pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n         region_bound: bounds.region_bound.fold_with(this),\n         builtin_bounds: bounds.builtin_bounds,\n         projection_bounds: bounds.projection_bounds.fold_with(this),\n+        region_bound_will_change: bounds.region_bound_will_change,\n     }\n }\n "}, {"sha": "5776235780a3a927b225d5e5d7074f72bb7bb63b", "filename": "src/librustc/middle/ty_match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -42,6 +42,11 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n     fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n+    fn will_change(&mut self, _: bool, _: bool) -> bool {\n+        // we're ignoring regions in this code\n+        false\n+    }\n+\n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n                                                _: ty::Variance,\n                                                a: &T,"}, {"sha": "b8b2469b2066737f05abd0a6cfe482352e5d1c41", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -22,6 +22,11 @@ use syntax::ast;\n \n pub type RelateResult<'tcx, T> = Result<T, ty::type_err<'tcx>>;\n \n+#[derive(Clone, Debug)]\n+pub enum Cause {\n+    ExistentialRegionBound(bool), // if true, this is a default, else explicit\n+}\n+\n pub trait TypeRelation<'a,'tcx> : Sized {\n     fn tcx(&self) -> &'a ty::ctxt<'tcx>;\n \n@@ -32,6 +37,19 @@ pub trait TypeRelation<'a,'tcx> : Sized {\n     /// relation. Just affects error messages.\n     fn a_is_expected(&self) -> bool;\n \n+    fn with_cause<F,R>(&mut self, _cause: Cause, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R\n+    {\n+        f(self)\n+    }\n+\n+    /// Hack for deciding whether the lifetime bound defaults change\n+    /// will be a breaking change or not. The bools indicate whether\n+    /// `a`/`b` have a default that will change to `'static`; the\n+    /// result is true if this will potentially affect the affect of\n+    /// relating `a` and `b`.\n+    fn will_change(&mut self, a: bool, b: bool) -> bool;\n+\n     /// Generic relation routine suitable for most anything.\n     fn relate<T:Relate<'a,'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n         Relate::relate(self, a, b)\n@@ -366,14 +384,21 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n                  -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n         where R: TypeRelation<'a,'tcx>\n     {\n-        let r = try!(relation.relate_with_variance(ty::Contravariant,\n-                                                   &a.region_bound,\n-                                                   &b.region_bound));\n+        let will_change = relation.will_change(a.region_bound_will_change,\n+                                               b.region_bound_will_change);\n+\n+        let r =\n+            try!(relation.with_cause(\n+                Cause::ExistentialRegionBound(will_change),\n+                |relation| relation.relate_with_variance(ty::Contravariant,\n+                                                         &a.region_bound,\n+                                                         &b.region_bound)));\n         let nb = try!(relation.relate(&a.builtin_bounds, &b.builtin_bounds));\n         let pb = try!(relation.relate(&a.projection_bounds, &b.projection_bounds));\n         Ok(ty::ExistentialBounds { region_bound: r,\n                                    builtin_bounds: nb,\n-                                   projection_bounds: pb })\n+                                   projection_bounds: pb,\n+                                   region_bound_will_change: will_change })\n     }\n }\n "}, {"sha": "44bea1cb621efc1037476f62eedffed1eab7c1e7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -290,13 +290,18 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n             try!(write!(f, \" + {:?}\", bound));\n         }\n \n-        // Region, if not obviously implied by builtin bounds.\n-        if bounds.region_bound != ty::ReStatic {\n-            // Region bound is implied by builtin bounds:\n-            let bound = bounds.region_bound.to_string();\n-            if !bound.is_empty() {\n-                try!(write!(f, \" + {}\", bound));\n-            }\n+        // FIXME: It'd be nice to compute from context when this bound\n+        // is implied, but that's non-trivial -- we'd perhaps have to\n+        // use thread-local data of some kind? There are also\n+        // advantages to just showing the region, since it makes\n+        // people aware that it's there.\n+        let bound = bounds.region_bound.to_string();\n+        if !bound.is_empty() {\n+            try!(write!(f, \" + {}\", bound));\n+        }\n+\n+        if bounds.region_bound_will_change && verbose() {\n+            try!(write!(f, \" [WILL-CHANGE]\"));\n         }\n \n         Ok(())"}, {"sha": "ed2d303b5e1b6f978f2bdef34b8e39ecf37025fc", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -82,6 +82,16 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n             return t_norm;\n         }\n \n+        fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n+                                   -> ty::ExistentialBounds<'tcx> {\n+            let mut s = ty_fold::super_fold_existential_bounds(self, s);\n+\n+            // this annoying flag messes up trans normalization\n+            s.region_bound_will_change = false;\n+\n+            s\n+        }\n+\n         fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n             where T : TypeFoldable<'tcx>\n         {"}, {"sha": "7f29af0d84b2df4dcb863c25bfff865853c2c2a1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -1549,7 +1549,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             let rscope1 =\n                 &ObjectLifetimeDefaultRscope::new(\n                     rscope,\n-                    Some(ty::ObjectLifetimeDefault::Specific(r)));\n+                    ty::ObjectLifetimeDefault::Specific(r));\n             let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n             tcx.mk_ref(tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n         }\n@@ -2016,19 +2016,38 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n                   \"only the builtin traits can be used as closure or object bounds\");\n     }\n \n-    let region_bound = compute_object_lifetime_bound(this,\n-                                                     rscope,\n-                                                     span,\n-                                                     &region_bounds,\n-                                                     principal_trait_ref,\n-                                                     builtin_bounds);\n+    let region_bound =\n+        compute_object_lifetime_bound(this,\n+                                      span,\n+                                      &region_bounds,\n+                                      principal_trait_ref,\n+                                      builtin_bounds);\n+\n+    let (region_bound, will_change) = match region_bound {\n+        Some(r) => (r, false),\n+        None => {\n+            match rscope.object_lifetime_default(span) {\n+                Some(r) => (r, rscope.object_lifetime_default_will_change_in_1_3()),\n+                None => {\n+                    span_err!(this.tcx().sess, span, E0228,\n+                              \"the lifetime bound for this object type cannot be deduced \\\n+                               from context; please supply an explicit bound\");\n+                    (ty::ReStatic, false)\n+                }\n+            }\n+        }\n+    };\n+\n+    debug!(\"region_bound: {:?} will_change: {:?}\",\n+           region_bound, will_change);\n \n     ty::sort_bounds_list(&mut projection_bounds);\n \n     ty::ExistentialBounds {\n         region_bound: region_bound,\n         builtin_bounds: builtin_bounds,\n         projection_bounds: projection_bounds,\n+        region_bound_will_change: will_change,\n     }\n }\n \n@@ -2038,12 +2057,11 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n /// region bounds. It may be that we can derive no bound at all, in which case we return `None`.\n fn compute_object_lifetime_bound<'tcx>(\n     this: &AstConv<'tcx>,\n-    rscope: &RegionScope,\n     span: Span,\n     explicit_region_bounds: &[&ast::Lifetime],\n     principal_trait_ref: ty::PolyTraitRef<'tcx>,\n     builtin_bounds: ty::BuiltinBounds)\n-    -> ty::Region\n+    -> Option<ty::Region> // if None, use the default\n {\n     let tcx = this.tcx();\n \n@@ -2061,11 +2079,11 @@ fn compute_object_lifetime_bound<'tcx>(\n     if !explicit_region_bounds.is_empty() {\n         // Explicitly specified region bound. Use that.\n         let r = explicit_region_bounds[0];\n-        return ast_region_to_region(tcx, r);\n+        return Some(ast_region_to_region(tcx, r));\n     }\n \n     if let Err(ErrorReported) = this.ensure_super_predicates(span,principal_trait_ref.def_id()) {\n-        return ty::ReStatic;\n+        return Some(ty::ReStatic);\n     }\n \n     // No explicit region bound specified. Therefore, examine trait\n@@ -2074,23 +2092,15 @@ fn compute_object_lifetime_bound<'tcx>(\n         object_region_bounds(tcx, &principal_trait_ref, builtin_bounds);\n \n     // If there are no derived region bounds, then report back that we\n-    // can find no region bound.\n+    // can find no region bound. The caller will use the default.\n     if derived_region_bounds.is_empty() {\n-        match rscope.object_lifetime_default(span) {\n-            Some(r) => { return r; }\n-            None => {\n-                span_err!(this.tcx().sess, span, E0228,\n-                          \"the lifetime bound for this object type cannot be deduced \\\n-                           from context; please supply an explicit bound\");\n-                return ty::ReStatic;\n-            }\n-        }\n+        return None;\n     }\n \n     // If any of the derived region bounds are 'static, that is always\n     // the best choice.\n     if derived_region_bounds.iter().any(|r| ty::ReStatic == *r) {\n-        return ty::ReStatic;\n+        return Some(ty::ReStatic);\n     }\n \n     // Determine whether there is exactly one unique region in the set\n@@ -2101,7 +2111,7 @@ fn compute_object_lifetime_bound<'tcx>(\n         span_err!(tcx.sess, span, E0227,\n                   \"ambiguous lifetime bound, explicit lifetime bound required\");\n     }\n-    return r;\n+    return Some(r);\n }\n \n pub struct PartitionedBounds<'a> {"}, {"sha": "05166fa6134cfdb6b3391c6850c9f98434b47061", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -1779,14 +1779,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        Some(self.base_object_lifetime_default(span))\n+    }\n+\n+    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n         // RFC #599 specifies that object lifetime defaults take\n         // precedence over other defaults. But within a fn body we\n         // don't have a *default* region, rather we use inference to\n         // find the *correct* region, which is strictly more general\n         // (and anyway, within a fn body the right region may not even\n         // be something the user can write explicitly, since it might\n         // be some expression).\n-        Some(self.infcx().next_region_var(infer::MiscVariable(span)))\n+        self.infcx().next_region_var(infer::MiscVariable(span))\n     }\n \n     fn anon_regions(&self, span: Span, count: usize)"}, {"sha": "e170808ad07d679fc7da428fc279ed424b68bb00", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -1532,8 +1532,7 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let object_lifetime_default_reprs: String =\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n-                                     Some(ty::ObjectLifetimeDefault::Specific(r)) =>\n-                                         r.to_string(),\n+                                     ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n                                      d => format!(\"{:?}\", d),\n                                  })\n                                  .collect::<Vec<String>>()\n@@ -1637,7 +1636,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         name: special_idents::type_self.name,\n         def_id: local_def(param_id),\n         default: None,\n-        object_lifetime_default: None,\n+        object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n     };\n \n     ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n@@ -1928,19 +1927,20 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                             param_id: ast::NodeId,\n                                             param_bounds: &[ast::TyParamBound],\n                                             where_clause: &ast::WhereClause)\n-                                            -> Option<ty::ObjectLifetimeDefault>\n+                                            -> ty::ObjectLifetimeDefault\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n     let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n     let all_bounds: HashSet<_> = inline_bounds.into_iter()\n                                               .chain(where_bounds)\n                                               .collect();\n     return if all_bounds.len() > 1 {\n-        Some(ty::ObjectLifetimeDefault::Ambiguous)\n+        ty::ObjectLifetimeDefault::Ambiguous\n+    } else if all_bounds.len() == 0 {\n+        ty::ObjectLifetimeDefault::BaseDefault\n     } else {\n-        all_bounds.into_iter()\n-                  .next()\n-                  .map(ty::ObjectLifetimeDefault::Specific)\n+        ty::ObjectLifetimeDefault::Specific(\n+            all_bounds.into_iter().next().unwrap())\n     };\n \n     fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,"}, {"sha": "d2c982b3099e7d93593c9273a1ed1b0a530f4439", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 98, "deletions": 18, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -45,6 +45,26 @@ pub trait RegionScope {\n     /// be derived from the object traits, what should we use? If\n     /// `None` is returned, an explicit annotation is required.\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region>;\n+\n+    /// The \"base\" default is the initial default for a scope. This is\n+    /// 'static except for in fn bodies, where it is a fresh inference\n+    /// variable. You shouldn't call this except for as part of\n+    /// computing `object_lifetime_default` (in particular, in legacy\n+    /// modes, it may not be relevant).\n+    fn base_object_lifetime_default(&self, span: Span) -> ty::Region;\n+\n+    /// Used to issue warnings in Rust 1.2, not needed after that.\n+    /// True if the result of `object_lifetime_default` will change in 1.3.\n+    fn object_lifetime_default_will_change_in_1_3(&self) -> bool {\n+        false\n+    }\n+\n+    /// Used to issue warnings in Rust 1.2, not needed after that.\n+    /// True if the result of `base_object_lifetime_default` differs\n+    /// from the result of `object_lifetime_default`.\n+    fn base_object_lifetime_default_differs(&self) -> bool {\n+        false\n+    }\n }\n \n // A scope in which all regions must be explicitly named. This is used\n@@ -53,16 +73,20 @@ pub trait RegionScope {\n pub struct ExplicitRscope;\n \n impl RegionScope for ExplicitRscope {\n-    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n-        Some(ty::ReStatic)\n-    }\n-\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: usize)\n                     -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         Err(None)\n     }\n+\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        Some(self.base_object_lifetime_default(span))\n+    }\n+\n+    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n+        ty::ReStatic\n+    }\n }\n \n // Same as `ExplicitRscope`, but provides some extra information for diagnostics\n@@ -75,17 +99,21 @@ impl UnelidableRscope {\n }\n \n impl RegionScope for UnelidableRscope {\n-    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n-        Some(ty::ReStatic)\n-    }\n-\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: usize)\n                     -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         let UnelidableRscope(ref v) = *self;\n         Err(v.clone())\n     }\n+\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        Some(self.base_object_lifetime_default(span))\n+    }\n+\n+    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n+        ty::ReStatic\n+    }\n }\n \n // A scope in which omitted anonymous region defaults to\n@@ -103,11 +131,15 @@ impl ElidableRscope {\n }\n \n impl RegionScope for ElidableRscope {\n-    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         // Per RFC #599, object-lifetimes default to 'static unless\n         // overridden by context, and this takes precedence over\n         // lifetime elision.\n-        Some(ty::ReStatic)\n+        Some(self.base_object_lifetime_default(span))\n+    }\n+\n+    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n+        ty::ReStatic\n     }\n \n     fn anon_regions(&self,\n@@ -140,11 +172,15 @@ impl BindingRscope {\n }\n \n impl RegionScope for BindingRscope {\n-    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         // Per RFC #599, object-lifetimes default to 'static unless\n         // overridden by context, and this takes precedence over the\n-        // binding defaults.\n-        Some(ty::ReStatic)\n+        // binding defaults in a fn signature.\n+        Some(self.base_object_lifetime_default(span))\n+    }\n+\n+    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n+        ty::ReStatic\n     }\n \n     fn anon_regions(&self,\n@@ -159,12 +195,12 @@ impl RegionScope for BindingRscope {\n /// A scope which overrides the default object lifetime but has no other effect.\n pub struct ObjectLifetimeDefaultRscope<'r> {\n     base_scope: &'r (RegionScope+'r),\n-    default: Option<ty::ObjectLifetimeDefault>,\n+    default: ty::ObjectLifetimeDefault,\n }\n \n impl<'r> ObjectLifetimeDefaultRscope<'r> {\n     pub fn new(base_scope: &'r (RegionScope+'r),\n-               default: Option<ty::ObjectLifetimeDefault>)\n+               default: ty::ObjectLifetimeDefault)\n                -> ObjectLifetimeDefaultRscope<'r>\n     {\n         ObjectLifetimeDefaultRscope {\n@@ -177,9 +213,49 @@ impl<'r> ObjectLifetimeDefaultRscope<'r> {\n impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         match self.default {\n-            None => self.base_scope.object_lifetime_default(span),\n-            Some(ty::ObjectLifetimeDefault::Ambiguous) => None,\n-            Some(ty::ObjectLifetimeDefault::Specific(r)) => Some(r),\n+            ty::ObjectLifetimeDefault::Ambiguous =>\n+                None,\n+\n+            ty::ObjectLifetimeDefault::BaseDefault =>\n+                if false { // this will become the behavior in Rust 1.3\n+                    Some(self.base_object_lifetime_default(span))\n+                } else {\n+                    self.base_scope.object_lifetime_default(span)\n+                },\n+\n+            ty::ObjectLifetimeDefault::Specific(r) =>\n+                Some(r),\n+        }\n+    }\n+\n+    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n+        assert!(false, \"this code should not execute until Rust 1.3\");\n+        self.base_scope.base_object_lifetime_default(span)\n+    }\n+\n+    fn object_lifetime_default_will_change_in_1_3(&self) -> bool {\n+        debug!(\"object_lifetime_default_will_change_in_1_3: {:?}\", self.default);\n+\n+        match self.default {\n+            ty::ObjectLifetimeDefault::Ambiguous |\n+            ty::ObjectLifetimeDefault::Specific(_) =>\n+                false,\n+\n+            ty::ObjectLifetimeDefault::BaseDefault =>\n+                self.base_scope.base_object_lifetime_default_differs()\n+        }\n+    }\n+\n+    fn base_object_lifetime_default_differs(&self) -> bool {\n+        debug!(\"base_object_lifetime_default_differs: {:?}\", self.default);\n+\n+        match self.default {\n+            ty::ObjectLifetimeDefault::Ambiguous |\n+            ty::ObjectLifetimeDefault::Specific(_) =>\n+                true,\n+\n+            ty::ObjectLifetimeDefault::BaseDefault =>\n+                self.base_scope.base_object_lifetime_default_differs(),\n         }\n     }\n \n@@ -210,6 +286,10 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n             .map(|r| ty_fold::shift_region(r, 1))\n     }\n \n+    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n+        ty_fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n+    }\n+\n     fn anon_regions(&self,\n                     span: Span,\n                     count: usize)"}, {"sha": "95f8b39c48745670db95b4248af6eab597806c18", "filename": "src/test/auxiliary/lifetime_bound_will_change_warning_lib.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fauxiliary%2Flifetime_bound_will_change_warning_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fauxiliary%2Flifetime_bound_will_change_warning_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flifetime_bound_will_change_warning_lib.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+// Helper for testing that we get suitable warnings when lifetime\n+// bound change will cause breakage.\n+\n+pub fn just_ref(x: &Fn()) {\n+}\n+\n+pub fn ref_obj(x: &Box<Fn()>) {\n+    // this will change to &Box<Fn()+'static>...\n+}"}, {"sha": "1fca8eb6ac4f3272f49c4c7ef3ffa4c0cc69a206", "filename": "src/test/compile-fail/issue-24446.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     static foo: Fn() -> u32 = || -> u32 {\n         //~^ ERROR: mismatched types:\n-        //~| expected `core::ops::Fn() -> u32`,\n+        //~| expected `core::ops::Fn() -> u32 + 'static`,\n         //~| found closure\n         //~| (expected trait core::ops::Fn,\n         //~| found closure)"}, {"sha": "4b575703e7c7575672c0455f7d446b4e3d93ba16", "filename": "src/test/compile-fail/lifetime-bound-will-change-warning.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Flifetime-bound-will-change-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Flifetime-bound-will-change-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-bound-will-change-warning.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lifetime_bound_will_change_warning_lib.rs\n+\n+// Test that we get suitable warnings when lifetime bound change will\n+// cause breakage.\n+\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![feature(rustc_attrs)]\n+\n+extern crate lifetime_bound_will_change_warning_lib as lib;\n+\n+fn just_ref(x: &Fn()) {\n+}\n+\n+fn ref_obj(x: &Box<Fn()>) {\n+    // this will change to &Box<Fn()+'static>...\n+\n+    // Note: no warning is issued here, because the type of `x` will change to 'static\n+    if false { ref_obj(x); }\n+}\n+\n+fn test1<'a>(x: &'a Box<Fn()+'a>) {\n+    // just_ref will stay the same.\n+    just_ref(&**x)\n+}\n+\n+fn test1cc<'a>(x: &'a Box<Fn()+'a>) {\n+    // same as test1, but cross-crate\n+    lib::just_ref(&**x)\n+}\n+\n+fn test2<'a>(x: &'a Box<Fn()+'a>) {\n+    // but ref_obj will not, so warn.\n+    ref_obj(x) //~ WARNING this code may fail to compile in Rust 1.3\n+}\n+\n+fn test2cc<'a>(x: &'a Box<Fn()+'a>) {\n+    // same as test2, but cross crate\n+    lib::ref_obj(x) //~ WARNING this code may fail to compile in Rust 1.3\n+}\n+\n+fn test3<'a>(x: &'a Box<Fn()+'static>) {\n+    // here, we have a 'static bound, so even when ref_obj changes, no error results\n+    ref_obj(x)\n+}\n+\n+fn test3cc<'a>(x: &'a Box<Fn()+'static>) {\n+    // same as test3, but cross crate\n+    lib::ref_obj(x)\n+}\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+}"}, {"sha": "b5c4e0c767b003fd06b05032ec3f0f270a1984db", "filename": "src/test/compile-fail/object-lifetime-default-mybox.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -39,5 +39,9 @@ fn load1<'a,'b>(a: &'a MyBox<SomeTrait>,\n       //~| ERROR mismatched types\n }\n \n+fn load2<'a>(ss: &MyBox<SomeTrait+'a>) -> MyBox<SomeTrait+'a> {\n+    load0(ss) //~ WARNING E0398\n+}\n+\n fn main() {\n }"}, {"sha": "104e10f3207dbd24de32e26d540a778dd2d55912", "filename": "src/test/compile-fail/object-lifetime-default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -11,10 +11,10 @@\n #![feature(rustc_attrs)]\n \n #[rustc_object_lifetime_default]\n-struct A<T>(T); //~ ERROR None\n+struct A<T>(T); //~ ERROR BaseDefault\n \n #[rustc_object_lifetime_default]\n-struct B<'a,T>(&'a (), T); //~ ERROR None\n+struct B<'a,T>(&'a (), T); //~ ERROR BaseDefault\n \n #[rustc_object_lifetime_default]\n struct C<'a,T:'a>(&'a T); //~ ERROR 'a\n@@ -29,6 +29,6 @@ struct E<'a,'b:'a,T:'b>(&'a T, &'b T); //~ ERROR 'b\n struct F<'a,'b,T:'a,U:'b>(&'a T, &'b U); //~ ERROR 'a,'b\n \n #[rustc_object_lifetime_default]\n-struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U); //~ ERROR 'a,Some(Ambiguous)\n+struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U); //~ ERROR 'a,Ambiguous\n \n fn main() { }"}, {"sha": "836f08d0e78bb21d2fe2fcf5786f6f9cca1d7acf", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -22,8 +22,8 @@ fn c(x: Box<Foo+Sync+Send>) {\n \n fn d(x: Box<Foo>) {\n     a(x); //~  ERROR mismatched types\n-          //~| expected `Box<Foo + Send>`\n-          //~| found `Box<Foo>`\n+          //~| expected `Box<Foo + Send + 'static>`\n+          //~| found `Box<Foo + 'static>`\n           //~| expected bounds `Send`\n           //~| found no bounds\n }"}, {"sha": "5fe3434e499e12a7f14fda13296795dda0fb433a", "filename": "src/test/run-pass/issue-21058.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c952b5b796828a9a774c2249e7d08056393464/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21058.rs?ref=50c952b5b796828a9a774c2249e7d08056393464", "patch": "@@ -26,5 +26,5 @@ fn main() {\n         std::intrinsics::type_name::<NT>(),\n         // DST\n         std::intrinsics::type_name::<DST>()\n-    )}, (\"[u8]\", \"str\", \"core::marker::Copy\", \"NT\", \"DST\"));\n+    )}, (\"[u8]\", \"str\", \"core::marker::Copy + 'static\", \"NT\", \"DST\"));\n }"}]}