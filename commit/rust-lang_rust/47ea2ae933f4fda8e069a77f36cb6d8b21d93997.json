{"sha": "47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZWEyYWU5MzNmNGZkYThlMDY5YTc3ZjM2Y2I2ZDhiMjFkOTM5OTc=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-24T19:02:09Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-15T17:31:46Z"}, "message": "Separate encoding paths.\n\nThe two paths will be modified independently in the next few commits.", "tree": {"sha": "b0b08cdbf6af3833928679c29d501ab15b17d3dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0b08cdbf6af3833928679c29d501ab15b17d3dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "html_url": "https://github.com/rust-lang/rust/commit/47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a6c636c40540707cdfd542866998862e8aa72e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6c636c40540707cdfd542866998862e8aa72e8", "html_url": "https://github.com/rust-lang/rust/commit/0a6c636c40540707cdfd542866998862e8aa72e8"}], "stats": {"total": 213, "additions": 116, "deletions": 97}, "files": [{"sha": "d39ac588026b05841f18b54c83cc14a825a3f452", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "patch": "@@ -30,7 +30,6 @@ use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt, Visibility};\n use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::Session;\n-use rustc_span::hygiene::ExpnDataDecodeMode;\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, hygiene::MacroKind, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n@@ -381,33 +380,29 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n             }\n         };\n \n-        rustc_span::hygiene::decode_expn_id(\n-            decoder,\n-            ExpnDataDecodeMode::Metadata(get_ctxt),\n-            |_this, index| {\n-                let cnum = expn_cnum.get().unwrap();\n-                // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n-                // are stored in the owning crate, to avoid duplication.\n-                let crate_data = if cnum == LOCAL_CRATE {\n-                    local_cdata\n-                } else {\n-                    local_cdata.cstore.get_crate_data(cnum)\n-                };\n-                let expn_data = crate_data\n-                    .root\n-                    .expn_data\n-                    .get(&crate_data, index)\n-                    .unwrap()\n-                    .decode((&crate_data, sess));\n-                let expn_hash = crate_data\n-                    .root\n-                    .expn_hashes\n-                    .get(&crate_data, index)\n-                    .unwrap()\n-                    .decode((&crate_data, sess));\n-                Ok((expn_data, expn_hash))\n-            },\n-        )\n+        rustc_span::hygiene::decode_expn_id(decoder, get_ctxt, |_this, index| {\n+            let cnum = expn_cnum.get().unwrap();\n+            // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n+            // are stored in the owning crate, to avoid duplication.\n+            let crate_data = if cnum == LOCAL_CRATE {\n+                local_cdata\n+            } else {\n+                local_cdata.cstore.get_crate_data(cnum)\n+            };\n+            let expn_data = crate_data\n+                .root\n+                .expn_data\n+                .get(&crate_data, index)\n+                .unwrap()\n+                .decode((&crate_data, sess));\n+            let expn_hash = crate_data\n+                .root\n+                .expn_hashes\n+                .get(&crate_data, index)\n+                .unwrap()\n+                .decode((&crate_data, sess));\n+            Ok((expn_data, expn_hash))\n+        })\n     }\n }\n "}, {"sha": "ba6d2d74aa7ff92fc8b303d4414da561ea187a8b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "patch": "@@ -31,7 +31,7 @@ use rustc_session::config::CrateType;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span, SyntaxContext};\n use rustc_span::{\n-    hygiene::{ExpnDataEncodeMode, HygieneEncodeContext, MacroKind},\n+    hygiene::{HygieneEncodeContext, MacroKind},\n     RealFileName,\n };\n use rustc_target::abi::VariantIdx;\n@@ -176,12 +176,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        rustc_span::hygiene::raw_encode_expn_id(\n-            *self,\n-            &s.hygiene_ctxt,\n-            ExpnDataEncodeMode::Metadata,\n-            s,\n-        )\n+        rustc_span::hygiene::raw_encode_expn_id(*self, &s.hygiene_ctxt, s)\n     }\n }\n "}, {"sha": "85e84d6a0f487717733e042506bf451ece530c4a", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "patch": "@@ -20,8 +20,7 @@ use rustc_serialize::{\n };\n use rustc_session::Session;\n use rustc_span::hygiene::{\n-    ExpnDataDecodeMode, ExpnDataEncodeMode, ExpnId, HygieneDecodeContext, HygieneEncodeContext,\n-    SyntaxContext, SyntaxContextData,\n+    ExpnId, HygieneDecodeContext, HygieneEncodeContext, SyntaxContext, SyntaxContextData,\n };\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n@@ -793,9 +792,9 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for SyntaxContext {\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n     fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         let expn_data = decoder.expn_data;\n-        rustc_span::hygiene::decode_expn_id(\n+        rustc_span::hygiene::decode_expn_id_incrcomp(\n             decoder,\n-            ExpnDataDecodeMode::incr_comp(decoder.hygiene_context),\n+            decoder.hygiene_context,\n             |this, index| {\n                 // This closure is invoked if we haven't already decoded the data for the `ExpnId` we are deserializing.\n                 // We look up the position of the associated `ExpnData` and decode it.\n@@ -983,12 +982,7 @@ where\n     E: 'a + OpaqueEncoder,\n {\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n-        rustc_span::hygiene::raw_encode_expn_id(\n-            *self,\n-            s.hygiene_context,\n-            ExpnDataEncodeMode::IncrComp,\n-            s,\n-        )\n+        rustc_span::hygiene::raw_encode_expn_id_incrcomp(*self, s.hygiene_context, s)\n     }\n }\n "}, {"sha": "ddf9e7b4255c6841bd6d7568a5e92aeb1fb035b1", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 87, "deletions": 52, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ea2ae933f4fda8e069a77f36cb6d8b21d93997/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "patch": "@@ -1076,22 +1076,74 @@ pub struct HygieneDecodeContext {\n     remapped_expns: Lock<Vec<Option<ExpnId>>>,\n }\n \n-pub fn decode_expn_id<'a, D: Decoder, G>(\n+pub fn decode_expn_id_incrcomp<D: Decoder>(\n     d: &mut D,\n-    mode: ExpnDataDecodeMode<'a, G>,\n+    context: &HygieneDecodeContext,\n     decode_data: impl FnOnce(&mut D, u32) -> Result<(ExpnData, ExpnHash), D::Error>,\n-) -> Result<ExpnId, D::Error>\n-where\n-    G: FnOnce(CrateNum) -> &'a HygieneDecodeContext,\n-{\n+) -> Result<ExpnId, D::Error> {\n     let index = u32::decode(d)?;\n-    let context = match mode {\n-        ExpnDataDecodeMode::IncrComp(context) => context,\n-        ExpnDataDecodeMode::Metadata(get_context) => {\n-            let krate = CrateNum::decode(d)?;\n-            get_context(krate)\n+\n+    // Do this after decoding, so that we decode a `CrateNum`\n+    // if necessary\n+    if index == ExpnId::root().as_u32() {\n+        debug!(\"decode_expn_id: deserialized root\");\n+        return Ok(ExpnId::root());\n+    }\n+\n+    let outer_expns = &context.remapped_expns;\n+\n+    // Ensure that the lock() temporary is dropped early\n+    {\n+        if let Some(expn_id) = outer_expns.lock().get(index as usize).copied().flatten() {\n+            return Ok(expn_id);\n         }\n-    };\n+    }\n+\n+    // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n+    // other ExpnIds\n+    let (mut expn_data, hash) = decode_data(d, index)?;\n+\n+    let expn_id = HygieneData::with(|hygiene_data| {\n+        if let Some(&expn_id) = hygiene_data.expn_hash_to_expn_id.get(&hash) {\n+            return expn_id;\n+        }\n+\n+        let expn_id = ExpnId(hygiene_data.expn_data.len() as u32);\n+\n+        // If we just deserialized an `ExpnData` owned by\n+        // the local crate, its `orig_id` will be stale,\n+        // so we need to update it to its own value.\n+        // This only happens when we deserialize the incremental cache,\n+        // since a crate will never decode its own metadata.\n+        if expn_data.krate == LOCAL_CRATE {\n+            expn_data.orig_id = Some(expn_id.0);\n+        }\n+\n+        hygiene_data.expn_data.push(Some(expn_data));\n+        hygiene_data.expn_hashes.push(hash);\n+        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n+        debug_assert!(_old_id.is_none());\n+\n+        let mut expns = outer_expns.lock();\n+        let new_len = index as usize + 1;\n+        if expns.len() < new_len {\n+            expns.resize(new_len, None);\n+        }\n+        expns[index as usize] = Some(expn_id);\n+        drop(expns);\n+        expn_id\n+    });\n+    Ok(expn_id)\n+}\n+\n+pub fn decode_expn_id<'a, D: Decoder>(\n+    d: &mut D,\n+    get_context: impl FnOnce(CrateNum) -> &'a HygieneDecodeContext,\n+    decode_data: impl FnOnce(&mut D, u32) -> Result<(ExpnData, ExpnHash), D::Error>,\n+) -> Result<ExpnId, D::Error> {\n+    let index = u32::decode(d)?;\n+    let krate = CrateNum::decode(d)?;\n+    let context = get_context(krate);\n \n     // Do this after decoding, so that we decode a `CrateNum`\n     // if necessary\n@@ -1274,56 +1326,39 @@ pub fn raw_encode_syntax_context<E: Encoder>(\n     ctxt.0.encode(e)\n }\n \n-pub fn raw_encode_expn_id<E: Encoder>(\n+pub fn raw_encode_expn_id_incrcomp<E: Encoder>(\n     expn: ExpnId,\n     context: &HygieneEncodeContext,\n-    mode: ExpnDataEncodeMode,\n     e: &mut E,\n ) -> Result<(), E::Error> {\n     // Record the fact that we need to serialize the corresponding\n     // `ExpnData`\n-    let needs_data = || {\n-        if !context.serialized_expns.lock().contains(&expn) {\n-            context.latest_expns.lock().insert(expn);\n-        }\n-    };\n-\n-    match mode {\n-        ExpnDataEncodeMode::IncrComp => {\n-            // Always serialize the `ExpnData` in incr comp mode\n-            needs_data();\n-            expn.0.encode(e)\n-        }\n-        ExpnDataEncodeMode::Metadata => {\n-            let data = expn.expn_data();\n-            // We only need to serialize the ExpnData\n-            // if it comes from this crate.\n-            // We currently don't serialize any hygiene information data for\n-            // proc-macro crates: see the `SpecializedEncoder<Span>` impl\n-            // for crate metadata.\n-            if data.krate == LOCAL_CRATE {\n-                needs_data();\n-            }\n-            data.orig_id.expect(\"Missing orig_id\").encode(e)?;\n-            data.krate.encode(e)\n-        }\n+    if !context.serialized_expns.lock().contains(&expn) {\n+        context.latest_expns.lock().insert(expn);\n     }\n+    expn.0.encode(e)\n }\n \n-pub enum ExpnDataEncodeMode {\n-    IncrComp,\n-    Metadata,\n-}\n-\n-pub enum ExpnDataDecodeMode<'a, F: FnOnce(CrateNum) -> &'a HygieneDecodeContext> {\n-    IncrComp(&'a HygieneDecodeContext),\n-    Metadata(F),\n-}\n-\n-impl<'a> ExpnDataDecodeMode<'a, Box<dyn FnOnce(CrateNum) -> &'a HygieneDecodeContext>> {\n-    pub fn incr_comp(ctxt: &'a HygieneDecodeContext) -> Self {\n-        ExpnDataDecodeMode::IncrComp(ctxt)\n+pub fn raw_encode_expn_id<E: Encoder>(\n+    expn: ExpnId,\n+    context: &HygieneEncodeContext,\n+    e: &mut E,\n+) -> Result<(), E::Error> {\n+    let data = expn.expn_data();\n+    // We only need to serialize the ExpnData\n+    // if it comes from this crate.\n+    // We currently don't serialize any hygiene information data for\n+    // proc-macro crates: see the `SpecializedEncoder<Span>` impl\n+    // for crate metadata.\n+    if data.krate == LOCAL_CRATE {\n+        // Record the fact that we need to serialize the corresponding\n+        // `ExpnData`\n+        if !context.serialized_expns.lock().contains(&expn) {\n+            context.latest_expns.lock().insert(expn);\n+        }\n     }\n+    data.orig_id.expect(\"Missing orig_id\").encode(e)?;\n+    data.krate.encode(e)\n }\n \n impl<E: Encoder> Encodable<E> for SyntaxContext {"}]}