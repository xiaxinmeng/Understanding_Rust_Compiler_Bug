{"sha": "9eb8d1179c220e44b3eec9edb69e1fbd04988538", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjhkMTE3OWMyMjBlNDRiM2VlYzllZGI2OWUxZmJkMDQ5ODg1Mzg=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-14T13:44:45Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-23T12:18:27Z"}, "message": "Improve borrow errors for closures.\n\nAdds improved messages for closures where returned type\ndoes not match the inferred return lifetime of the closure.", "tree": {"sha": "b5ec0cb5685f980cf0d0ebd230caeb2fb97d1d9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5ec0cb5685f980cf0d0ebd230caeb2fb97d1d9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb8d1179c220e44b3eec9edb69e1fbd04988538", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlunhJMACgkQAXYLT59T\n8VSzuQ/9GI3Bf6g83zdTbi9BBPb2DSv2MBLiFIoEukprUmr9EjhW29grRZFxY60c\nIp68CrjnxjLOgo4htI2TBnyW34LH4xaU1PeYlJR8yVoHrNWMar7ipsqnkpmHvyJ1\nLkaLMTIQSUk+tVtqXgUh0+4+yNBEOXuPNefbmfCVTlnXHNzp6uVrJ39Z2qEmKEdX\nkAZlOiW4iNI5AdUGcm/C8kYef09UwG8HIeZF12Cd3MoNljLPzypNa/IkwxSTONLZ\n5E0Jz5rbExqgBVTCTpvI4C4LSMpWP3JaPjhoaFPAvz4DJYlE3ADFCimAkev1e4rv\n2qxcociy0euvnFbs1eTGkjHlR+qKhARedbzjElKEfuOdZiP7hU5DdgGFst7t45rP\nuCkvrdin4nzssCqw0UIbwCT5sDn5jq2Cg6bWncTPlufj2f25Z5rSvbqRMoj1Tf2F\nJXQ1oMAy+0DQnjxf5U1PYLhPDt1Y7mfTYjreHmsSkHfupdrZ9yMQtF7dqFZTG6l8\nR6SymqYmQ/H9U4CMKe0HmswKykCIpAqilzSFkkZQoBSwXZ+U1zGGgRKtHTnKlcHC\nwUBXkNpsnYQJ9IuAWutqzUCZkKt4fEit/o0nq1ZjGWUP7pFr1BqQ+ALK4Vz++9vV\nNaN5/upRsC2461MaUmRWYFteeDIHVL8qGaXUFCymlpoai6QgiaA=\n=LnK3\n-----END PGP SIGNATURE-----", "payload": "tree b5ec0cb5685f980cf0d0ebd230caeb2fb97d1d9c\nparent 22e49e248df2dcaa0b6225a8f279292930af9c00\nauthor David Wood <david@davidtw.co> 1536932685 +0200\ncommitter David Wood <david@davidtw.co> 1537705107 +0200\n\nImprove borrow errors for closures.\n\nAdds improved messages for closures where returned type\ndoes not match the inferred return lifetime of the closure.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb8d1179c220e44b3eec9edb69e1fbd04988538", "html_url": "https://github.com/rust-lang/rust/commit/9eb8d1179c220e44b3eec9edb69e1fbd04988538", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb8d1179c220e44b3eec9edb69e1fbd04988538/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22e49e248df2dcaa0b6225a8f279292930af9c00", "url": "https://api.github.com/repos/rust-lang/rust/commits/22e49e248df2dcaa0b6225a8f279292930af9c00", "html_url": "https://github.com/rust-lang/rust/commit/22e49e248df2dcaa0b6225a8f279292930af9c00"}], "stats": {"total": 591, "additions": 438, "deletions": 153}, "files": [{"sha": "cae8e96acfc4f78d279ecce8c823838037e67ac3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -34,7 +34,13 @@ use hir;\n thread_local! {\n     /// Mechanism for highlighting of specific regions for display in NLL region inference errors.\n     /// Contains region to highlight and counter for number to use when highlighting.\n-    static HIGHLIGHT_REGION: Cell<Option<(RegionVid, usize)>> = Cell::new(None)\n+    static HIGHLIGHT_REGION_FOR_REGIONVID: Cell<Option<(RegionVid, usize)>> = Cell::new(None)\n+}\n+\n+thread_local! {\n+    /// Mechanism for highlighting of specific regions for display in NLL's 'borrow does not live\n+    /// long enough' errors. Contains a region to highlight and a counter to use.\n+    static HIGHLIGHT_REGION_FOR_REGION: Cell<Option<(ty::BoundRegion, usize)>> = Cell::new(None)\n }\n \n macro_rules! gen_display_debug_body {\n@@ -564,12 +570,34 @@ pub fn parameterized<F: fmt::Write>(f: &mut F,\n     PrintContext::new().parameterized(f, substs, did, projections)\n }\n \n-fn get_highlight_region() -> Option<(RegionVid, usize)> {\n-    HIGHLIGHT_REGION.with(|hr| hr.get())\n+fn get_highlight_region_for_regionvid() -> Option<(RegionVid, usize)> {\n+    HIGHLIGHT_REGION_FOR_REGIONVID.with(|hr| hr.get())\n }\n \n-pub fn with_highlight_region<R>(r: RegionVid, counter: usize, op: impl FnOnce() -> R) -> R {\n-    HIGHLIGHT_REGION.with(|hr| {\n+pub fn with_highlight_region_for_regionvid<R>(\n+    r: RegionVid,\n+    counter: usize,\n+    op: impl FnOnce() -> R\n+) -> R {\n+    HIGHLIGHT_REGION_FOR_REGIONVID.with(|hr| {\n+        assert_eq!(hr.get(), None);\n+        hr.set(Some((r, counter)));\n+        let r = op();\n+        hr.set(None);\n+        r\n+    })\n+}\n+\n+fn get_highlight_region_for_region() -> Option<(ty::BoundRegion, usize)> {\n+    HIGHLIGHT_REGION_FOR_REGION.with(|hr| hr.get())\n+}\n+\n+pub fn with_highlight_region_for_region<R>(\n+    r: ty::BoundRegion,\n+    counter: usize,\n+    op: impl Fn() -> R\n+) -> R {\n+    HIGHLIGHT_REGION_FOR_REGION.with(|hr| {\n         assert_eq!(hr.get(), None);\n         hr.set(Some((r, counter)));\n         let r = op();\n@@ -726,6 +754,15 @@ define_print! {\n                 return self.print_debug(f, cx);\n             }\n \n+            if let Some((region, counter)) = get_highlight_region_for_region() {\n+                if *self == region {\n+                    return match *self {\n+                        BrNamed(_, name) => write!(f, \"{}\", name),\n+                        BrAnon(_) | BrFresh(_) | BrEnv => write!(f, \"'{}\", counter)\n+                    };\n+                }\n+            }\n+\n             match *self {\n                 BrNamed(_, name) => write!(f, \"{}\", name),\n                 BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n@@ -748,7 +785,7 @@ define_print! {\n define_print! {\n     () ty::RegionKind, (self, f, cx) {\n         display {\n-            if cx.is_verbose || get_highlight_region().is_some() {\n+            if cx.is_verbose || get_highlight_region_for_regionvid().is_some() {\n                 return self.print_debug(f, cx);\n             }\n \n@@ -923,7 +960,7 @@ impl fmt::Debug for ty::FloatVid {\n \n impl fmt::Debug for ty::RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some((region, counter)) = get_highlight_region() {\n+        if let Some((region, counter)) = get_highlight_region_for_regionvid() {\n             debug!(\"RegionVid.fmt: region={:?} self={:?} counter={:?}\", region, self, counter);\n             return if *self == region {\n                 write!(f, \"'{:?}\", counter)"}, {"sha": "600d052cafb737a980731c7846e14a2923cdcc73", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 238, "deletions": 105, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -13,16 +13,16 @@ use borrow_check::prefixes::IsPrefixOf;\n use borrow_check::nll::explain_borrow::BorrowExplanation;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n-    BindingForm, BorrowKind, ClearCrossCrate, Field, FakeReadCause, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place,\n-    ProjectionElem, Rvalue, Statement, StatementKind,\n-    VarBindingForm,\n+    AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, FakeReadCause, Field, Local,\n+    LocalDecl, LocalKind, Location, Operand, Place, ProjectionElem, Rvalue, Statement,\n+    StatementKind, VarBindingForm,\n };\n+use rustc::hir::def_id::DefId;\n use rustc::ty;\n-use rustc::hir;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc::util::ppaux::with_highlight_region_for_region;\n use syntax_pos::Span;\n \n use super::borrow_set::BorrowData;\n@@ -462,7 +462,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        let mut err = match &self.describe_place(&borrow.borrowed_place) {\n+        let err = match &self.describe_place(&borrow.borrowed_place) {\n             Some(_) if self.is_place_thread_local(root_place) =>\n                 self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span),\n             Some(name) => self.report_local_value_does_not_live_long_enough(\n@@ -471,20 +471,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 &scope_tree,\n                 &borrow,\n                 drop_span,\n-                borrow_span,\n+                borrow_spans,\n                 kind.map(|k| (k, place_span.0)),\n             ),\n             None => self.report_temporary_value_does_not_live_long_enough(\n                 context,\n                 &scope_tree,\n                 &borrow,\n                 drop_span,\n+                borrow_spans,\n                 proper_span,\n             ),\n         };\n \n-        borrow_spans.args_span_label(&mut err, \"value captured here\");\n-\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -495,63 +494,41 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrow_span: Span,\n+        borrow_spans: UseSpans,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, name, scope_tree, borrow, drop_span, borrow_span\n+            context, name, scope_tree, borrow, drop_span, borrow_spans\n         );\n \n+        let borrow_span = borrow_spans.var_or_use();\n         let mut err = self.infcx.tcx.path_does_not_live_long_enough(\n             borrow_span,\n             &format!(\"`{}`\", name),\n             Origin::Mir,\n         );\n \n         let explanation = self.explain_why_borrow_contains_point(context, borrow, kind_place);\n-        if let Some((\n-            arg_name,\n-            arg_span,\n-            return_name,\n-            return_span,\n-        )) = self.find_name_and_ty_of_values() {\n-            err.span_label(\n-                arg_span,\n-                format!(\"has lifetime `{}`\", arg_name)\n-            );\n-\n-            err.span_label(\n-                return_span,\n-                format!(\n-                    \"{}has lifetime `{}`\",\n-                    if arg_name == return_name { \"also \" } else { \"\" },\n-                    return_name\n-                )\n-            );\n+        if let Some(annotation) = self.annotate_argument_and_return_for_borrow(borrow) {\n+            let region_name = annotation.emit(&mut err);\n \n             err.span_label(\n                 borrow_span,\n-                format!(\"`{}` would have to be valid for `{}`\", name, return_name),\n-            );\n-\n-            err.span_label(\n-                drop_span,\n-                format!(\"but `{}` dropped here while still borrowed\", name),\n+                format!(\"`{}` would have to be valid for `{}`\", name, region_name)\n             );\n+            err.span_label(drop_span, format!(\"but `{}` dropped here while still borrowed\", name));\n \n             if let BorrowExplanation::MustBeValidFor(..) = explanation { } else {\n                 explanation.emit(self.infcx.tcx, &mut err);\n             }\n         } else {\n             err.span_label(borrow_span, \"borrowed value does not live long enough\");\n+            err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n \n-            err.span_label(\n-                drop_span,\n-                format!(\"`{}` dropped here while still borrowed\", name),\n-            );\n+            borrow_spans.args_span_label(&mut err, \"value captured here\");\n \n             explanation.emit(self.infcx.tcx, &mut err);\n         }\n@@ -576,19 +553,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        let mut err = self.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n+        let mut err = self.infcx.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n \n         let (what_was_dropped, dropped_ty) = {\n             let desc = match self.describe_place(place) {\n                 Some(name) => format!(\"`{}`\", name.as_str()),\n                 None => format!(\"temporary value\"),\n             };\n-            let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n             (desc, ty)\n         };\n \n         let label = match dropped_ty.sty {\n-            ty::Adt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() => {\n+            ty::Adt(adt, _) if adt.has_dtor(self.infcx.tcx) && !adt.is_box() => {\n                 match self.describe_place(&borrow.borrowed_place) {\n                     Some(borrowed) =>\n                         format!(\"here, drop of {D} needs exclusive access to `{B}`, \\\n@@ -615,7 +592,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => {},\n         }\n \n-        explanation.emit(self.tcx, &mut err);\n+        explanation.emit(self.infcx.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -651,6 +628,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n+        borrow_spans: UseSpans,\n         proper_span: Span,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n@@ -678,67 +656,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n         explanation.emit(self.infcx.tcx, &mut err);\n \n-        err\n-    }\n-\n-    fn find_name_and_ty_of_values(\n-        &self,\n-    ) -> Option<(String, Span, String, Span)> {\n-        let mir_node_id = self.infcx.tcx.hir.as_local_node_id(self.mir_def_id)?;\n-        let fn_decl = self.infcx.tcx.hir.fn_decl(mir_node_id)?;\n-\n-        // If there is one argument and this error is being reported, that means\n-        // that the lifetime of the borrow could not be made to match the single\n-        // argument's lifetime. We can highlight it.\n-        //\n-        // If there is more than one argument and this error is being reported, that\n-        // means there must be a self parameter - as otherwise there would be an error\n-        // from lifetime elision and not this. So we highlight the self parameter.\n-        let arg = fn_decl.inputs\n-            .first()\n-            .and_then(|ty| {\n-                if let hir::TyKind::Rptr(\n-                    hir::Lifetime { name, span, ..  }, ..\n-                ) = ty.node {\n-                    Some((name, span))\n-                } else {\n-                    None\n-                }\n-            });\n-\n-        let ret = if let hir::FunctionRetTy::Return(ret_ty) = &fn_decl.output {\n-            if let hir::Ty {\n-                node: hir::TyKind::Rptr(hir::Lifetime { name, span, ..  }, ..),\n-                ..\n-            } = ret_ty.clone().into_inner() {\n-                Some((name, span))\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        };\n-\n-        let (arg_name, arg_span) = arg?;\n-        let (return_name, return_span) = ret?;\n-\n-        let lifetimes_match = arg_name == return_name;\n-\n-        let arg_name = if arg_name.is_elided() {\n-            \"'0\".to_string()\n-        } else {\n-            format!(\"{}\", arg_name.ident())\n-        };\n-\n-        let return_name = if return_name.is_elided() && lifetimes_match {\n-            \"'0\".to_string()\n-        } else if return_name.is_elided() {\n-            \"'1\".to_string()\n-        } else {\n-            format!(\"{}\", return_name.ident())\n-        };\n+        borrow_spans.args_span_label(&mut err, \"value captured here\");\n \n-        Some((arg_name, arg_span, return_name, return_span))\n+        err\n     }\n \n     fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveOutIndex> {\n@@ -1222,6 +1142,220 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             None\n         }\n     }\n+\n+    /// Annotate argument and return type of function and closure with (synthesized) lifetime for\n+    /// borrow of local value that does not live long enough.\n+    fn annotate_argument_and_return_for_borrow(\n+        &self,\n+        borrow: &BorrowData<'tcx>,\n+    ) -> Option<AnnotatedBorrowFnSignature> {\n+        // There are two cases that need handled: when a closure is involved and\n+        // when a closure is not involved.\n+        let location = borrow.reserve_location;\n+        let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n+\n+        match self.mir[location.block].statements.get(location.statement_index) {\n+            // When a closure is involved, we expect the reserve location to be an assignment\n+            // to a temporary local, which will be followed by a closure.\n+            Some(&Statement {\n+                kind: StatementKind::Assign(Place::Local(local), _),\n+                ..\n+            }) if self.mir.local_kind(local) == LocalKind::Temp => {\n+                // Look for the statements within this block after assigning to a local to see\n+                // if we have a closure. If we do, then annotate it.\n+                for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+                    if let StatementKind::Assign(\n+                        _,\n+                        Rvalue::Aggregate(\n+                            box AggregateKind::Closure(def_id, substs),\n+                            _\n+                        )\n+                    ) = stmt.kind {\n+                        return self.annotate_fn_sig(\n+                            def_id,\n+                            self.infcx.closure_sig(def_id, substs)\n+                        );\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // If this is not the case, then return if we're currently on a closure (as we\n+        // don't have a substs to get the PolyFnSig) or attempt to get the arguments\n+        // and return type of the function.\n+        if is_closure {\n+            None\n+        } else {\n+            let ty = self.infcx.tcx.type_of(self.mir_def_id);\n+            match ty.sty {\n+                ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) =>\n+                    self.annotate_fn_sig(\n+                        self.mir_def_id,\n+                        self.infcx.tcx.fn_sig(self.mir_def_id)\n+                    ),\n+                _ => None,\n+            }\n+        }\n+    }\n+\n+    /// Annotate the first argument and return type of a function signature if they are\n+    /// references.\n+    fn annotate_fn_sig(\n+        &self,\n+        did: DefId,\n+        sig: ty::PolyFnSig<'tcx>,\n+    ) -> Option<AnnotatedBorrowFnSignature> {\n+        let is_closure = self.infcx.tcx.is_closure(did);\n+        let fn_node_id = self.infcx.tcx.hir.as_local_node_id(did)?;\n+        let fn_decl = self.infcx.tcx.hir.fn_decl(fn_node_id)?;\n+\n+        // If there is one argument and this error is being reported, that means\n+        // that the lifetime of the borrow could not be made to match the single\n+        // argument's lifetime. We can highlight it.\n+        //\n+        // If there is more than one argument and this error is being reported, that\n+        // means there must be a self parameter - as otherwise there would be an error\n+        // from lifetime elision and not this. So we highlight the self parameter.\n+        let argument_span = fn_decl.inputs.first()?.span;\n+        let argument_ty = sig.inputs().skip_binder().first()?;\n+        if is_closure {\n+            // Closure arguments are wrapped in a tuple, so we need to get the first\n+            // from that.\n+            let argument_ty = if let ty::TyKind::Tuple(elems) = argument_ty.sty {\n+                let argument_ty = elems.first()?;\n+                if let ty::TyKind::Ref(_, _, _) = argument_ty.sty {\n+                    argument_ty\n+                } else {\n+                    return None;\n+                }\n+            } else {\n+                return None\n+            };\n+\n+            Some(AnnotatedBorrowFnSignature::Closure {\n+                argument_ty,\n+                argument_span,\n+            })\n+        } else if let ty::TyKind::Ref(argument_region, _, _) = argument_ty.sty {\n+            // We only consider the return type for functions.\n+            let return_span = fn_decl.output.span();\n+\n+            let return_ty = sig.output();\n+            let (return_region, return_ty) = if let ty::TyKind::Ref(\n+                return_region, _, _\n+            ) = return_ty.skip_binder().sty {\n+                (return_region, *return_ty.skip_binder())\n+            } else {\n+                return None;\n+            };\n+\n+            Some(AnnotatedBorrowFnSignature::Function {\n+                argument_ty,\n+                argument_span,\n+                return_ty,\n+                return_span,\n+                regions_equal: return_region == argument_region,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum AnnotatedBorrowFnSignature<'tcx> {\n+    Function {\n+        argument_ty: ty::Ty<'tcx>,\n+        argument_span: Span,\n+        return_ty: ty::Ty<'tcx>,\n+        return_span: Span,\n+        regions_equal: bool,\n+    },\n+    Closure {\n+        argument_ty: ty::Ty<'tcx>,\n+        argument_span: Span,\n+    }\n+}\n+\n+impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n+    fn emit(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'_>\n+    ) -> String {\n+        let (argument_ty, argument_span) = match self {\n+            AnnotatedBorrowFnSignature::Function {\n+                argument_ty,\n+                argument_span,\n+                ..\n+            } => (argument_ty, argument_span),\n+            AnnotatedBorrowFnSignature::Closure {\n+                argument_ty,\n+                argument_span,\n+            } => (argument_ty, argument_span),\n+        };\n+\n+        let (argument_region_name, argument_ty_name) = (\n+            self.get_region_name_for_ty(argument_ty, 0),\n+            self.get_name_for_ty(argument_ty, 0),\n+        );\n+        diag.span_label(\n+            *argument_span,\n+            format!(\"has type `{}`\", argument_ty_name)\n+        );\n+\n+        // Only emit labels for the return value when we're annotating a function.\n+        if let AnnotatedBorrowFnSignature::Function {\n+            return_ty,\n+            return_span,\n+            regions_equal,\n+            ..\n+        } = self {\n+            let counter = if *regions_equal { 0 } else { 1 };\n+            let (return_region_name, return_ty_name) = (\n+                self.get_region_name_for_ty(return_ty, counter),\n+                self.get_name_for_ty(return_ty, counter)\n+            );\n+\n+            let types_equal = return_ty_name == argument_ty_name;\n+            diag.span_label(\n+                *return_span,\n+                format!(\n+                    \"{}has type `{}`\",\n+                    if types_equal { \"also \" } else { \"\" },\n+                    return_ty_name,\n+                )\n+            );\n+\n+            return_region_name\n+        } else {\n+            argument_region_name\n+        }\n+    }\n+\n+    fn get_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n+        // We need to add synthesized lifetimes where appropriate. We do\n+        // this by hooking into the pretty printer and telling it to label the\n+        // lifetimes without names with the value `'0`.\n+        match ty.sty {\n+            ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _) |\n+            ty::TyKind::Ref(ty::RegionKind::ReSkolemized(_, br), _, _) =>\n+                with_highlight_region_for_region(*br, counter, || format!(\"{}\", ty)),\n+            _ => format!(\"{}\", ty),\n+        }\n+    }\n+\n+    fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n+        match ty.sty {\n+            ty::TyKind::Ref(region, _, _) => match region {\n+                ty::RegionKind::ReLateBound(_, br) |\n+                ty::RegionKind::ReSkolemized(_, br) =>\n+                    with_highlight_region_for_region(*br, counter, || format!(\"{}\", region)),\n+                _ => format!(\"{}\", region),\n+            }\n+            _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n+        }\n+    }\n }\n \n // The span(s) associated to a use of a place.\n@@ -1351,7 +1485,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n         use self::UseSpans::*;\n         use rustc::hir::ExprKind::Closure;\n-        use rustc::mir::AggregateKind;\n \n         let local = match self.mir[location.block]\n             .statements"}, {"sha": "06884875598df8a3eb9b419eed4647659f42286f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -618,7 +618,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 let drop_place_ty = drop_place.ty(self.mir, self.infcx.tcx);\n \n                 // Erase the regions.\n-                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).to_ty(self.infcx.tcx);\n+                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty)\n+                    .to_ty(self.infcx.tcx);\n \n                 // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but"}, {"sha": "be05e006608a26da38adaa291e9c7dbfb0cf68b9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -18,7 +18,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::Mir;\n use rustc::ty::subst::{Substs, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n-use rustc::util::ppaux::with_highlight_region;\n+use rustc::util::ppaux::with_highlight_region_for_regionvid;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::{Name, DUMMY_NODE_ID};\n use syntax::symbol::keywords;\n@@ -406,7 +406,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let type_name = with_highlight_region(needle_fr, *counter, || {\n+        let type_name = with_highlight_region_for_regionvid(needle_fr, *counter, || {\n             infcx.extract_type_name(&argument_ty)\n         });\n \n@@ -420,9 +420,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let (_, span) = self.get_argument_name_and_span_for_region(mir, argument_index);\n \n             Some(RegionName {\n-                // This counter value will already have been used, so this function will increment it\n-                // so the next value will be used next and return the region name that would have been\n-                // used.\n+                // This counter value will already have been used, so this function will increment\n+                // it so the next value will be used next and return the region name that would\n+                // have been used.\n                 name: self.synthesize_region_name(counter),\n                 source: RegionNameSource::CannotMatchHirTy(span, type_name),\n             })\n@@ -683,7 +683,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n-        let type_name = with_highlight_region(fr, *counter, || infcx.extract_type_name(&return_ty));\n+        let type_name = with_highlight_region_for_regionvid(\n+            fr, *counter, || infcx.extract_type_name(&return_ty));\n \n         let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n "}, {"sha": "75f14a6bbdac8f87b2de738ff0881d783e08c541", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -652,14 +652,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    pub fn universal_regions_outlived_by<'a>(\n-        &'a self,\n-        r: RegionVid\n-    ) -> impl Iterator<Item = RegionVid> + 'a {\n-        let borrow_scc = self.constraint_sccs.scc(r);\n-        self.scc_values.universal_regions_outlived_by(borrow_scc)\n-    }\n-\n     /// Invoked when we have some type-test (e.g., `T: 'X`) that we cannot\n     /// prove to be satisfied. If this is a closure, we will attempt to\n     /// \"promote\" this type-test into our `ClosureRegionRequirements` and"}, {"sha": "6d8a750d3d06dfc13dce7f06e0beffadeb228f7f", "filename": "src/test/ui/issues/issue-30438-c.nll.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -1,17 +1,16 @@\n error[E0597]: `x` does not live long enough\n   --> $DIR/issue-30438-c.rs:19:5\n    |\n+LL | fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n+   |                      ------------     ---------------------------- has type `&'y <Test<'z> as Trait>::Out`\n+   |                      |\n+   |                      has type `&'y Test<'z>`\n+LL |     let x = Test { s: \"this cannot last\" };\n LL |     &x\n-   |     ^^ borrowed value does not live long enough\n+   |     ^^ `x` would have to be valid for `'y`\n LL |     //~^ ERROR: `x` does not live long enough\n LL | }\n-   | - `x` dropped here while still borrowed\n-   |\n-note: borrowed value must be valid for the lifetime 'y as defined on the function body at 17:10...\n-  --> $DIR/issue-30438-c.rs:17:10\n-   |\n-LL | fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n-   |          ^^\n+   | - but `x` dropped here while still borrowed\n \n error: aborting due to previous error\n "}, {"sha": "b414c399884a3ddcad9414cc50f865e60d97249e", "filename": "src/test/ui/nll/borrowed-universal-error-2.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -1,17 +1,16 @@\n error[E0597]: `v` does not live long enough\n   --> $DIR/borrowed-universal-error-2.rs:16:5\n    |\n+LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n+   |               ----------     ------- has type `&'a u32`\n+   |               |\n+   |               has type `&'a (u32,)`\n+LL |     let v = 22;\n LL |     &v\n-   |     ^^ borrowed value does not live long enough\n+   |     ^^ `v` would have to be valid for `'a`\n LL |     //~^ ERROR `v` does not live long enough [E0597]\n LL | }\n-   | - `v` dropped here while still borrowed\n-   |\n-note: borrowed value must be valid for the lifetime 'a as defined on the function body at 14:8...\n-  --> $DIR/borrowed-universal-error-2.rs:14:8\n-   |\n-LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n-   |        ^^\n+   | - but `v` dropped here while still borrowed\n \n error: aborting due to previous error\n "}, {"sha": "a6f3f9fbd3c789be8f591c7841e45af9695d281b", "filename": "src/test/ui/nll/issue-52534-1.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+struct Test;\n+\n+impl Test {\n+    fn bar(&self, x: &u32) -> &u32 {\n+        let x = 22;\n+        &x\n+    }\n+}\n+\n+fn foo(x: &u32) -> &u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn baz(x: &u32) -> &&u32 {\n+    let x = 22;\n+    &&x\n+}\n+\n+fn main() { }"}, {"sha": "7b89336dabf220c0343f398e46e8159a0ad4f950", "filename": "src/test/ui/nll/issue-52534-1.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -0,0 +1,59 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:19:9\n+   |\n+LL |     fn bar(&self, x: &u32) -> &u32 {\n+   |            -----              ---- has type `&'0 u32`\n+   |            |\n+   |            has type `&'0 Test`\n+LL |         let x = 22;\n+LL |         &x\n+   |         ^^ `x` would have to be valid for `'0`\n+LL |     }\n+   |     - but `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:25:5\n+   |\n+LL | fn foo(x: &u32) -> &u32 {\n+   |           ----     ---- also has type `&'0 u32`\n+   |           |\n+   |           has type `&'0 u32`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'0`\n+LL | }\n+   | - but `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:30:6\n+   |\n+LL | fn baz(x: &u32) -> &&u32 {\n+   |           ----     ----- has type `&'0 &'0 u32`\n+   |           |\n+   |           has type `&'0 u32`\n+LL |     let x = 22;\n+LL |     &&x\n+   |      ^^ `x` would have to be valid for `'0`\n+LL | }\n+   | - but `x` dropped here while still borrowed\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/issue-52534-1.rs:30:6\n+   |\n+LL |     &&x\n+   |      ^^ temporary value does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 28:1...\n+  --> $DIR/issue-52534-1.rs:28:1\n+   |\n+LL | / fn baz(x: &u32) -> &&u32 {\n+LL | |     let x = 22;\n+LL | |     &&x\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "c75af27f83da4bb3229f8580d5edbf073ff9a5d5", "filename": "src/test/ui/nll/issue-52534.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fissue-52534.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fissue-52534.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534.rs?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+fn foo(_: impl FnOnce(&u32) -> &u32) {\n+}\n+\n+fn bar() {\n+    let x = 22;\n+    foo(|a| &x)\n+}\n+\n+fn main() { }"}, {"sha": "c92a4230e1e9dec19b96d3be8146947917951787", "filename": "src/test/ui/nll/issue-52534.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534.rs:19:14\n+   |\n+LL |     foo(|a| &x)\n+   |           -  ^ `x` would have to be valid for `'0`\n+   |           |\n+   |           has type `&'0 u32`\n+LL | }\n+   | - but `x` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "3f64806cc0fa77178f1ba764f7b1a4e070a0a329", "filename": "src/test/ui/regions/regions-nested-fns-2.nll.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -2,15 +2,13 @@ error[E0597]: `y` does not live long enough\n   --> $DIR/regions-nested-fns-2.rs:18:25\n    |\n LL |         |z| {\n-   |         --- value captured here\n+   |           - has type `&'0 isize`\n LL |             //~^ ERROR E0373\n LL |             if false { &y } else { z }\n-   |                         ^ borrowed value does not live long enough\n+   |                         ^ `y` would have to be valid for `'0`\n LL |         });\n LL | }\n-   | - `y` dropped here while still borrowed\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n+   | - but `y` dropped here while still borrowed\n \n error: aborting due to previous error\n "}, {"sha": "eab06e8b90f83c5f43dce3e745dd08f3bca6d5c8", "filename": "src/test/ui/regions/regions-nested-fns.nll.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9eb8d1179c220e44b3eec9edb69e1fbd04988538/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr?ref=9eb8d1179c220e44b3eec9edb69e1fbd04988538", "patch": "@@ -25,15 +25,13 @@ error[E0597]: `y` does not live long enough\n   --> $DIR/regions-nested-fns.rs:19:15\n    |\n LL |     ignore::<Box<for<'z> FnMut(&'z isize)>>(Box::new(|z| {\n-   |                                                      --- value captured here\n+   |                                                        - has type `&'0 isize`\n LL |         ay = x;\n LL |         ay = &y;\n-   |               ^ borrowed value does not live long enough\n+   |               ^ `y` would have to be valid for `'0`\n ...\n LL | }\n-   | - `y` dropped here while still borrowed\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n+   | - but `y` dropped here while still borrowed\n \n error: unsatisfied lifetime constraints\n   --> $DIR/regions-nested-fns.rs:23:68"}]}