{"sha": "39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YTU4YzM4YTBiOWFjOWU4MjJhMTczMmYwNzNhYmU4ZGRmNjVjZmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-14T19:10:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-21T21:26:53Z"}, "message": "introduce the rather simpler symbol-cache in place of symbol-map\n\nThe symbol map is not good for incremental: it has inputs from every fn\nin existence, and it will change if anything changes. One could imagine\ncheating with the symbol-map and exempting it from the usual dependency\ntracking, since the results are fully deterministic. Instead, I opted to\njust add a per-CGU cache, on the premise that recomputing some symbol\nnames is not going to be so very expensive.", "tree": {"sha": "8c837c206c4abf3293b0e2d20a8593e290545c07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c837c206c4abf3293b0e2d20a8593e290545c07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "html_url": "https://github.com/rust-lang/rust/commit/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c31750cd9afc64b0b7c9157b7044eb3e5703054", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c31750cd9afc64b0b7c9157b7044eb3e5703054", "html_url": "https://github.com/rust-lang/rust/commit/4c31750cd9afc64b0b7c9157b7044eb3e5703054"}], "stats": {"total": 153, "additions": 95, "deletions": 58}, "files": [{"sha": "c6fd87b68a0a51537d416fdb372001b1478499a7", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "patch": "@@ -65,6 +65,7 @@ use meth;\n use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n+use symbol_cache::SymbolCache;\n use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::{TransItem, DefPathBasedNames};\n@@ -75,7 +76,6 @@ use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::ffi::{CStr, CString};\n-use std::rc::Rc;\n use std::str;\n use std::i32;\n use syntax_pos::Span;\n@@ -1113,8 +1113,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (translation_items, codegen_units, symbol_map) =\n         collect_and_partition_translation_items(&shared_ccx);\n \n-    let symbol_map = Rc::new(symbol_map);\n-\n     let mut all_stats = Stats::default();\n     let modules: Vec<ModuleTranslation> = codegen_units\n         .into_iter()\n@@ -1123,7 +1121,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let (stats, module) =\n                 tcx.dep_graph.with_task(dep_node,\n                                         AssertDepGraphSafe(&shared_ccx),\n-                                        AssertDepGraphSafe((cgu, symbol_map.clone())),\n+                                        AssertDepGraphSafe(cgu),\n                                         module_translation);\n             all_stats.extend(stats);\n             module\n@@ -1132,16 +1130,17 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     fn module_translation<'a, 'tcx>(\n         scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n-        args: AssertDepGraphSafe<(CodegenUnit<'tcx>, Rc<SymbolMap<'tcx>>)>)\n+        args: AssertDepGraphSafe<CodegenUnit<'tcx>>)\n         -> (Stats, ModuleTranslation)\n     {\n         // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n         let AssertDepGraphSafe(scx) = scx;\n-        let AssertDepGraphSafe((cgu, symbol_map)) = args;\n+        let AssertDepGraphSafe(cgu) = args;\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_map);\n+        let symbol_cache = SymbolCache::new(scx);\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_cache);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n@@ -1176,11 +1175,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu, symbol_map.clone());\n+        let lcx = LocalCrateContext::new(scx, cgu, &symbol_cache);\n         let module = {\n             let ccx = CrateContext::new(scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n-                                 .items_in_deterministic_order(ccx.tcx(), &symbol_map);\n+                                 .items_in_deterministic_order(ccx.tcx(), &symbol_cache);\n             for &(trans_item, linkage) in &trans_items {\n                 trans_item.predefine(&ccx, linkage);\n             }"}, {"sha": "264e26e4594ca04c88baf6a33cb2c8fd7a09a401", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "patch": "@@ -51,8 +51,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                              TransItem::Fn(instance));\n+    let sym = ccx.symbol_cache().get(TransItem::Fn(instance));\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // This is subtle and surprising, but sometimes we have to bitcast"}, {"sha": "0105111fe6ccc9bf872c6a2e87fc5845ecb02cbd", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "patch": "@@ -93,20 +93,19 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = ccx.symbol_map()\n-                             .get(TransItem::Static(id))\n-                             .expect(\"Local statics should always be in the SymbolMap\");\n+                let sym = ccx.symbol_cache()\n+                             .get(TransItem::Static(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n                                                          .contains_key(&TransItem::Static(id));\n                 assert!(!defined_in_current_codegen_unit);\n \n-                if declare::get_declared_value(ccx, sym).is_some() {\n+                if declare::get_declared_value(ccx, &sym[..]).is_some() {\n                     span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n \n-                let g = declare::define_global(ccx, sym, llty).unwrap();\n+                let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n \n                 (g, attrs)\n             }"}, {"sha": "3769c8b026d3b3b1fcf954435b4d22db0e99b72e", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "patch": "@@ -29,15 +29,14 @@ use rustc::ty::layout::{LayoutTyper, TyLayout};\n use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n-use symbol_map::SymbolMap;\n+use symbol_cache::SymbolCache;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::marker::PhantomData;\n use std::ptr;\n use std::iter;\n-use std::rc::Rc;\n use std::str;\n use syntax::ast;\n use syntax::symbol::InternedString;\n@@ -94,7 +93,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n /// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n /// several compilation units may be optimized in parallel.  All other LLVM\n /// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n-pub struct LocalCrateContext<'tcx> {\n+pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     stats: Stats,\n@@ -166,10 +165,10 @@ pub struct LocalCrateContext<'tcx> {\n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n \n-    symbol_map: Rc<SymbolMap<'tcx>>,\n-\n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n+\n+    symbol_cache: &'a SymbolCache<'a, 'tcx>,\n }\n \n // Implement DepTrackingMapConfig for `trait_cache`\n@@ -227,12 +226,12 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n /// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccx: &'a LocalCrateContext<'tcx>,\n+    local_ccx: &'a LocalCrateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     pub fn new(shared: &'a SharedCrateContext<'a, 'tcx>,\n-               local_ccx: &'a LocalCrateContext<'tcx>)\n+               local_ccx: &'a LocalCrateContext<'a, 'tcx>)\n                -> Self {\n         CrateContext { shared, local_ccx }\n     }\n@@ -429,11 +428,11 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     }\n }\n \n-impl<'tcx> LocalCrateContext<'tcx> {\n-    pub fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n-                   codegen_unit: CodegenUnit<'tcx>,\n-                   symbol_map: Rc<SymbolMap<'tcx>>)\n-                   -> LocalCrateContext<'tcx> {\n+impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n+    pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n+               codegen_unit: CodegenUnit<'tcx>,\n+               symbol_cache: &'a SymbolCache<'a, 'tcx>)\n+               -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n             //\n@@ -487,8 +486,8 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n                 type_of_depth: Cell::new(0),\n-                symbol_map: symbol_map,\n                 local_gen_sym_counter: Cell::new(0),\n+                symbol_cache: symbol_cache,\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -522,9 +521,9 @@ impl<'tcx> LocalCrateContext<'tcx> {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(shared: &'a SharedCrateContext<'a, 'tcx>,\n-                     local_ccxs: &'a [LocalCrateContext<'tcx>])\n-                     -> CrateContext<'a, 'tcx> {\n+    fn dummy_ccx(shared: &'a SharedCrateContext<'a, 'tcx>,\n+                 local_ccxs: &'a [LocalCrateContext<'a, 'tcx>])\n+                 -> CrateContext<'a, 'tcx> {\n         assert!(local_ccxs.len() == 1);\n         CrateContext {\n             shared: shared,\n@@ -542,7 +541,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared\n     }\n \n-    fn local(&self) -> &'b LocalCrateContext<'tcx> {\n+    fn local(&self) -> &'b LocalCrateContext<'b, 'tcx> {\n         self.local_ccx\n     }\n \n@@ -709,8 +708,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn symbol_map(&self) -> &SymbolMap<'tcx> {\n-        &*self.local().symbol_map\n+    pub fn symbol_cache(&self) -> &'b SymbolCache<'b, 'tcx> {\n+        self.local().symbol_cache\n     }\n \n     /// Given the def-id of some item that has no type parameters, make\n@@ -856,7 +855,7 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n     }\n }\n \n-pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);\n+pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'a, 'tcx>);\n \n impl<'a, 'tcx> Drop for TypeOfDepthLock<'a, 'tcx> {\n     fn drop(&mut self) {"}, {"sha": "117d8568500b8a61176374b31d56aa5cc49d64b5", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "patch": "@@ -124,6 +124,7 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod partitioning;\n+mod symbol_cache;\n mod symbol_map;\n mod symbol_names_test;\n mod trans_item;"}, {"sha": "cc207b58fbc583f6cc2a6089309b5f9e092bf7ab", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "patch": "@@ -116,7 +116,7 @@ use rustc_incremental::IchHasher;\n use std::cmp::Ordering;\n use std::hash::Hash;\n use std::sync::Arc;\n-use symbol_map::SymbolMap;\n+use symbol_cache::SymbolCache;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n@@ -174,14 +174,15 @@ impl<'tcx> CodegenUnit<'tcx> {\n         DepNode::WorkProduct(self.work_product_id())\n     }\n \n-    pub fn compute_symbol_name_hash(&self,\n-                                    scx: &SharedCrateContext,\n-                                    symbol_map: &SymbolMap) -> u64 {\n+    pub fn compute_symbol_name_hash<'a>(&self,\n+                                        scx: &SharedCrateContext<'a, 'tcx>,\n+                                        symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                    -> u64 {\n         let mut state = IchHasher::new();\n         let exported_symbols = scx.exported_symbols();\n-        let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_map);\n+        let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_cache);\n         for (item, _) in all_items {\n-            let symbol_name = symbol_map.get(item).unwrap();\n+            let symbol_name = symbol_cache.get(item);\n             symbol_name.len().hash(&mut state);\n             symbol_name.hash(&mut state);\n             let exported = match item {\n@@ -201,10 +202,10 @@ impl<'tcx> CodegenUnit<'tcx> {\n         state.finish().to_smaller_hash()\n     }\n \n-    pub fn items_in_deterministic_order(&self,\n-                                        tcx: TyCtxt,\n-                                        symbol_map: &SymbolMap)\n-                                        -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n+    pub fn items_in_deterministic_order<'a>(&self,\n+                                            tcx: TyCtxt,\n+                                            symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                            -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n         let mut items: Vec<(TransItem<'tcx>, llvm::Linkage)> =\n             self.items.iter().map(|(item, linkage)| (*item, *linkage)).collect();\n \n@@ -216,9 +217,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n \n             match (node_id1, node_id2) {\n                 (None, None) => {\n-                    let symbol_name1 = symbol_map.get(trans_item1).unwrap();\n-                    let symbol_name2 = symbol_map.get(trans_item2).unwrap();\n-                    symbol_name1.cmp(symbol_name2)\n+                    let symbol_name1 = symbol_cache.get(trans_item1);\n+                    let symbol_name2 = symbol_cache.get(trans_item2);\n+                    symbol_name1.cmp(&symbol_name2)\n                 }\n                 // In the following two cases we can avoid looking up the symbol\n                 (None, Some(_)) => Ordering::Less,\n@@ -230,9 +231,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                         return ordering;\n                     }\n \n-                    let symbol_name1 = symbol_map.get(trans_item1).unwrap();\n-                    let symbol_name2 = symbol_map.get(trans_item2).unwrap();\n-                    symbol_name1.cmp(symbol_name2)\n+                    let symbol_name1 = symbol_cache.get(trans_item1);\n+                    let symbol_name2 = symbol_cache.get(trans_item2);\n+                    symbol_name1.cmp(&symbol_name2)\n                 }\n             }\n         });\n@@ -536,14 +537,12 @@ fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n+        let symbol_cache = SymbolCache::new(scx);\n         for cgu in cgus {\n-            let symbol_map = SymbolMap::build(scx, cgu.items\n-                                                      .iter()\n-                                                      .map(|(&trans_item, _)| trans_item));\n             debug!(\"CodegenUnit {}:\", cgu.name);\n \n             for (trans_item, linkage) in &cgu.items {\n-                let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n+                let symbol_name = symbol_cache.get(*trans_item);\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])\n                                                    .unwrap_or(\"<no hash>\");"}, {"sha": "bf96bf9542ab45e402e26dae431d76c423800348", "filename": "src/librustc_trans/symbol_cache.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fsymbol_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Fsymbol_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_cache.rs?ref=39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use context::SharedCrateContext;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+use trans_item::TransItem;\n+use util::nodemap::FxHashMap;\n+\n+// In the SymbolCache we collect the symbol names of translation items\n+// and cache them for later reference. This is just a performance\n+// optimization and the cache is populated lazilly; symbol names of\n+// translation items are deterministic and fully defined by the item.\n+// Thus they can always be recomputed if needed.\n+\n+pub struct SymbolCache<'a, 'tcx: 'a> {\n+    scx: &'a SharedCrateContext<'a, 'tcx>,\n+    index: RefCell<FxHashMap<TransItem<'tcx>, Rc<String>>>,\n+}\n+\n+impl<'a, 'tcx> SymbolCache<'a, 'tcx> {\n+    pub fn new(scx: &'a SharedCrateContext<'a, 'tcx>) -> Self {\n+        SymbolCache {\n+            scx,\n+            index: RefCell::new(FxHashMap())\n+        }\n+    }\n+\n+    pub fn get(&self, trans_item: TransItem<'tcx>) -> Rc<String> {\n+        let mut index = self.index.borrow_mut();\n+        index.entry(trans_item)\n+             .or_insert_with(|| Rc::new(trans_item.compute_symbol_name(self.scx)))\n+             .clone()\n+    }\n+}"}, {"sha": "3a4f73e0eb3bdd5025422458a6c66e3b30cba36a", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "patch": "@@ -118,8 +118,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                self.to_raw_string(),\n                ccx.codegen_unit().name());\n \n-        let symbol_name = ccx.symbol_map()\n-                             .get_or_compute(ccx.shared(), *self);\n+        let symbol_name = ccx.symbol_cache().get(*self);\n \n         debug!(\"symbol {}\", &symbol_name);\n "}]}