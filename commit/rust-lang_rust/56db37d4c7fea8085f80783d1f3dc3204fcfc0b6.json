{"sha": "56db37d4c7fea8085f80783d1f3dc3204fcfc0b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZGIzN2Q0YzdmZWE4MDg1ZjgwNzgzZDFmM2RjMzIwNGZjZmMwYjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-01T02:52:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-01T03:21:26Z"}, "message": "add iter library in preliminary form (limited syntactic support)", "tree": {"sha": "4d891ff22d4d1d15bccd0893fdf4c289af9af5a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d891ff22d4d1d15bccd0893fdf4c289af9af5a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56db37d4c7fea8085f80783d1f3dc3204fcfc0b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56db37d4c7fea8085f80783d1f3dc3204fcfc0b6", "html_url": "https://github.com/rust-lang/rust/commit/56db37d4c7fea8085f80783d1f3dc3204fcfc0b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56db37d4c7fea8085f80783d1f3dc3204fcfc0b6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5d095d67e3926fa104ac495076fe9d4cd4f5562", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d095d67e3926fa104ac495076fe9d4cd4f5562", "html_url": "https://github.com/rust-lang/rust/commit/e5d095d67e3926fa104ac495076fe9d4cd4f5562"}], "stats": {"total": 175, "additions": 173, "deletions": 2}, "files": [{"sha": "3bc5a031949371d0f0faf6b02ee74baa40747db3", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56db37d4c7fea8085f80783d1f3dc3204fcfc0b6/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/56db37d4c7fea8085f80783d1f3dc3204fcfc0b6/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=56db37d4c7fea8085f80783d1f3dc3204fcfc0b6", "patch": "@@ -30,7 +30,7 @@ This behavior can be disabled with the `no_core` crate attribute.\"\n \n export box, char, float, bessel, f32, f64, int, str, ptr;\n export uint, u8, u32, u64, vec, bool;\n-export either, option, result;\n+export either, option, result, iter;\n export ctypes, sys, unsafe, comm, task, logging;\n export extfmt;\n export math;\n@@ -64,7 +64,7 @@ mod either;\n mod option;\n mod result;\n mod tuple;\n-\n+mod iter;\n \n // Runtime and language-primitive support\n "}, {"sha": "7aa08a6980c3c646fbec1d55b75c3ed124f9d182", "filename": "src/libcore/iter.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/56db37d4c7fea8085f80783d1f3dc3204fcfc0b6/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56db37d4c7fea8085f80783d1f3dc3204fcfc0b6/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=56db37d4c7fea8085f80783d1f3dc3204fcfc0b6", "patch": "@@ -0,0 +1,171 @@\n+iface iterable<A> {\n+    fn iter(blk: fn(A));\n+}\n+\n+impl<A> of iterable<A> for fn@(fn(A)) {\n+    fn iter(blk: fn(A)) {\n+        self(blk);\n+    }\n+}\n+\n+// accomodate the fact that int/uint are passed by value by default:\n+impl of iterable<int> for fn@(fn(int)) {\n+    fn iter(blk: fn(&&int)) {\n+        self {|i| blk(i)}\n+    }\n+}\n+\n+impl of iterable<uint> for fn@(fn(uint)) {\n+    fn iter(blk: fn(&&uint)) {\n+        self {|i| blk(i)}\n+    }\n+}\n+\n+impl<A> of iterable<A> for [A] {\n+    fn iter(blk: fn(A)) {\n+        vec::iter(self, blk)\n+    }\n+}\n+\n+impl<A> of iterable<A> for option<A> {\n+    fn iter(blk: fn(A)) {\n+        option::may(self, blk)\n+    }\n+}\n+\n+fn enumerate<A,IA:iterable<A>>(self: IA, blk: fn(uint, A)) {\n+    let i = 0u;\n+    self.iter {|a|\n+        blk(i, a);\n+        i += 1u;\n+    }\n+}\n+\n+// Here: we have to use fn@ for predicates and map functions, because\n+// we will be binding them up into a closure.  Disappointing.  A true\n+// region type system might be able to do better than this.\n+\n+fn filter<A,IA:iterable<A>>(self: IA, prd: fn@(A) -> bool, blk: fn(A)) {\n+    self.iter {|a|\n+        if prd(a) { blk(a) }\n+    }\n+}\n+\n+fn map<A,B,IA:iterable<A>>(self: IA, cnv: fn@(A) -> B, blk: fn(B)) {\n+    self.iter {|a|\n+        let b = cnv(a);\n+        blk(b);\n+    }\n+}\n+\n+fn flat_map<A,B,IA:iterable<A>,IB:iterable<B>>(\n+    self: IA, cnv: fn@(A) -> IB, blk: fn(B)) {\n+    self.iter {|a|\n+        cnv(a).iter(blk)\n+    }\n+}\n+\n+fn foldl<A,B:copy,IA:iterable<A>>(self: IA, b0: B, blk: fn(B, A) -> B) -> B {\n+    let b = b0;\n+    self.iter {|a|\n+        b = blk(b, a);\n+    }\n+    ret b;\n+}\n+\n+fn to_list<A:copy,IA:iterable<A>>(self: IA) -> [A] {\n+    foldl::<A,[A],IA>(self, [], {|r, a| r + [a]})\n+}\n+\n+fn repeat(times: uint, blk: fn()) {\n+    let i = 0u;\n+    while i < times {\n+        blk();\n+        i += 1u;\n+    }\n+}\n+\n+\n+#[test]\n+fn test_enumerate() {\n+    enumerate([\"0\", \"1\", \"2\"]) {|i,j|\n+        assert #fmt[\"%u\",i] == j;\n+    }\n+}\n+\n+#[test]\n+fn test_map_and_to_list() {\n+    let a = bind vec::iter([0, 1, 2], _);\n+    let b = bind map(a, {|i| i*2}, _);\n+    let c = to_list(b);\n+    assert c == [0, 2, 4];\n+}\n+\n+#[test]\n+fn test_map_directly_on_vec() {\n+    let b = bind map([0, 1, 2], {|i| i*2}, _);\n+    let c = to_list(b);\n+    assert c == [0, 2, 4];\n+}\n+\n+#[test]\n+fn test_filter_on_int_range() {\n+    fn is_even(&&i: int) -> bool {\n+        ret (i % 2) == 0;\n+    }\n+\n+    let l = to_list(bind filter(bind int::range(0, 10, _), is_even, _));\n+    assert l == [0, 2, 4, 6, 8];\n+}\n+\n+#[test]\n+fn test_filter_on_uint_range() {\n+    fn is_even(&&i: uint) -> bool {\n+        ret (i % 2u) == 0u;\n+    }\n+\n+    let l = to_list(bind filter(bind uint::range(0u, 10u, _), is_even, _));\n+    assert l == [0u, 2u, 4u, 6u, 8u];\n+}\n+\n+#[test]\n+fn test_flat_map_with_option() {\n+    fn if_even(&&i: int) -> option<int> {\n+        if (i % 2) == 0 { some(i) }\n+        else { none }\n+    }\n+\n+    let a = bind vec::iter([0, 1, 2], _);\n+    let b = bind flat_map(a, if_even, _);\n+    let c = to_list(b);\n+    assert c == [0, 2];\n+}\n+\n+#[test]\n+fn test_flat_map_with_list() {\n+    fn repeat(&&i: int) -> [int] {\n+        let r = [];\n+        int::range(0, i) {|_j| r += [i]; }\n+        r\n+    }\n+\n+    let a = bind vec::iter([0, 1, 2, 3], _);\n+    let b = bind flat_map(a, repeat, _);\n+    let c = to_list(b);\n+    #debug[\"c = %?\", c];\n+    assert c == [1, 2, 2, 3, 3, 3];\n+}\n+\n+#[test]\n+fn test_repeat() {\n+    let c = [],\n+        i = 0u;\n+    repeat(5u) {||\n+        c += [(i * i)];\n+        i += 1u;\n+    };\n+    #debug[\"c = %?\", c];\n+    assert c == [0u, 1u, 4u, 9u, 16u];\n+}\n+\n+"}]}