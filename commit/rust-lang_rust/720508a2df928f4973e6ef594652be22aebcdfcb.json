{"sha": "720508a2df928f4973e6ef594652be22aebcdfcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMDUwOGEyZGY5MjhmNDk3M2U2ZWY1OTQ2NTJiZTIyYWViY2RmY2I=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-08T13:41:32Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-08T14:26:25Z"}, "message": "dedup struct debug impl code", "tree": {"sha": "77b551b1cfad6f49d611591ec02eeeb2b52bf729", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77b551b1cfad6f49d611591ec02eeeb2b52bf729"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/720508a2df928f4973e6ef594652be22aebcdfcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/720508a2df928f4973e6ef594652be22aebcdfcb", "html_url": "https://github.com/rust-lang/rust/commit/720508a2df928f4973e6ef594652be22aebcdfcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/720508a2df928f4973e6ef594652be22aebcdfcb/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc3ff1b486edf123e2dad17f5225ce761c3b5711", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc3ff1b486edf123e2dad17f5225ce761c3b5711", "html_url": "https://github.com/rust-lang/rust/commit/cc3ff1b486edf123e2dad17f5225ce761c3b5711"}], "stats": {"total": 80, "additions": 35, "deletions": 45}, "files": [{"sha": "7358444f17063fd9d387d98e0864905c7858c8e5", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 35, "deletions": 45, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/720508a2df928f4973e6ef594652be22aebcdfcb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720508a2df928f4973e6ef594652be22aebcdfcb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=720508a2df928f4973e6ef594652be22aebcdfcb", "patch": "@@ -178,16 +178,16 @@ fn impl_def_from_trait(\n     Some((impl_def, first_assoc_item))\n }\n \n+/// Generate a `Debug` impl based on the fields and members of the target type.\n fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n     match adt {\n         ast::Adt::Union(_) => {} // `Debug` cannot be derived for unions, so no default impl can be provided.\n         ast::Adt::Enum(enum_) => {\n             if let Some(list) = enum_.variant_list() {\n                 let mut arms = vec![];\n                 for variant in list.variants() {\n-                    let name = variant.name().unwrap();\n-\n                     // => Self::<Variant>\n+                    let name = variant.name().unwrap();\n                     let first = make::ext::ident_path(\"Self\");\n                     let second = make::ext::ident_path(&format!(\"{}\", name));\n                     let pat = make::path_pat(make::path_concat(first, second));\n@@ -199,7 +199,6 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n                     let target = make::expr_path(make::ext::ident_path(\"write\"));\n                     let expr = make::expr_macro_call(target, args);\n \n-                    // => Self::<Variant> => write!(f, \"<Variant>\"),\n                     arms.push(make::match_arm(Some(pat.into()), None, expr.into()));\n                 }\n \n@@ -212,52 +211,43 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n                 ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n             }\n         }\n-        ast::Adt::Struct(strukt) => match strukt.field_list() {\n-            Some(ast::FieldList::RecordFieldList(field_list)) => {\n-                let name = format!(\"\\\"{}\\\"\", annotated_name);\n-                let args = make::arg_list(Some(make::expr_literal(&name).into()));\n-                let target = make::expr_path(make::ext::ident_path(\"f\"));\n-                let mut expr = make::expr_method_call(target, \"debug_struct\", args);\n-                for field in field_list.fields() {\n-                    if let Some(name) = field.name() {\n-                        let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+        ast::Adt::Struct(strukt) => {\n+            let name = format!(\"\\\"{}\\\"\", annotated_name);\n+            let args = make::arg_list(Some(make::expr_literal(&name).into()));\n+            let target = make::expr_path(make::ext::ident_path(\"f\"));\n+\n+            let expr = match strukt.field_list() {\n+                None => make::expr_method_call(target, \"debug_struct\", args),\n+                Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                    let mut expr = make::expr_method_call(target, \"debug_struct\", args);\n+                    for field in field_list.fields() {\n+                        if let Some(name) = field.name() {\n+                            let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                            let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                            let f_path = make::expr_ref(f_path, false);\n+                            let f_path = make::expr_field(f_path, &format!(\"{}\", name)).into();\n+                            let args = make::arg_list(vec![f_name, f_path]);\n+                            expr = make::expr_method_call(expr, \"field\", args);\n+                        }\n+                    }\n+                    expr\n+                }\n+                Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                    let mut expr = make::expr_method_call(target, \"debug_tuple\", args);\n+                    for (idx, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", name)).into();\n-                        let args = make::arg_list(vec![f_name, f_path]);\n-                        expr = make::expr_method_call(expr, \"field\", args);\n+                        let f_path = make::expr_field(f_path, &format!(\"{}\", idx)).into();\n+                        expr = make::expr_method_call(expr, \"field\", make::arg_list(Some(f_path)));\n                     }\n+                    expr\n                 }\n-                let expr = make::expr_method_call(expr, \"finish\", make::arg_list(None));\n-                let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n-                ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n-            }\n-            Some(ast::FieldList::TupleFieldList(field_list)) => {\n-                let name = format!(\"\\\"{}\\\"\", annotated_name);\n-                let args = make::arg_list(Some(make::expr_literal(&name).into()));\n-                let target = make::expr_path(make::ext::ident_path(\"f\"));\n-                let mut expr = make::expr_method_call(target, \"debug_tuple\", args);\n-                for (idx, _) in field_list.fields().enumerate() {\n-                    let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n-                    let f_path = make::expr_ref(f_path, false);\n-                    let f_path = make::expr_field(f_path, &format!(\"{}\", idx)).into();\n-                    let args = make::arg_list(Some(f_path));\n-                    expr = make::expr_method_call(expr, \"field\", args);\n-                }\n-                let expr = make::expr_method_call(expr, \"finish\", make::arg_list(None));\n-                let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n-                ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n-            }\n-            None => {\n-                let name = format!(\"\\\"{}\\\"\", annotated_name);\n-                let args = make::arg_list(Some(make::expr_literal(&name).into()));\n-                let target = make::expr_path(make::ext::ident_path(\"f\"));\n-                let expr = make::expr_method_call(target, \"debug_struct\", args);\n-                let expr = make::expr_method_call(expr, \"finish\", make::arg_list(None));\n-                let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n-                ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n-            }\n-        },\n+            };\n+\n+            let expr = make::expr_method_call(expr, \"finish\", make::arg_list(None));\n+            let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n+            ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n+        }\n     }\n }\n "}]}