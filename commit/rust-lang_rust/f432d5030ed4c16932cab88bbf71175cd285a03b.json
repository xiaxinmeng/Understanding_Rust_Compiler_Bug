{"sha": "f432d5030ed4c16932cab88bbf71175cd285a03b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MzJkNTAzMGVkNGMxNjkzMmNhYjg4YmJmNzExNzVjZDI4NWEwM2I=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-16T15:09:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-16T15:09:33Z"}, "message": "Rollup merge of #63955 - RalfJung:intern, r=oli-obk\n\nMake sure interned constants are immutable\n\nThis makes sure that interning for constants (not statics) creates only immutable allocations.\n\nPreviously, the \"main\" allocation of `const FOO: Cell<i32> = Cell::new(0);` was marked as mutable, but I don't think we want that. It can be only copied, not written to.\n\nAlso, \"leftover\" allocations (behind raw pointers etc) were left mutable. I don't think we want to support that. I tried asserting that these are all already immutable (to double-check our static checks), but that failed in this one:\n```rust\nconst NON_NULL_PTR2: NonNull<u8> = unsafe { mem::transmute(&0) };\n```\nSeems like maybe we want more precise mutability annotation inside Miri for locals (like `&0` here) so that this would actually become immutable to begin with?\n\nI also factored `intern_shallow` out of the visitor so that we don't have to construct a visitor when we do not plan to visit anything. That confused me at first.", "tree": {"sha": "b7d6b5b5f7143cc302e005147eccf02a36c83769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7d6b5b5f7143cc302e005147eccf02a36c83769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f432d5030ed4c16932cab88bbf71175cd285a03b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdf6WtCRBK7hj4Ov3rIwAAdHIIAFH0BKPRYCwMYCdYgfSSSWlr\nKYd99jZ0j8Q2P4QHgyYSDxnaWSSiRuDDd6jD8hZ8Nq8uNeZKC8/iUrKbt6UZ/Dnk\ni98U3N4smyyH2KHKXo9dgAb/jPDdaOE4DcyDaQ7O7jorRXN92fM6mBw3Ao8UxWTf\n9xG0J2YF7TP6ZrRnDz7lfzyJKrwcPLyGou7YJQdLni0VjpsL5mtKv/NgUeBFE3s3\nsq3LV9X75wIYCjmJW9JmFBvQo3boukN5YLbWOiKI2DlIDgmZxpxsbdYCJOpIOEOz\nuprVSkW9roeQQIHzJSu4NDCvZqThd9uNvkLaeFzscRYA35LpzDchYRStpbGNw8c=\n=AzwL\n-----END PGP SIGNATURE-----\n", "payload": "tree b7d6b5b5f7143cc302e005147eccf02a36c83769\nparent b6269f27d99d7da9e95f0b3fdc53193dc8c42fbe\nparent 5462ecb4b131a513b2d821d52b9af491781bd898\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568646573 +0200\ncommitter GitHub <noreply@github.com> 1568646573 +0200\n\nRollup merge of #63955 - RalfJung:intern, r=oli-obk\n\nMake sure interned constants are immutable\n\nThis makes sure that interning for constants (not statics) creates only immutable allocations.\n\nPreviously, the \"main\" allocation of `const FOO: Cell<i32> = Cell::new(0);` was marked as mutable, but I don't think we want that. It can be only copied, not written to.\n\nAlso, \"leftover\" allocations (behind raw pointers etc) were left mutable. I don't think we want to support that. I tried asserting that these are all already immutable (to double-check our static checks), but that failed in this one:\n```rust\nconst NON_NULL_PTR2: NonNull<u8> = unsafe { mem::transmute(&0) };\n```\nSeems like maybe we want more precise mutability annotation inside Miri for locals (like `&0` here) so that this would actually become immutable to begin with?\n\nI also factored `intern_shallow` out of the visitor so that we don't have to construct a visitor when we do not plan to visit anything. That confused me at first.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f432d5030ed4c16932cab88bbf71175cd285a03b", "html_url": "https://github.com/rust-lang/rust/commit/f432d5030ed4c16932cab88bbf71175cd285a03b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f432d5030ed4c16932cab88bbf71175cd285a03b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6269f27d99d7da9e95f0b3fdc53193dc8c42fbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6269f27d99d7da9e95f0b3fdc53193dc8c42fbe", "html_url": "https://github.com/rust-lang/rust/commit/b6269f27d99d7da9e95f0b3fdc53193dc8c42fbe"}, {"sha": "5462ecb4b131a513b2d821d52b9af491781bd898", "url": "https://api.github.com/repos/rust-lang/rust/commits/5462ecb4b131a513b2d821d52b9af491781bd898", "html_url": "https://github.com/rust-lang/rust/commit/5462ecb4b131a513b2d821d52b9af491781bd898"}], "stats": {"total": 316, "additions": 195, "deletions": 121}, "files": [{"sha": "3f53f842f314f830ead99690074e4cc70873a653", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=f432d5030ed4c16932cab88bbf71175cd285a03b", "patch": "@@ -134,9 +134,8 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n-    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n+    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n     let tcx = ecx.tcx.tcx;\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n@@ -162,7 +161,6 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         ecx,\n         cid.instance.def_id(),\n         ret,\n-        param_env,\n     )?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n@@ -658,7 +656,7 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(\n-        |body| eval_body_using_ecx(&mut ecx, cid, body, key.param_env)\n+        |body| eval_body_using_ecx(&mut ecx, cid, body)\n     ).and_then(|place| {\n         Ok(RawConst {\n             alloc_id: place.ptr.assert_ptr().alloc_id,"}, {"sha": "95647ce642c5b6a5f9ec218da548805849ab1bc5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 145, "deletions": 116, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=f432d5030ed4c16932cab88bbf71175cd285a03b", "patch": "@@ -3,40 +3,37 @@\n //! After a const evaluation has computed a value, before we destroy the const evaluator's session\n //! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n \n-use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n+use rustc::ty::{Ty, self};\n use rustc::mir::interpret::{InterpResult, ErrorHandled};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use super::validity::RefTracking;\n use rustc_data_structures::fx::FxHashSet;\n \n use syntax::ast::Mutability;\n-use syntax_pos::Span;\n \n use super::{\n-    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, Scalar,\n+    ValueVisitor, MemoryKind, AllocId, MPlaceTy, Scalar,\n };\n use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n \n struct InternVisitor<'rt, 'mir, 'tcx> {\n-    /// previously encountered safe references\n-    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    /// The ectx from which we intern.\n     ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n-    param_env: ParamEnv<'tcx>,\n+    /// Previously encountered safe references.\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    /// A list of all encountered allocations. After type-based interning, we traverse this list to\n+    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n+    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n     /// The root node of the value that we're looking at. This field is never mutated and only used\n     /// for sanity assertions that will ICE when `const_qualif` screws up.\n     mode: InternMode,\n     /// This field stores the mutability of the value *currently* being checked.\n-    /// It is set to mutable when an `UnsafeCell` is encountered\n-    /// When recursing across a reference, we don't recurse but store the\n-    /// value to be checked in `ref_tracking` together with the mutability at which we are checking\n-    /// the value.\n-    /// When encountering an immutable reference, we treat everything as immutable that is behind\n-    /// it.\n+    /// When encountering a mutable reference, we determine the pointee mutability\n+    /// taking into account the mutability of the context: `& &mut i32` is entirely immutable,\n+    /// despite the nested mutable reference!\n+    /// The field gets updated when an `UnsafeCell` is encountered.\n     mutability: Mutability,\n-    /// A list of all encountered relocations. After type-based interning, we traverse this list to\n-    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n-    leftover_relocations: &'rt mut FxHashSet<AllocId>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n@@ -45,58 +42,111 @@ enum InternMode {\n     /// `static`. In a `static mut` we start out as mutable and thus can also contain further `&mut`\n     /// that will actually be treated as mutable.\n     Static,\n-    /// UnsafeCell is OK in the value of a constant, but not behind references in a constant\n+    /// UnsafeCell is OK in the value of a constant: `const FOO = Cell::new(0)` creates\n+    /// a new cell every time it is used.\n     ConstBase,\n-    /// `UnsafeCell` ICEs\n+    /// `UnsafeCell` ICEs.\n     Const,\n }\n \n /// Signalling data structure to ensure we don't recurse\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n+/// Intern an allocation without looking at its children.\n+/// `mode` is the mode of the environment where we found this pointer.\n+/// `mutablity` is the mutability of the place to be interned; even if that says\n+/// `immutable` things might become mutable if `ty` is not frozen.\n+/// `ty` can be `None` if there is no potential interior mutability\n+/// to account for (e.g. for vtables).\n+fn intern_shallow<'rt, 'mir, 'tcx>(\n+    ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n+    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n+    mode: InternMode,\n+    alloc_id: AllocId,\n+    mutability: Mutability,\n+    ty: Option<Ty<'tcx>>,\n+) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n+    trace!(\n+        \"InternVisitor::intern {:?} with {:?}\",\n+        alloc_id, mutability,\n+    );\n+    // remove allocation\n+    let tcx = ecx.tcx;\n+    let memory = ecx.memory_mut();\n+    let (kind, mut alloc) = match memory.alloc_map.remove(&alloc_id) {\n+        Some(entry) => entry,\n+        None => {\n+            // Pointer not found in local memory map. It is either a pointer to the global\n+            // map, or dangling.\n+            // If the pointer is dangling (neither in local nor global memory), we leave it\n+            // to validation to error. The `delay_span_bug` ensures that we don't forget such\n+            // a check in validation.\n+            if tcx.alloc_map.lock().get(alloc_id).is_none() {\n+                tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n+            }\n+            // treat dangling pointers like other statics\n+            // just to stop trying to recurse into them\n+            return Ok(Some(IsStaticOrFn));\n+        },\n+    };\n+    // This match is just a canary for future changes to `MemoryKind`, which most likely need\n+    // changes in this function.\n+    match kind {\n+        MemoryKind::Stack | MemoryKind::Vtable => {},\n+    }\n+    // Set allocation mutability as appropriate. This is used by LLVM to put things into\n+    // read-only memory, and also by Miri when evluating other constants/statics that\n+    // access this one.\n+    if mode == InternMode::Static {\n+        // When `ty` is `None`, we assume no interior mutability.\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(\n+            ecx.tcx.tcx,\n+            ecx.param_env,\n+            ecx.tcx.span,\n+        ));\n+        // For statics, allocation mutability is the combination of the place mutability and\n+        // the type mutability.\n+        // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n+        if mutability == Mutability::Immutable && frozen {\n+            alloc.mutability = Mutability::Immutable;\n+        } else {\n+            // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n+            assert_eq!(alloc.mutability, Mutability::Mutable);\n+        }\n+    } else {\n+        // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n+        // But we still intern that as immutable as the memory cannot be changed once the\n+        // initial value was computed.\n+        // Constants are never mutable.\n+        assert_eq!(\n+            mutability, Mutability::Immutable,\n+            \"Something went very wrong: mutability requested for a constant\"\n+        );\n+        alloc.mutability = Mutability::Immutable;\n+    };\n+    // link the alloc id to the actual allocation\n+    let alloc = tcx.intern_const_alloc(alloc);\n+    leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n+    tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+    Ok(None)\n+}\n+\n impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n-    /// Intern an allocation without looking at its children\n     fn intern_shallow(\n         &mut self,\n-        ptr: Pointer,\n+        alloc_id: AllocId,\n         mutability: Mutability,\n+        ty: Option<Ty<'tcx>>,\n     ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-        trace!(\n-            \"InternVisitor::intern {:?} with {:?}\",\n-            ptr, mutability,\n-        );\n-        // remove allocation\n-        let tcx = self.ecx.tcx;\n-        let memory = self.ecx.memory_mut();\n-        let (kind, mut alloc) = match memory.alloc_map.remove(&ptr.alloc_id) {\n-            Some(entry) => entry,\n-            None => {\n-                // if the pointer is dangling (neither in local nor global memory), we leave it\n-                // to validation to error. The `delay_span_bug` ensures that we don't forget such\n-                // a check in validation.\n-                if tcx.alloc_map.lock().get(ptr.alloc_id).is_none() {\n-                    tcx.sess.delay_span_bug(self.ecx.tcx.span, \"tried to intern dangling pointer\");\n-                }\n-                // treat dangling pointers like other statics\n-                // just to stop trying to recurse into them\n-                return Ok(Some(IsStaticOrFn));\n-            },\n-        };\n-        // This match is just a canary for future changes to `MemoryKind`, which most likely need\n-        // changes in this function.\n-        match kind {\n-            MemoryKind::Stack | MemoryKind::Vtable => {},\n-        }\n-        // Ensure llvm knows to only put this into immutable memory if the value is immutable either\n-        // by being behind a reference or by being part of a static or const without interior\n-        // mutability\n-        alloc.mutability = mutability;\n-        // link the alloc id to the actual allocation\n-        let alloc = tcx.intern_const_alloc(alloc);\n-        self.leftover_relocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n-        tcx.alloc_map.lock().set_alloc_id_memory(ptr.alloc_id, alloc);\n-        Ok(None)\n+        intern_shallow(\n+            self.ecx,\n+            self.leftover_allocations,\n+            self.mode,\n+            alloc_id,\n+            mutability,\n+            ty,\n+        )\n     }\n }\n \n@@ -119,14 +169,16 @@ for\n     ) -> InterpResult<'tcx> {\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n-                // We are crossing over an `UnsafeCell`, we can mutate again\n+                // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n+                // References we encounter inside here are interned as pointing to mutable\n+                // allocations.\n                 let old = std::mem::replace(&mut self.mutability, Mutability::Mutable);\n                 assert_ne!(\n                     self.mode, InternMode::Const,\n                     \"UnsafeCells are not allowed behind references in constants. This should have \\\n                     been prevented statically by const qualification. If this were allowed one \\\n-                    would be able to change a constant at one use site and other use sites may \\\n-                    arbitrarily decide to change, too.\",\n+                    would be able to change a constant at one use site and other use sites could \\\n+                    observe that mutation.\",\n                 );\n                 let walked = self.walk_aggregate(mplace, fields);\n                 self.mutability = old;\n@@ -145,12 +197,13 @@ for\n             // Handle trait object vtables\n             if let Ok(meta) = value.to_meta() {\n                 if let ty::Dynamic(..) =\n-                    self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.param_env).sty\n+                    self.ecx.tcx.struct_tail_erasing_lifetimes(\n+                        referenced_ty, self.ecx.param_env).sty\n                 {\n                     if let Ok(vtable) = meta.unwrap().to_ptr() {\n                         // explitly choose `Immutable` here, since vtables are immutable, even\n                         // if the reference of the fat pointer is mutable\n-                        self.intern_shallow(vtable, Mutability::Immutable)?;\n+                        self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n                     }\n                 }\n             }\n@@ -177,7 +230,7 @@ for\n                     (InternMode::Const, hir::Mutability::MutMutable) => {\n                         match referenced_ty.sty {\n                             ty::Array(_, n)\n-                                if n.eval_usize(self.ecx.tcx.tcx, self.param_env) == 0 => {}\n+                                if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n                             ty::Slice(_)\n                                 if value.to_meta().unwrap().unwrap().to_usize(self.ecx)? == 0 => {}\n                             _ => bug!(\"const qualif failed to prevent mutable references\"),\n@@ -195,21 +248,13 @@ for\n                     (Mutability::Mutable, hir::Mutability::MutMutable) => Mutability::Mutable,\n                     _ => Mutability::Immutable,\n                 };\n-                // Compute the mutability of the allocation\n-                let intern_mutability = intern_mutability(\n-                    self.ecx.tcx.tcx,\n-                    self.param_env,\n-                    mplace.layout.ty,\n-                    self.ecx.tcx.span,\n-                    mutability,\n-                );\n                 // Recursing behind references changes the intern mode for constants in order to\n                 // cause assertions to trigger if we encounter any `UnsafeCell`s.\n                 let mode = match self.mode {\n                     InternMode::ConstBase => InternMode::Const,\n                     other => other,\n                 };\n-                match self.intern_shallow(ptr, intern_mutability)? {\n+                match self.intern_shallow(ptr.alloc_id, mutability, Some(mplace.layout.ty))? {\n                     // No need to recurse, these are interned already and statics may have\n                     // cycles, so we don't want to recurse there\n                     Some(IsStaticOrFn) => {},\n@@ -224,69 +269,45 @@ for\n     }\n }\n \n-/// Figure out the mutability of the allocation.\n-/// Mutable if it has interior mutability *anywhere* in the type.\n-fn intern_mutability<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-    span: Span,\n-    mutability: Mutability,\n-) -> Mutability {\n-    let has_interior_mutability = !ty.is_freeze(tcx, param_env, span);\n-    if has_interior_mutability {\n-        Mutability::Mutable\n-    } else {\n-        mutability\n-    }\n-}\n-\n pub fn intern_const_alloc_recursive(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     def_id: DefId,\n     ret: MPlaceTy<'tcx>,\n-    // FIXME(oli-obk): can we scrap the param env? I think we can, the final value of a const eval\n-    // must always be monomorphic, right?\n-    param_env: ty::ParamEnv<'tcx>,\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     // this `mutability` is the mutability of the place, ignoring the type\n-    let (mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n+    let (base_mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n         Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n-        None => (Mutability::Immutable, InternMode::ConstBase),\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n         Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),\n+        // consts, promoteds. FIXME: what about array lengths, array initializers?\n+        None => (Mutability::Immutable, InternMode::ConstBase),\n     };\n \n-    // type based interning\n-    let mut ref_tracking = RefTracking::new((ret, mutability, base_intern_mode));\n-    let leftover_relocations = &mut FxHashSet::default();\n-\n-    // This mutability is the combination of the place mutability and the type mutability. If either\n-    // is mutable, `alloc_mutability` is mutable. This exists because the entire allocation needs\n-    // to be mutable if it contains an `UnsafeCell` anywhere. The other `mutability` exists so that\n-    // the visitor does not treat everything outside the `UnsafeCell` as mutable.\n-    let alloc_mutability = intern_mutability(\n-        tcx.tcx, param_env, ret.layout.ty, tcx.span, mutability,\n-    );\n+    // Type based interning.\n+    // `ref_tracking` tracks typed references we have seen and still need to crawl for\n+    // more typed information inside them.\n+    // `leftover_allocations` collects *all* allocations we see, because some might not\n+    // be available in a typed way. They get interned at the end.\n+    let mut ref_tracking = RefTracking::new((ret, base_mutability, base_intern_mode));\n+    let leftover_allocations = &mut FxHashSet::default();\n \n     // start with the outermost allocation\n-    InternVisitor {\n-        ref_tracking: &mut ref_tracking,\n+    intern_shallow(\n         ecx,\n-        mode: base_intern_mode,\n-        leftover_relocations,\n-        param_env,\n-        mutability,\n-    }.intern_shallow(ret.ptr.to_ptr()?, alloc_mutability)?;\n+        leftover_allocations,\n+        base_intern_mode,\n+        ret.ptr.to_ptr()?.alloc_id,\n+        base_mutability,\n+        Some(ret.layout.ty)\n+    )?;\n \n     while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n         let interned = InternVisitor {\n             ref_tracking: &mut ref_tracking,\n             ecx,\n             mode,\n-            leftover_relocations,\n-            param_env,\n+            leftover_allocations,\n             mutability,\n         }.visit_value(mplace);\n         if let Err(error) = interned {\n@@ -309,15 +330,23 @@ pub fn intern_const_alloc_recursive(\n     // Intern the rest of the allocations as mutable. These might be inside unions, padding, raw\n     // pointers, ... So we can't intern them according to their type rules\n \n-    let mut todo: Vec<_> = leftover_relocations.iter().cloned().collect();\n+    let mut todo: Vec<_> = leftover_allocations.iter().cloned().collect();\n     while let Some(alloc_id) = todo.pop() {\n-        if let Some((_, alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n-            // We can't call the `intern` method here, as its logic is tailored to safe references.\n-            // So we hand-roll the interning logic here again\n+        if let Some((_, mut alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n+            // We can't call the `intern_shallow` method here, as its logic is tailored to safe\n+            // references and a `leftover_allocations` set (where we only have a todo-list here).\n+            // So we hand-roll the interning logic here again.\n+            if base_intern_mode != InternMode::Static {\n+                // If it's not a static, it *must* be immutable.\n+                // We cannot have mutable memory inside a constant.\n+                // FIXME: ideally we would assert that they already are immutable, to double-\n+                // check our static checks.\n+                alloc.mutability = Mutability::Immutable;\n+            }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n             for &(_, ((), reloc)) in alloc.relocations().iter() {\n-                if leftover_relocations.insert(reloc) {\n+                if leftover_allocations.insert(reloc) {\n                     todo.push(reloc);\n                 }\n             }"}, {"sha": "b476e04529a52c86431c41b82b7dddf07b3f5204", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs?ref=f432d5030ed4c16932cab88bbf71175cd285a03b", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![feature(const_raw_ptr_deref)]\n+#![deny(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// make sure we do not just intern this as mutable\n+const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+\n+const MUTATING_BEHIND_RAW: () = {\n+    // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n+    unsafe {\n+        *MUTABLE_BEHIND_RAW = 99 //~ WARN skipping const checks\n+        //~^ ERROR any use of this value will cause an error\n+        //~^^ tried to modify constant memory\n+    }\n+};\n+\n+fn main() {}"}, {"sha": "507d4823a111d5876863b82d27d11c8d007d8926", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=f432d5030ed4c16932cab88bbf71175cd285a03b", "patch": "@@ -0,0 +1,27 @@\n+warning: skipping const checks\n+  --> $DIR/mutable_const.rs:14:9\n+   |\n+LL |         *MUTABLE_BEHIND_RAW = 99\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: any use of this value will cause an error\n+  --> $DIR/mutable_const.rs:14:9\n+   |\n+LL | / const MUTATING_BEHIND_RAW: () = {\n+LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n+LL | |     unsafe {\n+LL | |         *MUTABLE_BEHIND_RAW = 99\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ tried to modify constant memory\n+...  |\n+LL | |     }\n+LL | | };\n+   | |__-\n+   |\n+note: lint level defined here\n+  --> $DIR/mutable_const.rs:4:9\n+   |\n+LL | #![deny(const_err)]\n+   |         ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "28cf3537d605a41d005f78f29b5afa6f30980ab3", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f432d5030ed4c16932cab88bbf71175cd285a03b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr?ref=f432d5030ed4c16932cab88bbf71175cd285a03b", "patch": "@@ -6,7 +6,7 @@ LL |         *MUH.x.get() = 99;\n \n thread 'rustc' panicked at 'assertion failed: `(left != right)`\n   left: `Const`,\n- right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites may arbitrarily decide to change, too.', src/librustc_mir/interpret/intern.rs:LL:CC\n+ right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites could observe that mutation.', src/librustc_mir/interpret/intern.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic"}]}