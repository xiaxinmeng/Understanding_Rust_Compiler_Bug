{"sha": "e55c53c57e953a4f5716461dbaf4af5d623d80da", "node_id": "C_kwDOAAsO6NoAKGU1NWM1M2M1N2U5NTNhNGY1NzE2NDYxZGJhZjRhZjVkNjIzZDgwZGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-23T13:33:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-23T13:33:56Z"}, "message": "Auto merge of #97925 - the8472:cgroupv1, r=joshtriplett\n\nAdd cgroupv1 support to available_parallelism\n\nFixes #97549\n\nMy dev machine uses cgroup v2 so I was only able to test that code path. So the v1 code path is written only based on documentation. I could use some help testing that it works on a machine with cgroups v1:\n\n```\n$ x.py build --stage 1\n\n# quota.rs\nfn main() {\n    println!(\"{:?}\", std::thread::available_parallelism());\n}\n\n# assuming stage1 is linked in rustup\n$ rust +stage1 quota.rs\n\n# spawn a new cgroup scope for the current user\n$ sudo systemd-run -p CPUQuota=\"300%\" --uid=$(id -u) -tdS\n\n# should print Ok(3)\n$ ./quota\n```\n\nIf it doesn't work as expected an strace, the contents of `/proc/self/cgroups` and the structure of `/sys/fs/cgroups` would help.", "tree": {"sha": "8b73737293b99669118647a024ceb51c2e2ee047", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b73737293b99669118647a024ceb51c2e2ee047"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e55c53c57e953a4f5716461dbaf4af5d623d80da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e55c53c57e953a4f5716461dbaf4af5d623d80da", "html_url": "https://github.com/rust-lang/rust/commit/e55c53c57e953a4f5716461dbaf4af5d623d80da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e55c53c57e953a4f5716461dbaf4af5d623d80da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e43d068ced2162bc57da332094c06604bc1b191", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e43d068ced2162bc57da332094c06604bc1b191", "html_url": "https://github.com/rust-lang/rust/commit/2e43d068ced2162bc57da332094c06604bc1b191"}, {"sha": "2e33c812e8b1bea563893f17ff5edcb7023d5d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e33c812e8b1bea563893f17ff5edcb7023d5d41", "html_url": "https://github.com/rust-lang/rust/commit/2e33c812e8b1bea563893f17ff5edcb7023d5d41"}], "stats": {"total": 243, "additions": 196, "deletions": 47}, "files": [{"sha": "6b0c0ad7c2166c0b108a70a79c4682a1c3b4af86", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e55c53c57e953a4f5716461dbaf4af5d623d80da/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e55c53c57e953a4f5716461dbaf4af5d623d80da/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e55c53c57e953a4f5716461dbaf4af5d623d80da", "patch": "@@ -276,6 +276,7 @@\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n+#![feature(is_some_with)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_write_slice)]\n #![feature(mixed_integer_ops)]"}, {"sha": "36a3fa6023bfb1424771ba6a859d4bcd63e35986", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 189, "deletions": 46, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/e55c53c57e953a4f5716461dbaf4af5d623d80da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e55c53c57e953a4f5716461dbaf4af5d623d80da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=e55c53c57e953a4f5716461dbaf4af5d623d80da", "patch": "@@ -285,7 +285,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         ))] {\n             #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n             {\n-                let quota = cgroup2_quota().max(1);\n+                let quota = cgroups::quota().max(1);\n                 let mut set: libc::cpu_set_t = unsafe { mem::zeroed() };\n                 unsafe {\n                     if libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) == 0 {\n@@ -379,49 +379,88 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n     }\n }\n \n-/// Returns cgroup CPU quota in core-equivalents, rounded down, or usize::MAX if the quota cannot\n-/// be determined or is not set.\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n-fn cgroup2_quota() -> usize {\n+mod cgroups {\n+    //! Currently not covered\n+    //! * cgroup v2 in non-standard mountpoints\n+    //! * paths containing control characters or spaces, since those would be escaped in procfs\n+    //!   output and we don't unescape\n+    use crate::borrow::Cow;\n     use crate::ffi::OsString;\n     use crate::fs::{try_exists, File};\n     use crate::io::Read;\n+    use crate::io::{BufRead, BufReader};\n     use crate::os::unix::ffi::OsStringExt;\n+    use crate::path::Path;\n     use crate::path::PathBuf;\n+    use crate::str::from_utf8;\n \n-    let mut quota = usize::MAX;\n-    if cfg!(miri) {\n-        // Attempting to open a file fails under default flags due to isolation.\n-        // And Miri does not have parallelism anyway.\n-        return quota;\n-    }\n-\n-    let _: Option<()> = try {\n-        let mut buf = Vec::with_capacity(128);\n-        // find our place in the cgroup hierarchy\n-        File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n-        let cgroup_path = buf\n-            .split(|&c| c == b'\\n')\n-            .filter_map(|line| {\n-                let mut fields = line.splitn(3, |&c| c == b':');\n-                // expect cgroupv2 which has an empty 2nd field\n-                if fields.nth(1) != Some(b\"\") {\n-                    return None;\n-                }\n-                let path = fields.last()?;\n-                // skip leading slash\n-                Some(path[1..].to_owned())\n-            })\n-            .next()?;\n-        let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n+    #[derive(PartialEq)]\n+    enum Cgroup {\n+        V1,\n+        V2,\n+    }\n+\n+    /// Returns cgroup CPU quota in core-equivalents, rounded down or usize::MAX if the quota cannot\n+    /// be determined or is not set.\n+    pub(super) fn quota() -> usize {\n+        let mut quota = usize::MAX;\n+        if cfg!(miri) {\n+            // Attempting to open a file fails under default flags due to isolation.\n+            // And Miri does not have parallelism anyway.\n+            return quota;\n+        }\n+\n+        let _: Option<()> = try {\n+            let mut buf = Vec::with_capacity(128);\n+            // find our place in the cgroup hierarchy\n+            File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n+            let (cgroup_path, version) =\n+                buf.split(|&c| c == b'\\n').fold(None, |previous, line| {\n+                    let mut fields = line.splitn(3, |&c| c == b':');\n+                    // 2nd field is a list of controllers for v1 or empty for v2\n+                    let version = match fields.nth(1) {\n+                        Some(b\"\") => Cgroup::V2,\n+                        Some(controllers)\n+                            if from_utf8(controllers)\n+                                .is_ok_and(|c| c.split(\",\").any(|c| c == \"cpu\")) =>\n+                        {\n+                            Cgroup::V1\n+                        }\n+                        _ => return previous,\n+                    };\n+\n+                    // already-found v1 trumps v2 since it explicitly specifies its controllers\n+                    if previous.is_some() && version == Cgroup::V2 {\n+                        return previous;\n+                    }\n+\n+                    let path = fields.last()?;\n+                    // skip leading slash\n+                    Some((path[1..].to_owned(), version))\n+                })?;\n+            let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n+\n+            quota = match version {\n+                Cgroup::V1 => quota_v1(cgroup_path),\n+                Cgroup::V2 => quota_v2(cgroup_path),\n+            };\n+        };\n+\n+        quota\n+    }\n+\n+    fn quota_v2(group_path: PathBuf) -> usize {\n+        let mut quota = usize::MAX;\n \n         let mut path = PathBuf::with_capacity(128);\n         let mut read_buf = String::with_capacity(20);\n \n+        // standard mount location defined in file-hierarchy(7) manpage\n         let cgroup_mount = \"/sys/fs/cgroup\";\n \n         path.push(cgroup_mount);\n-        path.push(&cgroup_path);\n+        path.push(&group_path);\n \n         path.push(\"cgroup.controllers\");\n \n@@ -432,30 +471,134 @@ fn cgroup2_quota() -> usize {\n \n         path.pop();\n \n-        while path.starts_with(cgroup_mount) {\n-            path.push(\"cpu.max\");\n+        let _: Option<()> = try {\n+            while path.starts_with(cgroup_mount) {\n+                path.push(\"cpu.max\");\n+\n+                read_buf.clear();\n+\n+                if File::open(&path).and_then(|mut f| f.read_to_string(&mut read_buf)).is_ok() {\n+                    let raw_quota = read_buf.lines().next()?;\n+                    let mut raw_quota = raw_quota.split(' ');\n+                    let limit = raw_quota.next()?;\n+                    let period = raw_quota.next()?;\n+                    match (limit.parse::<usize>(), period.parse::<usize>()) {\n+                        (Ok(limit), Ok(period)) => {\n+                            quota = quota.min(limit / period);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n \n-            read_buf.clear();\n+                path.pop(); // pop filename\n+                path.pop(); // pop dir\n+            }\n+        };\n \n-            if File::open(&path).and_then(|mut f| f.read_to_string(&mut read_buf)).is_ok() {\n-                let raw_quota = read_buf.lines().next()?;\n-                let mut raw_quota = raw_quota.split(' ');\n-                let limit = raw_quota.next()?;\n-                let period = raw_quota.next()?;\n-                match (limit.parse::<usize>(), period.parse::<usize>()) {\n-                    (Ok(limit), Ok(period)) => {\n-                        quota = quota.min(limit / period);\n-                    }\n+        quota\n+    }\n+\n+    fn quota_v1(group_path: PathBuf) -> usize {\n+        let mut quota = usize::MAX;\n+        let mut path = PathBuf::with_capacity(128);\n+        let mut read_buf = String::with_capacity(20);\n+\n+        // Hardcode commonly used locations mentioned in the cgroups(7) manpage\n+        // if that doesn't work scan mountinfo and adjust `group_path` for bind-mounts\n+        let mounts: &[fn(&Path) -> Option<(_, &Path)>] = &[\n+            |p| Some((Cow::Borrowed(\"/sys/fs/cgroup/cpu\"), p)),\n+            |p| Some((Cow::Borrowed(\"/sys/fs/cgroup/cpu,cpuacct\"), p)),\n+            // this can be expensive on systems with tons of mountpoints\n+            // but we only get to this point when /proc/self/cgroups explicitly indicated\n+            // this process belongs to a cpu-controller cgroup v1 and the defaults didn't work\n+            find_mountpoint,\n+        ];\n+\n+        for mount in mounts {\n+            let Some((mount, group_path)) = mount(&group_path) else { continue };\n+\n+            path.clear();\n+            path.push(mount.as_ref());\n+            path.push(&group_path);\n+\n+            // skip if we guessed the mount incorrectly\n+            if matches!(try_exists(&path), Err(_) | Ok(false)) {\n+                continue;\n+            }\n+\n+            while path.starts_with(mount.as_ref()) {\n+                let mut parse_file = |name| {\n+                    path.push(name);\n+                    read_buf.clear();\n+\n+                    let f = File::open(&path);\n+                    path.pop(); // restore buffer before any early returns\n+                    f.ok()?.read_to_string(&mut read_buf).ok()?;\n+                    let parsed = read_buf.trim().parse::<usize>().ok()?;\n+\n+                    Some(parsed)\n+                };\n+\n+                let limit = parse_file(\"cpu.cfs_quota_us\");\n+                let period = parse_file(\"cpu.cfs_period_us\");\n+\n+                match (limit, period) {\n+                    (Some(limit), Some(period)) => quota = quota.min(limit / period),\n                     _ => {}\n                 }\n+\n+                path.pop();\n             }\n \n-            path.pop(); // pop filename\n-            path.pop(); // pop dir\n+            // we passed the try_exists above so we should have traversed the correct hierarchy\n+            // when reaching this line\n+            break;\n         }\n-    };\n \n-    quota\n+        quota\n+    }\n+\n+    /// Scan mountinfo for cgroup v1 mountpoint with a cpu controller\n+    ///\n+    /// If the cgroupfs is a bind mount then `group_path` is adjusted to skip\n+    /// over the already-included prefix\n+    fn find_mountpoint(group_path: &Path) -> Option<(Cow<'static, str>, &Path)> {\n+        let mut reader = BufReader::new(File::open(\"/proc/self/mountinfo\").ok()?);\n+        let mut line = String::with_capacity(256);\n+        loop {\n+            line.clear();\n+            if reader.read_line(&mut line).ok()? == 0 {\n+                break;\n+            }\n+\n+            let line = line.trim();\n+            let mut items = line.split(' ');\n+\n+            let sub_path = items.nth(3)?;\n+            let mount_point = items.next()?;\n+            let mount_opts = items.next_back()?;\n+            let filesystem_type = items.nth_back(1)?;\n+\n+            if filesystem_type != \"cgroup\" || !mount_opts.split(',').any(|opt| opt == \"cpu\") {\n+                // not a cgroup / not a cpu-controller\n+                continue;\n+            }\n+\n+            let sub_path = Path::new(sub_path).strip_prefix(\"/\").ok()?;\n+\n+            if !group_path.starts_with(sub_path) {\n+                // this is a bind-mount and the bound subdirectory\n+                // does not contain the cgroup this process belongs to\n+                continue;\n+            }\n+\n+            let trimmed_group_path = group_path.strip_prefix(sub_path).ok()?;\n+\n+            return Some((Cow::Owned(mount_point.to_owned()), trimmed_group_path));\n+        }\n+\n+        None\n+    }\n }\n \n #[cfg(all("}, {"sha": "44c8a50fd860a0a121df1ef5d00d2b8bbb7b45c2", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e55c53c57e953a4f5716461dbaf4af5d623d80da/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e55c53c57e953a4f5716461dbaf4af5d623d80da/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=e55c53c57e953a4f5716461dbaf4af5d623d80da", "patch": "@@ -1577,10 +1577,15 @@ fn _assert_sync_and_send() {\n ///\n /// On Linux:\n /// - It may overcount the amount of parallelism available when limited by a\n-///   process-wide affinity mask or cgroup quotas and cgroup2 fs or `sched_getaffinity()` can't be\n+///   process-wide affinity mask or cgroup quotas and `sched_getaffinity()` or cgroup fs can't be\n ///   queried, e.g. due to sandboxing.\n /// - It may undercount the amount of parallelism if the current thread's affinity mask\n ///   does not reflect the process' cpuset, e.g. due to pinned threads.\n+/// - If the process is in a cgroup v1 cpu controller, this may need to\n+///   scan mountpoints to find the corresponding cgroup v1 controller,\n+///   which may take time on systems with large numbers of mountpoints.\n+///   (This does not apply to cgroup v2, or to processes not in a\n+///   cgroup.)\n ///\n /// On all targets:\n /// - It may overcount the amount of parallelism available when running in a VM"}]}