{"sha": "084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NGVkYzQyNmYyZTdlNGJiZWRiNWM2YWZhN2ZjNDIyYTUyZWUzNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-26T00:11:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-26T00:11:36Z"}, "message": "Auto merge of #63812 - eddyb:promo-sanity, r=oli-obk\n\nrustc_mir: double-check const-promotion candidates for sanity.\n\nPreviously, const promotion involved tracking information about the value in a MIR local (or any part of the computation leading up to that value), aka \"qualifs\", in a quite stateful manner, which is hard to extend to arbitrary CFGs without a dataflow pass.\n\nHowever, the nature of the promotion we do is that it's effectively an SSA-like \"tree\" (or DAG, really), of assigned-once locals - which is how we can take them from the original MIR in the first place.\nThis structure means that the subset of the MIR responsible for computing any given part of a const-promoted value is readily analyzable by walking that tree/DAG.\n\nThis PR implements such an analysis in `promote_consts`, reusing the `HasMutInterior` / `NeedsDrop` computation from `qualify_consts`, but reimplementing the equivalent of `IsNotPromotable` / `IsNotImplicitlyPromotable`.\n\nEventually we should be able to remove `IsNotPromotable` / `IsNotImplicitlyPromotable` from `qualify_consts`, which will simplify @ecstatic-morse's dataflow-based const-checking efforts.\n\nBut currently this is mainly for a crater check-only run - it will compare the results from the old promotion collection and the new promotion validation and ICE if they don't match.\n\nr? @oli-obk", "tree": {"sha": "75bc17685ea3dfdba8b1660405e3d2a9bb516a34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75bc17685ea3dfdba8b1660405e3d2a9bb516a34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "html_url": "https://github.com/rust-lang/rust/commit/084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "246be7e1a557b8ac8287c6842379a0db67770be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/246be7e1a557b8ac8287c6842379a0db67770be6", "html_url": "https://github.com/rust-lang/rust/commit/246be7e1a557b8ac8287c6842379a0db67770be6"}, {"sha": "f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "html_url": "https://github.com/rust-lang/rust/commit/f2c8628920b73f546b6d1a64babd7e8a481a9b9f"}], "stats": {"total": 846, "additions": 789, "deletions": 57}, "files": [{"sha": "0c643f462432ebbf41cb8348981077e7bd87f42b", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, TyCtxt};\n pub use self::qualifs::Qualif;\n \n pub mod ops;\n-mod qualifs;\n+pub mod qualifs;\n mod resolver;\n pub mod validation;\n \n@@ -23,6 +23,7 @@ pub struct Item<'mir, 'tcx> {\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: validation::Mode,\n+    for_promotion: bool,\n }\n \n impl Item<'mir, 'tcx> {\n@@ -41,6 +42,28 @@ impl Item<'mir, 'tcx> {\n             def_id,\n             param_env,\n             mode,\n+            for_promotion: false,\n+        }\n+    }\n+\n+    // HACK(eddyb) this is to get around the panic for a runtime fn from `Item::new`.\n+    // Also, it allows promoting `&mut []`.\n+    pub fn for_promotion(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        body: &'mir mir::Body<'tcx>,\n+    ) -> Self {\n+        let param_env = tcx.param_env(def_id);\n+        let mode = validation::Mode::for_item(tcx, def_id)\n+            .unwrap_or(validation::Mode::ConstFn);\n+\n+        Item {\n+            body,\n+            tcx,\n+            def_id,\n+            param_env,\n+            mode,\n+            for_promotion: true,\n         }\n     }\n }"}, {"sha": "e666dd9571f1402cb3da419ce6cd8b00f20ef450", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "patch": "@@ -3,7 +3,6 @@\n use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n use rustc::ty::{self, Ty};\n-use rustc_index::bit_set::BitSet;\n use syntax_pos::DUMMY_SP;\n \n use super::Item as ConstCx;\n@@ -44,7 +43,7 @@ pub trait Qualif {\n \n     fn in_projection_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         if let [proj_base @ .., elem] = place.projection {\n@@ -65,7 +64,7 @@ pub trait Qualif {\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Downcast(..) => qualif,\n \n-                ProjectionElem::Index(local) => qualif || per_local.contains(*local),\n+                ProjectionElem::Index(local) => qualif || per_local(*local),\n             }\n         } else {\n             bug!(\"This should be called if projection is not empty\");\n@@ -74,22 +73,22 @@ pub trait Qualif {\n \n     fn in_projection(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         Self::in_projection_structurally(cx, per_local, place)\n     }\n \n     fn in_place(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n-            } => per_local.contains(*local),\n+            } => per_local(*local),\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n                     kind: StaticKind::Promoted(..),\n@@ -112,7 +111,7 @@ pub trait Qualif {\n \n     fn in_operand(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         operand: &Operand<'tcx>,\n     ) -> bool {\n         match *operand {\n@@ -143,7 +142,7 @@ pub trait Qualif {\n \n     fn in_rvalue_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         rvalue: &Rvalue<'tcx>,\n     ) -> bool {\n         match *rvalue {\n@@ -185,13 +184,17 @@ pub trait Qualif {\n         }\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &impl Fn(Local) -> bool,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> bool {\n         Self::in_rvalue_structurally(cx, per_local, rvalue)\n     }\n \n     fn in_call(\n         cx: &ConstCx<'_, 'tcx>,\n-        _per_local: &BitSet<Local>,\n+        _per_local: &impl Fn(Local) -> bool,\n         _callee: &Operand<'tcx>,\n         _args: &[Operand<'tcx>],\n         return_ty: Ty<'tcx>,\n@@ -216,7 +219,11 @@ impl Qualif for HasMutInterior {\n         !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &impl Fn(Local) -> bool,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> bool {\n         match *rvalue {\n             // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n             // allowed in constants (and the `Checker` will error), and/or it\n@@ -231,12 +238,11 @@ impl Qualif for HasMutInterior {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         ty::Array(..) | ty::Slice(_) if cx.mode == Mode::StaticMut => {},\n \n-                        // FIXME(ecstaticmorse): uncomment the following match arm to stop marking\n-                        // `&mut []` as `HasMutInterior`.\n-                        /*\n-                        ty::Array(_, len) if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n-                            => {},\n-                        */\n+                        // FIXME(eddyb) the `cx.for_promotion` condition\n+                        // seems unnecessary, given that this is merely a ZST.\n+                        ty::Array(_, len)\n+                            if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                                && cx.for_promotion => {},\n \n                         _ => return true,\n                     }\n@@ -275,7 +281,11 @@ impl Qualif for NeedsDrop {\n         ty.needs_drop(cx.tcx, cx.param_env)\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &impl Fn(Local) -> bool,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> bool {\n         if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n             if let AggregateKind::Adt(def, ..) = **kind {\n                 if def.has_dtor(cx.tcx) {"}, {"sha": "d3f1c760724f113000e5b8efd6d0fcbd27dba418", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "patch": "@@ -81,7 +81,13 @@ where\n         return_place: &mir::Place<'tcx>,\n     ) {\n         let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n-        let qualif = Q::in_call(self.item, &mut self.qualifs_per_local, func, args, return_ty);\n+        let qualif = Q::in_call(\n+            self.item,\n+            &|l| self.qualifs_per_local.contains(l),\n+            func,\n+            args,\n+            return_ty,\n+        );\n         if !return_place.is_indirect() {\n             self.assign_qualif_direct(return_place, qualif);\n         }\n@@ -114,7 +120,7 @@ where\n         rvalue: &mir::Rvalue<'tcx>,\n         location: Location,\n     ) {\n-        let qualif = Q::in_rvalue(self.item, self.qualifs_per_local, rvalue);\n+        let qualif = Q::in_rvalue(self.item, &|l| self.qualifs_per_local.contains(l), rvalue);\n         if !place.is_indirect() {\n             self.assign_qualif_direct(place, qualif);\n         }\n@@ -129,7 +135,7 @@ where\n         // here; that occurs in `apply_call_return_effect`.\n \n         if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n-            let qualif = Q::in_operand(self.item, self.qualifs_per_local, value);\n+            let qualif = Q::in_operand(self.item, &|l| self.qualifs_per_local.contains(l), value);\n             if !dest.is_indirect() {\n                 self.assign_qualif_direct(dest, qualif);\n             }"}, {"sha": "fa74663973656348170209bdf9cc17e57f066993", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "patch": "@@ -369,11 +369,10 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n         // interior mutability.\n         if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n-                &self.item,\n-                self.qualifs.has_mut_interior.get(),\n-                rvalue,\n-            );\n+            let rvalue_has_mut_interior = {\n+                let has_mut_interior = self.qualifs.has_mut_interior.get();\n+                HasMutInterior::in_rvalue(&self.item, &|l| has_mut_interior.contains(l), rvalue)\n+            };\n \n             if rvalue_has_mut_interior {\n                 let is_derived_from_illegal_borrow = match borrowed_place.as_local() {"}, {"sha": "7aaff5735f696a42cd61d51404ca3d886184d67a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 625, "deletions": 14, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "patch": "@@ -12,18 +12,26 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n+use rustc::mir::interpret::ConstValue;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n+use rustc::ty::{self, List, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n-use rustc::ty::{List, TyCtxt};\n-use syntax_pos::Span;\n+use rustc::ty::cast::CastTy;\n+use syntax::ast::LitKind;\n+use syntax::symbol::sym;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_index::vec::{IndexVec, Idx};\n+use rustc_target::spec::abi::Abi;\n \n use std::{iter, mem, usize};\n \n+use crate::transform::check_consts::{qualifs, Item as ConstCx};\n+\n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TempState {\n@@ -57,7 +65,7 @@ impl TempState {\n /// A \"root candidate\" for promotion, which will become the\n /// returned value in a promoted MIR, unless it's a subset\n /// of a larger candidate.\n-#[derive(Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Candidate {\n     /// Borrow of a constant temporary.\n     Ref(Location),\n@@ -73,13 +81,28 @@ pub enum Candidate {\n     Argument { bb: BasicBlock, index: usize },\n }\n \n-struct TempCollector<'tcx> {\n+fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n+    let attrs = tcx.get_attrs(def_id);\n+    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n+    let mut ret = vec![];\n+    for meta in attr.meta_item_list()? {\n+        match meta.literal()?.kind {\n+            LitKind::Int(a, _) => { ret.push(a as usize); }\n+            _ => return None,\n+        }\n+    }\n+    Some(ret)\n+}\n+\n+struct Collector<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n     temps: IndexVec<Local, TempState>,\n+    candidates: Vec<Candidate>,\n     span: Span,\n-    body: &'tcx Body<'tcx>,\n }\n \n-impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n+impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n     fn visit_local(&mut self,\n                    &index: &Local,\n                    context: PlaceContext,\n@@ -134,22 +157,610 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n         *temp = TempState::Unpromotable;\n     }\n \n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+\n+        match *rvalue {\n+            Rvalue::Ref(..) => {\n+                self.candidates.push(Candidate::Ref(location));\n+            }\n+            Rvalue::Repeat(..) if self.tcx.features().const_in_array_repeat_expressions => {\n+                // FIXME(#49147) only promote the element when it isn't `Copy`\n+                // (so that code that can copy it at runtime is unaffected).\n+                self.candidates.push(Candidate::Repeat(location));\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_terminator_kind(&mut self,\n+                             kind: &TerminatorKind<'tcx>,\n+                             location: Location) {\n+        self.super_terminator_kind(kind, location);\n+\n+        if let TerminatorKind::Call { ref func, .. } = *kind {\n+            if let ty::FnDef(def_id, _) = func.ty(self.body, self.tcx).kind {\n+                let fn_sig = self.tcx.fn_sig(def_id);\n+                if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = fn_sig.abi() {\n+                    let name = self.tcx.item_name(def_id);\n+                    // FIXME(eddyb) use `#[rustc_args_required_const(2)]` for shuffles.\n+                    if name.as_str().starts_with(\"simd_shuffle\") {\n+                        self.candidates.push(Candidate::Argument {\n+                            bb: location.block,\n+                            index: 2,\n+                        });\n+                    }\n+                }\n+\n+                if let Some(constant_args) = args_required_const(self.tcx, def_id) {\n+                    for index in constant_args {\n+                        self.candidates.push(Candidate::Argument { bb: location.block, index });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n         self.span = source_info.span;\n     }\n }\n \n-pub fn collect_temps(body: &Body<'_>,\n-                     rpo: &mut ReversePostorder<'_, '_>) -> IndexVec<Local, TempState> {\n-    let mut collector = TempCollector {\n+pub fn collect_temps_and_candidates(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    rpo: &mut ReversePostorder<'_, 'tcx>,\n+) -> (IndexVec<Local, TempState>, Vec<Candidate>) {\n+    let mut collector = Collector {\n+        tcx,\n+        body,\n         temps: IndexVec::from_elem(TempState::Undefined, &body.local_decls),\n+        candidates: vec![],\n         span: body.span,\n-        body,\n     };\n     for (bb, data) in rpo {\n         collector.visit_basic_block_data(bb, data);\n     }\n-    collector.temps\n+    (collector.temps, collector.candidates)\n+}\n+\n+struct Validator<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body: &'a Body<'tcx>,\n+    is_static: bool,\n+    is_static_mut: bool,\n+    is_non_const_fn: bool,\n+    temps: &'a IndexVec<Local, TempState>,\n+\n+    // FIXME(eddyb) deduplicate the data in this vs other fields.\n+    const_cx: ConstCx<'a, 'tcx>,\n+\n+    /// Explicit promotion happens e.g. for constant arguments declared via\n+    /// `rustc_args_required_const`.\n+    /// Implicit promotion has almost the same rules, except that disallows `const fn`\n+    /// except for those marked `#[rustc_promotable]`. This is to avoid changing\n+    /// a legitimate run-time operation into a failing compile-time operation\n+    /// e.g. due to addresses being compared inside the function.\n+    explicit: bool,\n+}\n+\n+struct Unpromotable;\n+\n+impl<'tcx> Validator<'_, 'tcx> {\n+    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n+        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n+        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+    }\n+\n+    fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n+        match candidate {\n+            Candidate::Ref(loc) => {\n+                assert!(!self.explicit);\n+\n+                let statement = &self.body[loc.block].statements[loc.statement_index];\n+                match &statement.kind {\n+                    StatementKind::Assign(box(_, Rvalue::Ref(_, kind, place))) => {\n+                        match kind {\n+                            BorrowKind::Shared | BorrowKind::Mut { .. } => {}\n+\n+                            // FIXME(eddyb) these aren't promoted here but *could*\n+                            // be promoted as part of a larger value because\n+                            // `validate_rvalue`  doesn't check them, need to\n+                            // figure out what is the intended behavior.\n+                            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n+                        }\n+\n+                        // We can only promote interior borrows of promotable temps (non-temps\n+                        // don't get promoted anyway).\n+                        let base = match place.base {\n+                            PlaceBase::Local(local) => local,\n+                            _ => return Err(Unpromotable),\n+                        };\n+                        self.validate_local(base)?;\n+\n+                        if place.projection.contains(&ProjectionElem::Deref) {\n+                            return Err(Unpromotable);\n+                        }\n+\n+                        let mut has_mut_interior =\n+                            self.qualif_local::<qualifs::HasMutInterior>(base);\n+                        // HACK(eddyb) this should compute the same thing as\n+                        // `<HasMutInterior as Qualif>::in_projection` from\n+                        // `check_consts::qualifs` but without recursion.\n+                        if has_mut_interior {\n+                            // This allows borrowing fields which don't have\n+                            // `HasMutInterior`, from a type that does, e.g.:\n+                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                            let mut place_projection = &place.projection[..];\n+                            // FIXME(eddyb) use a forward loop instead of a reverse one.\n+                            while let [proj_base @ .., elem] = place_projection {\n+                                // FIXME(eddyb) this is probably excessive, with\n+                                // the exception of `union` member accesses.\n+                                let ty =\n+                                    Place::ty_from(&place.base, proj_base, self.body, self.tcx)\n+                                        .projection_ty(self.tcx, elem)\n+                                        .ty;\n+                                if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n+                                    has_mut_interior = false;\n+                                    break;\n+                                }\n+\n+                                place_projection = proj_base;\n+                            }\n+                        }\n+\n+                        // FIXME(eddyb) this duplicates part of `validate_rvalue`.\n+                        if has_mut_interior {\n+                            return Err(Unpromotable);\n+                        }\n+                        if self.qualif_local::<qualifs::NeedsDrop>(base) {\n+                            return Err(Unpromotable);\n+                        }\n+                        if let BorrowKind::Mut { .. } = kind {\n+                            let ty = place.ty(self.body, self.tcx).ty;\n+\n+                            // In theory, any zero-sized value could be borrowed\n+                            // mutably without consequences. However, only &mut []\n+                            // is allowed right now, and only in functions.\n+                            if self.is_static_mut {\n+                                // Inside a `static mut`, &mut [...] is also allowed.\n+                                match ty.kind {\n+                                    ty::Array(..) | ty::Slice(_) => {}\n+                                    _ => return Err(Unpromotable),\n+                                }\n+                            } else if let ty::Array(_, len) = ty.kind {\n+                                // FIXME(eddyb) the `self.is_non_const_fn` condition\n+                                // seems unnecessary, given that this is merely a ZST.\n+                                match len.try_eval_usize(self.tcx, self.param_env) {\n+                                    Some(0) if self.is_non_const_fn => {},\n+                                    _ => return Err(Unpromotable),\n+                                }\n+                            } else {\n+                                return Err(Unpromotable);\n+                            }\n+                        }\n+\n+                        Ok(())\n+                    }\n+                    _ => bug!()\n+                }\n+            }\n+            Candidate::Repeat(loc) => {\n+                assert!(!self.explicit);\n+\n+                let statement = &self.body[loc.block].statements[loc.statement_index];\n+                match &statement.kind {\n+                    StatementKind::Assign(box(_, Rvalue::Repeat(ref operand, _))) => {\n+                        if !self.tcx.features().const_in_array_repeat_expressions {\n+                            return Err(Unpromotable);\n+                        }\n+\n+                        self.validate_operand(operand)\n+                    }\n+                    _ => bug!()\n+                }\n+            },\n+            Candidate::Argument { bb, index } => {\n+                assert!(self.explicit);\n+\n+                let terminator = self.body[bb].terminator();\n+                match &terminator.kind {\n+                    TerminatorKind::Call { args, .. } => {\n+                        self.validate_operand(&args[index])\n+                    }\n+                    _ => bug!()\n+                }\n+            }\n+        }\n+    }\n+\n+    // FIXME(eddyb) maybe cache this?\n+    fn qualif_local<Q: qualifs::Qualif>(&self, local: Local) -> bool {\n+        let per_local = &|l| self.qualif_local::<Q>(l);\n+\n+        if let TempState::Defined { location: loc, .. } = self.temps[local] {\n+            let num_stmts = self.body[loc.block].statements.len();\n+\n+            if loc.statement_index < num_stmts {\n+                let statement = &self.body[loc.block].statements[loc.statement_index];\n+                match &statement.kind {\n+                    StatementKind::Assign(box(_, rhs)) => {\n+                        Q::in_rvalue(&self.const_cx, per_local, rhs)\n+                    }\n+                    _ => {\n+                        span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n+                                statement);\n+                    }\n+                }\n+            } else {\n+                let terminator = self.body[loc.block].terminator();\n+                match &terminator.kind {\n+                    TerminatorKind::Call { func, args, .. } => {\n+                        let return_ty = self.body.local_decls[local].ty;\n+                        Q::in_call(&self.const_cx, per_local, func, args, return_ty)\n+                    }\n+                    kind => {\n+                        span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+                    }\n+                }\n+            }\n+        } else {\n+            let span = self.body.local_decls[local].source_info.span;\n+            span_bug!(span, \"{:?} not promotable, qualif_local shouldn't have been called\", local);\n+        }\n+    }\n+\n+    // FIXME(eddyb) maybe cache this?\n+    fn validate_local(&self, local: Local) -> Result<(), Unpromotable> {\n+        if let TempState::Defined { location: loc, .. } = self.temps[local] {\n+            let num_stmts = self.body[loc.block].statements.len();\n+\n+            if loc.statement_index < num_stmts {\n+                let statement = &self.body[loc.block].statements[loc.statement_index];\n+                match &statement.kind {\n+                    StatementKind::Assign(box(_, rhs)) => self.validate_rvalue(rhs),\n+                    _ => {\n+                        span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n+                                statement);\n+                    }\n+                }\n+            } else {\n+                let terminator = self.body[loc.block].terminator();\n+                match &terminator.kind {\n+                    TerminatorKind::Call { func, args, .. } => self.validate_call(func, args),\n+                    kind => {\n+                        span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+                    }\n+                }\n+            }\n+        } else {\n+            Err(Unpromotable)\n+        }\n+    }\n+\n+    fn validate_place(&self, place: PlaceRef<'_, 'tcx>) -> Result<(), Unpromotable> {\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: [],\n+            } => self.validate_local(*local),\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted { .. },\n+                    ..\n+                }),\n+                projection: [],\n+            } => bug!(\"qualifying already promoted MIR\"),\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Static,\n+                    def_id,\n+                    ..\n+                }),\n+                projection: [],\n+            } => {\n+                // Only allow statics (not consts) to refer to other statics.\n+                // FIXME(eddyb) does this matter at all for promotion?\n+                let allowed = self.is_static || self.is_static_mut;\n+                if !allowed {\n+                    return Err(Unpromotable);\n+                }\n+\n+                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n+                if is_thread_local {\n+                    return Err(Unpromotable);\n+                }\n+\n+                Ok(())\n+            }\n+            PlaceRef {\n+                base: _,\n+                projection: [proj_base @ .., elem],\n+            } => {\n+                match *elem {\n+                    ProjectionElem::Deref |\n+                    ProjectionElem::Downcast(..) => return Err(Unpromotable),\n+\n+                    ProjectionElem::ConstantIndex {..} |\n+                    ProjectionElem::Subslice {..} => {}\n+\n+                    ProjectionElem::Index(local) => {\n+                        self.validate_local(local)?;\n+                    }\n+\n+                    ProjectionElem::Field(..) => {\n+                        if self.is_non_const_fn {\n+                            let base_ty =\n+                                Place::ty_from(place.base, proj_base, self.body, self.tcx).ty;\n+                            if let Some(def) = base_ty.ty_adt_def() {\n+                                // No promotion of union field accesses.\n+                                if def.is_union() {\n+                                    return Err(Unpromotable);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                self.validate_place(PlaceRef {\n+                    base: place.base,\n+                    projection: proj_base,\n+                })\n+            }\n+        }\n+    }\n+\n+    fn validate_operand(&self, operand: &Operand<'tcx>) -> Result<(), Unpromotable> {\n+        match operand {\n+            Operand::Copy(place) |\n+            Operand::Move(place) => self.validate_place(place.as_ref()),\n+\n+            Operand::Constant(constant) => {\n+                if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n+                    if self.tcx.trait_of_item(def_id).is_some() {\n+                        // Don't peek inside trait associated constants.\n+                        // (see below what we do for other consts, for now)\n+                    } else {\n+                        // HACK(eddyb) ensure that errors propagate correctly.\n+                        // FIXME(eddyb) remove this once the old promotion logic\n+                        // is gone - we can always promote constants even if they\n+                        // fail to pass const-checking, as compilation would've\n+                        // errored independently and promotion can't change that.\n+                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        if bits == super::qualify_consts::QUALIF_ERROR_BIT {\n+                            self.tcx.sess.delay_span_bug(\n+                                constant.span,\n+                                \"promote_consts: MIR had errors\",\n+                            );\n+                            return Err(Unpromotable);\n+                        }\n+                    }\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n+        match *rvalue {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.is_non_const_fn => {\n+                let operand_ty = operand.ty(self.body, self.tcx);\n+                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                match (cast_in, cast_out) {\n+                    (CastTy::Ptr(_), CastTy::Int(_)) |\n+                    (CastTy::FnPtr, CastTy::Int(_)) => {\n+                        // in normal functions, mark such casts as not promotable\n+                        return Err(Unpromotable);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, _) if self.is_non_const_fn => {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n+                            op == BinOp::Le || op == BinOp::Lt ||\n+                            op == BinOp::Ge || op == BinOp::Gt ||\n+                            op == BinOp::Offset);\n+\n+                    // raw pointer operations are not allowed inside promoteds\n+                    return Err(Unpromotable);\n+                }\n+            }\n+\n+            Rvalue::NullaryOp(NullOp::Box, _) => return Err(Unpromotable),\n+\n+            _ => {}\n+        }\n+\n+        match rvalue {\n+            Rvalue::NullaryOp(..) => Ok(()),\n+\n+            Rvalue::Discriminant(place) |\n+            Rvalue::Len(place) => self.validate_place(place.as_ref()),\n+\n+            Rvalue::Use(operand) |\n+            Rvalue::Repeat(operand, _) |\n+            Rvalue::UnaryOp(_, operand) |\n+            Rvalue::Cast(_, operand, _) => self.validate_operand(operand),\n+\n+            Rvalue::BinaryOp(_, lhs, rhs) |\n+            Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n+                self.validate_operand(lhs)?;\n+                self.validate_operand(rhs)\n+            }\n+\n+            Rvalue::Ref(_, kind, place) => {\n+                if let BorrowKind::Mut { .. } = kind {\n+                    let ty = place.ty(self.body, self.tcx).ty;\n+\n+                    // In theory, any zero-sized value could be borrowed\n+                    // mutably without consequences. However, only &mut []\n+                    // is allowed right now, and only in functions.\n+                    if self.is_static_mut {\n+                        // Inside a `static mut`, &mut [...] is also allowed.\n+                        match ty.kind {\n+                            ty::Array(..) | ty::Slice(_) => {}\n+                            _ => return Err(Unpromotable),\n+                        }\n+                    } else if let ty::Array(_, len) = ty.kind {\n+                        // FIXME(eddyb) the `self.is_non_const_fn` condition\n+                        // seems unnecessary, given that this is merely a ZST.\n+                        match len.try_eval_usize(self.tcx, self.param_env) {\n+                            Some(0) if self.is_non_const_fn => {},\n+                            _ => return Err(Unpromotable),\n+                        }\n+                    } else {\n+                        return Err(Unpromotable);\n+                    }\n+                }\n+\n+                // Special-case reborrows to be more like a copy of the reference.\n+                let mut place = place.as_ref();\n+                if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n+                    let base_ty =\n+                        Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+                    if let ty::Ref(..) = base_ty.kind {\n+                        place = PlaceRef {\n+                            base: &place.base,\n+                            projection: proj_base,\n+                        };\n+                    }\n+                }\n+\n+                self.validate_place(place)?;\n+\n+                // HACK(eddyb) this should compute the same thing as\n+                // `<HasMutInterior as Qualif>::in_projection` from\n+                // `check_consts::qualifs` but without recursion.\n+                let mut has_mut_interior = match place.base {\n+                    PlaceBase::Local(local) => {\n+                        self.qualif_local::<qualifs::HasMutInterior>(*local)\n+                    }\n+                    PlaceBase::Static(_) => false,\n+                };\n+                if has_mut_interior {\n+                    let mut place_projection = place.projection;\n+                    // FIXME(eddyb) use a forward loop instead of a reverse one.\n+                    while let [proj_base @ .., elem] = place_projection {\n+                        // FIXME(eddyb) this is probably excessive, with\n+                        // the exception of `union` member accesses.\n+                        let ty = Place::ty_from(place.base, proj_base, self.body, self.tcx)\n+                            .projection_ty(self.tcx, elem)\n+                            .ty;\n+                        if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n+                            has_mut_interior = false;\n+                            break;\n+                        }\n+\n+                        place_projection = proj_base;\n+                    }\n+                }\n+                if has_mut_interior {\n+                    return Err(Unpromotable);\n+                }\n+\n+                Ok(())\n+            }\n+\n+            Rvalue::Aggregate(_, ref operands) => {\n+                for o in operands {\n+                    self.validate_operand(o)?;\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn validate_call(\n+        &self,\n+        callee: &Operand<'tcx>,\n+        args: &[Operand<'tcx>],\n+    ) -> Result<(), Unpromotable> {\n+        let fn_ty = callee.ty(self.body, self.tcx);\n+\n+        if !self.explicit && self.is_non_const_fn {\n+            if let ty::FnDef(def_id, _) = fn_ty.kind {\n+                // Never promote runtime `const fn` calls of\n+                // functions without `#[rustc_promotable]`.\n+                if !self.tcx.is_promotable_const_fn(def_id) {\n+                    return Err(Unpromotable);\n+                }\n+            }\n+        }\n+\n+        let is_const_fn = match fn_ty.kind {\n+            ty::FnDef(def_id, _) => {\n+                self.tcx.is_const_fn(def_id) ||\n+                self.tcx.is_unstable_const_fn(def_id).is_some() ||\n+                self.is_const_panic_fn(def_id)\n+            }\n+            _ => false,\n+        };\n+        if !is_const_fn {\n+            return Err(Unpromotable);\n+        }\n+\n+        self.validate_operand(callee)?;\n+        for arg in args {\n+            self.validate_operand(arg)?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+pub fn validate_candidates(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+    temps: &IndexVec<Local, TempState>,\n+    candidates: &[Candidate],\n+) -> Vec<Candidate> {\n+    let mut validator = Validator {\n+        tcx,\n+        param_env: tcx.param_env(def_id),\n+        body,\n+        is_static: false,\n+        is_static_mut: false,\n+        is_non_const_fn: false,\n+        temps,\n+\n+        const_cx: ConstCx::for_promotion(tcx, def_id, body),\n+\n+        explicit: false,\n+    };\n+\n+    // FIXME(eddyb) remove the distinctions that make this necessary.\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    match tcx.hir().body_owner_kind(id) {\n+        hir::BodyOwnerKind::Closure => validator.is_non_const_fn = true,\n+        hir::BodyOwnerKind::Fn => {\n+            if !tcx.is_const_fn(def_id) {\n+                validator.is_non_const_fn = true;\n+            }\n+        },\n+        hir::BodyOwnerKind::Static(hir::MutImmutable) => validator.is_static = true,\n+        hir::BodyOwnerKind::Static(hir::MutMutable) => validator.is_static_mut = true,\n+        _ => {}\n+    }\n+\n+    candidates.iter().copied().filter(|&candidate| {\n+        validator.explicit = match candidate {\n+            Candidate::Ref(_) |\n+            Candidate::Repeat(_) => false,\n+            Candidate::Argument { .. } => true,\n+        };\n+\n+        // FIXME(eddyb) also emit the errors for shuffle indices\n+        // and `#[rustc_args_required_const]` arguments here.\n+\n+        validator.validate_candidate(candidate).is_ok()\n+    }).collect()\n }\n \n struct Promoter<'a, 'tcx> {\n@@ -215,17 +826,17 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             self.temps[temp] = TempState::PromotedOut;\n         }\n \n-        let no_stmts = self.source[loc.block].statements.len();\n+        let num_stmts = self.source[loc.block].statements.len();\n         let new_temp = self.promoted.local_decls.push(\n             LocalDecl::new_temp(self.source.local_decls[temp].ty,\n                                 self.source.local_decls[temp].source_info.span));\n \n         debug!(\"promote({:?} @ {:?}/{:?}, {:?})\",\n-               temp, loc, no_stmts, self.keep_original);\n+               temp, loc, num_stmts, self.keep_original);\n \n         // First, take the Rvalue or Call out of the source MIR,\n         // or duplicate it, depending on keep_original.\n-        if loc.statement_index < no_stmts {\n+        if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n                 let rhs = match statement.kind {"}, {"sha": "21feeb1fad61d00cf84fde9ff4ef909eb97f9051", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 99, "deletions": 16, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/084edc426f2e7e4bbedb5c6afa7fc422a52ee379/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "patch": "@@ -206,6 +206,9 @@ trait Qualif {\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Downcast(..) => qualif,\n \n+                // FIXME(eddyb) shouldn't this be masked *after* including the\n+                // index local? Then again, it's `usize` which is neither\n+                // `HasMutInterior` nor `NeedsDrop`.\n                 ProjectionElem::Index(local) => qualif || Self::in_local(cx, *local),\n             }\n         } else {\n@@ -442,6 +445,7 @@ impl Qualif for IsNotPromotable {\n             StaticKind::Promoted(_, _) => unreachable!(),\n             StaticKind::Static => {\n                 // Only allow statics (not consts) to refer to other statics.\n+                // FIXME(eddyb) does this matter at all for promotion?\n                 let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n \n                 !allowed ||\n@@ -674,6 +678,7 @@ struct Checker<'a, 'tcx> {\n \n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>,\n+    unchecked_promotion_candidates: Vec<Candidate>,\n \n     /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n     suppress_errors: bool,\n@@ -703,7 +708,8 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n         assert!(def_id.is_local());\n         let mut rpo = traversal::reverse_postorder(body);\n-        let temps = promote_consts::collect_temps(body, &mut rpo);\n+        let (temps, unchecked_promotion_candidates) =\n+            promote_consts::collect_temps_and_candidates(tcx, body, &mut rpo);\n         rpo.reset();\n \n         let param_env = tcx.param_env(def_id);\n@@ -742,6 +748,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             rpo,\n             temp_promotion_state: temps,\n             promotion_candidates: vec![],\n+            unchecked_promotion_candidates,\n             errors: vec![],\n             suppress_errors: false,\n         }\n@@ -828,6 +835,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n                     // Don't promote BorrowKind::Shallow borrows, as they don't\n                     // reach codegen.\n+                    // FIXME(eddyb) the two other kinds of borrow (`Shallow` and `Unique`)\n+                    // aren't promoted here but *could* be promoted as part of a larger\n+                    // value because `IsNotPromotable` isn't being set for them,\n+                    // need to figure out what is the intended behavior.\n \n                     // We might have a candidate for promotion.\n                     let candidate = Candidate::Ref(location);\n@@ -967,6 +978,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n         let mut bb = START_BLOCK;\n+        let mut has_controlflow_error = false;\n         loop {\n             seen_blocks.insert(bb.index());\n \n@@ -1007,6 +1019,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     bb = target;\n                 }\n                 _ => {\n+                    has_controlflow_error = true;\n                     self.not_const(ops::Loop);\n                     validator.check_op(ops::Loop);\n                     break;\n@@ -1036,9 +1049,28 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n \n-        debug!(\"qualify_const: promotion_candidates={:?}\", self.promotion_candidates);\n-        for candidate in &self.promotion_candidates {\n-            match *candidate {\n+        // HACK(eddyb) don't try to validate promotion candidates if any\n+        // parts of the control-flow graph were skipped due to an error.\n+        let promotion_candidates = if has_controlflow_error {\n+            let unleash_miri = self\n+                .tcx\n+                .sess\n+                .opts\n+                .debugging_opts\n+                .unleash_the_miri_inside_of_you;\n+            if !unleash_miri {\n+                self.tcx.sess.delay_span_bug(\n+                    body.span,\n+                    \"check_const: expected control-flow error(s)\",\n+                );\n+            }\n+            self.promotion_candidates.clone()\n+        } else {\n+            self.valid_promotion_candidates()\n+        };\n+        debug!(\"qualify_const: promotion_candidates={:?}\", promotion_candidates);\n+        for candidate in promotion_candidates {\n+            match candidate {\n                 Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(box(_, Rvalue::Repeat(\n                         Operand::Move(place),\n@@ -1075,6 +1107,49 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n     }\n+\n+    /// Get the subset of `unchecked_promotion_candidates` that are eligible\n+    /// for promotion.\n+    // FIXME(eddyb) replace the old candidate gathering with this.\n+    fn valid_promotion_candidates(&self) -> Vec<Candidate> {\n+        // Sanity-check the promotion candidates.\n+        let candidates = promote_consts::validate_candidates(\n+            self.tcx,\n+            self.body,\n+            self.def_id,\n+            &self.temp_promotion_state,\n+            &self.unchecked_promotion_candidates,\n+        );\n+\n+        if candidates != self.promotion_candidates {\n+            let report = |msg, candidate| {\n+                let span = match candidate {\n+                    Candidate::Ref(loc) |\n+                    Candidate::Repeat(loc) => self.body.source_info(loc).span,\n+                    Candidate::Argument { bb, .. } => {\n+                        self.body[bb].terminator().source_info.span\n+                    }\n+                };\n+                self.tcx.sess.span_err(span, &format!(\"{}: {:?}\", msg, candidate));\n+            };\n+\n+            for &c in &self.promotion_candidates {\n+                if !candidates.contains(&c) {\n+                    report(\"invalidated old candidate\", c);\n+                }\n+            }\n+\n+            for &c in &candidates {\n+                if !self.promotion_candidates.contains(&c) {\n+                    report(\"extra new candidate\", c);\n+                }\n+            }\n+\n+            bug!(\"promotion candidate validation mismatches (see above)\");\n+        }\n+\n+        candidates\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n@@ -1644,6 +1719,10 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n+// FIXME(eddyb) this is only left around for the validation logic\n+// in `promote_consts`, see the comment in `validate_operand`.\n+pub(super) const QUALIF_ERROR_BIT: u8 = 1 << IsNotPromotable::IDX;\n+\n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n@@ -1653,7 +1732,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n \n     if body.return_ty().references_error() {\n         tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n-        return (1 << IsNotPromotable::IDX, tcx.arena.alloc(BitSet::new_empty(0)));\n+        return (QUALIF_ERROR_BIT, tcx.arena.alloc(BitSet::new_empty(0)));\n     }\n \n     Checker::new(tcx, def_id, body, Mode::Const).check_const()\n@@ -1695,29 +1774,33 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n             let (temps, candidates) = {\n                 let mut checker = Checker::new(tcx, def_id, body, mode);\n                 if let Mode::ConstFn = mode {\n-                    if tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                        checker.check_const();\n-                    } else if tcx.is_min_const_fn(def_id) {\n+                    let use_min_const_fn_checks =\n+                        !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n+                        tcx.is_min_const_fn(def_id);\n+                    if use_min_const_fn_checks {\n                         // Enforce `min_const_fn` for stable `const fn`s.\n                         use super::qualify_min_const_fn::is_min_const_fn;\n                         if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n                             error_min_const_fn_violation(tcx, span, err);\n-                        } else {\n-                            // this should not produce any errors, but better safe than sorry\n-                            // FIXME(#53819)\n-                            checker.check_const();\n+                            return;\n                         }\n-                    } else {\n-                        // Enforce a constant-like CFG for `const fn`.\n-                        checker.check_const();\n+\n+                        // `check_const` should not produce any errors, but better safe than sorry\n+                        // FIXME(#53819)\n+                        // NOTE(eddyb) `check_const` is actually needed for promotion inside\n+                        // `min_const_fn` functions.\n                     }\n+\n+                    // Enforce a constant-like CFG for `const fn`.\n+                    checker.check_const();\n                 } else {\n                     while let Some((bb, data)) = checker.rpo.next() {\n                         checker.visit_basic_block_data(bb, data);\n                     }\n                 }\n \n-                (checker.temp_promotion_state, checker.promotion_candidates)\n+                let promotion_candidates = checker.valid_promotion_candidates();\n+                (checker.temp_promotion_state, promotion_candidates)\n             };\n \n             // Do the actual promotion, now that we know what's viable."}]}