{"sha": "6e4bb5701433ab8f0809700827c76035d8be4813", "node_id": "C_kwDOAAsO6NoAKDZlNGJiNTcwMTQzM2FiOGYwODA5NzAwODI3Yzc2MDM1ZDhiZTQ4MTM", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-12T16:31:32Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-12T16:31:32Z"}, "message": "simplify", "tree": {"sha": "18bc21fb064415ca11a4ec9ef4e3fdd8863cc73d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18bc21fb064415ca11a4ec9ef4e3fdd8863cc73d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e4bb5701433ab8f0809700827c76035d8be4813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e4bb5701433ab8f0809700827c76035d8be4813", "html_url": "https://github.com/rust-lang/rust/commit/6e4bb5701433ab8f0809700827c76035d8be4813", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e4bb5701433ab8f0809700827c76035d8be4813/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57e6ef0bfbfda17276f7f9c62abee81f3f086f91", "url": "https://api.github.com/repos/rust-lang/rust/commits/57e6ef0bfbfda17276f7f9c62abee81f3f086f91", "html_url": "https://github.com/rust-lang/rust/commit/57e6ef0bfbfda17276f7f9c62abee81f3f086f91"}], "stats": {"total": 70, "additions": 23, "deletions": 47}, "files": [{"sha": "4c891108a60ea0863793e38ff606e8cd9062de6b", "filename": "crates/parser/src/parser.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e4bb5701433ab8f0809700827c76035d8be4813/crates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e4bb5701433ab8f0809700827c76035d8be4813/crates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fparser.rs?ref=6e4bb5701433ab8f0809700827c76035d8be4813", "patch": "@@ -56,7 +56,7 @@ impl<'t> Parser<'t> {\n         assert!(PARSER_STEP_LIMIT.check(steps as usize).is_ok(), \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n \n-        self.tokens.get(self.pos + n).kind\n+        self.tokens.kind(self.pos + n)\n     }\n \n     /// Checks if the current token is `kind`.\n@@ -92,7 +92,7 @@ impl<'t> Parser<'t> {\n             T![<<=] => self.at_composite3(n, T![<], T![<], T![=]),\n             T![>>=] => self.at_composite3(n, T![>], T![>], T![=]),\n \n-            _ => self.tokens.get(self.pos + n).kind == kind,\n+            _ => self.tokens.kind(self.pos + n) == kind,\n         }\n     }\n \n@@ -131,25 +131,17 @@ impl<'t> Parser<'t> {\n     }\n \n     fn at_composite2(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind) -> bool {\n-        let t1 = self.tokens.get(self.pos + n);\n-        if t1.kind != k1 || !t1.is_jointed_to_next {\n-            return false;\n-        }\n-        let t2 = self.tokens.get(self.pos + n + 1);\n-        t2.kind == k2\n+        self.tokens.kind(self.pos + n) == k1\n+            && self.tokens.kind(self.pos + n + 1) == k2\n+            && self.tokens.is_joint(self.pos + n)\n     }\n \n     fn at_composite3(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind, k3: SyntaxKind) -> bool {\n-        let t1 = self.tokens.get(self.pos + n);\n-        if t1.kind != k1 || !t1.is_jointed_to_next {\n-            return false;\n-        }\n-        let t2 = self.tokens.get(self.pos + n + 1);\n-        if t2.kind != k2 || !t2.is_jointed_to_next {\n-            return false;\n-        }\n-        let t3 = self.tokens.get(self.pos + n + 2);\n-        t3.kind == k3\n+        self.tokens.kind(self.pos + n) == k1\n+            && self.tokens.kind(self.pos + n + 1) == k2\n+            && self.tokens.kind(self.pos + n + 2) == k3\n+            && self.tokens.is_joint(self.pos + n)\n+            && self.tokens.is_joint(self.pos + n + 1)\n     }\n \n     /// Checks if the current token is in `kinds`.\n@@ -159,7 +151,7 @@ impl<'t> Parser<'t> {\n \n     /// Checks if the current token is contextual keyword with text `t`.\n     pub(crate) fn at_contextual_kw(&self, kw: SyntaxKind) -> bool {\n-        self.tokens.get(self.pos).contextual_kw == kw\n+        self.tokens.contextual_kind(self.pos) == kw\n     }\n \n     /// Starts a new node in the syntax tree. All nodes and tokens"}, {"sha": "74725df6d0d563f68a25d4f6dc9544887d2c03c6", "filename": "crates/parser/src/tokens.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6e4bb5701433ab8f0809700827c76035d8be4813/crates%2Fparser%2Fsrc%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e4bb5701433ab8f0809700827c76035d8be4813/crates%2Fparser%2Fsrc%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftokens.rs?ref=6e4bb5701433ab8f0809700827c76035d8be4813", "patch": "@@ -8,17 +8,6 @@ use crate::SyntaxKind;\n #[allow(non_camel_case_types)]\n type bits = u64;\n \n-/// `Token` abstracts the cursor of `TokenSource` operates on.\n-#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-pub(crate) struct Token {\n-    /// What is the current token?\n-    pub(crate) kind: SyntaxKind,\n-\n-    /// Is the current token joined to the next one (`> >` vs `>>`).\n-    pub(crate) is_jointed_to_next: bool,\n-    pub(crate) contextual_kw: SyntaxKind,\n-}\n-\n /// Main input to the parser.\n ///\n /// A sequence of tokens represented internally as a struct of arrays.\n@@ -71,10 +60,6 @@ impl Tokens {\n         let (idx, b_idx) = self.bit_index(n);\n         self.joint[idx] |= 1 << b_idx;\n     }\n-    fn get_joint(&self, n: usize) -> bool {\n-        let (idx, b_idx) = self.bit_index(n);\n-        self.joint[idx] & 1 << b_idx != 0\n-    }\n     fn bit_index(&self, n: usize) -> (usize, usize) {\n         let idx = n / (bits::BITS as usize);\n         let b_idx = n % (bits::BITS as usize);\n@@ -84,19 +69,18 @@ impl Tokens {\n     fn len(&self) -> usize {\n         self.kind.len()\n     }\n-    pub(crate) fn get(&self, idx: usize) -> Token {\n-        if idx < self.len() {\n-            let kind = self.kind[idx];\n-            let is_jointed_to_next = self.get_joint(idx);\n-            let contextual_kw = self.contextual_kw[idx];\n-            Token { kind, is_jointed_to_next, contextual_kw }\n-        } else {\n-            self.eof()\n-        }\n-    }\n+}\n \n-    #[cold]\n-    fn eof(&self) -> Token {\n-        Token { kind: SyntaxKind::EOF, is_jointed_to_next: false, contextual_kw: SyntaxKind::EOF }\n+/// pub(crate) impl used by the parser.\n+impl Tokens {\n+    pub(crate) fn kind(&self, idx: usize) -> SyntaxKind {\n+        self.kind.get(idx).copied().unwrap_or(SyntaxKind::EOF)\n+    }\n+    pub(crate) fn contextual_kind(&self, idx: usize) -> SyntaxKind {\n+        self.contextual_kw.get(idx).copied().unwrap_or(SyntaxKind::EOF)\n+    }\n+    pub(crate) fn is_joint(&self, n: usize) -> bool {\n+        let (idx, b_idx) = self.bit_index(n);\n+        self.joint[idx] & 1 << b_idx != 0\n     }\n }"}]}