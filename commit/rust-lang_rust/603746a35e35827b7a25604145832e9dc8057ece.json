{"sha": "603746a35e35827b7a25604145832e9dc8057ece", "node_id": "C_kwDOAAsO6NoAKDYwMzc0NmEzNWUzNTgyN2I3YTI1NjA0MTQ1ODMyZTlkYzgwNTdlY2U", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-05T20:26:23Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-14T20:44:27Z"}, "message": "Make ResolverAstLowering a struct.", "tree": {"sha": "250592eb3230db06ad2610727f588968ce56ea2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/250592eb3230db06ad2610727f588968ce56ea2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/603746a35e35827b7a25604145832e9dc8057ece", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/603746a35e35827b7a25604145832e9dc8057ece", "html_url": "https://github.com/rust-lang/rust/commit/603746a35e35827b7a25604145832e9dc8057ece", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/603746a35e35827b7a25604145832e9dc8057ece/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47799de35a118ffc5a24a414fd003428f850fae4", "url": "https://api.github.com/repos/rust-lang/rust/commits/47799de35a118ffc5a24a414fd003428f850fae4", "html_url": "https://github.com/rust-lang/rust/commit/47799de35a118ffc5a24a414fd003428f850fae4"}], "stats": {"total": 617, "additions": 354, "deletions": 263}, "files": [{"sha": "c47ce54e6b376dccde4e72436375d590bcb143f4", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -3569,6 +3569,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_middle\",\n  \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4386,7 +4387,6 @@ dependencies = [\n  \"bitflags\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n- \"rustc_ast_lowering\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\",\n  \"rustc_data_structures\","}, {"sha": "e344d8a7637c483cd67f0845e866f0576af051c0", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -14,6 +14,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "46e6ee9468ca8580fe2b9404f431b75991366803", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -1,4 +1,4 @@\n-use crate::{ImplTraitContext, ImplTraitPosition, ParamMode};\n+use crate::{ImplTraitContext, ImplTraitPosition, ParamMode, ResolverAstLoweringExt};\n \n use super::LoweringContext;\n \n@@ -243,7 +243,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n                             let node_id = self.resolver.next_node_id();\n-                            self.resolver.create_def(\n+                            self.create_def(\n                                 parent_def_id,\n                                 node_id,\n                                 DefPathData::AnonConst,"}, {"sha": "1e863f6395bc1ebe2a972a76090feca539117e5b", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -1,6 +1,6 @@\n-use crate::{FnDeclKind, ImplTraitPosition};\n-\n+use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n+use crate::{FnDeclKind, ImplTraitPosition};\n \n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n@@ -358,7 +358,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let node_id = self.resolver.next_node_id();\n \n                 // Add a definition for the in-band const def.\n-                self.resolver.create_def(\n+                self.create_def(\n                     parent_def_id,\n                     node_id,\n                     DefPathData::AnonConst,"}, {"sha": "4be22020ba15357ded0d85fb647e3d5eb3e7e7b9", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -6,6 +6,7 @@ use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::*;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::span_bug;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{Span, DUMMY_SP};\n@@ -75,7 +76,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // owner of that node.\n         if cfg!(debug_assertions) {\n             if hir_id.owner != self.owner {\n-                panic!(\n+                span_bug!(\n+                    span,\n                     \"inconsistent DepNode at `{:?}` for `{:?}`: \\\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),"}, {"sha": "49ba2876d1ff0c1514426a01390d06bb6c281026", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -1,4 +1,5 @@\n-use super::{AstOwner, ImplTraitContext, ImplTraitPosition, ResolverAstLowering};\n+use super::ResolverAstLoweringExt;\n+use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{LoweringContext, ParamMode};\n use crate::{Arena, FnDeclKind};\n \n@@ -11,8 +12,11 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::ty::ResolverOutputs;\n+use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::Session;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -24,7 +28,9 @@ use std::iter;\n \n pub(super) struct ItemLowerer<'a, 'hir> {\n     pub(super) sess: &'a Session,\n-    pub(super) resolver: &'a mut dyn ResolverAstLowering,\n+    pub(super) definitions: &'a mut Definitions,\n+    pub(super) cstore: &'a CrateStoreDyn,\n+    pub(super) resolver: &'a mut ResolverOutputs,\n     pub(super) arena: &'hir Arena<'hir>,\n     pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n     pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n@@ -59,6 +65,8 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         let mut lctx = LoweringContext {\n             // Pseudo-globals.\n             sess: &self.sess,\n+            definitions: self.definitions,\n+            cstore: self.cstore,\n             resolver: self.resolver,\n             arena: self.arena,\n \n@@ -136,7 +144,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         let def_id = self.resolver.local_def_id(item.id);\n \n         let parent_id = {\n-            let parent = self.resolver.definitions().def_key(def_id).parent;\n+            let parent = self.definitions.def_key(def_id).parent;\n             let local_def_index = parent.unwrap();\n             LocalDefId { local_def_index }\n         };"}, {"sha": "f7acb08abde25660b3fd6513420c19ad08ab1dfc", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 206, "deletions": 149, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -51,12 +51,14 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n-use rustc_hir::def_id::{DefId, DefPathHash, LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n+use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::definitions::{DefPathData, Definitions};\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::ty::ResolverOutputs;\n use rustc_query_system::ich::StableHashingContext;\n+use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, MacroKind};\n@@ -87,7 +89,9 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n-    resolver: &'a mut dyn ResolverAstLowering,\n+    definitions: &'a mut Definitions,\n+    cstore: &'a CrateStoreDyn,\n+    resolver: &'a mut ResolverOutputs,\n \n     /// Used to allocate HIR nodes.\n     arena: &'hir Arena<'hir>,\n@@ -134,46 +138,6 @@ struct LoweringContext<'a, 'hir: 'a> {\n     allow_into_future: Option<Lrc<[Symbol]>>,\n }\n \n-/// Resolution for a lifetime appearing in a type.\n-#[derive(Copy, Clone, Debug)]\n-pub enum LifetimeRes {\n-    /// Successfully linked the lifetime to a generic parameter.\n-    Param {\n-        /// Id of the generic parameter that introduced it.\n-        param: LocalDefId,\n-        /// Id of the introducing place. That can be:\n-        /// - an item's id, for the item's generic parameters;\n-        /// - a TraitRef's ref_id, identifying the `for<...>` binder;\n-        /// - a BareFn type's id;\n-        /// - a Path's id when this path has parenthesized generic args.\n-        ///\n-        /// This information is used for impl-trait lifetime captures, to know when to or not to\n-        /// capture any given lifetime.\n-        binder: NodeId,\n-    },\n-    /// Created a generic parameter for an anonymous lifetime.\n-    Fresh {\n-        /// Id of the generic parameter that introduced it.\n-        param: LocalDefId,\n-        /// Id of the introducing place. See `Param`.\n-        binder: NodeId,\n-    },\n-    /// This variant is used for anonymous lifetimes that we did not resolve during\n-    /// late resolution.  Shifting the work to the HIR lifetime resolver.\n-    Anonymous {\n-        /// Id of the introducing place. See `Param`.\n-        binder: NodeId,\n-        /// Whether this lifetime was spelled or elided.\n-        elided: bool,\n-    },\n-    /// Explicit `'static` lifetime.\n-    Static,\n-    /// Resolution failure.\n-    Error,\n-    /// HACK: This is used to recover the NodeId of an elided lifetime.\n-    ElidedAnchor { start: NodeId, end: NodeId },\n-}\n-\n /// When we lower a lifetime, it is inserted in `captures`, and the resolution is modified so\n /// to point to the lifetime parameter impl-trait will generate.\n /// When traversing `for<...>` binders, they are inserted in `binders_to_ignore` so we know *not*\n@@ -196,54 +160,96 @@ struct LifetimeCaptureContext {\n     binders_to_ignore: FxHashSet<NodeId>,\n }\n \n-pub trait ResolverAstLowering {\n-    fn def_key(&self, id: DefId) -> DefKey;\n+trait ResolverAstLoweringExt {\n+    fn legacy_const_generic_args(&self, expr: &Expr) -> Option<Vec<usize>>;\n+    fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n+    fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n+    fn get_label_res(&self, id: NodeId) -> Option<NodeId>;\n+    fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n+    fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n+    fn next_node_id(&mut self) -> NodeId;\n+    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId;\n+    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n+}\n \n-    fn def_span(&self, id: LocalDefId) -> Span;\n+impl ResolverAstLoweringExt for ResolverOutputs {\n+    fn legacy_const_generic_args(&self, expr: &Expr) -> Option<Vec<usize>> {\n+        if let ExprKind::Path(None, path) = &expr.kind {\n+            // Don't perform legacy const generics rewriting if the path already\n+            // has generic arguments.\n+            if path.segments.last().unwrap().args.is_some() {\n+                return None;\n+            }\n \n-    fn item_generics_num_lifetimes(&self, def: DefId) -> usize;\n+            let partial_res = self.partial_res_map.get(&expr.id)?;\n+            if partial_res.unresolved_segments() != 0 {\n+                return None;\n+            }\n \n-    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>>;\n+            if let Res::Def(DefKind::Fn, def_id) = partial_res.base_res() {\n+                // We only support cross-crate argument rewriting. Uses\n+                // within the same crate should be updated to use the new\n+                // const generics style.\n+                if def_id.is_local() {\n+                    return None;\n+                }\n+\n+                if let Some(v) = self.legacy_const_generic_args.get(&def_id) {\n+                    return v.clone();\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n \n     /// Obtains resolution for a `NodeId` with a single resolution.\n-    fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n+    fn get_partial_res(&self, id: NodeId) -> Option<PartialRes> {\n+        self.partial_res_map.get(&id).copied()\n+    }\n \n     /// Obtains per-namespace resolutions for `use` statement with the given `NodeId`.\n-    fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n+    fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res<NodeId>>> {\n+        self.import_res_map.get(&id).copied().unwrap_or_default()\n+    }\n \n     /// Obtains resolution for a label with the given `NodeId`.\n-    fn get_label_res(&self, id: NodeId) -> Option<NodeId>;\n+    fn get_label_res(&self, id: NodeId) -> Option<NodeId> {\n+        self.label_res_map.get(&id).copied()\n+    }\n \n     /// Obtains resolution for a lifetime with the given `NodeId`.\n-    fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n+    fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes> {\n+        self.lifetimes_res_map.get(&id).copied()\n+    }\n \n     /// Obtain the list of lifetimes parameters to add to an item.\n-    fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n-\n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;\n-\n-    fn definitions(&self) -> &Definitions;\n-\n-    fn next_node_id(&mut self) -> NodeId;\n-\n-    fn take_trait_map(&mut self, node: NodeId) -> Option<Vec<hir::TraitCandidate>>;\n-\n-    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n+    fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)> {\n+        self.extra_lifetime_params_map.remove(&id).unwrap_or_default()\n+    }\n \n-    fn local_def_id(&self, node: NodeId) -> LocalDefId;\n+    fn next_node_id(&mut self) -> NodeId {\n+        let next = self\n+            .next_node_id\n+            .as_usize()\n+            .checked_add(1)\n+            .expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = NodeId::from_usize(next);\n+        self.next_node_id\n+    }\n \n-    fn def_path_hash(&self, def_id: DefId) -> DefPathHash;\n+    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n+        self.node_id_to_def_id.get(&node).copied()\n+    }\n \n-    fn create_def(\n-        &mut self,\n-        parent: LocalDefId,\n-        node_id: ast::NodeId,\n-        data: DefPathData,\n-        expn_id: ExpnId,\n-        span: Span,\n-    ) -> LocalDefId;\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n+        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n+    }\n \n-    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n+    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n+        self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n+    }\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -353,7 +359,7 @@ enum AstOwner<'a> {\n }\n \n fn index_crate<'a>(\n-    resolver: &dyn ResolverAstLowering,\n+    resolver: &ResolverOutputs,\n     krate: &'a Crate,\n ) -> IndexVec<LocalDefId, AstOwner<'a>> {\n     let mut indexer = Indexer { resolver, index: IndexVec::new() };\n@@ -363,7 +369,7 @@ fn index_crate<'a>(\n     return indexer.index;\n \n     struct Indexer<'s, 'a> {\n-        resolver: &'s dyn ResolverAstLowering,\n+        resolver: &'s ResolverOutputs,\n         index: IndexVec<LocalDefId, AstOwner<'a>>,\n     }\n \n@@ -399,44 +405,56 @@ fn index_crate<'a>(\n /// Compute the hash for the HIR of the full crate.\n /// This hash will then be part of the crate_hash which is stored in the metadata.\n fn compute_hir_hash(\n-    resolver: &mut dyn ResolverAstLowering,\n+    sess: &Session,\n+    definitions: &Definitions,\n+    cstore: &CrateStoreDyn,\n     owners: &IndexVec<LocalDefId, hir::MaybeOwner<&hir::OwnerInfo<'_>>>,\n ) -> Fingerprint {\n     let mut hir_body_nodes: Vec<_> = owners\n         .iter_enumerated()\n         .filter_map(|(def_id, info)| {\n             let info = info.as_owner()?;\n-            let def_path_hash = resolver.definitions().def_path_hash(def_id);\n+            let def_path_hash = definitions.def_path_hash(def_id);\n             Some((def_path_hash, info))\n         })\n         .collect();\n     hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n     let mut stable_hasher = StableHasher::new();\n-    let mut hcx = resolver.create_stable_hashing_context();\n+    let mut hcx = StableHashingContext::new(sess, definitions, cstore);\n     hir_body_nodes.hash_stable(&mut hcx, &mut stable_hasher);\n     stable_hasher.finish()\n }\n \n-pub fn lower_crate<'a, 'hir>(\n-    sess: &'a Session,\n-    krate: &'a Crate,\n-    resolver: &'a mut dyn ResolverAstLowering,\n+pub fn lower_crate<'hir>(\n+    sess: &Session,\n+    krate: &Crate,\n+    definitions: &mut Definitions,\n+    cstore: &CrateStoreDyn,\n+    resolver: &mut ResolverOutputs,\n     arena: &'hir Arena<'hir>,\n ) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n     let ast_index = index_crate(resolver, krate);\n \n     let mut owners =\n-        IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, resolver.definitions().def_index_count());\n+        IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, definitions.def_index_count());\n \n     for def_id in ast_index.indices() {\n-        item::ItemLowerer { sess, resolver, arena, ast_index: &ast_index, owners: &mut owners }\n-            .lower_node(def_id);\n+        item::ItemLowerer {\n+            sess,\n+            definitions,\n+            cstore,\n+            resolver,\n+            arena,\n+            ast_index: &ast_index,\n+            owners: &mut owners,\n+        }\n+        .lower_node(def_id);\n     }\n \n-    let hir_hash = compute_hir_hash(resolver, &owners);\n+    let hir_hash = compute_hir_hash(sess, definitions, cstore, &owners);\n     let krate = hir::Crate { owners, hir_hash };\n     arena.alloc(krate)\n }\n@@ -457,6 +475,40 @@ enum ParenthesizedGenericArgs {\n }\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n+        StableHashingContext::new(self.sess, self.definitions, self.cstore)\n+    }\n+\n+    fn create_def(\n+        &mut self,\n+        parent: LocalDefId,\n+        node_id: ast::NodeId,\n+        data: DefPathData,\n+        expn_id: ExpnId,\n+        span: Span,\n+    ) -> LocalDefId {\n+        assert!(\n+            !self.resolver.node_id_to_def_id.contains_key(&node_id),\n+            \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n+            node_id,\n+            data,\n+            self.definitions.def_key(self.resolver.node_id_to_def_id[&node_id]),\n+        );\n+\n+        let def_id = self.definitions.create_def(parent, data, expn_id, span);\n+\n+        // Some things for which we allocate `LocalDefId`s don't correspond to\n+        // anything in the AST, so they don't have a `NodeId`. For these cases\n+        // we don't need a mapping from `NodeId` to `LocalDefId`.\n+        if node_id != ast::DUMMY_NODE_ID {\n+            debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n+            self.resolver.node_id_to_def_id.insert(node_id, def_id);\n+        }\n+        assert_eq!(self.resolver.def_id_to_node_id.push(node_id), def_id);\n+\n+        def_id\n+    }\n+\n     #[instrument(level = \"debug\", skip(self, f))]\n     fn with_hir_id_owner(\n         &mut self,\n@@ -518,8 +570,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bodies.sort_by_key(|(k, _)| *k);\n         let bodies = SortedMap::from_presorted_elements(bodies);\n         let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n-        let (nodes, parenting) =\n-            index::index_hir(self.sess, self.resolver.definitions(), node, &bodies);\n+        let (nodes, parenting) = index::index_hir(self.sess, self.definitions, node, &bodies);\n         let nodes = hir::OwnerNodes {\n             hash_including_bodies,\n             hash_without_bodies,\n@@ -528,7 +579,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             local_id_to_def_id,\n         };\n         let attrs = {\n-            let mut hcx = self.resolver.create_stable_hashing_context();\n+            let mut hcx = self.create_stable_hashing_context();\n             let mut stable_hasher = StableHasher::new();\n             attrs.hash_stable(&mut hcx, &mut stable_hasher);\n             let hash = stable_hasher.finish();\n@@ -545,7 +596,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         node: hir::OwnerNode<'hir>,\n         bodies: &SortedMap<hir::ItemLocalId, &'hir hir::Body<'hir>>,\n     ) -> (Fingerprint, Fingerprint) {\n-        let mut hcx = self.resolver.create_stable_hashing_context();\n+        let mut hcx = self.create_stable_hashing_context();\n         let mut stable_hasher = StableHasher::new();\n         hcx.with_hir_bodies(true, node.def_id(), bodies, |hcx| {\n             node.hash_stable(hcx, &mut stable_hasher)\n@@ -588,7 +639,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     self.local_id_to_def_id.insert(local_id, def_id);\n                 }\n \n-                if let Some(traits) = self.resolver.take_trait_map(ast_node_id) {\n+                if let Some(traits) = self.resolver.trait_map.remove(&ast_node_id) {\n                     self.trait_map.insert(hir_id.local_id, traits.into_boxed_slice());\n                 }\n \n@@ -648,7 +699,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             allow_internal_unstable,\n             reason,\n             self.sess.edition(),\n-            self.resolver.create_stable_hashing_context(),\n+            self.create_stable_hashing_context(),\n         )\n     }\n \n@@ -941,7 +992,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                     let parent_def_id = self.current_hir_id_owner;\n                     let impl_trait_node_id = self.resolver.next_node_id();\n-                    self.resolver.create_def(\n+                    self.create_def(\n                         parent_def_id,\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n@@ -1053,7 +1104,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 let node_id = self.resolver.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n-                                self.resolver.create_def(\n+                                self.create_def(\n                                     parent_def_id,\n                                     node_id,\n                                     DefPathData::AnonConst,\n@@ -1567,7 +1618,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let inner_node_id = self.resolver.next_node_id();\n \n             // Add a definition for the in scope lifetime def.\n-            self.resolver.create_def(\n+            self.create_def(\n                 opaque_ty_def_id,\n                 inner_node_id,\n                 DefPathData::LifetimeNs(name),\n@@ -1757,74 +1808,80 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Param { mut param, binder } => {\n                 debug_assert_ne!(ident.name, kw::UnderscoreLifetime);\n                 let p_name = ParamName::Plain(ident);\n-                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n-                    &mut self.captured_lifetimes\n-                    && !binders_to_ignore.contains(&binder)\n-                {\n-                    match captures.entry(param) {\n-                        Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n-                        Entry::Vacant(v) => {\n-                            let p_id = self.resolver.next_node_id();\n-                            let p_def_id = self.resolver.create_def(\n-                                *parent_def_id,\n-                                p_id,\n-                                DefPathData::LifetimeNs(p_name.ident().name),\n-                                ExpnId::root(),\n-                                span.with_parent(None),\n-                            );\n-\n-                            v.insert((span, p_id, p_name, res));\n-                            param = p_def_id;\n+                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n+                        match captured_lifetimes.captures.entry(param) {\n+                            Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n+                            Entry::Vacant(v) => {\n+                                let p_id = self.resolver.next_node_id();\n+                                let p_def_id = self.create_def(\n+                                    captured_lifetimes.parent_def_id,\n+                                    p_id,\n+                                    DefPathData::LifetimeNs(p_name.ident().name),\n+                                    ExpnId::root(),\n+                                    span.with_parent(None),\n+                                );\n+\n+                                v.insert((span, p_id, p_name, res));\n+                                param = p_def_id;\n+                            }\n                         }\n                     }\n+\n+                    self.captured_lifetimes = Some(captured_lifetimes);\n                 }\n                 hir::LifetimeName::Param(param, p_name)\n             }\n             LifetimeRes::Fresh { mut param, binder } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n-                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n-                    &mut self.captured_lifetimes\n-                    && !binders_to_ignore.contains(&binder)\n-                {\n-                    match captures.entry(param) {\n-                        Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n-                        Entry::Vacant(v) => {\n-                            let p_id = self.resolver.next_node_id();\n-                            let p_def_id = self.resolver.create_def(\n-                                *parent_def_id,\n-                                p_id,\n-                                DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                                ExpnId::root(),\n-                                span.with_parent(None),\n-                            );\n-\n-                            v.insert((span, p_id, ParamName::Fresh, res));\n-                            param = p_def_id;\n+                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n+                        match captured_lifetimes.captures.entry(param) {\n+                            Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n+                            Entry::Vacant(v) => {\n+                                let p_id = self.resolver.next_node_id();\n+                                let p_def_id = self.create_def(\n+                                    captured_lifetimes.parent_def_id,\n+                                    p_id,\n+                                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                                    ExpnId::root(),\n+                                    span.with_parent(None),\n+                                );\n+\n+                                v.insert((span, p_id, ParamName::Fresh, res));\n+                                param = p_def_id;\n+                            }\n                         }\n                     }\n+\n+                    self.captured_lifetimes = Some(captured_lifetimes);\n                 }\n                 hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n             LifetimeRes::Anonymous { binder, elided } => {\n-                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n-                    &mut self.captured_lifetimes\n-                    && !binders_to_ignore.contains(&binder)\n-                {\n-                    let p_id = self.resolver.next_node_id();\n-                    let p_def_id = self.resolver.create_def(\n-                        *parent_def_id,\n-                        p_id,\n-                        DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                        ExpnId::root(),\n-                        span.with_parent(None),\n-                    );\n-                    captures.insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n-                    hir::LifetimeName::Param(p_def_id, ParamName::Fresh)\n-                } else if elided {\n+                let mut l_name = None;\n+                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n+                        let p_id = self.resolver.next_node_id();\n+                        let p_def_id = self.create_def(\n+                            captured_lifetimes.parent_def_id,\n+                            p_id,\n+                            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                            ExpnId::root(),\n+                            span.with_parent(None),\n+                        );\n+                        captured_lifetimes\n+                            .captures\n+                            .insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n+                        l_name = Some(hir::LifetimeName::Param(p_def_id, ParamName::Fresh));\n+                    }\n+                    self.captured_lifetimes = Some(captured_lifetimes);\n+                };\n+                l_name.unwrap_or(if elided {\n                     hir::LifetimeName::Implicit\n                 } else {\n                     hir::LifetimeName::Underscore\n-                }\n+                })\n             }\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,"}, {"sha": "bd2e76e5528dab08b8a07e00353bc7bdbfb1e906", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -1,6 +1,6 @@\n-use crate::ImplTraitPosition;\n-\n+use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n+use crate::ImplTraitPosition;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;"}, {"sha": "13d3c9521b3832a4ae29790a43974c5fc36f2d9e", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -1,5 +1,6 @@\n use crate::ImplTraitPosition;\n \n+use super::ResolverAstLoweringExt;\n use super::{GenericArgsCtor, LifetimeRes, ParenthesizedGenericArgs};\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n "}, {"sha": "3927523f4c6ab6cd4375da23bbf02fb0efccf1c7", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -1,9 +1,9 @@\n-use crate::def_id::DefId;\n use crate::hir;\n \n use rustc_ast as ast;\n use rustc_ast::NodeId;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::Symbol;\n \n@@ -711,3 +711,43 @@ impl<Id> Res<Id> {\n         matches!(self, Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..))\n     }\n }\n+\n+/// Resolution for a lifetime appearing in a type.\n+#[derive(Copy, Clone, Debug)]\n+pub enum LifetimeRes {\n+    /// Successfully linked the lifetime to a generic parameter.\n+    Param {\n+        /// Id of the generic parameter that introduced it.\n+        param: LocalDefId,\n+        /// Id of the introducing place. That can be:\n+        /// - an item's id, for the item's generic parameters;\n+        /// - a TraitRef's ref_id, identifying the `for<...>` binder;\n+        /// - a BareFn type's id;\n+        /// - a Path's id when this path has parenthesized generic args.\n+        ///\n+        /// This information is used for impl-trait lifetime captures, to know when to or not to\n+        /// capture any given lifetime.\n+        binder: NodeId,\n+    },\n+    /// Created a generic parameter for an anonymous lifetime.\n+    Fresh {\n+        /// Id of the generic parameter that introduced it.\n+        param: LocalDefId,\n+        /// Id of the introducing place. See `Param`.\n+        binder: NodeId,\n+    },\n+    /// This variant is used for anonymous lifetimes that we did not resolve during\n+    /// late resolution.  Shifting the work to the HIR lifetime resolver.\n+    Anonymous {\n+        /// Id of the introducing place. See `Param`.\n+        binder: NodeId,\n+        /// Whether this lifetime was spelled or elided.\n+        elided: bool,\n+    },\n+    /// Explicit `'static` lifetime.\n+    Static,\n+    /// Resolution failure.\n+    Error,\n+    /// HACK: This is used to recover the NodeId of an elided lifetime.\n+    ElidedAnchor { start: NodeId, end: NodeId },\n+}"}, {"sha": "adeb384787ef8440a44f53060b6d505f2a593a95", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -481,14 +481,17 @@ pub fn configure_and_expand(\n     Ok(krate)\n }\n \n-pub fn lower_to_hir<'res, 'tcx>(\n-    sess: &'tcx Session,\n-    resolver: &'res mut Resolver<'_>,\n+fn lower_to_hir<'tcx>(\n+    sess: &Session,\n+    definitions: &mut Definitions,\n+    cstore: &CrateStoreDyn,\n+    resolver: &mut ResolverOutputs,\n     krate: Rc<ast::Crate>,\n     arena: &'tcx rustc_ast_lowering::Arena<'tcx>,\n ) -> &'tcx Crate<'tcx> {\n     // Lower AST to HIR.\n-    let hir_crate = rustc_ast_lowering::lower_crate(sess, &*krate, resolver, arena);\n+    let hir_crate =\n+        rustc_ast_lowering::lower_crate(sess, &krate, definitions, cstore, resolver, arena);\n \n     // Drop AST to free memory\n     sess.time(\"drop_ast\", || std::mem::drop(krate));\n@@ -826,10 +829,14 @@ pub fn create_global_ctxt<'tcx>(\n     // incr. comp. yet.\n     dep_graph.assert_ignored();\n \n+    let (mut definitions, cstore, mut resolver_outputs) =\n+        BoxedResolver::to_resolver_outputs(resolver);\n+\n     let sess = &compiler.session();\n+\n+    // Lower AST to HIR.\n     let krate =\n-        resolver.borrow_mut().access(|resolver| lower_to_hir(sess, resolver, krate, hir_arena));\n-    let (definitions, cstore, resolver_outputs) = BoxedResolver::to_resolver_outputs(resolver);\n+        lower_to_hir(sess, &mut definitions, &*cstore, &mut resolver_outputs, krate, hir_arena);\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n "}, {"sha": "e0cb0cb9709ffad417deadad8da2f14abf8302a1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -27,18 +27,21 @@ pub use adt::*;\n pub use assoc::*;\n pub use generics::*;\n use rustc_ast as ast;\n+use rustc_ast::node_id::NodeMap;\n use rustc_attr as attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n use rustc_hir::Node;\n+use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::{Align, VariantIdx};\n@@ -153,6 +156,30 @@ pub struct ResolverOutputs {\n     /// exist under `std`. For example, wrote `str::from_utf8` instead of `std::str::from_utf8`.\n     pub confused_type_with_std_module: FxHashMap<Span, Span>,\n     pub registered_tools: RegisteredTools,\n+    pub item_generics_num_lifetimes: FxHashMap<LocalDefId, usize>,\n+\n+    pub legacy_const_generic_args: FxHashMap<DefId, Option<Vec<usize>>>,\n+\n+    /// Resolutions for nodes that have a single resolution.\n+    pub partial_res_map: NodeMap<hir::def::PartialRes>,\n+    /// Resolutions for import nodes, which have multiple resolutions in different namespaces.\n+    pub import_res_map: NodeMap<hir::def::PerNS<Option<Res<ast::NodeId>>>>,\n+    /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n+    pub label_res_map: NodeMap<ast::NodeId>,\n+    /// Resolutions for lifetimes.\n+    pub lifetimes_res_map: NodeMap<LifetimeRes>,\n+    /// Lifetime parameters that lowering will have to introduce.\n+    pub extra_lifetime_params_map: NodeMap<Vec<(Ident, ast::NodeId, LifetimeRes)>>,\n+\n+    pub next_node_id: ast::NodeId,\n+\n+    pub node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n+    pub def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n+\n+    pub trait_map: NodeMap<Vec<hir::TraitCandidate>>,\n+    /// A small map keeping true kinds of built-in macros that appear to be fn-like on\n+    /// the surface (`macro` items in libcore), but are actually attributes or derives.\n+    pub builtin_macro_kinds: FxHashMap<LocalDefId, MacroKind>,\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "8bd8eb488b70721af7e381701a7671edafe369bc", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -12,7 +12,6 @@ tracing = \"0.1\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_arena = { path = \"../rustc_arena\" }\n rustc_middle = { path = \"../rustc_middle\" }\n-rustc_ast_lowering = { path = \"../rustc_ast_lowering\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "3fba923d9fdf425c443300fb15eed97ba6ffdfd8", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -5,7 +5,6 @@ use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n use rustc_ast::ForeignMod;\n use rustc_ast::NodeId;\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_middle::middle::privacy::AccessLevel;"}, {"sha": "8cca958fc630e6619af408ef0f12105b819501c1", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -16,7 +16,6 @@ use crate::{Resolver, ResolverArenas, Segment, ToNameBinding, VisResolutionError\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AssocItem, AssocItemKind, MetaItemKind, StmtKind};\n use rustc_ast::{Block, Fn, ForeignItem, ForeignItemKind, Impl, Item, ItemKind, NodeId};\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_attr as attr;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n@@ -27,7 +26,7 @@ use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::bug;\n use rustc_middle::metadata::ModChild;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, DefIdTree};\n use rustc_session::cstore::CrateStore;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind};\n use rustc_span::source_map::{respan, Spanned};\n@@ -112,10 +111,7 @@ impl<'a> Resolver<'a> {\n         loop {\n             match self.get_module(def_id) {\n                 Some(module) => return module,\n-                None => {\n-                    def_id.index =\n-                        self.def_key(def_id).parent.expect(\"non-root `DefId` without parent\")\n-                }\n+                None => def_id = self.parent(def_id),\n             }\n         }\n     }"}, {"sha": "f2f6f1d895e32ff4cb139f735cba8582e75015f3", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -30,7 +30,6 @@ use crate::Resolver;\n use rustc_ast as ast;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, MultiSpan};\n use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_IMPORTS};"}, {"sha": "52706fbb9e6ec63bd77fb7401f8609e9b8b70688", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -2,7 +2,6 @@ use crate::{ImplTraitContext, Resolver};\n use rustc_ast::visit::{self, FnKind};\n use rustc_ast::walk_list;\n use rustc_ast::*;\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::definitions::*;"}, {"sha": "381073a3f666359cb966ce83f8bb417e4fc33a64", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -15,11 +15,10 @@ use crate::{ResolutionError, Resolver, Segment, UseError};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n-use rustc_ast_lowering::{LifetimeRes, ResolverAstLowering};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, CtorKind, DefKind, PartialRes, PerNS};\n+use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{PrimTy, TraitCandidate};"}, {"sha": "ef54ae514011c6440c9ee60655c134fafe8e1dde", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -11,7 +11,6 @@ use rustc_ast::{\n     self as ast, AssocItemKind, Expr, ExprKind, GenericParam, GenericParamKind, Item, ItemKind,\n     NodeId, Path, Ty, TyKind,\n };\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::{"}, {"sha": "eb58f17fc7e03f73ed1684488b909a73f6d39a15", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 39, "deletions": 78, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -27,17 +27,16 @@ use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n-use rustc_ast_lowering::{LifetimeRes, ResolverAstLowering};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorOf, DefKind, PartialRes};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefPathHash, LocalDefId};\n+use rustc_hir::def::{self, CtorOf, DefKind, LifetimeRes, PartialRes};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n+use rustc_hir::definitions::{DefPathData, Definitions};\n use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n@@ -1121,85 +1120,15 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     }\n }\n \n-/// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n-/// the resolver is no longer needed as all the relevant information is inline.\n-impl ResolverAstLowering for Resolver<'_> {\n-    fn def_key(&self, id: DefId) -> DefKey {\n-        if let Some(id) = id.as_local() {\n-            self.definitions.def_key(id)\n-        } else {\n-            self.cstore().def_key(id)\n-        }\n-    }\n-\n-    #[inline]\n-    fn def_span(&self, id: LocalDefId) -> Span {\n-        self.definitions.def_span(id)\n-    }\n-\n-    fn item_generics_num_lifetimes(&self, def_id: DefId) -> usize {\n-        if let Some(def_id) = def_id.as_local() {\n-            self.item_generics_num_lifetimes[&def_id]\n-        } else {\n-            self.cstore().item_generics_num_lifetimes(def_id, self.session)\n-        }\n-    }\n-\n-    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>> {\n-        self.legacy_const_generic_args(expr)\n-    }\n-\n-    fn get_partial_res(&self, id: NodeId) -> Option<PartialRes> {\n-        self.partial_res_map.get(&id).cloned()\n-    }\n-\n-    fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res>> {\n-        self.import_res_map.get(&id).cloned().unwrap_or_default()\n-    }\n-\n-    fn get_label_res(&self, id: NodeId) -> Option<NodeId> {\n-        self.label_res_map.get(&id).cloned()\n-    }\n-\n-    fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes> {\n-        self.lifetimes_res_map.get(&id).copied()\n-    }\n-\n-    fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)> {\n-        self.extra_lifetime_params_map.remove(&id).unwrap_or_default()\n-    }\n-\n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(self.session, &self.definitions, self.crate_loader.cstore())\n-    }\n-\n-    fn definitions(&self) -> &Definitions {\n-        &self.definitions\n-    }\n-\n-    fn next_node_id(&mut self) -> NodeId {\n-        self.next_node_id()\n-    }\n-\n-    fn take_trait_map(&mut self, node: NodeId) -> Option<Vec<TraitCandidate>> {\n-        self.trait_map.remove(&node)\n-    }\n-\n+impl Resolver<'_> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()\n     }\n \n-    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n+    pub fn local_def_id(&self, node: NodeId) -> LocalDefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n     }\n \n-    fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n-        match def_id.as_local() {\n-            Some(def_id) => self.definitions.def_path_hash(def_id),\n-            None => self.cstore().def_path_hash(def_id),\n-        }\n-    }\n-\n     /// Adds a definition with a parent definition.\n     fn create_def(\n         &mut self,\n@@ -1231,8 +1160,12 @@ impl ResolverAstLowering for Resolver<'_> {\n         def_id\n     }\n \n-    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n-        self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n+    fn item_generics_num_lifetimes(&self, def_id: DefId) -> usize {\n+        if let Some(def_id) = def_id.as_local() {\n+            self.item_generics_num_lifetimes[&def_id]\n+        } else {\n+            self.cstore().item_generics_num_lifetimes(def_id, self.session)\n+        }\n     }\n }\n \n@@ -1472,6 +1405,18 @@ impl<'a> Resolver<'a> {\n             proc_macros,\n             confused_type_with_std_module,\n             registered_tools: self.registered_tools,\n+            item_generics_num_lifetimes: self.item_generics_num_lifetimes,\n+            legacy_const_generic_args: self.legacy_const_generic_args,\n+            partial_res_map: self.partial_res_map,\n+            import_res_map: self.import_res_map,\n+            label_res_map: self.label_res_map,\n+            lifetimes_res_map: self.lifetimes_res_map,\n+            extra_lifetime_params_map: self.extra_lifetime_params_map,\n+            next_node_id: self.next_node_id,\n+            node_id_to_def_id: self.node_id_to_def_id,\n+            def_id_to_node_id: self.def_id_to_node_id,\n+            trait_map: self.trait_map,\n+            builtin_macro_kinds: self.builtin_macro_kinds,\n         };\n         (definitions, cstore, resolutions)\n     }\n@@ -1499,10 +1444,26 @@ impl<'a> Resolver<'a> {\n             confused_type_with_std_module: self.confused_type_with_std_module.clone(),\n             registered_tools: self.registered_tools.clone(),\n             access_levels: self.access_levels.clone(),\n+            item_generics_num_lifetimes: self.item_generics_num_lifetimes.clone(),\n+            legacy_const_generic_args: self.legacy_const_generic_args.clone(),\n+            partial_res_map: self.partial_res_map.clone(),\n+            import_res_map: self.import_res_map.clone(),\n+            label_res_map: self.label_res_map.clone(),\n+            lifetimes_res_map: self.lifetimes_res_map.clone(),\n+            extra_lifetime_params_map: self.extra_lifetime_params_map.clone(),\n+            next_node_id: self.next_node_id.clone(),\n+            node_id_to_def_id: self.node_id_to_def_id.clone(),\n+            def_id_to_node_id: self.def_id_to_node_id.clone(),\n+            trait_map: self.trait_map.clone(),\n+            builtin_macro_kinds: self.builtin_macro_kinds.clone(),\n         };\n         (definitions, cstore, resolutions)\n     }\n \n+    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n+        StableHashingContext::new(self.session, &self.definitions, self.crate_loader.cstore())\n+    }\n+\n     pub fn cstore(&self) -> &CStore {\n         self.crate_loader.cstore()\n     }"}, {"sha": "f6c13b6870a66ee98091cc19233ae0cc9f999b8f", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -7,7 +7,6 @@ use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;"}, {"sha": "54b851660416ac93cbc4d0c48a0f3564b452caa7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -36,7 +36,6 @@ extern crate tracing;\n // Dependencies listed in Cargo.toml do not need `extern crate`.\n \n extern crate rustc_ast;\n-extern crate rustc_ast_lowering;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n extern crate rustc_const_eval;"}, {"sha": "38cfd7a27ddb48cdcf590aeb4330b103afb31708", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/603746a35e35827b7a25604145832e9dc8057ece/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603746a35e35827b7a25604145832e9dc8057ece/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=603746a35e35827b7a25604145832e9dc8057ece", "patch": "@@ -5,7 +5,6 @@ use crate::passes::collect_intra_doc_links::{Disambiguator, PreprocessedMarkdown\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{DefKind, Namespace, Res};"}]}