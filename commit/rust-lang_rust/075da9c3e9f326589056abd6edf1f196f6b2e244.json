{"sha": "075da9c3e9f326589056abd6edf1f196f6b2e244", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NWRhOWMzZTlmMzI2NTg5MDU2YWJkNmVkZjFmMTk2ZjZiMmUyNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-11T07:22:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-11T07:22:34Z"}, "message": "auto merge of #7050 : huonw/rust/extra-complex-work, r=Aatch", "tree": {"sha": "0637fc10b2376855159506fabc7a92c9200ca044", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0637fc10b2376855159506fabc7a92c9200ca044"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/075da9c3e9f326589056abd6edf1f196f6b2e244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/075da9c3e9f326589056abd6edf1f196f6b2e244", "html_url": "https://github.com/rust-lang/rust/commit/075da9c3e9f326589056abd6edf1f196f6b2e244", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/075da9c3e9f326589056abd6edf1f196f6b2e244/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bdd4c854575a6f92501f060e67c60bebea14e03", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bdd4c854575a6f92501f060e67c60bebea14e03", "html_url": "https://github.com/rust-lang/rust/commit/6bdd4c854575a6f92501f060e67c60bebea14e03"}, {"sha": "19c31b6b1afef7cad83275b2e73d27e5c44ed2a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/19c31b6b1afef7cad83275b2e73d27e5c44ed2a1", "html_url": "https://github.com/rust-lang/rust/commit/19c31b6b1afef7cad83275b2e73d27e5c44ed2a1"}], "stats": {"total": 121, "additions": 85, "deletions": 36}, "files": [{"sha": "bf97c86b5c99e3deaaa09ae9816b67baa0328277", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/075da9c3e9f326589056abd6edf1f196f6b2e244/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/075da9c3e9f326589056abd6edf1f196f6b2e244/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=075da9c3e9f326589056abd6edf1f196f6b2e244", "patch": "@@ -318,7 +318,7 @@ be distributed on the available cores.\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n     for uint::range(start*100000, (start+1)*100000) |num| {\n-        local_sum += (num as f64 + 1.0).pow(-2.0);\n+        local_sum += (num as f64 + 1.0).pow(&-2.0);\n     }\n     local_sum\n }\n@@ -355,7 +355,7 @@ a single large vector of floats. Each task needs the full vector to perform its\n use extra::arc::ARC;\n \n fn pnorm(nums: &~[float], p: uint) -> float {\n-    nums.iter().fold(0.0, |a,b| a+(*b).pow(p as float) ).pow(1f / (p as float))\n+    nums.iter().fold(0.0, |a,b| a+(*b).pow(&(p as float)) ).pow(&(1f / (p as float)))\n }\n \n fn main() {"}, {"sha": "1bb364f3a1c3fee5762bddeb92655cd5d1f117c9", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=075da9c3e9f326589056abd6edf1f196f6b2e244", "patch": "@@ -35,7 +35,7 @@ pub type Complex = Cmplx<float>;\n pub type Complex32 = Cmplx<f32>;\n pub type Complex64 = Cmplx<f64>;\n \n-impl<T: Copy + Num> Cmplx<T> {\n+impl<T: Clone + Num> Cmplx<T> {\n     /// Create a new Cmplx\n     #[inline]\n     pub fn new(re: T, im: T) -> Cmplx<T> {\n@@ -55,7 +55,7 @@ impl<T: Copy + Num> Cmplx<T> {\n     /// Returns the complex conjugate. i.e. `re - i im`\n     #[inline]\n     pub fn conj(&self) -> Cmplx<T> {\n-        Cmplx::new(self.re, -self.im)\n+        Cmplx::new(self.re.clone(), -self.im)\n     }\n \n \n@@ -80,62 +80,91 @@ impl<T: Copy + Num> Cmplx<T> {\n     }\n }\n \n+#[cfg(not(stage0))] // Fixed by #4228\n+impl<T: Clone + Algebraic + Num> Cmplx<T> {\n+    /// Calculate |self|\n+    #[inline(always)]\n+    pub fn norm(&self) -> T {\n+        self.re.hypot(&self.im)\n+    }\n+}\n+\n+#[cfg(not(stage0))] // Fixed by #4228\n+impl<T: Clone + Trigonometric + Algebraic + Num> Cmplx<T> {\n+    /// Calculate the principal Arg of self.\n+    #[inline(always)]\n+    pub fn arg(&self) -> T {\n+        self.im.atan2(&self.re)\n+    }\n+    /// Convert to polar form (r, theta), such that `self = r * exp(i\n+    /// * theta)`\n+    #[inline]\n+    pub fn to_polar(&self) -> (T, T) {\n+        (self.norm(), self.arg())\n+    }\n+    /// Convert a polar representation into a complex number.\n+    #[inline]\n+    pub fn from_polar(r: &T, theta: &T) -> Cmplx<T> {\n+        Cmplx::new(r * theta.cos(), r * theta.sin())\n+    }\n+}\n+\n /* arithmetic */\n // (a + i b) + (c + i d) == (a + c) + i (b + d)\n-impl<T: Copy + Num> Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn add(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re + other.re, self.im + other.im)\n     }\n }\n // (a + i b) - (c + i d) == (a - c) + i (b - d)\n-impl<T: Copy + Num> Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn sub(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re - other.re, self.im - other.im)\n     }\n }\n // (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n-impl<T: Copy + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn mul(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re*other.re - self.im*other.im,\n-                     self.re*other.im + self.im*other.re)\n+                   self.re*other.im + self.im*other.re)\n     }\n }\n \n // (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n //   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Copy + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         let norm_sqr = other.norm_sqr();\n         Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n-                     (self.im*other.re - self.re*other.im) / norm_sqr)\n+                   (self.im*other.re - self.re*other.im) / norm_sqr)\n     }\n }\n \n-impl<T: Copy + Num> Neg<Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Neg<Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn neg(&self) -> Cmplx<T> {\n         Cmplx::new(-self.re, -self.im)\n     }\n }\n \n /* constants */\n-impl<T: Copy + Num> Zero for Cmplx<T> {\n+impl<T: Clone + Num> Zero for Cmplx<T> {\n     #[inline]\n     fn zero() -> Cmplx<T> {\n         Cmplx::new(Zero::zero(), Zero::zero())\n     }\n \n     #[inline]\n     fn is_zero(&self) -> bool {\n-        *self == Zero::zero()\n+        self.re.is_zero() && self.im.is_zero()\n     }\n }\n \n-impl<T: Copy + Num> One for Cmplx<T> {\n+impl<T: Clone + Num> One for Cmplx<T> {\n     #[inline]\n     fn one() -> Cmplx<T> {\n         Cmplx::new(One::one(), Zero::zero())\n@@ -166,7 +195,7 @@ impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use core::num::{Zero,One};\n+    use core::num::{Zero,One,Real};\n \n     pub static _0_0i : Complex = Cmplx { re: 0f, im: 0f };\n     pub static _1_0i : Complex = Cmplx { re: 1f, im: 0f };\n@@ -193,9 +222,10 @@ mod test {\n     }\n \n     #[test]\n-    fn test_norm_sqr() {\n+    fn test_norm() {\n         fn test(c: Complex, ns: float) {\n             assert_eq!(c.norm_sqr(), ns);\n+            assert_eq!(c.norm(), ns.sqrt())\n         }\n         test(_0_0i, 0f);\n         test(_1_0i, 1f);\n@@ -235,6 +265,25 @@ mod test {\n         _0_0i.inv();\n     }\n \n+    #[test]\n+    fn test_arg() {\n+        fn test(c: Complex, arg: float) {\n+            assert!(c.arg().approx_eq(&arg))\n+        }\n+        test(_1_0i, 0f);\n+        test(_1_1i, 0.25f * Real::pi());\n+        test(_neg1_1i, 0.75f * Real::pi());\n+        test(_05_05i, 0.25f * Real::pi());\n+    }\n+\n+    #[test]\n+    fn test_polar_conv() {\n+        fn test(c: Complex) {\n+            let (r, theta) = c.to_polar();\n+            assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n+        }\n+        for all_consts.each |&c| { test(c); }\n+    }\n \n     mod arith {\n         use super::*;"}, {"sha": "7f9811873003ab2077ff2a17f81790f2a1ebdfd1", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=075da9c3e9f326589056abd6edf1f196f6b2e244", "patch": "@@ -391,7 +391,7 @@ impl Fractional for f32 {\n \n impl Algebraic for f32 {\n     #[inline(always)]\n-    fn pow(&self, n: f32) -> f32 { pow(*self, n) }\n+    fn pow(&self, n: &f32) -> f32 { pow(*self, *n) }\n \n     #[inline(always)]\n     fn sqrt(&self) -> f32 { sqrt(*self) }\n@@ -403,7 +403,7 @@ impl Algebraic for f32 {\n     fn cbrt(&self) -> f32 { cbrt(*self) }\n \n     #[inline(always)]\n-    fn hypot(&self, other: f32) -> f32 { hypot(*self, other) }\n+    fn hypot(&self, other: &f32) -> f32 { hypot(*self, *other) }\n }\n \n impl Trigonometric for f32 {\n@@ -426,7 +426,7 @@ impl Trigonometric for f32 {\n     fn atan(&self) -> f32 { atan(*self) }\n \n     #[inline(always)]\n-    fn atan2(&self, other: f32) -> f32 { atan2(*self, other) }\n+    fn atan2(&self, other: &f32) -> f32 { atan2(*self, *other) }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline(always)]\n@@ -450,7 +450,7 @@ impl Exponential for f32 {\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline(always)]\n-    fn log(&self, base: f32) -> f32 { self.ln() / base.ln() }\n+    fn log(&self, base: &f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline(always)]"}, {"sha": "6303e3045764e9b26698b571fc574408fef8526c", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=075da9c3e9f326589056abd6edf1f196f6b2e244", "patch": "@@ -403,7 +403,7 @@ impl Fractional for f64 {\n \n impl Algebraic for f64 {\n     #[inline(always)]\n-    fn pow(&self, n: f64) -> f64 { pow(*self, n) }\n+    fn pow(&self, n: &f64) -> f64 { pow(*self, *n) }\n \n     #[inline(always)]\n     fn sqrt(&self) -> f64 { sqrt(*self) }\n@@ -415,7 +415,7 @@ impl Algebraic for f64 {\n     fn cbrt(&self) -> f64 { cbrt(*self) }\n \n     #[inline(always)]\n-    fn hypot(&self, other: f64) -> f64 { hypot(*self, other) }\n+    fn hypot(&self, other: &f64) -> f64 { hypot(*self, *other) }\n }\n \n impl Trigonometric for f64 {\n@@ -438,7 +438,7 @@ impl Trigonometric for f64 {\n     fn atan(&self) -> f64 { atan(*self) }\n \n     #[inline(always)]\n-    fn atan2(&self, other: f64) -> f64 { atan2(*self, other) }\n+    fn atan2(&self, other: &f64) -> f64 { atan2(*self, *other) }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline(always)]\n@@ -462,7 +462,7 @@ impl Exponential for f64 {\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline(always)]\n-    fn log(&self, base: f64) -> f64 { self.ln() / base.ln() }\n+    fn log(&self, base: &f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline(always)]"}, {"sha": "267a8890e8267349e96504fd2ffc8dc1ea26a4a0", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=075da9c3e9f326589056abd6edf1f196f6b2e244", "patch": "@@ -475,8 +475,8 @@ impl Fractional for float {\n \n impl Algebraic for float {\n     #[inline(always)]\n-    fn pow(&self, n: float) -> float {\n-        (*self as f64).pow(n as f64) as float\n+    fn pow(&self, n: &float) -> float {\n+        (*self as f64).pow(&(*n as f64)) as float\n     }\n \n     #[inline(always)]\n@@ -495,8 +495,8 @@ impl Algebraic for float {\n     }\n \n     #[inline(always)]\n-    fn hypot(&self, other: float) -> float {\n-        (*self as f64).hypot(other as f64) as float\n+    fn hypot(&self, other: &float) -> float {\n+        (*self as f64).hypot(&(*other as f64)) as float\n     }\n }\n \n@@ -532,8 +532,8 @@ impl Trigonometric for float {\n     }\n \n     #[inline(always)]\n-    fn atan2(&self, other: float) -> float {\n-        (*self as f64).atan2(other as f64) as float\n+    fn atan2(&self, other: &float) -> float {\n+        (*self as f64).atan2(&(*other as f64)) as float\n     }\n \n     /// Simultaneously computes the sine and cosine of the number\n@@ -566,8 +566,8 @@ impl Exponential for float {\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline(always)]\n-    fn log(&self, base: float) -> float {\n-        (*self as f64).log(base as f64) as float\n+    fn log(&self, base: &float) -> float {\n+        (*self as f64).log(&(*base as f64)) as float\n     }\n \n     /// Returns the base 2 logarithm of the number"}, {"sha": "a9893579721c1365c57c13d3b442134a45d44330", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075da9c3e9f326589056abd6edf1f196f6b2e244/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=075da9c3e9f326589056abd6edf1f196f6b2e244", "patch": "@@ -106,11 +106,11 @@ pub trait Fractional: Num\n }\n \n pub trait Algebraic {\n-    fn pow(&self, n: Self) -> Self;\n+    fn pow(&self, n: &Self) -> Self;\n     fn sqrt(&self) -> Self;\n     fn rsqrt(&self) -> Self;\n     fn cbrt(&self) -> Self;\n-    fn hypot(&self, other: Self) -> Self;\n+    fn hypot(&self, other: &Self) -> Self;\n }\n \n pub trait Trigonometric {\n@@ -120,15 +120,15 @@ pub trait Trigonometric {\n     fn asin(&self) -> Self;\n     fn acos(&self) -> Self;\n     fn atan(&self) -> Self;\n-    fn atan2(&self, other: Self) -> Self;\n+    fn atan2(&self, other: &Self) -> Self;\n     fn sin_cos(&self) -> (Self, Self);\n }\n \n pub trait Exponential {\n     fn exp(&self) -> Self;\n     fn exp2(&self) -> Self;\n     fn ln(&self) -> Self;\n-    fn log(&self, base: Self) -> Self;\n+    fn log(&self, base: &Self) -> Self;\n     fn log2(&self) -> Self;\n     fn log10(&self) -> Self;\n }"}]}