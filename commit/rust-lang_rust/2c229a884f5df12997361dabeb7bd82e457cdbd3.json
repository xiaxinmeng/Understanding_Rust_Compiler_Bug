{"sha": "2c229a884f5df12997361dabeb7bd82e457cdbd3", "node_id": "C_kwDOAAsO6NoAKDJjMjI5YTg4NGY1ZGYxMjk5NzM2MWRhYmViN2JkODJlNDU3Y2RiZDM", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-02-03T19:48:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-03T19:48:22Z"}, "message": "Merge pull request #1346 from bjorn3/self_profile_cleanup\n\nImprove -Ztime-passes and -Zself-profile output", "tree": {"sha": "c617d23fbb6c0f6e50f4516a6ad751b42d902c6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c617d23fbb6c0f6e50f4516a6ad751b42d902c6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c229a884f5df12997361dabeb7bd82e457cdbd3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj3WUGCRBK7hj4Ov3rIwAAw1YIAAY7cWlgHNJkFMXPds1EWdnq\n7TLslZ24RgXQqFnjZf2qmWtL+GLRfRvnyxrvStkn0RIU6sKrAwQNij+15YDxVYTO\nAYc5+2g1fy4Vs+J/EFTg4omXYeC4EsLPLwXjna7XDZ86hB7ZWsYvM3a6qCjSgcOr\nW+eLmEvgu8NJkTPzUHqSYp5mR9jkmOe1q+WHvV4pft1z51CHtf70EEDKI0zaBhCj\n5Fioo+ZM3JCpa/TLpgRFMzUeUcu5Cz7y3B0H7jk23zwVAroLwTW2wPYBp3VfAnwE\njNsj9+4IxlL+wiUByMQXznCGd+2XZoX/gAqb/nFGjuXx0Q6c5NZrG5zRw+0xYuw=\n=wh7v\n-----END PGP SIGNATURE-----\n", "payload": "tree c617d23fbb6c0f6e50f4516a6ad751b42d902c6e\nparent 21bdff8bc015b557bfae85b968dc4c100be85caf\nparent a0d3b0963d68ebf4d63bd8ac4a3ca5ab3cc44873\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1675453702 +0100\ncommitter GitHub <noreply@github.com> 1675453702 +0100\n\nMerge pull request #1346 from bjorn3/self_profile_cleanup\n\nImprove -Ztime-passes and -Zself-profile output"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c229a884f5df12997361dabeb7bd82e457cdbd3", "html_url": "https://github.com/rust-lang/rust/commit/2c229a884f5df12997361dabeb7bd82e457cdbd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c229a884f5df12997361dabeb7bd82e457cdbd3/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21bdff8bc015b557bfae85b968dc4c100be85caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/21bdff8bc015b557bfae85b968dc4c100be85caf", "html_url": "https://github.com/rust-lang/rust/commit/21bdff8bc015b557bfae85b968dc4c100be85caf"}, {"sha": "a0d3b0963d68ebf4d63bd8ac4a3ca5ab3cc44873", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d3b0963d68ebf4d63bd8ac4a3ca5ab3cc44873", "html_url": "https://github.com/rust-lang/rust/commit/a0d3b0963d68ebf4d63bd8ac4a3ca5ab3cc44873"}], "stats": {"total": 259, "additions": 136, "deletions": 123}, "files": [{"sha": "3f5cc38b04c6291562a5997bf9da08d3b24d3147", "filename": "src/base.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=2c229a884f5df12997361dabeb7bd82e457cdbd3", "patch": "@@ -21,23 +21,6 @@ pub(crate) struct CodegenedFunction {\n     func_debug_cx: Option<FunctionDebugContext>,\n }\n \n-#[cfg_attr(not(feature = \"jit\"), allow(dead_code))]\n-pub(crate) fn codegen_and_compile_fn<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    cx: &mut crate::CodegenCx,\n-    cached_context: &mut Context,\n-    module: &mut dyn Module,\n-    instance: Instance<'tcx>,\n-) {\n-    let _inst_guard =\n-        crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n-\n-    let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n-    let codegened_func = codegen_fn(tcx, cx, cached_func, module, instance);\n-\n-    compile_fn(cx, cached_context, module, codegened_func);\n-}\n-\n pub(crate) fn codegen_fn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     cx: &mut crate::CodegenCx,\n@@ -47,6 +30,9 @@ pub(crate) fn codegen_fn<'tcx>(\n ) -> CodegenedFunction {\n     debug_assert!(!instance.substs.needs_infer());\n \n+    let symbol_name = tcx.symbol_name(instance).name.to_string();\n+    let _timer = tcx.prof.generic_activity_with_arg(\"codegen fn\", &*symbol_name);\n+\n     let mir = tcx.instance_mir(instance.def);\n     let _mir_guard = crate::PrintOnPanic(|| {\n         let mut buf = Vec::new();\n@@ -58,7 +44,6 @@ pub(crate) fn codegen_fn<'tcx>(\n     });\n \n     // Declare function\n-    let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let sig = get_function_sig(tcx, module.target_config().default_call_conv, instance);\n     let func_id = module.declare_function(&symbol_name, Linkage::Local, &sig).unwrap();\n \n@@ -112,7 +97,7 @@ pub(crate) fn codegen_fn<'tcx>(\n         next_ssa_var: 0,\n     };\n \n-    tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n+    tcx.prof.generic_activity(\"codegen clif ir\").run(|| codegen_fn_body(&mut fx, start_block));\n     fx.bcx.seal_all_blocks();\n     fx.bcx.finalize();\n \n@@ -146,6 +131,9 @@ pub(crate) fn compile_fn(\n     module: &mut dyn Module,\n     codegened_func: CodegenedFunction,\n ) {\n+    let _timer =\n+        cx.profiler.generic_activity_with_arg(\"compile function\", &*codegened_func.symbol_name);\n+\n     let clif_comments = codegened_func.clif_comments;\n \n     // Store function in context\n@@ -191,9 +179,30 @@ pub(crate) fn compile_fn(\n     };\n \n     // Define function\n-    cx.profiler.verbose_generic_activity(\"define function\").run(|| {\n+    cx.profiler.generic_activity(\"define function\").run(|| {\n         context.want_disasm = cx.should_write_ir;\n         module.define_function(codegened_func.func_id, context).unwrap();\n+\n+        if cx.profiler.enabled() {\n+            let mut recording_args = false;\n+            cx.profiler\n+                .generic_activity_with_arg_recorder(\n+                    \"define function (clif pass timings)\",\n+                    |recorder| {\n+                        let pass_times = cranelift_codegen::timing::take_current();\n+                        // Replace newlines with | as measureme doesn't allow control characters like\n+                        // newlines inside strings.\n+                        recorder.record_arg(format!(\"{}\", pass_times).replace(\"\\n\", \" | \"));\n+                        recording_args = true;\n+                    },\n+                )\n+                .run(|| {\n+                    if recording_args {\n+                        // Wait a tiny bit to ensure chrome's profiler doesn't hide the event\n+                        std::thread::sleep(std::time::Duration::from_nanos(2))\n+                    }\n+                });\n+        }\n     });\n \n     if cx.should_write_ir {\n@@ -220,7 +229,7 @@ pub(crate) fn compile_fn(\n     let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n-    cx.profiler.verbose_generic_activity(\"generate debug info\").run(|| {\n+    cx.profiler.generic_activity(\"generate debug info\").run(|| {\n         if let Some(debug_context) = debug_context {\n             codegened_func.func_debug_cx.unwrap().finalize(\n                 debug_context,\n@@ -237,7 +246,7 @@ pub(crate) fn verify_func(\n     writer: &crate::pretty_clif::CommentWriter,\n     func: &Function,\n ) {\n-    tcx.sess.time(\"verify clif ir\", || {\n+    tcx.prof.generic_activity(\"verify clif ir\").run(|| {\n         let flags = cranelift_codegen::settings::Flags::new(cranelift_codegen::settings::builder());\n         match cranelift_codegen::verify_function(&func, &flags) {\n             Ok(_) => {}\n@@ -273,7 +282,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n         fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n         return;\n     }\n-    fx.tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(fx, start_block));\n+    fx.tcx\n+        .prof\n+        .generic_activity(\"codegen prelude\")\n+        .run(|| crate::abi::codegen_fn_prelude(fx, start_block));\n \n     for (bb, bb_data) in fx.mir.basic_blocks.iter_enumerated() {\n         let block = fx.get_block(bb);\n@@ -434,7 +446,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n-                fx.tcx.sess.time(\"codegen call\", || {\n+                fx.tcx.prof.generic_activity(\"codegen call\").run(|| {\n                     crate::abi::codegen_terminator_call(\n                         fx,\n                         mir::SourceInfo { span: *fn_span, ..source_info },"}, {"sha": "263401e1c4b8343f76a2ad52e8fc90097a58a1c7", "filename": "src/config.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=2c229a884f5df12997361dabeb7bd82e457cdbd3", "patch": "@@ -42,12 +42,6 @@ pub struct BackendConfig {\n     /// Defaults to the value of `CG_CLIF_JIT_ARGS`.\n     pub jit_args: Vec<String>,\n \n-    /// Display the time it took to perform codegen for a crate.\n-    ///\n-    /// Defaults to true when the `CG_CLIF_DISPLAY_CG_TIME` env var is set to 1 or false otherwise.\n-    /// Can be set using `-Cllvm-args=display_cg_time=...`.\n-    pub display_cg_time: bool,\n-\n     /// Enable the Cranelift ir verifier for all compilation passes. If not set it will only run\n     /// once before passing the clif ir to Cranelift for compilation.\n     ///\n@@ -73,7 +67,6 @@ impl Default for BackendConfig {\n                 let args = std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n                 args.split(' ').map(|arg| arg.to_string()).collect()\n             },\n-            display_cg_time: bool_env_var(\"CG_CLIF_DISPLAY_CG_TIME\"),\n             enable_verifier: cfg!(debug_assertions) || bool_env_var(\"CG_CLIF_ENABLE_VERIFIER\"),\n             disable_incr_cache: bool_env_var(\"CG_CLIF_DISABLE_INCR_CACHE\"),\n         }\n@@ -92,7 +85,6 @@ impl BackendConfig {\n             if let Some((name, value)) = opt.split_once('=') {\n                 match name {\n                     \"mode\" => config.codegen_mode = value.parse()?,\n-                    \"display_cg_time\" => config.display_cg_time = parse_bool(name, value)?,\n                     \"enable_verifier\" => config.enable_verifier = parse_bool(name, value)?,\n                     \"disable_incr_cache\" => config.disable_incr_cache = parse_bool(name, value)?,\n                     _ => return Err(format!(\"Unknown option `{}`\", name)),"}, {"sha": "58b01dfb5b0ec84b25600137467fbe733ca1fe51", "filename": "src/driver/aot.rs", "status": "modified", "additions": 72, "deletions": 58, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=2c229a884f5df12997361dabeb7bd82e457cdbd3", "patch": "@@ -272,25 +272,25 @@ fn module_codegen(\n         ConcurrencyLimiterToken,\n     ),\n ) -> OngoingModuleCodegen {\n-    let (cgu_name, mut cx, mut module, codegened_functions) = tcx.sess.time(\"codegen cgu\", || {\n-        let cgu = tcx.codegen_unit(cgu_name);\n-        let mono_items = cgu.items_in_deterministic_order(tcx);\n-\n-        let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n-\n-        let mut cx = crate::CodegenCx::new(\n-            tcx,\n-            backend_config.clone(),\n-            module.isa(),\n-            tcx.sess.opts.debuginfo != DebugInfo::None,\n-            cgu_name,\n-        );\n-        super::predefine_mono_items(tcx, &mut module, &mono_items);\n-        let mut codegened_functions = vec![];\n-        for (mono_item, _) in mono_items {\n-            match mono_item {\n-                MonoItem::Fn(inst) => {\n-                    tcx.sess.time(\"codegen fn\", || {\n+    let (cgu_name, mut cx, mut module, codegened_functions) =\n+        tcx.prof.verbose_generic_activity_with_arg(\"codegen cgu\", cgu_name.as_str()).run(|| {\n+            let cgu = tcx.codegen_unit(cgu_name);\n+            let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+            let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n+\n+            let mut cx = crate::CodegenCx::new(\n+                tcx,\n+                backend_config.clone(),\n+                module.isa(),\n+                tcx.sess.opts.debuginfo != DebugInfo::None,\n+                cgu_name,\n+            );\n+            super::predefine_mono_items(tcx, &mut module, &mono_items);\n+            let mut codegened_functions = vec![];\n+            for (mono_item, _) in mono_items {\n+                match mono_item {\n+                    MonoItem::Fn(inst) => {\n                         let codegened_function = crate::base::codegen_fn(\n                             tcx,\n                             &mut cx,\n@@ -299,53 +299,68 @@ fn module_codegen(\n                             inst,\n                         );\n                         codegened_functions.push(codegened_function);\n-                    });\n-                }\n-                MonoItem::Static(def_id) => {\n-                    crate::constant::codegen_static(tcx, &mut module, def_id)\n-                }\n-                MonoItem::GlobalAsm(item_id) => {\n-                    crate::global_asm::codegen_global_asm_item(tcx, &mut cx.global_asm, item_id);\n+                    }\n+                    MonoItem::Static(def_id) => {\n+                        crate::constant::codegen_static(tcx, &mut module, def_id)\n+                    }\n+                    MonoItem::GlobalAsm(item_id) => {\n+                        crate::global_asm::codegen_global_asm_item(\n+                            tcx,\n+                            &mut cx.global_asm,\n+                            item_id,\n+                        );\n+                    }\n                 }\n             }\n-        }\n-        crate::main_shim::maybe_create_entry_wrapper(\n-            tcx,\n-            &mut module,\n-            &mut cx.unwind_context,\n-            false,\n-            cgu.is_primary(),\n-        );\n+            crate::main_shim::maybe_create_entry_wrapper(\n+                tcx,\n+                &mut module,\n+                &mut cx.unwind_context,\n+                false,\n+                cgu.is_primary(),\n+            );\n \n-        let cgu_name = cgu.name().as_str().to_owned();\n+            let cgu_name = cgu.name().as_str().to_owned();\n \n-        (cgu_name, cx, module, codegened_functions)\n-    });\n+            (cgu_name, cx, module, codegened_functions)\n+        });\n \n     OngoingModuleCodegen::Async(std::thread::spawn(move || {\n-        cx.profiler.clone().verbose_generic_activity(\"compile functions\").run(|| {\n-            let mut cached_context = Context::new();\n-            for codegened_func in codegened_functions {\n-                crate::base::compile_fn(&mut cx, &mut cached_context, &mut module, codegened_func);\n-            }\n-        });\n+        cx.profiler.clone().verbose_generic_activity_with_arg(\"compile functions\", &*cgu_name).run(\n+            || {\n+                let mut cached_context = Context::new();\n+                for codegened_func in codegened_functions {\n+                    crate::base::compile_fn(\n+                        &mut cx,\n+                        &mut cached_context,\n+                        &mut module,\n+                        codegened_func,\n+                    );\n+                }\n+            },\n+        );\n \n-        let global_asm_object_file =\n-            cx.profiler.verbose_generic_activity(\"compile assembly\").run(|| {\n+        let global_asm_object_file = cx\n+            .profiler\n+            .verbose_generic_activity_with_arg(\"compile assembly\", &*cgu_name)\n+            .run(|| {\n                 crate::global_asm::compile_global_asm(&global_asm_config, &cgu_name, &cx.global_asm)\n             })?;\n \n-        let codegen_result = cx.profiler.verbose_generic_activity(\"write object file\").run(|| {\n-            emit_cgu(\n-                &global_asm_config.output_filenames,\n-                &cx.profiler,\n-                cgu_name,\n-                module,\n-                cx.debug_context,\n-                cx.unwind_context,\n-                global_asm_object_file,\n-            )\n-        });\n+        let codegen_result = cx\n+            .profiler\n+            .verbose_generic_activity_with_arg(\"write object file\", &*cgu_name)\n+            .run(|| {\n+                emit_cgu(\n+                    &global_asm_config.output_filenames,\n+                    &cx.profiler,\n+                    cgu_name,\n+                    module,\n+                    cx.debug_context,\n+                    cx.unwind_context,\n+                    global_asm_object_file,\n+                )\n+            });\n         std::mem::drop(token);\n         codegen_result\n     }))\n@@ -375,7 +390,7 @@ pub(crate) fn run_aot(\n \n     let mut concurrency_limiter = ConcurrencyLimiter::new(tcx.sess, cgus.len());\n \n-    let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n+    let modules = tcx.sess.time(\"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n                 let cgu_reuse = if backend_config.disable_incr_cache {\n@@ -437,7 +452,6 @@ pub(crate) fn run_aot(\n     };\n \n     let metadata_module = if need_metadata_module {\n-        let _timer = tcx.prof.generic_activity(\"codegen crate metadata\");\n         let (metadata_cgu_name, tmp_file) = tcx.sess.time(\"write compressed metadata\", || {\n             use rustc_middle::mir::mono::CodegenUnitNameBuilder;\n "}, {"sha": "8b5a2da2c5944d631de0499f1905029de5c4b3c8", "filename": "src/driver/jit.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=2c229a884f5df12997361dabeb7bd82e457cdbd3", "patch": "@@ -121,22 +121,20 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n+    tcx.sess.time(\"codegen mono items\", || {\n         super::predefine_mono_items(tcx, &mut jit_module, &mono_items);\n         for (mono_item, _) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_and_compile_fn(\n-                                tcx,\n-                                &mut cx,\n-                                &mut cached_context,\n-                                &mut jit_module,\n-                                inst,\n-                            )\n-                        });\n+                        codegen_and_compile_fn(\n+                            tcx,\n+                            &mut cx,\n+                            &mut cached_context,\n+                            &mut jit_module,\n+                            inst,\n+                        );\n                     }\n                     CodegenMode::JitLazy => {\n                         codegen_shim(tcx, &mut cx, &mut cached_context, &mut jit_module, inst)\n@@ -219,6 +217,24 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     }\n }\n \n+pub(crate) fn codegen_and_compile_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n+    cached_context: &mut Context,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) {\n+    tcx.prof.generic_activity(\"codegen and compile fn\").run(|| {\n+        let _inst_guard =\n+            crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n+\n+        let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n+        let codegened_func = crate::base::codegen_fn(tcx, cx, cached_func, module, instance);\n+\n+        crate::base::compile_fn(cx, cached_context, module, codegened_func);\n+    });\n+}\n+\n extern \"C\" fn clif_jit_fn(\n     instance_ptr: *const Instance<'static>,\n     trampoline_ptr: *const u8,\n@@ -271,15 +287,7 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n                 false,\n                 Symbol::intern(\"dummy_cgu_name\"),\n             );\n-            tcx.sess.time(\"codegen fn\", || {\n-                crate::base::codegen_and_compile_fn(\n-                    tcx,\n-                    &mut cx,\n-                    &mut Context::new(),\n-                    jit_module,\n-                    instance,\n-                )\n-            });\n+            codegen_and_compile_fn(tcx, &mut cx, &mut Context::new(), jit_module, instance);\n \n             assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions().unwrap();"}, {"sha": "d09d3a529759cab809e2e8d637b23999fcf57d23", "filename": "src/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c229a884f5df12997361dabeb7bd82e457cdbd3/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=2c229a884f5df12997361dabeb7bd82e457cdbd3", "patch": "@@ -17,7 +17,7 @@ fn predefine_mono_items<'tcx>(\n     module: &mut dyn Module,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n-    tcx.sess.time(\"predefine functions\", || {\n+    tcx.prof.generic_activity(\"predefine functions\").run(|| {\n         let is_compiler_builtins = tcx.is_compiler_builtins(LOCAL_CRATE);\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n@@ -39,16 +39,3 @@ fn predefine_mono_items<'tcx>(\n         }\n     });\n }\n-\n-fn time<R>(tcx: TyCtxt<'_>, display: bool, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if display {\n-        println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n-        let before = std::time::Instant::now();\n-        let res = tcx.sess.time(name, f);\n-        let after = std::time::Instant::now();\n-        println!(\"[{:<30}: {}] end time: {:?}\", tcx.crate_name(LOCAL_CRATE), name, after - before);\n-        res\n-    } else {\n-        tcx.sess.time(name, f)\n-    }\n-}"}]}