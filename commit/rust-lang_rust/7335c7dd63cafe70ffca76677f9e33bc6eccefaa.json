{"sha": "7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMzVjN2RkNjNjYWZlNzBmZmNhNzY2NzdmOWUzM2JjNmVjY2VmYWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-02T19:01:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-02T19:01:12Z"}, "message": "rollup merge of #21830: japaric/for-cleanup\n\nConflicts:\n\tsrc/librustc/metadata/filesearch.rs\n\tsrc/librustc_back/target/mod.rs\n\tsrc/libstd/os.rs\n\tsrc/libstd/sys/windows/os.rs\n\tsrc/libsyntax/ext/tt/macro_parser.rs\n\tsrc/libsyntax/print/pprust.rs\n\tsrc/test/compile-fail/issue-2149.rs", "tree": {"sha": "3646a5159f74b47d8bdf471eff072ea71f395d82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3646a5159f74b47d8bdf471eff072ea71f395d82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "html_url": "https://github.com/rust-lang/rust/commit/7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "075588a4939acb47feea79779a9bdacce702d9c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/075588a4939acb47feea79779a9bdacce702d9c5", "html_url": "https://github.com/rust-lang/rust/commit/075588a4939acb47feea79779a9bdacce702d9c5"}, {"sha": "3484706c38272828efc50b2553578afc62230dbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3484706c38272828efc50b2553578afc62230dbb", "html_url": "https://github.com/rust-lang/rust/commit/3484706c38272828efc50b2553578afc62230dbb"}], "stats": {"total": 2751, "additions": 1308, "deletions": 1443}, "files": [{"sha": "07e92c704d86f9fb854660d24378c27026fac86f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -277,7 +277,7 @@ pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n            config.src_base.display());\n     let mut tests = Vec::new();\n     let dirs = fs::readdir(&config.src_base).unwrap();\n-    for file in dirs.iter() {\n+    for file in &dirs {\n         let file = file.clone();\n         debug!(\"inspecting file {:?}\", file.display());\n         if is_test(config, &file) {\n@@ -305,13 +305,13 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n \n     let mut valid = false;\n \n-    for ext in valid_extensions.iter() {\n+    for ext in &valid_extensions {\n         if name.ends_with(ext.as_slice()) {\n             valid = true;\n         }\n     }\n \n-    for pre in invalid_prefixes.iter() {\n+    for pre in &invalid_prefixes {\n         if name.starts_with(pre.as_slice()) {\n             valid = false;\n         }"}, {"sha": "4b0eea33d69b7a2176cd0c0c86d1480f43409c48", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -40,13 +40,13 @@ pub fn run(lib_path: &str,\n     let mut cmd = Command::new(prog);\n     cmd.args(args);\n     add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env.into_iter() {\n+    for (key, val) in env {\n         cmd.env(key, val);\n     }\n \n     match cmd.spawn() {\n         Ok(mut process) => {\n-            for input in input.iter() {\n+            if let Some(input) = input {\n                 process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n             let ProcessOutput { status, output, error } =\n@@ -72,13 +72,13 @@ pub fn run_background(lib_path: &str,\n     let mut cmd = Command::new(prog);\n     cmd.args(args);\n     add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env.into_iter() {\n+    for (key, val) in env {\n         cmd.env(key, val);\n     }\n \n     match cmd.spawn() {\n         Ok(mut process) => {\n-            for input in input.iter() {\n+            if let Some(input) = input {\n                 process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n "}, {"sha": "5bb0a4031ead5cac3844a717e8db5fd9e3793a0e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -547,7 +547,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                          exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))[]);\n \n             // Add line breakpoints\n-            for line in breakpoint_lines.iter() {\n+            for line in &breakpoint_lines {\n                 script_str.push_str(&format!(\"break '{}':{}\\n\",\n                                              testfile.filename_display(),\n                                              *line)[]);\n@@ -683,13 +683,13 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     script_str.push_str(\"type category enable Rust\\n\");\n \n     // Set breakpoints on every line that contains the string \"#break\"\n-    for line in breakpoint_lines.iter() {\n+    for line in &breakpoint_lines {\n         script_str.push_str(format!(\"breakpoint set --line {}\\n\",\n                                     line).as_slice());\n     }\n \n     // Append the other commands\n-    for line in commands.iter() {\n+    for line in &commands {\n         script_str.push_str(line.as_slice());\n         script_str.push_str(\"\\n\");\n     }\n@@ -847,7 +847,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             let mut rest = line.trim();\n             let mut first = true;\n             let mut failed = false;\n-            for frag in check_fragments[i].iter() {\n+            for frag in &check_fragments[i] {\n                 let found = if first {\n                     if rest.starts_with(frag.as_slice()) {\n                         Some(0)\n@@ -915,7 +915,7 @@ fn check_error_patterns(props: &TestProps,\n                               missing_patterns[0]).as_slice(),\n                       proc_res);\n     } else {\n-        for pattern in missing_patterns.iter() {\n+        for pattern in missing_patterns {\n             error(format!(\"error pattern '{}' not found!\",\n                           *pattern).as_slice());\n         }\n@@ -935,7 +935,7 @@ fn check_no_compiler_crash(proc_res: &ProcRes) {\n fn check_forbid_output(props: &TestProps,\n                        output_to_check: &str,\n                        proc_res: &ProcRes) {\n-    for pat in props.forbid_output.iter() {\n+    for pat in &props.forbid_output {\n         if output_to_check.contains(pat.as_slice()) {\n             fatal_proc_rec(\"forbidden pattern found in compiler output\", proc_res);\n         }\n@@ -1173,7 +1173,7 @@ fn compose_and_run_compiler(\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let extra_link_args = vec!(\"-L\".to_string(), aux_dir.as_str().unwrap().to_string());\n \n-    for rel_ab in props.aux_builds.iter() {\n+    for rel_ab in &props.aux_builds {\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = header::load_props(&abs_ab);\n         let mut crate_type = if aux_props.no_prefer_dynamic {\n@@ -1503,14 +1503,14 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     // run test via adb_run_wrapper\n     runargs.push(\"shell\".to_string());\n-    for (key, val) in env.into_iter() {\n+    for (key, val) in env {\n         runargs.push(format!(\"{}={}\", key, val));\n     }\n     runargs.push(format!(\"{}/adb_run_wrapper.sh\", config.adb_test_dir));\n     runargs.push(format!(\"{}\", config.adb_test_dir));\n     runargs.push(format!(\"{}\", prog_short));\n \n-    for tv in args.args.iter() {\n+    for tv in &args.args {\n         runargs.push(tv.to_string());\n     }\n     procsrv::run(\"\",\n@@ -1591,7 +1591,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n     let tdir = aux_output_dir_name(config, testfile);\n \n     let dirs = fs::readdir(&tdir).unwrap();\n-    for file in dirs.iter() {\n+    for file in &dirs {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\","}, {"sha": "078d992277af3f1eed0a65b4d13f89dc60d47f42", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -27,7 +27,7 @@ static OS_TABLE: &'static [(&'static str, &'static str)] = &[\n ];\n \n pub fn get_os(triple: &str) -> &'static str {\n-    for &(triple_os, os) in OS_TABLE.iter() {\n+    for &(triple_os, os) in OS_TABLE {\n         if triple.contains(triple_os) {\n             return os\n         }"}, {"sha": "0ff6cf7b79a359be37a4964de1252707efe462e3", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -127,7 +127,7 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&*self.head.borrow());\n-            for chunk in self.chunks.borrow().iter() {\n+            for chunk in &*self.chunks.borrow() {\n                 if !chunk.is_copy.get() {\n                     destroy_chunk(chunk);\n                 }"}, {"sha": "9301bf5e4ab47c701a57ef29f3a91fbbc868c10e", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -73,7 +73,7 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n     let mut keys = (0..n).map(|_| rng.gen::<uint>() % n)\n                               .collect::<Vec<_>>();\n \n-    for k in keys.iter() {\n+    for k in &keys {\n         insert(map, *k);\n     }\n "}, {"sha": "b51ec13335e0eb721ef52d8a73f5d90e0ab5cb0b", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -673,7 +673,7 @@ impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n-    fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {\n         let (lower, _) = iter.size_hint();\n \n         self.reserve(lower);\n@@ -696,7 +696,7 @@ mod tests {\n         let iterout = [9, 5, 3];\n         let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n-        for el in heap.iter() {\n+        for el in &heap {\n             assert_eq!(*el, iterout[i]);\n             i += 1;\n         }\n@@ -884,7 +884,7 @@ mod tests {\n \n         let mut q: BinaryHeap<uint> = xs.iter().rev().map(|&x| x).collect();\n \n-        for &x in xs.iter() {\n+        for &x in &xs {\n             assert_eq!(q.pop().unwrap(), x);\n         }\n     }"}, {"sha": "3e603f6ebaf86862703e047e0d2ccca269cdfb40", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -431,7 +431,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n-        for w in self.storage.iter_mut() { *w = !0u32; }\n+        for w in &mut self.storage { *w = !0u32; }\n         self.fix_last_block();\n     }\n \n@@ -451,7 +451,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n-        for w in self.storage.iter_mut() { *w = !*w; }\n+        for w in &mut self.storage { *w = !*w; }\n         self.fix_last_block();\n     }\n \n@@ -912,7 +912,7 @@ impl Bitv {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        for w in self.storage.iter_mut() { *w = 0u32; }\n+        for w in &mut self.storage { *w = 0u32; }\n     }\n }\n \n@@ -934,7 +934,7 @@ impl FromIterator<bool> for Bitv {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<bool> for Bitv {\n     #[inline]\n-    fn extend<I: Iterator<Item=bool>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=bool>>(&mut self, iterator: I) {\n         let (min, _) = iterator.size_hint();\n         self.reserve(min);\n         for element in iterator {\n@@ -976,7 +976,7 @@ impl Ord for Bitv {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        for bit in self.iter() {\n+        for bit in self {\n             try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n         }\n         Ok(())\n@@ -1141,7 +1141,7 @@ impl FromIterator<uint> for BitvSet {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<uint> for BitvSet {\n     #[inline]\n-    fn extend<I: Iterator<Item=uint>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=uint>>(&mut self, iterator: I) {\n         for i in iterator {\n             self.insert(i);\n         }\n@@ -1353,7 +1353,7 @@ impl BitvSet {\n         }\n \n         // virtually pad other with 0's for equal lengths\n-        let mut other_words = {\n+        let other_words = {\n             let (_, result) = match_words(self_bitv, other_bitv);\n             result\n         };\n@@ -1743,7 +1743,7 @@ impl fmt::Debug for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"BitvSet {{\"));\n         let mut first = true;\n-        for n in self.iter() {\n+        for n in self {\n             if !first {\n                 try!(write!(fmt, \", \"));\n             }\n@@ -1756,7 +1756,7 @@ impl fmt::Debug for BitvSet {\n \n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n     fn hash(&self, state: &mut S) {\n-        for pos in self.iter() {\n+        for pos in self {\n             pos.hash(state);\n         }\n     }\n@@ -2600,7 +2600,7 @@ mod bitv_bench {\n         b.iter(|| {\n             let mut sum = 0u;\n             for _ in 0u..10 {\n-                for pres in bitv.iter() {\n+                for pres in &bitv {\n                     sum += pres as uint;\n                 }\n             }\n@@ -2613,7 +2613,7 @@ mod bitv_bench {\n         let bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             let mut sum = 0u;\n-            for pres in bitv.iter() {\n+            for pres in &bitv {\n                 sum += pres as uint;\n             }\n             sum\n@@ -2674,8 +2674,8 @@ mod bitv_set_test {\n     fn test_bitv_set_frombitv_init() {\n         let bools = [true, false];\n         let lengths = [10, 64, 100];\n-        for &b in bools.iter() {\n-            for &l in lengths.iter() {\n+        for &b in &bools {\n+            for &l in &lengths {\n                 let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n                 assert_eq!(bitset.contains(&1u), b);\n                 assert_eq!(bitset.contains(&(l-1u)), b);\n@@ -3062,7 +3062,7 @@ mod bitv_set_bench {\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n             let mut sum = 0u;\n-            for idx in bitv.iter() {\n+            for idx in &bitv {\n                 sum += idx as uint;\n             }\n             sum"}, {"sha": "f1d39b3f2f447777cdabbb8164397e08468d1039", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -197,7 +197,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n-        for _ in mem::replace(self, BTreeMap::with_b(b)).into_iter() {};\n+        for _ in mem::replace(self, BTreeMap::with_b(b)) {};\n     }\n \n     // Searching in a B-Tree is pretty straightforward.\n@@ -846,7 +846,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n+    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -856,7 +856,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n         }\n     }\n@@ -1946,7 +1946,7 @@ mod bench {\n         }\n \n         b.iter(|| {\n-            for entry in map.iter() {\n+            for entry in &map {\n                 black_box(entry);\n             }\n         });"}, {"sha": "8fdfe9ed56a4882014fdcce5f8e1dea865bbbaa1", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -435,13 +435,13 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n             let mut vals = RawItems::from_parts(ret.vals().as_ptr(), 0);\n             let mut edges = RawItems::from_parts(ret.edges().as_ptr(), 0);\n \n-            for key in self.keys().iter() {\n+            for key in self.keys() {\n                 keys.push(key.clone())\n             }\n-            for val in self.vals().iter() {\n+            for val in self.vals() {\n                 vals.push(val.clone())\n             }\n-            for edge in self.edges().iter() {\n+            for edge in self.edges() {\n                 edges.push(edge.clone())\n             }\n "}, {"sha": "d58ae03ef7a28b41bd855d83d5ad9a6c9f3f87b8", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -499,7 +499,7 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n-    fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {\n         for elem in iter {\n             self.insert(elem);\n         }\n@@ -791,8 +791,8 @@ mod test {\n         let mut set_a = BTreeSet::new();\n         let mut set_b = BTreeSet::new();\n \n-        for x in a.iter() { assert!(set_a.insert(*x)) }\n-        for y in b.iter() { assert!(set_b.insert(*y)) }\n+        for x in a { assert!(set_a.insert(*x)) }\n+        for y in b { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n         f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n@@ -894,7 +894,7 @@ mod test {\n \n         let set: BTreeSet<int> = xs.iter().map(|&x| x).collect();\n \n-        for x in xs.iter() {\n+        for x in &xs {\n             assert!(set.contains(x));\n         }\n     }"}, {"sha": "d85e9ee32265e134fcfc9f2858b2eca5baecf26c", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -856,7 +856,7 @@ impl<'a, T> IntoIterator for &'a mut DList<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for DList<A> {\n-    fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n+    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n     }\n }\n@@ -917,7 +917,7 @@ impl<A: fmt::Debug> fmt::Debug for DList<A> {\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n         }\n     }\n@@ -1061,7 +1061,7 @@ mod tests {\n         let mut sum = v;\n         sum.push_all(u.as_slice());\n         assert_eq!(sum.len(), m.len());\n-        for elt in sum.into_iter() {\n+        for elt in sum {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n         assert_eq!(n.len(), 0);"}, {"sha": "8cbf50d29f23b02ebe9347b89c83dd619499e653", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -36,7 +36,7 @@ impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"EnumSet {{\"));\n         let mut first = true;\n-        for e in self.iter() {\n+        for e in self {\n             if !first {\n                 try!(write!(fmt, \", \"));\n             }\n@@ -266,7 +266,7 @@ impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n }\n \n impl<E:CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: Iterator<Item=E>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=E>>(&mut self, iterator: I) {\n         for element in iterator {\n             self.insert(element);\n         }"}, {"sha": "102dfb3df9d0319b4e221ca4863bb07c49cfc618", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -22,8 +22,6 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(core)]"}, {"sha": "18021dea9f29ed5f118208d9b948a5a1431b4cac", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1573,7 +1573,7 @@ impl<A: Ord> Ord for RingBuf<A> {\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n         }\n     }\n@@ -1635,7 +1635,7 @@ impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n-    fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n+    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n         for elt in iterator {\n             self.push_back(elt);\n         }\n@@ -1856,7 +1856,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut sum = 0;\n-            for &i in ring.iter() {\n+            for &i in &ring {\n                 sum += i;\n             }\n             test::black_box(sum);\n@@ -1869,7 +1869,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut sum = 0;\n-            for i in ring.iter_mut() {\n+            for i in &mut ring {\n                 sum += *i;\n             }\n             test::black_box(sum);"}, {"sha": "4b4ea3e4c3ca539729dc22c657aabc7be7221a67", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -98,9 +98,6 @@ use core::iter::{range_step, MultiplicativeIterator};\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n-#[cfg(stage0)]\n-use core::ops::{FnMut, FullRange};\n-#[cfg(not(stage0))]\n use core::ops::FnMut;\n use core::option::Option::{self, Some, None};\n use core::ptr::PtrExt;\n@@ -1121,7 +1118,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n     fn concat(&self) -> Vec<T> {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size);\n-        for v in self.iter() {\n+        for v in self {\n             result.push_all(v.as_slice())\n         }\n         result\n@@ -1131,7 +1128,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n-        for v in self.iter() {\n+        for v in self {\n             if first { first = false } else { result.push(sep.clone()) }\n             result.push_all(v.as_slice())\n         }\n@@ -1231,7 +1228,7 @@ impl Iterator for ElementSwaps {\n                 self.sdir.swap(i, j);\n \n                 // Swap the direction of each larger SizeDirection\n-                for x in self.sdir.iter_mut() {\n+                for x in &mut self.sdir {\n                     if x.size > sd.size {\n                         x.dir = match x.dir { Pos => Neg, Neg => Pos };\n                     }\n@@ -1512,9 +1509,6 @@ mod tests {\n     use core::prelude::{Some, None, range, Clone};\n     use core::prelude::{Iterator, IteratorExt};\n     use core::prelude::{AsSlice};\n-    #[cfg(stage0)]\n-    use core::prelude::{Ord, FullRange};\n-    #[cfg(not(stage0))]\n     use core::prelude::Ord;\n     use core::default::Default;\n     use core::mem;\n@@ -2362,7 +2356,7 @@ mod tests {\n     #[test]\n     fn test_mut_iterator() {\n         let mut xs = [1, 2, 3, 4, 5];\n-        for x in xs.iter_mut() {\n+        for x in &mut xs {\n             *x += 1;\n         }\n         assert!(xs == [2, 3, 4, 5, 6])\n@@ -2662,15 +2656,15 @@ mod tests {\n                 let left: &[_] = left;\n                 assert!(left[..left.len()] == [1, 2][]);\n             }\n-            for p in left.iter_mut() {\n+            for p in left {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n                 assert!(right[..right.len()] == [3, 4, 5][]);\n             }\n-            for p in right.iter_mut() {\n+            for p in right {\n                 *p += 2;\n             }\n         }\n@@ -2687,33 +2681,33 @@ mod tests {\n         assert_eq!(v.len(), 3);\n         let mut cnt = 0u;\n \n-        for f in v.iter() {\n+        for f in &v {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v[1..3].iter() {\n+        for f in &v[1..3] {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 5);\n \n-        for f in v.iter_mut() {\n+        for f in &mut v {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 8);\n \n-        for f in v.into_iter() {\n+        for f in v {\n             assert!(f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 11);\n \n         let xs: [Foo; 3] = [Foo, Foo, Foo];\n         cnt = 0;\n-        for f in xs.iter() {\n+        for f in &xs {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n@@ -2802,7 +2796,7 @@ mod tests {\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n         assert_eq!(v.chunks_mut(2).len(), 4);\n         for (i, chunk) in v.chunks_mut(3).enumerate() {\n-            for x in chunk.iter_mut() {\n+            for x in chunk {\n                 *x = i as u8;\n             }\n         }\n@@ -2814,7 +2808,7 @@ mod tests {\n     fn test_mut_chunks_rev() {\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n         for (i, chunk) in v.chunks_mut(3).rev().enumerate() {\n-            for x in chunk.iter_mut() {\n+            for x in chunk {\n                 *x = i as u8;\n             }\n         }\n@@ -2864,7 +2858,7 @@ mod bench {\n \n         b.iter(|| {\n             let mut sum = 0;\n-            for x in v.iter() {\n+            for x in &v {\n                 sum += *x;\n             }\n             // sum == 11806, to stop dead code elimination.\n@@ -2878,7 +2872,7 @@ mod bench {\n \n         b.iter(|| {\n             let mut i = 0;\n-            for x in v.iter_mut() {\n+            for x in &mut v {\n                 *x = i;\n                 i += 1;\n             }\n@@ -3012,7 +3006,7 @@ mod bench {\n             unsafe {\n                 v.set_len(1024);\n             }\n-            for x in v.iter_mut() {\n+            for x in &mut v {\n                 *x = 0;\n             }\n             v"}, {"sha": "75f7b812974d703daba644a855e53b9721e4b206", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -61,11 +61,6 @@ use core::clone::Clone;\n use core::iter::AdditiveIterator;\n use core::iter::{Iterator, IteratorExt};\n use core::ops::Index;\n-#[cfg(stage0)]\n-use core::ops::FullRange as RangeFull;\n-#[cfg(stage0)]\n-use core::ops::FullRange;\n-#[cfg(not(stage0))]\n use core::ops::RangeFull;\n use core::option::Option::{self, Some, None};\n use core::result::Result;\n@@ -104,7 +99,7 @@ impl<S: Str> SliceConcatExt<str, String> for [S] {\n         let len = s.iter().map(|s| s.as_slice().len()).sum();\n         let mut result = String::with_capacity(len);\n \n-        for s in s.iter() {\n+        for s in s {\n             result.push_str(s.as_slice())\n         }\n \n@@ -130,7 +125,7 @@ impl<S: Str> SliceConcatExt<str, String> for [S] {\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n-        for s in s.iter() {\n+        for s in s {\n             if first {\n                 first = false;\n             } else {\n@@ -2010,7 +2005,7 @@ mod tests {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n-        for ch in v.iter() {\n+        for ch in &v {\n             assert!(s.char_at(pos) == *ch);\n             pos += ch.to_string().len();\n         }\n@@ -2708,7 +2703,7 @@ mod tests {\n             &[\"\\u{378}\\u{308}\\u{903}\"], &[\"\\u{378}\\u{308}\", \"\\u{903}\"]),\n         ];\n \n-        for &(s, g) in test_same.iter() {\n+        for &(s, g) in &test_same[] {\n             // test forward iterator\n             assert!(order::equals(s.graphemes(true), g.iter().map(|&x| x)));\n             assert!(order::equals(s.graphemes(false), g.iter().map(|&x| x)));\n@@ -2718,7 +2713,7 @@ mod tests {\n             assert!(order::equals(s.graphemes(false).rev(), g.iter().rev().map(|&x| x)));\n         }\n \n-        for &(s, gt, gf) in test_diff.iter() {\n+        for &(s, gt, gf) in &test_diff {\n             // test forward iterator\n             assert!(order::equals(s.graphemes(true), gt.iter().map(|&x| x)));\n             assert!(order::equals(s.graphemes(false), gf.iter().map(|&x| x)));"}, {"sha": "554eee765f3eb5efc4a792ed6162b7c06cea5403", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -729,7 +729,7 @@ impl<'a> FromIterator<&'a str> for String {\n #[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl Extend<char> for String {\n-    fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) {\n+    fn extend<I:Iterator<Item=char>>(&mut self, iterator: I) {\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n         for ch in iterator {\n@@ -741,7 +741,7 @@ impl Extend<char> for String {\n #[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl<'a> Extend<&'a str> for String {\n-    fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=&'a str>>(&mut self, iterator: I) {\n         // A guess that at least one byte per iterator element will be needed.\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n@@ -877,16 +877,6 @@ impl ops::Index<ops::RangeFrom<uint>> for String {\n         &self[][*index]\n     }\n }\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::FullRange> for String {\n-    type Output = str;\n-    #[inline]\n-    fn index(&self, _index: &ops::FullRange) -> &str {\n-        unsafe { mem::transmute(self.vec.as_slice()) }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for String {\n     type Output = str;\n@@ -1011,8 +1001,6 @@ mod tests {\n     use str::Utf8Error;\n     use core::iter::repeat;\n     use super::{as_string, CowString};\n-    #[cfg(stage0)]\n-    use core::ops::FullRange;\n \n     #[test]\n     fn test_as_string() {\n@@ -1130,7 +1118,7 @@ mod tests {\n              (String::from_str(\"\\u{20000}\"),\n               vec![0xD840, 0xDC00])];\n \n-        for p in pairs.iter() {\n+        for p in &pairs {\n             let (s, u) = (*p).clone();\n             let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n             let u_as_string = String::from_utf16(u.as_slice()).unwrap();"}, {"sha": "e9ddfd4872f7e3671c77dd1bc1aabbb879ae4412", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1318,16 +1318,6 @@ impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n         self.as_slice().index(index)\n     }\n }\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::FullRange> for Vec<T> {\n-    type Output = [T];\n-    #[inline]\n-    fn index(&self, _index: &ops::FullRange) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n@@ -1361,16 +1351,6 @@ impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n-    type Output = [T];\n-    #[inline]\n-    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n-        self.as_mut_slice()\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n@@ -1395,7 +1375,7 @@ impl<T> ops::DerefMut for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n-    fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n+    fn from_iter<I:Iterator<Item=T>>(iterator: I) -> Vec<T> {\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n         for element in iterator {\n@@ -1432,7 +1412,7 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n #[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n-    fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=T>>(&mut self, iterator: I) {\n         let (lower, _) = iterator.size_hint();\n         self.reserve(lower);\n         for element in iterator {\n@@ -1567,7 +1547,7 @@ impl<T> Drop for Vec<T> {\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n         if self.cap != 0 {\n             unsafe {\n-                for x in self.iter() {\n+                for x in &*self {\n                     ptr::read(x);\n                 }\n                 dealloc(*self.ptr, self.cap)\n@@ -1934,8 +1914,6 @@ mod tests {\n     use prelude::*;\n     use core::mem::size_of;\n     use core::iter::repeat;\n-    #[cfg(stage0)]\n-    use core::ops::FullRange;\n     use test::Bencher;\n     use super::as_vec;\n \n@@ -2044,7 +2022,7 @@ mod tests {\n         {\n             let slice = &mut values[2 ..];\n             assert!(slice == [3, 4, 5]);\n-            for p in slice.iter_mut() {\n+            for p in slice {\n                 *p += 2;\n             }\n         }\n@@ -2058,7 +2036,7 @@ mod tests {\n         {\n             let slice = &mut values[.. 2];\n             assert!(slice == [1, 2]);\n-            for p in slice.iter_mut() {\n+            for p in slice {\n                 *p += 1;\n             }\n         }\n@@ -2075,15 +2053,15 @@ mod tests {\n                 let left: &[_] = left;\n                 assert!(&left[..left.len()] == &[1, 2][]);\n             }\n-            for p in left.iter_mut() {\n+            for p in left {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n                 assert!(&right[..right.len()] == &[3, 4, 5][]);\n             }\n-            for p in right.iter_mut() {\n+            for p in right {\n                 *p += 2;\n             }\n         }\n@@ -2151,15 +2129,15 @@ mod tests {\n         v.push(());\n         assert_eq!(v.iter().count(), 2);\n \n-        for &() in v.iter() {}\n+        for &() in &v {}\n \n         assert_eq!(v.iter_mut().count(), 2);\n         v.push(());\n         assert_eq!(v.iter_mut().count(), 3);\n         v.push(());\n         assert_eq!(v.iter_mut().count(), 4);\n \n-        for &mut () in v.iter_mut() {}\n+        for &mut () in &mut v {}\n         unsafe { v.set_len(0); }\n         assert_eq!(v.iter_mut().count(), 0);\n     }\n@@ -2355,7 +2333,7 @@ mod tests {\n     fn test_move_items() {\n         let vec = vec![1, 2, 3];\n         let mut vec2 : Vec<i32> = vec![];\n-        for i in vec.into_iter() {\n+        for i in vec {\n             vec2.push(i);\n         }\n         assert!(vec2 == vec![1, 2, 3]);\n@@ -2375,7 +2353,7 @@ mod tests {\n     fn test_move_items_zero_sized() {\n         let vec = vec![(), (), ()];\n         let mut vec2 : Vec<()> = vec![];\n-        for i in vec.into_iter() {\n+        for i in vec {\n             vec2.push(i);\n         }\n         assert!(vec2 == vec![(), (), ()]);"}, {"sha": "044a350bffb194be275604b4db942ae637a69cf7", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -90,7 +90,7 @@ impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n         // In order to not traverse the `VecMap` twice, count the elements\n         // during iteration.\n         let mut count: uint = 0;\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n             count += 1;\n         }\n@@ -562,7 +562,7 @@ impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n-    fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, iter: Iter) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -924,7 +924,7 @@ mod test_map {\n         assert!(m.insert(6, 10).is_none());\n         assert!(m.insert(10, 11).is_none());\n \n-        for (k, v) in m.iter_mut() {\n+        for (k, v) in &mut m {\n             *v += k as int;\n         }\n \n@@ -984,7 +984,7 @@ mod test_map {\n         let mut m = VecMap::new();\n         m.insert(1, box 2);\n         let mut called = false;\n-        for (k, v) in m.into_iter() {\n+        for (k, v) in m {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);\n@@ -1112,7 +1112,7 @@ mod test_map {\n \n         let map: VecMap<char> = xs.iter().map(|&x| x).collect();\n \n-        for &(k, v) in xs.iter() {\n+        for &(k, v) in &xs {\n             assert_eq!(map.get(&k), Some(&v));\n         }\n     }"}, {"sha": "5c4567e567b0daa9f880559994473760a69bbc2b", "filename": "src/libcore/array.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -20,9 +20,6 @@ use fmt;\n use hash::{Hash, Hasher, self};\n use iter::IntoIterator;\n use marker::Copy;\n-#[cfg(stage0)]\n-use ops::{Deref, FullRange};\n-#[cfg(not(stage0))]\n use ops::Deref;\n use option::Option;\n use slice::{Iter, IterMut, SliceExt};"}, {"sha": "ead49af18d03f27c5f19813b87cbbf7b1ee99629", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 55, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -38,7 +38,6 @@ mod float;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(hidden)]\n pub mod rt {\n-    #[cfg(stage0)] pub use self::v1::*;\n     pub mod v1;\n }\n \n@@ -191,46 +190,13 @@ impl<'a> Arguments<'a> {\n         }\n     }\n \n-    /// When using the format_args!() macro, this function is used to generate the\n-    /// Arguments structure.\n-    #[doc(hidden)] #[inline]\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(pieces: &'a [&'a str],\n-               args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n-        Arguments {\n-            pieces: pieces,\n-            fmt: None,\n-            args: args\n-        }\n-    }\n-\n     /// This function is used to specify nonstandard formatting parameters.\n     /// The `pieces` array must be at least as long as `fmt` to construct\n     /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_placeholders(pieces: &'a [&'a str],\n-                             fmt: &'a [rt::v1::Argument],\n-                             args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n-        Arguments {\n-            pieces: pieces,\n-            fmt: Some(fmt),\n-            args: args\n-        }\n-    }\n-    /// This function is used to specify nonstandard formatting parameters.\n-    /// The `pieces` array must be at least as long as `fmt` to construct\n-    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n-    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n-    /// created with `argumentuint`. However, failing to do so doesn't cause\n-    /// unsafety, but will ignore invalid .\n-    #[doc(hidden)] #[inline]\n-    #[cfg(not(stage0))]\n     pub fn new_v1_formatted(pieces: &'a [&'a str],\n                             args: &'a [ArgumentV1<'a>],\n                             fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n@@ -516,7 +482,7 @@ impl<'a> Formatter<'a> {\n \n         // Writes the sign if it exists, and then the prefix if it was requested\n         let write_prefix = |&: f: &mut Formatter| {\n-            for c in sign.into_iter() {\n+            if let Some(c) = sign {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n                 let b = unsafe { str::from_utf8_unchecked(&b[..n]) };\n@@ -684,25 +650,6 @@ impl Display for Error {\n     }\n }\n \n-/// This is a function which calls are emitted to by the compiler itself to\n-/// create the Argument structures that are passed into the `format` function.\n-#[doc(hidden)] #[inline]\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n-                       t: &'a T) -> ArgumentV1<'a> {\n-    ArgumentV1::new(t, f)\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a uint\n-/// (such as for width and precision), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn argumentuint<'a>(s: &'a uint) -> ArgumentV1<'a> {\n-    ArgumentV1::from_uint(s)\n-}\n-\n // Implementations of the core formatting traits\n \n macro_rules! fmt_refs {\n@@ -941,7 +888,7 @@ impl<T: Debug> Debug for [T] {\n             try!(write!(f, \"[\"));\n         }\n         let mut is_first = true;\n-        for x in self.iter() {\n+        for x in self {\n             if is_first {\n                 is_first = false;\n             } else {"}, {"sha": "0c9bb6316e0d805ecbcc08a05c1c6bb2fa67bc5e", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -16,19 +16,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[cfg(stage0)] pub use self::Position::*;\n-\n-#[cfg(stage0)] pub use self::Alignment::Left as AlignLeft;\n-#[cfg(stage0)] pub use self::Alignment::Right as AlignRight;\n-#[cfg(stage0)] pub use self::Alignment::Center as AlignCenter;\n-#[cfg(stage0)] pub use self::Alignment::Unknown as AlignUnknown;\n-#[cfg(stage0)] pub use self::Count::Is as CountIs;\n-#[cfg(stage0)] pub use self::Count::Implied as CountImplied;\n-#[cfg(stage0)] pub use self::Count::Param as CountIsParam;\n-#[cfg(stage0)] pub use self::Count::NextParam as CountIsNextParam;\n-#[cfg(stage0)] pub use self::Position::Next as ArgumentNext;\n-#[cfg(stage0)] pub use self::Position::At as ArgumentIs;\n-\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Argument {"}, {"sha": "d73e6ed589ff3bed1455121de3cc80a76ee8062e", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -205,7 +205,7 @@ impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n-        for elt in self.iter() {\n+        for elt in self {\n             elt.hash(state);\n         }\n     }"}, {"sha": "b954e69eaa863a49bca958777694d0493a08646c", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -174,7 +174,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn last(mut self) -> Option<Self::Item> {\n+    fn last(self) -> Option<Self::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n         last\n@@ -588,7 +588,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"recently added as part of collections reform\")]\n-    fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n+    fn partition<B, F>(self, mut f: F) -> (B, B) where\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n     {\n@@ -617,7 +617,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n+    fn fold<B, F>(self, init: B, mut f: F) -> B where\n         F: FnMut(B, Self::Item) -> B,\n     {\n         let mut accum = init;\n@@ -638,7 +638,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n+    fn all<F>(self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n     }\n@@ -946,7 +946,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!([2, 4], right);\n     /// ```\n     #[unstable(feature = \"core\", reason = \"recent addition\")]\n-    fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n+    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n         Self: Iterator<Item=(A, B)>,\n@@ -2205,7 +2205,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n-            for inner in self.frontiter.iter_mut() {\n+            if let Some(ref mut inner) = self.frontiter {\n                 for x in inner.by_ref() {\n                     return Some(x)\n                 }\n@@ -2238,7 +2238,7 @@ impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         loop {\n-            for inner in self.backiter.iter_mut() {\n+            if let Some(ref mut inner) = self.backiter {\n                 match inner.next_back() {\n                     None => (),\n                     y => return y"}, {"sha": "5e9793f270dedea1d37d6b2b565dab1b8b645dae", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -59,7 +59,6 @@\n #![no_std]\n #![allow(raw_pointer_derive)]\n #![deny(missing_docs)]\n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n \n #![feature(int_uint)]\n #![feature(intrinsics, lang_items)]"}, {"sha": "7af94c73f324d80324fdacec9a44edd95df61698", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -947,28 +947,11 @@ pub trait IndexMut<Index: ?Sized> {\n }\n \n /// An unbounded range.\n-#[cfg(stage0)]\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-#[lang=\"full_range\"]\n-#[unstable(feature = \"core\", reason  = \"may be renamed to RangeFull\")]\n-pub struct FullRange;\n-\n-/// An unbounded range.\n-#[cfg(not(stage0))]\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_full\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for FullRange {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(\"..\", fmt)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for RangeFull {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "f4b1a0633de5ceecf1d122fdce30ffd0bec80707", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -26,9 +26,6 @@\n \n // Reexported core operators\n pub use marker::{Copy, Send, Sized, Sync};\n-#[cfg(stage0)]\n-pub use ops::{Drop, Fn, FnMut, FnOnce, FullRange};\n-#[cfg(not(stage0))]\n pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // Reexported functions"}, {"sha": "d610962f8620cb491b41cd52882dd99e34857d66", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -956,7 +956,7 @@ pub fn fold<T,\n             E,\n             F: FnMut(V, T) -> V,\n             Iter: Iterator<Item=Result<T, E>>>(\n-            mut iterator: Iter,\n+            iterator: Iter,\n             mut init: V,\n             mut f: F)\n             -> Result<V, E> {"}, {"sha": "a750e81bf596b7fd9aeebbec55822b0146c0956d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -43,9 +43,6 @@ use default::Default;\n use iter::*;\n use num::Int;\n use ops::{FnMut, self, Index};\n-#[cfg(stage0)]\n-use ops::FullRange as RangeFull;\n-#[cfg(not(stage0))]\n use ops::RangeFull;\n use option::Option;\n use option::Option::{None, Some};\n@@ -769,16 +766,6 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n-    type Output = [T];\n-    #[inline]\n-    fn index(&self, _index: &ops::FullRange) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-#[cfg(not(stage0))]\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<RangeFull> for Iter<'a, T> {\n     type Output = [T];"}, {"sha": "026f708b30553f229949bde7ab1df351748f12a4", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1266,16 +1266,6 @@ mod traits {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::FullRange> for str {\n-        type Output = str;\n-        #[inline]\n-        fn index(&self, _index: &ops::FullRange) -> &str {\n-            self\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;"}, {"sha": "2e5c6fe5a2ff7bec0f1f4a3694a85a22957ee061", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -66,11 +66,11 @@ fn test_partial_min() {\n         (1.0f64, NAN, None)\n     ];\n \n-    for &(a, b, result) in data_integer.iter() {\n+    for &(a, b, result) in &data_integer {\n         assert!(partial_min(a, b) == result);\n     }\n \n-    for &(a, b, result) in data_float.iter() {\n+    for &(a, b, result) in &data_float {\n         assert!(partial_min(a, b) == result);\n     }\n }\n@@ -99,11 +99,11 @@ fn test_partial_max() {\n         (1.0f64, NAN, None)\n     ];\n \n-    for &(a, b, result) in data_integer.iter() {\n+    for &(a, b, result) in &data_integer {\n         assert!(partial_max(a, b) == result);\n     }\n \n-    for &(a, b, result) in data_float.iter() {\n+    for &(a, b, result) in &data_float {\n         assert!(partial_max(a, b) == result);\n     }\n }"}, {"sha": "2da3f370b40ac467435f5da7379213ea30aacbbe", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -25,7 +25,7 @@ impl Default for MyHasher {\n impl Writer for MyHasher {\n     // Most things we'll just add up the bytes.\n     fn write(&mut self, buf: &[u8]) {\n-        for byte in buf.iter() {\n+        for byte in buf {\n             self.hash += *byte as u64;\n         }\n     }"}, {"sha": "a493f71925e0a2a15a53158be8a9bf837fcea39c", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -109,7 +109,7 @@ fn test_siphash() {\n \n     fn to_hex_str(r: &[u8; 8]) -> String {\n         let mut s = String::new();\n-        for b in r.iter() {\n+        for b in r {\n             s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n         }\n         s\n@@ -130,7 +130,7 @@ fn test_siphash() {\n     fn result_str(h: u64) -> String {\n         let r = result_bytes(h);\n         let mut s = String::new();\n-        for b in r.iter() {\n+        for b in &r {\n             s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n         }\n         s"}, {"sha": "fc8d18df81523a6889f4216ccbc935fe9dbe4959", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -24,7 +24,6 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![cfg_attr(stage0, feature(core))]\n #![feature(int_uint)]\n #![feature(slicing_syntax)]\n #![feature(staged_api)]"}, {"sha": "b4eb8e9902ae22c4eaabb0b1e721edb2886b69e8", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -315,7 +315,7 @@ impl Matches {\n \n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n-        for nm in names.iter() {\n+        for nm in names {\n             match find_opt(self.opts.as_slice(), Name::from_str(&nm[])) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n@@ -326,7 +326,7 @@ impl Matches {\n \n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n-        for nm in names.iter() {\n+        for nm in names {\n             match self.opt_val(&nm[]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n@@ -342,7 +342,7 @@ impl Matches {\n     pub fn opt_strs(&self, nm: &str) -> Vec<String> {\n         let mut acc: Vec<String> = Vec::new();\n         let r = self.opt_vals(nm);\n-        for v in r.iter() {\n+        for v in &r {\n             match *v {\n                 Val(ref s) => acc.push((*s).clone()),\n                 _ => ()\n@@ -395,7 +395,7 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n     }\n \n     // Search in aliases.\n-    for candidate in opts.iter() {\n+    for candidate in opts {\n         if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n             return opts.iter().position(|opt| opt.name == candidate.name);\n         }\n@@ -648,7 +648,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 }\n             }\n             let mut name_pos = 0;\n-            for nm in names.iter() {\n+            for nm in &names {\n                 name_pos += 1;\n                 let optid = match find_opt(opts.as_slice(), (*nm).clone()) {\n                   Some(id) => id,"}, {"sha": "e9c7f837014b83b102ac7807163d50ffbbf3323d", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -548,7 +548,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n               options: &[RenderOption]) -> old_io::IoResult<()>\n {\n     fn writeln<W:Writer>(w: &mut W, arg: &[&str]) -> old_io::IoResult<()> {\n-        for &s in arg.iter() { try!(w.write_str(s)); }\n+        for &s in arg { try!(w.write_str(s)); }\n         w.write_char('\\n')\n     }\n \n@@ -557,7 +557,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n     }\n \n     try!(writeln(w, &[\"digraph \", g.graph_id().as_slice(), \" {\"]));\n-    for n in g.nodes().iter() {\n+    for n in &*g.nodes() {\n         try!(indent(w));\n         let id = g.node_id(n);\n         if options.contains(&RenderOption::NoNodeLabels) {\n@@ -569,7 +569,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n         }\n     }\n \n-    for e in g.edges().iter() {\n+    for e in &*g.edges() {\n         let escaped_label = g.edge_label(e).escape();\n         try!(indent(w));\n         let source = g.source(e);"}, {"sha": "aef6301dad7782db6903df2a11fe851a5fa366f8", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -194,7 +194,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n impl Rand for ChaChaRng {\n     fn rand<R: Rng>(other: &mut R) -> ChaChaRng {\n         let mut key : [u32; KEY_WORDS] = [0; KEY_WORDS];\n-        for word in key.iter_mut() {\n+        for word in &mut key {\n             *word = other.gen();\n         }\n         SeedableRng::from_seed(key.as_slice())"}, {"sha": "4958784f614503cd031ff6e658d73a14e6cc7ca2", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -123,7 +123,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         // we convert the list from individual weights to cumulative\n         // weights so we can binary search. This *could* drop elements\n         // with weight == 0 as an optimisation.\n-        for item in items.iter_mut() {\n+        for item in &mut *items {\n             running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n                 None => panic!(\"WeightedChoice::new called with a total weight \\\n@@ -305,7 +305,7 @@ mod tests {\n \n                 let mut rng = CountingRng { i: 0 };\n \n-                for &val in expected.iter() {\n+                for &val in &expected {\n                     assert_eq!(wc.ind_sample(&mut rng), val)\n                 }\n             }}"}, {"sha": "ab0b45e7d326891cd3df73a2f2b7e88b8f669c08", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -188,7 +188,7 @@ mod tests {\n                    let v: &[($ty, $ty)] = &[(0, 10),\n                                             (10, 127),\n                                             (Int::min_value(), Int::max_value())];\n-                   for &(low, high) in v.iter() {\n+                   for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in 0u..1000 {\n                             let v = sampler.sample(&mut rng);\n@@ -214,7 +214,7 @@ mod tests {\n                                             (-1e35, -1e25),\n                                             (1e-35, 1e-25),\n                                             (-1e35, 1e35)];\n-                   for &(low, high) in v.iter() {\n+                   for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in 0u..1000 {\n                             let v = sampler.sample(&mut rng);"}, {"sha": "d0f4afdde728a2e76a96631759b439744bed1c6c", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -134,7 +134,7 @@ impl IsaacRng {\n         }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        for &(mr_offset, m2_offset) in r.iter() {\n+        for &(mr_offset, m2_offset) in &r {\n \n             macro_rules! rngstepp {\n                 ($j:expr, $shift:expr) => {{\n@@ -373,7 +373,7 @@ impl Isaac64Rng {\n             }\n         }\n \n-        for &(mr_offset, m2_offset) in MP_VEC.iter() {\n+        for &(mr_offset, m2_offset) in &MP_VEC {\n             for base in (0..MIDPOINT / 4).map(|i| i * 4) {\n \n                 macro_rules! rngstepp {"}, {"sha": "5290e68033306c0da9423e99fb49dd4452d216b9", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -154,7 +154,7 @@ pub trait Rng : Sized {\n         // optimisations are on.\n         let mut count = 0;\n         let mut num = 0;\n-        for byte in dest.iter_mut() {\n+        for byte in dest {\n             if count == 0 {\n                 // we could micro-optimise here by generating a u32 if\n                 // we only need a few more bytes to fill the vector"}, {"sha": "75ac1b2cf44cc6bd758169e4c4773de08a1b671c", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -225,7 +225,7 @@ mod test {\n         // To test that `fill_bytes` actually did something, check that the\n         // average of `v` is not 0.\n         let mut sum = 0.0;\n-        for &x in v.iter() {\n+        for &x in &v {\n             sum += x as f64;\n         }\n         assert!(sum / v.len() as f64 != 0.0);"}, {"sha": "003248204335045969bb5b867fbedcc9ef01c140", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -23,8 +23,6 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]"}, {"sha": "53054f462c8b6c0cd6eccc16c813a980c97f6638", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -459,7 +459,7 @@ impl LintPass for ImproperCTypes {\n         }\n \n         fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n-            for input in decl.inputs.iter() {\n+            for input in &decl.inputs {\n                 check_ty(cx, &*input.ty);\n             }\n             if let ast::Return(ref ret_ty) = decl.output {\n@@ -469,7 +469,7 @@ impl LintPass for ImproperCTypes {\n \n         match it.node {\n             ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n-                for ni in nmod.items.iter() {\n+                for ni in &nmod.items {\n                     match ni.node {\n                         ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n                         ast::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n@@ -532,7 +532,7 @@ impl LintPass for BoxPointers {\n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             ast::ItemStruct(ref struct_def, _) => {\n-                for struct_field in struct_def.fields.iter() {\n+                for struct_field in &struct_def.fields {\n                     self.check_heap_type(cx, struct_field.span,\n                                          ty::node_id_to_type(cx.tcx, struct_field.node.id));\n                 }\n@@ -691,7 +691,7 @@ impl LintPass for UnusedAttributes {\n             \"no_builtins\",\n         ];\n \n-        for &name in ATTRIBUTE_WHITELIST.iter() {\n+        for &name in ATTRIBUTE_WHITELIST {\n             if attr.check_name(name) {\n                 break;\n             }\n@@ -793,7 +793,7 @@ impl LintPass for UnusedResults {\n         }\n \n         fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n-            for attr in attrs.iter() {\n+            for attr in attrs {\n                 if attr.check_name(\"must_use\") {\n                     let mut msg = \"unused result which must be used\".to_string();\n                     // check for #[must_use=\"...\"]\n@@ -877,7 +877,7 @@ impl LintPass for NonCamelCaseTypes {\n             ast::ItemEnum(ref enum_definition, _) => {\n                 if has_extern_repr { return }\n                 self.check_case(cx, \"type\", it.ident, it.span);\n-                for variant in enum_definition.variants.iter() {\n+                for variant in &enum_definition.variants {\n                     self.check_case(cx, \"variant\", variant.node.name, variant.span);\n                 }\n             }\n@@ -886,7 +886,7 @@ impl LintPass for NonCamelCaseTypes {\n     }\n \n     fn check_generics(&mut self, cx: &Context, it: &ast::Generics) {\n-        for gen in it.ty_params.iter() {\n+        for gen in &*it.ty_params {\n             self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n         }\n     }\n@@ -1056,7 +1056,7 @@ impl LintPass for NonSnakeCase {\n \n     fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n             _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n-        for sf in s.fields.iter() {\n+        for sf in &s.fields {\n             if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n                 self.check_snake_case(cx, \"structure field\", ident, sf.span);\n             }\n@@ -1354,7 +1354,7 @@ impl UnusedMut {\n         // avoid false warnings in match arms with multiple patterns\n \n         let mut mutables = FnvHashMap();\n-        for p in pats.iter() {\n+        for p in pats {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n@@ -1369,7 +1369,7 @@ impl UnusedMut {\n         }\n \n         let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-        for (_, v) in mutables.iter() {\n+        for (_, v) in &mutables {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n                 cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n                              \"variable does not need to be mutable\");\n@@ -1385,7 +1385,7 @@ impl LintPass for UnusedMut {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n-            for a in arms.iter() {\n+            for a in arms {\n                 self.check_unused_mut_pat(cx, &a.pats[])\n             }\n         }\n@@ -1402,7 +1402,7 @@ impl LintPass for UnusedMut {\n     fn check_fn(&mut self, cx: &Context,\n                 _: visit::FnKind, decl: &ast::FnDecl,\n                 _: &ast::Block, _: Span, _: ast::NodeId) {\n-        for a in decl.inputs.iter() {\n+        for a in &decl.inputs {\n             self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n     }\n@@ -1879,7 +1879,7 @@ impl LintPass for UnconditionalRecursion {\n             if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n                 let sess = cx.sess();\n                 // offer some help to the programmer.\n-                for call in self_call_spans.iter() {\n+                for call in &self_call_spans {\n                     sess.span_note(*call, \"recursive call site\")\n                 }\n                 sess.span_help(sp, \"a `loop` may express intention better if this is on purpose\")"}, {"sha": "91dba90b0d2e2508d1da2c9e571ca0c7096fd6c1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -116,7 +116,7 @@ impl LintStore {\n \n     pub fn register_pass(&mut self, sess: Option<&Session>,\n                          from_plugin: bool, pass: LintPassObject) {\n-        for &lint in pass.get_lints().iter() {\n+        for &lint in pass.get_lints() {\n             self.lints.push((*lint, from_plugin));\n \n             let id = LintId::of(*lint);\n@@ -260,7 +260,7 @@ impl LintStore {\n     }\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n-        for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n+        for &(ref lint_name, level) in &sess.opts.lint_opts {\n             match self.find_lint(&lint_name[], sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n@@ -329,7 +329,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n     let mut passes = $cx.lints.passes.take().unwrap();\n-    for obj in passes.iter_mut() {\n+    for obj in &mut passes {\n         obj.$f($cx, $($args),*);\n     }\n     $cx.lints.passes = Some(passes);\n@@ -340,7 +340,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n pub fn gather_attrs(attrs: &[ast::Attribute])\n                     -> Vec<Result<(InternedString, Level, Span), Span>> {\n     let mut out = vec!();\n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         let level = match Level::from_str(attr.name().get()) {\n             None => continue,\n             Some(lvl) => lvl,\n@@ -357,7 +357,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n             }\n         };\n \n-        for meta in metas.iter() {\n+        for meta in metas {\n             out.push(match meta.node {\n                 ast::MetaWord(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n                 _ => Err(meta.span),\n@@ -417,11 +417,11 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n-    for note in note.into_iter() {\n+    if let Some(note) = note {\n         sess.note(&note[]);\n     }\n \n-    for span in def.into_iter() {\n+    if let Some(span) = def {\n         sess.span_note(span, \"lint level defined here\");\n     }\n }\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         // specified closure\n         let mut pushed = 0;\n \n-        for result in gather_attrs(attrs).into_iter() {\n+        for result in gather_attrs(attrs) {\n             let v = match result {\n                 Err(span) => {\n                     self.tcx.sess.span_err(span, \"malformed lint attribute\");\n@@ -519,7 +519,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                 }\n             };\n \n-            for (lint_id, level, span) in v.into_iter() {\n+            for (lint_id, level, span) in v {\n                 let now = self.lints.get_level_source(lint_id).0;\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n@@ -727,7 +727,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n         match self.tcx.sess.lints.borrow_mut().remove(&id) {\n             None => {}\n             Some(lints) => {\n-                for (lint_id, span, msg) in lints.into_iter() {\n+                for (lint_id, span, msg) in lints {\n                     self.span_lint(lint_id.lint, span, &msg[])\n                 }\n             }\n@@ -794,8 +794,8 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    for (id, v) in tcx.sess.lints.borrow().iter() {\n-        for &(lint, span, ref msg) in v.iter() {\n+    for (id, v) in &*tcx.sess.lints.borrow() {\n+        for &(lint, span, ref msg) in v {\n             tcx.sess.span_bug(span,\n                               format!(\"unprocessed lint {} at {}: {}\",\n                                       lint.as_str(), tcx.map.node_to_string(*id), *msg).as_slice())"}, {"sha": "a787369dc633c35e23b8973dfee31e08222e0838", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -162,7 +162,7 @@ impl<'a> CrateReader<'a> {\n             dump_crates(&self.sess.cstore);\n         }\n \n-        for &(ref name, kind) in self.sess.opts.libs.iter() {\n+        for &(ref name, kind) in &self.sess.opts.libs {\n             register_native_lib(self.sess, None, name.clone(), kind);\n         }\n     }\n@@ -235,7 +235,7 @@ impl<'a> CrateReader<'a> {\n                         None\n                     })\n                     .collect::<Vec<&ast::Attribute>>();\n-                for m in link_args.iter() {\n+                for m in &link_args {\n                     match m.value_str() {\n                         Some(linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n                         None => { /* fallthrough */ }\n@@ -250,7 +250,7 @@ impl<'a> CrateReader<'a> {\n                         None\n                     })\n                     .collect::<Vec<&ast::Attribute>>();\n-                for m in link_args.iter() {\n+                for m in &link_args {\n                     match m.meta_item_list() {\n                         Some(items) => {\n                             let kind = items.iter().find(|k| {"}, {"sha": "619cfc1b52c09b4b96c98684f445b26089be6892", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -382,7 +382,7 @@ pub fn get_stability(cstore: &cstore::CStore,\n pub fn is_staged_api(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n     let attrs = decoder::get_crate_attributes(cdata.data());\n-    for attr in attrs.iter() {\n+    for attr in &attrs {\n         if attr.name().get() == \"staged_api\" {\n             match attr.node.value.node { ast::MetaWord(_) => return true, _ => (/*pass*/) }\n         }"}, {"sha": "0a3e173b35ee517cde4025249d01381356729d71", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -113,7 +113,7 @@ impl CStore {\n     pub fn iter_crate_data<I>(&self, mut i: I) where\n         I: FnMut(ast::CrateNum, &crate_metadata),\n     {\n-        for (&k, v) in self.metas.borrow().iter() {\n+        for (&k, v) in &*self.metas.borrow() {\n             i(k, &**v);\n         }\n     }\n@@ -122,7 +122,7 @@ impl CStore {\n     pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n         I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n     {\n-        for (&k, v) in self.metas.borrow().iter() {\n+        for (&k, v) in &*self.metas.borrow() {\n             let origin = self.get_used_crate_source(k);\n             origin.as_ref().map(|cs| { assert!(k == cs.cnum); });\n             i(k, &**v, origin);\n@@ -167,12 +167,12 @@ impl CStore {\n                  ordering: &mut Vec<ast::CrateNum>) {\n             if ordering.contains(&cnum) { return }\n             let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in meta.cnum_map.iter() {\n+            for (_, &dep) in &meta.cnum_map {\n                 visit(cstore, dep, ordering);\n             }\n             ordering.push(cnum);\n         };\n-        for (&num, _) in self.metas.borrow().iter() {\n+        for (&num, _) in &*self.metas.borrow() {\n             visit(self, num, &mut ordering);\n         }\n         ordering.reverse();"}, {"sha": "3a70490771eba706c670e72f935a80d88b81a954", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1022,7 +1022,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n     });\n \n     let mut impl_methods = Vec::new();\n-    for impl_method_id in impl_method_ids.iter() {\n+    for impl_method_id in &impl_method_ids {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data());\n         let family = item_family(impl_method_doc);\n         match family {\n@@ -1189,7 +1189,7 @@ fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n     try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n \n     let r = get_attributes(md);\n-    for attr in r.iter() {\n+    for attr in &r {\n         try!(write!(out, \"{}\\n\", pprust::attribute_to_string(attr)));\n     }\n \n@@ -1232,7 +1232,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n \n fn list_crate_deps(data: &[u8], out: &mut old_io::Writer) -> old_io::IoResult<()> {\n     try!(write!(out, \"=External Dependencies=\\n\"));\n-    for dep in get_crate_deps(data).iter() {\n+    for dep in &get_crate_deps(data) {\n         try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash));\n     }\n     try!(write!(out, \"\\n\"));"}, {"sha": "ccd524a2c03955a950b3929a96dae1659de9fffc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -288,7 +288,7 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n fn encode_struct_fields(rbml_w: &mut Encoder,\n                         fields: &[ty::field_ty],\n                         origin: DefId) {\n-    for f in fields.iter() {\n+    for f in fields {\n         if f.name == special_idents::unnamed_field.name {\n             rbml_w.start_tag(tag_item_unnamed_field);\n         } else {\n@@ -316,7 +316,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n                                DefId { krate: ast::LOCAL_CRATE, node: id });\n-    for variant in variants.iter() {\n+    for variant in variants {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n             val: variant.node.id as i64,\n@@ -367,7 +367,7 @@ fn encode_path<PI: Iterator<Item=PathElem>>(rbml_w: &mut Encoder, path: PI) {\n     let path = path.collect::<Vec<_>>();\n     rbml_w.start_tag(tag_path);\n     rbml_w.wr_tagged_u32(tag_path_len, path.len() as u32);\n-    for pe in path.iter() {\n+    for pe in &path {\n         let tag = match *pe {\n             ast_map::PathMod(_) => tag_path_elem_mod,\n             ast_map::PathName(_) => tag_path_elem_name\n@@ -402,8 +402,8 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     let impl_items = ecx.tcx.impl_items.borrow();\n     match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n         Some(implementations) => {\n-            for base_impl_did in implementations.iter() {\n-                for &method_did in (*impl_items)[*base_impl_did].iter() {\n+            for base_impl_did in &**implementations {\n+                for &method_did in &*(*impl_items)[*base_impl_did] {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n@@ -431,7 +431,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           -> bool {\n     match ecx.tcx.trait_items_cache.borrow().get(&exp.def_id) {\n         Some(trait_items) => {\n-            for trait_item in trait_items.iter() {\n+            for trait_item in &**trait_items {\n                 if let ty::MethodTraitItem(ref m) = *trait_item {\n                     encode_reexported_static_method(rbml_w,\n                                                     exp,\n@@ -517,9 +517,9 @@ fn encode_reexports(ecx: &EncodeContext,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n     match ecx.reexports.get(&id) {\n-        Some(ref exports) => {\n+        Some(exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n-            for exp in exports.iter() {\n+            for exp in exports {\n                 debug!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n                         {}\",\n                        exp.name,\n@@ -559,7 +559,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n-    for item in md.items.iter() {\n+    for item in &md.items {\n         rbml_w.start_tag(tag_mod_child);\n         rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n@@ -665,9 +665,9 @@ fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n \n fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n-    for source in source_opt.iter() {\n+    if let Some(source) = source_opt {\n         rbml_w.start_tag(tag_item_method_provided_source);\n-        let s = def_to_string(*source);\n+        let s = def_to_string(source);\n         rbml_w.writer.write_all(s.as_bytes());\n         rbml_w.end_tag();\n     }\n@@ -684,7 +684,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     let mut index = Vec::new();\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-    for field in fields.iter() {\n+    for field in fields {\n         let nm = field.name;\n         let id = field.id.node;\n \n@@ -783,7 +783,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.wr_tagged_u64(tag_region_param_def_index,\n                              param.index as u64);\n \n-        for &bound_region in param.bounds.iter() {\n+        for &bound_region in &param.bounds {\n             encode_region(ecx, rbml_w, bound_region);\n         }\n \n@@ -911,7 +911,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n fn encode_method_argument_names(rbml_w: &mut Encoder,\n                                 decl: &ast::FnDecl) {\n     rbml_w.start_tag(tag_method_argument_names);\n-    for arg in decl.inputs.iter() {\n+    for arg in &decl.inputs {\n         rbml_w.start_tag(tag_method_argument_name);\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n             let name = token::get_ident(path1.node);\n@@ -926,7 +926,7 @@ fn encode_repr_attrs(rbml_w: &mut Encoder,\n                      ecx: &EncodeContext,\n                      attrs: &[ast::Attribute]) {\n     let mut repr_attrs = Vec::new();\n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n                                                 attr).into_iter());\n     }\n@@ -962,7 +962,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().get(&def_id) {\n         None => {}\n         Some(implementations) => {\n-            for &impl_def_id in implementations.iter() {\n+            for &impl_def_id in &**implementations {\n                 rbml_w.start_tag(tag_items_data_item_inherent_impl);\n                 encode_def_id(rbml_w, impl_def_id);\n                 rbml_w.end_tag();\n@@ -978,7 +978,7 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n     match ecx.tcx.trait_impls.borrow().get(&trait_def_id) {\n         None => {}\n         Some(implementations) => {\n-            for &impl_def_id in implementations.borrow().iter() {\n+            for &impl_def_id in &*implementations.borrow() {\n                 rbml_w.start_tag(tag_items_data_item_extension_impl);\n                 encode_def_id(rbml_w, impl_def_id);\n                 rbml_w.end_tag();\n@@ -1091,7 +1091,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n \n         // Encode all the items in this module.\n-        for foreign_item in fm.items.iter() {\n+        for foreign_item in &fm.items {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(&def_to_string(local_def(foreign_item.id))[]);\n             rbml_w.end_tag();\n@@ -1123,7 +1123,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs[]);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n-        for v in (*enum_definition).variants.iter() {\n+        for v in &enum_definition.variants {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n@@ -1216,7 +1216,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for &item_def_id in items.iter() {\n+        for &item_def_id in items {\n             rbml_w.start_tag(tag_item_impl_item);\n             match item_def_id {\n                 ty::MethodTraitItemId(item_def_id) => {\n@@ -1230,7 +1230,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        for ast_trait_ref in opt_trait.iter() {\n+        if let Some(ref ast_trait_ref) = *opt_trait {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n@@ -1314,7 +1314,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs[]);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n+        for &method_def_id in &*ty::trait_item_def_ids(tcx, def_id) {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n                 ty::MethodTraitItemId(method_def_id) => {\n@@ -1589,7 +1589,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     T: Hash<SipHasher>,\n {\n     let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n-    for elt in index.into_iter() {\n+    for elt in index {\n         let mut s = SipHasher::new();\n         elt.val.hash(&mut s);\n         let h = s.finish() as uint;\n@@ -1599,10 +1599,10 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     rbml_w.start_tag(tag_index);\n     let mut bucket_locs = Vec::new();\n     rbml_w.start_tag(tag_index_buckets);\n-    for bucket in buckets.iter() {\n+    for bucket in &buckets {\n         bucket_locs.push(rbml_w.writer.tell().unwrap());\n         rbml_w.start_tag(tag_index_buckets_bucket);\n-        for elt in bucket.iter() {\n+        for elt in bucket {\n             rbml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             {\n@@ -1616,7 +1616,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     }\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_index_table);\n-    for pos in bucket_locs.iter() {\n+    for pos in &bucket_locs {\n         assert!(*pos < 0xffff_ffff);\n         let wr: &mut SeekableMemWriter = rbml_w.writer;\n         wr.write_be_u32(*pos as u32);\n@@ -1660,7 +1660,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n         rbml_w.start_tag(tag_meta_item_name);\n         rbml_w.writer.write_all(name.get().as_bytes());\n         rbml_w.end_tag();\n-        for inner_item in items.iter() {\n+        for inner_item in items {\n             encode_meta_item(rbml_w, &**inner_item);\n         }\n         rbml_w.end_tag();\n@@ -1670,7 +1670,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n \n fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     rbml_w.start_tag(tag_attributes);\n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         rbml_w.start_tag(tag_attribute);\n         rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n         encode_meta_item(rbml_w, &*attr.node.value);\n@@ -1694,7 +1694,7 @@ fn encode_paren_sugar(rbml_w: &mut Encoder, paren_sugar: bool) {\n \n fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n     rbml_w.start_tag(tag_associated_type_names);\n-    for &name in names.iter() {\n+    for &name in names {\n         rbml_w.wr_tagged_str(tag_associated_type_name, token::get_name(name).get());\n     }\n     rbml_w.end_tag();\n@@ -1726,7 +1726,7 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for n in deps.iter() {\n+        for n in &deps {\n             assert_eq!(n.cnum, expected_cnum);\n             expected_cnum += 1;\n         }\n@@ -1740,7 +1740,7 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     // but is enough to get transitive crate dependencies working.\n     rbml_w.start_tag(tag_crate_deps);\n     let r = get_ordered_deps(cstore);\n-    for dep in r.iter() {\n+    for dep in &r {\n         encode_crate_dep(rbml_w, (*dep).clone());\n     }\n     rbml_w.end_tag();\n@@ -1749,8 +1749,8 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_lang_items);\n \n-    for (i, def_id) in ecx.tcx.lang_items.items() {\n-        for id in def_id.iter() {\n+    for (i, &def_id) in ecx.tcx.lang_items.items() {\n+        if let Some(id) = def_id {\n             if id.krate == ast::LOCAL_CRATE {\n                 rbml_w.start_tag(tag_lang_items_item);\n \n@@ -1773,7 +1773,7 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n         }\n     }\n \n-    for i in ecx.tcx.lang_items.missing.iter() {\n+    for i in &ecx.tcx.lang_items.missing {\n         rbml_w.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n     }\n \n@@ -1817,7 +1817,7 @@ fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n fn encode_macro_defs(rbml_w: &mut Encoder,\n                      krate: &ast::Crate) {\n     rbml_w.start_tag(tag_macro_defs);\n-    for def in krate.exported_macros.iter() {\n+    for def in &krate.exported_macros {\n         rbml_w.start_tag(tag_macro_def);\n \n         encode_name(rbml_w, def.ident.name);\n@@ -1911,7 +1911,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n-    for item in krate.module.items.iter() {\n+    for item in &krate.module.items {\n         rbml_w.start_tag(tag_mod_child);\n         rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n@@ -1935,7 +1935,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_reachable_extern_fns);\n \n-    for id in ecx.reachable.iter() {\n+    for id in ecx.reachable {\n         if let Some(ast_map::NodeItem(i)) = ecx.tcx.map.find(*id) {\n             if let ast::ItemFn(_, _, abi, ref generics, _) = i.node {\n                 if abi != abi::Rust && !generics.is_type_parameterized() {\n@@ -2150,7 +2150,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n     stats.total_bytes = rbml_w.writer.tell().unwrap();\n \n     if tcx.sess.meta_stats() {\n-        for e in rbml_w.writer.get_ref().iter() {\n+        for e in rbml_w.writer.get_ref() {\n             if *e == 0 {\n                 stats.zero_bytes += 1;\n             }"}, {"sha": "1b2d82e68c19f2fbcb96f60fc937f898badbe0b6", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -66,7 +66,7 @@ impl<'a> FileSearch<'a> {\n         // Try RUST_PATH\n         if !found {\n             let rustpath = rust_path();\n-            for path in rustpath.iter() {\n+            for path in &rustpath {\n                 let tlib_path = make_rustpkg_lib_path(\n                     self.sysroot, path, self.triple);\n                 debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n@@ -243,8 +243,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         cwd.pop();\n     }\n-    let h = env::home_dir();\n-    for h in h.iter() {\n+    if let Some(h) = env::home_dir() {\n         let p = h.join(\".rust\");\n         if !env_rust_path.contains(&p) && p.exists() {\n             env_rust_path.push(p);"}, {"sha": "2fb5a6b64a6520b244f041346fc643b860fa5636", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -425,7 +425,7 @@ impl<'a> Context<'a> {\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n         let mut libraries = Vec::new();\n-        for (_hash, (rlibs, dylibs)) in candidates.into_iter() {\n+        for (_hash, (rlibs, dylibs)) in candidates {\n             let mut metadata = None;\n             let rlib = self.extract_one(rlibs, \"rlib\", &mut metadata);\n             let dylib = self.extract_one(dylibs, \"dylib\", &mut metadata);\n@@ -452,7 +452,7 @@ impl<'a> Context<'a> {\n                     &format!(\"multiple matching crates for `{}`\",\n                             self.crate_name)[]);\n                 self.sess.note(\"candidates:\");\n-                for lib in libraries.iter() {\n+                for lib in &libraries {\n                     match lib.dylib {\n                         Some((ref p, _)) => {\n                             self.sess.note(&format!(\"path: {}\",\n@@ -501,7 +501,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n-        for (lib, kind) in m.into_iter() {\n+        for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let metadata = match get_metadata_section(self.target.options.is_like_osx,\n                                                       &lib) {\n@@ -610,7 +610,7 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let mut locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n+            let locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display())[]);"}, {"sha": "4c0aefaf83d9721863ba1972379c3047b4b7fc18", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -249,7 +249,7 @@ fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n     F: FnMut(&mut PState<'a, 'tcx>) -> T,\n {\n     let mut r = VecPerParamSpace::empty();\n-    for &space in subst::ParamSpace::all().iter() {\n+    for &space in &subst::ParamSpace::all() {\n         assert_eq!(next(st), '[');\n         while peek(st) != ']' {\n             r.push(space, f(st));"}, {"sha": "f8081e2c3098ea84056221c689c67994bd87f786", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -97,7 +97,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         }\n         ty::ty_tup(ref ts) => {\n             mywrite!(w, \"T[\");\n-            for t in ts.iter() { enc_ty(w, cx, *t); }\n+            for t in ts { enc_ty(w, cx, *t); }\n             mywrite!(w, \"]\");\n         }\n         ty::ty_uniq(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n@@ -206,9 +206,9 @@ fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut SeekableMemWriter,\n                                            mut op: F) where\n     F: FnMut(&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T),\n {\n-    for &space in subst::ParamSpace::all().iter() {\n+    for &space in &subst::ParamSpace::all() {\n         mywrite!(w, \"[\");\n-        for t in v.get_slice(space).iter() {\n+        for t in v.get_slice(space) {\n             op(w, cx, t);\n         }\n         mywrite!(w, \"]\");\n@@ -337,7 +337,7 @@ pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                         fsig: &ty::PolyFnSig<'tcx>) {\n     mywrite!(w, \"[\");\n-    for ty in fsig.0.inputs.iter() {\n+    for ty in &fsig.0.inputs {\n         enc_ty(w, cx, *ty);\n     }\n     mywrite!(w, \"]\");\n@@ -357,7 +357,7 @@ fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n }\n \n pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n-    for bound in bs.iter() {\n+    for bound in bs {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n             ty::BoundSized => mywrite!(w, \"Z\"),\n@@ -383,17 +383,17 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                             bs: &ty::ParamBounds<'tcx>) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n-    for &r in bs.region_bounds.iter() {\n+    for &r in &bs.region_bounds {\n         mywrite!(w, \"R\");\n         enc_region(w, cx, r);\n     }\n \n-    for tp in bs.trait_bounds.iter() {\n+    for tp in &bs.trait_bounds {\n         mywrite!(w, \"I\");\n         enc_trait_ref(w, cx, &*tp.0);\n     }\n \n-    for tp in bs.projection_bounds.iter() {\n+    for tp in &bs.projection_bounds {\n         mywrite!(w, \"P\");\n         enc_projection_predicate(w, cx, &tp.0);\n     }"}, {"sha": "4130195ae40d1fc0d133587e717f8ed115a37975", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -766,7 +766,7 @@ fn encode_vec_per_param_space<T, F>(rbml_w: &mut Encoder,\n                                     mut f: F) where\n     F: FnMut(&mut Encoder, &T),\n {\n-    for &space in subst::ParamSpace::all().iter() {\n+    for &space in &subst::ParamSpace::all() {\n         rbml_w.emit_from_vec(v.get_slice(space),\n                              |rbml_w, n| Ok(f(rbml_w, n))).unwrap();\n     }\n@@ -1156,14 +1156,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    for def in tcx.def_map.borrow().get(&id).iter() {\n+    if let Some(def) = tcx.def_map.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| (*def).encode(rbml_w).unwrap());\n         })\n     }\n \n-    for &ty in tcx.node_types.borrow().get(&id).iter() {\n+    if let Some(ty) = tcx.node_types.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1172,7 +1172,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &item_substs in tcx.item_substs.borrow().get(&id).iter() {\n+    if let Some(item_substs) = tcx.item_substs.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1181,7 +1181,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &fv in tcx.freevars.borrow().get(&id).iter() {\n+    if let Some(fv) = tcx.freevars.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1191,7 +1191,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             })\n         });\n \n-        for freevar in fv.iter() {\n+        for freevar in fv {\n             rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n                 rbml_w.id(id);\n                 rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1209,7 +1209,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-    for &type_scheme in tcx.tcache.borrow().get(&lid).iter() {\n+    if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1218,7 +1218,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &type_param_def in tcx.ty_param_defs.borrow().get(&id).iter() {\n+    if let Some(type_param_def) = tcx.ty_param_defs.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1228,7 +1228,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let method_call = MethodCall::expr(id);\n-    for &method in tcx.method_map.borrow().get(&method_call).iter() {\n+    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1237,7 +1237,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &trait_ref in tcx.object_cast_map.borrow().get(&id).iter() {\n+    if let Some(trait_ref) = tcx.object_cast_map.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1246,11 +1246,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &adjustment in tcx.adjustments.borrow().get(&id).iter() {\n+    if let Some(adjustment) = tcx.adjustments.borrow().get(&id) {\n         match *adjustment {\n             _ if ty::adjust_is_object(adjustment) => {\n                 let method_call = MethodCall::autoobject(id);\n-                for &method in tcx.method_map.borrow().get(&method_call).iter() {\n+                if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n                     rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                         rbml_w.id(id);\n                         rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1263,7 +1263,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in 0..adj.autoderefs {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n-                    for &method in tcx.method_map.borrow().get(&method_call).iter() {\n+                    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n                             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1287,7 +1287,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &closure_type in tcx.closure_tys.borrow().get(&ast_util::local_def(id)).iter() {\n+    if let Some(closure_type) = tcx.closure_tys.borrow().get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1296,11 +1296,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &&closure_kind in tcx.closure_kinds.borrow().get(&ast_util::local_def(id)).iter() {\n+    if let Some(closure_kind) = tcx.closure_kinds.borrow().get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                encode_closure_kind(rbml_w, closure_kind)\n+                encode_closure_kind(rbml_w, *closure_kind)\n             })\n         })\n     }"}, {"sha": "d39b94a202e4ae1ab12648d14fbbcfaf51928115", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -68,7 +68,7 @@ fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n-        for stmt in blk.stmts.iter() {\n+        for stmt in &blk.stmts {\n             stmts_exit = self.stmt(&**stmt, stmts_exit);\n         }\n \n@@ -166,7 +166,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             self.pat(&*pats[0], pred)\n         } else {\n             let collect = self.add_dummy_node(&[]);\n-            for pat in pats.iter() {\n+            for pat in pats {\n                 let pat_exit = self.pat(&**pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n             }\n@@ -325,7 +325,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n                 let expr_exit = self.add_node(expr.id, &[]);\n                 let mut cond_exit = discr_exit;\n-                for arm in arms.iter() {\n+                for arm in arms {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n                     let pats_exit = self.pats_any(&arm.pats[],\n                                                   cond_exit);            // 3\n@@ -522,7 +522,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             assert!(!self.exit_map.contains_key(&id));\n             self.exit_map.insert(id, node);\n         }\n-        for &pred in preds.iter() {\n+        for &pred in preds {\n             self.add_contained_edge(pred, node);\n         }\n         node\n@@ -574,7 +574,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             Some(_) => {\n                 match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(&def::DefLabel(loop_id)) => {\n-                        for l in self.loop_scopes.iter() {\n+                        for l in &self.loop_scopes {\n                             if l.loop_id == loop_id {\n                                 return *l;\n                             }"}, {"sha": "925bd5b6395beea35e6a2b718cb4410563c69b61", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n                 self.inside_const(|v| {\n-                    for var in enum_definition.variants.iter() {\n+                    for var in &enum_definition.variants {\n                         if let Some(ref ex) = var.node.disr_expr {\n                             v.visit_expr(&**ex);\n                         }\n@@ -137,7 +137,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n         }\n         ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n-            for stmt in block.stmts.iter() {\n+            for stmt in &block.stmts {\n                 let block_span_err = |&: span|\n                     span_err!(v.tcx.sess, span, E0016,\n                               \"blocks in constants are limited to items and \\"}, {"sha": "38084d1c2c06fe42aa067491284e23e4a7a5707c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -77,7 +77,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n         let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n         let br = repeat('+').take(total_width).collect::<String>();\n         try!(write!(f, \"{}\\n\", br));\n-        for row in pretty_printed_matrix.into_iter() {\n+        for row in pretty_printed_matrix {\n             try!(write!(f, \"+\"));\n             for (column, pat_str) in row.into_iter().enumerate() {\n                 try!(write!(f, \" \"));\n@@ -157,7 +157,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n         ast::ExprMatch(ref scrut, ref arms, source) => {\n-            for arm in arms.iter() {\n+            for arm in arms {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n@@ -285,8 +285,8 @@ fn check_arms(cx: &MatchCheckCtxt,\n               source: ast::MatchSource) {\n     let mut seen = Matrix(vec![]);\n     let mut printed_if_let_err = false;\n-    for &(ref pats, guard) in arms.iter() {\n-        for pat in pats.iter() {\n+    for &(ref pats, guard) in arms {\n+        for pat in pats {\n             let v = vec![&**pat];\n \n             match is_useful(cx, &seen, &v[], LeaveOutWitness) {\n@@ -979,7 +979,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n \n     visit::walk_fn(cx, kind, decl, body, sp);\n \n-    for input in decl.inputs.iter() {\n+    for input in &decl.inputs {\n         is_refutable(cx, &*input.pat, |pat| {\n             span_err!(cx.tcx.sess, input.pat.span, E0006,\n                 \"refutable pattern in function argument: `{}` not covered\",\n@@ -1012,7 +1012,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let tcx = cx.tcx;\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n-    for pat in pats.iter() {\n+    for pat in pats {\n         pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n             match bm {\n                 ast::BindByRef(_) => {\n@@ -1039,7 +1039,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         }\n     };\n \n-    for pat in pats.iter() {\n+    for pat in pats {\n         walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {"}, {"sha": "fa5d5227be535394e135d200740ec5b462011969", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -104,7 +104,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                             -> Option<&'a Expr> {\n     fn variant_expr<'a>(variants: &'a [P<ast::Variant>], id: ast::NodeId)\n                         -> Option<&'a Expr> {\n-        for variant in variants.iter() {\n+        for variant in variants {\n             if variant.node.id == id {\n                 return variant.node.disr_expr.as_ref().map(|e| &**e);\n             }"}, {"sha": "8f5906db589003dd27aaa7292e796b6c258e6921", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             let mut orig_kills = self.kills[start.. end].to_vec();\n \n             let mut changed = false;\n-            for &node_id in edge.data.exiting_scopes.iter() {\n+            for &node_id in &edge.data.exiting_scopes {\n                 let opt_cfg_idx = self.nodeid_to_index.get(&node_id).map(|&i|i);\n                 match opt_cfg_idx {\n                     Some(cfg_idx) => {\n@@ -501,7 +501,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n \n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n-        for b in bits.iter_mut() {\n+        for b in bits {\n             *b = e;\n         }\n     }\n@@ -550,7 +550,7 @@ fn bits_to_string(words: &[uint]) -> String {\n \n     // Note: this is a little endian printout of bytes.\n \n-    for &word in words.iter() {\n+    for &word in words {\n         let mut v = word;\n         for _ in 0..uint::BYTES {\n             result.push(sep);"}, {"sha": "4478e3270874dc43b8642a64b563f260d40afb68", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             }\n         };\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n-        for pat in pats.iter() {\n+        for pat in pats {\n             let field_id = fields.iter()\n                 .find(|field| field.name == pat.node.ident.name).unwrap().id;\n             self.live_symbols.insert(field_id.node);\n@@ -318,7 +318,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     }\n \n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n-    for attr in lint::gather_attrs(attrs).into_iter() {\n+    for attr in lint::gather_attrs(attrs) {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n                 if name.get() == dead_code => return true,\n@@ -356,7 +356,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n                 self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n             }\n             ast::ItemImpl(_, _, _, Some(ref _trait_ref), _, ref impl_items) => {\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         ast::MethodImplItem(ref method) => {\n                             self.worklist.push(method.id);\n@@ -397,10 +397,10 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n     // depending on whether a crate is built as bin or lib, and we want\n     // the warning to be consistent, we also seed the worklist with\n     // exported symbols.\n-    for id in exported_items.iter() {\n+    for id in exported_items {\n         worklist.push(*id);\n     }\n-    for id in reachable_symbols.iter() {\n+    for id in reachable_symbols {\n         worklist.push(*id);\n     }\n \n@@ -499,8 +499,8 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         match self.tcx.inherent_impls.borrow().get(&local_def(id)) {\n             None => (),\n             Some(impl_list) => {\n-                for impl_did in impl_list.iter() {\n-                    for item_did in (*impl_items)[*impl_did].iter() {\n+                for impl_did in &**impl_list {\n+                    for item_did in &(*impl_items)[*impl_did] {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {\n                             return true;\n@@ -536,7 +536,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         } else {\n             match item.node {\n                 ast::ItemEnum(ref enum_def, _) => {\n-                    for variant in enum_def.variants.iter() {\n+                    for variant in &enum_def.variants {\n                         if self.should_warn_about_variant(&variant.node) {\n                             self.warn_dead_code(variant.node.id, variant.span,\n                                                 variant.node.name, \"variant\");"}, {"sha": "6d35a82d153cd6c5151e9fedd428c0ae963364e6", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -85,7 +85,7 @@ pub type Dependencies = FnvHashMap<config::CrateType, DependencyList>;\n \n pub fn calculate(tcx: &ty::ctxt) {\n     let mut fmts = tcx.dependency_formats.borrow_mut();\n-    for &ty in tcx.sess.crate_types.borrow().iter() {\n+    for &ty in &*tcx.sess.crate_types.borrow() {\n         fmts.insert(ty, calculate_type(&tcx.sess, ty));\n     }\n     tcx.sess.abort_if_errors();\n@@ -148,7 +148,7 @@ fn calculate_type(sess: &session::Session,\n             debug!(\"adding dylib: {}\", data.name);\n             add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n             let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n-            for &(depnum, style) in deps.iter() {\n+            for &(depnum, style) in &deps {\n                 debug!(\"adding {:?}: {}\", style,\n                        sess.cstore.get_crate_data(depnum).name.clone());\n                 add_library(sess, depnum, style, &mut formats);"}, {"sha": "24073848edf541eb353b03563a231d3be6e613c8", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -139,7 +139,7 @@ fn configure_main(this: &mut EntryContext) {\n                                but you have one or more functions named 'main' that are not \\\n                                defined at the crate level. Either move the definition or \\\n                                attach the `#[main]` attribute to override this behavior.\");\n-            for &(_, span) in this.non_main_fns.iter() {\n+            for &(_, span) in &this.non_main_fns {\n                 this.session.span_note(span, \"here is a function named 'main'\");\n             }\n             this.session.abort_if_errors();"}, {"sha": "44a816eb2f803c330e7ce9661eae3cd6d4d52a81", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -342,7 +342,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_arg_patterns(&mut self,\n                          decl: &ast::FnDecl,\n                          body: &ast::Block) {\n-        for arg in decl.inputs.iter() {\n+        for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n \n             let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n@@ -372,7 +372,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn consume_exprs(&mut self, exprs: &Vec<P<ast::Expr>>) {\n-        for expr in exprs.iter() {\n+        for expr in exprs {\n             self.consume_expr(&**expr);\n         }\n     }\n@@ -476,7 +476,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ast::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n                 self.consume_expr(&**cond_expr);\n                 self.walk_block(&**then_blk);\n-                for else_expr in opt_else_expr.iter() {\n+                if let Some(ref else_expr) = *opt_else_expr {\n                     self.consume_expr(&**else_expr);\n                 }\n             }\n@@ -490,7 +490,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n-                for arm in arms.iter() {\n+                for arm in arms {\n                     let mode = self.arm_move_mode(discr_cmt.clone(), arm);\n                     let mode = mode.match_mode();\n                     self.walk_arm(discr_cmt.clone(), arm, mode);\n@@ -511,11 +511,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprInlineAsm(ref ia) => {\n-                for &(_, ref input) in ia.inputs.iter() {\n+                for &(_, ref input) in &ia.inputs {\n                     self.consume_expr(&**input);\n                 }\n \n-                for &(_, ref output, is_rw) in ia.outputs.iter() {\n+                for &(_, ref output, is_rw) in &ia.outputs {\n                     self.mutate_expr(expr, &**output,\n                                            if is_rw { WriteAndRead } else { JustWrite });\n                 }\n@@ -572,7 +572,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprRet(ref opt_expr) => {\n-                for expr in opt_expr.iter() {\n+                if let Some(ref expr) = *opt_expr {\n                     self.consume_expr(&**expr);\n                 }\n             }\n@@ -715,11 +715,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_block(&mut self, blk: &ast::Block) {\n         debug!(\"walk_block(blk.id={})\", blk.id);\n \n-        for stmt in blk.stmts.iter() {\n+        for stmt in &blk.stmts {\n             self.walk_stmt(&**stmt);\n         }\n \n-        for tail_expr in blk.expr.iter() {\n+        if let Some(ref tail_expr) = blk.expr {\n             self.consume_expr(&**tail_expr);\n         }\n     }\n@@ -729,7 +729,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         fields: &Vec<ast::Field>,\n                         opt_with: &Option<P<ast::Expr>>) {\n         // Consume the expressions supplying values for each field.\n-        for field in fields.iter() {\n+        for field in fields {\n             self.consume_expr(&*field.expr);\n         }\n \n@@ -762,7 +762,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         };\n \n         // Consume those fields of the with expression that are needed.\n-        for with_field in with_fields.iter() {\n+        for with_field in &with_fields {\n             if !contains_field_named(with_field, fields) {\n                 let cmt_field = self.mc.cat_field(&*with_expr,\n                                                   with_cmt.clone(),\n@@ -908,7 +908,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         match pass_args {\n             PassArgs::ByValue => {\n                 self.consume_expr(receiver);\n-                for &arg in rhs.iter() {\n+                for &arg in &rhs {\n                     self.consume_expr(arg);\n                 }\n \n@@ -926,26 +926,26 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         let r = ty::ReScope(region::CodeExtent::from_node_id(expr.id));\n         let bk = ty::ImmBorrow;\n \n-        for &arg in rhs.iter() {\n+        for &arg in &rhs {\n             self.borrow_expr(arg, r, bk, OverloadedOperator);\n         }\n         return true;\n     }\n \n     fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode<Span> {\n         let mut mode = Unknown;\n-        for pat in arm.pats.iter() {\n+        for pat in &arm.pats {\n             self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n         }\n         mode\n     }\n \n     fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm, mode: MatchMode) {\n-        for pat in arm.pats.iter() {\n+        for pat in &arm.pats {\n             self.walk_pat(discr_cmt.clone(), &**pat, mode);\n         }\n \n-        for guard in arm.guard.iter() {\n+        if let Some(ref guard) = arm.guard {\n             self.consume_expr(&**guard);\n         }\n \n@@ -1195,7 +1195,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n         ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n-            for freevar in freevars.iter() {\n+            for freevar in freevars {\n                 let id_var = freevar.def.def_id().node;\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };"}, {"sha": "8cb2774f7dff8290ebba032426df06f65eda5b83", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -116,7 +116,7 @@ pub trait Combine<'tcx> : Sized {\n     {\n         let mut substs = subst::Substs::empty();\n \n-        for &space in subst::ParamSpace::all().iter() {\n+        for &space in &subst::ParamSpace::all() {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n             let tps = try!(self.tps(space, a_tps, b_tps));\n@@ -129,7 +129,7 @@ pub trait Combine<'tcx> : Sized {\n             }\n \n             (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n-                for &space in subst::ParamSpace::all().iter() {\n+                for &space in &subst::ParamSpace::all() {\n                     let a_regions = a.get_slice(space);\n                     let b_regions = b.get_slice(space);\n \n@@ -139,7 +139,7 @@ pub trait Combine<'tcx> : Sized {\n                             variances.regions.get_slice(space)\n                         }\n                         None => {\n-                            for _ in a_regions.iter() {\n+                            for _ in a_regions {\n                                 invariance.push(ty::Invariant);\n                             }\n                             &invariance[]"}, {"sha": "17b62e463dae3d17ec2d3428707e7f9bbdd8fa88", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -170,7 +170,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             errors: &Vec<RegionResolutionError<'tcx>>) {\n         let p_errors = self.process_errors(errors);\n         let errors = if p_errors.is_empty() { errors } else { &p_errors };\n-        for error in errors.iter() {\n+        for error in errors {\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup);\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut trace_origins = Vec::new();\n         let mut same_regions = Vec::new();\n         let mut processed_errors = Vec::new();\n-        for error in errors.iter() {\n+        for error in errors {\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\");\n@@ -257,7 +257,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n         if !same_regions.is_empty() {\n             let common_scope_id = same_regions[0].scope_id;\n-            for sr in same_regions.iter() {\n+            for sr in &same_regions {\n                 // Since ProcessedErrors is used to reconstruct the function\n                 // declaration, we want to make sure that they are, in fact,\n                 // from the same scope\n@@ -335,7 +335,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   same_frs: &FreeRegionsFromSameFn) {\n             let scope_id = same_frs.scope_id;\n             let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in same_regions.iter_mut() {\n+            for sr in &mut *same_regions {\n                 if sr.contains(&sup_fr.bound_region)\n                    && scope_id == sr.scope_id {\n                     sr.push(sub_fr.bound_region);\n@@ -796,11 +796,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                var_origins: &[RegionVariableOrigin],\n                                trace_origins: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n                                same_regions: &[SameRegions]) {\n-        for vo in var_origins.iter() {\n+        for vo in var_origins {\n             self.report_inference_failure(vo.clone());\n         }\n         self.give_suggestion(same_regions);\n-        for &(ref trace, terr) in trace_origins.iter() {\n+        for &(ref trace, terr) in trace_origins {\n             self.report_type_error(trace.clone(), &terr);\n         }\n     }\n@@ -916,7 +916,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let mut ty_params = self.generics.ty_params.clone();\n         let where_clause = self.generics.where_clause.clone();\n         let mut kept_lifetimes = HashSet::new();\n-        for sr in self.same_regions.iter() {\n+        for sr in self.same_regions {\n             self.cur_anon.set(0);\n             self.offset_cur_anon();\n             let (anon_nums, region_names) =\n@@ -958,7 +958,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             // vector of string and then sort them. However, it makes the\n             // choice of lifetime name deterministic and thus easier to test.\n             let mut names = Vec::new();\n-            for rn in region_names.iter() {\n+            for rn in region_names {\n                 let lt_name = token::get_name(*rn).get().to_string();\n                 names.push(lt_name);\n             }\n@@ -973,7 +973,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                    -> (HashSet<u32>, HashSet<ast::Name>) {\n         let mut anon_nums = HashSet::new();\n         let mut region_names = HashSet::new();\n-        for br in same_regions.regions.iter() {\n+        for br in &same_regions.regions {\n             match *br {\n                 ty::BrAnon(i) => {\n                     anon_nums.insert(i);\n@@ -989,8 +989,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn extract_all_region_names(&self) -> HashSet<ast::Name> {\n         let mut all_region_names = HashSet::new();\n-        for sr in self.same_regions.iter() {\n-            for br in sr.regions.iter() {\n+        for sr in self.same_regions {\n+            for br in &sr.regions {\n                 match *br {\n                     ty::BrNamed(_, name) => {\n                         all_region_names.insert(name);\n@@ -1123,11 +1123,11 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         where_clause: ast::WhereClause)\n                         -> ast::Generics {\n         let mut lifetimes = Vec::new();\n-        for lt in add.iter() {\n+        for lt in add {\n             lifetimes.push(ast::LifetimeDef { lifetime: *lt,\n                                               bounds: Vec::new() });\n         }\n-        for lt in generics.lifetimes.iter() {\n+        for lt in &generics.lifetimes {\n             if keep.contains(&lt.lifetime.name) ||\n                 !remove.contains(&lt.lifetime.name) {\n                 lifetimes.push((*lt).clone());\n@@ -1147,7 +1147,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        region_names: &HashSet<ast::Name>)\n                        -> Vec<ast::Arg> {\n         let mut new_inputs = Vec::new();\n-        for arg in inputs.iter() {\n+        for arg in inputs {\n             let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n                                                        anon_nums, region_names);\n             let possibly_new_arg = ast::Arg {\n@@ -1729,7 +1729,7 @@ struct LifeGiver {\n impl LifeGiver {\n     fn with_taken(taken: &[ast::LifetimeDef]) -> LifeGiver {\n         let mut taken_ = HashSet::new();\n-        for lt in taken.iter() {\n+        for lt in taken {\n             let lt_name = token::get_name(lt.lifetime.name).get().to_string();\n             taken_.insert(lt_name);\n         }"}, {"sha": "e4eecd919c82b8245d6dbf106d65316f82062729", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -176,7 +176,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             // in both A and B.  Replace the variable with the \"first\"\n             // bound region from A that we find it to be associated\n             // with.\n-            for (a_br, a_r) in a_map.iter() {\n+            for (a_br, a_r) in a_map {\n                 if tainted.iter().any(|x| x == a_r) {\n                     debug!(\"generalize_region(r0={:?}): \\\n                             replacing with {:?}, tainted={:?}\",\n@@ -258,7 +258,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             let mut a_r = None;\n             let mut b_r = None;\n             let mut only_new_vars = true;\n-            for r in tainted.iter() {\n+            for r in &tainted {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {\n                         return fresh_bound_variable(infcx, debruijn);\n@@ -315,7 +315,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                       a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n                       r: ty::Region) -> ty::Region\n         {\n-            for (a_br, a_r) in a_map.iter() {\n+            for (a_br, a_r) in a_map {\n                 if *a_r == r {\n                     return ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br);\n                 }\n@@ -497,9 +497,9 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n            skol_map.repr(infcx.tcx));\n \n     let new_vars = infcx.region_vars_confined_to_snapshot(snapshot);\n-    for (&skol_br, &skol) in skol_map.iter() {\n+    for (&skol_br, &skol) in skol_map {\n         let tainted = infcx.tainted_regions(snapshot, skol);\n-        for &tainted_region in tainted.iter() {\n+        for &tainted_region in &tainted {\n             // Each skolemized should only be relatable to itself\n             // or new variables:\n             match tainted_region {"}, {"sha": "f8dae3e92da6e86b5dca35473301a96b84397742", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -998,8 +998,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n                     error_str)[]);\n \n-                for err in err.iter() {\n-                    ty::note_and_explain_type_err(self.tcx, *err)\n+                if let Some(err) = err {\n+                    ty::note_and_explain_type_err(self.tcx, err)\n                 }\n             }\n         }"}, {"sha": "919ea0a25202c5ed5a4f1246e2d2f4e1e07f1b4c", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -667,7 +667,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                     a, b);\n                             }\n                             VerifyGenericBound(_, _, a, ref bs) => {\n-                                for &b in bs.iter() {\n+                                for &b in bs {\n                                     consider_adding_bidirectional_edges(\n                                         &mut result_set, r,\n                                         a, b);\n@@ -1200,7 +1200,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                       errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         let mut reg_reg_dups = FnvHashSet();\n-        for verify in self.verifys.borrow().iter() {\n+        for verify in &*self.verifys.borrow() {\n             match *verify {\n                 VerifyRegSubReg(ref origin, sub, sup) => {\n                     if self.is_subregion_of(sub, sup) {\n@@ -1333,7 +1333,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n         let dummy_idx = graph.add_node(());\n \n-        for (constraint, _) in constraints.iter() {\n+        for (constraint, _) in &*constraints {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n                     graph.add_edge(NodeIndex(a_id.index as uint),\n@@ -1393,8 +1393,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         lower_bounds.sort_by(|a, b| { free_regions_first(a, b) });\n         upper_bounds.sort_by(|a, b| { free_regions_first(a, b) });\n \n-        for lower_bound in lower_bounds.iter() {\n-            for upper_bound in upper_bounds.iter() {\n+        for lower_bound in &lower_bounds {\n+            for upper_bound in &upper_bounds {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n@@ -1435,8 +1435,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             return;\n         }\n \n-        for upper_bound_1 in upper_bounds.iter() {\n-            for upper_bound_2 in upper_bounds.iter() {\n+        for upper_bound_1 in &upper_bounds {\n+            for upper_bound_2 in &upper_bounds {\n                 match self.glb_concrete_regions(upper_bound_1.region,\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n@@ -1554,7 +1554,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, _) in self.constraints.borrow().iter() {\n+            for (constraint, _) in &*self.constraints.borrow() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {}\","}, {"sha": "9b8a4a844120ddd328c27e0f9b8db38be69ccb28", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                                already instantiated\")\n         };\n \n-        for &(dir, vid) in relations.iter() {\n+        for &(dir, vid) in &relations {\n             stack.push((ty, dir, vid));\n         }\n \n@@ -165,7 +165,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         let mut escaping_types = Vec::new();\n         let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n         debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n-        for action in actions_since_snapshot.iter() {\n+        for action in actions_since_snapshot {\n             match *action {\n                 sv::UndoLog::NewElem(index) => {\n                     // if any new variables were created during the"}, {"sha": "d9b90c1935a396058540d43958e475542b5300d7", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -120,7 +120,7 @@ impl LanguageItems {\n             (self.fn_once_trait(), ty::FnOnceClosureKind),\n             ];\n \n-        for &(opt_def_id, kind) in def_id_kinds.iter() {\n+        for &(opt_def_id, kind) in &def_id_kinds {\n             if Some(id) == opt_def_id {\n                 return Some(kind);\n             }\n@@ -217,7 +217,7 @@ impl<'a> LanguageItemCollector<'a> {\n }\n \n pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n-    for attribute in attrs.iter() {\n+    for attribute in attrs {\n         match attribute.value_str() {\n             Some(ref value) if attribute.check_name(\"lang\") => {\n                 return Some(value.clone());"}, {"sha": "e40e04bdee86acc308e66d45cf80fccbea0b78c7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -378,7 +378,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n-    for arg in decl.inputs.iter() {\n+    for arg in &decl.inputs {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n                                &*arg.pat,\n                                |_bm, arg_id, _x, path1| {\n@@ -427,7 +427,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n }\n \n fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n-    for pat in arm.pats.iter() {\n+    for pat in &arm.pats {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n@@ -464,7 +464,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // construction site.\n         let mut call_caps = Vec::new();\n         ty::with_freevars(ir.tcx, expr.id, |freevars| {\n-            for fv in freevars.iter() {\n+            for fv in freevars {\n                 if let DefLocal(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n@@ -1049,7 +1049,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for arm in arms.iter() {\n+            for arm in arms {\n                 let body_succ =\n                     self.propagate_through_expr(&*arm.body, succ);\n                 let guard_succ =\n@@ -1445,12 +1445,12 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       ast::ExprInlineAsm(ref ia) => {\n-        for &(_, ref input) in ia.inputs.iter() {\n+        for &(_, ref input) in &ia.inputs {\n           this.visit_expr(&**input);\n         }\n \n         // Output operands must be lvalues\n-        for &(_, ref out, _) in ia.outputs.iter() {\n+        for &(_, ref out, _) in &ia.outputs {\n           this.check_lvalue(&**out);\n           this.visit_expr(&**out);\n         }\n@@ -1590,7 +1590,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, decl: &ast::FnDecl, entry_ln: LiveNode) {\n-        for arg in decl.inputs.iter() {\n+        for arg in &decl.inputs {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    &*arg.pat,\n                                    |_bm, p_id, sp, path1| {\n@@ -1620,7 +1620,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                          -> bool {\n         if !self.used_on_entry(ln, var) {\n             let r = self.should_warn(var);\n-            for name in r.iter() {\n+            if let Some(name) = r {\n \n                 // annoying: for parameters in funcs like `fn(x: int)\n                 // {ret}`, there is only one node, so asking about\n@@ -1634,10 +1634,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 if is_assigned {\n                     self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         format!(\"variable `{}` is assigned to, but never used\",\n-                                *name));\n+                                name));\n                 } else {\n                     self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n-                        format!(\"unused variable: `{}`\", *name));\n+                        format!(\"unused variable: `{}`\", name));\n                 }\n             }\n             true\n@@ -1653,9 +1653,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n-            for name in r.iter() {\n+            if let Some(name) = r {\n                 self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n-                    format!(\"value assigned to `{}` is never read\", *name));\n+                    format!(\"value assigned to `{}` is never read\", name));\n             }\n         }\n     }"}, {"sha": "1ae483be2696d83a93183a58d73da756e7ada219", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1208,7 +1208,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     }\n                 }\n                 Some(&def::DefConst(..)) => {\n-                    for subpat in subpats.iter() {\n+                    for subpat in subpats {\n                         try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }\n                 }\n@@ -1230,7 +1230,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            for fp in field_pats.iter() {\n+            for fp in field_pats {\n                 let field_ty = try!(self.pat_ty(&*fp.node.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n                 try!(self.cat_pattern_(cmt_field, &*fp.node.pat, op));\n@@ -1259,15 +1259,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n               let elt_cmt = try!(self.cat_index(pat, try!(self.deref_vec(pat, cmt))));\n-              for before_pat in before.iter() {\n+              for before_pat in before {\n                   try!(self.cat_pattern_(elt_cmt.clone(), &**before_pat, op));\n               }\n-              for slice_pat in slice.iter() {\n+              if let Some(ref slice_pat) = *slice {\n                   let slice_ty = try!(self.pat_ty(&**slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n                   try!(self.cat_pattern_(slice_cmt, &**slice_pat, op));\n               }\n-              for after_pat in after.iter() {\n+              for after_pat in after {\n                   try!(self.cat_pattern_(elt_cmt.clone(), &**after_pat, op));\n               }\n           }"}, {"sha": "0af226de251a182afe820b6c8ed4fe350b123d78", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&mut self) {\n-        for (_, destructor_def_id) in self.tcx.destructor_for_type.borrow().iter() {\n+        for (_, destructor_def_id) in &*self.tcx.destructor_for_type.borrow() {\n             if destructor_def_id.krate == ast::LOCAL_CRATE {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }\n@@ -371,7 +371,7 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     //         other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    for id in exported_items.iter() {\n+    for id in exported_items {\n         reachable_context.worklist.push(*id);\n     }\n     for (_, item) in tcx.lang_items.items() {"}, {"sha": "7dcd358165c9248d88c7dbe3238b4797906465b4", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -20,7 +20,7 @@ use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n \n pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n-    for attr in krate.attrs.iter() {\n+    for attr in &krate.attrs {\n         if !attr.check_name(\"recursion_limit\") {\n             continue;\n         }"}, {"sha": "87d386d94c97270c3fc4a75af0a6d60f2c469a2d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -888,14 +888,14 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n                 record_rvalue_scope(visitor, &**subexpr, blk_id);\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n-                for field in fields.iter() {\n+                for field in fields {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &*field.expr, blk_id);\n                 }\n             }\n             ast::ExprVec(ref subexprs) |\n             ast::ExprTup(ref subexprs) => {\n-                for subexpr in subexprs.iter() {\n+                for subexpr in subexprs {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &**subexpr, blk_id);\n                 }"}, {"sha": "365355c4a2a0b3db38fd2594d0742d208c445cac", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -187,14 +187,14 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n+        for ty_param in &*generics.ty_params {\n             visit::walk_ty_param_bounds_helper(self, &ty_param.bounds);\n             match ty_param.default {\n                 Some(ref ty) => self.visit_ty(&**ty),\n                 None => {}\n             }\n         }\n-        for predicate in generics.where_clause.predicates.iter() {\n+        for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ ref bounded_ty,\n                                                                                ref bounds,\n@@ -207,7 +207,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                                                                                 .. }) => {\n \n                     self.visit_lifetime_ref(lifetime);\n-                    for bound in bounds.iter() {\n+                    for bound in bounds {\n                         self.visit_lifetime_ref(bound);\n                     }\n                 }\n@@ -229,7 +229,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n         self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n             this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n-            for lifetime in trait_ref.bound_lifetimes.iter() {\n+            for lifetime in &trait_ref.bound_lifetimes {\n                 this.visit_lifetime_def(lifetime);\n             }\n             this.visit_trait_ref(&trait_ref.trait_ref)\n@@ -408,7 +408,7 @@ impl<'a> LifetimeContext<'a> {\n             let lifetime_i = &lifetimes[i];\n \n             let special_idents = [special_idents::static_lifetime];\n-            for lifetime in lifetimes.iter() {\n+            for lifetime in lifetimes {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n                     span_err!(self.sess, lifetime.lifetime.span, E0262,\n                         \"illegal lifetime parameter name: `{}`\",\n@@ -431,7 +431,7 @@ impl<'a> LifetimeContext<'a> {\n             // It is a soft error to shadow a lifetime within a parent scope.\n             self.check_lifetime_def_for_shadowing(old_scope, &lifetime_i.lifetime);\n \n-            for bound in lifetime_i.bounds.iter() {\n+            for bound in &lifetime_i.bounds {\n                 self.resolve_lifetime_ref(bound);\n             }\n         }\n@@ -535,10 +535,10 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n         let mut collector =\n             FreeLifetimeCollector { early_bound: &mut early_bound,\n                                     late_bound: &mut late_bound };\n-        for ty_param in generics.ty_params.iter() {\n+        for ty_param in &*generics.ty_params {\n             visit::walk_ty_param_bounds_helper(&mut collector, &ty_param.bounds);\n         }\n-        for predicate in generics.where_clause.predicates.iter() {\n+        for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounds,\n                                                                               ref bounded_ty,\n@@ -551,7 +551,7 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n                                                                                 ..}) => {\n                     collector.visit_lifetime_ref(lifetime);\n \n-                    for bound in bounds.iter() {\n+                    for bound in bounds {\n                         collector.visit_lifetime_ref(bound);\n                     }\n                 }\n@@ -562,11 +562,11 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n \n     // Any lifetime that either has a bound or is referenced by a\n     // bound is early.\n-    for lifetime_def in generics.lifetimes.iter() {\n+    for lifetime_def in &generics.lifetimes {\n         if !lifetime_def.bounds.is_empty() {\n             shuffle(&mut early_bound, &mut late_bound,\n                     lifetime_def.lifetime.name);\n-            for bound in lifetime_def.bounds.iter() {\n+            for bound in &lifetime_def.bounds {\n                 shuffle(&mut early_bound, &mut late_bound,\n                         bound.name);\n             }"}, {"sha": "5028a1322cac1aaff0a6d369b72acef40883e531", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -148,7 +148,7 @@ impl Index {\n     /// Construct the stability index for a crate being compiled.\n     pub fn build(sess: &Session, krate: &Crate) -> Index {\n         let mut staged_api = false;\n-        for attr in krate.attrs.iter() {\n+        for attr in &krate.attrs {\n             if attr.name().get() == \"staged_api\" {\n                 match attr.node.value.node {\n                     ast::MetaWord(_) => {\n@@ -273,7 +273,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n         ast::ItemTrait(_, _, ref supertraits, _) => {\n-            for t in supertraits.iter() {\n+            for t in &**supertraits {\n                 if let ast::TraitTyParamBound(ref t, _) = *t {\n                     let id = ty::trait_ref_to_def_id(tcx, &t.trait_ref);\n                     maybe_do_stability_check(tcx, id, t.trait_ref.path.span, cb);\n@@ -410,11 +410,11 @@ pub fn check_unused_features(sess: &Session,\n     let mut active_lib_features: FnvHashMap<InternedString, Span>\n         = lib_features.clone().into_iter().collect();\n \n-    for used_feature in used_lib_features.iter() {\n+    for used_feature in used_lib_features {\n         active_lib_features.remove(used_feature);\n     }\n \n-    for (_, &span) in active_lib_features.iter() {\n+    for (_, &span) in &active_lib_features {\n         sess.add_lint(lint::builtin::UNUSED_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,"}, {"sha": "eb6bc4c38353a43e05d8107cc83c4892ef524df0", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -241,7 +241,7 @@ pub struct SeparateVecsPerParamSpace<T> {\n impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"VecPerParamSpace {{\"));\n-        for space in ParamSpace::all().iter() {\n+        for space in &ParamSpace::all() {\n             try!(write!(fmt, \"{:?}: {:?}, \", *space, self.get_slice(*space)));\n         }\n         try!(write!(fmt, \"}}\"));\n@@ -317,7 +317,7 @@ impl<T> VecPerParamSpace<T> {\n     ///\n     /// Unlike the `extend` method in `Vec`, this should not be assumed\n     /// to be a cheap operation (even when amortized over many calls).\n-    pub fn extend<I:Iterator<Item=T>>(&mut self, space: ParamSpace, mut values: I) {\n+    pub fn extend<I:Iterator<Item=T>>(&mut self, space: ParamSpace, values: I) {\n         // This could be made more efficient, obviously.\n         for item in values {\n             self.push(space, item);\n@@ -352,7 +352,7 @@ impl<T> VecPerParamSpace<T> {\n     pub fn replace(&mut self, space: ParamSpace, elems: Vec<T>) {\n         // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n         self.truncate(space, 0);\n-        for t in elems.into_iter() {\n+        for t in elems {\n             self.push(space, t);\n         }\n     }"}, {"sha": "8ce4e38896ecd2502726d577516e088af7052623", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -35,7 +35,7 @@ provide an impl. To see what I mean, consider the body of `clone_slice`:\n \n     fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n         let mut v = Vec::new();\n-        for e in x.iter() {\n+        for e in &x {\n             v.push((*e).clone()); // (*)\n         }\n     }"}, {"sha": "b8886fa65baa8c8db2e1d45be14068d364a30d9f", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -28,7 +28,7 @@ use util::ppaux::{Repr, UserString};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {\n-    for error in errors.iter() {\n+    for error in errors {\n         report_fulfillment_error(infcx, error);\n     }\n }\n@@ -68,7 +68,7 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                      span: Span) -> Option<String> {\n     let def_id = trait_ref.def_id;\n     let mut report = None;\n-    for item in ty::get_attrs(infcx.tcx, def_id).iter() {\n+    for item in &*ty::get_attrs(infcx.tcx, def_id) {\n         if item.check_name(\"rustc_on_unimplemented\") {\n             let err_sp = if item.meta().span == DUMMY_SP {\n                 span"}, {"sha": "8adcd256ccebcccc825e70aa72fa7dee0b608918", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         let mut selcx = SelectionContext::new(infcx, typer);\n         let normalized = project::normalize_projection_type(&mut selcx, projection_ty, cause, 0);\n \n-        for obligation in normalized.obligations.into_iter() {\n+        for obligation in normalized.obligations {\n             self.register_predicate_obligation(infcx, obligation);\n         }\n \n@@ -289,7 +289,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n-            for new_obligation in new_obligations.into_iter() {\n+            for new_obligation in new_obligations {\n                 self.register_predicate_obligation(selcx.infcx(), new_obligation);\n             }\n         }"}, {"sha": "f69bf31626f628591c721d2d3628988c470e9ddd", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -438,7 +438,7 @@ pub fn normalize_param_env<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx\n         let mut fulfill_cx = FulfillmentContext::new();\n         let Normalized { value: predicates, obligations } =\n             project::normalize(selcx, cause, &param_env.caller_bounds);\n-        for obligation in obligations.into_iter() {\n+        for obligation in obligations {\n             fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n         }\n         try!(fulfill_cx.select_all_or_error(selcx.infcx(), param_env));"}, {"sha": "c88e58266a07631aa32659791835aa356482cea6", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -176,7 +176,7 @@ fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // The `Self` type is erased, so it should not appear in list of\n     // arguments or return type apart from the receiver.\n     let ref sig = method.fty.sig;\n-    for &input_ty in sig.0.inputs[1..].iter() {\n+    for &input_ty in &sig.0.inputs[1..] {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }"}, {"sha": "3ede6bbb965ef4f823f2dd5056db4b1e6ff2d639", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -802,7 +802,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n \n     let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n     let mut impl_ty = None;\n-    for impl_item in impl_items.iter() {\n+    for impl_item in impl_items {\n         let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n             ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n             ty::MethodTraitItem(..) => { continue; }"}, {"sha": "000572cdd40a34f10c3edad3f8e7cca3d07fd022", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -295,7 +295,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n                                                 stack: Option<&TraitObligationStack<'o, 'tcx>>,\n-                                                mut predicates: I)\n+                                                predicates: I)\n                                                 -> EvaluationResult<'tcx>\n         where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n@@ -1089,7 +1089,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"assemble_candidates_from_impls(self_ty={})\", self_ty.repr(self.tcx()));\n \n         let all_impls = self.all_impls(obligation.predicate.def_id());\n-        for &impl_def_id in all_impls.iter() {\n+        for &impl_def_id in &all_impls {\n             self.infcx.probe(|snapshot| {\n                 let (skol_obligation_trait_pred, skol_map) =\n                     self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);"}, {"sha": "45ce692bb076354e7bbb86bc891bc36d77fb4a05", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -343,7 +343,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n \n         let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n-        for trait_item in trait_items.iter() {\n+        for trait_item in &**trait_items {\n             match *trait_item {\n                 ty::MethodTraitItem(_) => method_count += 1,\n                 ty::TypeTraitItem(_) => {}"}, {"sha": "ec331d8f4b97fc51555d994b97007ab6f8b8d307", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -872,7 +872,7 @@ macro_rules! sty_debug_print {\n                 $(let mut $variant = total;)*\n \n \n-                for (_, t) in tcx.interner.borrow().iter() {\n+                for (_, t) in &*tcx.interner.borrow() {\n                     let variant = match t.sty {\n                         ty::ty_bool | ty::ty_char | ty::ty_int(..) | ty::ty_uint(..) |\n                             ty::ty_float(..) | ty::ty_str => continue,\n@@ -2579,7 +2579,7 @@ impl FlagComputation {\n             &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_substs(principal.0.substs);\n-                for projection_bound in bounds.projection_bounds.iter() {\n+                for projection_bound in &bounds.projection_bounds {\n                     let mut proj_computation = FlagComputation::new();\n                     proj_computation.add_projection_predicate(&projection_bound.0);\n                     computation.add_bound_computation(&proj_computation);\n@@ -2618,7 +2618,7 @@ impl FlagComputation {\n     }\n \n     fn add_tys(&mut self, tys: &[Ty]) {\n-        for &ty in tys.iter() {\n+        for &ty in tys {\n             self.add_ty(ty);\n         }\n     }\n@@ -3530,7 +3530,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         // make no assumptions (other than that it cannot have an\n         // in-scope type parameter within, which makes no sense).\n         let mut tc = TC::All - TC::InteriorParam;\n-        for bound in bounds.builtin_bounds.iter() {\n+        for bound in &bounds.builtin_bounds {\n             tc = tc - match bound {\n                 BoundSync | BoundSend | BoundCopy => TC::None,\n                 BoundSized => TC::Nonsized,\n@@ -4644,7 +4644,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0;\n-    for f in fields.iter() { if f.name == name { return i; } i += 1; }\n+    for f in fields { if f.name == name { return i; } i += 1; }\n     tcx.sess.bug(&format!(\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n@@ -5468,25 +5468,25 @@ pub fn predicates<'tcx>(\n {\n     let mut vec = Vec::new();\n \n-    for builtin_bound in bounds.builtin_bounds.iter() {\n+    for builtin_bound in &bounds.builtin_bounds {\n         match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n             Ok(trait_ref) => { vec.push(trait_ref.as_predicate()); }\n             Err(ErrorReported) => { }\n         }\n     }\n \n-    for &region_bound in bounds.region_bounds.iter() {\n+    for &region_bound in &bounds.region_bounds {\n         // account for the binder being introduced below; no need to shift `param_ty`\n         // because, at present at least, it can only refer to early-bound regions\n         let region_bound = ty_fold::shift_region(region_bound, 1);\n         vec.push(ty::Binder(ty::OutlivesPredicate(param_ty, region_bound)).as_predicate());\n     }\n \n-    for bound_trait_ref in bounds.trait_bounds.iter() {\n+    for bound_trait_ref in &bounds.trait_bounds {\n         vec.push(bound_trait_ref.as_predicate());\n     }\n \n-    for projection in bounds.projection_bounds.iter() {\n+    for projection in &bounds.projection_bounds {\n         vec.push(projection.as_predicate());\n     }\n \n@@ -5931,17 +5931,17 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n         // Record the trait->implementation mappings, if applicable.\n         let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n-        for trait_ref in associated_traits.iter() {\n+        if let Some(ref trait_ref) = associated_traits {\n             record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for impl_item_def_id in impl_items.iter() {\n+        for impl_item_def_id in &impl_items {\n             let method_def_id = impl_item_def_id.def_id();\n             match impl_or_trait_item(tcx, method_def_id) {\n                 MethodTraitItem(method) => {\n-                    for &source in method.provided_source.iter() {\n+                    if let Some(source) = method.provided_source {\n                         tcx.provided_method_sources\n                            .borrow_mut()\n                            .insert(method_def_id, source);\n@@ -5985,11 +5985,11 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for impl_item_def_id in impl_items.iter() {\n+        for impl_item_def_id in &impl_items {\n             let method_def_id = impl_item_def_id.def_id();\n             match impl_or_trait_item(tcx, method_def_id) {\n                 MethodTraitItem(method) => {\n-                    for &source in method.provided_source.iter() {\n+                    if let Some(source) = method.provided_source {\n                         tcx.provided_method_sources\n                            .borrow_mut()\n                            .insert(method_def_id, source);\n@@ -6121,7 +6121,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n         };\n         let fn_sig = |&: state: &mut SipHasher, sig: &Binder<FnSig<'tcx>>| {\n             let sig = anonymize_late_bound_regions(tcx, sig).0;\n-            for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n+            for a in &sig.inputs { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {\n                 helper(tcx, output, svh, state);\n             }\n@@ -6270,15 +6270,15 @@ pub fn construct_free_substs<'a,'tcx>(\n                           free_id: ast::NodeId,\n                           region_params: &[RegionParameterDef])\n     {\n-        for r in region_params.iter() {\n+        for r in region_params {\n             regions.push(r.space, ty::free_region_from_def(free_id, r));\n         }\n     }\n \n     fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   types: &mut VecPerParamSpace<Ty<'tcx>>,\n                                   defs: &[TypeParameterDef<'tcx>]) {\n-        for def in defs.iter() {\n+        for def in defs {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n                    def.repr(tcx));\n             let ty = ty::mk_param_from_def(tcx, def);\n@@ -6351,7 +6351,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, predicates: &[ty::Predicate<'tcx>]) {\n         debug!(\"record_region_bounds(predicates={:?})\", predicates.repr(tcx));\n \n-        for predicate in predicates.iter() {\n+        for predicate in predicates {\n             match *predicate {\n                 Predicate::Projection(..) |\n                 Predicate::Trait(..) |\n@@ -6870,7 +6870,7 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n     let did = match self_type.sty {\n         ty::ty_struct(struct_did, substs) => {\n             let fields = ty::struct_fields(tcx, struct_did, substs);\n-            for field in fields.iter() {\n+            for field in &fields {\n                 if type_moves_by_default(param_env, span, field.mt.ty) {\n                     return Err(FieldDoesNotImplementCopy(field.name))\n                 }\n@@ -6879,8 +6879,8 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n         }\n         ty::ty_enum(enum_did, substs) => {\n             let enum_variants = ty::enum_variants(tcx, enum_did);\n-            for variant in enum_variants.iter() {\n-                for variant_arg_type in variant.args.iter() {\n+            for variant in &*enum_variants {\n+                for variant_arg_type in &variant.args {\n                     let substd_arg_type =\n                         variant_arg_type.subst(tcx, substs);\n                     if type_moves_by_default(param_env, span, substd_arg_type) {"}, {"sha": "425c9a4c9f7748dd8c01406559d1727e34da3658", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -78,7 +78,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n \n     let mut missing = HashSet::new();\n     sess.cstore.iter_crate_data(|cnum, _| {\n-        for item in csearch::get_missing_lang_items(&sess.cstore, cnum).iter() {\n+        for item in &csearch::get_missing_lang_items(&sess.cstore, cnum) {\n             missing.insert(*item);\n         }\n     });"}, {"sha": "110e672b70f87888484a02c1d07f4cc81c6e73a5", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -48,7 +48,7 @@ pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n         },\n         _ => {\n             diagnostic.handler().err(\"multiple plugin registration functions found\");\n-            for &(_, span) in finder.registrars.iter() {\n+            for &(_, span) in &finder.registrars {\n                 diagnostic.span_note(span, \"one is here\");\n             }\n             diagnostic.handler().abort_if_errors();"}, {"sha": "dd0b0a63ced9de64a3b63eddf14ace3d25b26bc6", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -73,7 +73,7 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     // We need to error on `#[macro_use] extern crate` when it isn't at the\n     // crate root, because `$crate` won't work properly. Identify these by\n     // spans, because the crate map isn't set up yet.\n-    for item in krate.module.items.iter() {\n+    for item in &krate.module.items {\n         if let ast::ItemExternCrate(_) = item.node {\n             loader.span_whitelist.insert(item.span);\n         }\n@@ -82,7 +82,7 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     visit::walk_crate(&mut loader, krate);\n \n     if let Some(plugins) = addl_plugins {\n-        for plugin in plugins.iter() {\n+        for plugin in &plugins {\n             loader.load_plugin(CrateOrString::Str(plugin.as_slice()),\n                                                   None, None, None)\n         }\n@@ -107,7 +107,7 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n         let mut plugin_attr = None;\n         let mut macro_selection = Some(HashSet::new());  // None => load all\n         let mut reexport = HashSet::new();\n-        for attr in item.attrs.iter() {\n+        for attr in &item.attrs {\n             let mut used = true;\n             match attr.name().get() {\n                 \"phase\" => {\n@@ -127,7 +127,7 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n                         macro_selection = None;\n                     }\n                     if let (Some(sel), Some(names)) = (macro_selection.as_mut(), names) {\n-                        for name in names.iter() {\n+                        for name in names {\n                             if let ast::MetaWord(ref name) = name.node {\n                                 sel.insert(name.clone());\n                             } else {\n@@ -145,7 +145,7 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n                         }\n                     };\n \n-                    for name in names.iter() {\n+                    for name in names {\n                         if let ast::MetaWord(ref name) = name.node {\n                             reexport.insert(name.clone());\n                         } else {\n@@ -204,7 +204,7 @@ impl<'a> PluginLoader<'a> {\n             }\n         }\n \n-        for mut def in macros.into_iter() {\n+        for mut def in macros {\n             let name = token::get_ident(def.ident);\n             def.use_locally = match macro_selection.as_ref() {\n                 None => true,"}, {"sha": "88f6dc673cf18f8e4b8ab2aaf97e92b03c840272", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -300,13 +300,13 @@ macro_rules! options {\n     pub fn $buildfn(matches: &getopts::Matches) -> $struct_name\n     {\n         let mut op = $defaultfn();\n-        for option in matches.opt_strs($prefix).into_iter() {\n+        for option in matches.opt_strs($prefix) {\n             let mut iter = option.splitn(1, '=');\n             let key = iter.next().unwrap();\n             let value = iter.next();\n             let option_to_lookup = key.replace(\"-\", \"_\");\n             let mut found = false;\n-            for &(candidate, setter, opt_type_desc, _) in $stat.iter() {\n+            for &(candidate, setter, opt_type_desc, _) in $stat {\n                 if option_to_lookup != candidate { continue }\n                 if !setter(&mut op, value) {\n                     match (value, opt_type_desc) {\n@@ -830,8 +830,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n \n-    for &level in [lint::Allow, lint::Warn, lint::Deny, lint::Forbid].iter() {\n-        for lint_name in matches.opt_strs(level.as_str()).into_iter() {\n+    for &level in &[lint::Allow, lint::Warn, lint::Deny, lint::Forbid] {\n+        for lint_name in matches.opt_strs(level.as_str()) {\n             if lint_name == \"help\" {\n                 describe_lints = true;\n             } else {\n@@ -853,7 +853,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let mut output_types = Vec::new();\n     if !debugging_opts.parse_only && !no_trans {\n         let unparsed_output_types = matches.opt_strs(\"emit\");\n-        for unparsed_output_type in unparsed_output_types.iter() {\n+        for unparsed_output_type in &unparsed_output_types {\n             for part in unparsed_output_type.split(',') {\n                 let output_type = match part.as_slice() {\n                     \"asm\" => OutputTypeAssembly,\n@@ -923,7 +923,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n \n     let mut search_paths = SearchPaths::new();\n-    for s in matches.opt_strs(\"L\").iter() {\n+    for s in &matches.opt_strs(\"L\") {\n         search_paths.add_path(&s[]);\n     }\n \n@@ -997,7 +997,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n \n     let mut externs = HashMap::new();\n-    for arg in matches.opt_strs(\"extern\").iter() {\n+    for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n@@ -1049,7 +1049,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateType>, String> {\n \n     let mut crate_types: Vec<CrateType> = Vec::new();\n-    for unparsed_crate_type in list_list.iter() {\n+    for unparsed_crate_type in &list_list {\n         for part in unparsed_crate_type.split(',') {\n             let new_part = match part {\n                 \"lib\"       => default_lib_output(),"}, {"sha": "b77a70f1f5d5a6467378f6262760eee94573d963", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -163,7 +163,7 @@ pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n     while i < queue.len() {\n         match edges_map.get(&queue[i]) {\n             Some(edges) => {\n-                for target in edges.iter() {\n+                for target in edges {\n                     if *target == destination {\n                         return true;\n                     }"}, {"sha": "8da06e63daefcf07ee3d07d7d876d3447e442ea8", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -62,7 +62,7 @@ impl Hasher for FnvHasher {\n impl Writer for FnvHasher {\n     fn write(&mut self, bytes: &[u8]) {\n         let FnvHasher(mut hash) = *self;\n-        for byte in bytes.iter() {\n+        for byte in bytes {\n             hash = hash ^ (*byte as u64);\n             hash = hash * 0x100000001b3;\n         }"}, {"sha": "458701f2dd7626c2746206c5bccacfb5fa5641bd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -494,11 +494,11 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps[..tps.len() - num_defaults].iter() {\n+    for t in &tps[..tps.len() - num_defaults] {\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    for projection in projections.iter() {\n+    for projection in projections {\n         strs.push(format!(\"{}={}\",\n                           projection.projection_ty.item_name.user_string(cx),\n                           projection.ty.user_string(cx)));\n@@ -665,7 +665,7 @@ impl<'tcx> UserString<'tcx> for ty::TyTrait<'tcx> {\n         components.push(tap.user_string(tcx));\n \n         // Builtin bounds.\n-        for bound in bounds.builtin_bounds.iter() {\n+        for bound in &bounds.builtin_bounds {\n             components.push(bound.user_string(tcx));\n         }\n \n@@ -748,7 +748,7 @@ impl<'tcx> Repr<'tcx> for subst::RegionSubsts {\n impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         let mut res = Vec::new();\n-        for b in self.iter() {\n+        for b in self {\n             res.push(match b {\n                 ty::BoundSend => \"Send\".to_string(),\n                 ty::BoundSized => \"Sized\".to_string(),\n@@ -764,7 +764,7 @@ impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n         res.push(self.builtin_bounds.repr(tcx));\n-        for t in self.trait_bounds.iter() {\n+        for t in &self.trait_bounds {\n             res.push(t.repr(tcx));\n         }\n         res.connect(\"+\")\n@@ -1157,7 +1157,7 @@ impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n         if !s.is_empty() {\n             result.push(s);\n         }\n-        for n in self.trait_bounds.iter() {\n+        for n in &self.trait_bounds {\n             result.push(n.user_string(tcx));\n         }\n         result.connect(\" + \")\n@@ -1173,11 +1173,11 @@ impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n             res.push(region_str);\n         }\n \n-        for bound in self.builtin_bounds.iter() {\n+        for bound in &self.builtin_bounds {\n             res.push(bound.user_string(tcx));\n         }\n \n-        for projection_bound in self.projection_bounds.iter() {\n+        for projection_bound in &self.projection_bounds {\n             res.push(projection_bound.user_string(tcx));\n         }\n "}, {"sha": "b779963a2191711774c1edbcb54171b5dd30d357", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -99,7 +99,7 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n     let oslibname = format!(\"{}{}{}\", osprefix, name, ossuffix);\n     let unixlibname = format!(\"lib{}.a\", name);\n \n-    for path in search_paths.iter() {\n+    for path in search_paths {\n         debug!(\"looking for {} inside {:?}\", name, path.display());\n         let test = path.join(&oslibname[]);\n         if test.exists() { return test }\n@@ -244,7 +244,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // 32,768, and we leave a bit of extra space for the program name.\n         static ARG_LENGTH_LIMIT: uint = 32000;\n \n-        for member_name in self.members.iter() {\n+        for member_name in &self.members {\n             let len = member_name.as_vec().len();\n \n             // `len + 1` to account for the space that's inserted before each\n@@ -297,7 +297,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n         let files = try!(fs::readdir(loc.path()));\n-        for file in files.iter() {\n+        for file in &files {\n             let filename = file.filename_str().unwrap();\n             if skip(filename) { continue }\n             if filename.contains(\".SYMDEF\") { continue }"}, {"sha": "36bbd4b987297d020e5fe867d36b604bfbf9211f", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -51,7 +51,7 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n-    for rpath in rpaths.iter() {\n+    for rpath in rpaths {\n         ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)[]));\n     }\n     return ret;\n@@ -63,7 +63,7 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n {\n     debug!(\"output: {:?}\", config.out_filename.display());\n     debug!(\"libs:\");\n-    for libpath in libs.iter() {\n+    for libpath in libs {\n         debug!(\"    {:?}\", libpath.display());\n     }\n \n@@ -77,7 +77,7 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n \n     fn log_rpaths(desc: &str, rpaths: &[String]) {\n         debug!(\"{} rpaths:\", desc);\n-        for rpath in rpaths.iter() {\n+        for rpath in rpaths {\n             debug!(\"    {}\", *rpath);\n         }\n     }\n@@ -138,7 +138,7 @@ fn get_install_prefix_rpath<F, G>(config: RPathConfig<F, G>) -> String where\n fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n-    for rpath in rpaths.iter() {\n+    for rpath in rpaths {\n         if set.insert(&rpath[]) {\n             minimized.push(rpath.clone());\n         }"}, {"sha": "c15b4114aa7b896cc19ffceacb2e37b462f59d37", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -557,15 +557,15 @@ mod tests {\n \n     fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n         // Test that it works when accepting the message all at once\n-        for t in tests.iter() {\n+        for t in tests {\n             sh.reset();\n             sh.input_str(t.input.as_slice());\n             let out_str = sh.result_str();\n             assert!(out_str == t.output_str);\n         }\n \n         // Test that it works when accepting the message in pieces\n-        for t in tests.iter() {\n+        for t in tests {\n             sh.reset();\n             let len = t.input.len();\n             let mut left = len;"}, {"sha": "a14f4775ec135be769035af2485329b12f4efabf", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -79,7 +79,7 @@ impl Svh {\n         //        avoid collisions.\n         let mut state = SipHasher::new();\n \n-        for data in metadata.iter() {\n+        for data in metadata {\n             data.hash(&mut state);\n         }\n \n@@ -97,7 +97,7 @@ impl Svh {\n         //\n         // We hash only the MetaItems instead of the entire Attribute\n         // to avoid hashing the AttrId\n-        for attr in krate.attrs.iter() {\n+        for attr in &krate.attrs {\n             attr.node.value.hash(&mut state);\n         }\n "}, {"sha": "b8d736ab9ca677fcf9e97fd555357b69c67479f6", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let loan_path = owned_ptr_base_path(loan_path);\n         let cont = self.each_in_scope_loan(scope, |loan| {\n             let mut ret = true;\n-            for restr_path in loan.restricted_paths.iter() {\n+            for restr_path in &loan.restricted_paths {\n                 if **restr_path == *loan_path {\n                     if !op(loan) {\n                         ret = false;\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n         self.each_issued_loan(scope, |issued_loan| {\n-            for &new_loan_index in new_loan_indices.iter() {\n+            for &new_loan_index in &new_loan_indices {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         for (i, &x) in new_loan_indices.iter().enumerate() {\n             let old_loan = &self.all_loans[x];\n-            for &y in new_loan_indices[(i+1) ..].iter() {\n+            for &y in &new_loan_indices[(i+1) ..] {\n                 let new_loan = &self.all_loans[y];\n                 self.report_error_if_loans_conflict(old_loan, new_loan);\n             }\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         }\n \n         let loan2_base_path = owned_ptr_base_path_rc(&loan2.loan_path);\n-        for restr_path in loan1.restricted_paths.iter() {\n+        for restr_path in &loan1.restricted_paths {\n             if *restr_path != loan2_base_path { continue; }\n \n             // If new_loan is something like `x.a`, and old_loan is something like `x.b`, we would"}, {"sha": "6f51ba3118278836f7822b13b9c4673300975b20", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -204,14 +204,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[]));\n \n     // Second, build parents from the moved and assigned.\n-    for m in moved.iter() {\n+    for m in &moved {\n         let mut p = this.path_parent(*m);\n         while p != InvalidMovePathIndex {\n             parents.push(p);\n             p = this.path_parent(p);\n         }\n     }\n-    for a in assigned.iter() {\n+    for a in &assigned {\n         let mut p = this.path_parent(*a);\n         while p != InvalidMovePathIndex {\n             parents.push(p);\n@@ -231,15 +231,15 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[]));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n-    for m in moved.iter() {\n+    for m in &moved {\n         let lp = this.path_loan_path(*m);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n-    for a in assigned.iter() {\n+    for a in &assigned {\n         let lp = this.path_loan_path(*a);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n-    for p in parents.iter() {\n+    for p in &parents {\n         let lp = this.path_loan_path(*p);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n@@ -369,7 +369,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let fields = ty::lookup_struct_fields(tcx, def_id);\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n-                    for f in fields.iter() {\n+                    for f in &fields {\n                         if f.name == ast_name {\n                             continue;\n                         }\n@@ -407,7 +407,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n                     let variant_arg_names = variant_info.arg_names.as_ref().unwrap();\n-                    for variant_arg_ident in variant_arg_names.iter() {\n+                    for variant_arg_ident in variant_arg_names {\n                         if variant_arg_ident.name == ast_name {\n                             continue;\n                         }"}, {"sha": "d9e86bd4b6d68d466c0a8cf147efb16405b0577a", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -67,10 +67,10 @@ pub struct GroupedMoveErrors<'tcx> {\n fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 errors: &Vec<MoveError<'tcx>>) {\n     let grouped_errors = group_errors_with_same_origin(errors);\n-    for error in grouped_errors.iter() {\n+    for error in &grouped_errors {\n         report_cannot_move_out_of(bccx, error.move_from.clone());\n         let mut is_first_note = true;\n-        for move_to in error.move_to_places.iter() {\n+        for move_to in &error.move_to_places {\n             note_move_destination(bccx, move_to.span,\n                                   &move_to.ident, is_first_note);\n             is_first_note = false;\n@@ -81,7 +81,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n                                        -> Vec<GroupedMoveErrors<'tcx>> {\n     let mut grouped_errors = Vec::new();\n-    for error in errors.iter() {\n+    for error in errors {\n         append_to_grouped_errors(&mut grouped_errors, error)\n     }\n     return grouped_errors;\n@@ -95,7 +95,7 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n         } else {\n             Vec::new()\n         };\n-        for ge in grouped_errors.iter_mut() {\n+        for ge in &mut *grouped_errors {\n             if move_from_id == ge.move_from.id && error.move_to.is_some() {\n                 debug!(\"appending move_to to list\");\n                 ge.move_to_places.extend(move_to.into_iter());"}, {"sha": "76c431fa4c58f477bdd3ae971193f36989357da5", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -475,13 +475,13 @@ impl<'tcx> MoveData<'tcx> {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        for assignment in self.path_assignments.borrow().iter() {\n+        for assignment in &*self.path_assignments.borrow() {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n         // Kill all moves related to a variable `x` when\n         // it goes out of scope:\n-        for path in self.paths.borrow().iter() {\n+        for path in &*self.paths.borrow() {\n             match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n@@ -633,11 +633,11 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n \n         let mut ret = None;\n-        for loan_path_index in self.move_data.path_map.borrow().get(&*loan_path).iter() {\n+        if let Some(loan_path_index) = self.move_data.path_map.borrow().get(&*loan_path) {\n             self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let the_move = self.move_data.moves.borrow();\n                 let the_move = (*the_move)[move_index];\n-                if the_move.path == **loan_path_index {\n+                if the_move.path == *loan_path_index {\n                     ret = Some(the_move.kind);\n                     false\n                 } else {\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                     ret = false;\n                 }\n             } else {\n-                for &loan_path_index in opt_loan_path_index.iter() {\n+                if let Some(loan_path_index) = opt_loan_path_index {\n                     let cont = self.move_data.each_base_path(moved_path, |p| {\n                         if p == loan_path_index {\n                             // Scenario 3: some extension of `loan_path`\n@@ -699,7 +699,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                             true\n                         }\n                     });\n-                    if !cont { ret = false; break }\n+                    if !cont { ret = false; }\n                 }\n             }\n             ret"}, {"sha": "8b1b156691af7379ae852699a52e19c51eb9450b", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;\n-        for &variant in self.variants.iter() {\n+        for &variant in &self.variants {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");"}, {"sha": "9b9cc14c4761510dd53634732a23eb4a2a9513ae", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -425,7 +425,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                 diagnostics::plugin::expand_build_diagnostic_array);\n         }\n \n-        for registrar in registrars.into_iter() {\n+        for registrar in registrars {\n             registry.args_hidden = Some(registrar.args);\n             (registrar.fun)(&mut registry);\n         }\n@@ -435,11 +435,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     {\n         let mut ls = sess.lint_store.borrow_mut();\n-        for pass in lint_passes.into_iter() {\n+        for pass in lint_passes {\n             ls.register_pass(Some(sess), true, pass);\n         }\n \n-        for (name, to) in lint_groups.into_iter() {\n+        for (name, to) in lint_groups {\n             ls.register_group(Some(sess), true, name, to);\n         }\n     }\n@@ -761,11 +761,11 @@ fn write_out_deps(sess: &Session,\n                   id: &str) {\n \n     let mut out_filenames = Vec::new();\n-    for output_type in sess.opts.output_types.iter() {\n+    for output_type in &sess.opts.output_types {\n         let file = outputs.path(*output_type);\n         match *output_type {\n             config::OutputTypeExe => {\n-                for output in sess.crate_types.borrow().iter() {\n+                for output in &*sess.crate_types.borrow() {\n                     let p = link::filename_for_input(sess, *output,\n                                                      id, &file);\n                     out_filenames.push(p);\n@@ -801,7 +801,7 @@ fn write_out_deps(sess: &Session,\n                                    .map(|fmap| escape_dep_filename(&fmap.name[]))\n                                    .collect();\n         let mut file = try!(old_io::File::create(&deps_filename));\n-        for path in out_filenames.iter() {\n+        for path in &out_filenames {\n             try!(write!(&mut file as &mut Writer,\n                           \"{}: {}\\n\\n\", path.display(), files.connect(\" \")));\n         }"}, {"sha": "d71e85e6a55c60a918c210e4cbe483d1bbe7c743", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -374,7 +374,7 @@ Available lint options:\n     println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n \n     let print_lints = |&: lints: Vec<&Lint>| {\n-        for lint in lints.into_iter() {\n+        for lint in lints {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n                      padded(&name[]), lint.default_level.as_str(), lint.desc);\n@@ -401,7 +401,7 @@ Available lint options:\n     println!(\"    {}  {}\", padded(\"----\"), \"---------\");\n \n     let print_lint_groups = |&: lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n-        for (name, to) in lints.into_iter() {\n+        for (name, to) in lints {\n             let name = name.chars().map(|x| x.to_lowercase())\n                            .collect::<String>().replace(\"_\", \"-\");\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n@@ -436,7 +436,7 @@ Available lint options:\n \n fn describe_debug_flags() {\n     println!(\"\\nAvailable debug options:\\n\");\n-    for &(name, _, opt_type_desc, desc) in config::DB_OPTIONS.iter() {\n+    for &(name, _, opt_type_desc, desc) in config::DB_OPTIONS {\n         let (width, extra) = match opt_type_desc {\n             Some(..) => (21, \"=val\"),\n             None => (25, \"\")\n@@ -448,7 +448,7 @@ fn describe_debug_flags() {\n \n fn describe_codegen_flags() {\n     println!(\"\\nAvailable codegen options:\\n\");\n-    for &(name, _, opt_type_desc, desc) in config::CG_OPTIONS.iter() {\n+    for &(name, _, opt_type_desc, desc) in config::CG_OPTIONS {\n         let (width, extra) = match opt_type_desc {\n             Some(..) => (21, \"=val\"),\n             None => (25, \"\")\n@@ -543,7 +543,7 @@ fn print_crate_info(sess: &Session,\n     if sess.opts.prints.len() == 0 { return false }\n \n     let attrs = input.map(|input| parse_crate_attrs(sess, input));\n-    for req in sess.opts.prints.iter() {\n+    for req in &sess.opts.prints {\n         match *req {\n             PrintRequest::Sysroot => println!(\"{}\", sess.sysroot().display()),\n             PrintRequest::FileNames |\n@@ -567,7 +567,7 @@ fn print_crate_info(sess: &Session,\n                 let crate_types = driver::collect_crate_types(sess, attrs);\n                 let metadata = driver::collect_crate_metadata(sess, attrs);\n                 *sess.crate_metadata.borrow_mut() = metadata;\n-                for &style in crate_types.iter() {\n+                for &style in &crate_types {\n                     let fname = link::filename_for_input(sess, style,\n                                                          id.as_slice(),\n                                                          &t_outputs.with_extension(\"\"));\n@@ -646,7 +646,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n                             BUG_REPORT_URL),\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n-                for note in xs.iter() {\n+                for note in &xs {\n                     emitter.emit(None, &note[], None, diagnostic::Note)\n                 }\n "}, {"sha": "20bf77190be720b5ede3d834f7c08f411f98f702", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn create_region_hierarchy(&self, rh: &RH) {\n-        for child_rh in rh.sub.iter() {\n+        for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh);\n             self.infcx.tcx.region_maps.record_encl_scope(\n                 CodeExtent::from_node_id(child_rh.id),\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                       names: &[String])\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n-            for item in m.items.iter() {\n+            for item in &m.items {\n                 if item.ident.user_string(this.infcx.tcx) == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }"}, {"sha": "a1532c044e3dcd5fdbd7e772998d89a4f5f741f7", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -262,13 +262,13 @@ impl AttrBuilder {\n     }\n \n     pub fn apply_llfn(&self, llfn: ValueRef) {\n-        for &(idx, ref attr) in self.attrs.iter() {\n+        for &(idx, ref attr) in &self.attrs {\n             attr.apply_llfn(idx as c_uint, llfn);\n         }\n     }\n \n     pub fn apply_callsite(&self, callsite: ValueRef) {\n-        for &(idx, ref attr) in self.attrs.iter() {\n+        for &(idx, ref attr) in &self.attrs {\n             attr.apply_callsite(idx as c_uint, callsite);\n         }\n     }"}, {"sha": "c398ff72f504a351a6326e6b4372a8141993ea0c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -79,7 +79,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // Enum variants are parented to the enum definition itself because\n             // they inherit privacy\n             ast::ItemEnum(ref def, _) => {\n-                for variant in def.variants.iter() {\n+                for variant in &def.variants {\n                     // The parent is considered the enclosing enum because the\n                     // enum will dictate the privacy visibility of this variant\n                     // instead.\n@@ -93,7 +93,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // parent all the methods to the trait to indicate that they're\n             // private.\n             ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n-                for m in methods.iter() {\n+                for m in methods {\n                     match *m {\n                         ast::ProvidedMethod(ref m) => {\n                             self.parents.insert(m.id, item.id);\n@@ -139,7 +139,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n \n         // While we have the id of the struct definition, go ahead and parent\n         // all the fields.\n-        for field in s.fields.iter() {\n+        for field in &s.fields {\n             self.parents.insert(field.node.id, self.curparent);\n         }\n         visit::walk_struct_def(self, s)\n@@ -233,7 +233,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // Enum variants inherit from their parent, so if the enum is\n             // public all variants are public unless they're explicitly priv\n             ast::ItemEnum(ref def, _) if public_first => {\n-                for variant in def.variants.iter() {\n+                for variant in &def.variants {\n                     self.exported_items.insert(variant.node.id);\n                 }\n             }\n@@ -278,7 +278,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 });\n \n                 if public_ty || public_trait {\n-                    for impl_item in impl_items.iter() {\n+                    for impl_item in impl_items {\n                         match *impl_item {\n                             ast::MethodImplItem(ref method) => {\n                                 let meth_public =\n@@ -299,7 +299,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // Default methods on traits are all public so long as the trait\n             // is public\n             ast::ItemTrait(_, _, _, ref methods) if public_first => {\n-                for method in methods.iter() {\n+                for method in methods {\n                     match *method {\n                         ast::ProvidedMethod(ref m) => {\n                             debug!(\"provided {}\", m.id);\n@@ -359,7 +359,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // crate module gets processed as well.\n         if self.prev_exported {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n-            for export in self.export_map[id].iter() {\n+            for export in &self.export_map[id] {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -837,7 +837,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 match vpath.node {\n                     ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n                     ast::ViewPathList(ref prefix, ref list) => {\n-                        for pid in list.iter() {\n+                        for pid in list {\n                             match pid.node {\n                                 ast::PathListIdent { id, name } => {\n                                     debug!(\"privacy - ident item {}\", id);\n@@ -898,15 +898,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             ast::ExprStruct(_, ref fields, _) => {\n                 match ty::expr_ty(self.tcx, expr).sty {\n                     ty::ty_struct(id, _) => {\n-                        for field in (*fields).iter() {\n+                        for field in &(*fields) {\n                             self.check_field(expr.span, id,\n                                              NamedField(field.ident.node));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow()[expr.id].clone() {\n                             def::DefVariant(_, variant_id, _) => {\n-                                for field in fields.iter() {\n+                                for field in fields {\n                                     self.check_field(expr.span, variant_id,\n                                                      NamedField(field.ident.node));\n                                 }\n@@ -971,15 +971,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             ast::PatStruct(_, ref fields, _) => {\n                 match ty::pat_ty(self.tcx, pattern).sty {\n                     ty::ty_struct(id, _) => {\n-                        for field in fields.iter() {\n+                        for field in fields {\n                             self.check_field(pattern.span, id,\n                                              NamedField(field.node.ident));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().get(&pattern.id) {\n                             Some(&def::DefVariant(_, variant_id, _)) => {\n-                                for field in fields.iter() {\n+                                for field in fields {\n                                     self.check_field(pattern.span, variant_id,\n                                                      NamedField(field.node.ident));\n                                 }\n@@ -1091,7 +1091,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 check_inherited(item.span, item.vis,\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         ast::MethodImplItem(ref m) => {\n                             check_inherited(m.span, m.pe_vis(), \"\");\n@@ -1112,7 +1112,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             }\n \n             ast::ItemEnum(ref def, _) => {\n-                for v in def.variants.iter() {\n+                for v in &def.variants {\n                     match v.node.vis {\n                         ast::Public => {\n                             if item.vis == ast::Public {\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             }\n \n             ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods.iter() {\n+                for m in methods {\n                     match *m {\n                         ast::ProvidedMethod(ref m) => {\n                             check_inherited(m.span, m.pe_vis(),\n@@ -1157,7 +1157,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             }\n         }\n         let check_struct = |&: def: &ast::StructDef| {\n-            for f in def.fields.iter() {\n+            for f in &def.fields {\n                match f.node.kind {\n                     ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n                     ast::UnnamedField(..) => {}\n@@ -1167,7 +1167,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n         check_inherited(tcx, item.span, item.vis);\n         match item.node {\n             ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         ast::MethodImplItem(ref m) => {\n                             check_inherited(tcx, m.span, m.pe_vis());\n@@ -1177,20 +1177,20 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ItemForeignMod(ref fm) => {\n-                for i in fm.items.iter() {\n+                for i in &fm.items {\n                     check_inherited(tcx, i.span, i.vis);\n                 }\n             }\n             ast::ItemEnum(ref def, _) => {\n-                for v in def.variants.iter() {\n+                for v in &def.variants {\n                     check_inherited(tcx, v.span, v.node.vis);\n                 }\n             }\n \n             ast::ItemStruct(ref def, _) => check_struct(&**def),\n \n             ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods.iter() {\n+                for m in methods {\n                     match *m {\n                         ast::RequiredMethod(..) => {}\n                         ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n@@ -1302,7 +1302,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     return\n                 }\n \n-                for bound in bounds.iter() {\n+                for bound in &**bounds {\n                     self.check_ty_param_bound(bound)\n                 }\n             }\n@@ -1371,7 +1371,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                     match *trait_ref {\n                         None => {\n-                            for impl_item in impl_items.iter() {\n+                            for impl_item in impl_items {\n                                 match *impl_item {\n                                     ast::MethodImplItem(ref method) => {\n                                         visit::walk_method_helper(self, &**method)\n@@ -1400,7 +1400,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // impl Public<Private> { ... }. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for impl_item in impl_items.iter() {\n+                    for impl_item in impl_items {\n                         match *impl_item {\n                             ast::MethodImplItem(ref method) => {\n                                 if method.pe_explicit_self().node ==\n@@ -1439,15 +1439,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            for bound in ty_param.bounds.iter() {\n+        for ty_param in &*generics.ty_params {\n+            for bound in &*ty_param.bounds {\n                 self.check_ty_param_bound(bound)\n             }\n         }\n-        for predicate in generics.where_clause.predicates.iter() {\n+        for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                    for bound in bound_pred.bounds.iter() {\n+                    for bound in &*bound_pred.bounds {\n                         self.check_ty_param_bound(bound)\n                     }\n                 }"}, {"sha": "a503398d4844fb2fdbbc0132444a3ffc71f21ac3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -223,8 +223,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                              token::get_name(name))[]);\n                     {\n                         let r = child.span_for_namespace(ns);\n-                        for sp in r.iter() {\n-                            self.session.span_note(*sp,\n+                        if let Some(sp) = r {\n+                            self.session.span_note(sp,\n                                  &format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n                                       token::get_name(name))[]);\n@@ -238,7 +238,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // Check each statement.\n-        for statement in block.stmts.iter() {\n+        for statement in &block.stmts {\n             match statement.node {\n                 StmtDecl(ref declaration, _) => {\n                     match declaration.node {\n@@ -338,7 +338,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             }\n                         }\n \n-                        for source_item in source_items.iter() {\n+                        for source_item in source_items {\n                             let (module_path, name) = match source_item.node {\n                                 PathListIdent { name, .. } =>\n                                     (module_path.clone(), name.name),\n@@ -477,7 +477,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 let module = name_bindings.get_module();\n \n-                for variant in (*enum_definition).variants.iter() {\n+                for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(\n                         &**variant,\n                         local_def(item.id),\n@@ -591,7 +591,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 };\n \n                 // For each implementation item...\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         MethodImplItem(ref method) => {\n                             // Add the method to the module.\n@@ -675,7 +675,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let def_id = local_def(item.id);\n \n                 // Add the names of all the items to the trait info.\n-                for trait_item in items.iter() {\n+                for trait_item in items {\n                     let (name, kind) = match *trait_item {\n                         ast::RequiredMethod(_) |\n                         ast::ProvidedMethod(_) => {\n@@ -926,7 +926,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n               let trait_item_def_ids =\n                 csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n-              for trait_item_def_id in trait_item_def_ids.iter() {\n+              for trait_item_def_id in &trait_item_def_ids {\n                   let (trait_item_name, trait_item_kind) =\n                       csearch::get_trait_item_name_and_kind(\n                           &self.session.cstore,\n@@ -1082,7 +1082,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                                 // Add each static method to the module.\n                                 let new_parent = type_module;\n-                                for method_info in methods.iter() {\n+                                for method_info in methods {\n                                     let name = method_info.name;\n                                     debug!(\"(building reduced graph for \\\n                                              external crate) creating \\"}, {"sha": "a239c73c110dbd67e96353ad8efca3f20b6b82b5", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                     }\n \n                     ViewPathList(_, ref list) => {\n-                        for i in list.iter() {\n+                        for i in list {\n                             self.finalize_import(i.node.id(), i.span);\n                         }\n                     }"}, {"sha": "a5fb57eadc41d0901d6d4f77043c8292b5ee9f39", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1031,7 +1031,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.current_module = orig_module;\n \n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n-        for (_, child_node) in module_.children.borrow().iter() {\n+        for (_, child_node) in &*module_.children.borrow() {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -1042,7 +1042,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n+        for (_, child_module) in &*module_.anonymous_children.borrow() {\n             self.resolve_imports_for_module_subtree(child_module.clone());\n         }\n     }\n@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn names_to_string(&self, names: &[Name]) -> String {\n         let mut first = true;\n         let mut result = String::new();\n-        for name in names.iter() {\n+        for name in names {\n             if first {\n                 first = false\n             } else {\n@@ -1596,7 +1596,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Add all resolved imports from the containing module.\n         let import_resolutions = containing_module.import_resolutions.borrow();\n-        for (ident, target_import_resolution) in import_resolutions.iter() {\n+        for (ident, target_import_resolution) in &*import_resolutions {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n                    token::get_name(*ident),\n@@ -1657,7 +1657,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n \n-        for (&name, name_bindings) in containing_module.children.borrow().iter() {\n+        for (&name, name_bindings) in &*containing_module.children.borrow() {\n             self.merge_import_resolution(module_,\n                                          containing_module.clone(),\n                                          import_directive,\n@@ -1667,7 +1667,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Add external module children from the containing module.\n-        for (&name, module) in containing_module.external_module_children.borrow().iter() {\n+        for (&name, module) in &*containing_module.external_module_children.borrow() {\n             let name_bindings =\n                 Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n@@ -2519,7 +2519,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Descend into children and anonymous children.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n-        for (_, child_node) in module_.children.borrow().iter() {\n+        for (_, child_node) in &*module_.children.borrow() {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Continue.\n@@ -2530,7 +2530,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        for (_, module_) in module_.anonymous_children.borrow().iter() {\n+        for (_, module_) in &*module_.anonymous_children.borrow() {\n             self.report_unresolved_imports(module_.clone());\n         }\n     }\n@@ -2609,7 +2609,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n                 let mut def = d;\n-                for rib in ribs.iter() {\n+                for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind => {\n                             // Nothing to do. Continue.\n@@ -2680,7 +2680,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             DlDef(def @ DefTyParam(..)) |\n             DlDef(def @ DefSelfTy(..)) => {\n-                for rib in ribs.iter() {\n+                for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ClosureRibKind(..) => {\n                             // Nothing to do. Continue.\n@@ -2795,8 +2795,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n             ItemEnum(ref enum_def, ref generics) => {\n-                for variant in (*enum_def).variants.iter() {\n-                    for dis_expr in variant.node.disr_expr.iter() {\n+                for variant in &(*enum_def).variants {\n+                    if let Some(ref dis_expr) = variant.node.disr_expr {\n                         // resolve the discriminator expr\n                         // as a constant\n                         self.with_constant_rib(|this| {\n@@ -2863,7 +2863,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.resolve_type_parameter_bounds(item.id, bounds,\n                                                        TraitDerivation);\n \n-                    for trait_item in (*trait_items).iter() {\n+                    for trait_item in &(*trait_items) {\n                         // Create a new rib for the trait_item-specific type\n                         // parameters.\n                         //\n@@ -2885,7 +2885,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 this.resolve_where_clause(&ty_m.generics\n                                                                .where_clause);\n \n-                                for argument in ty_m.decl.inputs.iter() {\n+                                for argument in &ty_m.decl.inputs {\n                                     this.resolve_type(&*argument.ty);\n                                 }\n \n@@ -2929,7 +2929,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ItemForeignMod(ref foreign_module) => {\n                 self.with_scope(Some(name), |this| {\n-                    for foreign_item in foreign_module.items.iter() {\n+                    for foreign_item in &foreign_module.items {\n                         match foreign_item.node {\n                             ForeignItemFn(_, ref generics) => {\n                                 this.with_type_parameter_rib(\n@@ -3075,7 +3075,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n                 Some(declaration) => {\n                     let mut bindings_list = HashMap::new();\n-                    for argument in declaration.inputs.iter() {\n+                    for argument in &declaration.inputs {\n                         this.resolve_pattern(&*argument.pat,\n                                              ArgumentIrrefutableMode,\n                                              &mut bindings_list);\n@@ -3103,14 +3103,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_type_parameters(&mut self,\n                                type_parameters: &OwnedSlice<TyParam>) {\n-        for type_parameter in type_parameters.iter() {\n+        for type_parameter in &**type_parameters {\n             self.resolve_type_parameter(type_parameter);\n         }\n     }\n \n     fn resolve_type_parameter(&mut self,\n                               type_parameter: &TyParam) {\n-        for bound in type_parameter.bounds.iter() {\n+        for bound in &*type_parameter.bounds {\n             self.resolve_type_parameter_bound(type_parameter.id, bound,\n                                               TraitBoundingTypeParameter);\n         }\n@@ -3124,7 +3124,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      id: NodeId,\n                                      type_parameter_bounds: &OwnedSlice<TyParamBound>,\n                                      reference_type: TraitReferenceType) {\n-        for type_parameter_bound in type_parameter_bounds.iter() {\n+        for type_parameter_bound in &**type_parameter_bounds {\n             self.resolve_type_parameter_bound(id, type_parameter_bound,\n                                               reference_type);\n         }\n@@ -3193,12 +3193,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_where_clause(&mut self, where_clause: &ast::WhereClause) {\n-        for predicate in where_clause.predicates.iter() {\n+        for predicate in &where_clause.predicates {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n                     self.resolve_type(&*bound_pred.bounded_ty);\n \n-                    for bound in bound_pred.bounds.iter() {\n+                    for bound in &*bound_pred.bounds {\n                         self.resolve_type_parameter_bound(bound_pred.bounded_ty.id, bound,\n                                                           TraitBoundingTypeParameter);\n                     }\n@@ -3236,7 +3236,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             this.resolve_where_clause(&generics.where_clause);\n \n             // Resolve fields.\n-            for field in fields.iter() {\n+            for field in fields {\n                 this.resolve_type(&*field.node.ty);\n             }\n         });\n@@ -3320,7 +3320,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 this.resolve_type(self_type);\n \n                 this.with_current_self_type(self_type, |this| {\n-                    for impl_item in impl_items.iter() {\n+                    for impl_item in impl_items {\n                         match *impl_item {\n                             MethodImplItem(ref method) => {\n                                 // If this is a trait impl, ensure the method\n@@ -3375,7 +3375,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn check_trait_item(&self, name: Name, span: Span) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n-        for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n+        if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if self.trait_item_map.get(&(name, did)).is_none() {\n                 let path_str = self.path_names_to_string(&trait_ref.path);\n                 self.resolve_error(span,\n@@ -3442,7 +3442,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(&**p);\n \n-            for (&key, &binding_0) in map_0.iter() {\n+            for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                   None => {\n                     self.resolve_error(\n@@ -3465,7 +3465,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            for (&key, &binding) in map_i.iter() {\n+            for (&key, &binding) in &map_i {\n                 if !map_0.contains_key(&key) {\n                     self.resolve_error(\n                         binding.span,\n@@ -3482,7 +3482,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n         let mut bindings_list = HashMap::new();\n-        for pattern in arm.pats.iter() {\n+        for pattern in &arm.pats {\n             self.resolve_pattern(&**pattern, RefutableMode, &mut bindings_list);\n         }\n \n@@ -3513,7 +3513,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Check for imports appearing after non-item statements.\n         let mut found_non_item = false;\n-        for statement in block.stmts.iter() {\n+        for statement in &block.stmts {\n             if let ast::StmtDecl(ref declaration, _) = statement.node {\n                 if let ast::DeclItem(ref i) = declaration.node {\n                     match i.node {\n@@ -3607,10 +3607,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             TyQPath(ref qpath) => {\n                 self.resolve_type(&*qpath.self_type);\n                 self.resolve_trait_reference(ty.id, &*qpath.trait_ref, TraitQPath);\n-                for ty in qpath.item_path.parameters.types().into_iter() {\n+                for ty in qpath.item_path.parameters.types() {\n                     self.resolve_type(&**ty);\n                 }\n-                for binding in qpath.item_path.parameters.bindings().into_iter() {\n+                for binding in qpath.item_path.parameters.bindings() {\n                     self.resolve_type(&*binding.ty);\n                 }\n             }\n@@ -4365,7 +4365,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut values: Vec<uint> = Vec::new();\n \n         for rib in this.value_ribs.iter().rev() {\n-            for (&k, _) in rib.bindings.iter() {\n+            for (&k, _) in &rib.bindings {\n                 maybes.push(token::get_name(k));\n                 values.push(uint::MAX);\n             }\n@@ -4640,7 +4640,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             build_reduced_graph::populate_module_if_necessary(self, &search_module);\n \n             {\n-                for (_, child_names) in search_module.children.borrow().iter() {\n+                for (_, child_names) in &*search_module.children.borrow() {\n                     let def = match child_names.def_for_namespace(TypeNS) {\n                         Some(def) => def,\n                         None => continue\n@@ -4656,7 +4656,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             // Look for imports.\n-            for (_, import) in search_module.import_resolutions.borrow().iter() {\n+            for (_, import) in &*search_module.import_resolutions.borrow() {\n                 let target = match import.target_for_namespace(TypeNS) {\n                     None => continue,\n                     Some(target) => target,\n@@ -4766,13 +4766,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"Children:\");\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n-        for (&name, _) in module_.children.borrow().iter() {\n+        for (&name, _) in &*module_.children.borrow() {\n             debug!(\"* {}\", token::get_name(name));\n         }\n \n         debug!(\"Import resolutions:\");\n         let import_resolutions = module_.import_resolutions.borrow();\n-        for (&name, import_resolution) in import_resolutions.iter() {\n+        for (&name, import_resolution) in &*import_resolutions {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = \"\".to_string(); }"}, {"sha": "5d025f40d32398490597b23e1be838c23a5d2e7a", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         self.record_exports_for_module(&*module_);\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n \n-        for (_, child_name_bindings) in module_.children.borrow().iter() {\n+        for (_, child_name_bindings) in &*module_.children.borrow() {\n             match child_name_bindings.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -91,7 +91,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n             }\n         }\n \n-        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n+        for (_, child_module) in &*module_.anonymous_children.borrow() {\n             self.record_exports_for_module_subtree(child_module.clone());\n         }\n     }\n@@ -133,12 +133,12 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n     fn add_exports_for_module(&mut self,\n                               exports: &mut Vec<Export>,\n                               module_: &Module) {\n-        for (name, importresolution) in module_.import_resolutions.borrow().iter() {\n+        for (name, importresolution) in &*module_.import_resolutions.borrow() {\n             if !importresolution.is_public {\n                 continue\n             }\n             let xs = [TypeNS, ValueNS];\n-            for &ns in xs.iter() {\n+            for &ns in &xs {\n                 match importresolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\","}, {"sha": "c94ec112ac2f59643a50f12fc631716e95d0420c", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -194,7 +194,7 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     symbol_hasher.input_str(&link_meta.crate_name[]);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n-    for meta in tcx.sess.crate_metadata.borrow().iter() {\n+    for meta in &*tcx.sess.crate_metadata.borrow() {\n         symbol_hasher.input_str(&meta[]);\n     }\n     symbol_hasher.input_str(\"-\");\n@@ -265,7 +265,7 @@ pub fn sanitize(s: &str) -> String {\n     return result;\n }\n \n-pub fn mangle<PI: Iterator<Item=PathElem>>(mut path: PI,\n+pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n                                       hash: Option<&str>) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n@@ -370,7 +370,7 @@ pub fn link_binary(sess: &Session,\n                    outputs: &OutputFilenames,\n                    crate_name: &str) -> Vec<Path> {\n     let mut out_filenames = Vec::new();\n-    for &crate_type in sess.crate_types.borrow().iter() {\n+    for &crate_type in &*sess.crate_types.borrow() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(&format!(\"invalid output type `{:?}` for target os `{}`\",\n                              crate_type, sess.opts.target_triple)[]);\n@@ -535,7 +535,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     let mut ab = ArchiveBuilder::create(config);\n     ab.add_file(obj_filename).unwrap();\n \n-    for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n+    for &(ref l, kind) in &*sess.cstore.get_used_libraries().borrow() {\n         match kind {\n             cstore::NativeStatic => {\n                 ab.add_native_library(&l[]).unwrap();\n@@ -721,7 +721,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     let mut all_native_libs = vec![];\n \n-    for &(cnum, ref path) in crates.iter() {\n+    for &(cnum, ref path) in &crates {\n         let ref name = sess.cstore.get_crate_data(cnum).name;\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n@@ -746,7 +746,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n                   and so may need to be preserved\");\n     }\n \n-    for &(kind, ref lib) in all_native_libs.iter() {\n+    for &(kind, ref lib) in &all_native_libs {\n         let name = match kind {\n             cstore::NativeStatic => \"static library\",\n             cstore::NativeUnknown => \"library\",\n@@ -1055,10 +1055,10 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     let libs = sess.cstore.get_used_libraries();\n     let libs = libs.borrow();\n \n-    let mut staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n+    let staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n         if kind == cstore::NativeStatic {Some(l)} else {None}\n     });\n-    let mut others = libs.iter().filter(|&&(_, kind)| {\n+    let others = libs.iter().filter(|&&(_, kind)| {\n         kind != cstore::NativeStatic\n     });\n \n@@ -1133,7 +1133,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // crates.\n     let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n \n-    for &(cnum, _) in deps.iter() {\n+    for &(cnum, _) in &deps {\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n@@ -1275,9 +1275,9 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n     // we're just getting an ordering of crate numbers, we're not worried about\n     // the paths.\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n-    for (cnum, _) in crates.into_iter() {\n+    for (cnum, _) in crates {\n         let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n-        for &(kind, ref lib) in libs.iter() {\n+        for &(kind, ref lib) in &libs {\n             match kind {\n                 cstore::NativeUnknown => {\n                     cmd.arg(format!(\"-l{}\", *lib));"}, {"sha": "38c68bc9fa426005e6add8fc17fd3a2f29ade027", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -34,7 +34,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n \n     // Make sure we actually can run LTO\n-    for crate_type in sess.crate_types.borrow().iter() {\n+    for crate_type in &*sess.crate_types.borrow() {\n         match *crate_type {\n             config::CrateTypeExecutable | config::CrateTypeStaticlib => {}\n             _ => {\n@@ -48,7 +48,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n-    for (cnum, path) in crates.into_iter() {\n+    for (cnum, path) in crates {\n         let name = sess.cstore.get_crate_data(cnum).name.clone();\n         let path = match path {\n             Some(p) => p,"}, {"sha": "5312d2ca1ddeee3d40675c631a80262e4b82599e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -100,7 +100,7 @@ impl SharedEmitter {\n \n     fn dump(&mut self, handler: &Handler) {\n         let mut buffer = self.buffer.lock().unwrap();\n-        for diag in buffer.iter() {\n+        for diag in &*buffer {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n@@ -452,7 +452,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                      config.no_builtins);\n             }\n \n-            for pass in config.passes.iter() {\n+            for pass in &config.passes {\n                 let pass = CString::from_slice(pass.as_bytes());\n                 if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n                     cgcx.handler.warn(format!(\"unknown pass {:?}, ignoring\",\n@@ -597,7 +597,7 @@ pub fn run_passes(sess: &Session,\n         modules_config.emit_bc = true;\n     }\n \n-    for output_type in output_types.iter() {\n+    for output_type in output_types {\n         match *output_type {\n             config::OutputTypeBitcode => { modules_config.emit_bc = true; },\n             config::OutputTypeLlvmAssembly => { modules_config.emit_ir = true; },\n@@ -761,7 +761,7 @@ pub fn run_passes(sess: &Session,\n     // Otherwise, we produced it only as a temporary output, and will need\n     // to get rid of it.\n     let mut user_wants_bitcode = false;\n-    for output_type in output_types.iter() {\n+    for output_type in output_types {\n         match *output_type {\n             config::OutputTypeBitcode => {\n                 user_wants_bitcode = true;\n@@ -941,7 +941,7 @@ fn run_work_multithreaded(sess: &Session,\n     }\n \n     let mut panicked = false;\n-    for rx in futures.into_iter() {\n+    for rx in futures {\n         match rx.recv() {\n             Ok(()) => {},\n             Err(_) => {\n@@ -1015,7 +1015,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         // FIXME #21627 disable faulty FastISel on AArch64 (even for -O0)\n         if sess.target.target.arch.as_slice() == \"aarch64\" { add(\"-fast-isel=0\"); }\n \n-        for arg in sess.opts.cg.llvm_args.iter() {\n+        for arg in &sess.opts.cg.llvm_args {\n             add(&(*arg)[]);\n         }\n     }"}, {"sha": "94a1d4dd5b2a42f89546bd1e2d4412fe92daefc4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -23,8 +23,6 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(collections)]"}, {"sha": "7758039e40a418ddbf2a522ee0c55ad68f53f75a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -113,7 +113,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             error!(\"Mis-calculated spans for path '{}'. \\\n                     Found {} spans, expected {}. Found spans:\",\n                    path_to_string(path), spans.len(), path.segments.len());\n-            for s in spans.iter() {\n+            for s in &spans {\n                 let loc = self.sess.codemap().lookup_char_pos(s.lo);\n                 error!(\"    '{}' in {}, line {}\",\n                        self.span.snippet(*s), loc.file.name, loc.line);\n@@ -204,7 +204,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return;\n         }\n         let sub_paths = &sub_paths[..len-2];\n-        for &(ref span, ref qualname) in sub_paths.iter() {\n+        for &(ref span, ref qualname) in sub_paths {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      &qualname[],\n@@ -264,13 +264,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n-        for arg in formals.iter() {\n+        for arg in formals {\n             assert!(self.collected_paths.len() == 0 && !self.collecting);\n             self.collecting = true;\n             self.visit_pat(&*arg.pat);\n             self.collecting = false;\n             let span_utils = self.span.clone();\n-            for &(id, ref p, _, _) in self.collected_paths.iter() {\n+            for &(id, ref p, _, _) in &self.collected_paths {\n                 let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n                     (*self.analysis.ty_cx.node_types.borrow())[id]);\n                 // get the span only for the name of the variable (I hope the path is only ever a\n@@ -389,7 +389,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.process_formals(&method.pe_fn_decl().inputs, qualname);\n \n         // walk arg and return types\n-        for arg in method.pe_fn_decl().inputs.iter() {\n+        for arg in &method.pe_fn_decl().inputs {\n             self.visit_ty(&*arg.ty);\n         }\n \n@@ -493,7 +493,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.process_formals(&decl.inputs, &qualname[]);\n \n         // walk arg and return types\n-        for arg in decl.inputs.iter() {\n+        for arg in &decl.inputs {\n             self.visit_ty(&*arg.ty);\n         }\n \n@@ -580,7 +580,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             &val[]);\n \n         // fields\n-        for field in def.fields.iter() {\n+        for field in &def.fields {\n             self.process_struct_field_def(field, &qualname[], item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n@@ -605,7 +605,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                        &format!(\"Could not find subspan for enum {}\",\n                                                enum_name)[]),\n         }\n-        for variant in enum_definition.variants.iter() {\n+        for variant in &enum_definition.variants {\n             let name = get_ident(variant.node.name);\n             let name = name.get();\n             let mut qualname = enum_name.clone();\n@@ -623,7 +623,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                &enum_name[],\n                                                &val[],\n                                                item.id);\n-                    for arg in args.iter() {\n+                    for arg in args {\n                         self.visit_ty(&*arg.ty);\n                     }\n                 }\n@@ -642,7 +642,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         &val[],\n                         item.id);\n \n-                    for field in struct_def.fields.iter() {\n+                    for field in &struct_def.fields {\n                         self.process_struct_field_def(field, qualname.as_slice(), variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n@@ -701,7 +701,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n-        for impl_item in impl_items.iter() {\n+        for impl_item in impl_items {\n             match *impl_item {\n                 ast::MethodImplItem(ref method) => {\n                     visit::walk_method_helper(self, &**method)\n@@ -729,7 +729,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                            &val[]);\n \n         // super-traits\n-        for super_bound in trait_refs.iter() {\n+        for super_bound in &**trait_refs {\n             let trait_ref = match *super_bound {\n                 ast::TraitTyParamBound(ref trait_ref, _) => {\n                     trait_ref\n@@ -759,7 +759,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // walk generics and methods\n         self.process_generic_params(generics, item.span, &qualname[], item.id);\n-        for method in methods.iter() {\n+        for method in methods {\n             self.visit_trait_item(method)\n         }\n     }\n@@ -912,11 +912,11 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             _ => None\n         };\n \n-        for field in fields.iter() {\n+        for field in fields {\n             match struct_def {\n                 Some(struct_def) => {\n                     let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for f in fields.iter() {\n+                    for f in &fields {\n                         if generated_code(field.ident.span) {\n                             continue;\n                         }\n@@ -1010,10 +1010,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                    self.span.snippet(p.span))[]);\n                     }\n                 };\n-                for &Spanned { node: ref field, span } in fields.iter() {\n+                for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n                     let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for f in fields.iter() {\n+                    for f in fields {\n                         if f.name == field.ident.name {\n                             self.fmt.ref_str(recorder::VarRef,\n                                              span,\n@@ -1104,7 +1104,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = &self.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n-                            for n in glob_map[item.id].iter() {\n+                            for n in &glob_map[item.id] {\n                                 if name_string.len() > 0 {\n                                     name_string.push_str(\", \");\n                                 }\n@@ -1122,7 +1122,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         self.write_sub_paths(path, true);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n-                        for plid in list.iter() {\n+                        for plid in list {\n                             match plid.node {\n                                 ast::PathListIdent { id, .. } => {\n                                     match self.lookup_type_ref(id) {\n@@ -1208,8 +1208,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for param in generics.ty_params.iter() {\n-            for bound in param.bounds.iter() {\n+        for param in &*generics.ty_params {\n+            for bound in &*param.bounds {\n                 if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n                     self.process_trait_ref(&trait_ref.trait_ref);\n                 }\n@@ -1270,7 +1270,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                          scope_id);\n \n                 // walk arg and return types\n-                for arg in method_type.decl.inputs.iter() {\n+                for arg in &method_type.decl.inputs {\n                     self.visit_ty(&*arg.ty);\n                 }\n \n@@ -1349,7 +1349,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 match *ty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n-                        for f in fields.iter() {\n+                        for f in &fields {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span.span_for_last_ident(ex.span);\n                                 self.fmt.ref_str(recorder::VarRef,\n@@ -1404,7 +1404,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.process_formals(&decl.inputs, &id[]);\n \n                 // walk arg and return types\n-                for arg in decl.inputs.iter() {\n+                for arg in &decl.inputs {\n                     self.visit_ty(&*arg.ty);\n                 }\n \n@@ -1435,15 +1435,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     fn visit_arm(&mut self, arm: &ast::Arm) {\n         assert!(self.collected_paths.len() == 0 && !self.collecting);\n         self.collecting = true;\n-        for pattern in arm.pats.iter() {\n+        for pattern in &arm.pats {\n             // collect paths from the arm's patterns\n             self.visit_pat(&**pattern);\n         }\n \n         // This is to get around borrow checking, because we need mut self to call process_path.\n         let mut paths_to_process = vec![];\n         // process collected paths\n-        for &(id, ref p, ref immut, ref_kind) in self.collected_paths.iter() {\n+        for &(id, ref p, ref immut, ref_kind) in &self.collected_paths {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n@@ -1477,7 +1477,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                             *def)\n             }\n         }\n-        for &(id, ref path, ref_kind) in paths_to_process.iter() {\n+        for &(id, ref path, ref_kind) in &paths_to_process {\n             self.process_path(id, path.span, path, ref_kind);\n         }\n         self.collecting = false;\n@@ -1508,7 +1508,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n         let value = self.span.snippet(l.span);\n \n-        for &(id, ref p, ref immut, _) in self.collected_paths.iter() {\n+        for &(id, ref p, ref immut, _) in &self.collected_paths {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n             let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id]);"}, {"sha": "52fe8797592b5b72c8bfedc006fdfb8a07ef21ac", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -366,7 +366,7 @@ impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n }\n \n fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n-    for br in m.iter() {\n+    for br in m {\n         match br.pats[col].node {\n             ast::PatIdent(_, _, Some(_)) => return true,\n             _ => ()\n@@ -561,7 +561,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n \n     let mut found: Vec<Opt> = vec![];\n-    for br in m.iter() {\n+    for br in m {\n         let cur = br.pats[col];\n         let opt = match cur.node {\n             ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n@@ -827,7 +827,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                bindings_map: &BindingsMap<'tcx>,\n                                cs: Option<cleanup::ScopeId>)\n                                -> Block<'blk, 'tcx> {\n-    for (&ident, &binding_info) in bindings_map.iter() {\n+    for (&ident, &binding_info) in bindings_map {\n         let llval = match binding_info.trmode {\n             // By value mut binding for a copy type: load from the ptr\n             // into the matched value and copy to our alloca\n@@ -883,15 +883,15 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n     let val = val.to_llbool(bcx);\n \n-    for (_, &binding_info) in data.bindings_map.iter() {\n+    for (_, &binding_info) in &data.bindings_map {\n         if let TrByCopy(llbinding) = binding_info.trmode {\n             call_lifetime_end(bcx, llbinding);\n         }\n     }\n \n     with_cond(bcx, Not(bcx, val, guard_expr.debug_loc()), |bcx| {\n         // Guard does not match: remove all bindings from the lllocals table\n-        for (_, &binding_info) in data.bindings_map.iter() {\n+        for (_, &binding_info) in &data.bindings_map {\n             call_lifetime_end(bcx, binding_info.llmatch);\n             bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n         }\n@@ -949,7 +949,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         None => {\n             let data = &m[0].data;\n-            for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n+            for &(ref ident, ref value_ptr) in &m[0].bound_ptrs {\n                 let llmatch = data.bindings_map[*ident].llmatch;\n                 call_lifetime_start(bcx, llmatch);\n                 Store(bcx, *value_ptr, llmatch);\n@@ -1055,7 +1055,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             Variant(_, ref repr, _) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n                 kind = the_kind;\n-                for &tval in val_opt.iter() { test_val = tval; }\n+                if let Some(tval) = val_opt { test_val = tval; }\n             }\n             SliceLengthEqual(_) | SliceLengthGreaterOrEqual(_, _) => {\n                 let (_, len) = tvec::get_base_and_len(bcx, val, left_ty);\n@@ -1064,7 +1064,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n     }\n-    for o in opts.iter() {\n+    for o in &opts {\n         match *o {\n             ConstantRange(_, _) => { kind = Compare; break },\n             SliceLengthGreaterOrEqual(_, _) => { kind = CompareSliceLength; break },\n@@ -1410,7 +1410,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     compile_submatch(bcx, &matches[], &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n-    for arm_data in arm_datas.iter() {\n+    for arm_data in &arm_datas {\n         let mut bcx = arm_data.bodycx;\n \n         // insert bindings into the lllocals map and add cleanups\n@@ -1623,7 +1623,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     });\n             }\n \n-            for inner_pat in inner.iter() {\n+            if let Some(ref inner_pat) = *inner {\n                 bcx = bind_irrefutable_pat(bcx, &**inner_pat, val, cleanup_scope);\n             }\n         }\n@@ -1639,7 +1639,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     &*repr,\n                                                     vinfo.disr_val,\n                                                     val);\n-                    for sub_pat in sub_pats.iter() {\n+                    if let Some(ref sub_pat) = *sub_pats {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(bcx, &*sub_pat[i],\n                                                        argval, cleanup_scope);\n@@ -1673,7 +1673,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n-                for f in fields.iter() {\n+                for f in fields {\n                     let ix = ty::field_idx_strict(tcx, f.node.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);"}, {"sha": "b99622ce911d2f2b6ee0f393874335e78eee358d", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -285,7 +285,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // alignment of the type.\n             let (_, align) = union_size_and_align(fields.as_slice());\n             let mut use_align = true;\n-            for st in fields.iter() {\n+            for st in &fields {\n                 // Get the first non-zero-sized field\n                 let field = st.fields.iter().skip(1).filter(|ty| {\n                     let t = type_of::sizing_type_of(cx, **ty);\n@@ -519,7 +519,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             cx.tcx().sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n     }\n-    for &ity in attempts.iter() {\n+    for &ity in attempts {\n         if bounds_usable(cx, ity, bounds) {\n             return ity;\n         }\n@@ -563,7 +563,7 @@ fn ensure_struct_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                  packed: bool,\n                                                  scapegoat: Ty<'tcx>) {\n     let mut offset = 0;\n-    for &llty in fields.iter() {\n+    for &llty in fields {\n         // Invariant: offset < ccx.obj_size_bound() <= 1<<61\n         if !packed {\n             let type_align = machine::llalign_of_min(ccx, llty);\n@@ -1097,7 +1097,7 @@ fn compute_struct_field_offsets<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut offsets = vec!();\n \n     let mut offset = 0;\n-    for &ty in st.fields.iter() {\n+    for &ty in &st.fields {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         if !st.packed {\n             let type_align = type_of::align_of(ccx, ty);"}, {"sha": "9e561fc883bb043366e5c7de7198d9863b5e3323", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -350,7 +350,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        for attr in ty::get_attrs(ccx.tcx(), did).iter() {\n+        for attr in &*ty::get_attrs(ccx.tcx(), did) {\n             if attr.check_name(\"thread_local\") {\n                 llvm::set_thread_local(c, true);\n             }\n@@ -442,7 +442,7 @@ pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: Val\n         InlineNone   => { /* fallthrough */ }\n     }\n \n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         let mut used = true;\n         match attr.name().get() {\n             \"no_stack_check\" => unset_split_stack(llfn),\n@@ -765,7 +765,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                         n_variants);\n                   let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n \n-                  for variant in (*variants).iter() {\n+                  for variant in &(*variants) {\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               &format!(\"enum-iter-variant-{}\",\n@@ -970,7 +970,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if need_invoke(bcx) {\n         debug!(\"invoking {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n-        for &llarg in llargs.iter() {\n+        for &llarg in llargs {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n         let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n@@ -986,7 +986,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return (llresult, normal_bcx);\n     } else {\n         debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n-        for &llarg in llargs.iter() {\n+        for &llarg in llargs {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n \n@@ -1830,7 +1830,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n         }\n     };\n-    for monomorphized_arg_type in monomorphized_arg_types.iter() {\n+    for monomorphized_arg_type in &monomorphized_arg_types {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\",\n                ty_to_string(ccx.tcx(), *monomorphized_arg_type));\n     }\n@@ -1908,7 +1908,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // This somewhat improves single-stepping experience in debugger.\n     unsafe {\n         let llreturn = fcx.llreturn.get();\n-        for &llreturn in llreturn.iter() {\n+        if let Some(llreturn) = llreturn {\n             llvm::LLVMMoveBasicBlockAfter(llreturn, bcx.llbb);\n         }\n     }\n@@ -2113,7 +2113,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     let avar = adt::represent_type(ccx, ty);\n     match *avar {\n         adt::General(_, ref variants, _) => {\n-            for var in variants.iter() {\n+            for var in variants {\n                 let mut size = 0;\n                 for field in var.fields.iter().skip(1) {\n                     // skip the discriminant\n@@ -2386,7 +2386,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n // and control visibility.\n pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n-    for item in m.items.iter() {\n+    for item in &m.items {\n         trans_item(ccx, &**item);\n     }\n }\n@@ -3165,7 +3165,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         stats.fn_stats.borrow_mut().sort_by(|&(_, insns_a), &(_, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n-        for tuple in stats.fn_stats.borrow().iter() {\n+        for tuple in &*stats.fn_stats.borrow() {\n             match *tuple {\n                 (ref name, insns) => {\n                     println!(\"{} insns, {}\", insns, *name);\n@@ -3174,7 +3174,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         }\n     }\n     if shared_ccx.sess().count_llvm_insns() {\n-        for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n+        for (k, v) in &*shared_ccx.stats().llvm_insns.borrow() {\n             println!(\"{:7} {}\", *v, *k);\n         }\n     }"}, {"sha": "5d1e6d2c9e84400a54e52c8ae6ac96351ce0acde", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -150,7 +150,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let mut arg_tys = Vec::new();\n-    for &aty in atys.iter() {\n+    for &aty in atys {\n         let ty = classify_arg_ty(ccx, aty);\n         arg_tys.push(ty);\n     }"}, {"sha": "50014230df67b2f88a5207f42f9901d4d2f24739", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -186,7 +186,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     };\n \n     let mut arg_tys = Vec::new();\n-    for &aty in atys.iter() {\n+    for &aty in atys {\n         let ty = classify_arg_ty(ccx, aty, align_fn);\n         arg_tys.push(ty);\n     }"}, {"sha": "fecd1a9013bb2c5bb9f7ea8cb1b278ad951bcccb", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -176,7 +176,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     let mut arg_tys = Vec::new();\n     let mut offset = if sret { 4 } else { 0 };\n \n-    for aty in atys.iter() {\n+    for aty in atys {\n         let ty = classify_arg_ty(ccx, *aty, &mut offset);\n         arg_tys.push(ty);\n     };"}, {"sha": "9583158a0e243971d028b6e0edef7b4a223a9409", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -171,7 +171,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     let mut arg_tys = Vec::new();\n     let mut offset = if sret { 4 } else { 0 };\n \n-    for aty in atys.iter() {\n+    for aty in atys {\n         let ty = classify_arg_ty(ccx, *aty, &mut offset);\n         arg_tys.push(ty);\n     };"}, {"sha": "028d20f308474eea3eed27a71d5059a5edf5a86f", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -60,7 +60,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n-    for &t in atys.iter() {\n+    for &t in atys {\n         let ty = match t.kind() {\n             Struct => {\n                 let size = llsize_of_alloc(ccx, t);"}, {"sha": "2484e74e19349a9f2aa30398d255ba1432a09fa3", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -151,7 +151,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     fn all_mem(cls: &mut [RegClass]) {\n-        for elt in cls.iter_mut() {\n+        for elt in cls {\n             *elt = Memory;\n         }\n     }\n@@ -195,7 +195,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                        off: uint,\n                        packed: bool) {\n         let mut field_off = off;\n-        for ty in tys.iter() {\n+        for ty in tys {\n             if !packed {\n                 field_off = align(field_off, *ty);\n             }\n@@ -333,7 +333,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1;\n-        for c in cls.iter() {\n+        for c in cls {\n             if *c != SSEUp {\n                 break;\n             }\n@@ -413,7 +413,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     }\n \n     let mut arg_tys = Vec::new();\n-    for t in atys.iter() {\n+    for t in atys {\n         let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n     }"}, {"sha": "9b34c3bf26200a7585b52779c3502ca7b5b72c6a", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -38,7 +38,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n-    for &t in atys.iter() {\n+    for &t in atys {\n         let ty = match t.kind() {\n             Struct => {\n                 match llsize_of_alloc(ccx, t) {"}, {"sha": "5f383d54a68ca5d355fb45fc49e90335dd245dfb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1045,7 +1045,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             }));\n \n             assert_eq!(arg_tys.len(), 1 + rhs.len());\n-            for (rhs, rhs_id) in rhs.into_iter() {\n+            for (rhs, rhs_id) in rhs {\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_datum(bcx, arg_tys[1], rhs,\n                                     arg_cleanup_scope,"}, {"sha": "ac76b52598d15c6e8917093c012173ed38c0e3a4", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -72,7 +72,7 @@ impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n             AstScopeKind(nid) => write!(f, \"AstScopeKind({})\", nid),\n             LoopScopeKind(nid, ref blks) => {\n                 try!(write!(f, \"LoopScopeKind({}, [\", nid));\n-                for blk in blks.iter() {\n+                for blk in blks {\n                     try!(write!(f, \"{:p}, \", blk));\n                 }\n                 write!(f, \"])\")"}, {"sha": "b65d50095b3f09c0397ff10757d884a5d978dd42", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -515,7 +515,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                        -> Block<'a, 'tcx> {\n         let out = self.new_id_block(\"join\", id);\n         let mut reachable = false;\n-        for bcx in in_cxs.iter() {\n+        for bcx in in_cxs {\n             if !bcx.unreachable.get() {\n                 build::Br(*bcx, out.llbb, DebugLoc::None);\n                 reachable = true;"}, {"sha": "651058a567485e8638d8d84f676631404bf05fea", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -96,7 +96,7 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(), b.id, b.span, true);\n     fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n \n-    for s in b.stmts.iter() {\n+    for s in &b.stmts {\n         bcx = trans_stmt(bcx, &**s);\n     }\n "}, {"sha": "66bb299273d9f86aa7aa4861f7468f3eddf783b0", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -375,7 +375,7 @@ impl<'tcx> TypeMap<'tcx> {\n             },\n             ty::ty_tup(ref component_types) => {\n                 unique_type_id.push_str(\"tuple \");\n-                for &component_type in component_types.iter() {\n+                for &component_type in component_types {\n                     let component_type_id =\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n@@ -447,7 +447,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n \n-                for &parameter_type in sig.inputs.iter() {\n+                for &parameter_type in &sig.inputs {\n                     let parameter_type_id =\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n@@ -533,7 +533,7 @@ impl<'tcx> TypeMap<'tcx> {\n             if tps.len() > 0 {\n                 output.push('<');\n \n-                for &type_parameter in tps.iter() {\n+                for &type_parameter in tps {\n                     let param_type_id =\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n@@ -563,7 +563,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n         let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n \n-        for &parameter_type in sig.inputs.iter() {\n+        for &parameter_type in &sig.inputs {\n             let parameter_type_id =\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n@@ -1440,7 +1440,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n \n         // Arguments types\n-        for arg in fn_decl.inputs.iter() {\n+        for arg in &fn_decl.inputs {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n             let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n             let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n@@ -2037,7 +2037,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // The `Ty` values returned by `ty::struct_fields` can still contain\n     // `ty_projection` variants, so normalize those away.\n-    for field in fields.iter_mut() {\n+    for field in &mut fields {\n         field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n     }\n \n@@ -2825,7 +2825,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     });\n \n     // regular arguments\n-    for &argument_type in signature.inputs.iter() {\n+    for &argument_type in &signature.inputs {\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n@@ -3215,7 +3215,7 @@ fn create_scope_map(cx: &CrateContext,\n \n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n-    for arg in args.iter() {\n+    for arg in args {\n         pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                ident: Some(path1.node) });\n@@ -3281,7 +3281,7 @@ fn create_scope_map(cx: &CrateContext,\n         scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n \n         // The interesting things here are statements and the concluding expression.\n-        for statement in block.stmts.iter() {\n+        for statement in &block.stmts {\n             scope_map.insert(ast_util::stmt_id(&**statement),\n                              scope_stack.last().unwrap().scope_metadata);\n \n@@ -3295,7 +3295,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n         }\n \n-        for exp in block.expr.iter() {\n+        if let Some(ref exp) = block.expr {\n             walk_expr(cx, &**exp, scope_stack, scope_map);\n         }\n     }\n@@ -3310,7 +3310,7 @@ fn create_scope_map(cx: &CrateContext,\n \n                 walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n \n-                for exp in local.init.iter() {\n+                if let Some(ref exp) = local.init {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }\n@@ -3396,7 +3396,7 @@ fn create_scope_map(cx: &CrateContext,\n \n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for sub_pat in sub_pat_opt.iter() {\n+                if let Some(ref sub_pat) = *sub_pat_opt {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n@@ -3408,8 +3408,8 @@ fn create_scope_map(cx: &CrateContext,\n             ast::PatEnum(_, ref sub_pats_opt) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for sub_pats in sub_pats_opt.iter() {\n-                    for p in sub_pats.iter() {\n+                if let Some(ref sub_pats) = *sub_pats_opt {\n+                    for p in sub_pats {\n                         walk_pattern(cx, &**p, scope_stack, scope_map);\n                     }\n                 }\n@@ -3429,7 +3429,7 @@ fn create_scope_map(cx: &CrateContext,\n             ast::PatTup(ref sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for sub_pat in sub_pats.iter() {\n+                for sub_pat in sub_pats {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n@@ -3453,15 +3453,15 @@ fn create_scope_map(cx: &CrateContext,\n             ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for sub_pat in front_sub_pats.iter() {\n+                for sub_pat in front_sub_pats {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n \n-                for sub_pat in middle_sub_pats.iter() {\n+                if let Some(ref sub_pat) = *middle_sub_pats {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n \n-                for sub_pat in back_sub_pats.iter() {\n+                for sub_pat in back_sub_pats {\n                     walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n@@ -3523,7 +3523,7 @@ fn create_scope_map(cx: &CrateContext,\n \n             ast::ExprVec(ref init_expressions) |\n             ast::ExprTup(ref init_expressions) => {\n-                for ie in init_expressions.iter() {\n+                for ie in init_expressions {\n                     walk_expr(cx, &**ie, scope_stack, scope_map);\n                 }\n             }\n@@ -3601,7 +3601,7 @@ fn create_scope_map(cx: &CrateContext,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    for &ast::Arg { pat: ref pattern, .. } in decl.inputs.iter() {\n+                    for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n                         walk_pattern(cx, &**pattern, scope_stack, scope_map);\n                     }\n \n@@ -3612,13 +3612,13 @@ fn create_scope_map(cx: &CrateContext,\n             ast::ExprCall(ref fn_exp, ref args) => {\n                 walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n \n-                for arg_exp in args.iter() {\n+                for arg_exp in args {\n                     walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                for arg_exp in args.iter() {\n+                for arg_exp in args {\n                     walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n                 }\n             }\n@@ -3631,19 +3631,19 @@ fn create_scope_map(cx: &CrateContext,\n                 // walk only one pattern per arm, as they all must contain the\n                 // same binding names.\n \n-                for arm_ref in arms.iter() {\n+                for arm_ref in arms {\n                     let arm_span = arm_ref.pats[0].span;\n \n                     with_new_scope(cx,\n                                    arm_span,\n                                    scope_stack,\n                                    scope_map,\n                                    |cx, scope_stack, scope_map| {\n-                        for pat in arm_ref.pats.iter() {\n+                        for pat in &arm_ref.pats {\n                             walk_pattern(cx, &**pat, scope_stack, scope_map);\n                         }\n \n-                        for guard_exp in arm_ref.guard.iter() {\n+                        if let Some(ref guard_exp) = arm_ref.guard {\n                             walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n                         }\n \n@@ -3653,7 +3653,7 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprStruct(_, ref fields, ref base_exp) => {\n-                for &ast::Field { expr: ref exp, .. } in fields.iter() {\n+                for &ast::Field { expr: ref exp, .. } in fields {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n@@ -3667,11 +3667,11 @@ fn create_scope_map(cx: &CrateContext,\n                                                 ref outputs,\n                                                 .. }) => {\n                 // inputs, outputs: Vec<(String, P<Expr>)>\n-                for &(_, ref exp) in inputs.iter() {\n+                for &(_, ref exp) in inputs {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n-                for &(_, ref exp, _) in outputs.iter() {\n+                for &(_, ref exp, _) in outputs {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }\n@@ -3726,7 +3726,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         ty::ty_tup(ref component_types) => {\n             output.push('(');\n-            for &component_type in component_types.iter() {\n+            for &component_type in component_types {\n                 push_debuginfo_type_name(cx, component_type, true, output);\n                 output.push_str(\", \");\n             }\n@@ -3791,7 +3791,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n             if sig.inputs.len() > 0 {\n-                for &parameter_type in sig.inputs.iter() {\n+                for &parameter_type in &sig.inputs {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n@@ -3837,7 +3837,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       def_id: ast::DefId,\n                       qualified: bool,\n                       output: &mut String) {\n-        ty::with_path(cx.tcx(), def_id, |mut path| {\n+        ty::with_path(cx.tcx(), def_id, |path| {\n             if qualified {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     output.push_str(crate_root_namespace(cx));"}, {"sha": "bed43a5c838823e36f062f1faeab10063ab48344", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1451,7 +1451,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n     // First we trans the base, if we have one, to the dest\n-    for base in optbase.iter() {\n+    if let Some(base) = optbase {\n         assert_eq!(discr, 0);\n \n         match ty::expr_kind(bcx.tcx(), &*base.expr) {\n@@ -1461,7 +1461,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\"),\n             _ => {\n                 let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n-                for &(i, t) in base.fields.iter() {\n+                for &(i, t) in &base.fields {\n                     let datum = base_datum.get_element(\n                             bcx, t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n                     assert!(type_is_sized(bcx.tcx(), datum.ty));\n@@ -1485,7 +1485,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // (i.e. avoid GEPi and `store`s to an alloca) .\n         let mut vec_val = C_undef(llty);\n \n-        for &(i, ref e) in fields.iter() {\n+        for &(i, ref e) in fields {\n             let block_datum = trans(bcx, &**e);\n             bcx = block_datum.bcx;\n             let position = C_uint(bcx.ccx(), i);\n@@ -1495,7 +1495,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Store(bcx, vec_val, addr);\n     } else {\n         // Now, we just overwrite the fields we've explicitly specified\n-        for &(i, ref e) in fields.iter() {\n+        for &(i, ref e) in fields {\n             let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n             let e_ty = expr_ty_adjusted(bcx, &**e);\n             bcx = trans_into(bcx, &**e, SaveIn(dest));"}, {"sha": "00bb3036546763787988d23ea4e5559e939d4bf0", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -352,7 +352,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     arg_idx += 1;\n-    for arg_ty in fn_type.arg_tys.iter() {\n+    for arg_ty in &fn_type.arg_tys {\n         if arg_ty.is_ignore() {\n             continue;\n         }\n@@ -453,7 +453,7 @@ fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n \n pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n-    for foreign_item in foreign_mod.items.iter() {\n+    for foreign_item in &foreign_mod.items {\n         let lname = link_name(&**foreign_item);\n \n         if let ast::ForeignItemFn(ref decl, _) = foreign_item.node {\n@@ -936,7 +936,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n         }\n     };\n \n-    for &arg_ty in tys.fn_ty.arg_tys.iter() {\n+    for &arg_ty in &tys.fn_ty.arg_tys {\n         if arg_ty.is_ignore() {\n             continue;\n         }\n@@ -987,7 +987,7 @@ fn add_argument_attributes(tys: &ForeignTypes,\n \n     i += 1;\n \n-    for &arg_ty in tys.fn_ty.arg_tys.iter() {\n+    for &arg_ty in &tys.fn_ty.arg_tys {\n         if arg_ty.is_ignore() {\n             continue;\n         }"}, {"sha": "5d26daab5cd8739f19f9d6d6a1e285ddb015fdfd", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -572,7 +572,7 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs().set(true);\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    for (_, ti) in ccx.tydescs().borrow().iter() {\n+    for (_, ti) in &*ccx.tydescs().borrow() {\n         // Each of the glue functions needs to be cast to a generic type\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when"}, {"sha": "6228043eeb1a9b307bf50dfa4e57f33ed0189e28", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -92,7 +92,7 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n     let mut last_failing_id = None;\n-    for transmute_restriction in ccx.tcx().transmute_restrictions.borrow().iter() {\n+    for transmute_restriction in &*ccx.tcx().transmute_restrictions.borrow() {\n         // Sometimes, a single call to transmute will push multiple\n         // type pairs to test in order to exhaustively test the\n         // possibility around a type parameter. If one of those fails,"}, {"sha": "f522024c2e7e910ec782cb5ad4fbd0233fbb0adb", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -65,7 +65,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     // items that we need to translate.\n     if !generics.ty_params.is_empty() {\n         let mut v = TransItemVisitor{ ccx: ccx };\n-        for impl_item in impl_items.iter() {\n+        for impl_item in impl_items {\n             match *impl_item {\n                 ast::MethodImplItem(ref method) => {\n                     visit::walk_method_helper(&mut v, &**method);\n@@ -75,7 +75,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         }\n         return;\n     }\n-    for impl_item in impl_items.iter() {\n+    for impl_item in impl_items {\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0 {"}, {"sha": "b3d388b0f0236b3e8f257db91d197b44fceba0bd", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -333,7 +333,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n            obligations.repr(tcx));\n \n     let mut fulfill_cx = traits::FulfillmentContext::new();\n-    for obligation in obligations.into_iter() {\n+    for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n     let result = drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &result);"}, {"sha": "66f603cbe07f2aea9c9d7bad2617e69f5da54e4e", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -263,7 +263,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprVec(ref elements) => {\n             match dest {\n                 Ignore => {\n-                    for element in elements.iter() {\n+                    for element in elements {\n                         bcx = expr::trans_into(bcx, &**element, Ignore);\n                     }\n                 }"}, {"sha": "2243982c20d61fcea680e035475493a91c4779a7", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -84,7 +84,7 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match inputs[inputs.len() - 1].sty {\n         ty::ty_tup(ref tupled_arguments) => {\n             debug!(\"untuple_arguments_if_necessary(): untupling arguments\");\n-            for &tupled_argument in tupled_arguments.iter() {\n+            for &tupled_argument in tupled_arguments {\n                 result.push(tupled_argument);\n             }\n         }"}, {"sha": "8809931cd80c23b23f81096be36772dd5b33d520", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -373,7 +373,7 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n     }\n \n-    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n+    for param in &ty_param_defs[supplied_ty_param_count..] {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter.\n@@ -537,7 +537,7 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n         instantiate_trait_ref(this, &shifted_rscope, &ast_trait_ref.trait_ref,\n                               self_ty, Some(&mut projections));\n \n-    for projection in projections.into_iter() {\n+    for projection in projections {\n         poly_projections.push(ty::Binder(projection));\n     }\n \n@@ -659,7 +659,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             prohibit_projections(this.tcx(), assoc_bindings.as_slice());\n         }\n         Some(ref mut v) => {\n-            for binding in assoc_bindings.iter() {\n+            for binding in &assoc_bindings {\n                 match ast_type_binding_to_projection_predicate(this, trait_ref.clone(),\n                                                                self_ty, binding) {\n                     Ok(pp) => { v.push(pp); }\n@@ -733,7 +733,7 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     // If converting for an object type, then remove the dummy-ty from `Self` now.\n     // Yuckety yuck.\n     if self_ty.is_none() {\n-        for candidate in candidates.iter_mut() {\n+        for candidate in &mut candidates {\n             let mut dummy_substs = candidate.0.substs.clone();\n             assert!(dummy_substs.self_ty() == Some(dummy_self_ty));\n             dummy_substs.types.pop(SelfSpace);\n@@ -979,7 +979,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                   token::get_name(assoc_name),\n                                   token::get_name(ty_param_name));\n \n-        for suitable_bound in suitable_bounds.iter() {\n+        for suitable_bound in &suitable_bounds {\n             span_note!(this.tcx().sess, ast_ty.span,\n                        \"associated type `{}` could derive from `{}`\",\n                        token::get_name(ty_param_name),\n@@ -1710,7 +1710,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n     let mut trait_def_ids = DefIdMap();\n-    for ast_bound in ast_bounds.iter() {\n+    for ast_bound in ast_bounds {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n                 match ::lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {"}, {"sha": "174a902953476da2db8519a7cca58188dbb3bb2e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -240,7 +240,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // below for details.\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n-            for elt in before.iter() {\n+            for elt in before {\n                 check_pat(pcx, &**elt, inner_ty);\n             }\n             if let Some(ref slice) = *slice {\n@@ -254,7 +254,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 });\n                 check_pat(pcx, &**slice, slice_ty);\n             }\n-            for elt in after.iter() {\n+            for elt in after {\n                 check_pat(pcx, &**elt, inner_ty);\n             }\n         }\n@@ -348,12 +348,12 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n-    for arm in arms.iter() {\n+    for arm in arms {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(&tcx.def_map, &*arm.pats[0]),\n         };\n-        for p in arm.pats.iter() {\n+        for p in &arm.pats {\n             check_pat(&mut pcx, &**p, discrim_ty);\n         }\n     }\n@@ -439,7 +439,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n                 \"use of trait `{}` in a struct pattern\", name);\n             fcx.write_error(pat.id);\n \n-            for field in fields.iter() {\n+            for field in fields {\n                 check_pat(pcx, &*field.node.pat, tcx.types.err);\n             }\n             return;\n@@ -458,7 +458,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n                         \"`{}` does not name a struct or a struct variant\", name);\n                     fcx.write_error(pat.id);\n \n-                    for field in fields.iter() {\n+                    for field in fields {\n                         check_pat(pcx, &*field.node.pat, tcx.types.err);\n                     }\n                     return;\n@@ -540,7 +540,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             fcx.write_error(pat.id);\n \n             if let Some(subpats) = subpats {\n-                for pat in subpats.iter() {\n+                for pat in subpats {\n                     check_pat(pcx, &**pat, tcx.types.err);\n                 }\n             }\n@@ -558,7 +558,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                       \"this pattern has {} field{}, but the corresponding {} has no fields\",\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n-            for pat in subpats.iter() {\n+            for pat in subpats {\n                 check_pat(pcx, &**pat, tcx.types.err);\n             }\n         } else {\n@@ -568,7 +568,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                       kind_name,\n                       arg_tys.len(), if arg_tys.len() == 1 {\"\"} else {\"s\"});\n \n-            for pat in subpats.iter() {\n+            for pat in subpats {\n                 check_pat(pcx, &**pat, tcx.types.err);\n             }\n         }\n@@ -598,7 +598,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let mut used_fields = FnvHashMap();\n \n     // Typecheck each field.\n-    for &Spanned { node: ref field, span } in fields.iter() {\n+    for &Spanned { node: ref field, span } in fields {\n         let field_type = match used_fields.entry(field.ident.name) {\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,"}, {"sha": "377af080526b7084a961c372de6535587d5cb511", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -33,7 +33,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     debug!(\"normalize_associated_types_in: result={} predicates={}\",\n            result.repr(infcx.tcx),\n            obligations.repr(infcx.tcx));\n-    for obligation in obligations.into_iter() {\n+    for obligation in obligations {\n         fulfillment_cx.register_predicate_obligation(infcx, obligation);\n     }\n     result"}, {"sha": "04a3f423dce11015ed08cf935ee13edf6c4784f1", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -353,7 +353,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     assert!(ty_substs_a.len() == ty_substs_b.len());\n \n                     let mut result = None;\n-                    let mut tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n+                    let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                     for (i, (tp_a, tp_b)) in tps {\n                         if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n                             continue;"}, {"sha": "dc4d7d466472800a9ddb633e0207c32e5be7c9e4", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -248,7 +248,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n \n-    for predicate in impl_pred.fns.into_iter() {\n+    for predicate in impl_pred.fns {\n         let traits::Normalized { value: predicate, .. } =\n             traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n "}, {"sha": "a988fb4cc6e19015e0b58ec43b737db33bbd6742", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -134,7 +134,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Create a list of simplified self types, if we can.\n     let mut simplified_steps = Vec::new();\n-    for step in steps.iter() {\n+    for step in &steps {\n         match fast_reject::simplify_type(fcx.tcx(), step.self_ty, true) {\n             None => { break; }\n             Some(simplified_type) => { simplified_steps.push(simplified_type); }\n@@ -236,7 +236,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_inherent_candidates(&mut self) {\n         let steps = self.steps.clone();\n-        for step in steps.iter() {\n+        for step in &*steps {\n             self.assemble_probe(step.self_ty);\n         }\n     }\n@@ -268,8 +268,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), def_id);\n \n-        for impl_infos in self.tcx().inherent_impls.borrow().get(&def_id).iter() {\n-            for &impl_def_id in impl_infos.iter() {\n+        if let Some(impl_infos) = self.tcx().inherent_impls.borrow().get(&def_id) {\n+            for &impl_def_id in &***impl_infos {\n                 self.assemble_inherent_impl_probe(impl_def_id);\n             }\n         }\n@@ -448,8 +448,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     {\n         let mut duplicates = HashSet::new();\n         let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n-        for applicable_traits in opt_applicable_traits.into_iter() {\n-            for &trait_did in applicable_traits.iter() {\n+        if let Some(applicable_traits) = opt_applicable_traits {\n+            for &trait_did in applicable_traits {\n                 if duplicates.insert(trait_did) {\n                     try!(self.assemble_extension_candidates_for_trait(trait_did));\n                 }\n@@ -530,7 +530,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             Some(impls) => impls,\n         };\n \n-        for &impl_def_id in impl_def_ids.borrow().iter() {\n+        for &impl_def_id in &*impl_def_ids.borrow() {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n                    trait_def_id.repr(self.tcx()),\n                    impl_def_id.repr(self.tcx()));\n@@ -601,7 +601,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // Check if there is an unboxed-closure self-type in the list of receivers.\n         // If so, add \"synthetic impls\".\n         let steps = self.steps.clone();\n-        for step in steps.iter() {\n+        for step in &*steps {\n             let (closure_def_id, _, _) = match step.self_ty.sty {\n                 ty::ty_closure(a, b, ref c) => (a, b, c),\n                 _ => continue,\n@@ -653,7 +653,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                method.repr(self.tcx()),\n                method_index);\n \n-        for step in self.steps.iter() {\n+        for step in &*self.steps {\n             debug!(\"assemble_projection_candidates: step={}\",\n                    step.repr(self.tcx()));\n "}, {"sha": "70e5d44ca672541b6aa87478390d0a964a21b6f8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -735,7 +735,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n               None => { }\n           }\n \n-        for impl_item in impl_items.iter() {\n+        for impl_item in impl_items {\n             match *impl_item {\n                 ast::MethodImplItem(ref m) => {\n                     check_method_body(ccx, &impl_pty.generics, &**m);\n@@ -750,7 +750,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemTrait(_, ref generics, _, ref trait_methods) => {\n         check_trait_on_unimplemented(ccx, generics, it);\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n-        for trait_method in trait_methods.iter() {\n+        for trait_method in trait_methods {\n             match *trait_method {\n                 RequiredMethod(..) => {\n                     // Nothing to do, since required methods don't have\n@@ -774,11 +774,11 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       }\n       ast::ItemForeignMod(ref m) => {\n         if m.abi == abi::RustIntrinsic {\n-            for item in m.items.iter() {\n+            for item in &m.items {\n                 check_intrinsic_type(ccx, &**item);\n             }\n         } else {\n-            for item in m.items.iter() {\n+            for item in &m.items {\n                 let pty = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n                 if !pty.generics.types.is_empty() {\n                     span_err!(ccx.tcx.sess, item.span, E0044,\n@@ -805,7 +805,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n         if let Some(ref istring) = attr.value_str() {\n-            let mut parser = Parser::new(istring.get());\n+            let parser = Parser::new(istring.get());\n             let types = generics.ty_params.as_slice();\n             for token in parser {\n                 match token {\n@@ -879,7 +879,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n-    for impl_item in impl_items.iter() {\n+    for impl_item in impl_items {\n         match *impl_item {\n             ast::MethodImplItem(ref impl_method) => {\n                 let impl_method_def_id = local_def(impl_method.id);\n@@ -969,7 +969,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check for missing items from trait\n     let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n-    for trait_item in trait_items.iter() {\n+    for trait_item in &*trait_items {\n         match *trait_item {\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n@@ -1341,7 +1341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n     pub fn default_type_parameters(&self) {\n         use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n-        for (_, &mut ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n+        for (_, &mut ref ty) in &mut *self.inh.node_types.borrow_mut() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n@@ -2321,7 +2321,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // of arguments when we typecheck the functions. This isn't really the\n     // right way to do this.\n     let xs = [false, true];\n-    for check_blocks in xs.iter() {\n+    for check_blocks in &xs {\n         let check_blocks = *check_blocks;\n         debug!(\"check_blocks={}\", check_blocks);\n \n@@ -3109,7 +3109,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mut best_dist = name.len();\n         let fields = ty::lookup_struct_fields(tcx, id);\n         let mut best = None;\n-        for elem in fields.iter() {\n+        for elem in &fields {\n             let n = elem.name.as_str();\n             // ignore already set fields\n             if skip.iter().any(|&x| x == n) {\n@@ -3207,14 +3207,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let mut class_field_map = FnvHashMap();\n         let mut fields_found = 0;\n-        for field in field_types.iter() {\n+        for field in field_types {\n             class_field_map.insert(field.name, (field.id, false));\n         }\n \n         let mut error_happened = false;\n \n         // Typecheck each field.\n-        for field in ast_fields.iter() {\n+        for field in ast_fields {\n             let mut expected_field_type = tcx.types.err;\n \n             let pair = class_field_map.get(&field.ident.node.name).map(|x| *x);\n@@ -3281,7 +3281,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             assert!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n                 let mut missing_fields = Vec::new();\n-                for class_field in field_types.iter() {\n+                for class_field in field_types {\n                     let name = class_field.name;\n                     let (_, seen) = class_field_map[name];\n                     if !seen {\n@@ -3382,7 +3382,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // Make sure to still write the types\n         // otherwise we might ICE\n         fcx.write_error(id);\n-        for field in fields.iter() {\n+        for field in fields {\n             check_expr(fcx, &*field.expr);\n         }\n         match *base_expr {\n@@ -3636,10 +3636,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           constrain_path_type_parameters(fcx, expr);\n       }\n       ast::ExprInlineAsm(ref ia) => {\n-          for &(_, ref input) in ia.inputs.iter() {\n+          for &(_, ref input) in &ia.inputs {\n               check_expr(fcx, &**input);\n           }\n-          for &(_, ref out, _) in ia.outputs.iter() {\n+          for &(_, ref out, _) in &ia.outputs {\n               check_expr(fcx, &**out);\n           }\n           fcx.write_nil(id);\n@@ -3772,14 +3772,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let typ = match uty {\n             Some(uty) => {\n-                for e in args.iter() {\n+                for e in args {\n                     check_expr_coercable_to_type(fcx, &**e, uty);\n                 }\n                 uty\n             }\n             None => {\n                 let t: Ty = fcx.infcx().next_ty_var();\n-                for e in args.iter() {\n+                for e in args {\n                     check_expr_has_type(fcx, &**e, t);\n                 }\n                 t\n@@ -4278,7 +4278,7 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let mut warned = false;\n     let mut any_diverges = false;\n     let mut any_err = false;\n-    for s in blk.stmts.iter() {\n+    for s in &blk.stmts {\n         check_stmt(fcx, &**s);\n         let s_id = ast_util::stmt_id(&**s);\n         let s_ty = fcx.node_ty(s_id);\n@@ -4514,7 +4514,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n-        for v in vs.iter() {\n+        for v in vs {\n \n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n@@ -4846,7 +4846,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // variables. If the user provided some types, we may still need\n     // to add defaults. If the user provided *too many* types, that's\n     // a problem.\n-    for &space in ParamSpace::all().iter() {\n+    for &space in &ParamSpace::all() {\n         adjust_type_parameters(fcx, span, space, type_defs, &mut substs);\n         assert_eq!(substs.types.len(space), type_defs.len(space));\n \n@@ -4878,13 +4878,13 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx: &FnCtxt,\n         segment: &ast::PathSegment)\n     {\n-        for typ in segment.parameters.types().iter() {\n+        for typ in &segment.parameters.types() {\n             span_err!(fcx.tcx().sess, typ.span, E0085,\n                 \"type parameters may not appear here\");\n             break;\n         }\n \n-        for lifetime in segment.parameters.lifetimes().iter() {\n+        for lifetime in &segment.parameters.lifetimes() {\n             span_err!(fcx.tcx().sess, lifetime.span, E0086,\n                 \"lifetime parameters may not appear here\");\n             break;"}, {"sha": "94414d842c9dfd0daee79c3cfd8dfcb2a46d681d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -148,7 +148,7 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   component_tys: &[Ty<'tcx>]) {\n     let mut rcx = Rcx::new(fcx, Repeating(0), SubjectNode::None);\n-    for &component_ty in component_tys.iter() {\n+    for &component_ty in component_tys {\n         // Check that each type outlives the empty region. Since the\n         // empty region is a subregion of all others, this can't fail\n         // unless the type does not meet the well-formedness\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                                        .region_obligations(node_id)\n                                        .to_vec();\n \n-        for r_o in region_obligations.iter() {\n+        for r_o in &region_obligations {\n             debug!(\"visit_region_obligations: r_o={}\",\n                    r_o.repr(self.tcx()));\n             let sup_type = self.resolve_type(r_o.sup_type);\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         debug!(\"relate_free_regions >>\");\n         let tcx = self.tcx();\n \n-        for &ty in fn_sig_tys.iter() {\n+        for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n             let body_scope = CodeExtent::from_node_id(body_id);\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                     tcx,\n                     ty,\n                     body_scope);\n-            for constraint in constraints.iter() {\n+            for constraint in &constraints {\n                 debug!(\"constraint: {}\", constraint.repr(tcx));\n                 match *constraint {\n                     regionmanip::RegionSubRegionConstraint(_,\n@@ -424,7 +424,7 @@ fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n \n fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n     // see above\n-    for p in arm.pats.iter() {\n+    for p in &arm.pats {\n         constrain_bindings_in_pat(&**p, rcx);\n     }\n \n@@ -487,13 +487,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    for &adjustment in rcx.fcx.inh.adjustments.borrow().get(&expr.id).iter() {\n+    if let Some(adjustment) = rcx.fcx.inh.adjustments.borrow().get(&expr.id) {\n         debug!(\"adjustment={:?}\", adjustment);\n         match *adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n-                for autoref in opt_autoref.iter() {\n+                if let Some(ref autoref) = *opt_autoref {\n                     link_autoref(rcx, expr, autoderefs, autoref);\n \n                     // Require that the resulting region encompasses\n@@ -753,7 +753,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         debug!(\"ensure_free_variable_types_outlive_closure_bound({}, {})\",\n                bounds.region_bound.repr(tcx), expr.repr(tcx));\n \n-        for freevar in freevars.iter() {\n+        for freevar in freevars {\n             let var_node_id = {\n                 let def_id = freevar.def.def_id();\n                 assert!(def_id.krate == ast::LOCAL_CRATE);\n@@ -779,7 +779,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             };\n \n             // Check that the type meets the criteria of the existential bounds:\n-            for builtin_bound in bounds.builtin_bounds.iter() {\n+            for builtin_bound in &bounds.builtin_bounds {\n                 let code = traits::ClosureCapture(var_node_id, expr.span, builtin_bound);\n                 let cause = traits::ObligationCause::new(freevar.span, rcx.fcx.body_id, code);\n                 rcx.fcx.register_builtin_bound(var_ty, builtin_bound, cause);\n@@ -802,7 +802,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"constrain_captured_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n-        for freevar in freevars.iter() {\n+        for freevar in freevars {\n             debug!(\"constrain_captured_variables: freevar.def={:?}\", freevar.def);\n \n             // Identify the variable being closed over and its node-id.\n@@ -854,7 +854,7 @@ fn constrain_callee(rcx: &mut Rcx,\n fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n                                                        call_expr: &ast::Expr,\n                                                        receiver: Option<&ast::Expr>,\n-                                                       mut arg_exprs: I,\n+                                                       arg_exprs: I,\n                                                        implicitly_ref_args: bool) {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n     //! and overloaded operators). Constrains the regions which appear\n@@ -897,13 +897,13 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     }\n \n     // as loop above, but for receiver\n-    for r in receiver.iter() {\n+    if let Some(r) = receiver {\n         debug!(\"receiver: {}\", r.repr(tcx));\n         type_of_node_must_outlive(\n             rcx, infer::CallRcvr(r.span),\n             r.id, callee_region);\n         if implicitly_ref_args {\n-            link_by_ref(rcx, &**r, callee_scope);\n+            link_by_ref(rcx, &*r, callee_scope);\n         }\n     }\n }\n@@ -1079,8 +1079,8 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n-    for arm in arms.iter() {\n-        for root_pat in arm.pats.iter() {\n+    for arm in arms {\n+        for root_pat in &arm.pats {\n             link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n         }\n     }\n@@ -1092,7 +1092,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n     debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    for arg in args.iter() {\n+    for arg in args {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n         let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n@@ -1418,7 +1418,7 @@ fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n             rcx.tcx(),\n             ty,\n             region);\n-    for constraint in constraints.iter() {\n+    for constraint in &constraints {\n         debug!(\"constraint: {}\", constraint.repr(rcx.tcx()));\n         match *constraint {\n             regionmanip::RegionSubRegionConstraint(None, r_a, r_b) => {\n@@ -1479,7 +1479,7 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // The problem is that the type of `x` is `&'a A`. To be\n     // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n-    for &(ref r, ref p) in rcx.region_bound_pairs.iter() {\n+    for &(ref r, ref p) in &rcx.region_bound_pairs {\n         debug!(\"generic={} p={}\",\n                generic.repr(rcx.tcx()),\n                p.repr(rcx.tcx()));"}, {"sha": "4a0e2acc854441a0cd2da7b950441b350e4417ea", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             }\n \n             ty::ty_tup(ref tuptys) => {\n-                for &tupty in tuptys.iter() {\n+                for &tupty in tuptys {\n                     self.accumulate_from_ty(tupty);\n                 }\n             }\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         // Variance of each type/region parameter.\n         let variances = ty::item_variances(self.tcx, def_id);\n \n-        for &space in ParamSpace::all().iter() {\n+        for &space in &ParamSpace::all() {\n             let region_params = substs.regions().get_slice(space);\n             let region_variances = variances.regions.get_slice(space);\n             let region_param_defs = generics.regions.get_slice(space);\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                     }\n                 }\n \n-                for &region_bound in region_param_def.bounds.iter() {\n+                for &region_bound in &region_param_def.bounds {\n                     // The type declared a constraint like\n                     //\n                     //     'b : 'a\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n                 // Inspect bounds on this type parameter for any\n                 // region bounds.\n-                for &r in type_param_def.bounds.region_bounds.iter() {\n+                for &r in &type_param_def.bounds.region_bounds {\n                     self.stack.push((r, Some(ty)));\n                     self.accumulate_from_ty(type_param_ty);\n                     self.stack.pop().unwrap();\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         // And then, in turn, to be well-formed, the\n         // `region_bound` that user specified must imply the\n         // region bounds required from all of the trait types:\n-        for &r_d in required_region_bounds.iter() {\n+        for &r_d in &required_region_bounds {\n             // Each of these is an instance of the `'c <= 'b`\n             // constraint above\n             self.out.push(RegionSubRegionConstraint(Some(ty), r_d, r_c));"}, {"sha": "b52e01f9a7a7684dd39b362ccac0d3c91aaeb7b6", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -138,7 +138,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n         }\n \n         ty::with_freevars(self.tcx(), expr.id, |freevars| {\n-            for freevar in freevars.iter() {\n+            for freevar in freevars {\n                 let var_node_id = freevar.def.local_node_id();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                              closure_expr_id: expr.id };"}, {"sha": "6f66010925ec0b5411d059312947ce6bdb08c573", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -142,7 +142,7 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ty::item_path_str(tcx, object_trait_ref.def_id()));\n \n     let violations = traits::object_safety_violations(tcx, object_trait_ref.clone());\n-    for violation in violations.into_iter() {\n+    for violation in violations {\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {\n                 tcx.sess.span_note(\n@@ -221,7 +221,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // bounds attached to the object cast. (In other words, if the\n     // object type is Foo+Send, this would create an obligation\n     // for the Send check.)\n-    for builtin_bound in object_trait.bounds.builtin_bounds.iter() {\n+    for builtin_bound in &object_trait.bounds.builtin_bounds {\n         fcx.register_builtin_bound(\n             referent_ty,\n             builtin_bound,\n@@ -231,7 +231,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Create obligations for the projection predicates.\n     let projection_bounds =\n         object_trait.projection_bounds_with_self_ty(fcx.tcx(), referent_ty);\n-    for projection_bound in projection_bounds.iter() {\n+    for projection_bound in &projection_bounds {\n         let projection_obligation =\n             Obligation::new(cause.clone(), projection_bound.as_predicate());\n         fcx.register_predicate(projection_obligation);\n@@ -263,13 +263,13 @@ fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n         })\n         .collect();\n \n-    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n+    for projection_bound in &object_trait.bounds.projection_bounds {\n         let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n                     projection_bound.0.projection_ty.item_name);\n         associated_types.remove(&pair);\n     }\n \n-    for (trait_def_id, name) in associated_types.into_iter() {\n+    for (trait_def_id, name) in associated_types {\n         span_err!(tcx.sess, span, E0191,\n             \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                     name.user_string(tcx),"}, {"sha": "71b495af444dd240f313e5a53f59ecedd489355c", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -147,15 +147,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         item.span,\n                                                         region::CodeExtent::from_node_id(item.id),\n                                                         Some(&mut this.cache));\n-            for variant in variants.iter() {\n-                for field in variant.fields.iter() {\n+            for variant in &variants {\n+                for field in &variant.fields {\n                     // Regions are checked below.\n                     bounds_checker.check_traits_in_ty(field.ty);\n                 }\n \n                 // For DST, all intermediate types must be sized.\n                 if variant.fields.len() > 0 {\n-                    for field in variant.fields.init().iter() {\n+                    for field in variant.fields.init() {\n                         fcx.register_builtin_bound(\n                             field.ty,\n                             ty::BoundSized,\n@@ -268,10 +268,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n                 traits::normalize(selcx, cause.clone(), &predicates)\n             };\n-            for predicate in predicates.value.into_iter() {\n+            for predicate in predicates.value {\n                 fcx.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n             }\n-            for obligation in predicates.obligations.into_iter() {\n+            for obligation in predicates.obligations {\n                 fcx.register_predicate(obligation);\n             }\n         });\n@@ -323,7 +323,7 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n         .map(|tp| tp.name).collect::<HashSet<_>>();\n \n-    for method_param in generics.types.get_slice(subst::FnSpace).iter() {\n+    for method_param in generics.types.get_slice(subst::FnSpace) {\n         if impl_params.contains(&method_param.name) {\n             span_err!(tcx.sess, span, E0194,\n                 \"type parameter `{}` shadows another type parameter of the same name\","}, {"sha": "52b1eb490cc257c23204268dc6f581b41bbeff28", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -49,7 +49,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     assert_eq!(fcx.writeback_errors.get(), false);\n     let mut wbcx = WritebackCx::new(fcx);\n     wbcx.visit_block(blk);\n-    for arg in decl.inputs.iter() {\n+    for arg in &decl.inputs {\n         wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n         wbcx.visit_pat(&*arg.pat);\n \n@@ -119,7 +119,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n \n         match e.node {\n             ast::ExprClosure(_, _, ref decl, _) => {\n-                for input in decl.inputs.iter() {\n+                for input in &decl.inputs {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);\n                 }\n@@ -182,7 +182,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        for (upvar_id, upvar_capture) in self.fcx.inh.upvar_capture_map.borrow().iter() {\n+        for (upvar_id, upvar_capture) in &*self.fcx.inh.upvar_capture_map.borrow() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n@@ -204,12 +204,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return\n         }\n \n-        for (def_id, closure_ty) in self.fcx.inh.closure_tys.borrow().iter() {\n+        for (def_id, closure_ty) in &*self.fcx.inh.closure_tys.borrow() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(*def_id));\n             self.fcx.tcx().closure_tys.borrow_mut().insert(*def_id, closure_ty);\n         }\n \n-        for (def_id, &closure_kind) in self.fcx.inh.closure_kinds.borrow().iter() {\n+        for (def_id, &closure_kind) in &*self.fcx.inh.closure_kinds.borrow() {\n             self.fcx.tcx().closure_kinds.borrow_mut().insert(*def_id, closure_kind);\n         }\n     }"}, {"sha": "ed340b0882ca3de3eb5398301559a260ccf476f4", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // the tcx.\n         let mut tcx_inherent_impls =\n             self.crate_context.tcx.inherent_impls.borrow_mut();\n-        for (k, v) in self.inherent_impls.borrow().iter() {\n+        for (k, v) in &*self.inherent_impls.borrow() {\n             tcx_inherent_impls.insert((*k).clone(),\n                                       Rc::new((*v.borrow()).clone()));\n         }\n@@ -167,7 +167,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         let impl_items = self.create_impl_from_item(item);\n \n-        for associated_trait in associated_traits.iter() {\n+        for associated_trait in associated_traits {\n             let trait_ref = ty::node_id_to_trait_ref(self.crate_context.tcx,\n                                                      associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n \n         let prov = ty::provided_trait_methods(tcx, trait_ref.def_id);\n-        for trait_method in prov.iter() {\n+        for trait_method in &prov {\n             // Synthesize an ID.\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                             }\n                         }).collect();\n \n-                for trait_ref in trait_refs.iter() {\n+                if let Some(ref trait_ref) = *trait_refs {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n                         self.crate_context.tcx,\n                         trait_ref.ref_id);\n@@ -345,17 +345,17 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         assert!(associated_traits.is_some());\n \n         // Record all the trait items.\n-        for trait_ref in associated_traits.iter() {\n+        if let Some(trait_ref) = associated_traits {\n             self.add_trait_impl(trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for item_def_id in impl_items.iter() {\n+        for item_def_id in &impl_items {\n             let impl_item = ty::impl_or_trait_item(tcx, item_def_id.def_id());\n             match impl_item {\n                 ty::MethodTraitItem(ref method) => {\n-                    for &source in method.provided_source.iter() {\n+                    if let Some(source) = method.provided_source {\n                         tcx.provided_method_sources\n                            .borrow_mut()\n                            .insert(item_def_id.def_id(), source);\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Some(found_impls) => found_impls\n         };\n \n-        for &impl_did in trait_impls.borrow().iter() {\n+        for &impl_did in &*trait_impls.borrow() {\n             let items = &(*impl_items)[impl_did];\n             if items.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // Clone first to avoid a double borrow error.\n         let trait_impls = trait_impls.borrow().clone();\n \n-        for &impl_did in trait_impls.iter() {\n+        for &impl_did in &trait_impls {\n             debug!(\"check_implementations_of_copy: impl_did={}\",\n                    impl_did.repr(tcx));\n \n@@ -559,7 +559,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // replace the type parameters declared on the trait with those\n     // from the impl\n-    for &space in [subst::TypeSpace, subst::SelfSpace].iter() {\n+    for &space in &[subst::TypeSpace, subst::SelfSpace] {\n         method_generics.types.replace(\n             space,\n             impl_type_scheme.generics.types.get_slice(space).to_vec());"}, {"sha": "403dcf1e25abaa52b4cefba4b6086aa2c413135a", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -46,7 +46,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                 (k, v.borrow().clone())\n             }).collect();\n \n-        for &(trait_def_id, ref impls) in trait_def_ids.iter() {\n+        for &(trait_def_id, ref impls) in &trait_def_ids {\n             self.check_for_overlapping_impls_of_trait(trait_def_id, impls);\n         }\n     }\n@@ -65,7 +65,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                 continue;\n             }\n \n-            for &impl2_def_id in trait_impls[(i+1)..].iter() {\n+            for &impl2_def_id in &trait_impls[(i+1)..] {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);"}, {"sha": "7dfa5298fb4c78b092d2e438b8b4694193f8ba27", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -203,7 +203,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n-    for variant in variants.iter() {\n+    for variant in variants {\n         let variant_def_id = local_def(variant.node.id);\n \n         // Nullary enum constructors get turned into constants; n-ary enum\n@@ -249,7 +249,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         if let ast::ItemTrait(_, _, _, ref trait_items) = item.node {\n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.impl_or_trait_items` table:\n-            for trait_item in trait_items.iter() {\n+            for trait_item in trait_items {\n                 match *trait_item {\n                     ast::RequiredMethod(_) |\n                     ast::ProvidedMethod(_) => {\n@@ -439,7 +439,7 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n-                                 mut ms: I,\n+                                 ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n@@ -527,8 +527,8 @@ fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n                                  thing: &'static str) {\n     let mut warn = false;\n \n-    for ty_param in generics.ty_params.iter() {\n-        for bound in ty_param.bounds.iter() {\n+    for ty_param in &*generics.ty_params {\n+        for bound in &*ty_param.bounds {\n             match *bound {\n                 ast::TraitTyParamBound(..) => {\n                     warn = true;\n@@ -596,7 +596,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n             };\n \n             let mut methods = Vec::new();\n-            for impl_item in impl_items.iter() {\n+            for impl_item in impl_items {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n                         let body_id = method.pe_body().id;\n@@ -644,7 +644,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                             &ty_generics,\n                             parent_visibility);\n \n-            for trait_ref in opt_trait_ref.iter() {\n+            if let Some(ref trait_ref) = *opt_trait_ref {\n                 astconv::instantiate_trait_ref(ccx,\n                                                &ExplicitRscope,\n                                                trait_ref,\n@@ -663,7 +663,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                    it.ident.repr(ccx.tcx),\n                    trait_def.repr(ccx.tcx));\n \n-            for trait_method in trait_methods.iter() {\n+            for trait_method in trait_methods {\n                 let self_type = ty::mk_self_type(tcx);\n                 match *trait_method {\n                     ast::RequiredMethod(ref type_method) => {\n@@ -1109,7 +1109,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     debug!(\"ty_generics_for_trait: assoc_predicates={}\", assoc_predicates.repr(ccx.tcx));\n \n-    for assoc_predicate in assoc_predicates.into_iter() {\n+    for assoc_predicate in assoc_predicates {\n         generics.predicates.push(subst::TypeSpace, assoc_predicate);\n     }\n \n@@ -1168,7 +1168,7 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n {\n     // Try to find an unbound in bounds.\n     let mut unbound = None;\n-    for ab in ast_bounds.iter() {\n+    for ab in ast_bounds {\n         if let &ast::TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = ab  {\n             if unbound.is_none() {\n                 assert!(ptr.bound_lifetimes.is_empty());\n@@ -1249,12 +1249,12 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     create_predicates(ccx.tcx, &mut result, space);\n \n     // Add the bounds not associated with a type parameter\n-    for predicate in where_clause.predicates.iter() {\n+    for predicate in &where_clause.predicates {\n         match predicate {\n             &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*bound_pred.bounded_ty);\n \n-                for bound in bound_pred.bounds.iter() {\n+                for bound in &*bound_pred.bounds {\n                     match bound {\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n@@ -1269,7 +1269,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n \n                             result.predicates.push(space, trait_ref.as_predicate());\n \n-                            for projection in projections.iter() {\n+                            for projection in &projections {\n                                 result.predicates.push(space, projection.as_predicate());\n                             }\n                         }\n@@ -1285,7 +1285,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n \n             &ast::WherePredicate::RegionPredicate(ref region_pred) => {\n                 let r1 = ast_region_to_region(ccx.tcx, &region_pred.lifetime);\n-                for bound in region_pred.bounds.iter() {\n+                for bound in &region_pred.bounds {\n                     let r2 = ast_region_to_region(ccx.tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n@@ -1308,16 +1308,16 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n         result: &mut ty::Generics<'tcx>,\n         space: subst::ParamSpace)\n     {\n-        for type_param_def in result.types.get_slice(space).iter() {\n+        for type_param_def in result.types.get_slice(space) {\n             let param_ty = ty::mk_param_from_def(tcx, type_param_def);\n-            for predicate in ty::predicates(tcx, param_ty, &type_param_def.bounds).into_iter() {\n+            for predicate in ty::predicates(tcx, param_ty, &type_param_def.bounds) {\n                 result.predicates.push(space, predicate);\n             }\n         }\n \n-        for region_param_def in result.regions.get_slice(space).iter() {\n+        for region_param_def in result.regions.get_slice(space) {\n             let region = region_param_def.to_early_bound_region();\n-            for &bound_region in region_param_def.bounds.iter() {\n+            for &bound_region in &region_param_def.bounds {\n                 // account for new binder introduced in the predicate below; no need\n                 // to shift `region` because it is never a late-bound region\n                 let bound_region = ty_fold::shift_region(bound_region, 1);\n@@ -1480,7 +1480,7 @@ fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                        ast_generics: &ast::Generics,\n                                        abi: abi::Abi)\n                                        -> ty::TypeScheme<'tcx> {\n-    for i in decl.inputs.iter() {\n+    for i in &decl.inputs {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n             ast::PatWild(ast::PatWildSingle) => (),\n@@ -1655,7 +1655,7 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     loop {\n         let num_inputs = input_parameters.len();\n \n-        let mut projection_predicates =\n+        let projection_predicates =\n             impl_scheme.generics.predicates\n             .iter()\n             .filter_map(|predicate| {"}, {"sha": "a07179b31bbd897725af62686a63778b9f63e2eb", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -73,7 +73,6 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(non_camel_case_types)]\n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n \n #![feature(box_syntax)]\n #![feature(collections)]"}, {"sha": "ddb485d9776d14d244d643494aed017142b0295c", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -165,7 +165,7 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n     {\n         match self.base_scope.anon_regions(span, count) {\n             Ok(mut v) => {\n-                for r in v.iter_mut() {\n+                for r in &mut v {\n                     *r = ty_fold::shift_region(*r, 1);\n                 }\n                 Ok(v)"}, {"sha": "40197ee2c4988bf3eb0c717340f8a502d52a1864", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -499,12 +499,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 // `ty::VariantInfo::from_ast_variant()` ourselves\n                 // here, mainly so as to mask the differences between\n                 // struct-like enums and so forth.\n-                for ast_variant in enum_definition.variants.iter() {\n+                for ast_variant in &enum_definition.variants {\n                     let variant =\n                         ty::VariantInfo::from_ast_variant(tcx,\n                                                           &**ast_variant,\n                                                           /*discriminant*/ 0);\n-                    for arg_ty in variant.args.iter() {\n+                    for arg_ty in &variant.args {\n                         self.add_constraints_from_ty(generics, *arg_ty, self.covariant);\n                     }\n                 }\n@@ -513,7 +513,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             ast::ItemStruct(..) => {\n                 let generics = &ty::lookup_item_type(tcx, did).generics;\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n-                for field_info in struct_fields.iter() {\n+                for field_info in &struct_fields {\n                     assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n                     let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n                     self.add_constraints_from_ty(generics, field_ty, self.covariant);\n@@ -522,7 +522,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n             ast::ItemTrait(..) => {\n                 let trait_items = ty::trait_items(tcx, did);\n-                for trait_item in trait_items.iter() {\n+                for trait_item in &*trait_items {\n                     match *trait_item {\n                         ty::MethodTraitItem(ref method) => {\n                             self.add_constraints_from_sig(&method.generics,\n@@ -759,7 +759,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_tup(ref subtys) => {\n-                for &subty in subtys.iter() {\n+                for &subty in subtys {\n                     self.add_constraints_from_ty(generics, subty, variance);\n                 }\n             }\n@@ -821,7 +821,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 let projections = data.projection_bounds_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);\n-                for projection in projections.iter() {\n+                for projection in &projections {\n                     self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n                 }\n             }\n@@ -866,7 +866,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n \n-        for p in type_param_defs.iter() {\n+        for p in type_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n                                        p.space, p.index as uint);\n@@ -875,7 +875,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n         }\n \n-        for p in region_param_defs.iter() {\n+        for p in region_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id,\n                                        RegionParam, p.space, p.index as uint);\n@@ -892,7 +892,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                 sig: &ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n-        for &input in sig.0.inputs.iter() {\n+        for &input in &sig.0.inputs {\n             self.add_constraints_from_ty(generics, input, contra);\n         }\n         if let ty::FnConverging(result_type) = sig.0.output {\n@@ -990,7 +990,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         while changed {\n             changed = false;\n \n-            for constraint in self.constraints.iter() {\n+            for constraint in &self.constraints {\n                 let Constraint { inferred, variance: term } = *constraint;\n                 let InferredIndex(inferred) = inferred;\n                 let variance = self.evaluate(term);"}, {"sha": "07679480bfb39ef6f6f2702070d99df4c98cdf09", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                 _ => unreachable!(),\n             };\n             let mut tmp = Vec::new();\n-            for child in m.items.iter_mut() {\n+            for child in &mut m.items {\n                 match child.inner {\n                     ModuleItem(..) => {}\n                     _ => continue,\n@@ -254,7 +254,7 @@ impl Item {\n     /// Finds the `doc` attribute as a List and returns the list of attributes\n     /// nested inside.\n     pub fn doc_list<'a>(&'a self) -> Option<&'a [Attribute]> {\n-        for attr in self.attrs.iter() {\n+        for attr in &self.attrs {\n             match *attr {\n                 List(ref x, ref list) if \"doc\" == *x => {\n                     return Some(list.as_slice());\n@@ -268,7 +268,7 @@ impl Item {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n-        for attr in self.attrs.iter() {\n+        for attr in &self.attrs {\n             match *attr {\n                 NameValue(ref x, ref v) if \"doc\" == *x => {\n                     return Some(v.as_slice());\n@@ -281,8 +281,8 @@ impl Item {\n \n     pub fn is_hidden_from_doc(&self) -> bool {\n         match self.doc_list() {\n-            Some(ref l) => {\n-                for innerattr in l.iter() {\n+            Some(l) => {\n+                for innerattr in l {\n                     match *innerattr {\n                         Word(ref s) if \"hidden\" == *s => {\n                             return true\n@@ -508,12 +508,12 @@ impl<'tcx> Clean<(Vec<TyParamBound>, Vec<TypeBinding>)> for ty::ExistentialBound\n     fn clean(&self, cx: &DocContext) -> (Vec<TyParamBound>, Vec<TypeBinding>) {\n         let mut tp_bounds = vec![];\n         self.region_bound.clean(cx).map(|b| tp_bounds.push(RegionBound(b)));\n-        for bb in self.builtin_bounds.iter() {\n+        for bb in &self.builtin_bounds {\n             tp_bounds.push(bb.clean(cx));\n         }\n \n         let mut bindings = vec![];\n-        for &ty::Binder(ref pb) in self.projection_bounds.iter() {\n+        for &ty::Binder(ref pb) in &self.projection_bounds {\n             bindings.push(TypeBinding {\n                 name: pb.projection_ty.item_name.clean(cx),\n                 ty: pb.ty.clean(cx)\n@@ -636,10 +636,10 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n \n         // collect any late bound regions\n         let mut late_bounds = vec![];\n-        for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace).iter() {\n+        for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace) {\n             use rustc::middle::ty::{Region, sty};\n             if let sty::ty_tup(ref ts) = ty_s.sty {\n-                for &ty_s in ts.iter() {\n+                for &ty_s in ts {\n                     if let sty::ty_rptr(ref reg, _) = ty_s.sty {\n                         if let &Region::ReLateBound(_, _) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n@@ -662,7 +662,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n impl<'tcx> Clean<Vec<TyParamBound>> for ty::ParamBounds<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut v = Vec::new();\n-        for t in self.trait_bounds.iter() {\n+        for t in &self.trait_bounds {\n             v.push(t.clean(cx));\n         }\n         for r in self.region_bounds.iter().filter_map(|r| r.clean(cx)) {\n@@ -872,7 +872,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n                     Some(did) => did,\n                     None => return false\n                 };\n-                for bound in bounds.iter() {\n+                for bound in bounds {\n                     if let TyParamBound::TraitBound(PolyTrait {\n                         trait_: Type::ResolvedPath { did, .. }, ..\n                     }, TBM::None) = *bound {\n@@ -915,7 +915,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n         }).collect::<Vec<_>>();\n         // Finally, run through the type parameters again and insert a ?Sized unbound for\n         // any we didn't find to be Sized.\n-        for tp in stripped_typarams.iter() {\n+        for tp in &stripped_typarams {\n             if !sized_params.contains(&tp.name) {\n                 let mut sized_bound = ty::BuiltinBound::BoundSized.clean(cx);\n                 if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n@@ -1420,12 +1420,12 @@ impl PrimitiveType {\n     }\n \n     fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n-        for attr in attrs.iter() {\n+        for attr in attrs {\n             let list = match *attr {\n                 List(ref k, ref l) if *k == \"doc\" => l,\n                 _ => continue,\n             };\n-            for sub_attr in list.iter() {\n+            for sub_attr in list {\n                 let value = match *sub_attr {\n                     NameValue(ref k, ref v)\n                         if *k == \"primitive\" => v.as_slice(),\n@@ -2175,7 +2175,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n                 let mut ret = vec![];\n                 let remaining = if !denied {\n                     let mut remaining = vec![];\n-                    for path in list.iter() {\n+                    for path in list {\n                         match inline::try_inline(cx, path.node.id(), None) {\n                             Some(items) => {\n                                 ret.extend(items.into_iter());"}, {"sha": "84e88158219ae584273f5e524d4c205f2d13d84d", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -62,7 +62,7 @@ macro_rules! load_or_return {\n \n pub fn load_external_files(names: &[String]) -> Option<String> {\n     let mut out = String::new();\n-    for name in names.iter() {\n+    for name in names {\n         out.push_str(load_or_return!(name.as_slice(), None, None).as_slice());\n         out.push('\\n');\n     }"}, {"sha": "e86c0e39714083faacbcaf37bf61441b0562f9cb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -212,21 +212,21 @@ impl fmt::Display for clean::PathParameters {\n                 if lifetimes.len() > 0 || types.len() > 0 || bindings.len() > 0 {\n                     try!(f.write_str(\"&lt;\"));\n                     let mut comma = false;\n-                    for lifetime in lifetimes.iter() {\n+                    for lifetime in lifetimes {\n                         if comma {\n                             try!(f.write_str(\", \"));\n                         }\n                         comma = true;\n                         try!(write!(f, \"{}\", *lifetime));\n                     }\n-                    for ty in types.iter() {\n+                    for ty in types {\n                         if comma {\n                             try!(f.write_str(\", \"));\n                         }\n                         comma = true;\n                         try!(write!(f, \"{}\", *ty));\n                     }\n-                    for binding in bindings.iter() {\n+                    for binding in bindings {\n                         if comma {\n                             try!(f.write_str(\", \"));\n                         }\n@@ -239,7 +239,7 @@ impl fmt::Display for clean::PathParameters {\n             clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n                 try!(f.write_str(\"(\"));\n                 let mut comma = false;\n-                for ty in inputs.iter() {\n+                for ty in inputs {\n                     if comma {\n                         try!(f.write_str(\", \"));\n                     }\n@@ -332,7 +332,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments[..amt].iter() {\n+                for seg in &path.segments[..amt] {\n                     if \"super\" == seg.name ||\n                             \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -347,7 +347,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n                 }\n             }\n             None => {\n-                for seg in path.segments[..amt].iter() {\n+                for seg in &path.segments[..amt] {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }\n@@ -359,7 +359,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n             let to_link = &fqp[..fqp.len() - 1];\n-            for component in to_link.iter() {\n+            for component in to_link {\n                 url.push_str(component.as_slice());\n                 url.push_str(\"/\");\n             }\n@@ -440,7 +440,7 @@ fn tybounds(w: &mut fmt::Formatter,\n             typarams: &Option<Vec<clean::TyParamBound> >) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n-            for param in params.iter() {\n+            for param in params {\n                 try!(write!(w, \" + \"));\n                 try!(write!(w, \"{}\", *param));\n             }\n@@ -770,7 +770,7 @@ impl fmt::Display for ModuleSummary {\n                         (100 * cnt.unmarked) as f64/tot as f64));\n             try!(write!(f, \"</td></tr>\"));\n \n-            for submodule in m.submodules.iter() {\n+            for submodule in &m.submodules {\n                 try!(fmt_inner(f, context, submodule));\n             }\n             context.pop();"}, {"sha": "6247c6dad1496dd23b3e2a9fce432e2427621e94", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -283,7 +283,7 @@ pub fn run(mut krate: clean::Crate,\n     let default: &[_] = &[];\n     match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(default)) {\n         Some(attrs) => {\n-            for attr in attrs.iter() {\n+            for attr in attrs {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n                             if \"html_favicon_url\" == *x => {\n@@ -353,7 +353,7 @@ pub fn run(mut krate: clean::Crate,\n     krate = cache.fold_crate(krate);\n \n     // Cache where all our extern crates are located\n-    for &(n, ref e) in krate.externs.iter() {\n+    for &(n, ref e) in &krate.externs {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n         cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n@@ -364,11 +364,11 @@ pub fn run(mut krate: clean::Crate,\n     // Favor linking to as local extern as possible, so iterate all crates in\n     // reverse topological order.\n     for &(n, ref e) in krate.externs.iter().rev() {\n-        for &prim in e.primitives.iter() {\n+        for &prim in &e.primitives {\n             cache.primitive_locations.insert(prim, n);\n         }\n     }\n-    for &prim in krate.primitives.iter() {\n+    for &prim in &krate.primitives {\n         cache.primitive_locations.insert(prim, ast::LOCAL_CRATE);\n     }\n \n@@ -402,7 +402,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n \n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n-        for &(pid, ref item) in orphan_methods.iter() {\n+        for &(pid, ref item) in orphan_methods {\n             let did = ast_util::local_def(pid);\n             match paths.get(&did) {\n                 Some(&(ref fqp, _)) => {\n@@ -420,7 +420,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<Stri\n \n         // Reduce `NodeId` in paths into smaller sequential numbers,\n         // and prune the paths that do not appear in the index.\n-        for item in search_index.iter() {\n+        for item in &*search_index {\n             match item.parent {\n                 Some(nodeid) => {\n                     if !nodeid_to_pathid.contains_key(&nodeid) {\n@@ -542,15 +542,15 @@ fn write_shared(cx: &Context,\n     let mut w = try!(File::create(&dst));\n     try!(writeln!(&mut w, \"var searchIndex = {{}};\"));\n     try!(writeln!(&mut w, \"{}\", search_index));\n-    for index in all_indexes.iter() {\n+    for index in &all_indexes {\n         try!(writeln!(&mut w, \"{}\", *index));\n     }\n     try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n     try!(mkdir(&dst));\n-    for (&did, imps) in cache.implementors.iter() {\n+    for (&did, imps) in &cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n@@ -564,7 +564,7 @@ fn write_shared(cx: &Context,\n         };\n \n         let mut mydst = dst.clone();\n-        for part in remote_path[..remote_path.len() - 1].iter() {\n+        for part in &remote_path[..remote_path.len() - 1] {\n             mydst.push(part.as_slice());\n             try!(mkdir(&mydst));\n         }\n@@ -578,12 +578,12 @@ fn write_shared(cx: &Context,\n         let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n         try!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"));\n \n-        for implementor in all_implementors.iter() {\n+        for implementor in &all_implementors {\n             try!(write!(&mut f, \"{}\", *implementor));\n         }\n \n         try!(write!(&mut f, r\"implementors['{}'] = [\", krate.name));\n-        for imp in imps.iter() {\n+        for imp in imps {\n             // If the trait and implementation are in the same crate, then\n             // there's no need to emit information about it (there's inlining\n             // going on). If they're in different crates then the crate defining\n@@ -679,10 +679,10 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    for attr in e.attrs.iter() {\n+    for attr in &e.attrs {\n         match *attr {\n             clean::List(ref x, ref list) if \"doc\" == *x => {\n-                for attr in list.iter() {\n+                for attr in list {\n                     match *attr {\n                         clean::NameValue(ref x, ref s)\n                                 if \"html_root_url\" == *x => {\n@@ -1043,7 +1043,7 @@ impl DocFolder for Cache {\n \n impl<'a> Cache {\n     fn generics(&mut self, generics: &clean::Generics) {\n-        for typ in generics.type_params.iter() {\n+        for typ in &generics.type_params {\n             self.typarams.insert(typ.did, typ.name.clone());\n         }\n     }\n@@ -1190,7 +1190,7 @@ impl Context {\n                                            .collect::<String>();\n                 match cache().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n-                        for name in (&names[..names.len() - 1]).iter() {\n+                        for name in &names[..names.len() - 1] {\n                             url.push_str(name.as_slice());\n                             url.push_str(\"/\");\n                         }\n@@ -1231,7 +1231,7 @@ impl Context {\n                         _ => unreachable!()\n                     };\n                     this.sidebar = this.build_sidebar(&m);\n-                    for item in m.items.into_iter() {\n+                    for item in m.items {\n                         f(this,item);\n                     }\n                     Ok(())\n@@ -1252,7 +1252,7 @@ impl Context {\n \n     fn build_sidebar(&self, m: &clean::Module) -> HashMap<String, Vec<NameDoc>> {\n         let mut map = HashMap::new();\n-        for item in m.items.iter() {\n+        for item in &m.items {\n             if self.ignore_private_item(item) { continue }\n \n             // avoid putting foreign items to the sidebar.\n@@ -1270,7 +1270,7 @@ impl Context {\n             v.push(NameDoc(myname, Some(shorter_line(item.doc_value()))));\n         }\n \n-        for (_, items) in map.iter_mut() {\n+        for (_, items) in &mut map {\n             items.sort();\n         }\n         return map;\n@@ -1536,7 +1536,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n     debug!(\"{:?}\", indices);\n     let mut curty = None;\n-    for &idx in indices.iter() {\n+    for &idx in &indices {\n         let myitem = &items[idx];\n \n         let myty = Some(shortty(myitem));\n@@ -1696,23 +1696,23 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"{{ }}\"));\n     } else {\n         try!(write!(w, \"{{\\n\"));\n-        for t in types.iter() {\n+        for t in &types {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, t.item()));\n             try!(write!(w, \";\\n\"));\n         }\n         if types.len() > 0 && required.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n-        for m in required.iter() {\n+        for m in &required {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m.item()));\n             try!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n-        for m in provided.iter() {\n+        for m in &provided {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m.item()));\n             try!(write!(w, \" {{ ... }}\\n\"));\n@@ -1741,7 +1741,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <h2 id='associated-types'>Associated Types</h2>\n             <div class='methods'>\n         \"));\n-        for t in types.iter() {\n+        for t in &types {\n             try!(trait_item(w, *t));\n         }\n         try!(write!(w, \"</div>\"));\n@@ -1753,7 +1753,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <h2 id='required-methods'>Required Methods</h2>\n             <div class='methods'>\n         \"));\n-        for m in required.iter() {\n+        for m in &required {\n             try!(trait_item(w, *m));\n         }\n         try!(write!(w, \"</div>\"));\n@@ -1763,7 +1763,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <h2 id='provided-methods'>Provided Methods</h2>\n             <div class='methods'>\n         \"));\n-        for m in provided.iter() {\n+        for m in &provided {\n             try!(trait_item(w, *m));\n         }\n         try!(write!(w, \"</div>\"));\n@@ -1776,7 +1776,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     \"));\n     match cache.implementors.get(&it.def_id) {\n         Some(implementors) => {\n-            for i in implementors.iter() {\n+            for i in implementors {\n                 try!(writeln!(w, \"<li>{}<code>impl{} {} for {}{}</code></li>\",\n                               ConciseStability(&i.stability),\n                               i.generics, i.trait_, i.for_, WhereClause(&i.generics)));\n@@ -1890,7 +1890,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \" {{}}\"));\n     } else {\n         try!(write!(w, \" {{\\n\"));\n-        for v in e.variants.iter() {\n+        for v in &e.variants {\n             try!(write!(w, \"    \"));\n             let name = v.name.as_ref().unwrap().as_slice();\n             match v.inner {\n@@ -1933,7 +1933,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(document(w, it));\n     if e.variants.len() > 0 {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n-        for variant in e.variants.iter() {\n+        for variant in &e.variants {\n             try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n                           stab = ConciseStability(&variant.stability),\n                           name = variant.name.as_ref().unwrap().as_slice()));\n@@ -1996,7 +1996,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         doctree::Plain => {\n             try!(write!(w, \" {{\\n{}\", tab));\n             let mut fields_stripped = false;\n-            for field in fields.iter() {\n+            for field in fields {\n                 match field.inner {\n                     clean::StructFieldItem(clean::HiddenStructField) => {\n                         fields_stripped = true;\n@@ -2049,7 +2049,7 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n                 .partition(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n-                for i in non_trait.iter() {\n+                for i in &non_trait {\n                     try!(render_impl(w, i));\n                 }\n             }\n@@ -2058,13 +2058,13 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n                                   Implementations</h2>\"));\n                 let (derived, manual): (Vec<_>, _) = traits.into_iter()\n                     .partition(|i| i.impl_.derived);\n-                for i in manual.iter() {\n+                for i in &manual {\n                     try!(render_impl(w, i));\n                 }\n                 if derived.len() > 0 {\n                     try!(write!(w, \"<h3 id='derived_implementations'>Derived Implementations \\\n                                 </h3>\"));\n-                    for i in derived.iter() {\n+                    for i in &derived {\n                         try!(render_impl(w, i));\n                     }\n                 }\n@@ -2137,14 +2137,14 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     }\n \n     try!(write!(w, \"<div class='impl-items'>\"));\n-    for trait_item in i.impl_.items.iter() {\n+    for trait_item in &i.impl_.items {\n         try!(doctraititem(w, trait_item, true));\n     }\n \n     fn render_default_methods(w: &mut fmt::Formatter,\n                               t: &clean::Trait,\n                               i: &clean::Impl) -> fmt::Result {\n-        for trait_item in t.items.iter() {\n+        for trait_item in &t.items {\n             let n = trait_item.item().name.clone();\n             match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n@@ -2209,7 +2209,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                 None => return Ok(())\n             };\n             try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n-            for &NameDoc(ref name, ref doc) in items.iter() {\n+            for &NameDoc(ref name, ref doc) in items {\n                 let curty = shortty(cur).to_static_str();\n                 let class = if cur.name.as_ref().unwrap() == name &&\n                                short == curty { \"current\" } else { \"\" };"}, {"sha": "7790c7d6a50f7262d2990c31c0d45488ec626015", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -185,7 +185,7 @@ impl fmt::Debug for Toc {\n impl fmt::Display for Toc {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"<ul>\"));\n-        for entry in self.entries.iter() {\n+        for entry in &self.entries {\n             // recursively format this table of contents (the\n             // `{children}` is the key).\n             try!(write!(fmt,"}, {"sha": "f4b8bbd5f8a518772bd64d88473e428ba94b2d24", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -200,11 +200,11 @@ pub fn main_args(args: &[String]) -> int {\n \n     if matches.opt_strs(\"passes\") == [\"list\"] {\n         println!(\"Available passes for running rustdoc:\");\n-        for &(name, _, description) in PASSES.iter() {\n+        for &(name, _, description) in PASSES {\n             println!(\"{:>20} - {}\", name, description);\n         }\n         println!(\"{}\", \"\\nDefault passes for rustdoc:\"); // FIXME: #9970\n-        for &name in DEFAULT_PASSES.iter() {\n+        for &name in DEFAULT_PASSES {\n             println!(\"{:>20}\", name);\n         }\n         return 0;\n@@ -220,7 +220,7 @@ pub fn main_args(args: &[String]) -> int {\n     let input = matches.free[0].as_slice();\n \n     let mut libs = SearchPaths::new();\n-    for s in matches.opt_strs(\"L\").iter() {\n+    for s in &matches.opt_strs(\"L\") {\n         libs.add_path(s.as_slice());\n     }\n     let externs = match parse_externs(&matches) {\n@@ -322,7 +322,7 @@ fn acquire_input(input: &str,\n /// error message.\n fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n-    for arg in matches.opt_strs(\"extern\").iter() {\n+    for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n@@ -356,7 +356,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // First, parse the crate and extract all relevant information.\n     let mut paths = SearchPaths::new();\n-    for s in matches.opt_strs(\"L\").iter() {\n+    for s in &matches.opt_strs(\"L\") {\n         paths.add_path(s.as_slice());\n     }\n     let cfgs = matches.opt_strs(\"cfg\");\n@@ -386,7 +386,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // with the passes which we are supposed to run.\n     match krate.module.as_ref().unwrap().doc_list() {\n         Some(nested) => {\n-            for inner in nested.iter() {\n+            for inner in nested {\n                 match *inner {\n                     clean::Word(ref x)\n                             if \"no_default_passes\" == *x => {\n@@ -420,7 +420,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let path = matches.opt_str(\"plugin-path\")\n                       .unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n     let mut pm = plugins::PluginManager::new(Path::new(path));\n-    for pass in passes.iter() {\n+    for pass in &passes {\n         let plugin = match PASSES.iter()\n                                  .position(|&(p, _, _)| {\n                                      p == *pass\n@@ -434,7 +434,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n         pm.add_plugin(plugin);\n     }\n     info!(\"loading plugins...\");\n-    for pname in plugins.into_iter() {\n+    for pname in plugins {\n         pm.load_plugin(pname);\n     }\n "}, {"sha": "365fb78cfae63cecbcf7073000fae4f7d12bce5d", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -47,7 +47,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n     output.set_extension(\"html\");\n \n     let mut css = String::new();\n-    for name in matches.opt_strs(\"markdown-css\").iter() {\n+    for name in &matches.opt_strs(\"markdown-css\") {\n         let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n         css.push_str(s.as_slice())\n     }"}, {"sha": "e1c6bf1f4cfdd341322a65e128377234f0df2f99", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -255,7 +255,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n             let mut i = i;\n             let mut avec: Vec<clean::Attribute> = Vec::new();\n-            for attr in i.attrs.iter() {\n+            for attr in &i.attrs {\n                 match attr {\n                     &clean::NameValue(ref x, ref s)\n                             if \"doc\" == *x => {\n@@ -280,7 +280,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n             let mut docstr = String::new();\n             let mut i = i;\n-            for attr in i.attrs.iter() {\n+            for attr in &i.attrs {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n                             if \"doc\" == *x => {"}, {"sha": "a2afba091f4a1f8aaf3ffc4248ac73741f14585c", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -64,7 +64,7 @@ impl PluginManager {\n     pub fn run_plugins(&self, krate: clean::Crate) -> (clean::Crate, Vec<PluginJson> ) {\n         let mut out_json = Vec::new();\n         let mut krate = krate;\n-        for &callback in self.callbacks.iter() {\n+        for &callback in &self.callbacks {\n             let (c, res) = callback(krate);\n             krate = c;\n             out_json.push(res);"}, {"sha": "5bcda778cbbb0d4284a3c924be7f4015985198f0", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.vis = vis;\n         om.stab = self.stability(id);\n         om.id = id;\n-        for i in m.items.iter() {\n+        for i in &m.items {\n             self.visit_item(&**i, None, &mut om);\n         }\n         om\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {\n-                            for i in m.items.iter() {\n+                            for i in &m.items {\n                                 self.visit_item(&**i, None, om);\n                             }\n                         }"}, {"sha": "d61d5b68462610ec82307d7625715505befa4b91", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -74,7 +74,7 @@ impl<\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n-            for (key, val) in self.iter() {\n+            for (key, val) in self {\n                 try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n                 try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n                 i += 1;\n@@ -107,7 +107,7 @@ impl<\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n-            for e in self.iter() {\n+            for e in self {\n                 try!(s.emit_seq_elt(i, |s| e.encode(s)));\n                 i += 1;\n             }\n@@ -135,7 +135,7 @@ impl<\n > Encodable for EnumSet<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let mut bits = 0;\n-        for item in self.iter() {\n+        for item in self {\n             bits |= item.to_uint();\n         }\n         s.emit_uint(bits)\n@@ -166,7 +166,7 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n-            for (key, val) in self.iter() {\n+            for (key, val) in self {\n                 try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n                 try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n                 i += 1;\n@@ -204,7 +204,7 @@ impl<T, S> Encodable for HashSet<T, S>\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n-            for e in self.iter() {\n+            for e in self {\n                 try!(s.emit_seq_elt(i, |s| e.encode(s)));\n                 i += 1;\n             }"}, {"sha": "a34ae1087dbbe3ccb5ec599cc014a8abf3aa3115", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -42,7 +42,7 @@ impl ToHex for [u8] {\n     /// ```\n     fn to_hex(&self) -> String {\n         let mut v = Vec::with_capacity(self.len() * 2);\n-        for &byte in self.iter() {\n+        for &byte in self {\n             v.push(CHARS[(byte >> 4) as uint]);\n             v.push(CHARS[(byte & 0xf) as uint]);\n         }"}, {"sha": "3bc9e699035da3b2f70eef1f2f2bb23aa87a69b4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1051,7 +1051,7 @@ impl Json {\n     /// Otherwise, it will return the Json value associated with the final key.\n     pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json>{\n         let mut target = self;\n-        for key in keys.iter() {\n+        for key in keys {\n             match target.find(*key) {\n                 Some(t) => { target = t; },\n                 None => return None\n@@ -1069,7 +1069,7 @@ impl Json {\n                 match map.get(key) {\n                     Some(json_value) => Some(json_value),\n                     None => {\n-                        for (_, v) in map.iter() {\n+                        for (_, v) in map {\n                             match v.search(key) {\n                                 x if x.is_some() => return x,\n                                 _ => ()\n@@ -1367,7 +1367,7 @@ impl Stack {\n     // Used by Parser to insert StackElement::Key elements at the top of the stack.\n     fn push_key(&mut self, key: string::String) {\n         self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n-        for c in key.as_bytes().iter() {\n+        for c in key.as_bytes() {\n             self.str_buffer.push(*c);\n         }\n     }\n@@ -2371,7 +2371,7 @@ impl ::Decoder for Decoder {\n     {\n         let obj = try!(expect!(self.pop(), Object));\n         let len = obj.len();\n-        for (key, value) in obj.into_iter() {\n+        for (key, value) in obj {\n             self.stack.push(value);\n             self.stack.push(Json::String(key));\n         }\n@@ -2497,7 +2497,7 @@ impl<A: ToJson> ToJson for Vec<A> {\n impl<A: ToJson> ToJson for BTreeMap<string::String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = BTreeMap::new();\n-        for (key, value) in self.iter() {\n+        for (key, value) in self {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Json::Object(d)\n@@ -2507,7 +2507,7 @@ impl<A: ToJson> ToJson for BTreeMap<string::String, A> {\n impl<A: ToJson> ToJson for HashMap<string::String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = BTreeMap::new();\n-        for (key, value) in self.iter() {\n+        for (key, value) in self {\n             d.insert((*key).clone(), value.to_json());\n         }\n         Json::Object(d)\n@@ -2670,7 +2670,7 @@ mod tests {\n     fn mk_object(items: &[(string::String, Json)]) -> Json {\n         let mut d = BTreeMap::new();\n \n-        for item in items.iter() {\n+        for item in items {\n             match *item {\n                 (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n             }\n@@ -3044,7 +3044,7 @@ mod tests {\n                  (\"\\\"\\\\u12ab\\\"\", \"\\u{12ab}\"),\n                  (\"\\\"\\\\uAB12\\\"\", \"\\u{AB12}\")];\n \n-        for &(i, o) in s.iter() {\n+        for &(i, o) in &s {\n             let v: string::String = super::decode(i).unwrap();\n             assert_eq!(v, o);\n         }"}, {"sha": "274c669d8dfc2ce902dafc027b35275a7006a6fd", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -134,15 +134,15 @@ impl AsciiExt<Vec<u8>> for [u8] {\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {\n-        for byte in self.iter_mut() {\n+        for byte in &mut self {\n             *byte = byte.to_ascii_uppercase();\n         }\n         self\n     }\n \n     #[inline]\n     fn into_ascii_lowercase(mut self) -> Vec<u8> {\n-        for byte in self.iter_mut() {\n+        for byte in &mut self {\n             *byte = byte.to_ascii_lowercase();\n         }\n         self\n@@ -232,7 +232,7 @@ pub fn escape_default<F>(c: u8, mut f: F) where\n         _ => {\n             f(b'\\\\');\n             f(b'x');\n-            for &offset in [4u, 0u].iter() {\n+            for &offset in &[4u, 0u] {\n                 match ((c as i32) >> offset) & 0xf {\n                     i @ 0 ... 9 => f(b'0' + (i as u8)),\n                     i => f(b'a' + (i as u8 - 10)),"}, {"sha": "ee091d1786b73faf2743f6bdf56593a2b6052bf2", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -20,7 +20,7 @@ use cmp::{max, Eq, PartialEq};\n use default::Default;\n use fmt::{self, Debug};\n use hash::{self, Hash, SipHasher};\n-use iter::{self, Iterator, ExactSizeIterator, IteratorExt, FromIterator, Extend, Map};\n+use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n use num::{Int, UnsignedInt};\n@@ -1385,6 +1385,42 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n+impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = IterMut<'a, K, V>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, K, V> {\n+        self.iter_mut()\n+    }\n+}\n+\n+impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = IntoIter<K, V>;\n+\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        self.into_iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n@@ -1539,7 +1575,7 @@ impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n+    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -1941,7 +1977,7 @@ mod test_map {\n \n         let mut observed: u32 = 0;\n \n-        for (k, v) in m.iter() {\n+        for (k, v) in &m {\n             assert_eq!(*v, *k * 2);\n             observed |= 1 << *k;\n         }\n@@ -2131,7 +2167,7 @@ mod test_map {\n \n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n-        for &(k, v) in xs.iter() {\n+        for &(k, v) in &xs {\n             assert_eq!(map.get(&k), Some(&v));\n         }\n     }"}, {"sha": "ae9fb9bca77913d143bc3fd8958e533fe6239775", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -18,7 +18,9 @@ use default::Default;\n use fmt::Debug;\n use fmt;\n use hash::{self, Hash};\n-use iter::{Iterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend};\n+use iter::{\n+    Iterator, IntoIterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend,\n+};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n \n@@ -634,7 +636,7 @@ impl<T, S, H> Extend<T> for HashSet<T, S>\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n-    fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) {\n+    fn extend<I: Iterator<Item=T>>(&mut self, iter: I) {\n         for k in iter {\n             self.insert(k);\n         }\n@@ -833,6 +835,30 @@ pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n+impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<T, S, H> IntoIterator for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n@@ -1007,7 +1033,7 @@ mod test_set {\n             assert!(a.insert(i));\n         }\n         let mut observed: u32 = 0;\n-        for k in a.iter() {\n+        for k in &a {\n             observed |= 1 << *k;\n         }\n         assert_eq!(observed, 0xFFFF_FFFF);\n@@ -1128,7 +1154,7 @@ mod test_set {\n \n         let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n \n-        for x in xs.iter() {\n+        for x in &xs {\n             assert!(set.contains(x));\n         }\n     }\n@@ -1214,7 +1240,7 @@ mod test_set {\n                 assert_eq!(last_i, 49);\n             }\n \n-            for _ in s.iter() { panic!(\"s should be empty!\"); }\n+            for _ in &s { panic!(\"s should be empty!\"); }\n \n             // reset to try again.\n             s.extend(1..100);"}, {"sha": "b8d770e6ad694e12734ac08d4c606b77ebdd0001", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -89,17 +89,6 @@ impl OsString {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ops::Index<ops::FullRange> for OsString {\n-    type Output = OsStr;\n-\n-    #[inline]\n-    fn index(&self, _index: &ops::FullRange) -> &OsStr {\n-        unsafe { mem::transmute(self.inner.as_slice()) }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl ops::Index<ops::RangeFull> for OsString {\n     type Output = OsStr;\n "}, {"sha": "47f5d64e2607cb11a024c488bb9a0c5f4137fa34", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -413,10 +413,6 @@ pub use core::fmt::{LowerExp, UpperExp};\n pub use core::fmt::Error;\n pub use core::fmt::{ArgumentV1, Arguments, write, radix, Radix, RadixFmt};\n \n-#[doc(hidden)]\n-#[cfg(stage0)]\n-pub use core::fmt::{argument, argumentuint};\n-\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///"}, {"sha": "839983d336d765e819cde518e8432b1c60731b4b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -120,14 +120,13 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![cfg_attr(not(stage0), feature(macro_reexport))]\n+#![feature(macro_reexport)]\n #![cfg_attr(test, feature(test))]\n \n // Don't link to std. We are std.\n #![no_std]\n \n #![deny(missing_docs)]\n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n \n #[cfg(test)]\n #[macro_use]"}, {"sha": "d729c2800ce13c3c134206866b219468fe0155e6", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -406,12 +406,12 @@ mod test {\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n \n         let mut writer = Vec::new();\n-        for i in uints.iter() {\n+        for i in &uints {\n             writer.write_le_u64(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer);\n-        for i in uints.iter() {\n+        for i in &uints {\n             assert!(reader.read_le_u64().unwrap() == *i);\n         }\n     }\n@@ -422,12 +422,12 @@ mod test {\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n \n         let mut writer = Vec::new();\n-        for i in uints.iter() {\n+        for i in &uints {\n             writer.write_be_u64(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer);\n-        for i in uints.iter() {\n+        for i in &uints {\n             assert!(reader.read_be_u64().unwrap() == *i);\n         }\n     }\n@@ -437,12 +437,12 @@ mod test {\n         let ints = [::i32::MIN, -123456, -42, -5, 0, 1, ::i32::MAX];\n \n         let mut writer = Vec::new();\n-        for i in ints.iter() {\n+        for i in &ints {\n             writer.write_be_i32(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer);\n-        for i in ints.iter() {\n+        for i in &ints {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n             assert!(reader.read_be_int_n(4).unwrap() == *i as i64);"}, {"sha": "abf215988bb4b859982967ee3dda5ceeb3294d65", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -597,7 +597,7 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n         return Ok(())\n     }\n \n-    let mut comps = path.components();\n+    let comps = path.components();\n     let mut curpath = path.root_path().unwrap_or(Path::new(\".\"));\n \n     for c in comps {\n@@ -649,7 +649,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n \n         // delete all regular files in the way and push subdirs\n         // on the stack\n-        for child in children.into_iter() {\n+        for child in children {\n             // FIXME(#12795) we should use lstat in all cases\n             let child_type = match cfg!(windows) {\n                 true => try!(update_err(stat(&child), path)),\n@@ -1110,7 +1110,7 @@ mod test {\n         }\n         let files = check!(readdir(dir));\n         let mut mem = [0u8; 4];\n-        for f in files.iter() {\n+        for f in &files {\n             {\n                 let n = f.filestem_str();\n                 check!(File::open(f).read(&mut mem));"}, {"sha": "2b7506b5c34a3f6edef804b3d0cf4abf30d29c0a", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -121,7 +121,7 @@ mod test {\n         let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n         let mut found_local = false;\n         let local_addr = &Ipv4Addr(127, 0, 0, 1);\n-        for addr in ipaddrs.iter() {\n+        for addr in &ipaddrs {\n             found_local = found_local || addr == local_addr;\n         }\n         assert!(found_local);"}, {"sha": "d85251795c887d254af8c696f8e57f9a2c9e5fb4", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n     // Return result of first successful parser\n     fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])\n                -> Option<T> {\n-        for pf in parsers.iter_mut() {\n+        for pf in parsers {\n             match self.read_atomically(|p: &mut Parser| pf.call_mut((p,))) {\n                 Some(r) => return Some(r),\n                 None => {}"}, {"sha": "bbe3a71dcc0d17a12057884758c81e22de430900", "filename": "src/libstd/old_io/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -36,7 +36,7 @@ fn with_addresses<A, T, F>(addr: A, mut action: F) -> IoResult<T> where\n \n     let addresses = try!(addr.to_socket_addr_all());\n     let mut err = DEFAULT_ERROR;\n-    for addr in addresses.into_iter() {\n+    for addr in addresses {\n         match action(addr) {\n             Ok(r) => return Ok(r),\n             Err(e) => err = e"}, {"sha": "61a07bc8208eda35ffc5b3a96b6e329943e621d9", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -401,7 +401,7 @@ impl fmt::Debug for Command {\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{:?}\", self.program));\n-        for arg in self.args.iter() {\n+        for arg in &self.args {\n             try!(write!(f, \" '{:?}'\", arg));\n         }\n         Ok(())\n@@ -1046,7 +1046,7 @@ mod tests {\n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n         let r = os::env();\n-        for &(ref k, ref v) in r.iter() {\n+        for &(ref k, ref v) in &r {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() ||\n                     output.contains(format!(\"{}={}\", *k, *v).as_slice()),\n@@ -1064,7 +1064,7 @@ mod tests {\n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n         let r = os::env();\n-        for &(ref k, ref v) in r.iter() {\n+        for &(ref k, ref v) in &r {\n             // don't check android RANDOM variables\n             if *k != \"RANDOM\".to_string() {\n                 assert!(output.contains(format!(\"{}={}\","}, {"sha": "ee72beccfa8488f61fa0f997809ea11b8bc8c3fa", "filename": "src/libstd/old_io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -92,7 +92,7 @@ fn base_port() -> u16 {\n \n     let mut final_base = base;\n \n-    for &(dir, base) in bases.iter() {\n+    for &(dir, base) in &bases {\n         if path_s.contains(dir) {\n             final_base = base;\n             break;"}, {"sha": "f78e3ac1f14dad01c1a2a4583b01026c70cf8b9d", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -144,15 +144,15 @@ impl<W> MultiWriter<W> where W: Writer {\n impl<W> Writer for MultiWriter<W> where W: Writer {\n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n-        for writer in self.writers.iter_mut() {\n+        for writer in &mut self.writers {\n             try!(writer.write_all(buf));\n         }\n         Ok(())\n     }\n \n     #[inline]\n     fn flush(&mut self) -> old_io::IoResult<()> {\n-        for writer in self.writers.iter_mut() {\n+        for writer in &mut self.writers {\n             try!(writer.flush());\n         }\n         Ok(())"}, {"sha": "d92f361af0bf24508fe18e9e4b11d5ed30aa5299", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -924,7 +924,7 @@ impl MemoryMap {\n         let mut custom_flags = false;\n         let len = round_up(min_len, env::page_size());\n \n-        for &o in options.iter() {\n+        for &o in options {\n             match o {\n                 MapReadable => { prot |= libc::PROT_READ; },\n                 MapWritable => { prot |= libc::PROT_WRITE; },\n@@ -1003,7 +1003,7 @@ impl MemoryMap {\n         let mut offset: uint = 0;\n         let len = round_up(min_len, env::page_size());\n \n-        for &o in options.iter() {\n+        for &o in options {\n             match o {\n                 MapReadable => { readable = true; },\n                 MapWritable => { writable = true; },\n@@ -1519,7 +1519,7 @@ mod tests {\n     fn test_env_getenv() {\n         let e = env();\n         assert!(e.len() > 0u);\n-        for p in e.iter() {\n+        for p in &e {\n             let (n, v) = (*p).clone();\n             debug!(\"{}\", n);\n             let v2 = getenv(n.as_slice());\n@@ -1574,7 +1574,7 @@ mod tests {\n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n \n-        for s in oldhome.iter() {\n+        if let Some(s) = oldhome {\n             setenv(\"HOME\", s.as_slice());\n         }\n     }\n@@ -1603,10 +1603,10 @@ mod tests {\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n         assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n \n-        for s in oldhome.iter() {\n+        if let Some(s) = oldhome {\n             setenv(\"HOME\", s.as_slice());\n         }\n-        for s in olduserprofile.iter() {\n+        if let Some(s) = olduserprofile {\n             setenv(\"USERPROFILE\", s.as_slice());\n         }\n     }"}, {"sha": "0d80258d7e04f1f3b590e30db7057f2b97bed0b9", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -68,8 +68,6 @@ use fmt;\n use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n-#[cfg(stage0)]\n-use ops::FullRange;\n use str;\n use str::StrExt;\n use string::{String, CowString};\n@@ -625,11 +623,11 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     fn push_many<T: BytesContainer>(&mut self, paths: &[T]) {\n         let t: Option<&T> = None;\n         if BytesContainer::is_str(t) {\n-            for p in paths.iter() {\n+            for p in paths {\n                 self.push(p.container_as_str().unwrap())\n             }\n         } else {\n-            for p in paths.iter() {\n+            for p in paths {\n                 self.push(p.container_as_bytes())\n             }\n         }"}, {"sha": "7ddd919c11e1fd858559bf78ec93edfd4e61886f", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -25,8 +25,6 @@ use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option::{self, Some, None};\n-#[cfg(stage0)]\n-use ops::FullRange;\n use result::Result::{self, Ok, Err};\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};"}, {"sha": "2398485afefb7ab481eaa38a0c18bd59ab941691", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -18,10 +18,6 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n-#[cfg(stage0)]\n-#[unstable(feature = \"std_misc\")]\n-#[doc(no_inline)] pub use ops::FullRange;\n-\n // Reexported functions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use mem::drop;"}, {"sha": "cc72c5bed99dc905102e3bffb0345abeb5f4676f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -464,7 +464,7 @@ mod test {\n         // check every remainder mod 8, both in small and big vectors.\n         let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n                        80, 81, 82, 83, 84, 85, 86, 87];\n-        for &n in lengths.iter() {\n+        for &n in &lengths {\n             let mut v = repeat(0u8).take(n).collect::<Vec<_>>();\n             r.fill_bytes(v.as_mut_slice());\n "}, {"sha": "4b45d5501c2351a2797c5d3f7c9ee86a913c1618", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -404,7 +404,7 @@ mod test {\n         }\n \n         // start all the tasks\n-        for tx in txs.iter() {\n+        for tx in &txs {\n             tx.send(()).unwrap();\n         }\n     }"}, {"sha": "3f15cf71ec3f74974e2f1fc8397ae1f9144c294b", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -58,7 +58,7 @@ pub fn cleanup() {\n         // If we never called init, not need to cleanup!\n         if queue as uint != 0 {\n             let queue: Box<Queue> = mem::transmute(queue);\n-            for to_run in queue.into_iter() {\n+            for to_run in *queue {\n                 to_run.invoke(());\n             }\n         }"}, {"sha": "81ca5aa0e8a6e3d4bc6aa332f4488daee05e202a", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -160,7 +160,7 @@ pub fn panicking() -> bool {\n // An uninlined, unmangled function upon which to slap yer breakpoints\n #[inline(never)]\n #[no_mangle]\n-#[cfg_attr(not(stage0), allow(private_no_mangle_fns))]\n+#[allow(private_no_mangle_fns)]\n fn rust_panic(cause: Box<Any + Send>) -> ! {\n     rtdebug!(\"begin_unwind()\");\n \n@@ -238,7 +238,7 @@ pub mod eabi {\n \n     #[lang=\"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n-    #[cfg_attr(not(stage0), allow(private_no_mangle_fns))]\n+    #[allow(private_no_mangle_fns)]\n     extern fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n@@ -551,7 +551,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n         let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n         &CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n     };\n-    for cb in callbacks.iter() {\n+    for cb in callbacks {\n         match cb.load(Ordering::SeqCst) {\n             0 => {}\n             n => {"}, {"sha": "2dfc708e15bebdc7386d96469e0451551b651251", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -508,7 +508,7 @@ mod tests {\n         }\n \n         // Wait for children to pass their asserts\n-        for r in children.into_iter() {\n+        for r in children {\n             assert!(r.join().is_ok());\n         }\n "}, {"sha": "833de8adda49dfbb41ce8fb95fa3dbf65a443279", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -554,7 +554,7 @@ pub fn await(fds: &[sock_t], deadline: Option<u64>,\n              status: SocketStatus) -> IoResult<()> {\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n     let mut max = 0;\n-    for &fd in fds.iter() {\n+    for &fd in fds {\n         c::fd_set(&mut set, fd);\n         max = cmp::max(max, fd + 1);\n     }"}, {"sha": "b30af10986b9952235c200e4de4a81db959d64e8", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -366,7 +366,7 @@ impl FromIterator<CodePoint> for Wtf8Buf {\n /// This replaces surrogate code point pairs with supplementary code points,\n /// like concatenating ill-formed UTF-16 strings effectively would.\n impl Extend<CodePoint> for Wtf8Buf {\n-    fn extend<T: Iterator<Item=CodePoint>>(&mut self, mut iterator: T) {\n+    fn extend<T: Iterator<Item=CodePoint>>(&mut self, iterator: T) {\n         let (low, _high) = iterator.size_hint();\n         // Lower bound of one byte per code point (ASCII only)\n         self.bytes.reserve(low);\n@@ -680,17 +680,6 @@ impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ops::Index<ops::FullRange> for Wtf8 {\n-    type Output = Wtf8;\n-\n-    #[inline]\n-    fn index(&self, _range: &ops::FullRange) -> &Wtf8 {\n-        self\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl ops::Index<ops::RangeFull> for Wtf8 {\n     type Output = Wtf8;\n "}, {"sha": "7e117b10a347c5ed80ffe46edb465a78d2836ff7", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -558,7 +558,7 @@ fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n         Some(env) => {\n             let mut tmps = Vec::with_capacity(env.len());\n \n-            for pair in env.iter() {\n+            for pair in env {\n                 let mut kv = Vec::new();\n                 kv.push_all(pair.0.container_as_bytes());\n                 kv.push('=' as u8);"}, {"sha": "3ca735f7fdfd347bfba8c86d39b9afe345c35bd5", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -142,12 +142,12 @@ impl Process {\n         // To have the spawning semantics of unix/windows stay the same, we need to\n         // read the *child's* PATH if one is provided. See #15149 for more details.\n         let program = cfg.env().and_then(|env| {\n-            for (key, v) in env.iter() {\n+            for (key, v) in env {\n                 if b\"PATH\" != key.container_as_bytes() { continue }\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n-                for path in os::split_paths(v.container_as_bytes()).into_iter() {\n+                for path in os::split_paths(v.container_as_bytes()) {\n                     let path = path.join(cfg.program().as_bytes())\n                                    .with_extension(env::consts::EXE_EXTENSION);\n                     if path.exists() {\n@@ -372,7 +372,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     let mut cmd = String::new();\n     append_arg(&mut cmd, str::from_utf8(prog.as_bytes()).ok()\n                              .expect(\"expected program name to be utf-8 encoded\"));\n-    for arg in args.iter() {\n+    for arg in args {\n         cmd.push(' ');\n         append_arg(&mut cmd, str::from_utf8(arg.as_bytes()).ok()\n                                 .expect(\"expected argument to be utf-8 encoded\"));\n@@ -437,7 +437,7 @@ fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T\n         Some(env) => {\n             let mut blk = Vec::new();\n \n-            for pair in env.iter() {\n+            for pair in env {\n                 let kv = format!(\"{}={}\",\n                                  pair.0.container_as_str().unwrap(),\n                                  pair.1.container_as_str().unwrap());"}, {"sha": "54a32e43daf5917909e1b5594b7003f646d71fa4", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -249,7 +249,7 @@ unsafe fn run_dtors() {\n             DTOR_LOCK.unlock();\n             ret\n         };\n-        for &(key, dtor) in dtors.iter() {\n+        for &(key, dtor) in &dtors {\n             let ptr = TlsGetValue(key);\n             if !ptr.is_null() {\n                 TlsSetValue(key, ptr::null_mut());"}, {"sha": "d4d777789dd5db204c8b45af81bb5f8e0f453de5", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -425,7 +425,7 @@ mod imp {\n         unsafe extern fn run_dtors(mut ptr: *mut u8) {\n             while !ptr.is_null() {\n                 let list: Box<List> = mem::transmute(ptr);\n-                for &(ptr, dtor) in list.iter() {\n+                for &(ptr, dtor) in &*list {\n                     dtor(ptr);\n                 }\n                 ptr = DTORS.get();"}, {"sha": "5535e5911e0c2fd5e85ae763a14dcaef7e18915a", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -730,7 +730,7 @@ impl<'ast> NodeCollector<'ast> {\n     }\n \n     fn visit_fn_decl(&mut self, decl: &'ast FnDecl) {\n-        for a in decl.inputs.iter() {\n+        for a in &decl.inputs {\n             self.insert(a.id, NodeArg(&*a.pat));\n         }\n     }\n@@ -743,7 +743,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = i.id;\n         match i.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         MethodImplItem(ref m) => {\n                             self.insert(m.id, NodeImplItem(impl_item));\n@@ -755,12 +755,12 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n-                for v in enum_definition.variants.iter() {\n+                for v in &enum_definition.variants {\n                     self.insert(v.node.id, NodeVariant(&**v));\n                 }\n             }\n             ItemForeignMod(ref nm) => {\n-                for nitem in nm.items.iter() {\n+                for nitem in &nm.items {\n                     self.insert(nitem.id, NodeForeignItem(&**nitem));\n                 }\n             }\n@@ -774,13 +774,13 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                 }\n             }\n             ItemTrait(_, _, ref bounds, ref trait_items) => {\n-                for b in bounds.iter() {\n+                for b in &**bounds {\n                     if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n                         self.insert(t.trait_ref.ref_id, NodeItem(i));\n                     }\n                 }\n \n-                for tm in trait_items.iter() {\n+                for tm in trait_items {\n                     match *tm {\n                         RequiredMethod(ref m) => {\n                             self.insert(m.id, NodeTraitItem(tm));"}, {"sha": "c62f76564a7013ada7ba7c1ff4ee0899293d4e66", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -316,7 +316,7 @@ pub fn split_trait_methods(trait_methods: &[TraitItem])\n                            -> (Vec<TypeMethod>, Vec<P<Method>> ) {\n     let mut reqd = Vec::new();\n     let mut provd = Vec::new();\n-    for trt_method in trait_methods.iter() {\n+    for trt_method in trait_methods {\n         match *trt_method {\n             RequiredMethod(ref tm) => reqd.push((*tm).clone()),\n             ProvidedMethod(ref m) => provd.push((*m).clone()),\n@@ -405,10 +405,10 @@ pub struct IdVisitor<'a, O:'a> {\n \n impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n     fn visit_generics_helper(&mut self, generics: &Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n+        for type_parameter in &*generics.ty_params {\n             self.operation.visit_id(type_parameter.id)\n         }\n-        for lifetime in generics.lifetimes.iter() {\n+        for lifetime in &generics.lifetimes {\n             self.operation.visit_id(lifetime.lifetime.id)\n         }\n     }\n@@ -444,14 +444,14 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n                     ViewPathSimple(_, _) |\n                     ViewPathGlob(_) => {}\n                     ViewPathList(_, ref paths) => {\n-                        for path in paths.iter() {\n+                        for path in paths {\n                             self.operation.visit_id(path.node.id())\n                         }\n                     }\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n-                for variant in enum_definition.variants.iter() {\n+                for variant in &enum_definition.variants {\n                     self.operation.visit_id(variant.node.id)\n                 }\n             }\n@@ -525,7 +525,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n             visit::FkFnBlock => {}\n         }\n \n-        for argument in function_declaration.inputs.iter() {\n+        for argument in &function_declaration.inputs {\n             self.operation.visit_id(argument.id)\n         }\n "}, {"sha": "301a18892d8e3684d6b6688878550771be4a3f0c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -373,7 +373,7 @@ impl fmt::Display for StabilityLevel {\n fn find_stability_generic<'a,\n                               AM: AttrMetaMethods,\n                               I: Iterator<Item=&'a AM>>\n-                             (diagnostic: &SpanHandler, mut attrs: I, item_sp: Span)\n+                             (diagnostic: &SpanHandler, attrs: I, item_sp: Span)\n                              -> (Option<Stability>, Vec<&'a AM>) {\n \n     let mut stab: Option<Stability> = None;\n@@ -394,7 +394,7 @@ fn find_stability_generic<'a,\n                 let mut feature = None;\n                 let mut since = None;\n                 let mut reason = None;\n-                for meta in metas.iter() {\n+                for meta in metas {\n                     if meta.name().get() == \"feature\" {\n                         match meta.value_str() {\n                             Some(v) => feature = Some(v),\n@@ -490,13 +490,13 @@ fn find_stability_generic<'a,\n pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n     let (s, used) = find_stability_generic(diagnostic, attrs.iter(), item_sp);\n-    for used in used.into_iter() { mark_used(used) }\n+    for used in used { mark_used(used) }\n     return s;\n }\n \n pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n-    for meta in metas.iter() {\n+    for meta in metas {\n         let name = meta.name();\n \n         if !set.insert(name.clone()) {\n@@ -518,7 +518,7 @@ pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAt\n     match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if *s == \"repr\" => {\n             mark_used(attr);\n-            for item in items.iter() {\n+            for item in items {\n                 match item.node {\n                     ast::MetaWord(ref word) => {\n                         let hint = match word.get() {"}, {"sha": "00857d10f439e763e4cdb3af4cbf160d09f0fc39", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -453,7 +453,7 @@ impl CodeMap {\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n-        for fm in self.files.borrow().iter() {\n+        for fm in &*self.files.borrow() {\n             if filename == fm.name {\n                 return fm.clone();\n             }\n@@ -477,7 +477,7 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        for mbc in map.multibyte_chars.borrow().iter() {\n+        for mbc in &*map.multibyte_chars.borrow() {\n             debug!(\"{}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 // every character is at least one byte, so we only"}, {"sha": "d22054d8ed0c44a45a5668887a852653ed7e22cc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -461,7 +461,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         elided = true;\n     }\n     // Print the offending lines\n-    for &line_number in display_lines.iter() {\n+    for &line_number in display_lines {\n         if let Some(line) = fm.get_line(line_number) {\n             try!(write!(&mut err.dst, \"{}:{} {}\\n\", fm.name,\n                         line_number + 1, line));\n@@ -550,7 +550,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                         last_line_number + 1, last_line));\n         }\n     } else {\n-        for &line_number in lines.iter() {\n+        for &line_number in lines {\n             if let Some(line) = fm.get_line(line_number) {\n                 try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n                             line_number + 1, line));"}, {"sha": "4e10cc9aacc08cf1e625f3b10e890d5153fb165f", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -25,7 +25,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n         None => return base::DummyResult::expr(sp)\n     };\n     let mut accumulator = String::new();\n-    for e in es.into_iter() {\n+    for e in es {\n         match e.node {\n             ast::ExprLit(ref lit) => {\n                 match lit.node {"}, {"sha": "02982039be0a3bf5a9ed8921bb1407d32d91c205", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -427,7 +427,7 @@ impl<'a> TraitDef<'a> {\n             bounds.push(cx.typarambound(trait_path.clone()));\n \n             // also add in any bounds from the declaration\n-            for declared_bound in ty_param.bounds.iter() {\n+            for declared_bound in &*ty_param.bounds {\n                 bounds.push((*declared_bound).clone());\n             }\n \n@@ -974,7 +974,7 @@ impl<'a> MethodDef<'a> {\n                     subpats.push(p);\n                     idents\n                 };\n-                for self_arg_name in self_arg_names.tail().iter() {\n+                for self_arg_name in self_arg_names.tail() {\n                     let (p, idents) = mk_self_pat(cx, &self_arg_name[]);\n                     subpats.push(p);\n                     self_pats_idents.push(idents);"}, {"sha": "efd9322661862b480226e6c9abb66ff95e1b2a5a", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -100,7 +100,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         _ => cx.span_bug(trait_span, \"impossible substructure in `derive(Hash)`\")\n     };\n \n-    for &FieldInfo { ref self_, span, .. } in fields.iter() {\n+    for &FieldInfo { ref self_, span, .. } in fields {\n         stmts.push(call_hash(span, self_.clone()));\n     }\n "}, {"sha": "ae7b20f7853fb0bd52f2f1f30142e02c81d848d6", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -93,7 +93,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n \n             let mut arms = Vec::new();\n \n-            for variant in enum_def.variants.iter() {\n+            for variant in &enum_def.variants {\n                 match variant.node.kind {\n                     ast::TupleVariantKind(ref args) => {\n                         if !args.is_empty() {"}, {"sha": "6eacb3440189454f279f31b05b9a03e3ac16eed7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -504,7 +504,7 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n         return it.expect_item();\n     }\n \n-    for attr in modifiers.iter() {\n+    for attr in &modifiers {\n         let mname = attr.name();\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n@@ -552,7 +552,7 @@ fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Ite\n \n // does this attribute list contain \"macro_use\" ?\n fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n-    for attr in attrs.iter() {\n+    for attr in attrs {\n         let mut is_use = attr.check_name(\"macro_use\");\n         if attr.check_name(\"macro_escape\") {\n             fld.cx.span_warn(attr.span, \"macro_escape is a deprecated synonym for macro_use\");\n@@ -853,7 +853,7 @@ impl<'v> Visitor<'v> for PatIdentFinder {\n             ast::Pat { id: _, node: ast::PatIdent(_, ref path1, ref inner), span: _ } => {\n                 self.ident_accumulator.push(path1.node);\n                 // visit optional subpattern of PatIdent:\n-                for subpat in inner.iter() {\n+                if let Some(ref subpat) = *inner {\n                     self.visit_pat(&**subpat)\n                 }\n             }\n@@ -873,7 +873,7 @@ fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n /// find the PatIdent paths in a\n fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n     let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n-    for arg in fn_decl.inputs.iter() {\n+    for arg in &fn_decl.inputs {\n         pat_idents.visit_pat(&*arg.pat);\n     }\n     pat_idents.ident_accumulator\n@@ -1063,7 +1063,7 @@ fn expand_annotatable(a: Annotatable,\n \n     let mut decorator_items = SmallVector::zero();\n     let mut new_attrs = Vec::new();\n-    for attr in a.attrs().iter() {\n+    for attr in a.attrs() {\n         let mname = attr.name();\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n@@ -1218,7 +1218,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n         return it\n     }\n \n-    for attr in modifiers.iter() {\n+    for attr in &modifiers {\n         let mname = attr.name();\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n@@ -1420,11 +1420,11 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander::new(&mut cx);\n \n-    for def in imported_macros.into_iter() {\n+    for def in imported_macros {\n         expander.cx.insert_macro(def);\n     }\n \n-    for (name, extension) in user_exts.into_iter() {\n+    for (name, extension) in user_exts {\n         expander.cx.syntax_env.insert(name, extension);\n     }\n "}, {"sha": "16aaccb0207a2d4beed76bc1e2b6a0c07db2d23f", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                                             self.ecx.expr_ident(e.span, name)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n-        for name in self.name_ordering.iter() {\n+        for name in &self.name_ordering {\n             let e = match self.names.remove(name) {\n                 Some(e) => e,\n                 None => continue\n@@ -706,7 +706,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n         }\n     }\n-    for (name, e) in cx.names.iter() {\n+    for (name, e) in &cx.names {\n         if !cx.name_types.contains_key(name) {\n             cx.ecx.span_err(e.span, \"named argument never used\");\n         }"}, {"sha": "9092169e1820067e1f7a4833e6e3b29792639626", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -694,7 +694,7 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n \n fn mk_tts(cx: &ExtCtxt, tts: &[ast::TokenTree]) -> Vec<P<ast::Stmt>> {\n     let mut ss = Vec::new();\n-    for tt in tts.iter() {\n+    for tt in tts {\n         ss.extend(mk_tt(cx, tt).into_iter());\n     }\n     ss"}, {"sha": "823efdd3eed225362d1f46ac3ab6a47a1dad22fa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -209,12 +209,12 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n              ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut usize) {\n         match m {\n             &TtSequence(_, ref seq) => {\n-                for next_m in seq.tts.iter() {\n+                for next_m in &seq.tts {\n                     n_rec(p_s, next_m, res, ret_val, idx)\n                 }\n             }\n             &TtDelimited(_, ref delim) => {\n-                for next_m in delim.tts.iter() {\n+                for next_m in &delim.tts {\n                     n_rec(p_s, next_m, res, ret_val, idx)\n                 }\n             }\n@@ -239,7 +239,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n     }\n     let mut ret_val = HashMap::new();\n     let mut idx = 0;\n-    for m in ms.iter() { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n+    for m in ms { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n     ret_val\n }\n \n@@ -444,7 +444,7 @@ pub fn parse(sess: &ParseSess,\n         if token_name_eq(&tok, &token::Eof) {\n             if eof_eis.len() == 1 {\n                 let mut v = Vec::new();\n-                for dv in (&mut eof_eis[0]).matches.iter_mut() {\n+                for dv in &mut (&mut eof_eis[0]).matches {\n                     v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, &v[]));"}, {"sha": "ac9f375e0a4a90535f1aa9ac299423d9c521102d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -259,7 +259,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n-    for lhs in lhses.iter() {\n+    for lhs in &lhses {\n         check_lhs_nt_follows(cx, &**lhs, def.span);\n     }\n "}, {"sha": "4e76359e93040d80f731e5f726501f7aed83cc76", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, i: &ast::Item) {\n-        for attr in i.attrs.iter() {\n+        for attr in &i.attrs {\n             if attr.name() == \"thread_local\" {\n                 self.gate_feature(\"thread_local\", i.span,\n                                   \"`#[thread_local]` is an experimental feature, and does not \\\n@@ -508,7 +508,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n \n     let mut unknown_features = Vec::new();\n \n-    for attr in krate.attrs.iter() {\n+    for attr in &krate.attrs {\n         if !attr.check_name(\"feature\") {\n             continue\n         }\n@@ -519,7 +519,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n                                                   expected #![feature(...)]\");\n             }\n             Some(list) => {\n-                for mi in list.iter() {\n+                for mi in list {\n                     let name = match mi.node {\n                         ast::MetaWord(ref word) => (*word).clone(),\n                         _ => {"}, {"sha": "9012ec2114d07462f6b3783183ba3dea8953df6c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -37,7 +37,7 @@ pub trait MoveMap<T> {\n \n impl<T> MoveMap<T> for Vec<T> {\n     fn move_map<F>(mut self, mut f: F) -> Vec<T> where F: FnMut(T) -> T {\n-        for p in self.iter_mut() {\n+        for p in &mut self {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n                 ptr::write(p, f(ptr::read_and_zero(p)));\n@@ -1117,7 +1117,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n         }, vec![], span)\n     };\n \n-    for def in exported_macros.iter_mut() {\n+    for def in &mut exported_macros {\n         def.id = folder.new_id(def.id);\n     }\n "}, {"sha": "08e795ef80d046002a7fd6eb1f40ca6a592b4eab", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -23,8 +23,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]"}, {"sha": "b17fc7fe82e6c66b09da7c36c0b9cd80b239fb34", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -90,7 +90,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut i = usize::MAX;\n         let mut can_trim = true;\n         let mut first = true;\n-        for line in lines.iter() {\n+        for line in &lines {\n             for (j, c) in line.chars().enumerate() {\n                 if j > i || !\"* \\t\".contains_char(c) {\n                     can_trim = false;\n@@ -125,7 +125,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n     // one-line comments lose their prefix\n     static ONLINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n-    for prefix in ONLINERS.iter() {\n+    for prefix in ONLINERS {\n         if comment.starts_with(*prefix) {\n             return (&comment[prefix.len()..]).to_string();\n         }"}, {"sha": "e6da47304cee39cebf6ce3b96c34b4007d2ed9b9", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1526,7 +1526,7 @@ mod test {\n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n     fn check_tokenization (mut string_reader: StringReader, expected: Vec<token::Token> ) {\n-        for expected_tok in expected.iter() {\n+        for expected_tok in &expected {\n             assert_eq!(&string_reader.next_token().tok, expected_tok);\n         }\n     }"}, {"sha": "72e4a74bc7355ff682dfcc86ead49191716f208c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1164,7 +1164,7 @@ mod test {\n                     \"impl z { fn a (self: Foo, &myarg: i32) {} }\",\n                     ];\n \n-        for &src in srcs.iter() {\n+        for &src in &srcs {\n             let spans = get_spans_of_pat_idents(src);\n             let Span{ lo, hi, .. } = spans[0];\n             assert!(\"self\" == &src[lo.to_usize()..hi.to_usize()],"}, {"sha": "c56734439eb145dde0428a06ac58637bde632b1f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -2713,7 +2713,7 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::Eof => {\n                 let open_braces = self.open_braces.clone();\n-                for sp in open_braces.iter() {\n+                for sp in &open_braces {\n                     self.span_help(*sp, \"did you mean to close this delimiter?\");\n                 }\n                 // There shouldn't really be a span, but it's easier for the test runner\n@@ -5207,7 +5207,7 @@ impl<'a> Parser<'a> {\n             Some(i) => {\n                 let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n-                for p in included_mod_stack[i.. len].iter() {\n+                for p in &included_mod_stack[i.. len] {\n                     err.push_str(&p.display().as_cow()[]);\n                     err.push_str(\" -> \");\n                 }\n@@ -5452,7 +5452,7 @@ impl<'a> Parser<'a> {\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_ty_sum()\n                 );\n-                for ty in arg_tys.into_iter() {\n+                for ty in arg_tys {\n                     args.push(ast::VariantArg {\n                         ty: ty,\n                         id: ast::DUMMY_NODE_ID,"}, {"sha": "e6d895a49fcd77896657f8e1bedfaf6527e73f0f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -593,7 +593,7 @@ impl<'a> State<'a> {\n     {\n         try!(self.rbox(0, b));\n         let mut first = true;\n-        for elt in elts.iter() {\n+        for elt in elts {\n             if first { first = false; } else { try!(self.word_space(\",\")); }\n             try!(op(self, elt));\n         }\n@@ -612,7 +612,7 @@ impl<'a> State<'a> {\n         try!(self.rbox(0, b));\n         let len = elts.len();\n         let mut i = 0;\n-        for elt in elts.iter() {\n+        for elt in elts {\n             try!(self.maybe_print_comment(get_span(elt).hi));\n             try!(op(self, elt));\n             i += 1;\n@@ -634,7 +634,7 @@ impl<'a> State<'a> {\n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n                      attrs: &[ast::Attribute]) -> IoResult<()> {\n         try!(self.print_inner_attributes(attrs));\n-        for item in _mod.items.iter() {\n+        for item in &_mod.items {\n             try!(self.print_item(&**item));\n         }\n         Ok(())\n@@ -643,16 +643,16 @@ impl<'a> State<'a> {\n     pub fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod,\n                              attrs: &[ast::Attribute]) -> IoResult<()> {\n         try!(self.print_inner_attributes(attrs));\n-        for item in nmod.items.iter() {\n+        for item in &nmod.items {\n             try!(self.print_foreign_item(&**item));\n         }\n         Ok(())\n     }\n \n     pub fn print_opt_lifetime(&mut self,\n                               lifetime: &Option<ast::Lifetime>) -> IoResult<()> {\n-        for l in lifetime.iter() {\n-            try!(self.print_lifetime(l));\n+        if let Some(l) = *lifetime {\n+            try!(self.print_lifetime(&l));\n             try!(self.nbsp());\n         }\n         Ok(())\n@@ -799,7 +799,7 @@ impl<'a> State<'a> {\n             ast::ItemExternCrate(ref optional_path) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"extern crate\")[]));\n-                for &(ref p, style) in optional_path.iter() {\n+                if let Some((ref p, style)) = *optional_path {\n                     try!(self.print_string(p.get(), style));\n                     try!(space(&mut self.s));\n                     try!(word(&mut self.s, \"as\"));\n@@ -945,7 +945,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes(&item.attrs[]));\n-                for impl_item in impl_items.iter() {\n+                for impl_item in impl_items {\n                     match *impl_item {\n                         ast::MethodImplItem(ref meth) => {\n                             try!(self.print_method(&**meth));\n@@ -966,7 +966,7 @@ impl<'a> State<'a> {\n                 try!(self.print_generics(generics));\n                 let bounds: Vec<_> = bounds.iter().map(|b| b.clone()).collect();\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n-                for b in bounds.into_iter() {\n+                for b in bounds {\n                     if let TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = b {\n                         try!(space(&mut self.s));\n                         try!(self.word_space(\"for ?\"));\n@@ -979,7 +979,7 @@ impl<'a> State<'a> {\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n-                for meth in methods.iter() {\n+                for meth in methods {\n                     try!(self.print_trait_method(meth));\n                 }\n                 try!(self.bclose(item.span));\n@@ -1010,7 +1010,7 @@ impl<'a> State<'a> {\n         if !t.bound_lifetimes.is_empty() {\n             try!(word(&mut self.s, \"for<\"));\n             let mut comma = false;\n-            for lifetime_def in t.bound_lifetimes.iter() {\n+            for lifetime_def in &t.bound_lifetimes {\n                 if comma {\n                     try!(self.word_space(\",\"))\n                 }\n@@ -1039,7 +1039,7 @@ impl<'a> State<'a> {\n                           variants: &[P<ast::Variant>],\n                           span: codemap::Span) -> IoResult<()> {\n         try!(self.bopen());\n-        for v in variants.iter() {\n+        for v in variants {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n             try!(self.print_outer_attributes(&v.node.attrs[]));\n@@ -1094,7 +1094,7 @@ impl<'a> State<'a> {\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());\n \n-            for field in struct_def.fields.iter() {\n+            for field in &struct_def.fields {\n                 match field.node.kind {\n                     ast::UnnamedField(..) => panic!(\"unexpected unnamed field\"),\n                     ast::NamedField(ident, visibility) => {\n@@ -1141,7 +1141,7 @@ impl<'a> State<'a> {\n             },\n             ast::TtSequence(_, ref seq) => {\n                 try!(word(&mut self.s, \"$(\"));\n-                for tt_elt in seq.tts.iter() {\n+                for tt_elt in &seq.tts {\n                     try!(self.print_tt(tt_elt));\n                 }\n                 try!(word(&mut self.s, \")\"));\n@@ -1278,7 +1278,7 @@ impl<'a> State<'a> {\n     pub fn print_outer_attributes(&mut self,\n                                   attrs: &[ast::Attribute]) -> IoResult<()> {\n         let mut count = 0;\n-        for attr in attrs.iter() {\n+        for attr in attrs {\n             match attr.node.style {\n                 ast::AttrOuter => {\n                     try!(self.print_attribute(attr));\n@@ -1296,7 +1296,7 @@ impl<'a> State<'a> {\n     pub fn print_inner_attributes(&mut self,\n                                   attrs: &[ast::Attribute]) -> IoResult<()> {\n         let mut count = 0;\n-        for attr in attrs.iter() {\n+        for attr in attrs {\n             match attr.node.style {\n                 ast::AttrInner => {\n                     try!(self.print_attribute(attr));\n@@ -1395,7 +1395,7 @@ impl<'a> State<'a> {\n \n         try!(self.print_inner_attributes(attrs));\n \n-        for st in blk.stmts.iter() {\n+        for st in &blk.stmts {\n             try!(self.print_stmt(&**st));\n         }\n         match blk.expr {\n@@ -1691,8 +1691,8 @@ impl<'a> State<'a> {\n                 try!(self.print_if_let(&**pat, &**expr, &** blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             ast::ExprWhile(ref test, ref blk, opt_ident) => {\n-                for ident in opt_ident.iter() {\n-                    try!(self.print_ident(*ident));\n+                if let Some(ident) = opt_ident {\n+                    try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while\"));\n@@ -1701,8 +1701,8 @@ impl<'a> State<'a> {\n                 try!(self.print_block(&**blk));\n             }\n             ast::ExprWhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n-                for ident in opt_ident.iter() {\n-                    try!(self.print_ident(*ident));\n+                if let Some(ident) = opt_ident {\n+                    try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while let\"));\n@@ -1714,8 +1714,8 @@ impl<'a> State<'a> {\n                 try!(self.print_block(&**blk));\n             }\n             ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n-                for ident in opt_ident.iter() {\n-                    try!(self.print_ident(*ident));\n+                if let Some(ident) = opt_ident {\n+                    try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"for\"));\n@@ -1727,8 +1727,8 @@ impl<'a> State<'a> {\n                 try!(self.print_block(&**blk));\n             }\n             ast::ExprLoop(ref blk, opt_ident) => {\n-                for ident in opt_ident.iter() {\n-                    try!(self.print_ident(*ident));\n+                if let Some(ident) = opt_ident {\n+                    try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"loop\"));\n@@ -1742,7 +1742,7 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n-                for arm in arms.iter() {\n+                for arm in arms {\n                     try!(self.print_arm(arm));\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n@@ -1825,16 +1825,16 @@ impl<'a> State<'a> {\n             ast::ExprBreak(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n-                for ident in opt_ident.iter() {\n-                    try!(self.print_ident(*ident));\n+                if let Some(ident) = opt_ident {\n+                    try!(self.print_ident(ident));\n                     try!(space(&mut self.s));\n                 }\n             }\n             ast::ExprAgain(opt_ident) => {\n                 try!(word(&mut self.s, \"continue\"));\n                 try!(space(&mut self.s));\n-                for ident in opt_ident.iter() {\n-                    try!(self.print_ident(*ident));\n+                if let Some(ident) = opt_ident {\n+                    try!(self.print_ident(ident));\n                     try!(space(&mut self.s))\n                 }\n             }\n@@ -1991,7 +1991,7 @@ impl<'a> State<'a> {\n         }\n \n         let mut first = true;\n-        for segment in path.segments.iter() {\n+        for segment in &path.segments {\n             if first {\n                 first = false\n             } else {\n@@ -2040,7 +2040,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"<\"));\n \n                 let mut comma = false;\n-                for lifetime in data.lifetimes.iter() {\n+                for lifetime in &data.lifetimes {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n@@ -2059,7 +2059,7 @@ impl<'a> State<'a> {\n                         comma = true;\n                 }\n \n-                for binding in data.bindings.iter() {\n+                for binding in &*data.bindings {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n@@ -2193,7 +2193,7 @@ impl<'a> State<'a> {\n                 try!(self.commasep(Inconsistent,\n                                    &before[],\n                                    |s, p| s.print_pat(&**p)));\n-                for p in slice.iter() {\n+                if let Some(ref p) = *slice {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n                     try!(self.print_pat(&**p));\n                     match **p {\n@@ -2224,7 +2224,7 @@ impl<'a> State<'a> {\n         try!(self.ibox(0));\n         try!(self.print_outer_attributes(&arm.attrs[]));\n         let mut first = true;\n-        for p in arm.pats.iter() {\n+        for p in &arm.pats {\n             if first {\n                 first = false;\n             } else {\n@@ -2309,7 +2309,7 @@ impl<'a> State<'a> {\n         // self type and the args all in the same box.\n         try!(self.rbox(0, Inconsistent));\n         let mut first = true;\n-        for &explicit_self in opt_explicit_self.iter() {\n+        if let Some(explicit_self) = opt_explicit_self {\n             let m = match explicit_self {\n                 &ast::SelfStatic => ast::MutImmutable,\n                 _ => match decl.inputs[0].pat.node {\n@@ -2327,7 +2327,7 @@ impl<'a> State<'a> {\n             &decl.inputs[1..]\n         };\n \n-        for arg in args.iter() {\n+        for arg in args {\n             if first { first = false; } else { try!(self.word_space(\",\")); }\n             try!(self.print_arg(arg));\n         }\n@@ -2397,7 +2397,7 @@ impl<'a> State<'a> {\n         if !bounds.is_empty() {\n             try!(word(&mut self.s, prefix));\n             let mut first = true;\n-            for bound in bounds.iter() {\n+            for bound in bounds {\n                 try!(self.nbsp());\n                 if first {\n                     first = false;\n@@ -2437,7 +2437,7 @@ impl<'a> State<'a> {\n     {\n         try!(self.print_lifetime(&lifetime.lifetime));\n         let mut sep = \":\";\n-        for v in lifetime.bounds.iter() {\n+        for v in &lifetime.bounds {\n             try!(word(&mut self.s, sep));\n             try!(self.print_lifetime(v));\n             sep = \"+\";\n@@ -2792,7 +2792,7 @@ impl<'a> State<'a> {\n             }\n             ast::LitBinary(ref v) => {\n                 let mut escaped: String = String::new();\n-                for &ch in v.iter() {\n+                for &ch in &**v {\n                     ascii::escape_default(ch as u8,\n                                           |ch| escaped.push(ch as char));\n                 }\n@@ -2842,7 +2842,7 @@ impl<'a> State<'a> {\n             }\n             comments::Isolated => {\n                 try!(self.hardbreak_if_not_bol());\n-                for line in cmnt.lines.iter() {\n+                for line in &cmnt.lines {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n@@ -2859,7 +2859,7 @@ impl<'a> State<'a> {\n                     hardbreak(&mut self.s)\n                 } else {\n                     try!(self.ibox(0));\n-                    for line in cmnt.lines.iter() {\n+                    for line in &cmnt.lines {\n                         if !line.is_empty() {\n                             try!(word(&mut self.s, &line[]));\n                         }"}, {"sha": "511442675194e77661b4a167bdfcddf67e247bfc", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -40,7 +40,7 @@ impl<T: Eq + Hash<Hasher> + Clone + 'static> Interner<T> {\n \n     pub fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n-        for v in init.iter() {\n+        for v in init {\n             rv.intern((*v).clone());\n         }\n         rv\n@@ -158,7 +158,7 @@ impl StrInterner {\n \n     pub fn prefill(init: &[&str]) -> StrInterner {\n         let rv = StrInterner::new();\n-        for &v in init.iter() { rv.intern(v); }\n+        for &v in init { rv.intern(v); }\n         rv\n     }\n "}, {"sha": "a6c92c037439658217f50e341b0a7f8ed9c9b893", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -38,7 +38,7 @@ impl<T> FromIterator<T> for SmallVector<T> {\n }\n \n impl<T> Extend<T> for SmallVector<T> {\n-    fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) {\n+    fn extend<I: Iterator<Item=T>>(&mut self, iter: I) {\n         for val in iter {\n             self.push(val);\n         }"}, {"sha": "bd84306fe17e06047ea235ddbe00cad15af31093", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -159,13 +159,13 @@ pub fn walk_inlined_item<'v,V>(visitor: &mut V, item: &'v InlinedItem)\n \n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n-    for attr in krate.attrs.iter() {\n+    for attr in &krate.attrs {\n         visitor.visit_attribute(attr);\n     }\n }\n \n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n-    for item in module.items.iter() {\n+    for item in &module.items {\n         visitor.visit_item(&**item)\n     }\n }\n@@ -179,7 +179,7 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               lifetime_def: &'v LifetimeDef) {\n     visitor.visit_name(lifetime_def.lifetime.span, lifetime_def.lifetime.name);\n-    for bound in lifetime_def.bounds.iter() {\n+    for bound in &lifetime_def.bounds {\n         visitor.visit_lifetime_bound(bound);\n     }\n }\n@@ -239,7 +239,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                     visitor.visit_path(path, item.id);\n                 }\n                 ViewPathList(ref prefix, ref list) => {\n-                    for id in list.iter() {\n+                    for id in list {\n                         match id.node {\n                             PathListIdent { name, .. } => {\n                                 visitor.visit_ident(id.span, name);\n@@ -270,7 +270,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemForeignMod(ref foreign_module) => {\n-            for foreign_item in foreign_module.items.iter() {\n+            for foreign_item in &foreign_module.items {\n                 visitor.visit_foreign_item(&**foreign_item)\n             }\n         }\n@@ -293,7 +293,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                 None => ()\n             }\n             visitor.visit_ty(&**typ);\n-            for impl_item in impl_items.iter() {\n+            for impl_item in impl_items {\n                 match *impl_item {\n                     MethodImplItem(ref method) => {\n                         walk_method_helper(visitor, &**method)\n@@ -315,21 +315,21 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n             walk_ty_param_bounds_helper(visitor, bounds);\n-            for method in methods.iter() {\n+            for method in methods {\n                 visitor.visit_trait_item(method)\n             }\n         }\n         ItemMac(ref mac) => visitor.visit_mac(mac),\n     }\n-    for attr in item.attrs.iter() {\n+    for attr in &item.attrs {\n         visitor.visit_attribute(attr);\n     }\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n                                          generics: &'v Generics) {\n-    for variant in enum_definition.variants.iter() {\n+    for variant in &enum_definition.variants {\n         visitor.visit_variant(&**variant, generics);\n     }\n }\n@@ -341,7 +341,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n \n     match variant.node.kind {\n         TupleVariantKind(ref variant_arguments) => {\n-            for variant_argument in variant_arguments.iter() {\n+            for variant_argument in variant_arguments {\n                 visitor.visit_ty(&*variant_argument.ty)\n             }\n         }\n@@ -356,7 +356,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n         Some(ref expr) => visitor.visit_expr(&**expr),\n         None => ()\n     }\n-    for attr in variant.node.attrs.iter() {\n+    for attr in &variant.node.attrs {\n         visitor.visit_attribute(attr);\n     }\n }\n@@ -385,12 +385,12 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(&*mutable_type.ty)\n         }\n         TyTup(ref tuple_element_types) => {\n-            for tuple_element_type in tuple_element_types.iter() {\n+            for tuple_element_type in tuple_element_types {\n                 visitor.visit_ty(&**tuple_element_type)\n             }\n         }\n         TyBareFn(ref function_declaration) => {\n-            for argument in function_declaration.decl.inputs.iter() {\n+            for argument in &function_declaration.decl.inputs {\n                 visitor.visit_ty(&*argument.ty)\n             }\n             walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n@@ -422,13 +422,13 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n \n pub fn walk_lifetime_decls_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                       lifetimes: &'v Vec<LifetimeDef>) {\n-    for l in lifetimes.iter() {\n+    for l in lifetimes {\n         visitor.visit_lifetime_def(l);\n     }\n }\n \n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n-    for segment in path.segments.iter() {\n+    for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n }\n@@ -453,21 +453,21 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                 path_parameters: &'v PathParameters) {\n     match *path_parameters {\n         ast::AngleBracketedParameters(ref data) => {\n-            for typ in data.types.iter() {\n+            for typ in &*data.types {\n                 visitor.visit_ty(&**typ);\n             }\n-            for lifetime in data.lifetimes.iter() {\n+            for lifetime in &data.lifetimes {\n                 visitor.visit_lifetime_ref(lifetime);\n             }\n-            for binding in data.bindings.iter() {\n+            for binding in &*data.bindings {\n                 visitor.visit_assoc_type_binding(&**binding);\n             }\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            for typ in data.inputs.iter() {\n+            for typ in &data.inputs {\n                 visitor.visit_ty(&**typ);\n             }\n-            for typ in data.output.iter() {\n+            if let Some(ref typ) = data.output {\n                 visitor.visit_ty(&**typ);\n             }\n         }\n@@ -484,20 +484,20 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n         PatEnum(ref path, ref children) => {\n             visitor.visit_path(path, pattern.id);\n-            for children in children.iter() {\n-                for child in children.iter() {\n-                    visitor.visit_pat(&**child)\n+            if let Some(ref children) = *children {\n+                for child in children {\n+                    visitor.visit_pat(&*child)\n                 }\n             }\n         }\n         PatStruct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n-            for field in fields.iter() {\n+            for field in fields {\n                 visitor.visit_pat(&*field.node.pat)\n             }\n         }\n         PatTup(ref tuple_elements) => {\n-            for tuple_element in tuple_elements.iter() {\n+            for tuple_element in tuple_elements {\n                 visitor.visit_pat(&**tuple_element)\n             }\n         }\n@@ -519,13 +519,13 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         }\n         PatWild(_) => (),\n         PatVec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n-            for prepattern in prepattern.iter() {\n+            for prepattern in prepattern {\n                 visitor.visit_pat(&**prepattern)\n             }\n-            for slice_pattern in slice_pattern.iter() {\n+            if let Some(ref slice_pattern) = *slice_pattern {\n                 visitor.visit_pat(&**slice_pattern)\n             }\n-            for postpattern in postpatterns.iter() {\n+            for postpattern in postpatterns {\n                 visitor.visit_pat(&**postpattern)\n             }\n         }\n@@ -545,14 +545,14 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n         ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ),\n     }\n \n-    for attr in foreign_item.attrs.iter() {\n+    for attr in &foreign_item.attrs {\n         visitor.visit_attribute(attr);\n     }\n }\n \n pub fn walk_ty_param_bounds_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                        bounds: &'v OwnedSlice<TyParamBound>) {\n-    for bound in bounds.iter() {\n+    for bound in &**bounds {\n         visitor.visit_ty_param_bound(bound)\n     }\n }\n@@ -576,11 +576,11 @@ pub fn walk_ty_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v TyParam) {\n }\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n-    for type_parameter in generics.ty_params.iter() {\n+    for type_parameter in &*generics.ty_params {\n         walk_ty_param(visitor, type_parameter);\n     }\n     walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n-    for predicate in generics.where_clause.predicates.iter() {\n+    for predicate in &generics.where_clause.predicates {\n         match predicate {\n             &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounded_ty,\n                                                                           ref bounds,\n@@ -593,7 +593,7 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n                                                                             ..}) => {\n                 visitor.visit_lifetime_ref(lifetime);\n \n-                for bound in bounds.iter() {\n+                for bound in bounds {\n                     visitor.visit_lifetime_ref(bound);\n                 }\n             }\n@@ -615,7 +615,7 @@ pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionR\n }\n \n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n-    for argument in function_declaration.inputs.iter() {\n+    for argument in &function_declaration.inputs {\n         visitor.visit_pat(&*argument.pat);\n         visitor.visit_ty(&*argument.ty)\n     }\n@@ -635,7 +635,7 @@ pub fn walk_method_helper<'v, V: Visitor<'v>>(visitor: &mut V, method: &'v Metho\n                              &**body,\n                              method.span,\n                              method.id);\n-            for attr in method.attrs.iter() {\n+            for attr in &method.attrs {\n                 visitor.visit_attribute(attr);\n             }\n \n@@ -673,12 +673,12 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_ty_method<'v, V: Visitor<'v>>(visitor: &mut V, method_type: &'v TypeMethod) {\n     visitor.visit_ident(method_type.span, method_type.ident);\n     visitor.visit_explicit_self(&method_type.explicit_self);\n-    for argument_type in method_type.decl.inputs.iter() {\n+    for argument_type in &method_type.decl.inputs {\n         visitor.visit_ty(&*argument_type.ty)\n     }\n     visitor.visit_generics(&method_type.generics);\n     walk_fn_ret_ty(visitor, &method_type.decl.output);\n-    for attr in method_type.attrs.iter() {\n+    for attr in &method_type.attrs {\n         visitor.visit_attribute(attr);\n     }\n }\n@@ -695,7 +695,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v Tr\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                            struct_definition: &'v StructDef) {\n-    for field in struct_definition.fields.iter() {\n+    for field in &struct_definition.fields {\n         visitor.visit_struct_field(field)\n     }\n }\n@@ -708,13 +708,13 @@ pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n \n     visitor.visit_ty(&*struct_field.node.ty);\n \n-    for attr in struct_field.node.attrs.iter() {\n+    for attr in &struct_field.node.attrs {\n         visitor.visit_attribute(attr);\n     }\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n-    for statement in block.stmts.iter() {\n+    for statement in &block.stmts {\n         visitor.visit_stmt(&**statement)\n     }\n     walk_expr_opt(visitor, &block.expr)\n@@ -746,7 +746,7 @@ pub fn walk_expr_opt<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_exprs<'v, V: Visitor<'v>>(visitor: &mut V, expressions: &'v [P<Expr>]) {\n-    for expression in expressions.iter() {\n+    for expression in expressions {\n         visitor.visit_expr(&**expression)\n     }\n }\n@@ -770,25 +770,25 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         }\n         ExprStruct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n-            for field in fields.iter() {\n+            for field in fields {\n                 visitor.visit_expr(&*field.expr)\n             }\n             walk_expr_opt(visitor, optional_base)\n         }\n         ExprTup(ref subexpressions) => {\n-            for subexpression in subexpressions.iter() {\n+            for subexpression in subexpressions {\n                 visitor.visit_expr(&**subexpression)\n             }\n         }\n         ExprCall(ref callee_expression, ref arguments) => {\n-            for argument in arguments.iter() {\n+            for argument in arguments {\n                 visitor.visit_expr(&**argument)\n             }\n             visitor.visit_expr(&**callee_expression)\n         }\n         ExprMethodCall(_, ref types, ref arguments) => {\n             walk_exprs(visitor, arguments.as_slice());\n-            for typ in types.iter() {\n+            for typ in types {\n                 visitor.visit_ty(&**typ)\n             }\n         }\n@@ -832,7 +832,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprLoop(ref block, _) => visitor.visit_block(&**block),\n         ExprMatch(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(&**subexpression);\n-            for arm in arms.iter() {\n+            for arm in arms {\n                 visitor.visit_arm(arm)\n             }\n         }\n@@ -881,11 +881,11 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**subexpression)\n         }\n         ExprInlineAsm(ref ia) => {\n-            for input in ia.inputs.iter() {\n+            for input in &ia.inputs {\n                 let (_, ref input) = *input;\n                 visitor.visit_expr(&**input)\n             }\n-            for output in ia.outputs.iter() {\n+            for output in &ia.outputs {\n                 let (_, ref output, _) = *output;\n                 visitor.visit_expr(&**output)\n             }\n@@ -896,12 +896,12 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n }\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n-    for pattern in arm.pats.iter() {\n+    for pattern in &arm.pats {\n         visitor.visit_pat(&**pattern)\n     }\n     walk_expr_opt(visitor, &arm.guard);\n     visitor.visit_expr(&*arm.body);\n-    for attr in arm.attrs.iter() {\n+    for attr in &arm.attrs {\n         visitor.visit_attribute(attr);\n     }\n }"}, {"sha": "4173744ab4b1877b11e53223b384c995a25f9474", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -109,7 +109,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         *dst = (*src).clone();\n     }\n \n-    for &c in cap.iter() {\n+    for &c in cap {\n         let cur = c as char;\n         let mut old_state = state;\n         match state {\n@@ -613,7 +613,7 @@ mod test {\n         }\n \n         let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n-        for &cap in caps.iter() {\n+        for &cap in &caps {\n             let res = get_res(\"\", cap, &[], vars);\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", cap);\n@@ -627,7 +627,7 @@ mod test {\n                     \"Op {} failed with 1 stack entry: {}\", cap, res.err().unwrap());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n-        for &cap in caps.iter() {\n+        for &cap in &caps {\n             let res = expand(cap.as_bytes(), &[], vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 0 stack entries\", cap);\n@@ -648,7 +648,7 @@ mod test {\n     #[test]\n     fn test_comparison_ops() {\n         let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n-        for &(op, bs) in v.iter() {\n+        for &(op, bs) in &v {\n             let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());"}, {"sha": "6ee477fc80823cf40d8c60e4794e6c9c4cc0c953", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -57,7 +57,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     };\n \n     // Look for the terminal in all of the search directories\n-    for p in dirs_to_search.iter() {\n+    for p in &dirs_to_search {\n         if p.exists() {\n             let f = first_char.to_string();\n             let newp = p.join_many(&[&f[], term]);"}, {"sha": "ba82239656c69525f591a96b7705c78c45dd192f", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -32,8 +32,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![cfg_attr(not(stage0), allow(unused_mut))] // NOTE: remove after stage0 snap\n-\n #![feature(asm, slicing_syntax)]\n #![feature(box_syntax)]\n #![feature(collections)]\n@@ -576,7 +574,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = Vec::new();\n         let mut fail_out = String::new();\n-        for &(ref f, ref stdout) in self.failures.iter() {\n+        for &(ref f, ref stdout) in &self.failures {\n             failures.push(f.name.to_string());\n             if stdout.len() > 0 {\n                 fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n@@ -593,7 +591,7 @@ impl<T: Writer> ConsoleTestState<T> {\n \n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         failures.sort();\n-        for name in failures.iter() {\n+        for name in &failures {\n             try!(self.write_plain(format!(\"    {}\\n\",\n                                           name.as_slice()).as_slice()));\n         }\n@@ -652,7 +650,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> old_io:\n                     TrMetrics(mm) => {\n                         let tname = test.name.as_slice();\n                         let MetricMap(mm) = mm;\n-                        for (k,v) in mm.iter() {\n+                        for (k,v) in &mm {\n                             st.metrics\n                               .insert_metric(format!(\"{}.{}\",\n                                                      tname,\n@@ -806,7 +804,7 @@ fn run_tests<F>(opts: &TestOpts,\n \n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n-    for b in filtered_benchs_and_metrics.into_iter() {\n+    for b in filtered_benchs_and_metrics {\n         try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n         run_test(opts, !opts.run_benchmarks, b, tx.clone());\n         let (test, result, stdout) = rx.recv().unwrap();\n@@ -1060,15 +1058,15 @@ impl Bencher {\n \n             let loop_run = Duration::span(|| {\n \n-                for p in samples.iter_mut() {\n+                for p in &mut *samples {\n                     self.bench_n(n, |x| f(x));\n                     *p = self.ns_per_iter() as f64;\n                 };\n \n                 stats::winsorize(samples, 5.0);\n                 summ = Some(stats::Summary::new(samples));\n \n-                for p in samples.iter_mut() {\n+                for p in &mut *samples {\n                     self.bench_n(5 * n, |x| f(x));\n                     *p = self.ns_per_iter() as f64;\n                 };\n@@ -1299,7 +1297,7 @@ mod tests {\n         {\n             fn testfn() { }\n             let mut tests = Vec::new();\n-            for name in names.iter() {\n+            for name in &names {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n                         name: DynTestName((*name).clone()),"}, {"sha": "ebd86dbf61cbff9e8d19e5f5e3b2167afaa6048e", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -167,7 +167,7 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n     fn sum(&self) -> T {\n         let mut partials = vec![];\n \n-        for &x in self.iter() {\n+        for &x in self {\n             let mut x = x;\n             let mut j = 0;\n             // This inner loop applies `hi`/`lo` summation to each\n@@ -223,7 +223,7 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n         } else {\n             let mean = self.mean();\n             let mut v: T = Float::zero();\n-            for s in self.iter() {\n+            for s in self {\n                 let x = *s - mean;\n                 v = v + x*x;\n             }\n@@ -321,7 +321,7 @@ pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n     let lo = percentile_of_sorted(tmp.as_slice(), pct);\n     let hundred: T = FromPrimitive::from_uint(100).unwrap();\n     let hi = percentile_of_sorted(tmp.as_slice(), hundred-pct);\n-    for samp in samples.iter_mut() {\n+    for samp in samples {\n         if *samp > hi {\n             *samp = hi\n         } else if *samp < lo {\n@@ -332,7 +332,7 @@ pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n \n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n-pub fn freq_count<T, U>(mut iter: T) -> hash_map::HashMap<U, uint>\n+pub fn freq_count<T, U>(iter: T) -> hash_map::HashMap<U, uint>\n   where T: Iterator<Item=U>, U: Eq + Clone + Hash<Hasher>\n {\n     let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();"}, {"sha": "e35634ac465ee3fa615f0cbdc84e3571b3da4706", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -52,7 +52,7 @@ fn d<F>(c: char, i: &mut F, k: bool) where F: FnMut(char) {\n     // First check the canonical decompositions\n     match bsearch_table(c, canonical_table) {\n         Some(canon) => {\n-            for x in canon.iter() {\n+            for x in canon {\n                 d(*x, i, k);\n             }\n             return;\n@@ -66,7 +66,7 @@ fn d<F>(c: char, i: &mut F, k: bool) where F: FnMut(char) {\n     // Then check the compatibility decompositions\n     match bsearch_table(c, compatibility_table) {\n         Some(compat) => {\n-            for x in compat.iter() {\n+            for x in compat {\n                 d(*x, i, k);\n             }\n             return;"}, {"sha": "e7739300790d3471262cd9490e9a7b5880735568", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -49,7 +49,7 @@ impl<'a> Iterator for BookItems<'a> {\n                 let cur = self.cur_items.get(self.cur_idx).unwrap();\n \n                 let mut section = \"\".to_string();\n-                for &(_, idx) in self.stack.iter() {\n+                for &(_, idx) in &self.stack {\n                     section.push_str(&(idx + 1).to_string()[]);\n                     section.push('.');\n                 }"}, {"sha": "3c9c4bdedcc876febdf62a64dfaa8698ece966c4", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -177,7 +177,7 @@ impl Subcommand for Build {\n             }\n             Err(errors) => {\n                 let n = errors.len();\n-                for err in errors.into_iter() {\n+                for err in errors {\n                     term.err(&format!(\"error: {}\", err)[]);\n                 }\n "}, {"sha": "d3cb8a7316e8640178eb2c8fb7d726f0c66e857b", "filename": "src/rustbook/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ftest.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -64,7 +64,7 @@ impl Subcommand for Test {\n                 }\n             }\n             Err(errors) => {\n-                for err in errors.into_iter() {\n+                for err in errors {\n                     term.err(&err[]);\n                 }\n                 return Err(box \"There was an error.\" as Box<Error>);"}, {"sha": "058e2e6bf7f28680c60817ed391389e5590bb4a5", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -1,3 +1,12 @@\n+S 2015-01-31 474b324\n+  freebsd-x86_64 c5b55eb488790ff8425d74afa3b37c49517bc55f\n+  linux-i386 319f2f3573c058cb2c4dfc75faaf8ea3ae86ef11\n+  linux-x86_64 7e71108be890adfecc7644ab6ad183e8a657dc97\n+  macos-i386 b0b2676681c6d8ec8cb85700428555761c7bdbb8\n+  macos-x86_64 381dd1587920388e2f71e120a1eabac2648d9672\n+  winnt-i386 5f99509f88355437824a746f7f90fc22233edb9b\n+  winnt-x86_64 382aa20518b1a19d374f06a038025619ba00b77d\n+\n S 2015-01-28 a45e117\n   freebsd-x86_64 08a3ce7331fd1a52466acc0598cf745a009f86f6\n   linux-i386 66e36a3461c12e2102a7f7f241d1b0e242c704d0"}, {"sha": "587af956c77caad3d4c4c81adf830af7a23cba7d", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -35,7 +35,7 @@ pub fn alist_get<A:Clone + 'static,\n                  -> B {\n     let eq_fn = lst.eq_fn;\n     let data = lst.data.borrow();\n-    for entry in (*data).iter() {\n+    for entry in &(*data) {\n         if eq_fn(entry.key.clone(), k.clone()) {\n             return entry.value.clone();\n         }"}, {"sha": "259b4d9418dcf428b5bf8312db7fa43e09cf1571", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -75,7 +75,7 @@ fn run(args: &[String]) {\n             server(&from_parent, &to_parent);\n         });\n \n-        for r in worker_results.into_iter() {\n+        for r in worker_results {\n             let _ = r.join();\n         }\n "}, {"sha": "1341c03e5055b05e7645f55f2d0ab011786dbf46", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -82,7 +82,7 @@ fn run(args: &[String]) {\n             server(&from_parent, &to_parent);\n         });\n \n-        for r in worker_results.into_iter() {\n+        for r in worker_results {\n             let _ = r.join();\n         }\n "}, {"sha": "5d17e3a460c4902b706db91e68c335edd9f31011", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -99,7 +99,7 @@ fn main() {\n         thread_ring(0, msg_per_task, num_chan, num_port);\n \n         // synchronize\n-        for f in futures.iter_mut() {\n+        for f in &mut futures {\n             f.get()\n         }\n     });"}, {"sha": "dc5b2f4596ebd7fe2617dce26d057a7bd702f2b5", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -45,7 +45,7 @@ impl Noise2DContext {\n         let mut rng = StdRng::new().unwrap();\n \n         let mut rgradients = [Vec2 { x: 0.0, y: 0.0 }; 256];\n-        for x in rgradients.iter_mut() {\n+        for x in &mut rgradients[] {\n             *x = random_gradient(&mut rng);\n         }\n "}, {"sha": "dc65a63c5cb400c2f3d5271d6aa44093a9c3366a", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -114,7 +114,7 @@ fn main() {\n         Thread::scoped(move || inner(depth, iterations))\n     }).collect::<Vec<_>>();\n \n-    for message in messages.into_iter() {\n+    for message in messages {\n         println!(\"{}\", message.join().ok().unwrap());\n     }\n "}, {"sha": "0835dd9a08e964103e2237bd0c39ec75fa5ca522", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -47,8 +47,8 @@ use std::thread::Thread;\n \n fn print_complements() {\n     let all = [Blue, Red, Yellow];\n-    for aa in all.iter() {\n-        for bb in all.iter() {\n+    for aa in &all {\n+        for bb in &all {\n             println!(\"{:?} + {:?} -> {:?}\", *aa, *bb, transform(*aa, *bb));\n         }\n     }\n@@ -80,7 +80,7 @@ struct CreatureInfo {\n \n fn show_color_list(set: Vec<Color>) -> String {\n     let mut out = String::new();\n-    for col in set.iter() {\n+    for col in &set {\n         out.push(' ');\n         out.push_str(format!(\"{:?}\", col).as_slice());\n     }"}, {"sha": "47613e2d69c73c7d5a95637b167daf8e97ce483d", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -171,7 +171,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n \n     let mut checksum = 0;\n     let mut maxflips = 0;\n-    for fut in futures.into_iter() {\n+    for fut in futures {\n         let (cs, mf) = fut.join().ok().unwrap();\n         checksum += cs;\n         maxflips = cmp::max(maxflips, mf);"}, {"sha": "5386fc0419dc3c405b09283c2f4f70d229fa1486", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -92,7 +92,7 @@ static HOMO_SAPIENS: [AminoAcid;4] = [\n fn sum_and_scale(a: &'static [AminoAcid]) -> Vec<AminoAcid> {\n     let mut result = Vec::new();\n     let mut p = 0f32;\n-    for a_i in a.iter() {\n+    for a_i in a {\n         let mut a_i = *a_i;\n         p += a_i.p;\n         a_i.p = p * LOOKUP_SCALE;\n@@ -180,7 +180,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n \n     fn nextc(&mut self) -> u8 {\n         let r = self.rng(1.0);\n-        for a in self.lookup.iter() {\n+        for a in &self.lookup[] {\n             if a.p >= r {\n                 return a.c;\n             }"}, {"sha": "ad8e6551a031b1a44c2ac5cba27ac8071b214c27", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -56,14 +56,14 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n    let mut pairs = Vec::new();\n \n    // map -> [(k,%)]\n-   for (key, &val) in mm.iter() {\n+   for (key, &val) in mm {\n       pairs.push(((*key).clone(), pct(val, total)));\n    }\n \n    let pairs_sorted = sortKV(pairs);\n \n    let mut buffer = String::new();\n-   for &(ref k, v) in pairs_sorted.iter() {\n+   for &(ref k, v) in &pairs_sorted {\n        buffer.push_str(format!(\"{:?} {:0.3}\\n\",\n                                k.to_ascii_uppercase(),\n                                v).as_slice());"}, {"sha": "e3f8e60df93db2fcc7a0901e331abeefa1a7b346", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -264,7 +264,7 @@ fn print_frequencies(frequencies: &Table, frame: uint) {\n     vector.as_mut_slice().sort();\n \n     let mut total_count = 0;\n-    for &(count, _) in vector.iter() {\n+    for &(count, _) in &vector {\n         total_count += count;\n     }\n \n@@ -308,7 +308,7 @@ fn main() {\n         Thread::scoped(move|| generate_frequencies(input.as_slice(), occ.len()))\n     }).collect();\n \n-    for (i, freq) in nb_freqs.into_iter() {\n+    for (i, freq) in nb_freqs {\n         print_frequencies(&freq.join().ok().unwrap(), i);\n     }\n     for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs.into_iter()) {"}, {"sha": "a5729c5b5bd4c1c02596d6a661418c8e8ec2379a", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -106,7 +106,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n         })\n     }).collect::<Vec<_>>();\n \n-    for res in precalc_futures.into_iter() {\n+    for res in precalc_futures {\n         let (rs, is) = res.join().ok().unwrap();\n         precalc_r.extend(rs.into_iter());\n         precalc_i.extend(is.into_iter());\n@@ -133,7 +133,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n                 (i + 1) * chunk_size\n             };\n \n-            for &init_i in vec_init_i[start..end].iter() {\n+            for &init_i in &vec_init_i[start..end] {\n                 write_line(init_i, init_r_slice, &mut res);\n             }\n \n@@ -142,7 +142,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n     }).collect::<Vec<_>>();\n \n     try!(writeln!(&mut out as &mut Writer, \"P4\\n{} {}\", w, h));\n-    for res in data.into_iter() {\n+    for res in data {\n         try!(out.write(res.join().ok().unwrap().as_slice()));\n     }\n     out.flush()"}, {"sha": "d061403d5901d175828fb86ad8b82c180020b14a", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -116,9 +116,9 @@ fn transform(piece: Vec<(i32, i32)> , all: bool) -> Vec<Vec<(i32, i32)>> {\n         }).collect();\n \n     // translating to (0, 0) as minimum coordinates.\n-    for cur_piece in res.iter_mut() {\n+    for cur_piece in &mut res {\n         let (dy, dx) = *cur_piece.iter().min_by(|e| *e).unwrap();\n-        for &mut (ref mut y, ref mut x) in cur_piece.iter_mut() {\n+        for &mut (ref mut y, ref mut x) in cur_piece {\n             *y -= dy; *x -= dx;\n         }\n     }\n@@ -135,7 +135,7 @@ fn transform(piece: Vec<(i32, i32)> , all: bool) -> Vec<Vec<(i32, i32)>> {\n // dx) is on the board.\n fn mask(dy: i32, dx: i32, id: usize, p: &Vec<(i32, i32)>) -> Option<u64> {\n     let mut m = 1 << (50 + id);\n-    for &(y, x) in p.iter() {\n+    for &(y, x) in p {\n         let x = x + dx + (y + (dy % 2)) / 2;\n         if x < 0 || x > 4 {return None;}\n         let y = y + dy;\n@@ -184,7 +184,7 @@ fn is_board_unfeasible(board: u64, masks: &Vec<Vec<Vec<u64>>>) -> bool {\n         if board & 1 << i != 0 { continue; }\n         for (cur_id, pos_masks) in masks_at.iter().enumerate() {\n             if board & 1 << (50 + cur_id) != 0 { continue; }\n-            for &cur_m in pos_masks.iter() {\n+            for &cur_m in pos_masks {\n                 if cur_m & board != 0 { continue; }\n                 coverable |= cur_m;\n                 // if every coordinates can be covered and every"}, {"sha": "a8de1469456cb18d1fb89d3b2557e0c19d20d968", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -109,7 +109,7 @@ fn advance(bodies: &mut [Planet;N_BODIES], dt: f64, steps: int) {\n                 Some(bi) => bi,\n                 None => break\n             };\n-            for bj in b_slice.iter_mut() {\n+            for bj in &mut *b_slice {\n                 let dx = bi.x - bj.x;\n                 let dy = bi.y - bj.y;\n                 let dz = bi.z - bj.z;\n@@ -158,7 +158,7 @@ fn offset_momentum(bodies: &mut [Planet;N_BODIES]) {\n     let mut px = 0.0;\n     let mut py = 0.0;\n     let mut pz = 0.0;\n-    for bi in bodies.iter() {\n+    for bi in &*bodies {\n         px += bi.vx * bi.mass;\n         py += bi.vy * bi.mass;\n         pz += bi.vz * bi.mass;"}, {"sha": "ea1d913b3e2ee9cd5f576908c7d507e40ef989e2", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -82,7 +82,7 @@ fn stress(num_tasks: int) {\n             stress_task(i);\n         }));\n     }\n-    for r in results.into_iter() {\n+    for r in results {\n         let _ = r.join();\n     }\n }"}, {"sha": "492fd4a2c849a8ba9d9f7a9c2c1de65fbbe2b32c", "filename": "src/test/compile-fail/borrowck-for-loop-correct-cmt-for-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -25,7 +25,7 @@ fn main() {\n     let f = Foo {\n         a: [box 3, box 4, box 5],\n     };\n-    for &a in f.a.iter() {  //~ ERROR cannot move out\n+    for &a in &f.a {  //~ ERROR cannot move out\n     }\n \n     let x = Some(box 1);"}, {"sha": "043ea0bf00e55615a01dde1ce30b1961126ebf10", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -12,7 +12,7 @@ use std::iter::repeat;\n \n fn main() {\n     let mut vector = vec![1us, 2];\n-    for &x in vector.iter() {\n+    for &x in &vector {\n         let cap = vector.capacity();\n         vector.extend(repeat(0));      //~ ERROR cannot borrow\n         vector[1us] = 5us;   //~ ERROR cannot borrow"}, {"sha": "2c6348659838f679aa444cf1279a5cfbedd00b1b", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -17,7 +17,7 @@ struct Foo {\n \n impl Foo {\n     pub fn foo<F>(&mut self, mut fun: F) where F: FnMut(&isize) {\n-        for f in self.n.iter() {\n+        for f in &self.n {\n             fun(f);\n         }\n     }"}, {"sha": "dc8deb04833450805bdddf11366ba557a6c76e16", "filename": "src/test/compile-fail/drop-with-active-borrows-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-1.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let a = \"\".to_string();\n     let b: Vec<&str> = a.lines().collect();\n     drop(a);    //~ ERROR cannot move out of `a` because it is borrowed\n-    for s in b.iter() {\n+    for s in &b {\n         println!(\"{}\", *s);\n     }\n }"}, {"sha": "30f58f909a088e73ae8e8c6bbabccb0cb3a963bd", "filename": "src/test/compile-fail/issue-15480.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-15480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-15480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15480.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -14,7 +14,7 @@ fn main() {\n //~^ ERROR borrowed value does not live long enough\n     ];\n \n-    for &&x in v.iter() {\n+    for &&x in &v {\n         println!(\"{}\", x + 3);\n     }\n }"}, {"sha": "015f1fa603a2004ae08c5fcae9cff0af5295b7bb", "filename": "src/test/compile-fail/issue-18400.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -22,7 +22,7 @@ impl<'a, T, S> Set<&'a [T]> for S where\n     }\n \n     fn set(&mut self, bits: &[T]) {\n-        for &bit in bits.iter() {\n+        for &bit in bits {\n             self.set(bit)\n         }\n     }"}, {"sha": "998b9587b965e007b81cbd987c267e5a2d403f2b", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -15,8 +15,8 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for Vec<A> {\n     fn bind<B, F>(&self, mut f: F) where F: FnMut(A) -> Vec<B> {\n         let mut r = panic!();\n-        for elt in self.iter() { r = r + f(*elt); }\n-        //~^ ERROR binary operation `+` cannot be applied to type `collections::vec::Vec<B>`\n+        for elt in self { r = r + f(*elt); }\n+        //~^ ERROR the type of this value must be known\n    }\n }\n fn main() {"}, {"sha": "a2711d532d2cc4023eb81ee3e2941c82ba0ff45c", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -16,7 +16,7 @@\n fn fail_len(v: Vec<isize> ) -> usize {\n     let mut i = 3;\n     panic!();\n-    for x in v.iter() { i += 1us; }\n+    for x in &v { i += 1us; }\n     //~^ ERROR: unreachable statement\n     return i;\n }"}, {"sha": "474274c93fd3c39a55f13cf7f05db88e7c97795d", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -64,7 +64,7 @@ fn main() {\n              ('c', 'd'),\n              ('e', 'f')];\n \n-    for &(x,y) in v.iter() {} // should be OK\n+    for &(x,y) in &v {} // should be OK\n \n     // Make sure none of the errors above were fatal\n     let x: char = true; //~  ERROR mismatched types"}, {"sha": "c15c556f5d68f2bc7eb0b07e4386a2c4c3da1794", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -32,7 +32,7 @@ pub fn remove_package_from_database() {\n     };\n     list_database(push_id);\n \n-    for l in lines_to_use.iter() {\n+    for l in &lines_to_use {\n         println!(\"{}\", l.local_path);\n     }\n \n@@ -41,7 +41,7 @@ pub fn remove_package_from_database() {\n pub fn list_database<F>(mut f: F) where F: FnMut(&CrateId) {\n     let stuff = [\"foo\", \"bar\"];\n \n-    for l in stuff.iter() {\n+    for l in &stuff {\n         f(&CrateId::new(*l));\n     }\n }"}, {"sha": "023ef72c453bb5a2d9580ccc5e84b4e84074000e", "filename": "src/test/compile-fail/vec-mut-iter-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let mut xs: Vec<isize> = vec!();\n \n-    for x in xs.iter_mut() {\n+    for x in &mut xs {\n         xs.push(1) //~ ERROR cannot borrow `xs`\n     }\n }"}, {"sha": "0d526d60190ae1aa75acf9f1ef6403aed733e940", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -170,14 +170,14 @@ fn main() {\n         z: true\n     };\n \n-    for &Struct { x, y, z } in [s].iter() {\n+    for &Struct { x, y, z } in &[s] {\n         zzz(); // #break\n     }\n \n     let tuple: (i8, u8, i16, u16, i32, u32, i64, u64, f32, f64) =\n         (0x6f, 0x70, -113, 114, -115, 116, -117, 118, 119.5, 120.5);\n \n-    for &(_i8, _u8, _i16, _u16, _i32, _u32, _i64, _u64, _f32, _f64) in [tuple].iter() {\n+    for &(_i8, _u8, _i16, _u16, _i32, _u32, _i64, _u64, _f32, _f64) in &[tuple] {\n         zzz(); // #break\n     }\n \n@@ -215,7 +215,7 @@ fn main() {\n       zzz(); // #break\n     }\n \n-    for simple_tuple_ident in vec![(34903493u32, 232323i64)].into_iter() {\n+    for simple_tuple_ident in vec![(34903493u32, 232323i64)] {\n       zzz(); // #break\n     }\n }"}, {"sha": "fe5983cbb6a3fc4c26eb98a9982a1ea6c43eeda6", "filename": "src/test/debuginfo/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -94,7 +94,7 @@ fn main() {\n \n     let x = 1000000; // wan meeeljen doollaars!\n \n-    for &x in range.iter() {\n+    for &x in &range {\n         zzz(); // #break\n         sentinel();\n "}, {"sha": "8bcb54af8ba8487e8b625175ae85eb483c23ca62", "filename": "src/test/debuginfo/unreachable-locals.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -26,7 +26,7 @@ fn after_return() {\n     match (20i32, 'c') {\n         (a, ref b) => {}\n     }\n-    for a in [111i32].iter() {}\n+    for a in &[111i32] {}\n }\n \n fn after_panic() {\n@@ -36,7 +36,7 @@ fn after_panic() {\n     match (20i32, 'c') {\n         (a, ref b) => {}\n     }\n-    for a in [111i32].iter() {}\n+    for a in &[111i32] {}\n }\n \n fn after_diverging_function() {\n@@ -46,7 +46,7 @@ fn after_diverging_function() {\n     match (20i32, 'c') {\n         (a, ref b) => {}\n     }\n-    for a in [111i32].iter() {}\n+    for a in &[111i32] {}\n }\n \n fn after_break() {\n@@ -57,7 +57,7 @@ fn after_break() {\n         match (20i32, 'c') {\n             (a, ref b) => {}\n         }\n-        for a in [111i32].iter() {}\n+        for a in &[111i32] {}\n     }\n }\n \n@@ -69,7 +69,7 @@ fn after_continue() {\n         match (20i32, 'c') {\n             (a, ref b) => {}\n         }\n-        for a in [111i32].iter() {}\n+        for a in &[111i32] {}\n     }\n }\n "}, {"sha": "5a55cb4e561309b2781f8b28c7767f5c42e3d3d1", "filename": "src/test/pretty/block-comment-wchar.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -109,7 +109,7 @@\n          '\\u2000', '\\u2001', '\\u2002', '\\u2003', '\\u2004', '\\u2005', '\\u2006',\n          '\\u2007', '\\u2008', '\\u2009', '\\u200A', '\\u2028', '\\u2029', '\\u202F',\n          '\\u205F', '\\u3000'];\n-    for c in chars.iter() {\n+    for c in &chars {\n         let ws = c.is_whitespace();\n         println!(\"{} {}\" , c , ws);\n     }"}, {"sha": "c82bdcd8dcb9388efc2fa79409a8be1557686fbe", "filename": "src/test/pretty/block-comment-wchar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -103,7 +103,7 @@ fn main() {\n          '\\u2000', '\\u2001', '\\u2002', '\\u2003', '\\u2004', '\\u2005', '\\u2006',\n          '\\u2007', '\\u2008', '\\u2009', '\\u200A', '\\u2028', '\\u2029', '\\u202F',\n          '\\u205F', '\\u3000'];\n-    for c in chars.iter() {\n+    for c in &chars {\n         let ws = c.is_whitespace();\n         println!(\"{} {}\", c , ws);\n     }"}, {"sha": "0f2a667e11cb212cff5bbe66c3e2c9a4feb5a4c6", "filename": "src/test/pretty/for-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fpretty%2Ffor-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Fpretty%2Ffor-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffor-comment.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -12,7 +12,7 @@\n \n fn f(v: &[int]) -> int {\n     let mut n = 0;\n-    for e in v.iter() {\n+    for e in v {\n         n = *e; // This comment once triggered pretty printer bug\n     }\n "}, {"sha": "2cc7451e138944c27b371b27bf34a5c3ebd8dbe3", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n pub fn main() {\n     let mut sum = 0;\n     let xs = vec!(1, 2, 3, 4, 5);\n-    for x in xs.iter() {\n+    for x in &xs {\n         sum += *x;\n     }\n     assert_eq!(sum, 15);"}, {"sha": "2f530331a2bdedb019d2167b70044b4ea530d2c6", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -13,7 +13,7 @@ pub fn main() {\n     let v = vec!(-1.0f64, 0.0, 1.0, 2.0, 3.0);\n \n     // Statement form does not require parentheses:\n-    for i in v.iter() {\n+    for i in &v {\n         println!(\"{}\", *i);\n     }\n "}, {"sha": "d5d26f42ef0953cce28df180d701eaa9b81e3c04", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn iter_vec<T, F>(v: Vec<T> , mut f: F) where F: FnMut(&T) { for x in v.iter() { f(x); } }\n+fn iter_vec<T, F>(v: Vec<T> , mut f: F) where F: FnMut(&T) { for x in &v { f(x); } }\n \n pub fn main() {\n     let v = vec![1i32, 2, 3, 4, 5, 6, 7];"}, {"sha": "8c079ca4b079afe2e3e600424abe294ba624f327", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn iter_vec<T, F>(v: Vec<T>, mut f: F) where F: FnMut(&T) { for x in v.iter() { f(x); } }\n+fn iter_vec<T, F>(v: Vec<T>, mut f: F) where F: FnMut(&T) { for x in &v { f(x); } }\n \n pub fn main() {\n     let v = vec![1i32, 2, 3, 4, 5];"}, {"sha": "94c7c2b13cec4cfc146c8990151d45255407516d", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n \n fn want_slice(v: &[int]) -> int {\n     let mut sum = 0;\n-    for i in v.iter() { sum += *i; }\n+    for i in v { sum += *i; }\n     sum\n }\n "}, {"sha": "6498c4b461def60ad1e3d8da878c76210e4e4342", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     loop { i += 1; if i == 20 { break; } }\n     assert_eq!(i, 20);\n     let xs = [1, 2, 3, 4, 5, 6];\n-    for x in xs.iter() {\n+    for x in &xs {\n         if *x == 3 { break; } assert!((*x <= 3));\n     }\n     i = 0;\n@@ -26,7 +26,7 @@ pub fn main() {\n         if i >= 10 { break; }\n     }\n     let ys = vec!(1, 2, 3, 4, 5, 6);\n-    for x in ys.iter() {\n+    for x in &ys {\n         if *x % 2 == 0 { continue; }\n         assert!((*x % 2 != 0));\n     }"}, {"sha": "5e696566bfa986d1c750c7e2d01f61ef2520b4e3", "filename": "src/test/run-pass/capture-clauses-boxed-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn each<T, F>(x: &[T], mut f: F) where F: FnMut(&T) {\n-    for val in x.iter() {\n+    for val in x {\n         f(val)\n     }\n }"}, {"sha": "de1196e10d88c0f7a7b4861870359decb5a3b4c3", "filename": "src/test/run-pass/capture-clauses-unboxed-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n #![feature(unboxed_closures)]\n \n fn each<'a,T,F:FnMut(&'a T)>(x: &'a [T], mut f: F) {\n-    for val in x.iter() {\n+    for val in x {\n         f(val)\n     }\n }"}, {"sha": "f69a0332cc4f42e49d5a6fa5e1f05130dc759345", "filename": "src/test/run-pass/cleanup-rvalue-for-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-for-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-for-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-for-scope.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -61,7 +61,7 @@ impl Drop for AddFlags {\n pub fn main() {\n     // The array containing [AddFlags] should not be dropped until\n     // after the for loop:\n-    for x in [AddFlags(1)].iter() {\n+    for x in &[AddFlags(1)] {\n         check_flags(0);\n     }\n     check_flags(1);"}, {"sha": "b6b30e2fe9b217230b2c72643de1cc53c9007974", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -10,7 +10,7 @@\n \n fn sum(x: &[int]) -> int {\n     let mut sum = 0;\n-    for y in x.iter() { sum += *y; }\n+    for y in x { sum += *y; }\n     return sum;\n }\n "}, {"sha": "4b07b1d3b076e72c226422ebf5e11eb97a6ff3a2", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -22,8 +22,8 @@ static mut closures: &'static mut [S<fn()>] = &mut [S(f as fn()), S(f as fn())];\n \n pub fn main() {\n     unsafe {\n-        for &bare_fn in bare_fns.iter() { bare_fn() }\n-        for closure in closures.iter_mut() {\n+        for &bare_fn in bare_fns { bare_fn() }\n+        for closure in &mut *closures {\n             let S(ref mut closure) = *closure;\n             (*closure)()\n         }"}, {"sha": "ef9dc377bc7f7164c5db03428ccd102a869e032b", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -16,7 +16,7 @@ struct Box {\n \n impl Box {\n     pub fn set_many(&mut self, xs: &[uint]) {\n-        for x in xs.iter() { self.x = *x; }\n+        for x in xs { self.x = *x; }\n     }\n }\n "}, {"sha": "4e2c8facaf8202ab01585456b9607c5d3bc3d25b", "filename": "src/test/run-pass/fn-pattern-expected-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let v : &[(int,int)] = &[ (1, 2), (3, 4), (5, 6) ];\n-    for &(x, y) in v.iter() {\n+    for &(x, y) in v {\n         println!(\"{}\", y);\n         println!(\"{}\", x);\n     }"}, {"sha": "7a9b8a45b2af10d308907dbd037d4c7e5adce2e0", "filename": "src/test/run-pass/for-destruct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Ffor-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Ffor-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-destruct.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n struct Pair { x: int, y: int }\n \n pub fn main() {\n-    for elt in (vec!(Pair {x: 10, y: 20}, Pair {x: 30, y: 0})).iter() {\n+    for elt in &(vec!(Pair {x: 10, y: 20}, Pair {x: 30, y: 0})) {\n         assert_eq!(elt.x + elt.y, 30);\n     }\n }"}, {"sha": "7754751120e489ffccb97ec3ca4736dcb3f54ecd", "filename": "src/test/run-pass/for-loop-goofiness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Ffor-loop-goofiness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Ffor-loop-goofiness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-goofiness.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -17,7 +17,7 @@ type Iterator = int;\n \n pub fn main() {\n     let x = [ 3, 3, 3 ];\n-    for i in x.iter() {\n+    for i in &x {\n         assert_eq!(*i, 3);\n     }\n }"}, {"sha": "d2de1ed8c7e6f3ff032bfbfe4cbe635b586e2aa1", "filename": "src/test/run-pass/for-loop-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Ffor-loop-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Ffor-loop-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-panic.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n \n-pub fn main() { let x: Vec<int> = Vec::new(); for _ in x.iter() { panic!(\"moop\"); } }\n+pub fn main() { let x: Vec<int> = Vec::new(); for _ in &x { panic!(\"moop\"); } }"}, {"sha": "e9e8c3f09290d784e1999f3d802a330747248423", "filename": "src/test/run-pass/foreach-external-iterators-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-break.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n pub fn main() {\n     let x = [1; 100];\n     let mut y = 0;\n-    for i in x.iter() {\n+    for i in &x[] {\n         if y > 10 {\n             break;\n         }"}, {"sha": "a4988bf016cf2caeba27cba89f9e8c9939cba5a3", "filename": "src/test/run-pass/foreach-external-iterators-hashmap-break-restart.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -19,7 +19,7 @@ use std::collections::HashMap;\n pub fn main() {\n     let mut h = HashMap::new();\n     let kvs = [(1, 10), (2, 20), (3, 30)];\n-    for &(k,v) in kvs.iter() {\n+    for &(k,v) in &kvs {\n         h.insert(k,v);\n     }\n     let mut x = 0;"}, {"sha": "ed4328d94fe34b89a5eeddbac020979ae6131912", "filename": "src/test/run-pass/foreach-external-iterators-hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -15,12 +15,12 @@ use std::collections::HashMap;\n pub fn main() {\n     let mut h = HashMap::new();\n     let kvs = [(1, 10), (2, 20), (3, 30)];\n-    for &(k,v) in kvs.iter() {\n+    for &(k,v) in &kvs {\n         h.insert(k,v);\n     }\n     let mut x = 0;\n     let mut y = 0;\n-    for (&k,&v) in h.iter() {\n+    for (&k,&v) in &h {\n         x += k;\n         y += v;\n     }"}, {"sha": "6acfbc95317627bc9213fa92eb18032f6e7aed15", "filename": "src/test/run-pass/foreach-external-iterators-nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-nested.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -13,8 +13,8 @@ pub fn main() {\n     let y = [2; 100];\n     let mut p = 0;\n     let mut q = 0;\n-    for i in x.iter() {\n-        for j in y.iter() {\n+    for i in &x[] {\n+        for j in &y[] {\n             p += *j;\n         }\n         q += *i + p;"}, {"sha": "2f154be659d888538de644a2f2cc1da4405bfb55", "filename": "src/test/run-pass/foreach-external-iterators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fforeach-external-iterators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n pub fn main() {\n     let x = [1; 100];\n     let mut y = 0;\n-    for i in x.iter() {\n+    for i in &x[] {\n         y += *i\n     }\n     assert!(y == 100);"}, {"sha": "7f84efcdd5de8862cd5d26eb93381ce1819838d9", "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -16,7 +16,7 @@ trait vec_utils<T> {\n impl<T> vec_utils<T> for Vec<T> {\n     fn map_<U, F>(x: &Vec<T> , mut f: F) -> Vec<U> where F: FnMut(&T) -> U {\n         let mut r = Vec::new();\n-        for elt in x.iter() {\n+        for elt in x {\n             r.push(f(elt));\n         }\n         r"}, {"sha": "651ac632439fa5f0c49598b1cbe1cede2f263216", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -35,7 +35,7 @@ mod map_reduce {\n     enum ctrl_proto { find_reducer(Vec<u8>, Sender<int>), mapper_done, }\n \n     fn start_mappers(ctrl: Sender<ctrl_proto>, inputs: Vec<String>) {\n-        for i in inputs.iter() {\n+        for i in &inputs {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n             Thread::spawn(move|| map_task(ctrl.clone(), i.clone()) );"}, {"sha": "b487608d4e660340bd0effd21131f0a6eac2e136", "filename": "src/test/run-pass/issue-10396.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-10396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-10396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10396.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -14,7 +14,7 @@ enum Foo<'s> {\n }\n \n fn f(arr: &[&Foo]) {\n-    for &f in arr.iter() {\n+    for &f in arr {\n         println!(\"{:?}\", f);\n     }\n }"}, {"sha": "a0e6f2c9be96e3117bdf6e0ca65932d02792c91a", "filename": "src/test/run-pass/issue-17068.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-17068.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-17068.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17068.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n // Test that regionck creates the right region links in the pattern\n // binding of a for loop\n fn foo<'a>(v: &'a [uint]) -> &'a uint {\n-    for &ref x in v.iter() { return x; }\n+    for &ref x in v { return x; }\n     unreachable!()\n }\n "}, {"sha": "b55f369135868aa5db8c5180330aee011fb034e4", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -66,12 +66,12 @@ fn read_board_grid<rdr:'static + old_io::Reader>(mut input: rdr)\n     let mut line = [0; 10];\n     input.read(&mut line);\n     let mut row = Vec::new();\n-    for c in line.iter() {\n+    for c in &line {\n         row.push(square_from_char(*c as char))\n     }\n     grid.push(row);\n     let width = grid[0].len();\n-    for row in grid.iter() { assert!(row.len() == width) }\n+    for row in &grid { assert!(row.len() == width) }\n     grid\n }\n "}, {"sha": "26558bdd30c3b48b66f7fcfea4537d24b2cfd363", "filename": "src/test/run-pass/issue-3389.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3389.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -15,7 +15,7 @@ struct trie_node {\n }\n \n fn print_str_vector(vector: Vec<String> ) {\n-    for string in vector.iter() {\n+    for string in &vector {\n         println!(\"{}\", *string);\n     }\n }"}, {"sha": "2cf29296b859165479841616e28705dcbe4db682", "filename": "src/test/run-pass/issue-3563-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n trait Canvas {\n     fn add_point(&self, point: &int);\n     fn add_points(&self, shapes: &[int]) {\n-        for pt in shapes.iter() {\n+        for pt in shapes {\n             self.add_point(pt)\n         }\n     }"}, {"sha": "5d02a1b2bd2982a52d1c6958c23e1527e8de9385", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -122,7 +122,7 @@ trait Canvas {\n     // Unlike interfaces traits support default implementations.\n     // Got an ICE as soon as I added this method.\n     fn add_points(&mut self, shapes: &[Point]) {\n-        for pt in shapes.iter() {self.add_point(*pt)};\n+        for pt in shapes {self.add_point(*pt)};\n     }\n }\n "}, {"sha": "89cf2f69b34ec456197260dbcebe7e84f4cad6df", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -100,7 +100,7 @@ priv fn cmd_to_string(cmd: ~[String]) -> String {\n   let mut res = \"*\".to_string();\n   res.push_str(cmd.len().to_string());\n   res.push_str(\"\\r\\n\");\n-    for s in cmd.iter() {\n+    for s in &cmd {\n     res.push_str([\"$\".to_string(), s.len().to_string(), \"\\r\\n\".to_string(),\n                   (*s).clone(), \"\\r\\n\".to_string()].concat() );\n     }"}, {"sha": "ae72de50d26d838d48999e67fe86ff52288580f7", "filename": "src/test/run-pass/issue-4542.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-4542.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7335c7dd63cafe70ffca76677f9e33bc6eccefaa/src%2Ftest%2Frun-pass%2Fissue-4542.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4542.rs?ref=7335c7dd63cafe70ffca76677f9e33bc6eccefaa", "patch": "@@ -11,7 +11,7 @@\n use std::os;\n \n pub fn main() {\n-    for arg in os::args().iter() {\n+    for arg in &os::args() {\n         match (*arg).clone() {\n             _s => { }\n         }"}]}