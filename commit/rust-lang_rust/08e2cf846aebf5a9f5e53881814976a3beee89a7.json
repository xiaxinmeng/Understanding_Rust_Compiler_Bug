{"sha": "08e2cf846aebf5a9f5e53881814976a3beee89a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZTJjZjg0NmFlYmY1YTlmNWU1Mzg4MTgxNDk3NmEzYmVlZTg5YTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-06T01:00:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-06T01:00:52Z"}, "message": "auto merge of #5676 : nikomatsakis/rust/issue-4183-trait_ref, r=nikomatsakis\n\nThese are a number of incremental steps towards #4183 and #4646.", "tree": {"sha": "ed81332bccf792d086d46c604b724a444f8656d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed81332bccf792d086d46c604b724a444f8656d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08e2cf846aebf5a9f5e53881814976a3beee89a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08e2cf846aebf5a9f5e53881814976a3beee89a7", "html_url": "https://github.com/rust-lang/rust/commit/08e2cf846aebf5a9f5e53881814976a3beee89a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08e2cf846aebf5a9f5e53881814976a3beee89a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "babe50633349cd29f0a0757079e0e13bdc0310fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/babe50633349cd29f0a0757079e0e13bdc0310fa", "html_url": "https://github.com/rust-lang/rust/commit/babe50633349cd29f0a0757079e0e13bdc0310fa"}, {"sha": "13801f60b26009991cd6880b6b40fae9265a8280", "url": "https://api.github.com/repos/rust-lang/rust/commits/13801f60b26009991cd6880b6b40fae9265a8280", "html_url": "https://github.com/rust-lang/rust/commit/13801f60b26009991cd6880b6b40fae9265a8280"}], "stats": {"total": 3317, "additions": 1895, "deletions": 1422}, "files": [{"sha": "95d963a36e3aa97abdd0c3a302f627aeef5052bb", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -1394,7 +1394,7 @@ pub mod funcs {\n             use libc::types::common::posix88::{DIR, dirent_t};\n             use libc::types::os::arch::c95::{c_char, c_int, c_long};\n \n-            // NOTE: On OS X opendir and readdir have two versions,\n+            // NB: On OS X opendir and readdir have two versions,\n             // one for 32-bit kernelspace and one for 64.\n             // We should be linking to the 64-bit ones, called\n             // opendir$INODE64, etc. but for some reason rustc"}, {"sha": "de1482e2c39188a8f2253c1ae7e2337190232127", "filename": "src/libcore/option.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -46,7 +46,8 @@ use ops::Add;\n use kinds::Copy;\n use util;\n use num::Zero;\n-use iter::{BaseIter, MutableIter};\n+use iter::{BaseIter, MutableIter, ExtendedIter};\n+use iter;\n \n #[cfg(test)] use ptr;\n #[cfg(test)] use str;\n@@ -118,6 +119,31 @@ impl<T> MutableIter<T> for Option<T> {\n     }\n }\n \n+impl<A> ExtendedIter<A> for Option<A> {\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n+        iter::eachi(self, blk)\n+    }\n+    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+        iter::all(self, blk)\n+    }\n+    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+        iter::any(self, blk)\n+    }\n+    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n+        iter::foldl(self, b0, blk)\n+    }\n+    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+        iter::position(self, f)\n+    }\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n+    }\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+        -> ~[B] {\n+        iter::flat_map_to_vec(self, op)\n+    }\n+}\n+\n pub impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n     fn is_none(&const self) -> bool {"}, {"sha": "a449c4e73cf7e1b68c13a1349cef51e90071486a", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -443,9 +443,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_trait(&self) -> bool {\n-        self.align_to::<TyVisitor>();\n+        self.align_to::<@TyVisitor>();\n         if ! self.inner.visit_trait() { return false; }\n-        self.bump_past::<TyVisitor>();\n+        self.bump_past::<@TyVisitor>();\n         true\n     }\n "}, {"sha": "98564beeba90136ba0fd12f4d17461bb08dfb800", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -298,7 +298,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n     @ProgRes(repr) as @Program\n }\n \n-fn read_all(rd: io::Reader) -> ~str {\n+fn read_all(rd: @io::Reader) -> ~str {\n     let buf = io::with_bytes_writer(|wr| {\n         let mut bytes = [0, ..4096];\n         while !rd.eof() {"}, {"sha": "cd1af369570efff738bf46e1fb1055d062a35881", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -308,7 +308,7 @@ pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n \n     };\n \n-    // NOTE: Android hack\n+    // NB: Android hack\n     if sess.targ_cfg.arch == abi::Arm &&\n             (sess.opts.output_type == link::output_type_object ||\n              sess.opts.output_type == link::output_type_exe) {"}, {"sha": "71a1f1b3f9b2060e3eaf9d0fc503d02fcf316371", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -74,7 +74,9 @@ pub static tag_crate_dep_vers: uint = 0x2cu;\n pub static tag_mod_impl: uint = 0x30u;\n \n pub static tag_item_trait_method: uint = 0x31u;\n-pub static tag_impl_trait: uint = 0x32u;\n+\n+pub static tag_item_trait_ref: uint = 0x32u;\n+pub static tag_item_super_trait_ref: uint = 0x33u;\n \n // discriminator value for variants\n pub static tag_disr_val: uint = 0x34u;\n@@ -102,6 +104,7 @@ pub static tag_item_dtor: uint = 0x49u;\n pub static tag_item_trait_method_self_ty: uint = 0x4b;\n pub static tag_item_trait_method_self_ty_region: uint = 0x4c;\n \n+\n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n pub static tag_items_data_item_reexport: uint = 0x4d;\n@@ -159,6 +162,10 @@ pub static tag_items_data_item_visibility: uint = 0x78;\n pub static tag_link_args: uint = 0x79;\n pub static tag_link_args_arg: uint = 0x7a;\n \n+pub static tag_item_method_tps: uint = 0x7b;\n+pub static tag_item_method_fty: uint = 0x7c;\n+pub static tag_item_method_transformed_self_ty: uint = 0x7d;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "74e891a01942ff7404e82489ee43b5fffa943b17", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -111,12 +111,24 @@ pub fn get_impls_for_mod(cstore: @mut cstore::CStore, def: ast::def_id,\n     }\n }\n \n-pub fn get_trait_methods(tcx: ty::ctxt,\n-                         def: ast::def_id)\n-                      -> @~[ty::method] {\n-    let cstore = tcx.cstore;\n+pub fn get_method(tcx: ty::ctxt,\n+                  def: ast::def_id) -> ty::method\n+{\n+    let cdata = cstore::get_crate_data(tcx.cstore, def.crate);\n+    decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n+}\n+\n+pub fn get_method_name_and_self_ty(cstore: @mut cstore::CStore,\n+                                   def: ast::def_id) -> (ast::ident, ast::self_ty_)\n+{\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_method_name_and_self_ty(cstore.intr, cdata, def.node)\n+}\n+\n+pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n+                                def: ast::def_id) -> ~[ast::def_id] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_trait_methods(cstore.intr, cdata, def.node, tcx)\n+    decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n@@ -127,19 +139,12 @@ pub fn get_provided_trait_methods(tcx: ty::ctxt,\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n+pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[@ty::TraitRef] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n-pub fn get_method_names_if_trait(cstore: @mut cstore::CStore,\n-                                 def: ast::def_id)\n-                              -> Option<~[(ast::ident, ast::self_ty_)]> {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n-}\n-\n pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::def_id)\n                           -> Option<ast::ident> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n@@ -175,6 +180,12 @@ pub fn get_type(tcx: ty::ctxt,\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n+pub fn get_trait_def(tcx: ty::ctxt, def: ast::def_id) -> ty::TraitDef {\n+    let cstore = tcx.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_trait_def(cdata, def.node, tcx)\n+}\n+\n pub fn get_region_param(cstore: @mut metadata::cstore::CStore,\n                         def: ast::def_id) -> Option<ty::region_variance> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n@@ -199,16 +210,17 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     debug!(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n-        bounds: @~[],\n-        region_param: None,\n+        generics: ty::Generics {bounds: @~[],\n+                                region_param: None},\n         ty: ty\n     }\n }\n \n // Given a def_id for an impl or class, return the traits it implements,\n // or the empty vector if it's not for an impl or for a class that implements\n // traits\n-pub fn get_impl_traits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n+pub fn get_impl_traits(tcx: ty::ctxt,\n+                       def: ast::def_id) -> ~[@ty::TraitRef] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_traits(cdata, def.node, tcx)"}, {"sha": "d9ef30ff297d0f2b038b30cc5c7c0644366b5c83", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 117, "deletions": 68, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -19,7 +19,8 @@ use metadata::csearch::{ProvidedTraitMethodInfo, StaticMethodInfo};\n use metadata::csearch;\n use metadata::cstore;\n use metadata::decoder;\n-use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n+use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n+                         parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::{ty, resolve};\n \n use core::hash::HashUtil;\n@@ -229,6 +230,22 @@ fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n                   |_, did| translate_def_id(cdata, did))\n }\n \n+fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::BareFnTy {\n+    let tp = reader::get_doc(doc, tag_item_method_fty);\n+    parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n+                          |_, did| translate_def_id(cdata, did))\n+}\n+\n+fn doc_transformed_self_ty(doc: ebml::Doc,\n+                           tcx: ty::ctxt,\n+                           cdata: cmd) -> Option<ty::t>\n+{\n+    do reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map |tp| {\n+        parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n+                      |_, did| translate_def_id(cdata, did))\n+    }\n+}\n+\n pub fn item_type(item_id: ast::def_id, item: ebml::Doc,\n                  tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let t = doc_type(item, tcx, cdata);\n@@ -239,18 +256,21 @@ pub fn item_type(item_id: ast::def_id, item: ebml::Doc,\n     }\n }\n \n-fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n-    let mut results = ~[];\n-    for reader::tagged_docs(item, tag_impl_trait) |ity| {\n-        results.push(doc_type(ity, tcx, cdata));\n-    };\n-    results\n+fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n+    parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n+                         |_, did| translate_def_id(cdata, did))\n+}\n+\n+fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n+    let tp = reader::get_doc(doc, tag_item_trait_ref);\n+    doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n+fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n+                        tag: uint)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    for reader::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n+    for reader::tagged_docs(item, tag) |p| {\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx,\n                                    |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n@@ -338,7 +358,8 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n             dl_def(ast::def_variant(enum_did, did))\n         }\n-        Trait | Enum => dl_def(ast::def_ty(did)),\n+        Trait => dl_def(ast::def_trait(did)),\n+        Enum => dl_def(ast::def_ty(did)),\n         Impl => dl_impl(did),\n         PublicField | PrivateField | InheritedField => dl_field,\n     }\n@@ -352,19 +373,34 @@ pub fn lookup_def(cnum: ast::crate_num, data: @~[u8], did_: ast::def_id) ->\n     return def_like_to_def(item_to_def_like(item, did, cnum));\n }\n \n+pub fn get_trait_def(cdata: cmd,\n+                     item_id: ast::node_id,\n+                     tcx: ty::ctxt) -> ty::TraitDef\n+{\n+    let item_doc = lookup_item(item_id, cdata.data);\n+    let tp_bounds = item_ty_param_bounds(item_doc, tcx, cdata,\n+                                         tag_items_data_item_ty_param_bounds);\n+    let rp = item_ty_region_param(item_doc);\n+    ty::TraitDef {\n+        generics: ty::Generics {bounds: tp_bounds,\n+                                region_param: rp},\n+        trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n+    }\n+}\n+\n pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data);\n     let t = item_type(ast::def_id { crate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n     let tp_bounds = if family_has_type_params(item_family(item)) {\n-        item_ty_param_bounds(item, tcx, cdata)\n+        item_ty_param_bounds(item, tcx, cdata, tag_items_data_item_ty_param_bounds)\n     } else { @~[] };\n     let rp = item_ty_region_param(item);\n     ty::ty_param_bounds_and_ty {\n-        bounds: tp_bounds,\n-        region_param: rp,\n+        generics: ty::Generics {bounds: tp_bounds,\n+                                region_param: rp},\n         ty: t\n     }\n }\n@@ -380,9 +416,19 @@ pub fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-pub fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-                    -> ~[ty::t] {\n-    item_impl_traits(lookup_item(id, cdata.data), tcx, cdata)\n+pub fn get_impl_traits(cdata: cmd,\n+                       id: ast::node_id,\n+                       tcx: ty::ctxt) -> ~[@ty::TraitRef]\n+{\n+    let item_doc = lookup_item(id, cdata.data);\n+    let mut results = ~[];\n+    for reader::tagged_docs(item_doc, tag_item_trait_ref) |tp| {\n+        let trait_ref =\n+            @parse_trait_ref_data(tp.data, cdata.cnum, tp.start, tcx,\n+                                  |_, did| translate_def_id(cdata, did));\n+        results.push(trait_ref);\n+    };\n+    results\n }\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n@@ -690,36 +736,53 @@ pub fn get_impls_for_mod(intr: @ident_interner,\n     @result\n }\n \n-/* Works for both classes and traits */\n-pub fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                         tcx: ty::ctxt) -> @~[ty::method] {\n+pub fn get_method_name_and_self_ty(\n+    intr: @ident_interner,\n+    cdata: cmd,\n+    id: ast::node_id) -> (ast::ident, ast::self_ty_)\n+{\n+    let method_doc = lookup_item(id, cdata.data);\n+    let name = item_name(intr, method_doc);\n+    let self_ty = get_self_ty(method_doc);\n+    (name, self_ty)\n+}\n+\n+pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n+                  tcx: ty::ctxt) -> ty::method\n+{\n+    let method_doc = lookup_item(id, cdata.data);\n+    let def_id = item_def_id(method_doc, cdata);\n+    let name = item_name(intr, method_doc);\n+    let bounds =\n+        item_ty_param_bounds(method_doc, tcx, cdata,\n+                             tag_item_method_tps);\n+    let transformed_self_ty = doc_transformed_self_ty(method_doc, tcx, cdata);\n+    let fty = doc_method_fty(method_doc, tcx, cdata);\n+    let vis = item_visibility(method_doc);\n+    let self_ty = get_self_ty(method_doc);\n+    ty::method {\n+        ident: name,\n+        generics: ty::Generics {\n+            bounds: bounds,\n+            region_param: None\n+        },\n+        transformed_self_ty: transformed_self_ty,\n+        fty: fty,\n+        self_ty: self_ty,\n+        vis: vis,\n+        def_id: def_id\n+    }\n+}\n+\n+pub fn get_trait_method_def_ids(cdata: cmd,\n+                                id: ast::node_id) -> ~[ast::def_id] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n     for reader::tagged_docs(item, tag_item_trait_method) |mth| {\n-        let bounds = item_ty_param_bounds(mth, tcx, cdata);\n-        let name = item_name(intr, mth);\n-        let ty = doc_type(mth, tcx, cdata);\n-        let def_id = item_def_id(mth, cdata);\n-        let fty = match ty::get(ty).sty {\n-            ty::ty_bare_fn(ref f) => copy *f,\n-            _ => {\n-                tcx.diag.handler().bug(\n-                    ~\"get_trait_methods: id has non-function type\");\n-            }\n-        };\n-        let self_ty = get_self_ty(mth);\n-        result.push(ty::method {\n-            ident: name,\n-            tps: bounds,\n-            fty: fty,\n-            self_ty: self_ty,\n-            vis: ast::public,\n-            def_id: def_id\n-        });\n+        result.push(item_def_id(mth, cdata));\n     }\n-    debug!(\"get_trait_methods: }\");\n-    @result\n+    result\n }\n \n pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n@@ -734,7 +797,8 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n         let did = item_def_id(mth, cdata);\n \n-        let bounds = item_ty_param_bounds(mth, tcx, cdata);\n+        let bounds = item_ty_param_bounds(mth, tcx, cdata,\n+                                          tag_items_data_item_ty_param_bounds);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n \n@@ -746,10 +810,15 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n             }\n         };\n \n+        let transformed_self_ty = doc_transformed_self_ty(mth, tcx, cdata);\n         let self_ty = get_self_ty(mth);\n         let ty_method = ty::method {\n             ident: name,\n-            tps: bounds,\n+            generics: ty::Generics {\n+                bounds: bounds,\n+                region_param: None\n+            },\n+            transformed_self_ty: transformed_self_ty,\n             fty: fty,\n             self_ty: self_ty,\n             vis: ast::public,\n@@ -768,35 +837,15 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n /// Returns the supertraits of the given trait.\n pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-                    -> ~[ty::t] {\n+                    -> ~[@ty::TraitRef] {\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n-    for reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n-        results.push(doc_type(trait_doc, tcx, cdata));\n+    for reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+        results.push(@doc_trait_ref(trait_doc, tcx, cdata));\n     }\n     return results;\n }\n \n-// If the item in question is a trait, returns its set of methods and\n-// their self types. Otherwise, returns none. This overlaps in an\n-// annoying way with get_trait_methods.\n-pub fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n-                                 node_id: ast::node_id)\n-                              -> Option<~[(ast::ident, ast::self_ty_)]> {\n-\n-    let item = lookup_item(node_id, cdata.data);\n-    if item_family(item) != Trait {\n-        return None;\n-    }\n-\n-    let mut resulting_methods = ~[];\n-    for reader::tagged_docs(item, tag_item_trait_method) |method| {\n-        resulting_methods.push(\n-            (item_name(intr, method), get_self_ty(method)));\n-    }\n-    return Some(resulting_methods);\n-}\n-\n pub fn get_type_name_if_impl(intr: @ident_interner,\n                              cdata: cmd,\n                              node_id: ast::node_id) -> Option<ast::ident> {\n@@ -821,8 +870,8 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n         return None;\n     }\n \n-    // If this impl has a trait ref, don't consider it.\n-    for reader::tagged_docs(item, tag_impl_trait) |_doc| {\n+    // If this impl implements a trait, don't consider it.\n+    for reader::tagged_docs(item, tag_item_trait_ref) |_doc| {\n         return None;\n     }\n "}, {"sha": "e251af7c8a85b0cd561ab6bb585345680928b623", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 135, "deletions": 115, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -153,14 +153,23 @@ fn add_to_index(ecx: @EncodeContext, ebml_w: writer::Encoder, path: &[ident],\n         });\n }\n \n-fn encode_trait_ref(ebml_w: writer::Encoder, ecx: @EncodeContext,\n-                    t: @trait_ref) {\n-    ebml_w.start_tag(tag_impl_trait);\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n+fn encode_trait_ref(ebml_w: writer::Encoder,\n+                    ecx: @EncodeContext,\n+                    trait_ref: &ty::TraitRef,\n+                    tag: uint)\n+{\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+\n+    ebml_w.start_tag(tag);\n+    tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n     ebml_w.end_tag();\n }\n \n-\n // Item info table encoding\n fn encode_family(ebml_w: writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n@@ -170,16 +179,18 @@ fn encode_family(ebml_w: writer::Encoder, c: char) {\n \n pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @EncodeContext,\n-                               params: @~[ty::param_bounds]) {\n+fn encode_ty_type_param_bounds(ebml_w: writer::Encoder,\n+                               ecx: @EncodeContext,\n+                               params: @~[ty::param_bounds],\n+                               tag: uint) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n         reachable: |a| reachable(ecx, a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each |param| {\n-        ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n+        ebml_w.start_tag(tag);\n         tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, *param);\n         ebml_w.end_tag();\n     }\n@@ -190,7 +201,8 @@ fn encode_type_param_bounds(ebml_w: writer::Encoder,\n                             params: &OptVec<TyParam>) {\n     let ty_param_bounds =\n         @params.map_to_vec(|param| *ecx.tcx.ty_param_bounds.get(&param.id));\n-    encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n+    encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds,\n+                                tag_items_data_item_ty_param_bounds);\n }\n \n \n@@ -227,6 +239,34 @@ fn encode_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n     ebml_w.end_tag();\n }\n \n+fn encode_transformed_self_ty(ecx: @EncodeContext,\n+                              ebml_w: writer::Encoder,\n+                              opt_typ: Option<ty::t>)\n+{\n+    for opt_typ.each |&typ| {\n+        ebml_w.start_tag(tag_item_method_transformed_self_ty);\n+        write_type(ecx, ebml_w, typ);\n+        ebml_w.end_tag();\n+    }\n+}\n+\n+fn encode_method_fty(ecx: @EncodeContext,\n+                     ebml_w: writer::Encoder,\n+                     typ: &ty::BareFnTy)\n+{\n+    ebml_w.start_tag(tag_item_method_fty);\n+\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n+\n+    ebml_w.end_tag();\n+}\n+\n fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n@@ -542,21 +582,37 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n+fn encode_method_ty_fields(ecx: @EncodeContext,\n+                           ebml_w: writer::Encoder,\n+                           method_ty: &ty::method)\n+{\n+    encode_def_id(ebml_w, method_ty.def_id);\n+    encode_name(ecx, ebml_w, method_ty.ident);\n+    encode_ty_type_param_bounds(ebml_w, ecx, method_ty.generics.bounds,\n+                                tag_item_method_tps);\n+    encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n+    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n+    encode_visibility(ebml_w, method_ty.vis);\n+    encode_self_type(ebml_w, method_ty.self_ty);\n+}\n+\n fn encode_info_for_method(ecx: @EncodeContext,\n                           ebml_w: writer::Encoder,\n                           impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n                           parent_id: node_id,\n                           m: @method,\n-                          parent_visibility: ast::visibility,\n                           owner_generics: &ast::Generics,\n                           method_generics: &ast::Generics) {\n     debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n            *ecx.tcx.sess.str_of(m.ident),\n            owner_generics.ty_params.len(),\n            method_generics.ty_params.len());\n     ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(m.id));\n+\n+    let method_def_id = local_def(m.id);\n+    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n+    encode_method_ty_fields(ecx, ebml_w, method_ty);\n \n     match m.self_ty.node {\n         ast::sty_static => {\n@@ -572,16 +628,7 @@ fn encode_info_for_method(ecx: @EncodeContext,\n     encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n \n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n-    encode_name(ecx, ebml_w, m.ident);\n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n-    encode_self_type(ebml_w, m.self_ty.node);\n-\n-    // Combine parent visibility and this visibility.\n-    let visibility = match m.vis {\n-        ast::inherited => parent_visibility,\n-        vis => vis,\n-    };\n-    encode_visibility(ebml_w, visibility);\n \n     if len > 0u || should_inline {\n         (ecx.encode_inlined_item)(\n@@ -590,6 +637,7 @@ fn encode_info_for_method(ecx: @EncodeContext,\n     } else {\n         encode_symbol(ecx, ebml_w, m.id);\n     }\n+\n     ebml_w.end_tag();\n }\n \n@@ -833,8 +881,9 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n             ebml_w.end_tag();\n         }\n-        for opt_trait.each |associated_trait| {\n-           encode_trait_ref(ebml_w, ecx, *associated_trait);\n+        for opt_trait.each |ast_trait_ref| {\n+            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n+            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n@@ -843,17 +892,6 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         let mut impl_path = vec::append(~[], path);\n         impl_path += ~[ast_map::path_name(item.ident)];\n \n-        // If there is a trait reference, treat the methods as always public.\n-        // This is to work around some incorrect behavior in privacy checking:\n-        // when the method belongs to a trait, it should acquire the privacy\n-        // from the trait, not the impl. Forcing the visibility to be public\n-        // makes things sorta work.\n-        let parent_visibility = if opt_trait.is_some() {\n-            ast::public\n-        } else {\n-            item.vis\n-        };\n-\n         for methods.each |m| {\n             index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx,\n@@ -862,113 +900,95 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                    should_inline(m.attrs),\n                                    item.id,\n                                    *m,\n-                                   parent_visibility,\n                                    generics,\n                                    &m.generics);\n         }\n       }\n-      item_trait(ref generics, ref traits, ref ms) => {\n-        let mut provided_methods = ~[];\n-\n+      item_trait(ref generics, ref super_traits, ref ms) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n         encode_region_param(ecx, ebml_w, item);\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        let trait_def = ty::lookup_trait_def(tcx, local_def(item.id));\n+        encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        let mut i = 0u;\n-        for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n-            match (*ms)[i] {\n-              required(ref ty_m) => {\n-                ebml_w.start_tag(tag_item_trait_method);\n-                encode_def_id(ebml_w, local_def((*ty_m).id));\n-                encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx,\n-                                         &ty_m.generics.ty_params);\n-                encode_type(ecx, ebml_w,\n-                            ty::mk_bare_fn(tcx, copy mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n-                encode_self_type(ebml_w, mty.self_ty);\n-                encode_method_sort(ebml_w, 'r');\n-                encode_visibility(ebml_w, ast::public);\n-                ebml_w.end_tag();\n-              }\n-              provided(m) => {\n-                provided_methods.push(m);\n-\n-                ebml_w.start_tag(tag_item_trait_method);\n-                encode_def_id(ebml_w, local_def(m.id));\n-                encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx,\n-                                         &m.generics.ty_params);\n-                encode_type(ecx, ebml_w,\n-                            ty::mk_bare_fn(tcx, copy mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n-                encode_self_type(ebml_w, mty.self_ty);\n-                encode_method_sort(ebml_w, 'p');\n-                encode_visibility(ebml_w, m.vis);\n-                ebml_w.end_tag();\n-              }\n-            }\n-            i += 1;\n+        for ty::trait_method_def_ids(tcx, local_def(item.id)).each |&method_def_id| {\n+            ebml_w.start_tag(tag_item_trait_method);\n+            encode_def_id(ebml_w, method_def_id);\n+            ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        for traits.each |associated_trait| {\n-           encode_trait_ref(ebml_w, ecx, *associated_trait)\n+        for super_traits.each |ast_trait_ref| {\n+            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n+            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n         }\n-\n         ebml_w.end_tag();\n \n-        // Now, output all of the static methods as items.  Note that for the\n-        // method info, we output static methods with type signatures as\n-        // written. Here, we output the *real* type signatures. I feel like\n-        // maybe we should only ever handle the real type signatures.\n-        for ms.each |m| {\n-            let ty_m = ast_util::trait_method_to_ty_method(m);\n-            if ty_m.self_ty.node != ast::sty_static { loop; }\n+        // Now output the method info for each method.\n+        for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n+            assert!(method_def_id.crate == ast::local_crate);\n+\n+            let method_ty: @ty::method = ty::method(tcx, method_def_id);\n \n-            index.push(entry { val: ty_m.id, pos: ebml_w.writer.tell() });\n+            index.push(entry {val: method_def_id.node, pos: ebml_w.writer.tell()});\n \n             ebml_w.start_tag(tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(ty_m.id));\n+\n+            encode_method_ty_fields(ecx, ebml_w, method_ty);\n+\n             encode_parent_item(ebml_w, local_def(item.id));\n-            encode_name(ecx, ebml_w, ty_m.ident);\n-            encode_family(ebml_w,\n-                          purity_static_method_family(ty_m.purity));\n-            let polyty = ecx.tcx.tcache.get(&local_def(ty_m.id));\n-            encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n-            encode_type(ecx, ebml_w, polyty.ty);\n-            let mut m_path = vec::append(~[], path); // :-(\n-            m_path += [ast_map::path_name(item.ident)];\n-            encode_path(ecx, ebml_w, m_path, ast_map::path_name(ty_m.ident));\n-\n-            // For now, use the item visibility until trait methods can have\n-            // real visibility in the AST.\n-            encode_visibility(ebml_w, item.vis);\n \n-            ebml_w.end_tag();\n-        }\n+            let mut trait_path = vec::append(~[], path);\n+            trait_path.push(ast_map::path_name(item.ident));\n+            encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n+\n+            match method_ty.self_ty {\n+                sty_static => {\n+                    encode_family(ebml_w,\n+                                  purity_static_method_family(\n+                                      method_ty.fty.purity));\n \n-        // Finally, output all the provided methods as items.\n-        for provided_methods.each |m| {\n-            index.push(entry { val: m.id, pos: ebml_w.writer.tell() });\n+                    let tpt = ty::lookup_item_type(tcx, method_def_id);\n+                    encode_ty_type_param_bounds(ebml_w, ecx, tpt.generics.bounds,\n+                                                tag_items_data_item_ty_param_bounds);\n+                    encode_type(ecx, ebml_w, tpt.ty);\n+                }\n \n-            // We do not concatenate the generics of the owning impl and that\n-            // of provided methods.  I am not sure why this is. -ndm\n-            let owner_generics = ast_util::empty_generics();\n+                _ => {\n+                    encode_family(ebml_w,\n+                                  purity_fn_family(\n+                                      method_ty.fty.purity));\n+                }\n+            }\n \n-            encode_info_for_method(ecx,\n-                                   ebml_w,\n-                                   /*bad*/copy path,\n-                                   true,\n-                                   item.id,\n-                                   *m,\n-                                   item.vis,\n-                                   &owner_generics,\n-                                   &m.generics);\n+            match ms[i] {\n+                required(_) => {\n+                    encode_method_sort(ebml_w, 'r');\n+                }\n+\n+                provided(m) => {\n+                    // This is obviously a bogus assert but I don't think this\n+                    // ever worked before anyhow...near as I can tell, before\n+                    // we would emit two items.\n+                    if method_ty.self_ty == sty_static {\n+                        tcx.sess.span_unimpl(\n+                            item.span,\n+                            fmt!(\"Method %s is both provided and static\",\n+                                 *tcx.sess.intr().get(method_ty.ident)));\n+                    }\n+                    encode_type_param_bounds(ebml_w, ecx,\n+                                             &m.generics.ty_params);\n+                    encode_method_sort(ebml_w, 'p');\n+                    (ecx.encode_inlined_item)(\n+                        ecx, ebml_w, path,\n+                        ii_method(local_def(item.id), m));\n+                }\n+            }\n+\n+            ebml_w.end_tag();\n         }\n       }\n       item_mac(*) => fail!(~\"item macros unimplemented\")"}, {"sha": "2ec13abb483d664d7a07bb8dd190af145128719f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -119,6 +119,18 @@ pub fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n     parse_ty(st, conv)\n }\n \n+pub fn parse_bare_fn_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+                             conv: conv_did) -> ty::BareFnTy {\n+    let st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_bare_fn_ty(st, conv)\n+}\n+\n+pub fn parse_trait_ref_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+                            conv: conv_did) -> ty::TraitRef {\n+    let st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_trait_ref(st, conv)\n+}\n+\n pub fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                       conv: conv_did) -> ty::arg {\n     let st = parse_state_from_data(data, crate_num, pos, tcx);\n@@ -177,7 +189,6 @@ fn parse_trait_store(st: @mut PState) -> ty::TraitStore {\n         '~' => ty::UniqTraitStore,\n         '@' => ty::BoxTraitStore,\n         '&' => ty::RegionTraitStore(parse_region(st)),\n-        '.' => ty::BareTraitStore,\n         c => st.tcx.sess.bug(fmt!(\"parse_trait_store(): bad input '%c'\", c))\n     }\n }\n@@ -259,6 +270,12 @@ fn parse_str(st: @mut PState, term: char) -> ~str {\n     return result;\n }\n \n+fn parse_trait_ref(st: @mut PState, conv: conv_did) -> ty::TraitRef {\n+    let def = parse_def(st, NominalType, conv);\n+    let substs = parse_substs(st, conv);\n+    ty::TraitRef {def_id: def, substs: substs}\n+}\n+\n fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n       'n' => return ty::mk_nil(st.tcx),\n@@ -545,7 +562,7 @@ fn parse_bounds(st: @mut PState, conv: conv_did) -> @~[ty::param_bound] {\n           'C' => ty::bound_copy,\n           'K' => ty::bound_const,\n           'O' => ty::bound_durable,\n-          'I' => ty::bound_trait(parse_ty(st, conv)),\n+          'I' => ty::bound_trait(@parse_trait_ref(st, conv)),\n           '.' => break,\n           _ => fail!(~\"parse_bounds: bad bounds\")\n         });"}, {"sha": "ca2d66de9c44d6065b2c89b190307c5852e756c3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -214,11 +214,16 @@ pub fn enc_vstore(w: @io::Writer, cx: @ctxt, v: ty::vstore) {\n     }\n }\n \n+pub fn enc_trait_ref(w: @io::Writer, cx: @ctxt, s: &ty::TraitRef) {\n+    w.write_str((cx.ds)(s.def_id));\n+    w.write_char('|');\n+    enc_substs(w, cx, s.substs);\n+}\n+\n pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => w.write_char('~'),\n         ty::BoxTraitStore => w.write_char('@'),\n-        ty::BareTraitStore => w.write_char('.'),\n         ty::RegionTraitStore(re) => {\n             w.write_char('&');\n             enc_region(w, cx, re);\n@@ -384,7 +389,7 @@ fn enc_onceness(w: @io::Writer, o: Onceness) {\n     }\n }\n \n-fn enc_bare_fn_ty(w: @io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty(w: @io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n     enc_abi_set(w, ft.abis);\n     enc_fn_sig(w, cx, &ft.sig);\n@@ -415,8 +420,8 @@ pub fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n           ty::bound_const => w.write_char('K'),\n           ty::bound_durable => w.write_char('O'),\n           ty::bound_trait(tp) => {\n-            w.write_char('I');\n-            enc_ty(w, cx, tp);\n+              w.write_char('I');\n+              enc_trait_ref(w, cx, tp);\n           }\n         }\n     }"}, {"sha": "20b72a19df7948a4ee42a22eff12f4433cc127b4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -417,6 +417,7 @@ impl tr for ast::def {\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n           }\n+          ast::def_trait(did) => ast::def_trait(did.tr(xcx)),\n           ast::def_ty(did) => ast::def_ty(did.tr(xcx)),\n           ast::def_prim_ty(p) => ast::def_prim_ty(p),\n           ast::def_ty_param(did, v) => ast::def_ty_param(did.tr(xcx), v),\n@@ -778,16 +779,20 @@ impl ebml_writer_helpers for writer::Encoder {\n \n     fn emit_tpbt(&self, ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_struct(\"ty_param_bounds_and_ty\", 3) {\n-            do self.emit_field(~\"bounds\", 0) {\n-                do self.emit_from_vec(*tpbt.bounds) |bs| {\n-                    self.emit_bounds(ecx, *bs);\n+        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n+            do self.emit_field(~\"generics\", 0) {\n+                do self.emit_struct(\"Generics\", 2) {\n+                    do self.emit_field(~\"bounds\", 0) {\n+                        do self.emit_from_vec(*tpbt.generics.bounds) |bs| {\n+                            self.emit_bounds(ecx, *bs);\n+                        }\n+                    }\n+                    do self.emit_field(~\"region_param\", 1) {\n+                        tpbt.generics.region_param.encode(self);\n+                    }\n                 }\n             }\n-            do self.emit_field(~\"region_param\", 1u) {\n-                tpbt.region_param.encode(self);\n-            }\n-            do self.emit_field(~\"ty\", 2u) {\n+            do self.emit_field(~\"ty\", 1) {\n                 self.emit_ty(ecx, tpbt.ty);\n             }\n         }\n@@ -1045,15 +1050,19 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n     fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n         -> ty::ty_param_bounds_and_ty\n     {\n-        do self.read_struct(\"ty_param_bounds_and_ty\", 3) {\n+        do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n             ty::ty_param_bounds_and_ty {\n-                bounds: self.read_field(~\"bounds\", 0u, || {\n-                    @self.read_to_vec(|| self.read_bounds(xcx) )\n-                }),\n-                region_param: self.read_field(~\"region_param\", 1u, || {\n-                    Decodable::decode(self)\n-                }),\n-                ty: self.read_field(~\"ty\", 2u, || {\n+                generics: do self.read_struct(\"Generics\", 2) {\n+                    ty::Generics {\n+                        bounds: self.read_field(~\"bounds\", 0, || {\n+                            @self.read_to_vec(|| self.read_bounds(xcx) )\n+                        }),\n+                        region_param: self.read_field(~\"region_param\", 1, || {\n+                            Decodable::decode(self)\n+                        })\n+                    }\n+                },\n+                ty: self.read_field(~\"ty\", 1, || {\n                     self.read_ty(xcx)\n                 })\n             }"}, {"sha": "96e8ef40770a238abb741d34b4b044b5c8183fd3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -91,7 +91,7 @@ fn check_struct_safe_for_destructor(cx: Context,\n                                     span: span,\n                                     struct_did: def_id) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n-    if struct_tpt.bounds.len() == 0 {\n+    if struct_tpt.generics.bounds.len() == 0 {\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did, ty::substs {\n             self_r: None,\n             self_ty: None,\n@@ -279,7 +279,7 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n         let bounds = match e.node {\n           expr_path(_) => {\n             let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&e.id));\n-            ty::lookup_item_type(cx.tcx, did).bounds\n+            ty::lookup_item_type(cx.tcx, did).generics.bounds\n           }\n           _ => {\n             // Type substitutions should only occur on paths and\n@@ -340,7 +340,7 @@ fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n             // FIXME(#5562): removing this copy causes a segfault before stage2\n             let ts = /*bad*/ copy **ts;\n             let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&id));\n-            let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n+            let bounds = ty::lookup_item_type(cx.tcx, did).generics.bounds;\n             for vec::each2(ts, *bounds) |ty, bound| {\n                 check_bounds(cx, aty.id, aty.span, *ty, *bound)\n             }"}, {"sha": "b4aff91ed5b280257e7e122a9127273a70ea5823", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -825,8 +825,7 @@ fn check_item_heap(cx: ty::ctxt, it: @ast::item) {\n       ast::item_fn(*) |\n       ast::item_ty(*) |\n       ast::item_enum(*) |\n-      ast::item_struct(*) |\n-      ast::item_trait(*) => check_type(cx, it.id, it.id, it.span,\n+      ast::item_struct(*) => check_type(cx, it.id, it.id, it.span,\n                                        ty::node_id_to_type(cx, it.id)),\n       _ => ()\n     }"}, {"sha": "6473cb8e8e00668b3ddf21de2845fa22132e04ee", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -462,7 +462,7 @@ pub impl mem_categorization_ctxt {\n           ast::def_fn(*) | ast::def_static_method(*) | ast::def_mod(_) |\n           ast::def_foreign_mod(_) | ast::def_const(_) |\n           ast::def_use(_) | ast::def_variant(*) |\n-          ast::def_ty(_) | ast::def_prim_ty(_) |\n+          ast::def_trait(_) | ast::def_ty(_) | ast::def_prim_ty(_) |\n           ast::def_ty_param(*) | ast::def_struct(*) |\n           ast::def_typaram_binder(*) | ast::def_region(_) |\n           ast::def_label(_) | ast::def_self_ty(*) => {"}, {"sha": "1401d86123e646e2cd7ed46c84cb34b43b5db225", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -211,7 +211,7 @@ use core::prelude::*;\n use middle::pat_util::{pat_bindings};\n use middle::freevars;\n use middle::ty;\n-use middle::typeck::method_map;\n+use middle::typeck::{method_map};\n use util::ppaux;\n use util::common::indenter;\n \n@@ -463,7 +463,7 @@ pub impl VisitContext {\n             expr_method_call(callee, _, _, ref args, _) => { // callee.m(args)\n                 // Implicit self is equivalent to & mode, but every\n                 // other kind should be + mode.\n-                self.use_receiver(expr.id, expr.span, callee, visitor);\n+                self.use_receiver(callee, visitor);\n                 self.use_fn_args(expr.callee_id, *args, visitor);\n             }\n \n@@ -665,7 +665,7 @@ pub impl VisitContext {\n             return false;\n         }\n \n-        self.use_receiver(expr.id, expr.span, receiver_expr, visitor);\n+        self.use_receiver(receiver_expr, visitor);\n \n         // for overloaded operatrs, we are always passing in a\n         // borrowed pointer, so it's always read mode:\n@@ -718,8 +718,6 @@ pub impl VisitContext {\n     }\n \n     fn use_receiver(&self,\n-                    _expr_id: node_id,\n-                    _span: span,\n                     receiver_expr: @expr,\n                     visitor: vt<VisitContext>)\n     {"}, {"sha": "1c60c37ed12a04b71d537181a192b2f9448a062e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -690,7 +690,9 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     match ty.node {\n       ast::ty_path(path, id) => {\n         match cx.def_map.find(&id) {\n-          Some(&ast::def_ty(did)) | Some(&ast::def_struct(did)) => {\n+          Some(&ast::def_ty(did)) |\n+          Some(&ast::def_trait(did)) |\n+          Some(&ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n                 if cx.region_is_relevant(path.rp) {\n                     cx.add_dep(did.node);"}, {"sha": "fcf0b7022a7a7b6cad299dfa55e0fd5b48d6bd74", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 65, "deletions": 53, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -12,7 +12,8 @@ use core::prelude::*;\n \n use driver::session;\n use driver::session::Session;\n-use metadata::csearch::{each_path, get_method_names_if_trait};\n+use metadata::csearch::{each_path, get_trait_method_def_ids};\n+use metadata::csearch::get_method_name_and_self_ty;\n use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n@@ -31,7 +32,7 @@ use syntax::ast::{crate, decl_item, def, def_arg, def_binding};\n use syntax::ast::{def_const, def_foreign_mod, def_fn, def_id, def_label};\n use syntax::ast::{def_local, def_mod, def_prim_ty, def_region, def_self};\n use syntax::ast::{def_self_ty, def_static_method, def_struct, def_ty};\n-use syntax::ast::{def_ty_param, def_typaram_binder};\n+use syntax::ast::{def_ty_param, def_typaram_binder, def_trait};\n use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n use syntax::ast::{expr_binary, expr_break, expr_field};\n use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n@@ -78,6 +79,7 @@ use syntax::opt_vec::OptVec;\n use core::option::Some;\n use core::str::each_split_str;\n use core::hashmap::{HashMap, HashSet};\n+use core::util;\n \n // Definition mapping\n pub type DefMap = @mut HashMap<node_id,def>;\n@@ -1341,7 +1343,7 @@ pub impl Resolver {\n                 let def_id = local_def(item.id);\n                 self.trait_info.insert(def_id, method_names);\n \n-                name_bindings.define_type(privacy, def_ty(def_id), sp);\n+                name_bindings.define_type(privacy, def_trait(def_id), sp);\n                 visit_item(item, new_parent, visitor);\n             }\n \n@@ -1611,36 +1613,40 @@ pub impl Resolver {\n                     crate) building value %s\", final_ident);\n             child_name_bindings.define_value(Public, def, dummy_sp());\n           }\n-          def_ty(def_id) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building type %s\", final_ident);\n-\n-            // If this is a trait, add all the method names\n-            // to the trait info.\n-\n-            match get_method_names_if_trait(self.session.cstore, def_id) {\n-              None => {\n-                // Nothing to do.\n-              }\n-              Some(method_names) => {\n-                let mut interned_method_names = HashSet::new();\n-                for method_names.each |method_data| {\n-                    let (method_name, self_ty) = *method_data;\n-                    debug!(\"(building reduced graph for \\\n-                            external crate) ... adding \\\n-                            trait method '%s'\",\n-                           *self.session.str_of(method_name));\n-\n-                    // Add it to the trait info if not static.\n-                    if self_ty != sty_static {\n-                        interned_method_names.insert(method_name);\n-                    }\n-                }\n-                self.trait_info.insert(def_id, interned_method_names);\n+          def_trait(def_id) => {\n+              debug!(\"(building reduced graph for external \\\n+                      crate) building type %s\", final_ident);\n+\n+              // If this is a trait, add all the method names\n+              // to the trait info.\n+\n+              let method_def_ids = get_trait_method_def_ids(self.session.cstore,\n+                                                            def_id);\n+              let mut interned_method_names = HashSet::new();\n+              for method_def_ids.each |&method_def_id| {\n+                  let (method_name, self_ty) =\n+                      get_method_name_and_self_ty(self.session.cstore,\n+                                                  method_def_id);\n+\n+                  debug!(\"(building reduced graph for \\\n+                          external crate) ... adding \\\n+                          trait method '%s'\",\n+                         *self.session.str_of(method_name));\n+\n+                  // Add it to the trait info if not static.\n+                  if self_ty != sty_static {\n+                      interned_method_names.insert(method_name);\n+                  }\n               }\n-            }\n+              self.trait_info.insert(def_id, interned_method_names);\n \n-            child_name_bindings.define_type(Public, def, dummy_sp());\n+              child_name_bindings.define_type(Public, def, dummy_sp());\n+          }\n+          def_ty(_) => {\n+              debug!(\"(building reduced graph for external \\\n+                      crate) building type %s\", final_ident);\n+\n+              child_name_bindings.define_type(Public, def, dummy_sp());\n           }\n           def_struct(def_id) => {\n             debug!(\"(building reduced graph for external \\\n@@ -3409,7 +3415,6 @@ pub impl Resolver {\n                       self_type,\n                       ref methods) => {\n                 self.resolve_implementation(item.id,\n-                                            item.span,\n                                             generics,\n                                             implemented_traits,\n                                             self_type,\n@@ -3718,13 +3723,30 @@ pub impl Resolver {\n         for type_parameters.each |type_parameter| {\n             for type_parameter.bounds.each |&bound| {\n                 match bound {\n-                    TraitTyParamBound(ty) => self.resolve_type(ty, visitor),\n+                    TraitTyParamBound(tref) => {\n+                        self.resolve_trait_reference(tref, visitor)\n+                    }\n                     RegionTyParamBound => {}\n                 }\n             }\n         }\n     }\n \n+    fn resolve_trait_reference(@mut self,\n+                               trait_reference: &trait_ref,\n+                               visitor: ResolveVisitor) {\n+        match self.resolve_path(trait_reference.path, TypeNS, true, visitor) {\n+            None => {\n+                self.session.span_err(trait_reference.path.span,\n+                                      ~\"attempt to implement an \\\n+                                        unknown trait\");\n+            }\n+            Some(def) => {\n+                self.record_def(trait_reference.ref_id, def);\n+            }\n+        }\n+    }\n+\n     fn resolve_struct(@mut self,\n                       id: node_id,\n                       generics: &Generics,\n@@ -3792,7 +3814,6 @@ pub impl Resolver {\n \n     fn resolve_implementation(@mut self,\n                               id: node_id,\n-                              span: span,\n                               generics: &Generics,\n                               opt_trait_reference: Option<@trait_ref>,\n                               self_type: @Ty,\n@@ -3811,25 +3832,16 @@ pub impl Resolver {\n             let original_trait_refs;\n             match opt_trait_reference {\n                 Some(trait_reference) => {\n-                    let mut new_trait_refs = ~[];\n-                    match self.resolve_path(\n-                        trait_reference.path, TypeNS, true, visitor) {\n-                        None => {\n-                            self.session.span_err(span,\n-                                                  ~\"attempt to implement an \\\n-                                                    unknown trait\");\n-                        }\n-                        Some(def) => {\n-                            self.record_def(trait_reference.ref_id, def);\n+                    self.resolve_trait_reference(trait_reference, visitor);\n \n-                            // Record the current trait reference.\n-                            new_trait_refs.push(def_id_of_def(def));\n-                        }\n-                    }\n                     // Record the current set of trait references.\n-                    let mut old = Some(new_trait_refs);\n-                    self.current_trait_refs <-> old;\n-                    original_trait_refs = Some(old);\n+                    let mut new_trait_refs = ~[];\n+                    for self.def_map.find(&trait_reference.ref_id).each |&def| {\n+                        new_trait_refs.push(def_id_of_def(*def));\n+                    }\n+                    original_trait_refs = Some(util::replace(\n+                        &mut self.current_trait_refs,\n+                        Some(new_trait_refs)));\n                 }\n                 None => {\n                     original_trait_refs = None;\n@@ -4952,7 +4964,7 @@ pub impl Resolver {\n                 match child_name_bindings.def_for_namespace(TypeNS) {\n                     Some(def) => {\n                         match def {\n-                            def_ty(trait_def_id) => {\n+                            def_trait(trait_def_id) => {\n                                 self.add_trait_info_if_containing_method(\n                                     &mut found_traits, trait_def_id, name);\n                             }\n@@ -4979,7 +4991,7 @@ pub impl Resolver {\n                         match target.bindings.def_for_namespace(TypeNS) {\n                             Some(def) => {\n                                 match def {\n-                                    def_ty(trait_def_id) => {\n+                                    def_trait(trait_def_id) => {\n                                         let added = self.\n                                         add_trait_info_if_containing_method(\n                                             &mut found_traits,"}, {"sha": "de14266573af9e42f3599a632cfa008ca10a6df4", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -148,7 +148,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             ast::def_self(*) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            ast::def_mod(*) | ast::def_foreign_mod(*) |\n+            ast::def_mod(*) | ast::def_foreign_mod(*) | ast::def_trait(*) |\n             ast::def_const(*) | ast::def_ty(*) | ast::def_prim_ty(*) |\n             ast::def_use(*) | ast::def_typaram_binder(*) |\n             ast::def_region(*) | ast::def_label(*) | ast::def_ty_param(*) |\n@@ -238,8 +238,7 @@ pub fn trans_fn_ref_with_vtables(\n \n     // Modify the def_id if this is a default method; we want to be\n     // monomorphizing the trait's code.\n-    let (def_id, opt_impl_did) =\n-            match tcx.provided_method_sources.find(&def_id) {\n+    let (def_id, opt_impl_did) = match tcx.provided_method_sources.find(&def_id) {\n         None => (def_id, None),\n         Some(source) => (source.method_id, Some(source.impl_id))\n     };"}, {"sha": "593d37c2ff8d1e9ee4cae429a6320de4c01e622d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -1062,9 +1062,6 @@ pub fn T_opaque_trait(cx: @CrateContext, store: ty::TraitStore) -> TypeRef {\n         ty::RegionTraitStore(_) => {\n             T_struct(~[T_ptr(cx.tydesc_type), T_ptr(T_i8())])\n         }\n-        ty::BareTraitStore => {\n-            cx.sess.bug(~\"can't make T_opaque_trait with bare trait store\")\n-        }\n     }\n }\n "}, {"sha": "d4a1013e83c85a8e0aaef642303c74213138c4cd", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -1714,7 +1714,6 @@ fn trans_assign_op(bcx: block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n-// NOTE: Mode neccessary here?\n fn shorten(+x: ~str) -> ~str {\n     if x.len() > 60 { x.substr(0, 60).to_owned() } else { x }\n }"}, {"sha": "d8c8301a83563332f40d37f9ed426ab8e6ab1495", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -40,7 +40,6 @@ use core::libc::c_uint;\n use core::str;\n use std::time;\n use syntax::ast;\n-use syntax::parse::token::special_idents;\n \n pub fn trans_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_free\");\n@@ -400,11 +399,9 @@ pub fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n-    let ty_visitor_name = special_idents::ty_visitor;\n-    assert!(bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n-    let (trait_id, ty) = *bcx.ccx().tcx.intrinsic_defs.get(&ty_visitor_name);\n-    let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n-    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n+    let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n+    let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n+    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n     build_return(bcx);\n }\n \n@@ -554,8 +551,7 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v0, t, drop_ty)\n       }\n-      ty::ty_trait(_, _, ty::BoxTraitStore) |\n-      ty::ty_trait(_, _, ty::BareTraitStore) => {\n+      ty::ty_trait(_, _, ty::BoxTraitStore) => {\n         let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n         decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n       }\n@@ -621,8 +617,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n-      ty::ty_trait(_, _, ty::BoxTraitStore) |\n-      ty::ty_trait(_, _, ty::BareTraitStore) => {\n+      ty::ty_trait(_, _, ty::BoxTraitStore) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, 1u]));\n         incr_refcnt_of_boxed(bcx, llbox);\n         bcx"}, {"sha": "2ca19b90754234d81bc68f4729f1f7ef7b694830", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -87,8 +87,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n             ccx.stats.n_inlines += 1;\n             ccx.external.insert(fn_id, Some(mth.id));\n             let ty::ty_param_bounds_and_ty {\n-                bounds: impl_bnds,\n-                region_param: _,\n+                generics: ty::Generics { bounds: impl_bnds, _ },\n                 ty: _\n             } = ty::lookup_item_type(ccx.tcx, impl_did);\n             if translate &&"}, {"sha": "bbf53480a56fb9f27799df0e74d9d3117909b220", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use back::abi;\n-use driver;\n use lib::llvm::llvm;\n use lib::llvm::ValueRef;\n use lib;\n@@ -174,6 +173,7 @@ pub fn trans_method_callee(bcx: block,\n                            mentry: typeck::method_map_entry)\n                         -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n+    let tcx = bcx.tcx();\n \n     debug!(\"trans_method_callee(callee_id=%?, self=%s, mentry=%?)\",\n            callee_id, bcx.expr_to_str(self), mentry);\n@@ -189,33 +189,33 @@ pub fn trans_method_callee(bcx: block,\n \n             // Get the ID of the method we're calling.\n             let method_name =\n-                ty::trait_methods(bcx.tcx(), trait_id)[method_index].ident;\n-            let method_id = method_with_name(bcx.ccx(), impl_def_id,\n-                                             method_name);\n+                ty::trait_method(tcx, trait_id, method_index).ident;\n+            let method_id =\n+                method_with_name(bcx.ccx(), impl_def_id, method_name);\n             origin = typeck::method_static(method_id);\n         }\n         typeck::method_super(trait_id, method_index) => {\n             // <self_ty> is the self type for this method call\n             let self_ty = node_id_type(bcx, self.id);\n-            let tcx = bcx.tcx();\n             // <impl_id> is the ID of the implementation of\n             // trait <trait_id> for type <self_ty>\n             let impl_id = ty::get_impl_id(tcx, trait_id, self_ty);\n             // Get the supertrait's methods\n-            let supertrait_methods = ty::trait_methods(tcx, trait_id);\n+            let supertrait_method_def_ids = ty::trait_method_def_ids(tcx, trait_id);\n             // Make sure to fail with a readable error message if\n             // there's some internal error here\n-            if !(method_index < supertrait_methods.len()) {\n+            if !(method_index < supertrait_method_def_ids.len()) {\n                 tcx.sess.bug(~\"trans_method_callee: supertrait method \\\n                                index is out of bounds\");\n             }\n             // Get the method name using the method index in the origin\n-            let method_name = supertrait_methods[method_index].ident;\n+            let method_name =\n+                ty::method(tcx, supertrait_method_def_ids[method_index]).ident;\n             // Now that we know the impl ID, we can look up the method\n             // ID from its name\n             origin = typeck::method_static(method_with_name(bcx.ccx(),\n-                                              impl_id,\n-                                              method_name));\n+                                                            impl_id,\n+                                                            method_name));\n         }\n         typeck::method_static(*) | typeck::method_param(*) |\n         typeck::method_trait(*) => {}\n@@ -301,8 +301,8 @@ pub fn trans_static_method_callee(bcx: block,\n     // found on the type parametesr T1...Tn to find the index of the\n     // one we are interested in.\n     let bound_index = {\n-        let trait_polyty = ty::lookup_item_type(bcx.tcx(), trait_id);\n-        ty::count_traits_and_supertraits(bcx.tcx(), *trait_polyty.bounds)\n+        let trait_def = ty::lookup_trait_def(bcx.tcx(), trait_id);\n+        ty::count_traits_and_supertraits(bcx.tcx(), *trait_def.generics.bounds)\n     };\n \n     let mname = if method_id.crate == ast::local_crate {\n@@ -375,7 +375,8 @@ pub fn method_with_name(ccx: @CrateContext, impl_id: ast::def_id,\n     }\n }\n \n-pub fn method_with_name_or_default(ccx: @CrateContext, impl_id: ast::def_id,\n+pub fn method_with_name_or_default(ccx: @CrateContext,\n+                                   impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match *ccx.tcx.items.get(&impl_id.node) {\n@@ -448,7 +449,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n     return match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n-          let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;\n+          let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n           let mth_id = method_with_name_or_default(\n               bcx.ccx(), impl_did, mname);\n \n@@ -550,8 +551,10 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     // rcvr + method bounds.\n     let ccx = bcx.ccx(), tcx = bcx.tcx();\n     let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n-    let ty::ty_param_bounds_and_ty {bounds: r_m_bounds, _}\n-        = ty::lookup_item_type(tcx, mth_did);\n+    let ty::ty_param_bounds_and_ty {\n+        generics: ty::Generics {bounds: r_m_bounds, _},\n+        _\n+    } = ty::lookup_item_type(tcx, mth_did);\n     let n_r_m_tps = r_m_bounds.len(); // rcvr + method tps\n     let m_boundss = vec::slice(*r_m_bounds, n_r_m_tps - n_m_tps, n_r_m_tps);\n \n@@ -654,7 +657,6 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             // payload.\n             match store {\n                 ty::BoxTraitStore |\n-                ty::BareTraitStore |\n                 ty::UniqTraitStore => {\n                     llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n                 }\n@@ -677,7 +679,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n \n             // Pass a pointer to the box.\n             match store {\n-                ty::BoxTraitStore | ty::BareTraitStore => llself = llbox,\n+                ty::BoxTraitStore => llself = llbox,\n                 _ => bcx.tcx().sess.bug(~\"@self receiver with non-@Trait\")\n             }\n \n@@ -783,18 +785,14 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n     let tcx = ccx.tcx;\n \n     // XXX: This should support multiple traits.\n-    let trt_id = driver::session::expect(\n-        tcx.sess,\n-        ty::ty_to_def_id(ty::impl_traits(tcx,\n-                                         impl_id,\n-                                         ty::BoxTraitStore)[0]),\n-        || ~\"make_impl_vtable: non-trait-type implemented\");\n-\n-    let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n-    make_vtable(ccx, vec::map(*ty::trait_methods(tcx, trt_id), |im| {\n+    let trt_id = ty::impl_trait_refs(tcx, impl_id)[0].def_id;\n+\n+    let has_tps = ty::lookup_item_type(ccx.tcx, impl_id).generics.bounds.len() > 0u;\n+    make_vtable(ccx, ty::trait_method_def_ids(tcx, trt_id).map(|method_def_id| {\n+        let im = ty::method(tcx, *method_def_id);\n         let fty = ty::subst_tps(tcx, substs, None,\n                                 ty::mk_bare_fn(tcx, copy im.fty));\n-        if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n+        if im.generics.bounds.len() > 0u || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    *tcx.sess.str_of(im.ident));\n             C_null(T_ptr(T_nil()))\n@@ -841,7 +839,7 @@ pub fn trans_trait_cast(bcx: block,\n     let v_ty = expr_ty(bcx, val);\n \n     match store {\n-        ty::RegionTraitStore(_) | ty::BoxTraitStore | ty::BareTraitStore => {\n+        ty::RegionTraitStore(_) | ty::BoxTraitStore => {\n             let mut llboxdest = GEPi(bcx, lldest, [0u, 1u]);\n             // Just store the pointer into the pair.\n             llboxdest = PointerCast(bcx,"}, {"sha": "319f57fb75ce07ba17eaa46dc0e4d0c508f7b0b8", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -169,7 +169,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let psubsts = Some(@param_substs {\n         tys: substs,\n         vtables: vtables,\n-        bounds: tpt.bounds,\n+        bounds: tpt.generics.bounds,\n         self_ty: impl_ty_opt\n     });\n \n@@ -291,7 +291,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n         ty::ty_trait(_, _, ref store) => {\n             let sigil = match *store {\n                 ty::UniqTraitStore => ast::OwnedSigil,\n-                ty::BoxTraitStore | ty::BareTraitStore => ast::ManagedSigil,\n+                ty::BoxTraitStore => ast::ManagedSigil,\n                 ty::RegionTraitStore(_) => ast::BorrowedSigil,\n             };\n \n@@ -328,7 +328,7 @@ pub fn make_mono_id(ccx: @CrateContext, item: ast::def_id, substs: &[ty::t],\n                     +param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n-        let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n+        let bounds = ty::lookup_item_type(ccx.tcx, item).generics.bounds;\n         let mut i = 0;\n         vec::map2(*bounds, substs, |bounds, subst| {\n             let mut v = ~[];"}, {"sha": "224981d6e759aaaca939eb29422526f6806537f8", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -31,7 +31,7 @@ use syntax::ast;\n \n pub struct Reflector {\n     visitor_val: ValueRef,\n-    visitor_methods: @~[ty::method],\n+    visitor_methods: @~[@ty::method],\n     final_bcx: block,\n     tydesc_ty: TypeRef,\n     bcx: block"}, {"sha": "b20678ac092e02c4227264170bf11cf539ef3d1c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 217, "deletions": 154, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -25,8 +25,10 @@ use middle;\n use util::ppaux::{note_and_explain_region, bound_region_to_str};\n use util::ppaux::{region_to_str, vstore_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, tys_to_str};\n+use util::ppaux::{trait_ref_to_str};\n use util::common::{indenter};\n \n+use core;\n use core::cast;\n use core::cmp;\n use core::ops;\n@@ -44,6 +46,7 @@ use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::print::pprust;\n+use syntax::parse::token::special_idents;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -70,7 +73,8 @@ pub type param_bounds = @~[param_bound];\n \n pub struct method {\n     ident: ast::ident,\n-    tps: @~[param_bounds],\n+    generics: ty::Generics,\n+    transformed_self_ty: Option<ty::t>,\n     fty: BareFnTy,\n     self_ty: ast::self_ty_,\n     vis: ast::visibility,\n@@ -95,9 +99,8 @@ pub enum vstore {\n \n #[auto_encode]\n #[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum TraitStore {\n-    BareTraitStore,             // a plain trait without a sigil\n     BoxTraitStore,              // @Trait\n     UniqTraitStore,             // ~Trait\n     RegionTraitStore(Region),   // &Trait\n@@ -224,11 +227,6 @@ pub struct ProvidedMethodSource {\n     impl_id: ast::def_id\n }\n \n-pub struct InstantiatedTraitRef {\n-    def_id: ast::def_id,\n-    tpt: ty_param_substs_and_ty\n-}\n-\n pub type ctxt = @ctxt_;\n \n struct ctxt_ {\n@@ -255,8 +253,21 @@ struct ctxt_ {\n     // other items.\n     node_type_substs: @mut HashMap<node_id, ~[t]>,\n \n+    // Maps from a method to the method \"descriptor\"\n+    methods: @mut HashMap<def_id, @method>,\n+\n+    // Maps from a trait def-id to a list of the def-ids of its methods\n+    trait_method_def_ids: @mut HashMap<def_id, @~[def_id]>,\n+\n+    // A cache for the trait_methods() routine\n+    trait_methods_cache: @mut HashMap<def_id, @~[@method]>,\n+\n+    trait_refs: @mut HashMap<node_id, @TraitRef>,\n+    trait_defs: @mut HashMap<def_id, @TraitDef>,\n+\n     items: ast_map::map,\n     intrinsic_defs: @mut HashMap<ast::ident, (ast::def_id, t)>,\n+    intrinsic_traits: @mut HashMap<ast::ident, @TraitRef>,\n     freevars: freevars::freevar_map,\n     tcache: type_cache,\n     rcache: creader_cache,\n@@ -266,7 +277,6 @@ struct ctxt_ {\n     tc_cache: @mut HashMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: @mut HashMap<def_id, @~[VariantInfo]>,\n-    trait_method_cache: @mut HashMap<def_id, @~[method]>,\n     ty_param_bounds: @mut HashMap<ast::node_id, param_bounds>,\n     inferred_modes: @mut HashMap<ast::node_id, ast::mode>,\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n@@ -277,7 +287,7 @@ struct ctxt_ {\n     // that implementation implements.\n     provided_methods: ProvidedMethodsMap,\n     provided_method_sources: @mut HashMap<ast::def_id, ProvidedMethodSource>,\n-    supertraits: @mut HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n+    supertraits: @mut HashMap<ast::def_id, @~[@TraitRef]>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n@@ -527,6 +537,12 @@ pub enum sty {\n     ty_unboxed_vec(mt),\n }\n \n+#[deriving(Eq, IterBytes)]\n+pub struct TraitRef {\n+    def_id: def_id,\n+    substs: substs\n+}\n+\n #[deriving(Eq)]\n pub enum IntVarValue {\n     IntType(ast::int_ty),\n@@ -573,16 +589,17 @@ pub enum type_err {\n     terr_self_substs,\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n-    terr_float_mismatch(expected_found<ast::float_ty>)\n+    terr_float_mismatch(expected_found<ast::float_ty>),\n+    terr_traits(expected_found<ast::def_id>),\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum param_bound {\n     bound_copy,\n     bound_durable,\n     bound_owned,\n     bound_const,\n-    bound_trait(t),\n+    bound_trait(@TraitRef),\n }\n \n #[deriving(Eq)]\n@@ -651,19 +668,6 @@ impl cmp::Eq for InferRegion {\n     }\n }\n \n-impl to_bytes::IterBytes for param_bound {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          bound_copy => 0u8.iter_bytes(lsb0, f),\n-          bound_durable => 1u8.iter_bytes(lsb0, f),\n-          bound_owned => 2u8.iter_bytes(lsb0, f),\n-          bound_const => 3u8.iter_bytes(lsb0, f),\n-          bound_trait(ref t) =>\n-          to_bytes::iter_bytes_2(&4u8, t, lsb0, f)\n-        }\n-    }\n-}\n-\n pub trait Vid {\n     fn to_uint(&self) -> uint;\n }\n@@ -750,6 +754,13 @@ impl to_bytes::IterBytes for RegionVid {\n     }\n }\n \n+/// Information about the type/lifetime parametesr associated with an item.\n+/// Analogous to ast::Generics.\n+pub struct Generics {\n+    bounds: @~[param_bounds],\n+    region_param: Option<region_variance>,\n+}\n+\n /// A polytype.\n ///\n /// - `bounds`: The list of bounds for each type parameter.  The length of the\n@@ -761,11 +772,16 @@ impl to_bytes::IterBytes for RegionVid {\n /// - `ty`: the base type.  May have reference to the (unsubstituted) bound\n ///   region `&self` or to (unsubstituted) ty_param types\n pub struct ty_param_bounds_and_ty {\n-    bounds: @~[param_bounds],\n-    region_param: Option<region_variance>,\n+    generics: Generics,\n     ty: t\n }\n \n+/// As `ty_param_bounds_and_ty` but for a trait ref.\n+pub struct TraitDef {\n+    generics: Generics,\n+    trait_ref: @ty::TraitRef,\n+}\n+\n pub struct ty_param_substs_and_ty {\n     substs: ty::substs,\n     ty: ty::t\n@@ -820,6 +836,9 @@ pub fn mk_ctxt(s: session::Session,\n         region_paramd_items: region_paramd_items,\n         node_types: @mut SmallIntMap::new(),\n         node_type_substs: @mut HashMap::new(),\n+        trait_refs: @mut HashMap::new(),\n+        trait_defs: @mut HashMap::new(),\n+        intrinsic_traits: @mut HashMap::new(),\n         items: amap,\n         intrinsic_defs: @mut HashMap::new(),\n         freevars: freevars,\n@@ -831,7 +850,9 @@ pub fn mk_ctxt(s: session::Session,\n         tc_cache: @mut HashMap::new(),\n         ast_ty_to_ty_cache: @mut HashMap::new(),\n         enum_var_cache: @mut HashMap::new(),\n-        trait_method_cache: @mut HashMap::new(),\n+        methods: @mut HashMap::new(),\n+        trait_method_def_ids: @mut HashMap::new(),\n+        trait_methods_cache: @mut HashMap::new(),\n         ty_param_bounds: @mut HashMap::new(),\n         inferred_modes: @mut HashMap::new(),\n         adjustments: @mut HashMap::new(),\n@@ -1401,7 +1422,7 @@ pub fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n         bound_durable => ~\"'static\",\n         bound_owned => ~\"owned\",\n         bound_const => ~\"const\",\n-        bound_trait(t) => ::util::ppaux::ty_to_str(cx, t)\n+        bound_trait(t) => ::util::ppaux::trait_ref_to_str(cx, t)\n     }\n }\n \n@@ -1455,13 +1476,26 @@ pub fn subst(cx: ctxt,\n     }\n }\n \n+pub fn subst_in_trait_ref(cx: ctxt,\n+                          substs: &substs,\n+                          trait_ref: &ty::TraitRef) -> ty::TraitRef\n+{\n+    ty::TraitRef {\n+        def_id: trait_ref.def_id,\n+        substs: subst_in_substs(cx, substs, &trait_ref.substs)\n+    }\n+}\n+\n // Performs substitutions on a set of substitutions (result = sup(sub)) to\n // yield a new set of substitutions. This is used in trait inheritance.\n-pub fn subst_substs(cx: ctxt, sup: &substs, sub: &substs) -> substs {\n+pub fn subst_in_substs(cx: ctxt,\n+                       substs: &substs,\n+                       in_substs: &substs) -> substs\n+{\n     substs {\n-        self_r: sup.self_r,\n-        self_ty: sup.self_ty.map(|typ| subst(cx, sub, *typ)),\n-        tps: sup.tps.map(|typ| subst(cx, sub, *typ))\n+        self_r: in_substs.self_r,\n+        self_ty: in_substs.self_ty.map(|&typ| subst(cx, substs, typ)),\n+        tps: in_substs.tps.map(|&typ| subst(cx, substs, typ))\n     }\n }\n \n@@ -1477,6 +1511,11 @@ pub fn type_is_error(ty: t) -> bool {\n     (get(ty).flags & (has_ty_err as uint)) != 0\n }\n \n+pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n+    tref.substs.self_ty.any(|&t| type_is_error(t)) ||\n+        tref.substs.tps.any(|&t| type_is_error(t))\n+}\n+\n pub fn type_is_ty_var(ty: t) -> bool {\n     match get(ty).sty {\n       ty_infer(TyVar(_)) => true,\n@@ -1921,8 +1960,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_OWNED_CLOSURE\n             }\n \n-            ty_trait(_, _, BoxTraitStore) |\n-            ty_trait(_, _, BareTraitStore) => {\n+            ty_trait(_, _, BoxTraitStore) => {\n                 TC_MANAGED\n             }\n \n@@ -2581,17 +2619,6 @@ impl to_bytes::IterBytes for vstore {\n     }\n }\n \n-impl to_bytes::IterBytes for TraitStore {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          BareTraitStore => 0u8.iter_bytes(lsb0, f),\n-          UniqTraitStore => 1u8.iter_bytes(lsb0, f),\n-          BoxTraitStore => 2u8.iter_bytes(lsb0, f),\n-          RegionTraitStore(ref r) => to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n-        }\n-    }\n-}\n-\n impl to_bytes::IterBytes for substs {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n@@ -2704,6 +2731,16 @@ impl to_bytes::IterBytes for sty {\n     }\n }\n \n+pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n+    match cx.trait_refs.find(&id) {\n+       Some(&t) => t,\n+       None => cx.sess.bug(\n+           fmt!(\"node_id_to_trait_ref: no trait ref for node `%s`\",\n+                ast_map::node_id_to_str(cx.items, id,\n+                                        cx.sess.parse_sess.interner)))\n+    }\n+}\n+\n pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     //io::println(fmt!(\"%?/%?\", id, cx.node_types.len()));\n     match cx.node_types.find(&(id as uint)) {\n@@ -2726,6 +2763,16 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n     cx.node_type_substs.contains_key(&id)\n }\n \n+pub fn ty_fn_sig(fty: t) -> FnSig {\n+    match get(fty).sty {\n+        ty_bare_fn(ref f) => copy f.sig,\n+        ty_closure(ref f) => copy f.sig,\n+        ref s => {\n+            fail!(fmt!(\"ty_fn_sig() called on non-fn type: %?\", s))\n+        }\n+    }\n+}\n+\n // Type accessors for substructures of types\n pub fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).sty {\n@@ -3004,7 +3051,7 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n             // n.b.: When we encode impl methods, the bounds\n             // that we encode include both the impl bounds\n             // and then the method bounds themselves...\n-            ty::lookup_item_type(tcx, did).bounds\n+            ty::lookup_item_type(tcx, did).generics.bounds\n           }\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n@@ -3015,10 +3062,9 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n-            let trt_bounds =\n-                ty::lookup_item_type(tcx, trt_id).bounds;\n+            let trt_bounds = ty::lookup_trait_def(tcx, trt_id).generics.bounds;\n             @(vec::append(/*bad*/copy *trt_bounds,\n-                          *ty::trait_methods(tcx, trt_id)[n_mth].tps))\n+                          *ty::trait_method(tcx, trt_id, n_mth).generics.bounds))\n           }\n         }\n     }\n@@ -3203,10 +3249,8 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n-pub fn method_idx(id: ast::ident, meths: &[method]) -> Option<uint> {\n-    let mut i = 0u;\n-    for meths.each |m| { if m.ident == id { return Some(i); } i += 1u; }\n-    return None;\n+pub fn method_idx(id: ast::ident, meths: &[@method]) -> Option<uint> {\n+    vec::position(meths, |m| m.ident == id)\n }\n \n /// Returns a vector containing the indices of all type parameters that appear\n@@ -3469,6 +3513,11 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  ty_sort_str(cx, values.expected),\n                  ty_sort_str(cx, values.found))\n         }\n+        terr_traits(values) => {\n+            fmt!(\"expected trait %s but found trait %s\",\n+                 item_path_str(cx, values.expected),\n+                 item_path_str(cx, values.found))\n+        }\n         terr_self_substs => {\n             ~\"inconsistent self substitution\" // XXX this is more of a bug\n         }\n@@ -3527,10 +3576,6 @@ pub fn def_has_ty_params(def: ast::def) -> bool {\n     }\n }\n \n-pub fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n-    cx.trait_method_cache.insert(ast_util::local_def(id), ms);\n-}\n-\n pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     if is_local(id) {\n         match cx.items.find(&id.node) {\n@@ -3550,11 +3595,11 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n }\n \n pub fn trait_supertraits(cx: ctxt,\n-                         id: ast::def_id)\n-                      -> @~[InstantiatedTraitRef] {\n+                         id: ast::def_id) -> @~[@TraitRef]\n+{\n     // Check the cache.\n     match cx.supertraits.find(&id) {\n-        Some(&instantiated_trait_info) => { return instantiated_trait_info; }\n+        Some(&trait_refs) => { return trait_refs; }\n         None => {}  // Continue.\n     }\n \n@@ -3563,81 +3608,89 @@ pub fn trait_supertraits(cx: ctxt,\n     assert!(!is_local(id));\n \n     // Get the supertraits out of the metadata and create the\n-    // InstantiatedTraitRef for each.\n-    let mut result = ~[];\n-    for csearch::get_supertraits(cx, id).each |trait_type| {\n-        match get(*trait_type).sty {\n-            ty_trait(def_id, ref substs, _) => {\n-                result.push(InstantiatedTraitRef {\n-                    def_id: def_id,\n-                    tpt: ty_param_substs_and_ty {\n-                        substs: (/*bad*/copy *substs),\n-                        ty: *trait_type\n-                    }\n-                });\n-            }\n-            _ => cx.sess.bug(~\"trait_supertraits: trait ref wasn't a trait\")\n-        }\n-    }\n-\n-    // Unwrap and return the result.\n-    return @result;\n+    // TraitRef for each.\n+    let result = @csearch::get_supertraits(cx, id);\n+    cx.supertraits.insert(id, result);\n+    return result;\n }\n \n-pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n-    match cx.trait_method_cache.find(&id) {\n-      // Local traits are supposed to have been added explicitly.\n-      Some(&ms) => ms,\n-      _ => {\n-        // If the lookup in trait_method_cache fails, assume that the trait\n-        // method we're trying to look up is in a different crate, and look\n-        // for it there.\n-        assert!(id.crate != ast::local_crate);\n-        let result = csearch::get_trait_methods(cx, id);\n+fn lookup_locally_or_in_crate_store<V:Copy>(\n+    descr: &str,\n+    def_id: ast::def_id,\n+    map: &mut HashMap<ast::def_id, V>,\n+    load_external: &fn() -> V) -> V\n+{\n+    /*!\n+     *\n+     * Helper for looking things up in the various maps\n+     * that are populated during typeck::collect (e.g.,\n+     * `cx.methods`, `cx.tcache`, etc).  All of these share\n+     * the pattern that if the id is local, it should have\n+     * been loaded into the map by the `typeck::collect` phase.\n+     * If the def-id is external, then we have to go consult\n+     * the crate loading code (and cache the result for the future).\n+     */\n+\n+    match map.find(&def_id) {\n+        Some(&v) => { return v; }\n+        None => { }\n+    }\n \n-        // Store the trait method in the local trait_method_cache so that\n-        // future lookups succeed.\n-        cx.trait_method_cache.insert(id, result);\n-        result\n-      }\n+    if def_id.crate == ast::local_crate {\n+        fail!(fmt!(\"No def'n found for %? in tcx.%s\",\n+                   def_id, descr));\n     }\n+    let v = load_external();\n+    map.insert(def_id, v);\n+    return v;\n }\n \n-/*\n-  Could this return a list of (def_id, substs) pairs?\n- */\n-pub fn impl_traits(cx: ctxt, id: ast::def_id, store: TraitStore) -> ~[t] {\n-    fn storeify(cx: ctxt, ty: t, store: TraitStore) -> t {\n-        match ty::get(ty).sty {\n-            ty::ty_trait(did, ref substs, trait_store) => {\n-                if store == trait_store {\n-                    ty\n-                } else {\n-                    mk_trait(cx, did, (/*bad*/copy *substs), store)\n-                }\n-            }\n-            _ => cx.sess.bug(~\"impl_traits: not a trait\")\n+pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @method {\n+    let method_def_id = ty::trait_method_def_ids(cx, trait_did)[idx];\n+    ty::method(cx, method_def_id)\n+}\n+\n+pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@method] {\n+    match cx.trait_methods_cache.find(&trait_did) {\n+        Some(&methods) => methods,\n+        None => {\n+            let def_ids = ty::trait_method_def_ids(cx, trait_did);\n+            let methods = @def_ids.map(|d| ty::method(cx, *d));\n+            cx.trait_methods_cache.insert(trait_did, methods);\n+            methods\n         }\n     }\n+}\n+\n+pub fn method(cx: ctxt, id: ast::def_id) -> @method {\n+    lookup_locally_or_in_crate_store(\n+        \"methods\", id, cx.methods,\n+        || @csearch::get_method(cx, id))\n+}\n+\n+pub fn trait_method_def_ids(cx: ctxt, id: ast::def_id) -> @~[def_id] {\n+    lookup_locally_or_in_crate_store(\n+        \"methods\", id, cx.trait_method_def_ids,\n+        || @csearch::get_trait_method_def_ids(cx.cstore, id))\n+}\n \n+pub fn impl_trait_refs(cx: ctxt, id: ast::def_id) -> ~[@TraitRef] {\n     if id.crate == ast::local_crate {\n         debug!(\"(impl_traits) searching for trait impl %?\", id);\n         match cx.items.find(&id.node) {\n            Some(&ast_map::node_item(@ast::item {\n                         node: ast::item_impl(_, opt_trait, _, _),\n                         _},\n                     _)) => {\n-\n-               do opt_trait.map_default(~[]) |trait_ref| {\n-                   ~[storeify(cx, node_id_to_type(cx, trait_ref.ref_id),\n-                              store)]\n+               match opt_trait {\n+                   Some(t) => ~[ty::node_id_to_trait_ref(cx, t.ref_id)],\n+                   None => ~[]\n                }\n            }\n            _ => ~[]\n         }\n     } else {\n-        vec::map(csearch::get_impl_traits(cx, id),\n-                 |x| storeify(cx, *x, store))\n+        csearch::get_impl_traits(cx, id)\n     }\n }\n \n@@ -3906,18 +3959,25 @@ pub fn enum_variant_with_id(cx: ctxt,\n pub fn lookup_item_type(cx: ctxt,\n                         did: ast::def_id)\n                      -> ty_param_bounds_and_ty {\n-    match cx.tcache.find(&did) {\n-      Some(&tpt) => {\n-        // The item is in this crate. The caller should have added it to the\n-        // type cache already\n-        return tpt;\n-      }\n-      None => {\n-        assert!(did.crate != ast::local_crate);\n-        let tyt = csearch::get_type(cx, did);\n-        cx.tcache.insert(did, tyt);\n-        return tyt;\n-      }\n+    lookup_locally_or_in_crate_store(\n+        \"tcache\", did, cx.tcache,\n+        || csearch::get_type(cx, did))\n+}\n+\n+/// Given the did of a trait, returns its canonical trait ref.\n+pub fn lookup_trait_def(cx: ctxt, did: ast::def_id) -> @ty::TraitDef {\n+    match cx.trait_defs.find(&did) {\n+        Some(&trait_def) => {\n+            // The item is in this crate. The caller should have added it to the\n+            // type cache already\n+            return trait_def;\n+        }\n+        None => {\n+            assert!(did.crate != ast::local_crate);\n+            let trait_def = @csearch::get_trait_def(cx, did);\n+            cx.trait_defs.insert(did, trait_def);\n+            return trait_def;\n+        }\n     }\n }\n \n@@ -4204,9 +4264,6 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n                 t\n             },\n \n-        ty_trait(did, ref substs, BareTraitStore) =>\n-            mk_trait(cx, did, copy *substs, BoxTraitStore),\n-\n         _ =>\n             t\n     };\n@@ -4272,12 +4329,11 @@ pub fn determine_inherited_purity(parent_purity: ast::purity,\n // list.\n pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n                                          bounds: param_bounds,\n-                                         f: &fn(t) -> bool) {\n+                                         f: &fn(&TraitRef) -> bool) {\n     let mut fin = false;\n \n     for bounds.each |bound| {\n-\n-        let bound_trait_ty = match *bound {\n+        let bound_trait_ref = match *bound {\n             ty::bound_trait(bound_t) => bound_t,\n \n             ty::bound_copy | ty::bound_owned |\n@@ -4286,39 +4342,38 @@ pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n             }\n         };\n \n-        let mut supertrait_map = HashMap::new();\n+        let mut supertrait_set = HashMap::new();\n         let mut seen_def_ids = ~[];\n         let mut i = 0;\n-        let trait_ty_id = ty_to_def_id(bound_trait_ty).expect(\n-            ~\"iter_trait_ty_supertraits got a non-trait type\");\n-        let mut trait_ty = bound_trait_ty;\n+        let trait_ty_id = bound_trait_ref.def_id;\n+        let mut trait_ref = bound_trait_ref;\n \n-        debug!(\"iter_bound_traits_and_supertraits: trait_ty = %s\",\n-               ty_to_str(tcx, trait_ty));\n+        debug!(\"iter_bound_traits_and_supertraits: trait_ref = %s\",\n+               trait_ref_to_str(tcx, trait_ref));\n \n         // Add the given trait ty to the hash map\n-        supertrait_map.insert(trait_ty_id, trait_ty);\n+        supertrait_set.insert(trait_ty_id, ());\n         seen_def_ids.push(trait_ty_id);\n \n-        if f(trait_ty) {\n+        if f(trait_ref) {\n             // Add all the supertraits to the hash map,\n             // executing <f> on each of them\n-            while i < supertrait_map.len() && !fin {\n+            while i < supertrait_set.len() && !fin {\n                 let init_trait_id = seen_def_ids[i];\n                 i += 1;\n-                 // Add supertraits to supertrait_map\n-                let supertraits = trait_supertraits(tcx, init_trait_id);\n-                for supertraits.each |supertrait| {\n-                    let super_t = supertrait.tpt.ty;\n-                    let d_id = ty_to_def_id(super_t).expect(\"supertrait \\\n-                        should be a trait ty\");\n-                    if !supertrait_map.contains_key(&d_id) {\n-                        supertrait_map.insert(d_id, super_t);\n-                        trait_ty = super_t;\n+\n+                 // Add supertraits to supertrait_set\n+                let supertrait_refs = trait_supertraits(tcx, init_trait_id);\n+                for supertrait_refs.each |&supertrait_ref| {\n+                    let d_id = supertrait_ref.def_id;\n+                    if !supertrait_set.contains_key(&d_id) {\n+                        // FIXME(#5527) Could have same trait multiple times\n+                        supertrait_set.insert(d_id, ());\n+                        trait_ref = supertrait_ref;\n                         seen_def_ids.push(d_id);\n                     }\n-                    debug!(\"A super_t = %s\", ty_to_str(tcx, trait_ty));\n-                    if !f(trait_ty) {\n+                    debug!(\"A super_t = %s\", trait_ref_to_str(tcx, trait_ref));\n+                    if !f(trait_ref) {\n                         fin = true;\n                     }\n                 }\n@@ -4355,6 +4410,14 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n     }\n }\n \n+pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n+    let ty_visitor_name = special_idents::ty_visitor;\n+    assert!(tcx.intrinsic_traits.contains_key(&ty_visitor_name));\n+    let trait_ref = *tcx.intrinsic_traits.get(&ty_visitor_name);\n+    (trait_ref,\n+     mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs, BoxTraitStore))\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "209091ecd6643bd8ad03355fd89d9e0bb9dce41b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 179, "deletions": 67, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -14,14 +14,14 @@\n  * is parameterized by an instance of `AstConv` and a `region_scope`.\n  *\n  * The parameterization of `ast_ty_to_ty()` is because it behaves\n- * somewhat differently during the collect and check phases, particularly\n- * with respect to looking up the types of top-level items.  In the\n- * collect phase, the crate context is used as the `AstConv` instance;\n- * in this phase, the `get_item_ty()` function triggers a recursive call\n- * to `ty_of_item()` (note that `ast_ty_to_ty()` will detect recursive\n- * types and report an error).  In the check phase, when the @FnCtxt is\n- * used as the `AstConv`, `get_item_ty()` just looks up the item type in\n- * `tcx.tcache`.\n+ * somewhat differently during the collect and check phases,\n+ * particularly with respect to looking up the types of top-level\n+ * items.  In the collect phase, the crate context is used as the\n+ * `AstConv` instance; in this phase, the `get_item_ty()` function\n+ * triggers a recursive call to `ty_of_item()`  (note that\n+ * `ast_ty_to_ty()` will detect recursive types and report an error).\n+ * In the check phase, when the @FnCtxt is used as the `AstConv`,\n+ * `get_item_ty()` just looks up the item type in `tcx.tcache`.\n  *\n  * The `region_scope` trait controls how region references are\n  * handled.  It has two methods which are used to resolve anonymous\n@@ -76,6 +76,7 @@ use util::common::indenter;\n pub trait AstConv {\n     fn tcx(&self) -> ty::ctxt;\n     fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n+    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef;\n \n     // what type should we use when a type is omitted?\n     fn ty_infer(&self, span: span) -> ty::t;\n@@ -129,62 +130,96 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + Durable>(\n     get_region_reporting_err(self.tcx(), span, opt_lifetime, res)\n }\n \n-pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: &AC,\n-        rscope: &RS,\n-        did: ast::def_id,\n-        path: @ast::path)\n-     -> ty_param_substs_and_ty {\n-    let tcx = self.tcx();\n-    let ty::ty_param_bounds_and_ty {\n-        bounds: decl_bounds,\n-        region_param: decl_rp,\n-        ty: decl_ty\n-    } = self.get_item_ty(did);\n+fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + Durable>(\n+    self: &AC,\n+    rscope: &RS,\n+    def_id: ast::def_id,\n+    decl_generics: &ty::Generics,\n+    path: @ast::path) -> ty::substs\n+{\n+    /*!\n+     *\n+     * Given a path `path` that refers to an item `I` with the\n+     * declared generics `decl_generics`, returns an appropriate\n+     * set of substitutions for this particular reference to `I`.\n+     */\n \n-    debug!(\"ast_path_to_substs_and_ty: did=%? decl_rp=%?\",\n-           did, decl_rp);\n+    let tcx = self.tcx();\n \n     // If the type is parameterized by the self region, then replace self\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let self_r = match (decl_rp, path.rp) {\n-      (None, None) => {\n+    let self_r = match (&decl_generics.region_param, &path.rp) {\n+      (&None, &None) => {\n         None\n       }\n-      (None, Some(_)) => {\n+      (&None, &Some(_)) => {\n         tcx.sess.span_err(\n             path.span,\n             fmt!(\"no region bound is allowed on `%s`, \\\n                   which is not declared as containing region pointers\",\n-                 ty::item_path_str(tcx, did)));\n+                 ty::item_path_str(tcx, def_id)));\n         None\n       }\n-      (Some(_), None) => {\n+      (&Some(_), &None) => {\n         let res = rscope.anon_region(path.span);\n         let r = get_region_reporting_err(self.tcx(), path.span, None, res);\n         Some(r)\n       }\n-      (Some(_), Some(_)) => {\n+      (&Some(_), &Some(_)) => {\n         Some(ast_region_to_region(self, rscope, path.span, path.rp))\n       }\n     };\n \n     // Convert the type parameters supplied by the user.\n-    if !vec::same_length(*decl_bounds, path.types) {\n+    if !vec::same_length(*decl_generics.bounds, path.types) {\n         self.tcx().sess.span_fatal(\n             path.span,\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n-                 (*decl_bounds).len(), path.types.len()));\n+                 decl_generics.bounds.len(), path.types.len()));\n     }\n     let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, *a_t));\n \n-    let substs = substs {self_r:self_r, self_ty:None, tps:tps};\n-    let ty = ty::subst(tcx, &substs, decl_ty);\n+    substs {self_r:self_r, self_ty:None, tps:tps}\n+}\n \n+pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n+    self: &AC,\n+    rscope: &RS,\n+    did: ast::def_id,\n+    path: @ast::path) -> ty_param_substs_and_ty\n+{\n+    let tcx = self.tcx();\n+    let ty::ty_param_bounds_and_ty {\n+        generics: generics,\n+        ty: decl_ty\n+    } = self.get_item_ty(did);\n+\n+    let substs = ast_path_substs(self, rscope, did, &generics, path);\n+    let ty = ty::subst(tcx, &substs, decl_ty);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n+pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + Durable>(\n+    self: &AC,\n+    rscope: &RS,\n+    trait_def_id: ast::def_id,\n+    path: @ast::path) -> @ty::TraitRef\n+{\n+    let trait_def =\n+        self.get_trait_def(trait_def_id);\n+    let substs =\n+        ast_path_substs(\n+            self, rscope,\n+            trait_def.trait_ref.def_id, &trait_def.generics,\n+            path);\n+    let trait_ref =\n+        @ty::TraitRef {def_id: trait_def_id,\n+                       substs: substs};\n+    return trait_ref;\n+}\n+\n+\n pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: &AC,\n         rscope: &RS,\n@@ -243,36 +278,29 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n                     }\n-                    Some(&ast::def_ty(type_def_id)) => {\n-                        let result = ast_path_to_substs_and_ty(\n-                            self, rscope,\n-                            type_def_id, path);\n-                        match ty::get(result.ty).sty {\n-                            ty::ty_trait(trait_def_id, ref substs, _) => {\n-                                let trait_store = match vst {\n-                                    ty::vstore_box => ty::BoxTraitStore,\n-                                    ty::vstore_uniq => ty::UniqTraitStore,\n-                                    ty::vstore_slice(r) => {\n-                                        ty::RegionTraitStore(r)\n-                                    }\n-                                    ty::vstore_fixed(*) => {\n-                                        tcx.sess.span_err(\n-                                            path.span,\n-                                            ~\"@trait, ~trait or &trait \\\n-                                              are the only supported \\\n-                                              forms of casting-to-\\\n-                                              trait\");\n-                                        ty::BoxTraitStore\n-                                    }\n-                                };\n-                                return ty::mk_trait(tcx,\n-                                                    trait_def_id,\n-                                                    /*bad*/copy *substs,\n-                                                    trait_store);\n-\n+                    Some(&ast::def_trait(trait_def_id)) => {\n+                        let result = ast_path_to_trait_ref(\n+                            self, rscope, trait_def_id, path);\n+                        let trait_store = match vst {\n+                            ty::vstore_box => ty::BoxTraitStore,\n+                            ty::vstore_uniq => ty::UniqTraitStore,\n+                            ty::vstore_slice(r) => {\n+                                ty::RegionTraitStore(r)\n+                            }\n+                            ty::vstore_fixed(*) => {\n+                                tcx.sess.span_err(\n+                                    path.span,\n+                                    ~\"@trait, ~trait or &trait \\\n+                                      are the only supported \\\n+                                      forms of casting-to-\\\n+                                      trait\");\n+                                ty::BoxTraitStore\n                             }\n-                            _ => {}\n-                        }\n+                        };\n+                        return ty::mk_trait(tcx,\n+                                            result.def_id,\n+                                            copy result.substs,\n+                                            trait_store);\n                     }\n                     _ => {}\n                 }\n@@ -372,6 +400,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n           Some(&d) => d\n         };\n         match a_def {\n+          ast::def_trait(_) => {\n+              let path_str = path_to_str(path, tcx.sess.intr());\n+              tcx.sess.span_err(\n+                  ast_ty.span,\n+                  fmt!(\"reference to trait `%s` where a type is expected; \\\n+                        try `@%s`, `~%s`, or `&%s`\",\n+                       path_str, path_str, path_str, path_str));\n+              ty::mk_err(tcx)\n+          }\n           ast::def_ty(did) | ast::def_struct(did) => {\n             ast_path_to_ty(self, rscope, did, path).ty\n           }\n@@ -540,13 +577,50 @@ pub fn bound_lifetimes<AC:AstConv>(\n     bound_lifetime_names\n }\n \n+struct SelfInfo {\n+    untransformed_self_ty: ty::t,\n+    self_transform: ast::self_ty\n+}\n+\n+pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + Durable>(\n+    self: &AC,\n+    rscope: &RS,\n+    purity: ast::purity,\n+    lifetimes: &OptVec<ast::Lifetime>,\n+    untransformed_self_ty: ty::t,\n+    self_transform: ast::self_ty,\n+    decl: &ast::fn_decl) -> (Option<ty::t>, ty::BareFnTy)\n+{\n+    let self_info = SelfInfo {\n+        untransformed_self_ty: untransformed_self_ty,\n+        self_transform: self_transform\n+    };\n+    let (a, b) = ty_of_method_or_bare_fn(\n+        self, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n+    (a.get(), b)\n+}\n+\n pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n     self: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n     abi: AbiSet,\n     lifetimes: &OptVec<ast::Lifetime>,\n     decl: &ast::fn_decl) -> ty::BareFnTy\n+{\n+    let (_, b) = ty_of_method_or_bare_fn(\n+        self, rscope, purity, abi, lifetimes, None, decl);\n+    b\n+}\n+\n+fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n+    self: &AC,\n+    rscope: &RS,\n+    purity: ast::purity,\n+    abi: AbiSet,\n+    lifetimes: &OptVec<ast::Lifetime>,\n+    opt_self_info: Option<&SelfInfo>,\n+    decl: &ast::fn_decl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n {\n     debug!(\"ty_of_bare_fn\");\n \n@@ -555,18 +629,56 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n     let bound_lifetime_names = bound_lifetimes(self, lifetimes);\n     let rb = in_binding_rscope(rscope, RegionParamNames(copy bound_lifetime_names));\n \n+    let opt_transformed_self_ty = opt_self_info.map(|&self_info| {\n+        transform_self_ty(self, &rb, self_info)\n+    });\n+\n     let input_tys = decl.inputs.map(|a| ty_of_arg(self, &rb, *a, None));\n+\n     let output_ty = match decl.output.node {\n         ast::ty_infer => self.ty_infer(decl.output.span),\n         _ => ast_ty_to_ty(self, &rb, decl.output)\n     };\n \n-    ty::BareFnTy {\n-        purity: purity,\n-        abis: abi,\n-        sig: ty::FnSig {bound_lifetime_names: bound_lifetime_names,\n-                        inputs: input_tys,\n-                        output: output_ty}\n+    return (opt_transformed_self_ty,\n+            ty::BareFnTy {\n+                purity: purity,\n+                abis: abi,\n+                sig: ty::FnSig {bound_lifetime_names: bound_lifetime_names,\n+                                inputs: input_tys,\n+                                output: output_ty}\n+            });\n+\n+    fn transform_self_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n+        self: &AC,\n+        rscope: &RS,\n+        self_info: &SelfInfo) -> Option<ty::t>\n+    {\n+        match self_info.self_transform.node {\n+            ast::sty_static => None,\n+            ast::sty_value => {\n+                Some(self_info.untransformed_self_ty)\n+            }\n+            ast::sty_region(lifetime, mutability) => {\n+                let region =\n+                    ast_region_to_region(self, rscope,\n+                                         self_info.self_transform.span,\n+                                         lifetime);\n+                Some(ty::mk_rptr(self.tcx(), region,\n+                                 ty::mt {ty: self_info.untransformed_self_ty,\n+                                         mutbl: mutability}))\n+            }\n+            ast::sty_box(mutability) => {\n+                Some(ty::mk_box(self.tcx(),\n+                                ty::mt {ty: self_info.untransformed_self_ty,\n+                                        mutbl: mutability}))\n+            }\n+            ast::sty_uniq(mutability) => {\n+                Some(ty::mk_uniq(self.tcx(),\n+                                 ty::mt {ty: self_info.untransformed_self_ty,\n+                                         mutbl: mutability}))\n+            }\n+        }\n     }\n }\n "}, {"sha": "605caba74a3803dd393e3b19c1da30bffe8e5eb2", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -135,7 +135,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                     ty::enum_variant_with_id(tcx, enm, var);\n                 let var_tpt = ty::lookup_item_type(tcx, var);\n                 vinfo.args.map(|t| {\n-                    if var_tpt.bounds.len() == expected_substs.tps.len() {\n+                    if var_tpt.generics.bounds.len() == expected_substs.tps.len() {\n                         ty::subst(tcx, expected_substs, *t)\n                     }\n                     else {"}, {"sha": "fa3cb43d9abe030539bf99605f4ff667c46fb27d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 102, "deletions": 91, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -92,13 +92,15 @@ use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{method_map_entry, method_origin, method_param};\n use middle::typeck::{method_self, method_static, method_trait, method_super};\n+use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n use util::ppaux::expr_repr;\n \n use core::hashmap::HashSet;\n use core::result;\n use core::uint;\n use core::vec;\n+use std::list::Nil;\n use syntax::ast::{def_id, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, node_id, by_copy, by_ref};\n use syntax::ast::{m_const, m_mutbl, m_imm};\n@@ -121,7 +123,7 @@ pub fn lookup(\n         fcx: @mut FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: @ast::expr,                   // The expression `a.b`.\n+        expr: @ast::expr,                   // The expression `a.b(...)`.\n         self_expr: @ast::expr,              // The expression `a`.\n         callee_id: node_id,                 // Where to store `a.b`'s type\n         m_name: ast::ident,                 // The ident `b`.\n@@ -174,13 +176,7 @@ pub struct LookupContext<'self> {\n pub struct Candidate {\n     rcvr_ty: ty::t,\n     rcvr_substs: ty::substs,\n-    explicit_self: ast::self_ty_,\n-\n-    // FIXME #3446---these two fields should be easily derived from\n-    // origin, yet are not\n-    num_method_tps: uint,\n-    self_mode: ast::rmode,\n-\n+    method_ty: @ty::method,\n     origin: method_origin,\n }\n \n@@ -386,7 +382,7 @@ pub impl<'self> LookupContext<'self> {\n         let bounds = tcx.ty_param_bounds.get(&param_ty.def_id.node);\n \n         for bounds.each |bound| {\n-            let bound_trait_ty = match *bound {\n+            let bound_trait_ref = match *bound {\n                 ty::bound_trait(bound_t) => bound_t,\n \n                 ty::bound_copy | ty::bound_owned |\n@@ -395,22 +391,10 @@ pub impl<'self> LookupContext<'self> {\n                 }\n             };\n \n-\n-            let bound_substs = match ty::get(bound_trait_ty).sty {\n-                ty::ty_trait(_, ref substs, _) => (/*bad*/copy *substs),\n-                _ => {\n-                    self.bug(fmt!(\"add_candidates_from_param: \\\n-                                   non-trait bound %s\",\n-                                  self.ty_to_str(bound_trait_ty)));\n-                }\n-            };\n-\n-\n             // Loop over the trait and all of its supertraits.\n             let mut worklist = ~[];\n \n-            let init_trait_ty = bound_trait_ty;\n-            let init_substs = bound_substs;\n+            let init_trait_ref = bound_trait_ref;\n \n             // Replace any appearance of `self` with the type of the\n             // generic parameter itself.  Note that this is the only\n@@ -421,37 +405,34 @@ pub impl<'self> LookupContext<'self> {\n             // to self are not permitted).\n             let init_substs = substs {\n                 self_ty: Some(rcvr_ty),\n-                ..init_substs\n+                ..copy bound_trait_ref.substs\n             };\n \n-            worklist.push((init_trait_ty, init_substs));\n+            worklist.push((init_trait_ref.def_id, init_substs));\n \n             let mut i = 0;\n             while i < worklist.len() {\n-                let (init_trait_ty, init_substs) = /*bad*/copy worklist[i];\n+                let (init_trait_id, init_substs) = /*bad*/copy worklist[i];\n                 i += 1;\n \n-                let init_trait_id = ty::ty_to_def_id(init_trait_ty).get();\n-\n                 // Add all the supertraits of this trait to the worklist.\n-                let supertraits = ty::trait_supertraits(tcx,\n-                                                        init_trait_id);\n-                for supertraits.each |supertrait| {\n+                let supertraits = ty::trait_supertraits(tcx, init_trait_id);\n+                for supertraits.each |supertrait_ref| {\n                     debug!(\"adding supertrait: %?\",\n-                           supertrait.def_id);\n+                           supertrait_ref.def_id);\n \n-                    let new_substs = ty::subst_substs(\n+                    let new_substs = ty::subst_in_substs(\n                         tcx,\n-                        &supertrait.tpt.substs,\n-                        &init_substs);\n+                        &init_substs,\n+                        &supertrait_ref.substs);\n \n                     // Again replacing the self type\n                     let new_substs = substs {\n                         self_ty: Some(rcvr_ty),\n                         ..new_substs\n                     };\n \n-                    worklist.push((supertrait.tpt.ty, new_substs));\n+                    worklist.push((supertrait_ref.def_id, new_substs));\n                 }\n \n \n@@ -472,7 +453,7 @@ pub impl<'self> LookupContext<'self> {\n                         }\n                     }\n                 };\n-                let method = &trait_methods[pos];\n+                let method = trait_methods[pos];\n \n                 let (rcvr_ty, rcvr_substs) =\n                     self.create_rcvr_ty_and_substs_for_method(\n@@ -484,9 +465,7 @@ pub impl<'self> LookupContext<'self> {\n                 let cand = Candidate {\n                     rcvr_ty: rcvr_ty,\n                     rcvr_substs: rcvr_substs,\n-                    explicit_self: method.self_ty,\n-                    num_method_tps: method.tps.len(),\n-                    self_mode: get_mode_from_self_type(method.self_ty),\n+                    method_ty: method,\n                     origin: method_param(\n                         method_param {\n                             trait_id: init_trait_id,\n@@ -518,7 +497,7 @@ pub impl<'self> LookupContext<'self> {\n             Some(i) => i,\n             None => { return; } // no method with the right name\n         };\n-        let method = &ms[index];\n+        let method = ms[index];\n \n         /* FIXME(#3157) we should transform the vstore in accordance\n            with the self type\n@@ -552,9 +531,7 @@ pub impl<'self> LookupContext<'self> {\n         self.inherent_candidates.push(Candidate {\n             rcvr_ty: rcvr_ty,\n             rcvr_substs: rcvr_substs,\n-            explicit_self: method.self_ty,\n-            num_method_tps: method.tps.len(),\n-            self_mode: get_mode_from_self_type(method.self_ty),\n+            method_ty: method,\n             origin: method_trait(did, index, store)\n         });\n     }\n@@ -563,63 +540,65 @@ pub impl<'self> LookupContext<'self> {\n                                           self_ty: ty::t,\n                                           did: def_id,\n                                           substs: &ty::substs) {\n+        struct MethodInfo {\n+            method_ty: @ty::method,\n+            trait_def_id: ast::def_id,\n+            index: uint\n+        }\n+\n         let tcx = self.tcx();\n         // First, try self methods\n-        let mut method = None;\n+        let mut method_info: Option<MethodInfo> = None;\n         let methods = ty::trait_methods(tcx, did);\n-        let mut index = None;\n-        let mut trait_did = None;\n         match vec::position(*methods, |m| m.ident == self.m_name) {\n             Some(i) => {\n-                index = Some(i);\n-                trait_did = Some(did);\n-                method = Some((methods[i].self_ty, methods[i].tps.len()));\n+                method_info = Some(MethodInfo {\n+                    method_ty: methods[i],\n+                    index: i,\n+                    trait_def_id: did\n+                });\n             }\n             None => ()\n         }\n         // No method found yet? Check each supertrait\n-        if method.is_none() {\n+        if method_info.is_none() {\n             for ty::trait_supertraits(tcx, did).each() |trait_ref| {\n                 let supertrait_methods =\n                     ty::trait_methods(tcx, trait_ref.def_id);\n                 match vec::position(*supertrait_methods,\n                                     |m| m.ident == self.m_name) {\n                     Some(i) => {\n-                        index = Some(i);\n-                        trait_did = Some(trait_ref.def_id);\n-                        method = Some((supertrait_methods[i].self_ty,\n-                                       supertrait_methods[i].tps.len()));\n+                        method_info = Some(MethodInfo {\n+                            method_ty: supertrait_methods[i],\n+                            index: i,\n+                            trait_def_id: trait_ref.def_id\n+                        });\n                         break;\n                     }\n                     None => ()\n                 }\n             }\n         }\n-        match (method, index, trait_did) {\n-            (Some((method_self_ty, method_num_tps)),\n-             Some(index), Some(trait_did)) => {\n-\n+        match method_info {\n+            Some(ref info) => {\n                 // We've found a method -- return it\n-                let rcvr_substs = substs { self_ty: Some(self_ty),\n+                let rcvr_substs = substs {self_ty: Some(self_ty),\n                                           ..copy *substs };\n                 let (rcvr_ty, rcvr_substs) =\n                     self.create_rcvr_ty_and_substs_for_method(\n-                        method_self_ty,\n+                        info.method_ty.self_ty,\n                         self_ty,\n                         rcvr_substs,\n                         TransformTypeNormally);\n-                let origin = if trait_did == did {\n-                    method_self(trait_did, index)\n-                }\n-                else {\n-                    method_super(trait_did, index)\n+                let origin = if did == info.trait_def_id {\n+                    method_self(info.trait_def_id, info.index)\n+                } else {\n+                    method_super(info.trait_def_id, info.index)\n                 };\n                 self.inherent_candidates.push(Candidate {\n                     rcvr_ty: rcvr_ty,\n                     rcvr_substs: rcvr_substs,\n-                    explicit_self: method_self_ty,\n-                    num_method_tps: method_num_tps,\n-                    self_mode: get_mode_from_self_type(method_self_ty),\n+                    method_ty: info.method_ty,\n                     origin: origin\n                 });\n             }\n@@ -651,7 +630,7 @@ pub impl<'self> LookupContext<'self> {\n             }\n         };\n \n-        let method = &impl_info.methods[idx];\n+        let method = ty::method(self.tcx(), impl_info.methods[idx].did);\n \n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n@@ -667,18 +646,16 @@ pub impl<'self> LookupContext<'self> {\n \n         let (impl_ty, impl_substs) =\n             self.create_rcvr_ty_and_substs_for_method(\n-                method.self_type,\n+                method.self_ty,\n                 impl_ty,\n                 impl_substs,\n                 TransformTypeNormally);\n \n         candidates.push(Candidate {\n             rcvr_ty: impl_ty,\n             rcvr_substs: impl_substs,\n-            explicit_self: method.self_type,\n-            num_method_tps: method.n_tps,\n-            self_mode: get_mode_from_self_type(method.self_type),\n-            origin: method_static(method.did)\n+            method_ty: method,\n+            origin: method_static(method.def_id)\n         });\n     }\n \n@@ -699,6 +676,9 @@ pub impl<'self> LookupContext<'self> {\n             debug!(\"(pushing candidates from provided methods) adding \\\n                     candidate\");\n \n+            let method = ty::method(self.tcx(),\n+                                    provided_method_info.method_info.did);\n+\n             // XXX: Needs to support generics.\n             let dummy_substs = substs {\n                 self_r: None,\n@@ -707,18 +687,15 @@ pub impl<'self> LookupContext<'self> {\n             };\n             let (impl_ty, impl_substs) =\n                 self.create_rcvr_ty_and_substs_for_method(\n-                    provided_method_info.method_info.self_type,\n+                    method.self_ty,\n                     self_ty,\n                     dummy_substs,\n                     TransformTypeNormally);\n \n             candidates.push(Candidate {\n                 rcvr_ty: impl_ty,\n                 rcvr_substs: impl_substs,\n-                explicit_self: provided_method_info.method_info.self_type,\n-                num_method_tps: provided_method_info.method_info.n_tps,\n-                self_mode: get_mode_from_self_type(\n-                    provided_method_info.method_info.self_type),\n+                method_ty: method,\n                 origin: method_static(provided_method_info.method_info.did)\n             });\n         }\n@@ -1092,10 +1069,16 @@ pub impl<'self> LookupContext<'self> {\n     fn confirm_candidate(&self,\n                          self_ty: ty::t,\n                          candidate: &Candidate)\n-        -> method_map_entry {\n+        -> method_map_entry\n+    {\n         let tcx = self.tcx();\n         let fty = self.fn_ty_from_origin(&candidate.origin);\n \n+        debug!(\"confirm_candidate(expr=%s, candidate=%s, fty=%s)\",\n+               expr_repr(tcx, self.expr),\n+               self.cand_to_str(candidate),\n+               self.ty_to_str(fty));\n+\n         self.enforce_trait_instance_limitations(fty, candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n@@ -1118,20 +1101,21 @@ pub impl<'self> LookupContext<'self> {\n         // If they were not explicitly supplied, just construct fresh\n         // type variables.\n         let num_supplied_tps = self.supplied_tps.len();\n+        let num_method_tps = candidate.method_ty.generics.bounds.len();\n         let m_substs = {\n             if num_supplied_tps == 0u {\n-                self.fcx.infcx().next_ty_vars(candidate.num_method_tps)\n-            } else if candidate.num_method_tps == 0u {\n+                self.fcx.infcx().next_ty_vars(num_method_tps)\n+            } else if num_method_tps == 0u {\n                 tcx.sess.span_err(\n                     self.expr.span,\n                     ~\"this method does not take type parameters\");\n-                self.fcx.infcx().next_ty_vars(candidate.num_method_tps)\n-            } else if num_supplied_tps != candidate.num_method_tps {\n+                self.fcx.infcx().next_ty_vars(num_method_tps)\n+            } else if num_supplied_tps != num_method_tps {\n                 tcx.sess.span_err(\n                     self.expr.span,\n                     ~\"incorrect number of type \\\n                      parameters given for this method\");\n-                self.fcx.infcx().next_ty_vars(candidate.num_method_tps)\n+                self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n                 self.supplied_tps.to_vec()\n             }\n@@ -1145,13 +1129,41 @@ pub impl<'self> LookupContext<'self> {\n             ../*bad*/copy candidate.rcvr_substs\n         };\n \n-        self.fcx.write_ty_substs(self.callee_id, fty, all_substs);\n+        // Compute the method type with type parameters substituted\n+        debug!(\"fty=%s all_substs=%s\",\n+               self.ty_to_str(fty),\n+               ty::substs_to_str(tcx, &all_substs));\n+        let fty = ty::subst(tcx, &all_substs, fty);\n+        debug!(\"after subst, fty=%s\", self.ty_to_str(fty));\n+\n+        // Replace any bound regions that appear in the function\n+        // signature with region variables\n+        let bare_fn_ty = match ty::get(fty).sty {\n+            ty::ty_bare_fn(ref f) => copy *f,\n+            ref s => {\n+                tcx.sess.span_bug(\n+                    self.expr.span,\n+                    fmt!(\"Invoking method with non-bare-fn ty: %?\", s));\n+            }\n+        };\n+        let (_, _, fn_sig) =\n+            replace_bound_regions_in_fn_sig(\n+                tcx, @Nil, None, &bare_fn_ty.sig,\n+                |_br| self.fcx.infcx().next_region_var(\n+                    self.expr.span, self.expr.id));\n+        let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n+        debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n+\n+        let self_mode = get_mode_from_self_type(candidate.method_ty.self_ty);\n+\n+        self.fcx.write_ty(self.callee_id, fty);\n+        self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n             self_arg: arg {\n-                mode: ast::expl(candidate.self_mode),\n+                mode: ast::expl(self_mode),\n                 ty: candidate.rcvr_ty,\n             },\n-            explicit_self: candidate.explicit_self,\n+            explicit_self: candidate.method_ty.self_ty,\n             origin: candidate.origin,\n         }\n     }\n@@ -1183,7 +1195,7 @@ pub impl<'self> LookupContext<'self> {\n                   self-type through a boxed trait\");\n         }\n \n-        if candidate.num_method_tps > 0 {\n+        if candidate.method_ty.generics.bounds.len() > 0 {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n                 ~\"cannot call a generic method through a boxed trait\");\n@@ -1300,10 +1312,9 @@ pub impl<'self> LookupContext<'self> {\n     }\n \n     fn cand_to_str(&self, cand: &Candidate) -> ~str {\n-        fmt!(\"Candidate(rcvr_ty=%s, rcvr_substs=%s, self_mode=%?, origin=%?)\",\n+        fmt!(\"Candidate(rcvr_ty=%s, rcvr_substs=%s, origin=%?)\",\n              self.ty_to_str(cand.rcvr_ty),\n              ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n-             cand.self_mode,\n              cand.origin)\n     }\n "}, {"sha": "c3ec2d14d83d01c11f434a666dd211100610c27f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 165, "deletions": 163, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -610,7 +610,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         } else {\n             for m.items.each |item| {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n-                if !tpt.bounds.is_empty() {\n+                if !tpt.generics.bounds.is_empty() {\n                     ccx.tcx.sess.span_err(\n                         item.span,\n                         fmt!(\"foreign items may not have type parameters\"));\n@@ -629,6 +629,10 @@ impl AstConv for FnCtxt {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n+    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef {\n+        ty::lookup_trait_def(self.tcx(), id)\n+    }\n+\n     fn ty_infer(&self, _span: span) -> ty::t {\n         self.infcx().next_ty_var()\n     }\n@@ -1064,7 +1068,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n     let (n_tps, region_param, raw_ty) = {\n         let ity = ty::lookup_item_type(tcx, did);\n-        (vec::len(*ity.bounds), ity.region_param, ity.ty)\n+        (ity.generics.bounds.len(), ity.generics.region_param, ity.ty)\n     };\n \n     let self_r = if region_param.is_some() {\n@@ -1122,103 +1126,84 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                unifier: &fn()) {\n     debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n-    // A generic function to factor out common logic from call and\n-    // overloaded operations\n-    fn check_call_inner(\n+    fn check_method_argument_types(\n         fcx: @mut FnCtxt,\n         sp: span,\n-        call_expr_id: ast::node_id,\n-        in_fty: ty::t,\n+        method_fn_ty: ty::t,\n         callee_expr: @ast::expr,\n         args: &[@ast::expr],\n         sugar: ast::CallSugar,\n         deref_args: DerefArgs) -> ty::t\n     {\n-        let tcx = fcx.ccx.tcx;\n-\n-        // Replace all region parameters in the arguments and return\n-        // type with fresh region variables.\n-\n-        debug!(\"check_call_inner: before universal quant., in_fty=%s\",\n-               fcx.infcx().ty_to_str(in_fty));\n-\n-        let formal_tys;\n-\n-        // FIXME(#3678) For now, do not permit calls to C abi functions.\n-        match structure_of(fcx, sp, in_fty) {\n-            ty::ty_bare_fn(ty::BareFnTy {abis, _}) => {\n-                if !abis.is_rust() {\n-                    tcx.sess.span_err(\n+        if ty::type_is_error(method_fn_ty) {\n+            let err_inputs = err_args(fcx.tcx(), args.len());\n+            check_argument_types(fcx, sp, err_inputs, callee_expr,\n+                                 args, sugar, deref_args);\n+            method_fn_ty\n+        } else {\n+            match ty::get(method_fn_ty).sty {\n+                ty::ty_bare_fn(ref fty) => {\n+                    check_argument_types(fcx, sp, fty.sig.inputs, callee_expr,\n+                                         args, sugar, deref_args);\n+                    fty.sig.output\n+                }\n+                _ => {\n+                    fcx.tcx().sess.span_bug(\n                         sp,\n-                        fmt!(\"Calls to C ABI functions are not (yet) \\\n-                              supported; be patient, dear user\"));\n+                        fmt!(\"Method without bare fn type\"));\n                 }\n             }\n-            _ => {}\n         }\n+    }\n \n-        // This is subtle: we expect `fty` to be a function type, which\n-        // normally introduce a level of binding.  In this case, we want to\n-        // process the types bound by the function but not by any nested\n-        // functions.  Therefore, we match one level of structure.\n-        let ret_ty = match structure_of(fcx, sp, in_fty) {\n-            ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n-            ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-                let (_, _, sig) =\n-                    replace_bound_regions_in_fn_sig(\n-                        tcx, @Nil, None, sig,\n-                        |_br| fcx.infcx().next_region_var(\n-                            sp, call_expr_id));\n-\n-                let supplied_arg_count = args.len();\n-\n-                // Grab the argument types, supplying fresh type variables\n-                // if the wrong number of arguments were supplied\n-                let expected_arg_count = sig.inputs.len();\n-                formal_tys = if expected_arg_count == supplied_arg_count {\n-                    sig.inputs.map(|a| a.ty)\n-                } else {\n-                    let suffix = match sugar {\n-                        ast::NoSugar => \"\",\n-                        ast::DoSugar => \" (including the closure passed by \\\n-                                         the `do` keyword)\",\n-                        ast::ForSugar => \" (including the closure passed by \\\n-                                          the `for` keyword)\"\n-                    };\n-                    let msg = fmt!(\"this function takes %u parameter%s but \\\n-                                    %u parameter%s supplied%s\",\n-                                   expected_arg_count,\n-                                   if expected_arg_count == 1 {\"\"}\n-                                   else {\"s\"},\n-                                   supplied_arg_count,\n-                                   if supplied_arg_count == 1 {\" was\"}\n-                                   else {\"s were\"},\n-                                   suffix);\n-\n-                    tcx.sess.span_err(sp, msg);\n-\n-                    vec::from_fn(supplied_arg_count, |_| ty::mk_err(tcx))\n-                };\n-\n-                sig.output\n-            }\n+    fn check_argument_types(\n+        fcx: @mut FnCtxt,\n+        sp: span,\n+        fn_inputs: &[ty::arg],\n+        callee_expr: @ast::expr,\n+        args: &[@ast::expr],\n+        sugar: ast::CallSugar,\n+        deref_args: DerefArgs)\n+    {\n+        /*!\n+         *\n+         * Generic function that factors out common logic from\n+         * function calls, method calls and overloaded operators.\n+         */\n \n-            _ => {\n-                fcx.type_error_message(sp, |actual| {\n-                    fmt!(\"expected function or foreign function but \\\n-                          found `%s`\", actual) }, in_fty, None);\n+        let tcx = fcx.ccx.tcx;\n \n-                // check each arg against \"error\", in order to set up\n-                // all the node type bindings\n-                formal_tys = args.map(|_x| ty::mk_err(tcx));\n-                ty::mk_err(tcx)\n-            }\n+        // Grab the argument types, supplying fresh type variables\n+        // if the wrong number of arguments were supplied\n+        let supplied_arg_count = args.len();\n+        let expected_arg_count = fn_inputs.len();\n+        let formal_tys = if expected_arg_count == supplied_arg_count {\n+            fn_inputs.map(|a| a.ty)\n+        } else {\n+            let suffix = match sugar {\n+                ast::NoSugar => \"\",\n+                ast::DoSugar => \" (including the closure passed by \\\n+                                 the `do` keyword)\",\n+                ast::ForSugar => \" (including the closure passed by \\\n+                                  the `for` keyword)\"\n+            };\n+            let msg = fmt!(\"this function takes %u parameter%s but \\\n+                            %u parameter%s supplied%s\",\n+                           expected_arg_count,\n+                           if expected_arg_count == 1 {\"\"}\n+                           else {\"s\"},\n+                           supplied_arg_count,\n+                           if supplied_arg_count == 1 {\" was\"}\n+                           else {\"s were\"},\n+                           suffix);\n+\n+            tcx.sess.span_err(sp, msg);\n+\n+            vec::from_elem(supplied_arg_count, ty::mk_err(tcx))\n         };\n \n-        debug!(\"check_call_inner: after universal quant., \\\n-                formal_tys=%? ret_ty=%s\",\n-               formal_tys.map(|t| fcx.infcx().ty_to_str(*t)),\n-               fcx.infcx().ty_to_str(ret_ty));\n+        debug!(\"check_argument_types: formal_tys=%?\",\n+               formal_tys.map(|t| fcx.infcx().ty_to_str(*t)));\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n@@ -1268,8 +1253,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n             }\n         }\n+    }\n \n-        ret_ty\n+    fn err_args(tcx: ty::ctxt, len: uint) -> ~[ty::arg] {\n+        vec::from_fn(len, |_| ty::arg {mode: ast::expl(ast::by_copy),\n+                                       ty: ty::mk_err(tcx)})\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1284,43 +1272,63 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // The callee checks for bot / err, we don't need to\n     }\n \n-    // A generic function for doing all of the checking for call or\n-    // method expressions\n-    fn check_call_or_method(fcx: @mut FnCtxt,\n-                            sp: span,\n-                            call_expr_id: ast::node_id,\n-                            fn_ty: ty::t,\n-                            expr: @ast::expr,\n-                            args: &[@ast::expr],\n-                            sugar: ast::CallSugar)\n-    {\n-\n-        // Call the generic checker.\n-        let ret_ty = check_call_inner(fcx, sp, call_expr_id,\n-                                           fn_ty, expr, args, sugar,\n-                                           DontDerefArgs);\n-        // Pull the return type out of the type of the function.\n-        fcx.write_ty(call_expr_id, ret_ty);\n-        // Callee checks for bot and err, no need for that\n-    }\n-\n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @mut FnCtxt,\n-                  sp: span,\n-                  call_expr_id: ast::node_id,\n+                  call_expr: @ast::expr,\n                   f: @ast::expr,\n                   args: &[@ast::expr],\n                   sugar: ast::CallSugar) {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n-        let mut _bot = check_expr(fcx, f);\n-        check_call_or_method(fcx,\n-                             sp,\n-                             call_expr_id,\n-                             fcx.expr_ty(f),\n-                             f,\n-                             args,\n-                             sugar)\n+        check_expr(fcx, f);\n+\n+\n+        // Extract the function signature from `in_fty`.\n+        let fn_ty = fcx.expr_ty(f);\n+        let fn_sty = structure_of(fcx, f.span, fn_ty);\n+\n+        // FIXME(#3678) For now, do not permit calls to C abi functions.\n+        match fn_sty {\n+            ty::ty_bare_fn(ty::BareFnTy {abis, _}) => {\n+                if !abis.is_rust() {\n+                    fcx.tcx().sess.span_err(\n+                        call_expr.span,\n+                        fmt!(\"Calls to C ABI functions are not (yet) \\\n+                              supported; be patient, dear user\"));\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        let fn_sig = match fn_sty {\n+            ty::ty_bare_fn(ty::BareFnTy {sig: sig, _}) |\n+            ty::ty_closure(ty::ClosureTy {sig: sig, _}) => sig,\n+            _ => {\n+                fcx.type_error_message(call_expr.span, |actual| {\n+                    fmt!(\"expected function but \\\n+                          found `%s`\", actual) }, fn_ty, None);\n+\n+                // check each arg against \"error\", in order to set up\n+                // all the node type bindings\n+                FnSig {bound_lifetime_names: opt_vec::Empty,\n+                       inputs: err_args(fcx.tcx(), args.len()),\n+                       output: ty::mk_err(fcx.tcx())}\n+            }\n+        };\n+\n+        // Replace any bound regions that appear in the function\n+        // signature with region variables\n+        let (_, _, fn_sig) =\n+            replace_bound_regions_in_fn_sig(\n+                fcx.tcx(), @Nil, None, &fn_sig,\n+                |_br| fcx.infcx().next_region_var(call_expr.span, call_expr.id));\n+\n+        // Call the generic checker.\n+        check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n+                             args, sugar, DontDerefArgs);\n+\n+        // Pull the return type out of the type of the function.\n+        fcx.write_ty(call_expr.id, fn_sig.output);\n     }\n \n     // Checks a method call.\n@@ -1332,6 +1340,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          tps: &[@ast::Ty],\n                          sugar: ast::CallSugar) {\n         check_expr(fcx, rcvr);\n+\n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n                                                 expr.span,\n@@ -1369,13 +1378,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         }\n \n-        check_call_or_method(fcx,\n-                             expr.span,\n-                             expr.id,\n-                             fcx.node_ty(expr.callee_id),\n-                             expr,\n-                             args,\n-                             sugar)\n+        // Call the generic checker.\n+        let fn_ty = fcx.node_ty(expr.callee_id);\n+        let ret_ty = check_method_argument_types(fcx, expr.span,\n+                                                 fn_ty, expr, args, sugar,\n+                                                 DontDerefArgs);\n+\n+        // Pull the return type out of the type of the function.\n+        fcx.write_ty(expr.id, ret_ty);\n     }\n \n     // A generic function for checking the then and else in an if\n@@ -1423,20 +1433,19 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n                 let method_map = fcx.inh.method_map;\n                 method_map.insert(op_ex.id, *origin);\n-                check_call_inner(fcx, op_ex.span,\n-                                 op_ex.id, method_ty,\n-                                 op_ex, args,\n-                                 ast::NoSugar, deref_args)\n+                check_method_argument_types(fcx, op_ex.span,\n+                                            method_ty, op_ex, args,\n+                                            ast::NoSugar, deref_args)\n             }\n             _ => {\n                 let tcx = fcx.tcx();\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n                 let expected_ty = ty::mk_err(tcx);\n-                check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                 expected_ty, op_ex, args,\n-                                 ast::NoSugar, deref_args);\n+                check_method_argument_types(fcx, op_ex.span,\n+                                            expected_ty, op_ex, args,\n+                                            ast::NoSugar, deref_args);\n                 ty::mk_err(tcx)\n             }\n         }\n@@ -1884,8 +1893,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         } else {\n             let item_type = ty::lookup_item_type(tcx, class_id);\n-            type_parameter_count = (*item_type.bounds).len();\n-            region_parameterized = item_type.region_param;\n+            type_parameter_count = item_type.generics.bounds.len();\n+            region_parameterized = item_type.generics.region_param;\n             raw_type = item_type.ty;\n         }\n \n@@ -1972,8 +1981,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         } else {\n             let item_type = ty::lookup_item_type(tcx, enum_id);\n-            type_parameter_count = (*item_type.bounds).len();\n-            region_parameterized = item_type.region_param;\n+            type_parameter_count = item_type.generics.bounds.len();\n+            region_parameterized = item_type.generics.region_param;\n             raw_type = item_type.ty;\n         }\n \n@@ -2121,12 +2130,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     match expr.node {\n       ast::expr_vstore(ev, vst) => {\n         let typ = match ev.node {\n-          ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, s.len(), vst);\n+          ast::expr_lit(@codemap::spanned { node: ast::lit_str(_), _ }) => {\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             ty::mk_estr(tcx, tt)\n           }\n           ast::expr_vec(ref args, mutbl) => {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, args.len(), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability;\n             let mut any_error = false;\n             let mut any_bot = false;\n@@ -2158,9 +2167,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n-            let count = ty::eval_repeat_count(tcx, count_expr);\n+            let _ = ty::eval_repeat_count(tcx, count_expr);\n             check_expr_with_hint(fcx, count_expr, ty::mk_uint(tcx));\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability = match vst {\n                 ast::expr_vstore_mut_box | ast::expr_vstore_mut_slice => {\n                     ast::m_mutbl\n@@ -2546,7 +2555,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, fcx.node_ty(b.node.id));\n       }\n       ast::expr_call(f, ref args, sugar) => {\n-          check_call(fcx, expr.span, expr.id, f, *args, sugar);\n+          check_call(fcx, expr, f, *args, sugar);\n           let f_ty = fcx.expr_ty(f);\n           let (args_bot, args_err) = args.foldl((false, false),\n              |&(rest_bot, rest_err), a| {\n@@ -3143,8 +3152,10 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::def_fn(_, ast::extern_fn) => {\n         // extern functions are just u8 pointers\n         return ty_param_bounds_and_ty {\n-            bounds: @~[],\n-            region_param: None,\n+            generics: ty::Generics {\n+                bounds: @~[],\n+                region_param: None\n+            },\n             ty: ty::mk_ptr(\n                 fcx.ccx.tcx,\n                 ty::mt {\n@@ -3169,7 +3180,10 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::def_upvar(_, inner, _, _) => {\n         return ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n-      ast::def_ty(_) | ast::def_prim_ty(_) | ast::def_ty_param(*)=> {\n+      ast::def_trait(_) |\n+      ast::def_ty(_) |\n+      ast::def_prim_ty(_) |\n+      ast::def_ty_param(*)=> {\n         fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found type\");\n       }\n       ast::def_mod(*) | ast::def_foreign_mod(*) => {\n@@ -3204,14 +3218,18 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         region_lb: ty::Region) {\n     debug!(\">>> instantiate_path\");\n \n-    let ty_param_count = vec::len(*tpt.bounds);\n+    let ty_param_count = tpt.generics.bounds.len();\n     let ty_substs_len = vec::len(pth.types);\n \n+    debug!(\"ty_param_count=%? ty_substs_len=%?\",\n+           ty_param_count,\n+           ty_substs_len);\n+\n     // determine the region bound, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n     let self_r = match pth.rp {\n       Some(_) => { // user supplied a lifetime parameter...\n-        match tpt.region_param {\n+        match tpt.generics.region_param {\n           None => { // ...but the type is not lifetime parameterized!\n             fcx.ccx.tcx.sess.span_err\n                 (span, ~\"this item is not region-parameterized\");\n@@ -3224,7 +3242,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n       }\n       None => { // no lifetime parameter supplied, insert default\n         fcx.region_var_if_parameterized(\n-            tpt.region_param, span, region_lb)\n+            tpt.generics.region_param, span, region_lb)\n       }\n     };\n \n@@ -3302,7 +3320,6 @@ pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n \n pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n                                  e: @ast::expr,\n-                                 _n: uint,\n                                  v: ast::expr_vstore)\n                               -> ty::vstore {\n     match v {\n@@ -3423,28 +3440,13 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       }\n       ~\"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n-          let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n           assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-          assert!(ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n           let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n-          let (_, visitor_trait) = *tcx.intrinsic_defs.get(&ty_visitor_name);\n-\n-          let visitor_trait = match ty::get(visitor_trait).sty {\n-            ty::ty_trait(trait_def_id, ref trait_substs, _) => {\n-                ty::mk_trait(tcx,\n-                             trait_def_id,\n-                             copy *trait_substs,\n-                             ty::BoxTraitStore)\n-            }\n-            _ => {\n-                tcx.sess.span_bug(it.span, ~\"TyVisitor wasn't a trait?!\")\n-            }\n-          };\n-\n+          let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n                                                    mutbl: ast::m_imm});\n           (0u, ~[arg(ast::by_copy, td_ptr),\n-                 arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n+                 arg(ast::by_ref, visitor_object_ty)], ty::mk_nil(tcx))\n       }\n       ~\"frame_address\" => {\n         let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n@@ -3690,7 +3692,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                     output: output}\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n-    let i_n_tps = (*i_ty.bounds).len();\n+    let i_n_tps = i_ty.generics.bounds.len();\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span, fmt!(\"intrinsic has wrong number \\\n                                          of type parameters: found %u, \\"}, {"sha": "c30765baf37b3a274c201d13f9792c55e981b647", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 142, "deletions": 168, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -70,19 +70,19 @@ pub impl VtableContext {\n     fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n }\n \n-pub fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n+fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n         bs.any(|b| {\n             match b { &ty::bound_trait(_) => true, _ => false }\n         })\n     })\n }\n \n-pub fn lookup_vtables(vcx: &VtableContext,\n-                      location_info: &LocationInfo,\n-                      bounds: @~[ty::param_bounds],\n-                      substs: &ty::substs,\n-                      is_early: bool) -> vtable_res {\n+fn lookup_vtables(vcx: &VtableContext,\n+                  location_info: &LocationInfo,\n+                  bounds: @~[ty::param_bounds],\n+                  substs: &ty::substs,\n+                  is_early: bool) -> vtable_res {\n     debug!(\"lookup_vtables(location_info=%?,\n             # bounds=%?, \\\n             substs=%s\",\n@@ -95,30 +95,30 @@ pub fn lookup_vtables(vcx: &VtableContext,\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n         for ty::iter_bound_traits_and_supertraits(\n-            tcx, bounds[i]) |trait_ty|\n+            tcx, bounds[i]) |trait_ref|\n         {\n             debug!(\"about to subst: %?, %?\",\n-                   ppaux::ty_to_str(tcx, trait_ty),\n+                   ppaux::trait_ref_to_str(tcx, trait_ref),\n                    ty::substs_to_str(tcx, substs));\n \n             let new_substs = substs {\n                 self_ty: Some(*ty),\n                 ../*bad*/copy *substs\n             };\n-            let trait_ty = ty::subst(tcx, &new_substs, trait_ty);\n+            let trait_ref = ty::subst_in_trait_ref(tcx, &new_substs, trait_ref);\n \n             debug!(\"after subst: %?\",\n-                   ppaux::ty_to_str(tcx, trait_ty));\n+                   vcx.infcx.trait_ref_to_str(&trait_ref));\n \n-            match lookup_vtable(vcx, location_info, *ty, trait_ty, is_early) {\n+            match lookup_vtable(vcx, location_info, *ty, &trait_ref, is_early) {\n                 Some(vtable) => result.push(vtable),\n                 None => {\n                     vcx.tcx().sess.span_fatal(\n                         location_info.span,\n                         fmt!(\"failed to find an implementation of \\\n                               trait %s for %s\",\n-                             ppaux::ty_to_str(vcx.tcx(), trait_ty),\n-                             ppaux::ty_to_str(vcx.tcx(), *ty)));\n+                             vcx.infcx.trait_ref_to_str(&trait_ref),\n+                             vcx.infcx.ty_to_str(*ty)));\n                 }\n             }\n         }\n@@ -136,9 +136,9 @@ pub fn lookup_vtables(vcx: &VtableContext,\n     @result\n }\n \n-pub fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n-                    id: ast::def_id, +substs: ty::substs,\n-                    is_early: bool) -> Option<ty::substs> {\n+fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n+                id: ast::def_id, +substs: ty::substs,\n+                is_early: bool) -> Option<ty::substs> {\n     let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n@@ -152,31 +152,58 @@ pub fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n     }\n }\n \n-pub fn relate_trait_tys(vcx: &VtableContext, location_info: &LocationInfo,\n-                        exp_trait_ty: ty::t, act_trait_ty: ty::t) {\n-    demand_suptype(vcx, location_info.span, exp_trait_ty, act_trait_ty)\n+fn relate_trait_refs(vcx: &VtableContext,\n+                     location_info: &LocationInfo,\n+                     act_trait_ref: &ty::TraitRef,\n+                     exp_trait_ref: &ty::TraitRef)\n+{\n+    /*!\n+     *\n+     * Checks that an implementation of `act_trait_ref` is suitable\n+     * for use where `exp_trait_ref` is required and reports an\n+     * error otherwise.\n+     */\n+\n+    match infer::mk_sub_trait_refs(vcx.infcx, false, location_info.span,\n+                                   act_trait_ref, exp_trait_ref)\n+    {\n+        result::Ok(()) => {} // Ok.\n+        result::Err(ref err) => {\n+            let r_act_trait_ref =\n+                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(act_trait_ref);\n+            let r_exp_trait_ref =\n+                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(exp_trait_ref);\n+            if !ty::trait_ref_contains_error(&r_act_trait_ref) &&\n+                !ty::trait_ref_contains_error(&r_exp_trait_ref)\n+            {\n+                let tcx = vcx.tcx();\n+                tcx.sess.span_err(\n+                    location_info.span,\n+                    fmt!(\"expected %s, but found %s (%s)\",\n+                         ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n+                         ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n+                         ty::type_err_to_str(tcx, err)));\n+            }\n+        }\n+    }\n }\n \n // Look up the vtable to use when treating an item of type `t` as if it has\n // type `trait_ty`\n-pub fn lookup_vtable(vcx: &VtableContext,\n-                     location_info: &LocationInfo,\n-                     ty: ty::t,\n-                     trait_ty: ty::t,\n-                     is_early: bool)\n-                  -> Option<vtable_origin> {\n-    debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n-           vcx.infcx.ty_to_str(ty), vcx.infcx.ty_to_str(trait_ty));\n+fn lookup_vtable(vcx: &VtableContext,\n+                 location_info: &LocationInfo,\n+                 ty: ty::t,\n+                 trait_ref: &ty::TraitRef,\n+                 is_early: bool)\n+    -> Option<vtable_origin>\n+{\n+    debug!(\"lookup_vtable(ty=%s, trait_ref=%s)\",\n+           vcx.infcx.ty_to_str(ty),\n+           vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n \n     let tcx = vcx.tcx();\n-    let (trait_id, trait_substs, trait_store) = match ty::get(trait_ty).sty {\n-        ty::ty_trait(did, ref substs, store) =>\n-            (did, (/*bad*/copy *substs), store),\n-        _ => tcx.sess.impossible_case(location_info.span,\n-                                      \"lookup_vtable: \\\n-                                       don't know how to handle a non-trait\")\n-    };\n+\n     let ty = match fixup_ty(vcx, location_info, ty, is_early) {\n         Some(ty) => ty,\n         None => {\n@@ -194,37 +221,20 @@ pub fn lookup_vtable(vcx: &VtableContext,\n             let mut n_bound = 0;\n             let bounds = *tcx.ty_param_bounds.get(&did.node);\n             for ty::iter_bound_traits_and_supertraits(\n-                tcx, bounds) |ity| {\n+                tcx, bounds) |bound_trait_ref|\n+            {\n                 debug!(\"checking bounds trait %?\",\n-                       vcx.infcx.ty_to_str(ity));\n-\n-                match ty::get(ity).sty {\n-                    ty::ty_trait(idid, ref isubsts, _) => {\n-                        if trait_id == idid {\n-                            debug!(\"(checking vtable) @0 \\\n-                                    relating ty to trait \\\n-                                    ty with did %?\",\n-                                   idid);\n-\n-                            // Convert `ity` so that it has the right vstore.\n-                            let ity = ty::mk_trait(vcx.tcx(),\n-                                                   idid,\n-                                                   copy *isubsts,\n-                                                   trait_store);\n-\n-                            relate_trait_tys(vcx, location_info,\n-                                             trait_ty, ity);\n-                            let vtable = vtable_param(n, n_bound);\n-                            debug!(\"found param vtable: %?\",\n-                                   vtable);\n-                            return Some(vtable);\n-                        }\n-                    }\n-                    _ => tcx.sess.impossible_case(\n-                        location_info.span,\n-                        \"lookup_vtable: in loop, \\\n-                         don't know how to handle a \\\n-                         non-trait ity\")\n+                       vcx.infcx.trait_ref_to_str(bound_trait_ref));\n+\n+                if bound_trait_ref.def_id == trait_ref.def_id {\n+                    relate_trait_refs(vcx,\n+                                      location_info,\n+                                      bound_trait_ref,\n+                                      trait_ref);\n+                    let vtable = vtable_param(n, n_bound);\n+                    debug!(\"found param vtable: %?\",\n+                           vtable);\n+                    return Some(vtable);\n                 }\n \n                 n_bound += 1;\n@@ -236,18 +246,19 @@ pub fn lookup_vtable(vcx: &VtableContext,\n \n             let mut impls_seen = HashSet::new();\n \n-            match vcx.ccx.coherence_info.extension_methods.find(&trait_id) {\n+            match vcx.ccx.coherence_info.extension_methods.find(&trait_ref.def_id) {\n                 None => {\n                     // Nothing found. Continue.\n                 }\n                 Some(implementations) => {\n                     let implementations: &mut ~[@Impl] = *implementations;\n+\n                     // implementations is the list of all impls in scope for\n-                    // trait_ty. (Usually, there's just one.)\n+                    // trait_ref. (Usually, there's just one.)\n                     for uint::range(0, implementations.len()) |i| {\n                         let im = implementations[i];\n \n-                        // im is one specific impl of trait_ty.\n+                        // im is one specific impl of trait_ref.\n \n                         // First, ensure we haven't processed this impl yet.\n                         if impls_seen.contains(&im.did) {\n@@ -269,22 +280,15 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                         //   ~[baz<int>, bar, quux]\n                         //\n                         // For each of the traits foo implements, if\n-                        // it's the same trait as trait_ty, we need to\n-                        // unify it with trait_ty in order to get all\n+                        // it's the same trait as trait_ref, we need to\n+                        // unify it with trait_ref in order to get all\n                         // the ty vars sorted out.\n-                        for vec::each(ty::impl_traits(tcx,\n-                                                      im.did,\n-                                                      trait_store)) |of_ty| {\n-                            match ty::get(*of_ty).sty {\n-                                ty::ty_trait(id, _, _) => {\n-                                    // Not the trait we're looking for\n-                                    if id != trait_id { loop; }\n-                                }\n-                                _ => { /* ok */ }\n-                            }\n+                        for ty::impl_trait_refs(tcx, im.did).each |&of_trait_ref|\n+                        {\n+                            if of_trait_ref.def_id != trait_ref.def_id { loop; }\n \n-                            // At this point, we know that of_ty is\n-                            // the same trait as trait_ty, but\n+                            // At this point, we know that of_trait_ref is\n+                            // the same trait as trait_ref, but\n                             // possibly applied to different substs.\n                             //\n                             // Next, we check whether the \"for\" ty in\n@@ -318,39 +322,36 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                                    vcx.infcx.ty_to_str(for_ty),\n                                    tys_to_str(vcx.tcx(), substs.tps));\n \n-                            // Next, we unify trait_ty -- the type\n-                            // that we want to cast to -- with of_ty\n+                            // Next, we unify trait_ref -- the type\n+                            // that we want to cast to -- with of_trait_ref\n                             // -- the trait that im implements. At\n                             // this point, we require that they be\n                             // unifiable with each other -- that's\n-                            // what relate_trait_tys does.\n+                            // what relate_trait_refs does.\n                             //\n                             // For example, in the above example,\n-                            // of_ty would be some_trait<T>, so we\n-                            // would be unifying trait_ty<U> (for some\n+                            // of_trait_ref would be some_trait<T>, so we\n+                            // would be unifying trait_ref<U> (for some\n                             // value of U) with some_trait<T>. This\n                             // would fail if T and U weren't\n                             // compatible.\n \n                             debug!(\"(checking vtable) @2 relating trait \\\n-                                    ty %s to of_ty %s\",\n-                                   vcx.infcx.ty_to_str(trait_ty),\n-                                   vcx.infcx.ty_to_str(*of_ty));\n-                            let of_ty = ty::subst(tcx, &substs, *of_ty);\n-                            relate_trait_tys(vcx, location_info, trait_ty,\n-                                             of_ty);\n-\n-                            // Recall that trait_ty -- the trait type\n-                            // we're casting to -- is the trait with\n-                            // id trait_id applied to the substs\n-                            // trait_substs. Now we extract out the\n-                            // types themselves from trait_substs.\n+                                    ty %s to of_trait_ref %s\",\n+                                   vcx.infcx.trait_ref_to_str(trait_ref),\n+                                   vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n-                            let trait_tps = /*bad*/copy trait_substs.tps;\n+                            let of_trait_ref =\n+                                ty::subst_in_trait_ref(tcx, &substs, of_trait_ref);\n+                            relate_trait_refs(\n+                                vcx, location_info,\n+                                &of_trait_ref, trait_ref);\n \n-                            debug!(\"Casting to a trait ty whose substs \\\n-                                    (trait_tps) are %s\",\n-                                   tys_to_str(vcx.tcx(), trait_tps));\n+                            // Recall that trait_ref -- the trait type\n+                            // we're casting to -- is the trait with\n+                            // id trait_ref.def_id applied to the substs\n+                            // trait_ref.substs. Now we extract out the\n+                            // types themselves from trait_ref.substs.\n \n                             // Recall that substs is the impl self\n                             // type's list of substitutions. That is,\n@@ -362,7 +363,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n \n                             let substs_f = match fixup_substs(vcx,\n                                                               location_info,\n-                                                              trait_id,\n+                                                              trait_ref.def_id,\n                                                               substs,\n                                                               is_early) {\n                                 Some(ref substs) => (/*bad*/copy *substs),\n@@ -377,7 +378,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                                     they will be unified with the bounds for \\\n                                     the target ty, %s\",\n                                    tys_to_str(vcx.tcx(), substs_f.tps),\n-                                   tys_to_str(vcx.tcx(), trait_tps));\n+                                   vcx.infcx.trait_ref_to_str(trait_ref));\n \n                             // Next, we unify the fixed-up\n                             // substitutions for the impl self ty with\n@@ -386,14 +387,13 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                             // to. connect_trait_tps requires these\n                             // lists of types to unify pairwise.\n \n-                            let im_bs = ty::lookup_item_type(tcx,\n-                                                             im.did).bounds;\n+                            let im_bs =\n+                                ty::lookup_item_type(tcx, im.did).generics.bounds;\n                             connect_trait_tps(vcx,\n                                               location_info,\n-                                              /*bad*/copy substs_f.tps,\n-                                              trait_tps,\n-                                              im.did,\n-                                              trait_store);\n+                                              &substs_f,\n+                                              trait_ref,\n+                                              im.did);\n                             let subres = lookup_vtables(\n                                 vcx, location_info, im_bs, &substs_f,\n                                 is_early);\n@@ -430,10 +430,10 @@ pub fn lookup_vtable(vcx: &VtableContext,\n     return None;\n }\n \n-pub fn fixup_ty(vcx: &VtableContext,\n-                location_info: &LocationInfo,\n-                ty: ty::t,\n-                is_early: bool) -> Option<ty::t> {\n+fn fixup_ty(vcx: &VtableContext,\n+            location_info: &LocationInfo,\n+            ty: ty::t,\n+            is_early: bool) -> Option<ty::t> {\n     let tcx = vcx.tcx();\n     match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n@@ -450,45 +450,23 @@ pub fn fixup_ty(vcx: &VtableContext,\n     }\n }\n \n-// Version of demand::suptype() that takes a vtable context instead of a\n-// function context.\n-pub fn demand_suptype(vcx: &VtableContext, sp: span, e: ty::t, a: ty::t) {\n-    // NB: Order of actual, expected is reversed.\n-    match infer::mk_subty(vcx.infcx, false, sp, a, e) {\n-        result::Ok(()) => {} // Ok.\n-        result::Err(ref err) => {\n-            vcx.infcx.report_mismatched_types(sp, e, a, err);\n-        }\n-    }\n-}\n-\n-pub fn connect_trait_tps(vcx: &VtableContext,\n-                         location_info: &LocationInfo,\n-                         impl_tys: ~[ty::t],\n-                         trait_tys: ~[ty::t],\n-                         impl_did: ast::def_id,\n-                         store: ty::TraitStore) {\n+fn connect_trait_tps(vcx: &VtableContext,\n+                     location_info: &LocationInfo,\n+                     impl_substs: &ty::substs,\n+                     trait_ref: &ty::TraitRef,\n+                     impl_did: ast::def_id)\n+{\n     let tcx = vcx.tcx();\n \n     // XXX: This should work for multiple traits.\n-    let ity = ty::impl_traits(tcx, impl_did, store)[0];\n-    let trait_ty = ty::subst_tps(tcx, impl_tys, None, ity);\n-    debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n-           ty::get(trait_ty).sty, impl_did);\n-    match ty::get(trait_ty).sty {\n-     ty::ty_trait(_, ref substs, _) => {\n-         for vec::each2((*substs).tps, trait_tys) |a, b| {\n-            demand_suptype(vcx, location_info.span, *a, *b);\n-         }\n-      }\n-     _ => tcx.sess.impossible_case(location_info.span, \"connect_trait_tps: \\\n-            don't know how to handle a non-trait ty\")\n-    }\n+    let impl_trait_ref = ty::impl_trait_refs(tcx, impl_did)[0];\n+    let impl_trait_ref = ty::subst_in_trait_ref(tcx, impl_substs, impl_trait_ref);\n+    relate_trait_refs(vcx, location_info, trait_ref, &impl_trait_ref);\n }\n \n-pub fn insert_vtables(fcx: @mut FnCtxt,\n-                      callee_id: ast::node_id,\n-                      vtables: vtable_res) {\n+fn insert_vtables(fcx: @mut FnCtxt,\n+                  callee_id: ast::node_id,\n+                  vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n            callee_id, vtables.map(|v| v.to_str(fcx.tcx())));\n     fcx.inh.vtable_map.insert(callee_id, vtables);\n@@ -517,15 +495,15 @@ pub fn early_resolve_expr(ex: @ast::expr,\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def %? %?, %?, %?\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n-            if has_trait_bounds(/*bad*/copy *item_ty.bounds) {\n-                for item_ty.bounds.each |bounds| {\n+            if has_trait_bounds(/*bad*/copy *item_ty.generics.bounds) {\n+                for item_ty.generics.bounds.each |bounds| {\n                     debug!(\"early_resolve_expr: looking up vtables for bound \\\n                             %s\",\n                            ty::param_bounds_to_str(fcx.tcx(), *bounds));\n                 }\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           item_ty.bounds, substs, is_early);\n+                                           item_ty.generics.bounds, substs, is_early);\n                 if !is_early {\n                     insert_vtables(fcx, ex.id, vtbls);\n                 }\n@@ -564,7 +542,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n       ast::expr_cast(src, _) => {\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n-              ty::ty_trait(_, _, store) => {\n+              ty::ty_trait(target_def_id, ref target_substs, store) => {\n                   // Look up vtables for the type we're casting to,\n                   // passing in the source and target type.  The source\n                   // must be a pointer type suitable to the object sigil,\n@@ -573,7 +551,6 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                                       fcx.expr_ty(src));\n                   match (&ty::get(ty).sty, store) {\n                       (&ty::ty_box(mt), ty::BoxTraitStore) |\n-                      // XXX: Bare trait store is deprecated.\n                       (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n                       (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*)) => {\n                           let location_info =\n@@ -582,11 +559,15 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                               ccx: fcx.ccx,\n                               infcx: fcx.infcx()\n                           };\n+                          let target_trait_ref = ty::TraitRef {\n+                              def_id: target_def_id,\n+                              substs: copy *target_substs\n+                          };\n                           let vtable_opt =\n                               lookup_vtable(&vcx,\n                                             location_info,\n                                             mt.ty,\n-                                            target_ty,\n+                                            &target_trait_ref,\n                                             is_early);\n                           match vtable_opt {\n                               Some(vtable) => {\n@@ -622,11 +603,12 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                           }\n                       }\n \n-                      (_, ty::BareTraitStore) => {\n+                      (_, ty::UniqTraitStore) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n-                              ~\"a sigil (`@`, `~`, or `&`) must be specified \\\n-                                when casting to a trait\");\n+                              fmt!(\"can only cast an ~-pointer \\\n+                                    to a ~-object, not a %s\",\n+                                   ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n \n                       (_, ty::BoxTraitStore) => {\n@@ -637,14 +619,6 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                    ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n \n-                      (_, ty::UniqTraitStore) => {\n-                          fcx.ccx.tcx.sess.span_err(\n-                              ex.span,\n-                              fmt!(\"can only cast an ~-pointer \\\n-                                    to a ~-object, not a %s\",\n-                                   ty::ty_sort_str(fcx.tcx(), ty)));\n-                      }\n-\n                       (_, ty::RegionTraitStore(_)) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n@@ -661,9 +635,9 @@ pub fn early_resolve_expr(ex: @ast::expr,\n     }\n }\n \n-pub fn resolve_expr(ex: @ast::expr,\n-                    &&fcx: @mut FnCtxt,\n-                    v: visit::vt<@mut FnCtxt>) {\n+fn resolve_expr(ex: @ast::expr,\n+                &&fcx: @mut FnCtxt,\n+                v: visit::vt<@mut FnCtxt>) {\n     early_resolve_expr(ex, fcx, false);\n     visit::visit_expr(ex, fcx, v);\n }"}, {"sha": "b0e5ecee01ebbec03dbd4f7802ad1a05e1c8213b", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -38,7 +38,7 @@ use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n-use syntax::ast::{crate, def_id, def_mod, def_ty};\n+use syntax::ast::{crate, def_id, def_mod, def_trait};\n use syntax::ast::{item, item_impl, item_mod, local_crate, method, trait_ref};\n use syntax::ast;\n use syntax::ast_map::node_item;\n@@ -333,10 +333,16 @@ pub impl CoherenceChecker {\n             let new_id = parse::next_node_id(tcx.sess.parse_sess);\n             let new_did = local_def(new_id);\n \n+            let new_method_ty = @ty::method {\n+                def_id: new_did,\n+                ..copy *trait_method\n+            };\n+\n             // XXX: Perform substitutions.\n             let new_polytype = ty::lookup_item_type(tcx,\n                                                     trait_method.def_id);\n             tcx.tcache.insert(new_did, new_polytype);\n+            tcx.methods.insert(new_did, new_method_ty);\n \n             // Pair the new synthesized ID up with the\n             // ID of the method.\n@@ -352,7 +358,7 @@ pub impl CoherenceChecker {\n                 @ProvidedMethodInfo {\n                     method_info: @MethodInfo {\n                         did: new_did,\n-                        n_tps: trait_method.tps.len(),\n+                        n_tps: trait_method.generics.bounds.len(),\n                         ident: trait_method.ident,\n                         self_type: trait_method.self_ty\n                     },\n@@ -498,7 +504,7 @@ pub impl CoherenceChecker {\n \n     fn each_provided_trait_method(&self,\n             trait_did: ast::def_id,\n-            f: &fn(x: &ty::method) -> bool) {\n+            f: &fn(x: @ty::method) -> bool) {\n         // Make a list of all the names of the provided methods.\n         // XXX: This is horrible.\n         let mut provided_method_idents = HashSet::new();\n@@ -507,7 +513,7 @@ pub impl CoherenceChecker {\n             provided_method_idents.insert(*ident);\n         }\n \n-        for ty::trait_methods(tcx, trait_did).each |method| {\n+        for ty::trait_methods(tcx, trait_did).each |&method| {\n             if provided_method_idents.contains(&method.ident) {\n                 if !f(method) {\n                     break;\n@@ -536,10 +542,10 @@ pub impl CoherenceChecker {\n                                   -> UniversalQuantificationResult {\n         // NDM--this span is bogus.\n         let self_region =\n-            polytype.region_param.map(\n+            polytype.generics.region_param.map(\n                 |_r| self.inference_context.next_region_var_nb(dummy_sp()));\n \n-        let bounds_count = polytype.bounds.len();\n+        let bounds_count = polytype.generics.bounds.len();\n         let type_parameters =\n             self.inference_context.next_ty_vars(bounds_count);\n \n@@ -559,7 +565,7 @@ pub impl CoherenceChecker {\n         UniversalQuantificationResult {\n             monotype: monotype,\n             type_variables: type_parameters,\n-            bounds: polytype.bounds\n+            bounds: polytype.generics.bounds\n         }\n     }\n \n@@ -858,17 +864,8 @@ pub impl CoherenceChecker {\n             }\n \n             // Record all the trait methods.\n-            for associated_traits.each |trait_type| {\n-                match get(*trait_type).sty {\n-                    ty_trait(trait_id, _, _) => {\n-                        self.add_trait_method(trait_id, *implementation);\n-                    }\n-                    _ => {\n-                        self.crate_context.tcx.sess.bug(~\"trait type \\\n-                                                          returned is not a \\\n-                                                          trait\");\n-                    }\n-                }\n+            for associated_traits.each |trait_ref| {\n+                self.add_trait_method(trait_ref.def_id, *implementation);\n             }\n \n             // Add the implementation to the mapping from\n@@ -917,7 +914,7 @@ pub impl CoherenceChecker {\n                 @ProvidedMethodInfo {\n                     method_info: @MethodInfo {\n                         did: new_did,\n-                        n_tps: trait_method_info.ty.tps.len(),\n+                        n_tps: trait_method_info.ty.generics.bounds.len(),\n                         ident: trait_method_info.ty.ident,\n                         self_type: trait_method_info.ty.self_ty\n                     },\n@@ -947,16 +944,8 @@ pub impl CoherenceChecker {\n                                                   crate_store,\n                                                   def_id);\n                     }\n-                    dl_def(def_ty(def_id)) => {\n-                        let tcx = self.crate_context.tcx;\n-                        let polytype = csearch::get_type(tcx, def_id);\n-                        match ty::get(polytype.ty).sty {\n-                            ty::ty_trait(*) => {\n-                                self.add_default_methods_for_external_trait(\n-                                    def_id);\n-                            }\n-                            _ => {}\n-                        }\n+                    dl_def(def_trait(def_id)) => {\n+                        self.add_default_methods_for_external_trait(def_id);\n                     }\n                     dl_def(_) | dl_impl(_) | dl_field => {\n                         // Skip this."}, {"sha": "a9d54716cd8a86d534816a772da1171084e94402", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 384, "deletions": 321, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -33,17 +33,15 @@ are represented as `ty_param()` instances.\n use core::prelude::*;\n \n use metadata::csearch;\n-use middle::ty::InstantiatedTraitRef;\n-use middle::ty::{substs, ty_param_bounds_and_ty, ty_param_substs_and_ty};\n+use middle::ty::{substs, ty_param_bounds_and_ty};\n use middle::ty;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::infer;\n use middle::typeck::rscope::*;\n use middle::typeck::rscope;\n-use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx,\n-                     write_tpt_to_tcx};\n+use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n use util::common::{indenter, pluralize};\n use util::ppaux;\n \n@@ -53,7 +51,6 @@ use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n-use syntax::ast_util::{trait_method_to_ty_method};\n use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n@@ -84,12 +81,10 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n \n                     match intrinsic_item.node {\n                       ast::item_trait(*) => {\n-                        let ty = ty::mk_trait(ccx.tcx,\n-                                              def_id,\n-                                              substs,\n-                                              ty::BareTraitStore);\n-                        ccx.tcx.intrinsic_defs.insert\n-                            (intrinsic_item.ident, (def_id, ty));\n+                          let tref = @ty::TraitRef {def_id: def_id,\n+                                                    substs: substs};\n+                          ccx.tcx.intrinsic_traits.insert\n+                              (intrinsic_item.ident, tref);\n                       }\n \n                       ast::item_enum(*) => {\n@@ -153,6 +148,10 @@ impl AstConv for CrateCtxt {\n         }\n     }\n \n+    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef {\n+        get_trait_def(self, id)\n+    }\n+\n     fn ty_infer(&self, span: span) -> ty::t {\n         self.tcx.sess.span_bug(span,\n                                ~\"found `ty_infer` in unexpected place\");\n@@ -187,8 +186,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n             ast::struct_variant_kind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    bounds: ty_param_bounds(ccx, generics),\n-                    region_param: rp,\n+                    generics: ty_generics(ccx, rp, generics),\n                     ty: enum_ty\n                 };\n \n@@ -209,8 +207,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n             None => {}\n             Some(result_ty) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    bounds: ty_param_bounds(ccx, generics),\n-                    region_param: rp,\n+                    generics: ty_generics(ccx, rp, generics),\n                     ty: result_ty\n                 };\n                 tcx.tcache.insert(local_def(variant.node.id), tpt);\n@@ -221,23 +218,62 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n }\n \n pub fn ensure_trait_methods(ccx: &CrateCtxt,\n-                            id: ast::node_id,\n-                            trait_ty: ty::t) {\n-    fn store_methods<T>(ccx: &CrateCtxt,\n-                        id: ast::node_id,\n-                        stuff: &[T],\n-                        f: &fn(v: &T) -> ty::method) {\n-        ty::store_trait_methods(ccx.tcx, id, @stuff.map(f));\n+                            trait_id: ast::node_id)\n+{\n+    let tcx = ccx.tcx;\n+    let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|&x| *x);\n+    match *tcx.items.get(&trait_id) {\n+        ast_map::node_item(@ast::item {\n+            node: ast::item_trait(ref generics, _, ref ms),\n+            _\n+        }, _) => {\n+            let trait_ty_generics = ty_generics(ccx, region_paramd, generics);\n+\n+            // For each method, construct a suitable ty::method and\n+            // store it into the `tcx.methods` table:\n+            for ms.each |m| {\n+                let ty_method = @match m {\n+                    &ast::required(ref m) => {\n+                        ty_method_of_trait_method(\n+                            ccx, trait_id, region_paramd, generics,\n+                            &m.id, &m.ident, &m.self_ty,\n+                            &m.generics, &m.purity, &m.decl)\n+                    }\n+\n+                    &ast::provided(ref m) => {\n+                        ty_method_of_trait_method(\n+                            ccx, trait_id, region_paramd, generics,\n+                            &m.id, &m.ident, &m.self_ty,\n+                            &m.generics, &m.purity, &m.decl)\n+                    }\n+                };\n+\n+                if ty_method.self_ty == ast::sty_static {\n+                    make_static_method_ty(ccx, trait_id, ty_method,\n+                                          &trait_ty_generics);\n+                }\n+\n+                tcx.methods.insert(ty_method.def_id, ty_method);\n+            }\n+\n+            // Add an entry mapping\n+            let method_def_ids = @ms.map(|m| {\n+                match m {\n+                    &ast::required(ref ty_method) => local_def(ty_method.id),\n+                    &ast::provided(ref method) => local_def(method.id)\n+                }\n+            });\n+\n+            let trait_def_id = local_def(trait_id);\n+            tcx.trait_method_def_ids.insert(trait_def_id, method_def_ids);\n+        }\n+        _ => { /* Ignore things that aren't traits */ }\n     }\n \n     fn make_static_method_ty(ccx: &CrateCtxt,\n-                             am: &ast::ty_method,\n-                             rp: Option<ty::region_variance>,\n-                             m: ty::method,\n-                             // Take this as an argument b/c we may check\n-                             // the impl before the trait.\n-                             trait_ty: ty::t,\n-                             trait_bounds: @~[ty::param_bounds]) {\n+                             trait_id: ast::node_id,\n+                             m: &ty::method,\n+                             trait_ty_generics: &ty::Generics) {\n         // We need to create a typaram that replaces self. This param goes\n         // *in between* the typarams from the trait and those from the\n         // method (since its bound can depend on the trait? or\n@@ -248,12 +284,13 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n         let dummy_defid = ast::def_id {crate: 0, node: 0};\n \n-        let non_shifted_trait_tps = do vec::from_fn(trait_bounds.len()) |i| {\n+        let num_trait_bounds = trait_ty_generics.bounds.len();\n+        let non_shifted_trait_tps = do vec::from_fn(num_trait_bounds) |i| {\n             ty::mk_param(ccx.tcx, i, dummy_defid)\n         };\n-        let self_param = ty::mk_param(ccx.tcx, trait_bounds.len(),\n+        let self_param = ty::mk_param(ccx.tcx, num_trait_bounds,\n                                       dummy_defid);\n-        let shifted_method_tps = do vec::from_fn(m.tps.len()) |i| {\n+        let shifted_method_tps = do vec::from_fn(m.generics.bounds.len()) |i| {\n             ty::mk_param(ccx.tcx, i + 1, dummy_defid)\n         };\n \n@@ -265,76 +302,77 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         let ty = ty::subst(ccx.tcx,\n                            &substs,\n                            ty::mk_bare_fn(ccx.tcx, copy m.fty));\n-        let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n-                       + *m.tps);\n-        ccx.tcx.tcache.insert(local_def(am.id),\n+        let trait_def = get_trait_def(ccx, local_def(trait_id));\n+        let trait_ref = trait_def.trait_ref;\n+        let mut new_bounds = ~[];\n+        new_bounds.push_all(*trait_ty_generics.bounds);\n+        new_bounds.push(@~[ty::bound_trait(trait_ref)]);\n+        new_bounds.push_all(*m.generics.bounds);\n+        ccx.tcx.tcache.insert(m.def_id,\n                               ty_param_bounds_and_ty {\n-                                bounds: bounds,\n-                                region_param: rp,\n-                                ty: ty});\n+                                  generics: ty::Generics {\n+                                      bounds: @new_bounds,\n+                                      region_param: trait_ty_generics.region_param\n+                                  },\n+                                  ty: ty\n+                              });\n     }\n \n-\n-    let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(&id).map_consume(|x| *x);\n-    match *tcx.items.get(&id) {\n-      ast_map::node_item(@ast::item {\n-                node: ast::item_trait(ref generics, _, ref ms),\n-                _\n-            }, _) => {\n-        store_methods::<ast::trait_method>(ccx, id, *ms, |m| {\n-            let def_id;\n-            match *m {\n-                ast::required(ref ty_method) => {\n-                    def_id = local_def((*ty_method).id)\n-                }\n-                ast::provided(method) => def_id = local_def(method.id)\n-            }\n-\n-            let trait_bounds = ty_param_bounds(ccx, generics);\n-            let ty_m = trait_method_to_ty_method(m);\n-            let method_ty = ty_of_ty_method(\n-                ccx,\n-                &ty_m,\n-                region_paramd,\n-                def_id,\n-                generics\n-            );\n-            if ty_m.self_ty.node == ast::sty_static {\n-                make_static_method_ty(ccx, &ty_m, region_paramd,\n-                                      method_ty, trait_ty,\n-                                      trait_bounds);\n-            }\n-            method_ty\n-        });\n-      }\n-      _ => { /* Ignore things that aren't traits */ }\n+    fn ty_method_of_trait_method(self: &CrateCtxt,\n+                                 trait_id: ast::node_id,\n+                                 trait_rp: Option<ty::region_variance>,\n+                                 trait_generics: &ast::Generics,\n+                                 m_id: &ast::node_id,\n+                                 m_ident: &ast::ident,\n+                                 m_self_ty: &ast::self_ty,\n+                                 m_generics: &ast::Generics,\n+                                 m_purity: &ast::purity,\n+                                 m_decl: &ast::fn_decl) -> ty::method\n+    {\n+        let trait_self_ty = ty::mk_self(self.tcx, local_def(trait_id));\n+        let rscope = MethodRscope::new(m_self_ty.node, trait_rp, trait_generics);\n+        let (transformed_self_ty, fty) =\n+            astconv::ty_of_method(self, &rscope, *m_purity, &m_generics.lifetimes,\n+                                  trait_self_ty, *m_self_ty, m_decl);\n+        ty::method {\n+            ident: *m_ident,\n+            generics: ty_generics(self, None, m_generics),\n+            transformed_self_ty: transformed_self_ty,\n+            fty: fty,\n+            self_ty: m_self_ty.node,\n+            // assume public, because this is only invoked on trait methods\n+            vis: ast::public,\n+            def_id: local_def(*m_id)\n+        }\n     }\n }\n \n pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::node_id,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n-                          trait_refs: &[@ast::trait_ref],\n-                          generics: &ast::Generics) {\n+                          ast_trait_refs: &[@ast::trait_ref],\n+                          generics: &ast::Generics)\n+{\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n-    let mut instantiated = ~[];\n-    for trait_refs.each |trait_ref| {\n-        let (did, tpt) = instantiate_trait_ref(ccx, *trait_ref, rp, generics);\n-        if instantiated.any(|other_trait: &InstantiatedTraitRef|\n-                            { other_trait.def_id == did }) {\n+    let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n+    for ast_trait_refs.each |&ast_trait_ref| {\n+        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp, generics);\n+\n+        // FIXME(#5527) Could have same trait multiple times\n+        if ty_trait_refs.any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n             // This means a trait inherited from the same supertrait more\n             // than once.\n             tcx.sess.span_err(sp, ~\"Duplicate supertrait in trait \\\n                                      declaration\");\n-            return;\n+            break;\n+        } else {\n+            ty_trait_refs.push(trait_ref);\n         }\n-        instantiated.push(InstantiatedTraitRef { def_id: did, tpt: tpt });\n     }\n-    tcx.supertraits.insert(local_def(id), @instantiated);\n+    tcx.supertraits.insert(local_def(id), @ty_trait_refs);\n }\n \n /**\n@@ -388,15 +426,15 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         }\n     }\n \n-    if impl_m.tps.len() != trait_m.tps.len() {\n+    if impl_m.generics.bounds.len() != trait_m.generics.bounds.len() {\n         tcx.sess.span_err(\n             cm.span,\n             fmt!(\"method `%s` has %u type %s, but its trait \\\n                   declaration has %u type %s\",\n-                 *tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n-                 pluralize(impl_m.tps.len(), ~\"parameter\"),\n-                 trait_m.tps.len(),\n-                 pluralize(trait_m.tps.len(), ~\"parameter\")));\n+                 *tcx.sess.str_of(trait_m.ident), impl_m.generics.bounds.len(),\n+                 pluralize(impl_m.generics.bounds.len(), ~\"parameter\"),\n+                 trait_m.generics.bounds.len(),\n+                 pluralize(trait_m.generics.bounds.len(), ~\"parameter\")));\n         return;\n     }\n \n@@ -414,9 +452,9 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // FIXME(#2687)---we should be checking that the bounds of the\n     // trait imply the bounds of the subtype, but it appears\n     // we are...not checking this.\n-    for trait_m.tps.eachi() |i, trait_param_bounds| {\n+    for trait_m.generics.bounds.eachi() |i, trait_param_bounds| {\n         // For each of the corresponding impl ty param's bounds...\n-        let impl_param_bounds = impl_m.tps[i];\n+        let impl_param_bounds = impl_m.generics.bounds[i];\n         // Make sure the bounds lists have the same length\n         // Would be nice to use the ty param names in the error message,\n         // but we don't have easy access to them here\n@@ -456,7 +494,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     };\n     debug!(\"impl_fty: %s\", ppaux::ty_to_str(tcx, impl_fty));\n     let trait_fty = {\n-        let dummy_tps = do vec::from_fn((*trait_m.tps).len()) |i| {\n+        let dummy_tps = do vec::from_fn(trait_m.generics.bounds.len()) |i| {\n             // hack: we don't know the def id of the impl tp, but it\n             // is not important for unification\n             ty::mk_param(tcx, i + impl_tps, ast::def_id {crate: 0, node: 0})\n@@ -501,40 +539,26 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                                    rp: Option<ty::region_variance>,\n                                    selfty: ty::t,\n                                    a_trait_ty: @ast::trait_ref,\n-                                   impl_ms: &[ConvertedMethod]) {\n-\n+                                   impl_ms: &[ConvertedMethod])\n+{\n     let tcx = ccx.tcx;\n-    let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp, generics);\n-\n-    if did.crate == ast::local_crate {\n-        // NB: This is subtle. We need to do this on the type of the trait\n-        // item *itself*, not on the type that includes the parameter\n-        // substitutions provided by the programmer at this particular\n-        // trait ref. Otherwise, we will potentially overwrite the types of\n-        // the methods within the trait with bogus results. (See issue #3903.)\n-\n-        match tcx.items.find(&did.node) {\n-            Some(&ast_map::node_item(item, _)) => {\n-                let tpt = ty_of_item(ccx, item);\n-                ensure_trait_methods(ccx, did.node, tpt.ty);\n-            }\n-            _ => {\n-                tcx.sess.bug(~\"trait ref didn't resolve to trait\");\n-            }\n-        }\n+    let trait_ref = instantiate_trait_ref(ccx, a_trait_ty, rp, generics);\n+\n+    if trait_ref.def_id.crate == ast::local_crate {\n+        ensure_trait_methods(ccx, trait_ref.def_id.node);\n     }\n \n     // Check that each method we impl is a method on the trait\n     // Trait methods we don't implement must be default methods, but if not\n     // we'll catch it in coherence\n-    let trait_ms = ty::trait_methods(tcx, did);\n+    let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n     for impl_ms.each |impl_m| {\n         match trait_ms.find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n-            Some(ref trait_m) => {\n+            Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method(\n                     ccx.tcx, num_impl_tps, impl_m, trait_m,\n-                    &tpt.substs, selfty);\n+                    &trait_ref.substs, selfty);\n             }\n             None => {\n                 // This method is not part of the trait\n@@ -560,44 +584,91 @@ pub fn convert_field(ccx: &CrateCtxt,\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n                           ty::ty_param_bounds_and_ty {\n-                              bounds: bounds,\n-                              region_param: rp,\n+                              generics: ty::Generics {\n+                                  bounds: bounds,\n+                                  region_param: rp\n+                              },\n                               ty: tt\n                           });\n }\n \n pub struct ConvertedMethod {\n-    mty: ty::method,\n+    mty: @ty::method,\n     id: ast::node_id,\n     span: span,\n     body_id: ast::node_id\n }\n \n pub fn convert_methods(ccx: &CrateCtxt,\n                        ms: &[@ast::method],\n-                       rp: Option<ty::region_variance>,\n-                       rcvr_bounds: @~[ty::param_bounds],\n-                       rcvr_generics: &ast::Generics)\n-                    -> ~[ConvertedMethod] {\n-\n+                       untransformed_rcvr_ty: ty::t,\n+                       rcvr_ty_generics: &ty::Generics,\n+                       rcvr_ast_generics: &ast::Generics,\n+                       rcvr_visibility: ast::visibility)\n+                    -> ~[ConvertedMethod]\n+{\n     let tcx = ccx.tcx;\n-    do vec::map(ms) |m| {\n-        let bounds = ty_param_bounds(ccx, &m.generics);\n-        let mty = ty_of_method(ccx, *m, rp, rcvr_generics, &m.generics);\n-        let fty = ty::mk_bare_fn(tcx, copy mty.fty);\n+    return vec::map(ms, |m| {\n+        let m_ty_generics =\n+            ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics);\n+        let mty =\n+            @ty_of_method(ccx, *m, rcvr_ty_generics.region_param,\n+                          untransformed_rcvr_ty,\n+                          rcvr_ast_generics, rcvr_visibility,\n+                          &m.generics);\n+        let fty =\n+            ty::mk_bare_fn(tcx, copy mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n \n             // n.b.: the type of a method is parameterized by both\n             // the tps on the receiver and those on the method itself\n             ty_param_bounds_and_ty {\n-                bounds: @(vec::append(/*bad*/copy *rcvr_bounds, *bounds)),\n-                region_param: rp,\n+                generics: ty::Generics {\n+                    bounds: @(vec::append(copy *rcvr_ty_generics.bounds,\n+                                          *m_ty_generics.bounds)),\n+                    region_param: rcvr_ty_generics.region_param\n+                },\n                 ty: fty\n             });\n         write_ty_to_tcx(tcx, m.id, fty);\n+        tcx.methods.insert(mty.def_id, mty);\n         ConvertedMethod {mty: mty, id: m.id,\n                          span: m.span, body_id: m.body.node.id}\n+    });\n+\n+    fn ty_of_method(ccx: &CrateCtxt,\n+                    m: @ast::method,\n+                    rp: Option<ty::region_variance>,\n+                    untransformed_rcvr_ty: ty::t,\n+                    rcvr_generics: &ast::Generics,\n+                    rcvr_visibility: ast::visibility,\n+                    method_generics: &ast::Generics) -> ty::method\n+    {\n+        let rscope = MethodRscope::new(m.self_ty.node,\n+                                       rp,\n+                                       rcvr_generics);\n+        let (transformed_self_ty, fty) =\n+            astconv::ty_of_method(ccx, &rscope, m.purity,\n+                                  &method_generics.lifetimes,\n+                                  untransformed_rcvr_ty,\n+                                  m.self_ty, &m.decl);\n+\n+        // if the method specifies a visibility, use that, otherwise\n+        // inherit the visibility from the impl (so `foo` in `pub impl\n+        // { fn foo(); }` is public, but private in `priv impl { fn\n+        // foo(); }`).\n+        let method_vis = m.vis.inherit_from(rcvr_visibility);\n+\n+        ty::method {\n+            ident: m.ident,\n+            generics: ty_generics(ccx, None, &m.generics),\n+            transformed_self_ty: transformed_self_ty,\n+            fty: fty,\n+            self_ty: m.self_ty.node,\n+            vis: method_vis,\n+            def_id: local_def(m.id)\n+        }\n     }\n }\n \n@@ -633,36 +704,49 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n                                generics,\n                                rp);\n       }\n-      ast::item_impl(ref generics, trait_ref, selfty, ref ms) => {\n-        let i_bounds = ty_param_bounds(ccx, generics);\n+      ast::item_impl(ref generics, opt_trait_ref, selfty, ref ms) => {\n+        let i_ty_generics = ty_generics(ccx, rp, generics);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n         let selfty = ccx.to_ty(&type_rscope(region_parameterization), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n                           ty_param_bounds_and_ty {\n-                            bounds: i_bounds,\n-                            region_param: rp,\n-                            ty: selfty});\n+                              generics: i_ty_generics,\n+                              ty: selfty});\n+\n+        // If there is a trait reference, treat the methods as always public.\n+        // This is to work around some incorrect behavior in privacy checking:\n+        // when the method belongs to a trait, it should acquire the privacy\n+        // from the trait, not the impl. Forcing the visibility to be public\n+        // makes things sorta work.\n+        let parent_visibility = if opt_trait_ref.is_some() {\n+            ast::public\n+        } else {\n+            it.vis\n+        };\n \n-        // XXX: Bad copy of `ms` below.\n-        let cms = convert_methods(ccx, *ms, rp, i_bounds, generics);\n-        for trait_ref.each |t| {\n+        let cms = convert_methods(ccx, *ms, selfty,\n+                                  &i_ty_generics, generics,\n+                                  parent_visibility);\n+        for opt_trait_ref.each |t| {\n             check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n         }\n       }\n       ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n-        let tpt = ty_of_item(ccx, it);\n-        debug!(\"item_trait(it.id=%d, tpt.ty=%s)\",\n-               it.id, ppaux::ty_to_str(tcx, tpt.ty));\n-        write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        ensure_trait_methods(ccx, it.id, tpt.ty);\n-        ensure_supertraits(ccx, it.id, it.span, rp, *supertraits, generics);\n-\n-        let (_, provided_methods) =\n-            split_trait_methods(*trait_methods);\n-        let (bounds, _) = mk_substs(ccx, generics, rp);\n-        let _ = convert_methods(ccx, provided_methods, rp, bounds, generics);\n+          let trait_def = trait_def_of_item(ccx, it);\n+          tcx.trait_defs.insert(local_def(it.id), trait_def);\n+          ensure_trait_methods(ccx, it.id);\n+          ensure_supertraits(ccx, it.id, it.span, rp, *supertraits, generics);\n+\n+          let (_, provided_methods) =\n+              split_trait_methods(*trait_methods);\n+          let (ty_generics, _) = mk_substs(ccx, generics, rp);\n+          let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n+          let _ = convert_methods(ccx, provided_methods,\n+                                  untransformed_rcvr_ty,\n+                                  &ty_generics, generics,\n+                                  it.vis);\n       }\n       ast::item_struct(struct_def, ref generics) => {\n         ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n@@ -714,14 +798,16 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           ty_param_bounds_and_ty {\n-                            bounds: tpt.bounds,\n-                            region_param: rp,\n-                            ty: t_dtor});\n+                              generics: ty::Generics {\n+                                  bounds: tpt.generics.bounds,\n+                                  region_param: rp\n+                              },\n+                              ty: t_dtor});\n     };\n \n     // Write the type of each of the members\n     for struct_def.fields.each |f| {\n-       convert_field(ccx, rp, tpt.bounds, *f, generics);\n+       convert_field(ccx, rp, tpt.generics.bounds, *f, generics);\n     }\n     let (_, substs) = mk_substs(ccx, generics, rp);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n@@ -744,8 +830,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx, inputs, selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.insert(local_def(ctor_id), ty_param_bounds_and_ty {\n-                    bounds: tpt.bounds,\n-                    region_param: tpt.region_param,\n+                    generics: tpt.generics,\n                     ty: ctor_fn_ty\n                 });\n             }\n@@ -762,85 +847,75 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: @ast::foreign_item) {\n     ccx.tcx.tcache.insert(local_def(i.id), tpt);\n }\n \n-pub fn ty_of_method(ccx: &CrateCtxt,\n-                    m: @ast::method,\n-                    rp: Option<ty::region_variance>,\n-                    rcvr_generics: &ast::Generics,\n-                    method_generics: &ast::Generics)\n-                 -> ty::method {\n-    let rscope = MethodRscope::new(m.self_ty.node,\n-                                   rp,\n-                                   rcvr_generics);\n-    ty::method {\n-        ident: m.ident,\n-        tps: ty_param_bounds(ccx, &m.generics),\n-        fty: astconv::ty_of_bare_fn(ccx,\n-                                    &rscope,\n-                                    m.purity,\n-                                    AbiSet::Rust(),\n-                                    &method_generics.lifetimes,\n-                                    &m.decl),\n-        self_ty: m.self_ty.node,\n-        vis: m.vis,\n-        def_id: local_def(m.id)\n-    }\n-}\n-\n-pub fn ty_of_ty_method(self: &CrateCtxt,\n-                       m: &ast::ty_method,\n-                       rp: Option<ty::region_variance>,\n-                       id: ast::def_id,\n-                       generics: &ast::Generics)\n-                    -> ty::method {\n-    let rscope = MethodRscope::new(m.self_ty.node, rp, generics);\n-    ty::method {\n-        ident: m.ident,\n-        tps: ty_param_bounds(self, &m.generics),\n-        fty: astconv::ty_of_bare_fn(self,\n-                                    &rscope,\n-                                    m.purity,\n-                                    AbiSet::Rust(),\n-                                    &m.generics.lifetimes,\n-                                    &m.decl),\n-        // assume public, because this is only invoked on trait methods\n-        self_ty: m.self_ty.node,\n-        vis: ast::public,\n-        def_id: id\n-    }\n-}\n-\n-/*\n-  Instantiates the path for the given trait reference, assuming that\n-  it's bound to a valid trait type. Returns the def_id for the defining\n-  trait. Fails if the type is a type other than an trait type.\n- */\n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n-                             t: @ast::trait_ref,\n+                             ast_trait_ref: @ast::trait_ref,\n                              rp: Option<ty::region_variance>,\n-                             generics: &ast::Generics)\n-    -> (ast::def_id, ty_param_substs_and_ty) {\n-\n-    let sp = t.path.span, err = ~\"can only implement trait types\",\n-        sess = ccx.tcx.sess;\n+                             generics: &ast::Generics) -> @ty::TraitRef\n+{\n+    /*!\n+     * Instantiates the path for the given trait reference, assuming that\n+     * it's bound to a valid trait type. Returns the def_id for the defining\n+     * trait. Fails if the type is a type other than an trait type.\n+     */\n \n     let rp = RegionParameterization::from_variance_and_generics(rp, generics);\n \n     let rscope = type_rscope(rp);\n \n-    match lookup_def_tcx(ccx.tcx, t.path.span, t.ref_id) {\n-      ast::def_ty(t_id) => {\n-        let tpt = astconv::ast_path_to_ty(ccx, &rscope, t_id, t.path);\n+    match lookup_def_tcx(ccx.tcx, ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n+        ast::def_trait(trait_did) => {\n+            let trait_ref =\n+                astconv::ast_path_to_trait_ref(\n+                    ccx, &rscope, trait_did, ast_trait_ref.path);\n+            ccx.tcx.trait_refs.insert(\n+                ast_trait_ref.ref_id, trait_ref);\n+            return trait_ref;\n+        }\n+        _ => {\n+            ccx.tcx.sess.span_fatal(\n+                ast_trait_ref.path.span,\n+                fmt!(\"%s is not a trait\",\n+                    path_to_str(ast_trait_ref.path,\n+                                ccx.tcx.sess.intr())));\n+        }\n+    }\n+}\n \n-        write_tpt_to_tcx(ccx.tcx, t.ref_id, &tpt);\n+fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::def_id) -> @ty::TraitDef {\n+    if trait_id.crate != ast::local_crate {\n+        ty::lookup_trait_def(ccx.tcx, trait_id)\n+    } else {\n+        match ccx.tcx.items.get(&trait_id.node) {\n+            &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n+            _ => ccx.tcx.sess.bug(fmt!(\"get_trait_def(%d): not an item\",\n+                                       trait_id.node))\n+        }\n+    }\n+}\n \n-        match ty::get(tpt.ty).sty {\n-           ty::ty_trait(*) => {\n-              (t_id, tpt)\n-           }\n-           _ => sess.span_fatal(sp, err),\n+pub fn trait_def_of_item(ccx: &CrateCtxt, it: @ast::item) -> @ty::TraitDef {\n+    let def_id = local_def(it.id);\n+    let tcx = ccx.tcx;\n+    match tcx.trait_defs.find(&def_id) {\n+      Some(&def) => return def,\n+      _ => {}\n+    }\n+    let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n+    match it.node {\n+        ast::item_trait(ref generics, _, _) => {\n+            let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n+            let trait_ref = @ty::TraitRef {def_id: def_id,\n+                                           substs: substs};\n+            let trait_def = @ty::TraitDef {generics: ty_generics,\n+                                           trait_ref: trait_ref};\n+            tcx.trait_defs.insert(def_id, trait_def);\n+            return trait_def;\n+        }\n+        ref s => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                fmt!(\"trait_def_of_item invoked on %?\", s));\n         }\n-      }\n-      _ => sess.span_fatal(sp, err)\n     }\n }\n \n@@ -861,16 +936,19 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n         return tpt;\n       }\n       ast::item_fn(ref decl, purity, _, ref generics, _) => {\n-        let bounds = ty_param_bounds(ccx, generics);\n+        assert!(rp.is_none());\n+        let ty_generics = ty_generics(ccx, None, generics);\n         let tofd = astconv::ty_of_bare_fn(ccx,\n                                           &empty_rscope,\n                                           purity,\n                                           AbiSet::Rust(),\n                                           &generics.lifetimes,\n                                           decl);\n         let tpt = ty_param_bounds_and_ty {\n-            bounds: bounds,\n-            region_param: None,\n+            generics: ty::Generics {\n+                bounds: ty_generics.bounds,\n+                region_param: None\n+            },\n             ty: ty::mk_bare_fn(ccx.tcx, tofd)\n         };\n         debug!(\"type of %s (id %d) is %s\",\n@@ -901,8 +979,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n                 }\n             };\n             ty_param_bounds_and_ty {\n-                bounds: ty_param_bounds(ccx, generics),\n-                region_param: rp,\n+                generics: ty_generics(ccx, rp, generics),\n                 ty: ty\n             }\n         };\n@@ -912,37 +989,26 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n       }\n       ast::item_enum(_, ref generics) => {\n         // Create a new generic polytype.\n-        let (bounds, substs) = mk_substs(ccx, generics, rp);\n+        let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n         let tpt = ty_param_bounds_and_ty {\n-            bounds: bounds,\n-            region_param: rp,\n+            generics: ty_generics,\n             ty: t\n         };\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_trait(ref generics, _, _) => {\n-        let (bounds, substs) = mk_substs(ccx, generics, rp);\n-        let t = ty::mk_trait(tcx,\n-                             local_def(it.id),\n-                             substs,\n-                             ty::BareTraitStore);\n-        let tpt = ty_param_bounds_and_ty {\n-            bounds: bounds,\n-            region_param: rp,\n-            ty: t\n-        };\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n+      ast::item_trait(*) => {\n+          tcx.sess.span_bug(\n+              it.span,\n+              fmt!(\"Invoked ty_of_item on trait\"));\n       }\n       ast::item_struct(_, ref generics) => {\n-          let (bounds, substs) = mk_substs(ccx, generics, rp);\n+          let (ty_generics, substs) = mk_substs(ccx, generics, rp);\n           let t = ty::mk_struct(tcx, local_def(it.id), substs);\n           let tpt = ty_param_bounds_and_ty {\n-            bounds: bounds,\n-            region_param: rp,\n-            ty: t\n+              generics: ty_generics,\n+              ty: t\n           };\n           tcx.tcache.insert(local_def(it.id), tpt);\n           return tpt;\n@@ -964,76 +1030,82 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt, it: @ast::foreign_item)\n         }\n         ast::foreign_item_const(t) => {\n             ty::ty_param_bounds_and_ty {\n-                bounds: @~[],\n-                region_param: None,\n+                generics: ty::Generics {\n+                    bounds: @~[],\n+                    region_param: None,\n+                },\n                 ty: ast_ty_to_ty(ccx, &empty_rscope, t)\n             }\n         }\n     }\n }\n \n-// Translate the AST's notion of ty param bounds (which are an enum consisting\n-// of a newtyped Ty or a region) to ty's notion of ty param bounds, which can\n-// either be user-defined traits, or one of the four built-in traits (formerly\n-// known as kinds): Const, Copy, Durable, and Send.\n-pub fn compute_bounds(ccx: &CrateCtxt,\n-                      ast_bounds: @OptVec<ast::TyParamBound>)\n-                   -> ty::param_bounds {\n-    @ast_bounds.flat_map_to_vec(|b| {\n-        match b {\n-            &TraitTyParamBound(b) => {\n-                let li = &ccx.tcx.lang_items;\n-                let ity = ast_ty_to_ty(ccx, &empty_rscope, b);\n-                match ty::get(ity).sty {\n-                    ty::ty_trait(did, _, _) => {\n-                        if did == li.owned_trait() {\n-                            ~[ty::bound_owned]\n-                        } else if did == li.copy_trait() {\n-                            ~[ty::bound_copy]\n-                        } else if did == li.const_trait() {\n-                            ~[ty::bound_const]\n-                        } else if did == li.durable_trait() {\n-                            ~[ty::bound_durable]\n-                        } else {\n-                            // Must be a user-defined trait\n-                            ~[ty::bound_trait(ity)]\n-                        }\n-                    }\n-                    _ => {\n-                        ccx.tcx.sess.span_err(\n-                            (*b).span, ~\"type parameter bounds must be \\\n-                                         trait types\");\n-                        ~[]\n-                    }\n+pub fn ty_generics(ccx: &CrateCtxt,\n+                   rp: Option<ty::region_variance>,\n+                   generics: &ast::Generics) -> ty::Generics {\n+    return ty::Generics {\n+        region_param: rp,\n+        bounds: @generics.ty_params.map_to_vec(|param| {\n+            match ccx.tcx.ty_param_bounds.find(&param.id) {\n+                Some(&bs) => bs,\n+                None => {\n+                    let bounds = compute_bounds(ccx, rp, generics, param.bounds);\n+                    ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n+                    bounds\n                 }\n             }\n-            &RegionTyParamBound => ~[ty::bound_durable]\n-        }\n-    })\n-}\n+        })\n+    };\n \n-pub fn ty_param_bounds(ccx: &CrateCtxt,\n-                       generics: &ast::Generics)\n-                    -> @~[ty::param_bounds] {\n-    @do generics.ty_params.map_to_vec |param| {\n-        match ccx.tcx.ty_param_bounds.find(&param.id) {\n-          Some(&bs) => bs,\n-          None => {\n-            let bounds = compute_bounds(ccx, param.bounds);\n-            ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n-            bounds\n-          }\n-        }\n+    fn compute_bounds(\n+        ccx: &CrateCtxt,\n+        rp: Option<ty::region_variance>,\n+        generics: &ast::Generics,\n+        ast_bounds: @OptVec<ast::TyParamBound>) -> ty::param_bounds\n+    {\n+        /*!\n+         *\n+         * Translate the AST's notion of ty param bounds (which are an\n+         * enum consisting of a newtyped Ty or a region) to ty's\n+         * notion of ty param bounds, which can either be user-defined\n+         * traits, or one of the four built-in traits (formerly known\n+         * as kinds): Const, Copy, Durable, and Send.\n+         */\n+\n+        @ast_bounds.flat_map_to_vec(|b| {\n+            match b {\n+                &TraitTyParamBound(b) => {\n+                    let li = &ccx.tcx.lang_items;\n+                    let trait_ref = instantiate_trait_ref(ccx, b, rp, generics);\n+                    if trait_ref.def_id == li.owned_trait() {\n+                        ~[ty::bound_owned]\n+                    } else if trait_ref.def_id == li.copy_trait() {\n+                        ~[ty::bound_copy]\n+                    } else if trait_ref.def_id == li.const_trait() {\n+                        ~[ty::bound_const]\n+                    } else if trait_ref.def_id == li.durable_trait() {\n+                        ~[ty::bound_durable]\n+                    } else {\n+                        // Must be a user-defined trait\n+                        ~[ty::bound_trait(trait_ref)]\n+                    }\n+                }\n+\n+                &RegionTyParamBound => {\n+                    ~[ty::bound_durable]\n+                }\n+            }\n+        })\n     }\n }\n \n pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              decl: &ast::fn_decl,\n                              def_id: ast::def_id,\n-                             generics: &ast::Generics)\n+                             ast_generics: &ast::Generics)\n                           -> ty::ty_param_bounds_and_ty {\n-    let bounds = ty_param_bounds(ccx, generics);\n-    let region_param_names = RegionParamNames::from_generics(generics);\n+    let ty_generics = ty_generics(ccx, None, ast_generics);\n+    let region_param_names = RegionParamNames::from_generics(ast_generics);\n     let rb = in_binding_rscope(&empty_rscope, region_param_names);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, *a, None) );\n     let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n@@ -1048,33 +1120,24 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                             output: output_ty}\n         });\n     let tpt = ty_param_bounds_and_ty {\n-        bounds: bounds,\n-        region_param: None,\n+        generics: ty_generics,\n         ty: t_fn\n     };\n     ccx.tcx.tcache.insert(def_id, tpt);\n     return tpt;\n }\n \n-pub fn mk_generics(ccx: &CrateCtxt, generics: &ast::Generics)\n-    -> (@~[ty::param_bounds], ~[ty::t])\n-{\n-    let mut i = 0u;\n-    let bounds = ty_param_bounds(ccx, generics);\n-    (bounds,\n-     generics.ty_params.map_to_vec(|atp| {\n-         let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n-         i += 1u;\n-         t\n-     }))\n-}\n-\n pub fn mk_substs(ccx: &CrateCtxt,\n-                 generics: &ast::Generics,\n-                 rp: Option<ty::region_variance>)\n-              -> (@~[ty::param_bounds], ty::substs)\n+                 ast_generics: &ast::Generics,\n+                 rp: Option<ty::region_variance>) -> (ty::Generics, ty::substs)\n {\n-    let (bounds, params) = mk_generics(ccx, generics);\n+    let mut i = 0;\n+    let ty_generics = ty_generics(ccx, rp, ast_generics);\n+    let params = ast_generics.ty_params.map_to_vec(|atp| {\n+        let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n+        i += 1u;\n+        t\n+    });\n     let self_r = rscope::bound_self_region(rp);\n-    (bounds, substs { self_r: self_r, self_ty: None, tps: params })\n+    (ty_generics, substs {self_r: self_r, self_ty: None, tps: params})\n }"}, {"sha": "69c7b1d616b0a3dce308868b4709eb045f9f8e98", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -90,7 +90,7 @@ pub trait Combine {\n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]>;\n     fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n                -> cres<Option<ty::t>>;\n-    fn substs(&self, did: ast::def_id, as_: &ty::substs,\n+    fn substs(&self, generics: &ty::Generics, as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs>;\n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy>;\n@@ -114,6 +114,7 @@ pub trait Combine {\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n                  -> cres<ty::TraitStore>;\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef>;\n }\n \n pub struct CombineFields {\n@@ -192,32 +193,31 @@ pub fn eq_opt_regions<C:Combine>(\n }\n \n pub fn super_substs<C:Combine>(\n-    self: &C, did: ast::def_id,\n+    self: &C, generics: &ty::Generics,\n     a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n \n     fn relate_region_param<C:Combine>(\n         self: &C,\n-        did: ast::def_id,\n+        generics: &ty::Generics,\n         a: Option<ty::Region>,\n         b: Option<ty::Region>)\n         -> cres<Option<ty::Region>>\n     {\n-        let polyty = ty::lookup_item_type(self.infcx().tcx, did);\n-        match (polyty.region_param, a, b) {\n-          (None, None, None) => {\n+        match (&generics.region_param, &a, &b) {\n+          (&None, &None, &None) => {\n             Ok(None)\n           }\n-          (Some(ty::rv_invariant), Some(a), Some(b)) => {\n+          (&Some(ty::rv_invariant), &Some(a), &Some(b)) => {\n             do eq_regions(self, a, b).then {\n                 Ok(Some(a))\n             }\n           }\n-          (Some(ty::rv_covariant), Some(a), Some(b)) => {\n+          (&Some(ty::rv_covariant), &Some(a), &Some(b)) => {\n             do self.regions(a, b).chain |r| {\n                 Ok(Some(r))\n             }\n           }\n-          (Some(ty::rv_contravariant), Some(a), Some(b)) => {\n+          (&Some(ty::rv_contravariant), &Some(a), &Some(b)) => {\n             do self.contraregions(a, b).chain |r| {\n                 Ok(Some(r))\n             }\n@@ -233,14 +233,14 @@ pub fn super_substs<C:Combine>(\n                       b had opt_region %s with variance %?\",\n                       a.inf_str(self.infcx()),\n                       b.inf_str(self.infcx()),\n-                      polyty.region_param));\n+                     generics.region_param));\n           }\n         }\n     }\n \n     do self.tps(a.tps, b.tps).chain |tps| {\n         do self.self_tys(a.self_ty, b.self_ty).chain |self_ty| {\n-            do relate_region_param(self, did,\n+            do relate_region_param(self, generics,\n                                    a.self_r, b.self_r).chain |self_r|\n             {\n                 Ok(substs {\n@@ -520,26 +520,29 @@ pub fn super_tys<C:Combine>(\n       (ty::ty_enum(a_id, ref a_substs),\n        ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n-        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            Ok(ty::mk_enum(tcx, a_id, substs))\n-        }\n+          let type_def = ty::lookup_item_type(tcx, a_id);\n+          do self.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+              Ok(ty::mk_enum(tcx, a_id, substs))\n+          }\n       }\n \n       (ty::ty_trait(a_id, ref a_substs, a_store),\n        ty::ty_trait(b_id, ref b_substs, b_store))\n       if a_id == b_id => {\n-        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            do self.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n-                Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s))\n-            }\n-        }\n+          let trait_def = ty::lookup_trait_def(tcx, a_id);\n+          do self.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n+              do self.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n+                  Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s))\n+              }\n+          }\n       }\n \n       (ty::ty_struct(a_id, ref a_substs), ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n-        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            Ok(ty::mk_struct(tcx, a_id, substs))\n-        }\n+          let type_def = ty::lookup_item_type(tcx, a_id);\n+          do self.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+              Ok(ty::mk_struct(tcx, a_id, substs))\n+          }\n       }\n \n       (ty::ty_box(ref a_mt), ty::ty_box(ref b_mt)) => {\n@@ -634,3 +637,25 @@ pub fn super_tys<C:Combine>(\n         Ok(ty::mk_mach_float(tcx, val))\n     }\n }\n+\n+pub fn super_trait_refs<C:Combine>(\n+    self: &C, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef>\n+{\n+    // Different traits cannot be related\n+\n+    // - NOTE in the future, expand out subtraits!\n+\n+    if a.def_id != b.def_id {\n+        Err(ty::terr_traits(\n+            expected_found(self, a.def_id, b.def_id)))\n+    } else {\n+        let tcx = self.infcx().tcx;\n+        let trait_def = ty::lookup_trait_def(tcx, a.def_id);\n+        let substs = if_ok!(self.substs(&trait_def.generics, &a.substs, &b.substs));\n+        Ok(ty::TraitRef {\n+            def_id: a.def_id,\n+            substs: substs\n+        })\n+    }\n+}\n+"}, {"sha": "43f2b0eaf722942b16abbd888550c7076adec7a3", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -299,10 +299,11 @@ impl Combine for Glb {\n         super_closure_tys(self, a, b)\n     }\n \n-    fn substs(&self, did: ast::def_id,\n+    fn substs(&self,\n+              generics: &ty::Generics,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, did, as_, bs)\n+        super_substs(self, generics, as_, bs)\n     }\n \n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n@@ -313,5 +314,9 @@ impl Combine for Glb {\n                -> cres<Option<ty::t>> {\n         super_self_tys(self, a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        super_trait_refs(self, a, b)\n+    }\n }\n "}, {"sha": "7cf4d25c6702426b74d4d65394465ceea8151b0a", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -244,10 +244,11 @@ impl Combine for Lub {\n         super_args(self, a, b)\n     }\n \n-    fn substs(&self, did: ast::def_id,\n+    fn substs(&self,\n+              generics: &ty::Generics,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, did, as_, bs)\n+        super_substs(self, generics, as_, bs)\n     }\n \n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n@@ -258,4 +259,8 @@ impl Combine for Lub {\n                -> cres<Option<ty::t>> {\n         super_self_tys(self, a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        super_trait_refs(self, a, b)\n+    }\n }"}, {"sha": "58de0122c8c9b95bf2fea43e5f39f8073c5f1253", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -265,7 +265,7 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::isr_alist;\n use util::common::indent;\n-use util::ppaux::{bound_region_to_str, ty_to_str};\n+use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str};\n \n use core::cmp::Eq;\n use core::result::{Result, Ok, Err};\n@@ -419,6 +419,23 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n     }.to_ures()\n }\n \n+pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n+                         a_is_expected: bool,\n+                         span: span,\n+                         a: &ty::TraitRef,\n+                         b: &ty::TraitRef)\n+    -> ures\n+{\n+    debug!(\"mk_sub_trait_refs(%s <: %s)\",\n+           a.inf_str(cx), b.inf_str(cx));\n+    do indent {\n+        do cx.commit {\n+            let suber = cx.sub(a_is_expected, span);\n+            suber.trait_refs(a, b)\n+        }\n+    }.to_ures()\n+}\n+\n pub fn mk_coercety(cx: @mut InferCtxt,\n                    a_is_expected: bool,\n                    span: span,\n@@ -700,13 +717,43 @@ pub impl InferCtxt {\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n+    fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n+        let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n+        trait_ref_to_str(self.tcx, &t)\n+    }\n+\n     fn resolve_type_vars_if_possible(@mut self, typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n           result::Ok(new_type) => new_type,\n           result::Err(_) => typ\n         }\n     }\n \n+    fn resolve_type_vars_in_trait_ref_if_possible(@mut self,\n+                                                  trait_ref: &ty::TraitRef)\n+        -> ty::TraitRef\n+    {\n+        // make up a dummy type just to reuse/abuse the resolve machinery\n+        let dummy0 = ty::mk_trait(self.tcx,\n+                                  trait_ref.def_id,\n+                                  copy trait_ref.substs,\n+                                  ty::UniqTraitStore);\n+        let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n+        match ty::get(dummy1).sty {\n+            ty::ty_trait(ref def_id, ref substs, _) => {\n+                ty::TraitRef {def_id: *def_id,\n+                              substs: copy *substs}\n+            }\n+            _ => {\n+                self.tcx.sess.bug(\n+                    fmt!(\"resolve_type_vars_if_possible() yielded %s \\\n+                          when supplied with %s\",\n+                         self.ty_to_str(dummy0),\n+                         self.ty_to_str(dummy1)));\n+            }\n+        }\n+    }\n+\n     fn type_error_message(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n                           actual_ty: ty::t, err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);"}, {"sha": "2e1be2c380f8f63260554a2b8c81c1d45b91cf18", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -256,10 +256,11 @@ impl Combine for Sub {\n         super_args(self, a, b)\n     }\n \n-    fn substs(&self, did: ast::def_id,\n+    fn substs(&self,\n+              generics: &ty::Generics,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, did, as_, bs)\n+        super_substs(self, generics, as_, bs)\n     }\n \n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n@@ -270,5 +271,9 @@ impl Combine for Sub {\n                -> cres<Option<ty::t>> {\n         super_self_tys(self, a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        super_trait_refs(self, a, b)\n+    }\n }\n "}, {"sha": "d4959961f12ce01dbe919688f0a411d058da7f31", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -16,7 +16,7 @@ use middle::ty;\n use middle::typeck::infer::{Bound, Bounds};\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::unify::{Redirect, Root, VarValue};\n-use util::ppaux::{mt_to_str, ty_to_str};\n+use util::ppaux::{mt_to_str, ty_to_str, trait_ref_to_str};\n \n use syntax::ast;\n \n@@ -91,3 +91,9 @@ impl InferStr for ast::float_ty {\n         self.to_str()\n     }\n }\n+\n+impl InferStr for ty::TraitRef {\n+    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+        trait_ref_to_str(cx.tcx, self)\n+    }\n+}"}, {"sha": "d3502adb33ab8b8b97f92512a379d6a4cb9f7a49", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -222,8 +222,8 @@ pub fn lookup_def_ccx(ccx: @mut CrateCtxt, sp: span, id: ast::node_id)\n \n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n-        bounds: @~[],\n-        region_param: None,\n+        generics: ty::Generics {bounds: @~[],\n+                                region_param: None},\n         ty: t\n     }\n }"}, {"sha": "cdeb12b80f4486e3497c5f80bbcedebdba8c5f35", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -239,7 +239,6 @@ pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n \n pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n-      ty::BareTraitStore => ~\"\",\n       ty::UniqTraitStore => ~\"~\",\n       ty::BoxTraitStore => ~\"@\",\n       ty::RegionTraitStore(r) => region_to_str_space(cx, \"&\", r)\n@@ -285,6 +284,12 @@ pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n          ty_to_str(cx, typ.output))\n }\n \n+pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n+    let path = ty::item_path(cx, trait_ref.def_id);\n+    let base = ast_map::path_to_str(path, cx.sess.intr());\n+    parameterized(cx, base, trait_ref.substs.self_r, trait_ref.substs.tps)\n+}\n+\n pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn fn_input_to_str(cx: ctxt, input: ty::arg) -> ~str {\n         let ty::arg {mode: mode, ty: ty} = input;\n@@ -443,7 +448,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                    str::from_bytes(~[('a' as u8) + (id as u8)]))\n           }\n       }\n-      ty_self(*) => ~\"self\",\n+      ty_self(*) => ~\"Self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());"}, {"sha": "08008ab2bcae08d144a1dc5dc8d3ff2d463a8cf2", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -117,7 +117,7 @@ fn fold_mod(\n                         !doc.methods.is_empty()\n                     } else {\n                         // This is a trait implementation, make it visible\n-                        // NOTE: This is not quite right since this could be an impl\n+                        // NB: This is not quite right since this could be an impl\n                         // of a private trait. We can't know that without running\n                         // resolve though.\n                         true"}, {"sha": "ec77b54a853713aea88dd4852280e00b8729ee21", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -144,7 +144,7 @@ pub static crate_node_id: node_id = 0;\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Owned, and Const.\n pub enum TyParamBound {\n-    TraitTyParamBound(@Ty),\n+    TraitTyParamBound(@trait_ref),\n     RegionTyParamBound\n }\n \n@@ -194,6 +194,7 @@ pub enum def {\n     def_local(node_id, bool /* is_mutbl */),\n     def_variant(def_id /* enum */, def_id /* variant */),\n     def_ty(def_id),\n+    def_trait(def_id),\n     def_prim_ty(prim_ty),\n     def_ty_param(def_id, uint),\n     def_binding(node_id, binding_mode),\n@@ -1185,6 +1186,15 @@ pub struct trait_ref {\n #[deriving(Eq)]\n pub enum visibility { public, private, inherited }\n \n+impl visibility {\n+    fn inherit_from(&self, parent_visibility: visibility) -> visibility {\n+        match self {\n+            &inherited => parent_visibility,\n+            &public | &private => *self\n+        }\n+    }\n+}\n+\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]"}, {"sha": "c7227fa17687c3f961bff1e3b2c61a8c554533a9", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -61,7 +61,7 @@ pub fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_struct(id) => {\n+      def_use(id) | def_struct(id) | def_trait(id) => {\n         id\n       }\n       def_arg(id, _, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)"}, {"sha": "97bc89248acf2abef2a0d7e39feee5533497318f", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -222,15 +222,14 @@ pub fn expand_auto_decode(\n priv impl @ext_ctxt {\n     fn bind_path(\n         &self,\n-        span: span,\n+        _span: span,\n         ident: ast::ident,\n         path: @ast::path,\n         bounds: @OptVec<ast::TyParamBound>\n     ) -> ast::TyParam {\n-        let bound = ast::TraitTyParamBound(@ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_path(path, self.next_id()),\n-            span: span,\n+        let bound = ast::TraitTyParamBound(@ast::trait_ref {\n+            ref_id: self.next_id(),\n+            path: path\n         });\n \n         ast::TyParam {\n@@ -466,10 +465,9 @@ fn mk_impl(\n     // All the type parameters need to bound to the trait.\n     let mut impl_tps = opt_vec::with(ty_param);\n     for generics.ty_params.each |tp| {\n-        let t_bound = ast::TraitTyParamBound(@ast::Ty {\n-            id: cx.next_id(),\n-            node: ast::ty_path(path, cx.next_id()),\n-            span: span,\n+        let t_bound = ast::TraitTyParamBound(@ast::trait_ref {\n+            path: path,\n+            ref_id: cx.next_id(),\n         });\n \n         impl_tps.push(ast::TyParam {"}, {"sha": "43f0c9edcb96437e1db6a0e5d26973d5e8fb1e57", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -337,6 +337,17 @@ pub fn mk_ty_path_global(cx: @ext_ctxt,\n     let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n+pub fn mk_trait_ref_global(cx: @ext_ctxt,\n+                           span: span,\n+                           +idents: ~[ ast::ident ])\n+    -> @ast::trait_ref\n+{\n+    let path = build::mk_raw_path_global(span, idents);\n+    @ast::trait_ref {\n+        path: path,\n+        ref_id: cx.next_id()\n+    }\n+}\n pub fn mk_simple_ty_path(cx: @ext_ctxt,\n                          span: span,\n                          ident: ast::ident)"}, {"sha": "ccd9a33757dd5f331689318dbdcb01f10f8942f1", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -177,9 +177,9 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n \n     // Create the type parameters.\n     let impl_ty_params = generics.ty_params.map(|ty_param| {\n-        let bound = build::mk_ty_path_global(cx,\n-                                             span,\n-                                             trait_path.map(|x| *x));\n+        let bound = build::mk_trait_ref_global(cx,\n+                                               span,\n+                                               trait_path.map(|x| *x));\n         let bounds = @opt_vec::with(TraitTyParamBound(bound));\n         build::mk_ty_param(cx, ty_param.ident, bounds)\n     });"}, {"sha": "5aa51c262e174ce49d9e5c7066bb0e91c62238b4", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -134,7 +134,7 @@ pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n \n fn fold_ty_param_bound(tpb: &TyParamBound, fld: @ast_fold) -> TyParamBound {\n     match *tpb {\n-        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_ty(ty)),\n+        TraitTyParamBound(ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }"}, {"sha": "3a3597828cd24366238a26729f0346047215cbb7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -2750,8 +2750,8 @@ pub impl Parser {\n                     self.bump();\n                 }\n                 token::MOD_SEP | token::IDENT(*) => {\n-                    let maybe_bound = match *self.token {\n-                        token::MOD_SEP => None,\n+                    let obsolete_bound = match *self.token {\n+                        token::MOD_SEP => false,\n                         token::IDENT(copy sid, _) => {\n                             match *self.id_to_str(sid) {\n                                 ~\"send\" |\n@@ -2761,27 +2761,18 @@ pub impl Parser {\n                                     self.obsolete(\n                                         *self.span,\n                                         ObsoleteLowerCaseKindBounds);\n-\n-                                    // Bogus value, but doesn't matter, since\n-                                    // is an error\n-                                    Some(TraitTyParamBound(\n-                                        self.mk_ty_path(sid)))\n+                                    self.bump();\n+                                    true\n                                 }\n-                                _ => None\n+                                _ => false\n                             }\n                         }\n                         _ => fail!()\n                     };\n \n-                    match maybe_bound {\n-                        Some(bound) => {\n-                            self.bump();\n-                            result.push(bound);\n-                        }\n-                        None => {\n-                            let ty = self.parse_ty(true);\n-                            result.push(TraitTyParamBound(ty));\n-                        }\n+                    if !obsolete_bound {\n+                        let tref = self.parse_trait_ref();\n+                        result.push(TraitTyParamBound(tref));\n                     }\n                 }\n                 _ => break,"}, {"sha": "20fc99baf217904d9c17b45252f10244f449310e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -562,7 +562,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n \n         match opt_trait {\n             Some(t) => {\n-                print_path(s, t.path, false);\n+                print_trait_ref(s, t);\n                 space(s.s);\n                 word_space(s, ~\"for\");\n             }\n@@ -619,6 +619,10 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n     (s.ann.post)(ann_node);\n }\n \n+fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n+    print_path(s, t.path, false);\n+}\n+\n pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n                       generics: &ast::Generics, ident: ast::ident,\n                       span: codemap::span, visibility: ast::visibility) {\n@@ -1744,7 +1748,7 @@ pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n             }\n \n             match *bound {\n-                TraitTyParamBound(ty) => print_type(s, ty),\n+                TraitTyParamBound(tref) => print_trait_ref(s, tref),\n                 RegionTyParamBound => word(s.s, ~\"'static\"),\n             }\n         }"}, {"sha": "b20c5eeee1f04e82ccd6d459e0f5e7df767d444f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -147,6 +147,10 @@ pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     }\n }\n \n+fn visit_trait_ref<E>(tref: @ast::trait_ref, e: E, v: vt<E>) {\n+    visit_path(tref.path, e, v);\n+}\n+\n pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n         item_const(t, ex) => {\n@@ -189,9 +193,9 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         }\n         item_impl(ref tps, ref traits, ty, ref methods) => {\n             (v.visit_generics)(tps, e, v);\n-            for traits.each |p| {\n-                visit_path(p.path, e, v);\n-        }\n+            for traits.each |&p| {\n+                visit_trait_ref(p, e, v);\n+            }\n             (v.visit_ty)(ty, e, v);\n             for methods.each |m| {\n                 visit_method_helper(*m, e, v)\n@@ -327,8 +331,8 @@ pub fn visit_ty_param_bounds<E>(bounds: @OptVec<TyParamBound>,\n                                 e: E, v: vt<E>) {\n     for bounds.each |bound| {\n         match *bound {\n-            TraitTyParamBound(ty) => (v.visit_ty)(ty, e, v),\n-            RegionTyParamBound => ()\n+            TraitTyParamBound(ty) => visit_trait_ref(ty, e, v),\n+            RegionTyParamBound => {}\n         }\n     }\n }"}, {"sha": "32723cf31bc6ff6a7c59dfb7b856caecd1829a2b", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -314,7 +314,7 @@ void update_log_settings(void* crate_map, char* settings) {\n                      n_dirs, &n_matches);\n \n     if (n_matches < n_dirs) {\n-        // NOTE: Android compiler is complaining about format specifiers here\n+        // NB: Android compiler is complaining about format specifiers here\n         // and I don't understand why\n         /*printf(\"warning: got %\" PRIdPTR \" RUST_LOG specs, \"\n                \"enabled %\" PRIdPTR \" flags.\","}, {"sha": "58649f3209bb1cb4e7f0abd494e51582ee3476cb", "filename": "src/test/compile-fail/extern-no-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:expected function or foreign function but found `*u8`\n+// error-pattern:expected function but found `*u8`\n extern fn f() {\n }\n "}, {"sha": "6152e82294d1b51f9d0d4faa28506f0cf48117ae", "filename": "src/test/compile-fail/issue-2330.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -15,7 +15,7 @@ trait channel<T> {\n }\n \n // `chan` is not a trait, it's an enum\n-impl chan for int { //~ ERROR can only implement trait types\n+impl chan for int { //~ ERROR chan is not a trait\n     fn send(&self, v: int) { fail!() }\n }\n "}, {"sha": "d56cb0d51d234e962e1cb5c7dbb3e3c830acb8b4", "filename": "src/test/compile-fail/issue-3563.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -10,7 +10,7 @@\n \n trait A {\n   fn a(&self) {\n-      || self.b() //~ ERROR type `&'self self` does not implement any method in scope named `b`\n+      || self.b() //~ ERROR type `&'self Self` does not implement any method in scope named `b`\n   }\n }\n fn main() {}"}, {"sha": "220573660c5b08dca07205b2d8f4c6f3283db891", "filename": "src/test/compile-fail/selftype-traittype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -12,7 +12,7 @@ trait add {\n     fn plus(&self, x: Self) -> Self;\n }\n \n-fn do_add(x: add, y: add) -> add {\n+fn do_add(x: @add, y: @add) -> @add {\n     x.plus(y) //~ ERROR cannot call a method whose type contains a self-type through a boxed trait\n }\n "}, {"sha": "7c2f8cf98cb8a297f0f5906ae012b7b911d8a984", "filename": "src/test/run-pass/issue-3702.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3702.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -13,7 +13,7 @@ pub fn main() {\n     fn to_str(&self) -> ~str;\n   }\n \n-  fn to_string(t: Text) {\n+  fn to_string(t: @Text) {\n     io::println(t.to_str());\n   }\n "}, {"sha": "a27599e6ed00afc66534d747202a60427b38d7a7", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -417,9 +417,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_trait(&self) -> bool {\n-        self.align_to::<TyVisitor>();\n+        self.align_to::<@TyVisitor>();\n         if ! self.inner.visit_trait() { return false; }\n-        self.bump_past::<TyVisitor>();\n+        self.bump_past::<@TyVisitor>();\n         true\n     }\n "}, {"sha": "174b9a206ccdf2488382c42e3917166661972f2f", "filename": "src/test/run-pass/regions-expl-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Frun-pass%2Fregions-expl-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2cf846aebf5a9f5e53881814976a3beee89a7/src%2Ftest%2Frun-pass%2Fregions-expl-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-expl-self.rs?ref=08e2cf846aebf5a9f5e53881814976a3beee89a7", "patch": "@@ -15,7 +15,7 @@ struct Foo {\n }\n \n pub impl Foo {\n-    fn foo(&'a self) {}\n+    fn foo<'a>(&'a self) {}\n }\n \n pub fn main() {}\n\\ No newline at end of file"}]}