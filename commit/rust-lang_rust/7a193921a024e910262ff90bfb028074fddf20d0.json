{"sha": "7a193921a024e910262ff90bfb028074fddf20d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMTkzOTIxYTAyNGU5MTAyNjJmZjkwYmZiMDI4MDc0ZmRkZjIwZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-10T05:15:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-10T05:15:01Z"}, "message": "Auto merge of #77862 - danielhenrymantilla:rustdoc/fix-macros_2_0-paths, r=jyn514,petrochenkov\n\nRustdoc: Fix macros 2.0 and built-in derives being shown at the wrong path\n\nFixes #74355\n\n  - ~~waiting on author + draft PR since my code ought to be cleaned up _w.r.t._ the way I avoid the `.unwrap()`s:~~\n\n      - ~~dummy items may avoid the first `?`,~~\n\n      - ~~but within the module traversal some tests did fail (hence the second `?`), meaning the crate did not possess the exact path of the containing module (`extern` / `impl` blocks maybe? I'll look into that).~~\n\nr? `@jyn514`", "tree": {"sha": "4bed9c42ed5cfc1595324dca26bcd937ac1a57d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bed9c42ed5cfc1595324dca26bcd937ac1a57d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a193921a024e910262ff90bfb028074fddf20d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a193921a024e910262ff90bfb028074fddf20d0", "html_url": "https://github.com/rust-lang/rust/commit/7a193921a024e910262ff90bfb028074fddf20d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a193921a024e910262ff90bfb028074fddf20d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cf205610e1310897f43b35713a42459e8b40c64", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf205610e1310897f43b35713a42459e8b40c64", "html_url": "https://github.com/rust-lang/rust/commit/7cf205610e1310897f43b35713a42459e8b40c64"}, {"sha": "bceb1737ed2ba6dbf8e294519011f0e4e264b7a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bceb1737ed2ba6dbf8e294519011f0e4e264b7a3", "html_url": "https://github.com/rust-lang/rust/commit/bceb1737ed2ba6dbf8e294519011f0e4e264b7a3"}], "stats": {"total": 176, "additions": 163, "deletions": 13}, "files": [{"sha": "c2db2c82fa1c40b60d2d6c480402bf8056261cca", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a193921a024e910262ff90bfb028074fddf20d0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a193921a024e910262ff90bfb028074fddf20d0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=7a193921a024e910262ff90bfb028074fddf20d0", "patch": "@@ -832,10 +832,15 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n+        // Non-opaque macros cannot make other items more accessible than they already are.\n         if attr::find_transparency(&self.tcx.sess, &md.attrs, md.ast.macro_rules).0\n             != Transparency::Opaque\n         {\n-            self.update(md.hir_id, Some(AccessLevel::Public));\n+            // `#[macro_export]`-ed `macro_rules!` are `Public` since they\n+            // ignore their containing path to always appear at the crate root.\n+            if md.ast.macro_rules {\n+                self.update(md.hir_id, Some(AccessLevel::Public));\n+            }\n             return;\n         }\n "}, {"sha": "26302d0ecf2b15507568c8b2378d6426a25e6a02", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a193921a024e910262ff90bfb028074fddf20d0/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a193921a024e910262ff90bfb028074fddf20d0/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=7a193921a024e910262ff90bfb028074fddf20d0", "patch": "@@ -41,17 +41,17 @@ pub use crate::result::Result::{self, Err, Ok};\n pub use core::prelude::v1::{\n     asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n     format_args_nl, global_asm, include, include_bytes, include_str, line, llvm_asm, log_syntax,\n-    module_path, option_env, stringify, trace_macros,\n+    module_path, option_env, stringify, trace_macros, Clone, Copy, Debug, Default, Eq, Hash, Ord,\n+    PartialEq, PartialOrd,\n };\n \n-// FIXME: Attribute and derive macros are not documented because for them rustdoc generates\n+// FIXME: Attribute and internal derive macros are not documented because for them rustdoc generates\n // dead links which fail link checker testing.\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n #[doc(hidden)]\n pub use core::prelude::v1::{\n-    bench, global_allocator, test, test_case, Clone, Copy, Debug, Default, Eq, Hash, Ord,\n-    PartialEq, PartialOrd, RustcDecodable, RustcEncodable,\n+    bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n };\n \n #[unstable("}, {"sha": "ee45f74666a54e4f22bad635f08a17dd3cd3730f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a193921a024e910262ff90bfb028074fddf20d0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a193921a024e910262ff90bfb028074fddf20d0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7a193921a024e910262ff90bfb028074fddf20d0", "patch": "@@ -169,7 +169,17 @@ crate fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKin\n         if !s.is_empty() { Some(s) } else { None }\n     });\n     let fqn = if let clean::TypeKind::Macro = kind {\n-        vec![crate_name, relative.last().expect(\"relative was empty\")]\n+        // Check to see if it is a macro 2.0 or built-in macro\n+        if matches!(\n+            cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())),\n+            LoadedMacro::MacroDef(def, _)\n+                if matches!(&def.kind, ast::ItemKind::MacroDef(ast_def)\n+                    if !ast_def.macro_rules)\n+        ) {\n+            once(crate_name).chain(relative).collect()\n+        } else {\n+            vec![crate_name, relative.last().expect(\"relative was empty\")]\n+        }\n     } else {\n         once(crate_name).chain(relative).collect()\n     };"}, {"sha": "1fedd26a1ef2f125e01e282b35027eaee9b31d8f", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7a193921a024e910262ff90bfb028074fddf20d0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a193921a024e910262ff90bfb028074fddf20d0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7a193921a024e910262ff90bfb028074fddf20d0", "patch": "@@ -61,20 +61,60 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     crate fn visit(mut self, krate: &'tcx hir::Crate<'_>) -> Module<'tcx> {\n-        let mut module = self.visit_mod_contents(\n+        let mut top_level_module = self.visit_mod_contents(\n             krate.item.span,\n             &Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Public },\n             hir::CRATE_HIR_ID,\n             &krate.item.module,\n             None,\n         );\n-        // Attach the crate's exported macros to the top-level module:\n-        module.macros.extend(krate.exported_macros.iter().map(|def| (def, None)));\n-        module.is_crate = true;\n-\n+        top_level_module.is_crate = true;\n+        // Attach the crate's exported macros to the top-level module.\n+        // In the case of macros 2.0 (`pub macro`), and for built-in `derive`s or attributes as\n+        // well (_e.g._, `Copy`), these are wrongly bundled in there too, so we need to fix that by\n+        // moving them back to their correct locations.\n+        'exported_macros: for def in krate.exported_macros {\n+            // The `def` of a macro in `exported_macros` should correspond to either:\n+            //  - a `#[macro_export] macro_rules!` macro,\n+            //  - a built-in `derive` (or attribute) macro such as the ones in `::core`,\n+            //  - a `pub macro`.\n+            // Only the last two need to be fixed, thus:\n+            if def.ast.macro_rules {\n+                top_level_module.macros.push((def, None));\n+                continue 'exported_macros;\n+            }\n+            let tcx = self.cx.tcx;\n+            // Note: this is not the same as `.parent_module()`. Indeed, the latter looks\n+            // for the closest module _ancestor_, which is not necessarily a direct parent\n+            // (since a direct parent isn't necessarily a module, c.f. #77828).\n+            let macro_parent_def_id = {\n+                use rustc_middle::ty::DefIdTree;\n+                tcx.parent(tcx.hir().local_def_id(def.hir_id).to_def_id()).unwrap()\n+            };\n+            let macro_parent_path = tcx.def_path(macro_parent_def_id);\n+            // HACK: rustdoc has no way to lookup `doctree::Module`s by their HirId. Instead,\n+            // lookup the module by its name, by looking at each path segment one at a time.\n+            let mut cur_mod = &mut top_level_module;\n+            for path_segment in macro_parent_path.data {\n+                // Path segments may refer to a module (in which case they belong to the type\n+                // namespace), which is _necessary_ for the macro to be accessible outside it\n+                // (no \"associated macros\" as of yet). Else we bail with an outer `continue`.\n+                let path_segment_ty_ns = match path_segment.data {\n+                    rustc_hir::definitions::DefPathData::TypeNs(symbol) => symbol,\n+                    _ => continue 'exported_macros,\n+                };\n+                // Descend into the child module that matches this path segment (if any).\n+                match cur_mod.mods.iter_mut().find(|child| child.name == Some(path_segment_ty_ns)) {\n+                    Some(child_mod) => cur_mod = &mut *child_mod,\n+                    None => continue 'exported_macros,\n+                }\n+            }\n+            let cur_mod_def_id = tcx.hir().local_def_id(cur_mod.id).to_def_id();\n+            assert_eq!(cur_mod_def_id, macro_parent_def_id);\n+            cur_mod.macros.push((def, None));\n+        }\n         self.cx.renderinfo.get_mut().exact_paths = self.exact_paths;\n-\n-        module\n+        top_level_module\n     }\n \n     fn visit_mod_contents("}, {"sha": "137b12386007cb6a24e8c319d41d29ef5f8834ad", "filename": "src/test/rustdoc/auxiliary/macro_pub_in_module.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a193921a024e910262ff90bfb028074fddf20d0/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmacro_pub_in_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a193921a024e910262ff90bfb028074fddf20d0/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmacro_pub_in_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmacro_pub_in_module.rs?ref=7a193921a024e910262ff90bfb028074fddf20d0", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+\n+#![feature(decl_macro)]\n+#![crate_name = \"external_crate\"]\n+\n+pub mod some_module {\n+    /* == Make sure the logic is not affected by a re-export == */\n+    mod private {\n+        pub macro external_macro() {}\n+    }\n+\n+    pub use private::external_macro;\n+}"}, {"sha": "4fd85d68994019602ff49ac54420d8d4512e39ad", "filename": "src/test/rustdoc/macro_pub_in_module.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7a193921a024e910262ff90bfb028074fddf20d0/src%2Ftest%2Frustdoc%2Fmacro_pub_in_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a193921a024e910262ff90bfb028074fddf20d0/src%2Ftest%2Frustdoc%2Fmacro_pub_in_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro_pub_in_module.rs?ref=7a193921a024e910262ff90bfb028074fddf20d0", "patch": "@@ -0,0 +1,82 @@\n+// aux-build:macro_pub_in_module.rs\n+// edition:2018\n+// build-aux-docs\n+\n+//! See issue #74355\n+#![feature(decl_macro, no_core, rustc_attrs)]\n+#![crate_name = \"krate\"]\n+#![no_core]\n+\n+ // @has external_crate/some_module/macro.external_macro.html\n+  // @!has external_crate/macro.external_macro.html\n+extern crate external_crate;\n+\n+pub mod inner {\n+    // @has krate/inner/macro.raw_const.html\n+    // @!has krate/macro.raw_const.html\n+    pub macro raw_const() {}\n+\n+    // @has krate/inner/macro.test.html\n+    // @!has krate/macro.test.html\n+    #[rustc_builtin_macro]\n+    pub macro test($item:item) {}\n+\n+    // @has krate/inner/macro.Clone.html\n+    // @!has krate/macro.Clone.html\n+    #[rustc_builtin_macro]\n+    pub macro Clone($item:item) {}\n+\n+    // Make sure the logic is not affected by re-exports.\n+    mod unrenamed {\n+        // @!has krate/macro.unrenamed.html\n+        #[rustc_macro_transparency = \"semitransparent\"]\n+        pub macro unrenamed() {}\n+    }\n+    // @has krate/inner/macro.unrenamed.html\n+    pub use unrenamed::unrenamed;\n+\n+    mod private {\n+        // @!has krate/macro.m.html\n+        pub macro m() {}\n+    }\n+    // @has krate/inner/macro.renamed.html\n+    // @!has krate/macro.renamed.html\n+    pub use private::m as renamed;\n+\n+    mod private2 {\n+        // @!has krate/macro.m2.html\n+        pub macro m2() {}\n+    }\n+    use private2 as renamed_mod;\n+    // @has krate/inner/macro.m2.html\n+    pub use renamed_mod::m2;\n+\n+    // @has krate/inner/macro.external_macro.html\n+    // @!has krate/macro.external_macro.html\n+    pub use ::external_crate::some_module::external_macro;\n+}\n+\n+// Namespaces: Make sure the logic does not mix up a function name with a module name\u2026\n+fn both_fn_and_mod() {\n+    // @!has krate/macro.in_both_fn_and_mod.html\n+    pub macro in_both_fn_and_mod() {}\n+}\n+pub mod both_fn_and_mod {\n+    // @!has krate/both_fn_and_mod/macro.in_both_fn_and_mod.html\n+}\n+\n+const __: () = {\n+    // @!has krate/macro.in_both_const_and_mod.html\n+    pub macro in_both_const_and_mod() {}\n+};\n+pub mod __ {\n+    // @!has krate/__/macro.in_both_const_and_mod.html\n+}\n+\n+enum Enum {\n+    Crazy = {\n+        // @!has krate/macro.this_is_getting_weird.html;\n+        pub macro this_is_getting_weird() {}\n+        42\n+    },\n+}"}]}