{"sha": "5eb1ab5265402cf0a40b71a5236cfe6289e7647d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYjFhYjUyNjU0MDJjZjBhNDBiNzFhNTIzNmNmZTYyODllNzY0N2Q=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2019-02-21T16:58:40Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2019-02-28T22:11:21Z"}, "message": "print doc coverage as a table of individual item types", "tree": {"sha": "376a1ca8f36d773de030f5ccc36f4dbe431af700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/376a1ca8f36d773de030f5ccc36f4dbe431af700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eb1ab5265402cf0a40b71a5236cfe6289e7647d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eb1ab5265402cf0a40b71a5236cfe6289e7647d", "html_url": "https://github.com/rust-lang/rust/commit/5eb1ab5265402cf0a40b71a5236cfe6289e7647d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eb1ab5265402cf0a40b71a5236cfe6289e7647d/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95500c078bec0082fe0e4f3e20d962d436a0e099", "url": "https://api.github.com/repos/rust-lang/rust/commits/95500c078bec0082fe0e4f3e20d962d436a0e099", "html_url": "https://github.com/rust-lang/rust/commit/95500c078bec0082fe0e4f3e20d962d436a0e099"}], "stats": {"total": 208, "additions": 166, "deletions": 42}, "files": [{"sha": "366e60b3ad9206e89282d7806dfcd69ee3cc7852", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eb1ab5265402cf0a40b71a5236cfe6289e7647d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb1ab5265402cf0a40b71a5236cfe6289e7647d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=5eb1ab5265402cf0a40b71a5236cfe6289e7647d", "patch": "@@ -15,7 +15,7 @@ use crate::clean;\n /// module headings. If you are adding to this enum and want to ensure that the sidebar also prints\n /// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n /// ordering based on a helper function inside `item_module`, in the same file.\n-#[derive(Copy, PartialEq, Clone, Debug)]\n+#[derive(Copy, PartialEq, Eq, Clone, Debug, PartialOrd, Ord)]\n pub enum ItemType {\n     Module          = 0,\n     ExternCrate     = 1,"}, {"sha": "06f9a604ec83f32adfe98ef3f0a3881a9eacf4dc", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 165, "deletions": 41, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/5eb1ab5265402cf0a40b71a5236cfe6289e7647d/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb1ab5265402cf0a40b71a5236cfe6289e7647d/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=5eb1ab5265402cf0a40b71a5236cfe6289e7647d", "patch": "@@ -1,12 +1,14 @@\n use crate::clean;\n use crate::core::DocContext;\n+use crate::html::item_type::ItemType;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n \n use syntax::attr;\n \n-use std::ops::Sub;\n+use std::collections::BTreeMap;\n use std::fmt;\n+use std::ops;\n \n pub const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     name: \"calculate-doc-coverage\",\n@@ -18,17 +20,7 @@ fn calculate_doc_coverage(krate: clean::Crate, _: &DocContext<'_, '_, '_>) -> cl\n     let mut calc = CoverageCalculator::default();\n     let krate = calc.fold_crate(krate);\n \n-    let non_traits = calc.items - calc.trait_impl_items;\n-\n-    print!(\"Rustdoc found {} items with documentation\", calc.items);\n-    println!(\" ({} not counting trait impls)\", non_traits);\n-\n-    if let (Some(percentage), Some(percentage_non_traits)) =\n-        (calc.items.percentage(), non_traits.percentage())\n-    {\n-        println!(\"    Score: {:.1}% ({:.1}% not counting trait impls)\",\n-                 percentage, percentage_non_traits);\n-    }\n+    calc.print_results();\n \n     krate\n }\n@@ -57,7 +49,7 @@ impl ItemCount {\n     }\n }\n \n-impl Sub for ItemCount {\n+impl ops::Sub for ItemCount {\n     type Output = Self;\n \n     fn sub(self, rhs: Self) -> Self {\n@@ -68,6 +60,13 @@ impl Sub for ItemCount {\n     }\n }\n \n+impl ops::AddAssign for ItemCount {\n+    fn add_assign(&mut self, rhs: Self) {\n+        self.total += rhs.total;\n+        self.with_docs += rhs.with_docs;\n+    }\n+}\n+\n impl fmt::Display for ItemCount {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}/{}\", self.with_docs, self.total)\n@@ -76,58 +75,183 @@ impl fmt::Display for ItemCount {\n \n #[derive(Default)]\n struct CoverageCalculator {\n-    items: ItemCount,\n-    trait_impl_items: ItemCount,\n+    items: BTreeMap<ItemType, ItemCount>,\n+}\n+\n+impl CoverageCalculator {\n+    fn print_results(&self) {\n+        use crate::html::item_type::ItemType::*;\n+\n+        let mut total = ItemCount::default();\n+\n+        let main_types = [\n+            Module, Function,\n+            Struct, StructField,\n+            Enum, Variant,\n+            Union,\n+            Method,\n+            Trait, TyMethod,\n+            AssociatedType, AssociatedConst,\n+            Macro,\n+            Static, Constant,\n+            ForeignType, Existential,\n+            Typedef, TraitAlias,\n+            Primitive, Keyword,\n+        ];\n+\n+        println!(\"+-{0:->25}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n+        println!(\"| {:<25} | {:>10} | {:>10} | {:>10} |\",\n+                 \"Item Type\", \"Documented\", \"Total\", \"Percentage\");\n+        println!(\"+-{0:->25}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n+\n+        for item_type in &main_types {\n+            let count = self.items.get(item_type).cloned().unwrap_or_default();\n+\n+            if let Some(percentage) = count.percentage() {\n+                println!(\"| {:<25} | {:>10} | {:>10} | {:>9.1}% |\",\n+                         table_name(item_type), count.with_docs, count.total, percentage);\n+\n+                total += count;\n+            }\n+        }\n+\n+        println!(\"+-{0:->25}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n+\n+        if let Some(count) = self.items.get(&Impl) {\n+            if let Some(percentage) = count.percentage() {\n+                if let Some(percentage) = total.percentage() {\n+                    println!(\"| {:<25} | {:>10} | {:>10} | {:>9.1}% |\",\n+                             \"Total (non trait impls)\", total.with_docs, total.total, percentage);\n+                }\n+\n+                println!(\"+-{0:->25}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n+\n+                println!(\"| {:<25} | {:>10} | {:>10} | {:>9.1}% |\",\n+                         table_name(&Impl), count.with_docs, count.total, percentage);\n+\n+                println!(\"+-{0:->25}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n+\n+                total += *count;\n+            }\n+        }\n+\n+        println!(\"| {:<25} | {:>10} | {:>10} | {:>9.1}% |\",\n+                 \"Total\", total.with_docs, total.total, total.percentage().unwrap_or(0.0));\n+        println!(\"+-{0:->25}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n+    }\n }\n \n impl fold::DocFolder for CoverageCalculator {\n-    fn fold_item(&mut self, i: clean::Item) -> Option<clean::Item> {\n+    fn fold_item(&mut self, mut i: clean::Item) -> Option<clean::Item> {\n+        let has_docs = !i.attrs.doc_strings.is_empty();\n+\n         match i.inner {\n+            _ if !i.def_id.is_local() => {\n+                // non-local items are skipped because they can be out of the users control,\n+                // especially in the case of trait impls, which rustdoc eagerly inlines\n+                return Some(i);\n+            }\n             clean::StrippedItem(..) => {\n                 // don't count items in stripped modules\n                 return Some(i);\n             }\n-            clean::ImportItem(..) | clean::ExternCrateItem(..) => {}\n+            clean::ImportItem(..) | clean::ExternCrateItem(..) => {\n+                // docs on `use` and `extern crate` statements are not displayed, so they're not\n+                // worth counting\n+                return Some(i);\n+            }\n             clean::ImplItem(ref impl_)\n                 if attr::contains_name(&i.attrs.other_attrs, \"automatically_derived\")\n                     || impl_.synthetic || impl_.blanket_impl.is_some() =>\n             {\n-                // skip counting anything inside these impl blocks\n+                // built-in derives get the `#[automatically_derived]` attribute, and\n+                // synthetic/blanket impls are made up by rustdoc and can't be documented\n                 // FIXME(misdreavus): need to also find items that came out of a derive macro\n                 return Some(i);\n             }\n-            // non-local items are skipped because they can be out of the users control, especially\n-            // in the case of trait impls, which rustdoc eagerly inlines\n-            _ => if i.def_id.is_local() {\n-                let has_docs = !i.attrs.doc_strings.is_empty();\n-\n-                if let clean::ImplItem(ref i) = i.inner {\n-                    if let Some(ref tr) = i.trait_ {\n-                        debug!(\"counting impl {:#} for {:#}\", tr, i.for_);\n+            clean::ImplItem(ref impl_) => {\n+                if let Some(ref tr) = impl_.trait_ {\n+                    debug!(\"counting impl {:#} for {:#}\", tr, impl_.for_);\n \n-                        self.items.count_item(has_docs);\n+                    // trait impls inherit their docs from the trait definition, so documenting\n+                    // them can be considered optional\n+                    self.items.entry(ItemType::Impl).or_default().count_item(has_docs);\n \n-                        // trait impls inherit their docs from the trait definition, so documenting\n-                        // them can be considered optional\n+                    for it in &impl_.items {\n+                        let has_docs = !it.attrs.doc_strings.is_empty();\n+                        self.items.entry(ItemType::Impl).or_default().count_item(has_docs);\n+                    }\n \n-                        self.trait_impl_items.count_item(has_docs);\n+                    // now skip recursing, so that we don't double-count this impl's items\n+                    return Some(i);\n+                } else {\n+                    // inherent impls *can* be documented, and those docs show up, but in most\n+                    // cases it doesn't make sense, as all methods on a type are in one single\n+                    // impl block\n+                    debug!(\"not counting impl {:#}\", impl_.for_);\n+                }\n+            }\n+            clean::MacroItem(..) | clean::ProcMacroItem(..) => {\n+                // combine `macro_rules!` macros and proc-macros in the same count\n+                debug!(\"counting macro {:?}\", i.name);\n+                self.items.entry(ItemType::Macro).or_default().count_item(has_docs);\n+            }\n+            clean::TraitItem(ref mut trait_) => {\n+                // because both trait methods with a default impl and struct methods are\n+                // ItemType::Method, we need to properly tag trait methods as TyMethod instead\n+                debug!(\"counting trait {:?}\", i.name);\n+                self.items.entry(ItemType::Trait).or_default().count_item(has_docs);\n \n-                        for it in &i.items {\n-                            self.trait_impl_items.count_item(!it.attrs.doc_strings.is_empty());\n-                        }\n+                // since we're not going on to document the crate, it doesn't matter if we discard\n+                // the item after counting it\n+                trait_.items.retain(|it| {\n+                    if it.type_() == ItemType::Method {\n+                        let has_docs = !it.attrs.doc_strings.is_empty();\n+                        self.items.entry(ItemType::TyMethod).or_default().count_item(has_docs);\n+                        false\n                     } else {\n-                        // inherent impls *can* be documented, and those docs show up, but in most\n-                        // cases it doesn't make sense, as all methods on a type are in one single\n-                        // impl block\n-                        debug!(\"not counting impl {:#}\", i.for_);\n+                        true\n                     }\n-                } else {\n-                    debug!(\"counting {} {:?}\", i.type_(), i.name);\n-                    self.items.count_item(has_docs);\n-                }\n+                });\n+            }\n+            _ => {\n+                debug!(\"counting {} {:?}\", i.type_(), i.name);\n+                self.items.entry(i.type_()).or_default().count_item(has_docs);\n             }\n         }\n \n         self.fold_item_recur(i)\n     }\n }\n+\n+fn table_name(type_: &ItemType) -> &'static str {\n+        match *type_ {\n+            ItemType::Module          => \"Modules\",\n+            ItemType::Struct          => \"Structs\",\n+            ItemType::Union           => \"Unions\",\n+            ItemType::Enum            => \"Enums\",\n+            ItemType::Function        => \"Functions\",\n+            ItemType::Typedef         => \"Type Aliases\",\n+            ItemType::Static          => \"Statics\",\n+            ItemType::Trait           => \"Traits\",\n+            // inherent impls aren't counted, and trait impls get all their items thrown into this\n+            // counter\n+            ItemType::Impl            => \"Trait Impl Items\",\n+            // even though trait methods with a default impl get cleaned as Method, we convert them\n+            // to TyMethod when counting\n+            ItemType::TyMethod        => \"Trait Methods\",\n+            ItemType::Method          => \"Methods\",\n+            ItemType::StructField     => \"Struct Fields\",\n+            ItemType::Variant         => \"Enum Variants\",\n+            ItemType::Macro           => \"Macros\",\n+            ItemType::Primitive       => \"Primitives\",\n+            ItemType::AssociatedType  => \"Associated Types\",\n+            ItemType::Constant        => \"Constants\",\n+            ItemType::AssociatedConst => \"Associated Constants\",\n+            ItemType::ForeignType     => \"Foreign Types\",\n+            ItemType::Keyword         => \"Keywords\",\n+            ItemType::Existential     => \"Existential Types\",\n+            ItemType::TraitAlias      => \"Trait Aliases\",\n+            _                         => panic!(\"unanticipated ItemType: {}\", type_),\n+        }\n+}"}]}