{"sha": "b469bf3b08a1c7def04ed256342a68739d8dd6a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NjliZjNiMDhhMWM3ZGVmMDRlZDI1NjM0MmE2ODczOWQ4ZGQ2YTc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-03-12T10:58:59Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-03-12T10:58:59Z"}, "message": "Refactor driver/aot.rs\n\nFixes #917", "tree": {"sha": "83ee485e545bbee469777dc2559b6b064cd53314", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83ee485e545bbee469777dc2559b6b064cd53314"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b469bf3b08a1c7def04ed256342a68739d8dd6a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b469bf3b08a1c7def04ed256342a68739d8dd6a7", "html_url": "https://github.com/rust-lang/rust/commit/b469bf3b08a1c7def04ed256342a68739d8dd6a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b469bf3b08a1c7def04ed256342a68739d8dd6a7/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "933ef94f6330e77127e8756e7db82bd67d424201", "url": "https://api.github.com/repos/rust-lang/rust/commits/933ef94f6330e77127e8756e7db82bd67d424201", "html_url": "https://github.com/rust-lang/rust/commit/933ef94f6330e77127e8756e7db82bd67d424201"}], "stats": {"total": 244, "additions": 126, "deletions": 118}, "files": [{"sha": "3473b0ae40c652dc81787510d4a443127a539dba", "filename": "src/driver/aot.rs", "status": "modified", "additions": 126, "deletions": 118, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/b469bf3b08a1c7def04ed256342a68739d8dd6a7/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b469bf3b08a1c7def04ed256342a68739d8dd6a7/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=b469bf3b08a1c7def04ed256342a68739d8dd6a7", "patch": "@@ -5,77 +5,146 @@ use rustc::session::config::{DebugInfo, OutputType};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::CrateInfo;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n use crate::prelude::*;\n \n use crate::backend::{Emit, WriteDebugInfo};\n \n-pub(super) fn run_aot(\n+fn new_module(tcx: TyCtxt<'_>, name: String) -> Module<crate::backend::Backend> {\n+    let module = crate::backend::make_module(tcx.sess, name);\n+    assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n+    module\n+}\n+\n+struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+\n+\n+impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n+    fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n+        // do nothing\n+    }\n+}\n+\n+fn emit_module<B: Backend>(\n     tcx: TyCtxt<'_>,\n-    metadata: EncodedMetadata,\n-    need_metadata_module: bool,\n-) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n-    let mut work_products = FxHashMap::default();\n+    name: String,\n+    kind: ModuleKind,\n+    mut module: Module<B>,\n+    debug: Option<DebugContext>,\n+) -> ModuleCodegenResult\n+    where B::Product: Emit + WriteDebugInfo,\n+{\n+    module.finalize_definitions();\n+    let mut product = module.finish();\n+\n+    if let Some(mut debug) = debug {\n+        debug.emit(&mut product);\n+    }\n \n-    fn new_module(tcx: TyCtxt<'_>, name: String) -> Module<crate::backend::Backend> {\n-        let module = crate::backend::make_module(tcx.sess, name);\n-        assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n-        module\n-    };\n+    let tmp_file = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .temp_path(OutputType::Object, Some(&name));\n+    let obj = product.emit();\n+    std::fs::write(&tmp_file, obj).unwrap();\n \n-    struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+    let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n+        None\n+    } else {\n+        rustc_incremental::copy_cgu_workproducts_to_incr_comp_cache_dir(\n+            tcx.sess,\n+            &name,\n+            &[(WorkProductFileKind::Object, tmp_file.clone())],\n+        )\n+    };\n \n-    use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+    ModuleCodegenResult(\n+        CompiledModule {\n+            name,\n+            kind,\n+            object: Some(tmp_file),\n+            bytecode: None,\n+            bytecode_compressed: None,\n+        },\n+        work_product,\n+    )\n+}\n \n-    impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n-        fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n-            // do nothing\n+fn reuse_workproduct_for_cgu(\n+    tcx: TyCtxt<'_>,\n+    cgu: &CodegenUnit,\n+    work_products: &mut FxHashMap<WorkProductId, WorkProduct>,\n+) -> CompiledModule {\n+    let incr_comp_session_dir = tcx.sess.incr_comp_session_dir();\n+    let mut object = None;\n+    let work_product = cgu.work_product(tcx);\n+    for (kind, saved_file) in &work_product.saved_files {\n+        let obj_out = match kind {\n+            WorkProductFileKind::Object => {\n+                let path = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n+                object = Some(path.clone());\n+                path\n+            }\n+            WorkProductFileKind::Bytecode | WorkProductFileKind::BytecodeCompressed => {\n+                panic!(\"cg_clif doesn't use bytecode\");\n+            }\n+        };\n+        let source_file = rustc_incremental::in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n+        if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n+            tcx.sess.err(&format!(\n+                \"unable to copy {} to {}: {}\",\n+                source_file.display(),\n+                obj_out.display(),\n+                err\n+            ));\n         }\n     }\n \n-    fn emit_module<B: Backend>(\n-        tcx: TyCtxt<'_>,\n-        name: String,\n-        kind: ModuleKind,\n-        mut module: Module<B>,\n-        debug: Option<DebugContext>,\n-    ) -> ModuleCodegenResult\n-        where B::Product: Emit + WriteDebugInfo,\n-    {\n-            module.finalize_definitions();\n-            let mut product = module.finish();\n-\n-            if let Some(mut debug) = debug {\n-                debug.emit(&mut product);\n-            }\n+    work_products.insert(cgu.work_product_id(), work_product);\n \n-            let tmp_file = tcx\n-                .output_filenames(LOCAL_CRATE)\n-                .temp_path(OutputType::Object, Some(&name));\n-            let obj = product.emit();\n-            std::fs::write(&tmp_file, obj).unwrap();\n+    CompiledModule {\n+        name: cgu.name().to_string(),\n+        kind: ModuleKind::Regular,\n+        object,\n+        bytecode: None,\n+        bytecode_compressed: None,\n+    }\n+}\n \n-            let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n-                None\n-            } else {\n-                rustc_incremental::copy_cgu_workproducts_to_incr_comp_cache_dir(\n-                    tcx.sess,\n-                    &name,\n-                    &[(WorkProductFileKind::Object, tmp_file.clone())],\n-                )\n-            };\n-\n-            ModuleCodegenResult(\n-                CompiledModule {\n-                    name,\n-                    kind,\n-                    object: Some(tmp_file),\n-                    bytecode: None,\n-                    bytecode_compressed: None,\n-                },\n-                work_product,\n-            )\n-        };\n+fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n+    let cgu = tcx.codegen_unit(cgu_name);\n+    let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+    let mut module = new_module(tcx, cgu_name.as_str().to_string());\n+\n+    let mut debug = if tcx.sess.opts.debuginfo != DebugInfo::None {\n+        let debug = DebugContext::new(\n+            tcx,\n+            module.target_config().pointer_type().bytes() as u8,\n+        );\n+        Some(debug)\n+    } else {\n+        None\n+    };\n+\n+    super::codegen_mono_items(tcx, &mut module, debug.as_mut(), mono_items);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module);\n+\n+    emit_module(\n+        tcx,\n+        cgu.name().as_str().to_string(),\n+        ModuleKind::Regular,\n+        module,\n+        debug,\n+    )\n+}\n+\n+pub(super) fn run_aot(\n+    tcx: TyCtxt<'_>,\n+    metadata: EncodedMetadata,\n+    need_metadata_module: bool,\n+) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n+    let mut work_products = FxHashMap::default();\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n \n@@ -94,40 +163,7 @@ pub(super) fn run_aot(\n                 _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n                 CguReuse::No => {}\n                 CguReuse::PreLto => {\n-                    let incr_comp_session_dir = tcx.sess.incr_comp_session_dir();\n-                    let mut object = None;\n-                    let work_product = cgu.work_product(tcx);\n-                    for (kind, saved_file) in &work_product.saved_files {\n-                        let obj_out = match kind {\n-                            WorkProductFileKind::Object => {\n-                                let path = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n-                                object = Some(path.clone());\n-                                path\n-                            }\n-                            WorkProductFileKind::Bytecode | WorkProductFileKind::BytecodeCompressed => {\n-                                panic!(\"cg_clif doesn't use bytecode\");\n-                            }\n-                        };\n-                        let source_file = rustc_incremental::in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n-                        if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n-                            tcx.sess.err(&format!(\n-                                \"unable to copy {} to {}: {}\",\n-                                source_file.display(),\n-                                obj_out.display(),\n-                                err\n-                            ));\n-                        }\n-                    }\n-\n-                    work_products.insert(cgu.work_product_id(), work_product);\n-\n-                    return CompiledModule {\n-                        name: cgu.name().to_string(),\n-                        kind: ModuleKind::Regular,\n-                        object,\n-                        bytecode: None,\n-                        bytecode_compressed: None,\n-                    };\n+                    return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n                 }\n                 CguReuse::PostLto => unreachable!(),\n             }\n@@ -136,34 +172,6 @@ pub(super) fn run_aot(\n             let (ModuleCodegenResult(module, work_product), _) =\n                 tcx.dep_graph.with_task(dep_node, tcx, cgu.name(), module_codegen, rustc::dep_graph::hash_result);\n \n-            fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n-                let cgu = tcx.codegen_unit(cgu_name);\n-                let mono_items = cgu.items_in_deterministic_order(tcx);\n-\n-                let mut module = new_module(tcx, cgu_name.as_str().to_string());\n-\n-                let mut debug = if tcx.sess.opts.debuginfo != DebugInfo::None {\n-                    let debug = DebugContext::new(\n-                        tcx,\n-                        module.target_config().pointer_type().bytes() as u8,\n-                    );\n-                    Some(debug)\n-                } else {\n-                    None\n-                };\n-\n-                super::codegen_mono_items(tcx, &mut module, debug.as_mut(), mono_items);\n-                crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module);\n-\n-                emit_module(\n-                    tcx,\n-                    cgu.name().as_str().to_string(),\n-                    ModuleKind::Regular,\n-                    module,\n-                    debug,\n-                )\n-            }\n-\n             if let Some((id, product)) = work_product {\n                 work_products.insert(id, product);\n             }"}]}