{"sha": "5aab1a9a88dd30d622a5303f26d9ad213c551473", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYWIxYTlhODhkZDMwZDYyMmE1MzAzZjI2ZDlhZDIxM2M1NTE0NzM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-24T00:32:06Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-24T00:32:06Z"}, "message": "Tweak binop errors\n\n* Suggest potentially missing binop trait bound (fix #73416)\n* Use structured suggestion for dereference in binop", "tree": {"sha": "6c60f0643a59e6d108ea8412beb3edbe288b8846", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c60f0643a59e6d108ea8412beb3edbe288b8846"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aab1a9a88dd30d622a5303f26d9ad213c551473", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aab1a9a88dd30d622a5303f26d9ad213c551473", "html_url": "https://github.com/rust-lang/rust/commit/5aab1a9a88dd30d622a5303f26d9ad213c551473", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aab1a9a88dd30d622a5303f26d9ad213c551473/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a39c7787ba246353178e099373b9240be0d9e603", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39c7787ba246353178e099373b9240be0d9e603", "html_url": "https://github.com/rust-lang/rust/commit/a39c7787ba246353178e099373b9240be0d9e603"}], "stats": {"total": 209, "additions": 169, "deletions": 40}, "files": [{"sha": "7acf8843185733cc4b153af117b8b67f9a16f7fd", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 98, "deletions": 37, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -9,7 +9,9 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n-use rustc_middle::ty::{self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -254,6 +256,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if !lhs_ty.references_error() && !rhs_ty.references_error() {\n                     let source_map = self.tcx.sess.source_map();\n \n+                    let note = |err: &mut DiagnosticBuilder<'_>, missing_trait| {\n+                        err.note(&format!(\n+                            \"the trait `{}` is not implemented for `{}`\",\n+                            missing_trait, lhs_ty\n+                        ));\n+                    };\n                     match is_assign {\n                         IsAssign::Yes => {\n                             let mut err = struct_span_err!(\n@@ -286,10 +294,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             rty.peel_refs(),\n                                             lstring,\n                                         );\n-                                        err.span_suggestion(\n-                                            lhs_expr.span,\n+                                        err.span_suggestion_verbose(\n+                                            lhs_expr.span.shrink_to_lo(),\n                                             msg,\n-                                            format!(\"*{}\", lstring),\n+                                            \"*\".to_string(),\n                                             rustc_errors::Applicability::MachineApplicable,\n                                         );\n                                         suggested_deref = true;\n@@ -310,6 +318,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 _ => None,\n                             };\n                             if let Some(missing_trait) = missing_trait {\n+                                let mut visitor = TypeParamVisitor(vec![]);\n+                                visitor.visit_ty(lhs_ty);\n+\n+                                let mut sugg = false;\n                                 if op.node == hir::BinOpKind::Add\n                                     && self.check_str_addition(\n                                         lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, true, op,\n@@ -318,18 +330,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(p) = lhs_ty.kind {\n-                                    suggest_constraining_param(\n-                                        self.tcx,\n-                                        self.body_id,\n-                                        &mut err,\n-                                        lhs_ty,\n-                                        rhs_ty,\n-                                        missing_trait,\n-                                        p,\n-                                        false,\n-                                    );\n-                                } else if !suggested_deref {\n+                                    sugg = true;\n+                                } else if let [ty] = &visitor.0[..] {\n+                                    if let ty::Param(p) = ty.kind {\n+                                        // FIXME: This *guesses* that constraining the type param\n+                                        // will make the operation available, but this is only true\n+                                        // when the corresponding trait has a blanked\n+                                        // implementation, like the following:\n+                                        // `impl<'a> PartialEq for &'a [T] where T: PartialEq {}`\n+                                        // The correct thing to do would be to verify this\n+                                        // projection would hold.\n+                                        if *ty != lhs_ty {\n+                                            note(&mut err, missing_trait);\n+                                        }\n+                                        suggest_constraining_param(\n+                                            self.tcx,\n+                                            self.body_id,\n+                                            &mut err,\n+                                            ty,\n+                                            rhs_ty,\n+                                            missing_trait,\n+                                            p,\n+                                            false,\n+                                        );\n+                                        sugg = true;\n+                                    }\n+                                }\n+                                if !sugg && !suggested_deref {\n                                     suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n                             }\n@@ -458,18 +485,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         .is_ok()\n                                 } {\n                                     if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        err.help(&format!(\n-                                            \"`{}` can be used on '{}', you can \\\n-                                            dereference `{2}`: `*{2}`\",\n-                                            op.node.as_str(),\n-                                            rty.peel_refs(),\n-                                            lstring\n-                                        ));\n+                                        err.span_suggestion_verbose(\n+                                            lhs_expr.span.shrink_to_lo(),\n+                                            &format!(\n+                                                \"`{}` can be used on `{}`, you can dereference \\\n+                                                 `{}`\",\n+                                                op.node.as_str(),\n+                                                rty.peel_refs(),\n+                                                lstring,\n+                                            ),\n+                                            \"*\".to_string(),\n+                                            Applicability::MachineApplicable,\n+                                        );\n                                         suggested_deref = true;\n                                     }\n                                 }\n                             }\n                             if let Some(missing_trait) = missing_trait {\n+                                let mut visitor = TypeParamVisitor(vec![]);\n+                                visitor.visit_ty(lhs_ty);\n+\n+                                let mut sugg = false;\n                                 if op.node == hir::BinOpKind::Add\n                                     && self.check_str_addition(\n                                         lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, false, op,\n@@ -478,18 +514,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(p) = lhs_ty.kind {\n-                                    suggest_constraining_param(\n-                                        self.tcx,\n-                                        self.body_id,\n-                                        &mut err,\n-                                        lhs_ty,\n-                                        rhs_ty,\n-                                        missing_trait,\n-                                        p,\n-                                        use_output,\n-                                    );\n-                                } else if !suggested_deref && !involves_fn {\n+                                    sugg = true;\n+                                } else if let [ty] = &visitor.0[..] {\n+                                    if let ty::Param(p) = ty.kind {\n+                                        // FIXME: This *guesses* that constraining the type param\n+                                        // will make the operation available, but this is only true\n+                                        // when the corresponding trait has a blanked\n+                                        // implementation, like the following:\n+                                        // `impl<'a> PartialEq for &'a [T] where T: PartialEq {}`\n+                                        // The correct thing to do would be to verify this\n+                                        // projection would hold.\n+                                        if *ty != lhs_ty {\n+                                            note(&mut err, missing_trait);\n+                                        }\n+                                        suggest_constraining_param(\n+                                            self.tcx,\n+                                            self.body_id,\n+                                            &mut err,\n+                                            ty,\n+                                            rhs_ty,\n+                                            missing_trait,\n+                                            p,\n+                                            use_output,\n+                                        );\n+                                        sugg = true;\n+                                    }\n+                                }\n+                                if !sugg && !suggested_deref && !involves_fn {\n                                     suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n                             }\n@@ -928,8 +979,7 @@ fn suggest_impl_missing(err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>, missing_tra\n     if let Adt(def, _) = ty.peel_refs().kind {\n         if def.did.is_local() {\n             err.note(&format!(\n-                \"an implementation of `{}` might \\\n-                be missing for `{}`\",\n+                \"an implementation of `{}` might be missing for `{}`\",\n                 missing_trait, ty\n             ));\n         }\n@@ -975,3 +1025,14 @@ fn suggest_constraining_param(\n         err.span_label(span, msg);\n     }\n }\n+\n+struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n+\n+impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        if let ty::Param(_) = ty.kind {\n+            self.0.push(ty);\n+        }\n+        ty.super_visit_with(self)\n+    }\n+}"}, {"sha": "de9dc19af29beeb4b10fee7cfd4032fbb0cada71", "filename": "src/test/ui/binary-op-on-double-ref.fixed", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let vr = v.iter().filter(|x| {\n+        *x % 2 == 0\n+        //~^ ERROR cannot mod `&&{integer}` by `{integer}`\n+    });\n+    println!(\"{:?}\", vr);\n+}"}, {"sha": "2616c560cbefb6c320808d9086976a0b65ac570e", "filename": "src/test/ui/binary-op-on-double-ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n fn main() {\n     let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let vr = v.iter().filter(|x| {"}, {"sha": "02b0488488c555154537ef7829870465590c6071", "filename": "src/test/ui/binary-op-on-double-ref.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -1,12 +1,15 @@\n error[E0369]: cannot mod `&&{integer}` by `{integer}`\n-  --> $DIR/binary-op-on-double-ref.rs:4:11\n+  --> $DIR/binary-op-on-double-ref.rs:5:11\n    |\n LL |         x % 2 == 0\n    |         - ^ - {integer}\n    |         |\n    |         &&{integer}\n    |\n-   = help: `%` can be used on '{integer}', you can dereference `x`: `*x`\n+help: `%` can be used on `{integer}`, you can dereference `x`\n+   |\n+LL |         *x % 2 == 0\n+   |         ^\n \n error: aborting due to previous error\n "}, {"sha": "c8f1f88a4708e2dd6f1da291fd14ab9eacf2343f", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -5,6 +5,12 @@ LL |     a.iter().map(|a| a*a)\n    |                      -^- &T\n    |                      |\n    |                      &T\n+   |\n+   = note: the trait `std::ops::Mul` is not implemented for `&T`\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn func<'a, T: std::ops::Mul<Output = &T>>(a: &'a [T]) -> impl Iterator<Item=&'a T> {\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d0c71e73463c153b30a429f7add5889fc774b006", "filename": "src/test/ui/issues/issue-5239-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -9,7 +9,7 @@ LL |     let x = |ref x: isize| { x += 1; };\n help: `+=` can be used on 'isize', you can dereference `x`\n    |\n LL |     let x = |ref x: isize| { *x += 1; };\n-   |                              ^^\n+   |                              ^\n \n error: aborting due to previous error\n "}, {"sha": "02886bb845cf7afafdd82105a8bcf7b152e1aca6", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+\n+pub fn strip_prefix<'a, T: std::cmp::PartialEq>(s: &'a [T], prefix: &[T]) -> Option<&'a [T]> {\n+    let n = prefix.len();\n+    if n <= s.len() {\n+        let (head, tail) = s.split_at(n);\n+        if head == prefix { //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n+            return Some(tail);\n+        }\n+    }\n+    None\n+}\n+fn main() {}"}, {"sha": "aa4ef467360d9a30fb3e9690283409499495f642", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+\n+pub fn strip_prefix<'a, T>(s: &'a [T], prefix: &[T]) -> Option<&'a [T]> {\n+    let n = prefix.len();\n+    if n <= s.len() {\n+        let (head, tail) = s.split_at(n);\n+        if head == prefix { //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n+            return Some(tail);\n+        }\n+    }\n+    None\n+}\n+fn main() {}"}, {"sha": "dab4e575be1fa595fa1b3f1e15c24090d532505e", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -0,0 +1,17 @@\n+error[E0369]: binary operation `==` cannot be applied to type `&[T]`\n+  --> $DIR/missing-trait-bound-for-op.rs:7:17\n+   |\n+LL |         if head == prefix {\n+   |            ---- ^^ ------ &[T]\n+   |            |\n+   |            &[T]\n+   |\n+   = note: the trait `std::cmp::PartialEq` is not implemented for `&[T]`\n+help: consider restricting type parameter `T`\n+   |\n+LL | pub fn strip_prefix<'a, T: std::cmp::PartialEq>(s: &'a [T], prefix: &[T]) -> Option<&'a [T]> {\n+   |                          ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "1c424ce7da6695acf793cb55ec2a35505edc5015", "filename": "src/test/ui/traits/trait-resolution-in-overloaded-op.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aab1a9a88dd30d622a5303f26d9ad213c551473/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr?ref=5aab1a9a88dd30d622a5303f26d9ad213c551473", "patch": "@@ -5,6 +5,12 @@ LL |     a * b\n    |     - ^ - f64\n    |     |\n    |     &T\n+   |\n+   = note: the trait `std::ops::Mul` is not implemented for `&T`\n+help: consider further restricting this bound\n+   |\n+LL | fn foo<T: MyMul<f64, f64> + std::ops::Mul<Output = f64>>(a: &T, b: f64) -> f64 {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}