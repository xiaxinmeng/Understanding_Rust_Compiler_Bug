{"sha": "eef546abb6ce8f153dd517db52fbc6c955f631dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZjU0NmFiYjZjZThmMTUzZGQ1MTdkYjUyZmJjNmM5NTVmNjMxZGM=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-28T04:45:30Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-29T03:27:27Z"}, "message": "addressed review feedback", "tree": {"sha": "f2b95d2038a25b334aca00331bbca51536469cea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b95d2038a25b334aca00331bbca51536469cea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eef546abb6ce8f153dd517db52fbc6c955f631dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eef546abb6ce8f153dd517db52fbc6c955f631dc", "html_url": "https://github.com/rust-lang/rust/commit/eef546abb6ce8f153dd517db52fbc6c955f631dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eef546abb6ce8f153dd517db52fbc6c955f631dc/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c97d8992ae0ffc6f773fedcfe419bc260a644ea6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97d8992ae0ffc6f773fedcfe419bc260a644ea6", "html_url": "https://github.com/rust-lang/rust/commit/c97d8992ae0ffc6f773fedcfe419bc260a644ea6"}], "stats": {"total": 96, "additions": 78, "deletions": 18}, "files": [{"sha": "e0c09d9ed0d8a898964963c6352efeb286bdb27b", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eef546abb6ce8f153dd517db52fbc6c955f631dc/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef546abb6ce8f153dd517db52fbc6c955f631dc/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=eef546abb6ce8f153dd517db52fbc6c955f631dc", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::source_map::original_sp;\n use rustc_span::{BytePos, ExpnKind, MacroKind, Span, Symbol};\n \n+use std::cell::RefCell;\n use std::cmp::Ordering;\n \n #[derive(Debug, Copy, Clone)]\n@@ -68,6 +69,7 @@ impl CoverageStatement {\n pub(super) struct CoverageSpan {\n     pub span: Span,\n     pub expn_span: Span,\n+    pub current_macro_or_none: RefCell<Option<Option<Symbol>>>,\n     pub bcb: BasicCoverageBlock,\n     pub coverage_statements: Vec<CoverageStatement>,\n     pub is_closure: bool,\n@@ -78,6 +80,7 @@ impl CoverageSpan {\n         Self {\n             span: fn_sig_span,\n             expn_span: fn_sig_span,\n+            current_macro_or_none: Default::default(),\n             bcb: START_BCB,\n             coverage_statements: vec![],\n             is_closure: false,\n@@ -103,6 +106,7 @@ impl CoverageSpan {\n         Self {\n             span,\n             expn_span,\n+            current_macro_or_none: Default::default(),\n             bcb,\n             coverage_statements: vec![CoverageStatement::Statement(bb, span, stmt_index)],\n             is_closure,\n@@ -118,6 +122,7 @@ impl CoverageSpan {\n         Self {\n             span,\n             expn_span,\n+            current_macro_or_none: Default::default(),\n             bcb,\n             coverage_statements: vec![CoverageStatement::Terminator(bb, span)],\n             is_closure: false,\n@@ -174,15 +179,19 @@ impl CoverageSpan {\n             .join(\"\\n\")\n     }\n \n-    /// If the span is part of a macro, and the macro is visible (expands directly to the given\n-    /// body_span), returns the macro name symbol.\n+    /// If the span is part of a macro, returns the macro name symbol.\n     pub fn current_macro(&self) -> Option<Symbol> {\n-        if let ExpnKind::Macro(MacroKind::Bang, current_macro) =\n-            self.expn_span.ctxt().outer_expn_data().kind\n-        {\n-            return Some(current_macro);\n-        }\n-        None\n+        self.current_macro_or_none\n+            .borrow_mut()\n+            .get_or_insert_with(|| {\n+                if let ExpnKind::Macro(MacroKind::Bang, current_macro) =\n+                    self.expn_span.ctxt().outer_expn_data().kind\n+                {\n+                    return Some(current_macro);\n+                }\n+                None\n+            })\n+            .map(|symbol| symbol)\n     }\n \n     /// If the span is part of a macro, and the macro is visible (expands directly to the given\n@@ -474,8 +483,8 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                 self.curr().expn_span.ctxt() != prev_expn_span.ctxt()\n             }) {\n                 let merged_prefix_len = self.curr_original_span.lo() - self.curr().span.lo();\n-                let after_macro_bang = merged_prefix_len\n-                    + BytePos(visible_macro.to_string().bytes().count() as u32 + 1);\n+                let after_macro_bang =\n+                    merged_prefix_len + BytePos(visible_macro.as_str().bytes().count() as u32 + 1);\n                 let mut macro_name_cov = self.curr().clone();\n                 self.curr_mut().span =\n                     self.curr().span.with_lo(self.curr().span.lo() + after_macro_bang);\n@@ -766,6 +775,9 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n }\n \n+/// See `function_source_span()` for a description of the two returned spans.\n+/// If the MIR `Statement` is not contributive to computing coverage spans,\n+/// returns `None`.\n pub(super) fn filtered_statement_span(\n     statement: &'a Statement<'tcx>,\n     body_span: Span,\n@@ -811,6 +823,9 @@ pub(super) fn filtered_statement_span(\n     }\n }\n \n+/// See `function_source_span()` for a description of the two returned spans.\n+/// If the MIR `Terminator` is not contributive to computing coverage spans,\n+/// returns `None`.\n pub(super) fn filtered_terminator_span(\n     terminator: &'a Terminator<'tcx>,\n     body_span: Span,\n@@ -854,8 +869,21 @@ pub(super) fn filtered_terminator_span(\n     }\n }\n \n-/// Returns the span within the function source body, and the given span, which will be different\n-/// if the given span is an expansion (macro, syntactic sugar, etc.).\n+/// Returns two spans from the given span (the span associated with a\n+/// `Statement` or `Terminator`):\n+///\n+///   1. An extrapolated span (pre-expansion[^1]) corresponding to a range within\n+///      the function's body source. This span is guaranteed to be contained\n+///      within, or equal to, the `body_span`. If the extrapolated span is not\n+///      contained within the `body_span`, the `body_span` is returned.\n+///   2. The actual `span` value from the `Statement`, before expansion.\n+///\n+/// Only the first span is used when computing coverage code regions. The second\n+/// span is useful if additional expansion data is needed (such as to look up\n+/// the macro name for a composed span within that macro).)\n+///\n+/// [^1]Expansions result from Rust syntax including macros, syntactic\n+/// sugar, etc.).\n #[inline]\n fn function_source_span(span: Span, body_span: Span) -> (Span, Span) {\n     let original_span = original_sp(span, body_span).with_ctxt(body_span.ctxt());"}, {"sha": "8256daa1419b3e572cfe3ab1a65f3ffdd4fe97d5", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-84561.txt", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eef546abb6ce8f153dd517db52fbc6c955f631dc/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eef546abb6ce8f153dd517db52fbc6c955f631dc/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt?ref=eef546abb6ce8f153dd517db52fbc6c955f631dc", "patch": "@@ -10,7 +10,7 @@\n   | Unexecuted instantiation: <issue_84561::Foo as core::cmp::PartialEq>::ne\n   ------------------\n     5|       |struct Foo(u32);\n-    6|      1|fn test2() {\n+    6|      1|fn test3() {\n     7|      1|    let is_true = std::env::args().len() == 1;\n     8|      1|    let bar = Foo(1);\n     9|      1|    assert_eq!(bar, Foo(1));\n@@ -173,8 +173,24 @@\n   160|      1|    debug!(\"debug is enabled\");\n   161|      1|}\n   162|       |\n-  163|      1|fn main() {\n-  164|      1|    test1();\n-  165|      1|    test2();\n-  166|      1|}\n+  163|       |macro_rules! call_debug {\n+  164|       |    ($($arg:tt)+) => (\n+  165|      1|        fn call_print(s: &str) {\n+  166|      1|            print!(\"{}\", s);\n+  167|      1|        }\n+  168|       |\n+  169|       |        call_print(\"called from call_debug: \");\n+  170|       |        debug!($($arg)+);\n+  171|       |    );\n+  172|       |}\n+  173|       |\n+  174|      1|fn test2() {\n+  175|      1|    call_debug!(\"debug is enabled\");\n+  176|      1|}\n+  177|       |\n+  178|      1|fn main() {\n+  179|      1|    test1();\n+  180|      1|    test2();\n+  181|      1|    test3();\n+  182|      1|}\n "}, {"sha": "b39a289c45e209bc71529a0a1d6c64c77580c405", "filename": "src/test/run-make-fulldeps/coverage/issue-84561.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eef546abb6ce8f153dd517db52fbc6c955f631dc/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef546abb6ce8f153dd517db52fbc6c955f631dc/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs?ref=eef546abb6ce8f153dd517db52fbc6c955f631dc", "patch": "@@ -3,7 +3,7 @@\n // expect-exit-status-101\n #[derive(PartialEq, Eq)]\n struct Foo(u32);\n-fn test2() {\n+fn test3() {\n     let is_true = std::env::args().len() == 1;\n     let bar = Foo(1);\n     assert_eq!(bar, Foo(1));\n@@ -160,7 +160,23 @@ fn test1() {\n     debug!(\"debug is enabled\");\n }\n \n+macro_rules! call_debug {\n+    ($($arg:tt)+) => (\n+        fn call_print(s: &str) {\n+            print!(\"{}\", s);\n+        }\n+\n+        call_print(\"called from call_debug: \");\n+        debug!($($arg)+);\n+    );\n+}\n+\n+fn test2() {\n+    call_debug!(\"debug is enabled\");\n+}\n+\n fn main() {\n     test1();\n     test2();\n+    test3();\n }"}]}