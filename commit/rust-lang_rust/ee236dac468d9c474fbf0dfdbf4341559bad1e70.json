{"sha": "ee236dac468d9c474fbf0dfdbf4341559bad1e70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMjM2ZGFjNDY4ZDljNDc0ZmJmMGRmZGJmNDM0MTU1OWJhZDFlNzA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-28T09:06:01Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-28T09:06:01Z"}, "message": "Merge pull request #522 from devonhollowood/methods_refactor\n\nRefactor `check_expr()` impl for `MethodsPass`", "tree": {"sha": "793b8e2b675fa1407a7758944c651ccc642da1f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/793b8e2b675fa1407a7758944c651ccc642da1f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee236dac468d9c474fbf0dfdbf4341559bad1e70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee236dac468d9c474fbf0dfdbf4341559bad1e70", "html_url": "https://github.com/rust-lang/rust/commit/ee236dac468d9c474fbf0dfdbf4341559bad1e70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee236dac468d9c474fbf0dfdbf4341559bad1e70/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbf1cdf34aa89cdaba1bb9993e6aed221dfceb90", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf1cdf34aa89cdaba1bb9993e6aed221dfceb90", "html_url": "https://github.com/rust-lang/rust/commit/dbf1cdf34aa89cdaba1bb9993e6aed221dfceb90"}, {"sha": "29b53d600f63b998eaf3d723ee0da90379b7a8b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/29b53d600f63b998eaf3d723ee0da90379b7a8b8", "html_url": "https://github.com/rust-lang/rust/commit/29b53d600f63b998eaf3d723ee0da90379b7a8b8"}], "stats": {"total": 262, "additions": 159, "deletions": 103}, "files": [{"sha": "d4809d374a31e081f008757cc448d381ff7a8ae0", "filename": "src/methods.rs", "status": "modified", "additions": 130, "deletions": 103, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/ee236dac468d9c474fbf0dfdbf4341559bad1e70/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee236dac468d9c474fbf0dfdbf4341559bad1e70/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=ee236dac468d9c474fbf0dfdbf4341559bad1e70", "patch": "@@ -5,9 +5,10 @@ use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, walk_ptrs_ty_depth,\n-    walk_ptrs_ty};\n+use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args,\n+            walk_ptrs_ty_depth, walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n+use utils::MethodArgs;\n \n use self::SelfKind::*;\n use self::OutType::*;\n@@ -157,107 +158,21 @@ impl LintPass for MethodsPass {\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-\n-        if let ExprMethodCall(ref name, _, ref args) = expr.node {\n-            let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n-            match &*name.node.as_str() {\n-                \"unwrap\" if match_type(cx, obj_ty, &OPTION_PATH) => {\n-                    span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n-                              \"used unwrap() on an Option value. If you don't want \\\n-                               to handle the None case gracefully, consider using \\\n-                               expect() to provide a better panic message\");\n-                },\n-                \"unwrap\" if match_type(cx, obj_ty, &RESULT_PATH) => {\n-                    span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n-                              \"used unwrap() on a Result value. Graceful handling \\\n-                               of Err values is preferred\");\n-                },\n-                \"to_string\" if obj_ty.sty == ty::TyStr => {\n-                    let mut arg_str = snippet(cx, args[0].span, \"_\");\n-                    if ptr_depth > 1 {\n-                        arg_str = Cow::Owned(format!(\n-                            \"({}{})\",\n-                            iter::repeat('*').take(ptr_depth - 1).collect::<String>(),\n-                            arg_str));\n-                    }\n-                    span_lint(cx, STR_TO_STRING, expr.span, &format!(\n-                        \"`{}.to_owned()` is faster\", arg_str));\n-                },\n-                \"to_string\" if match_type(cx, obj_ty, &STRING_PATH) => {\n-                    span_lint(cx, STRING_TO_STRING, expr.span, \"`String.to_string()` is a no-op; use \\\n-                                                                `clone()` to make a copy\");\n-                },\n-                \"expect\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"ok\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &RESULT_PATH) {\n-                        let result_type = cx.tcx.expr_ty(&inner_args[0]);\n-                        if let Some(error_type) = get_error_type(cx, result_type) {\n-                            if has_debug_impl(error_type, cx) {\n-                                span_lint(cx, OK_EXPECT, expr.span,\n-                                         \"called `ok().expect()` on a Result \\\n-                                          value. You can call `expect` directly \\\n-                                          on the `Result`\");\n-                            }\n-                        }\n-                    }\n-                },\n-                // check Option.map(_).unwrap_or(_)\n-                \"unwrap_or\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"map\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n-                        // lint message\n-                        let msg =\n-                            \"called `map(f).unwrap_or(a)` on an Option value. This can be done \\\n-                             more directly by calling `map_or(a, f)` instead\";\n-                        // get args to map() and unwrap_or()\n-                        let map_arg = snippet(cx, inner_args[1].span, \"..\");\n-                        let unwrap_arg = snippet(cx, args[1].span, \"..\");\n-                        // lint, with note if neither arg is > 1 line and both map() and\n-                        // unwrap_or() have the same span\n-                        let multiline = map_arg.lines().count() > 1\n-                                        || unwrap_arg.lines().count() > 1;\n-                        let same_span = inner_args[1].span.expn_id == args[1].span.expn_id;\n-                        if same_span && !multiline {\n-                            span_note_and_lint(\n-                                cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n-                                &format!(\"replace this with map_or({1}, {0})\",\n-                                         map_arg, unwrap_arg)\n-                            );\n-                        }\n-                        else if same_span && multiline {\n-                            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n-                        };\n-                    }\n-                },\n-                // check Option.map(_).unwrap_or_else(_)\n-                \"unwrap_or_else\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"map\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n-                        // lint message\n-                        let msg =\n-                            \"called `map(f).unwrap_or_else(g)` on an Option value. This can be \\\n-                             done more directly by calling `map_or_else(g, f)` instead\";\n-                        // get args to map() and unwrap_or_else()\n-                        let map_arg = snippet(cx, inner_args[1].span, \"..\");\n-                        let unwrap_arg = snippet(cx, args[1].span, \"..\");\n-                        // lint, with note if neither arg is > 1 line and both map() and\n-                        // unwrap_or_else() have the same span\n-                        let multiline = map_arg.lines().count() > 1\n-                                        || unwrap_arg.lines().count() > 1;\n-                        let same_span = inner_args[1].span.expn_id == args[1].span.expn_id;\n-                        if same_span && !multiline {\n-                            span_note_and_lint(\n-                                cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n-                                &format!(\"replace this with map_or_else({1}, {0})\",\n-                                         map_arg, unwrap_arg)\n-                            );\n-                        }\n-                        else if same_span && multiline {\n-                            span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n-                        };\n-                    }\n-                },\n-                _ => {},\n+        if let ExprMethodCall(_, _, _) = expr.node {\n+            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+                lint_unwrap(cx, expr, arglists[0]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n+                lint_to_string(cx, expr, arglists[0]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n+                lint_ok_expect(cx, expr, arglists[0]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n+                lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n+                lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n             }\n         }\n     }\n@@ -304,6 +219,118 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `unwrap()` for `Option`s and `Result`s\n+fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n+    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&unwrap_args[0]));\n+\n+    if match_type(cx, obj_ty, &OPTION_PATH) {\n+        span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n+                  \"used unwrap() on an Option value. If you don't want to handle the None case \\\n+                   gracefully, consider using expect() to provide a better panic message\");\n+    }\n+    else if match_type(cx, obj_ty, &RESULT_PATH) {\n+        span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n+                  \"used unwrap() on a Result value. Graceful handling of Err values is preferred\");\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `to_string()` for `&str`s and `String`s\n+fn lint_to_string(cx: &LateContext, expr: &Expr, to_string_args: &MethodArgs) {\n+    let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&to_string_args[0]));\n+\n+    if obj_ty.sty == ty::TyStr {\n+        let mut arg_str = snippet(cx, to_string_args[0].span, \"_\");\n+        if ptr_depth > 1 {\n+            arg_str = Cow::Owned(format!(\n+                \"({}{})\",\n+                iter::repeat('*').take(ptr_depth - 1).collect::<String>(),\n+                arg_str));\n+        }\n+        span_lint(cx, STR_TO_STRING, expr.span,\n+                  &format!(\"`{}.to_owned()` is faster\", arg_str));\n+    }\n+    else if match_type(cx, obj_ty, &STRING_PATH) {\n+        span_lint(cx, STRING_TO_STRING, expr.span,\n+                  \"`String.to_string()` is a no-op; use `clone()` to make a copy\");\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `ok().expect()` for `Result`s\n+fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n+    // lint if the caller of `ok()` is a `Result`\n+    if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &RESULT_PATH) {\n+        let result_type = cx.tcx.expr_ty(&ok_args[0]);\n+        if let Some(error_type) = get_error_type(cx, result_type) {\n+            if has_debug_impl(error_type, cx) {\n+                span_lint(cx, OK_EXPECT, expr.span,\n+                          \"called `ok().expect()` on a Result value. You can call `expect` \\\n+                           directly on the `Result`\");\n+            }\n+        }\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `map().unwrap_or()` for `Option`s\n+fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs,\n+                      map_args: &MethodArgs) {\n+    // lint if the caller of `map()` is an `Option`\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+        // lint message\n+        let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more \\\n+                   directly by calling `map_or(a, f)` instead\";\n+        // get snippets for args to map() and unwrap_or()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or() have the same span\n+        let multiline = map_snippet.lines().count() > 1\n+                        || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n+        if same_span && !multiline {\n+            span_note_and_lint(\n+                cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n+                &format!(\"replace this with map_or({1}, {0})\", map_snippet, unwrap_snippet)\n+            );\n+        }\n+        else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n+        };\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `map().unwrap_or_else()` for `Option`s\n+fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs,\n+                           map_args: &MethodArgs) {\n+    // lint if the caller of `map()` is an `Option`\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+        // lint message\n+        let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more \\\n+                   directly by calling `map_or_else(g, f)` instead\";\n+        // get snippets for args to map() and unwrap_or_else()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or_else() have the same span\n+        let multiline = map_snippet.lines().count() > 1\n+                        || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n+        if same_span && !multiline {\n+            span_note_and_lint(\n+                cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n+                &format!(\"replace this with map_or_else({1}, {0})\", map_snippet, unwrap_snippet)\n+            );\n+        }\n+        else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n+        };\n+    }\n+}\n+\n // Given a `Result<T, E>` type, return its error type (`E`)\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     if !match_type(cx, ty, &RESULT_PATH) {"}, {"sha": "2ff498b564644af08d99473ebbf8fd658602b9ad", "filename": "src/utils.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee236dac468d9c474fbf0dfdbf4341559bad1e70/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee236dac468d9c474fbf0dfdbf4341559bad1e70/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ee236dac468d9c474fbf0dfdbf4341559bad1e70", "patch": "@@ -8,10 +8,13 @@ use rustc::middle::ty;\n use std::borrow::Cow;\n use syntax::ast::Lit_::*;\n use syntax::ast;\n+use syntax::ptr::P;\n \n use rustc::session::Session;\n use std::str::FromStr;\n \n+pub type MethodArgs = HirVec<P<Expr>>;\n+\n // module DefPaths for certain structs/enums we check for\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n@@ -136,6 +139,7 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n         false\n     }\n }\n+\n /// check if method call given in \"expr\" belongs to given trait\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n@@ -163,6 +167,31 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n         |(a, b)| a.identifier.name.as_str() == *b)\n }\n \n+/// match an Expr against a chain of methods, and return the matched Exprs. For example, if `expr`\n+/// represents the `.baz()` in `foo.bar().baz()`, `matched_method_chain(expr, &[\"bar\", \"baz\"])`\n+/// will return a Vec containing the Exprs for `.bar()` and `.baz()`\n+pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a MethodArgs>> {\n+    let mut current = expr;\n+    let mut matched = Vec::with_capacity(methods.len());\n+    for method_name in methods.iter().rev() { // method chains are stored last -> first\n+        if let ExprMethodCall(ref name, _, ref args) = current.node {\n+            if name.node.as_str() == *method_name {\n+                matched.push(args); // build up `matched` backwards\n+                current = &args[0] // go to parent expression\n+            }\n+            else {\n+                return None;\n+            }\n+        }\n+        else {\n+            return None;\n+        }\n+    }\n+    matched.reverse(); // reverse `matched`, so that it is in the same order as `methods`\n+    Some(matched)\n+}\n+\n+\n /// get the name of the item the expression is in, if available\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);"}]}