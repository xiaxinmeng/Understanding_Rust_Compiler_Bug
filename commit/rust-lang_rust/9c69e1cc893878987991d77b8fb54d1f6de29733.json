{"sha": "9c69e1cc893878987991d77b8fb54d1f6de29733", "node_id": "C_kwDOAAsO6NoAKDljNjllMWNjODkzODc4OTg3OTkxZDc3YjhmYjU0ZDFmNmRlMjk3MzM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-11-17T14:17:28Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-11-25T09:09:35Z"}, "message": "Simplify", "tree": {"sha": "f600967ecc1bd74007c85b3ae2c0ac04274abf70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f600967ecc1bd74007c85b3ae2c0ac04274abf70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c69e1cc893878987991d77b8fb54d1f6de29733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c69e1cc893878987991d77b8fb54d1f6de29733", "html_url": "https://github.com/rust-lang/rust/commit/9c69e1cc893878987991d77b8fb54d1f6de29733", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c69e1cc893878987991d77b8fb54d1f6de29733/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fa57575302a5931517590daf8df2ef8a93f7a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa57575302a5931517590daf8df2ef8a93f7a7b", "html_url": "https://github.com/rust-lang/rust/commit/4fa57575302a5931517590daf8df2ef8a93f7a7b"}], "stats": {"total": 173, "additions": 78, "deletions": 95}, "files": [{"sha": "d7e4834230649a2ef94492afcc80a0a769300e1b", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 78, "deletions": 95, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/9c69e1cc893878987991d77b8fb54d1f6de29733/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c69e1cc893878987991d77b8fb54d1f6de29733/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=9c69e1cc893878987991d77b8fb54d1f6de29733", "patch": "@@ -363,72 +363,60 @@ fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> HasSaf\n         has_safety_comment => return has_safety_comment,\n     }\n \n-    if item.span.ctxt() == SyntaxContext::root() {\n-        if let Some(parent_node) = get_parent_node(cx.tcx, item.hir_id()) {\n-            let comment_start = match parent_node {\n-                Node::Crate(parent_mod) => {\n-                    comment_start_before_item_in_mod(cx, parent_mod, parent_mod.spans.inner_span, item)\n-                },\n-                Node::Item(parent_item) => {\n-                    if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n-                        comment_start_before_item_in_mod(cx, parent_mod, parent_item.span, item)\n-                    } else {\n-                        // Doesn't support impls in this position. Pretend a comment was found.\n-                        return HasSafetyComment::Maybe;\n-                    }\n-                },\n-                Node::Stmt(stmt) => {\n-                    if let Some(stmt_parent) = get_parent_node(cx.tcx, stmt.hir_id) {\n-                        match stmt_parent {\n-                            Node::Block(block) => walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo),\n-                            _ => {\n-                                // Doesn't support impls in this position. Pretend a comment was found.\n-                                return HasSafetyComment::Maybe;\n-                            },\n-                        }\n-                    } else {\n-                        // Problem getting the parent node. Pretend a comment was found.\n-                        return HasSafetyComment::Maybe;\n-                    }\n-                },\n-                _ => {\n+    if item.span.ctxt() != SyntaxContext::root() {\n+        return HasSafetyComment::No;\n+    }\n+    if let Some(parent_node) = get_parent_node(cx.tcx, item.hir_id()) {\n+        let comment_start = match parent_node {\n+            Node::Crate(parent_mod) => {\n+                comment_start_before_item_in_mod(cx, parent_mod, parent_mod.spans.inner_span, item)\n+            },\n+            Node::Item(parent_item) => {\n+                if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n+                    comment_start_before_item_in_mod(cx, parent_mod, parent_item.span, item)\n+                } else {\n                     // Doesn't support impls in this position. Pretend a comment was found.\n                     return HasSafetyComment::Maybe;\n-                },\n-            };\n+                }\n+            },\n+            Node::Stmt(stmt) => {\n+                if let Some(Node::Block(block)) = get_parent_node(cx.tcx, stmt.hir_id) {\n+                    walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo)\n+                } else {\n+                    // Problem getting the parent node. Pretend a comment was found.\n+                    return HasSafetyComment::Maybe;\n+                }\n+            },\n+            _ => {\n+                // Doesn't support impls in this position. Pretend a comment was found.\n+                return HasSafetyComment::Maybe;\n+            },\n+        };\n \n-            let source_map = cx.sess().source_map();\n-            if let Some(comment_start) = comment_start\n-                && let Ok(unsafe_line) = source_map.lookup_line(item.span.lo())\n-                && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n-                && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n-                && let Some(src) = unsafe_line.sf.src.as_deref()\n-            {\n-                unsafe_line.sf.lines(|lines| {\n-                    if comment_start_line.line >= unsafe_line.line {\n-                        HasSafetyComment::No\n-                    } else {\n-                        match text_has_safety_comment(\n-                            src,\n-                            &lines[comment_start_line.line + 1..=unsafe_line.line],\n-                            unsafe_line.sf.start_pos.to_usize(),\n-                        ) {\n-                            Some(b) => HasSafetyComment::Yes(b),\n-                            None => HasSafetyComment::No,\n-                        }\n+        let source_map = cx.sess().source_map();\n+        if let Some(comment_start) = comment_start\n+            && let Ok(unsafe_line) = source_map.lookup_line(item.span.lo())\n+            && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n+            && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n+            && let Some(src) = unsafe_line.sf.src.as_deref()\n+        {\n+            return unsafe_line.sf.lines(|lines| {\n+                if comment_start_line.line >= unsafe_line.line {\n+                    HasSafetyComment::No\n+                } else {\n+                    match text_has_safety_comment(\n+                        src,\n+                        &lines[comment_start_line.line + 1..=unsafe_line.line],\n+                        unsafe_line.sf.start_pos.to_usize(),\n+                    ) {\n+                        Some(b) => HasSafetyComment::Yes(b),\n+                        None => HasSafetyComment::No,\n                     }\n-                })\n-            } else {\n-                // Problem getting source text. Pretend a comment was found.\n-                HasSafetyComment::Maybe\n-            }\n-        } else {\n-            // No parent node. Pretend a comment was found.\n-            HasSafetyComment::Maybe\n+                }\n+            });\n         }\n-    } else {\n-        HasSafetyComment::No\n     }\n+    HasSafetyComment::Maybe\n }\n \n /// Checks if the lines immediately preceding the item contain a safety comment.\n@@ -439,45 +427,40 @@ fn stmt_has_safety_comment(cx: &LateContext<'_>, span: Span, hir_id: HirId) -> H\n         has_safety_comment => return has_safety_comment,\n     }\n \n-    if span.ctxt() == SyntaxContext::root() {\n-        if let Some(parent_node) = get_parent_node(cx.tcx, hir_id) {\n-            let comment_start = match parent_node {\n-                Node::Block(block) => walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo),\n-                _ => return HasSafetyComment::Maybe,\n-            };\n+    if span.ctxt() != SyntaxContext::root() {\n+        return HasSafetyComment::No;\n+    }\n \n-            let source_map = cx.sess().source_map();\n-            if let Some(comment_start) = comment_start\n-                && let Ok(unsafe_line) = source_map.lookup_line(span.lo())\n-                && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n-                && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n-                && let Some(src) = unsafe_line.sf.src.as_deref()\n-            {\n-                unsafe_line.sf.lines(|lines| {\n-                    if comment_start_line.line >= unsafe_line.line {\n-                        HasSafetyComment::No\n-                    } else {\n-                        match text_has_safety_comment(\n-                            src,\n-                            &lines[comment_start_line.line + 1..=unsafe_line.line],\n-                            unsafe_line.sf.start_pos.to_usize(),\n-                        ) {\n-                            Some(b) => HasSafetyComment::Yes(b),\n-                            None => HasSafetyComment::No,\n-                        }\n+    if let Some(parent_node) = get_parent_node(cx.tcx, hir_id) {\n+        let comment_start = match parent_node {\n+            Node::Block(block) => walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo),\n+            _ => return HasSafetyComment::Maybe,\n+        };\n+\n+        let source_map = cx.sess().source_map();\n+        if let Some(comment_start) = comment_start\n+            && let Ok(unsafe_line) = source_map.lookup_line(span.lo())\n+            && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n+            && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n+            && let Some(src) = unsafe_line.sf.src.as_deref()\n+        {\n+            return unsafe_line.sf.lines(|lines| {\n+                if comment_start_line.line >= unsafe_line.line {\n+                    HasSafetyComment::No\n+                } else {\n+                    match text_has_safety_comment(\n+                        src,\n+                        &lines[comment_start_line.line + 1..=unsafe_line.line],\n+                        unsafe_line.sf.start_pos.to_usize(),\n+                    ) {\n+                        Some(b) => HasSafetyComment::Yes(b),\n+                        None => HasSafetyComment::No,\n                     }\n-                })\n-            } else {\n-                // Problem getting source text. Pretend a comment was found.\n-                HasSafetyComment::Maybe\n-            }\n-        } else {\n-            // No parent node. Pretend a comment was found.\n-            HasSafetyComment::Maybe\n+                }\n+            });\n         }\n-    } else {\n-        HasSafetyComment::No\n     }\n+    HasSafetyComment::Maybe\n }\n \n fn comment_start_before_item_in_mod("}]}