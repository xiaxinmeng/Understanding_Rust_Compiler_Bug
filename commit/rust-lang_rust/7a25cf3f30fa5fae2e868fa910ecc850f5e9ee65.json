{"sha": "7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMjVjZjNmMzBmYTVmYWUyZTg2OGZhOTEwZWNjODUwZjVlOWVlNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-30T17:06:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-30T17:06:18Z"}, "message": "auto merge of #15944 : alexcrichton/rust/task-dont-die, r=brson\n\nPreviously both spawning mechanisms were not resilient to task failures which were initiated from the task spawning infrastructure.\r\n\r\nCloses #15895", "tree": {"sha": "008d8b16797b8beb73c0e683f2bff73527118252", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/008d8b16797b8beb73c0e683f2bff73527118252"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "html_url": "https://github.com/rust-lang/rust/commit/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6814206247d20a523e3cb1def5dad704c019cb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6814206247d20a523e3cb1def5dad704c019cb1", "html_url": "https://github.com/rust-lang/rust/commit/f6814206247d20a523e3cb1def5dad704c019cb1"}, {"sha": "8643a0d61359dfb1ebe38d4aae615e7c836b3d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/8643a0d61359dfb1ebe38d4aae615e7c836b3d18", "html_url": "https://github.com/rust-lang/rust/commit/8643a0d61359dfb1ebe38d4aae615e7c836b3d18"}], "stats": {"total": 127, "additions": 111, "deletions": 16}, "files": [{"sha": "b9144047df5c0b7e3017f3fdeb27bedd594a82d4", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "patch": "@@ -219,7 +219,7 @@ impl Scheduler {\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n         rtassert!(match message { msgq::Empty => true, _ => false });\n \n-        stask.task.get_mut_ref().destroyed = true;\n+        stask.task.take().unwrap().drop();\n     }\n \n     // This does not return a scheduler, as the scheduler is placed"}, {"sha": "12d7b75569782f18ff52408d5b880e31e45aee2c", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "patch": "@@ -442,15 +442,30 @@ impl Runtime for GreenTask {\n                      f: proc():Send) {\n         self.put_task(cur_task);\n \n+        // First, set up a bomb which when it goes off will restore the local\n+        // task unless its disarmed. This will allow us to gracefully fail from\n+        // inside of `configure` which allocates a new task.\n+        struct Bomb { inner: Option<Box<GreenTask>> }\n+        impl Drop for Bomb {\n+            fn drop(&mut self) {\n+                let _ = self.inner.take().map(|task| task.put());\n+            }\n+        }\n+        let mut bomb = Bomb { inner: Some(self) };\n+\n         // Spawns a task into the current scheduler. We allocate the new task's\n         // stack from the scheduler's stack pool, and then configure it\n         // accordingly to `opts`. Afterwards we bootstrap it immediately by\n         // switching to it.\n         //\n         // Upon returning, our task is back in TLS and we're good to return.\n-        let mut sched = self.sched.take_unwrap();\n-        let sibling = GreenTask::configure(&mut sched.stack_pool, opts, f);\n-        sched.run_task(self, sibling)\n+        let sibling = {\n+            let sched = bomb.inner.get_mut_ref().sched.get_mut_ref();\n+            GreenTask::configure(&mut sched.stack_pool, opts, f)\n+        };\n+        let mut me = bomb.inner.take().unwrap();\n+        let sched = me.sched.take().unwrap();\n+        sched.run_task(me, sibling)\n     }\n \n     // Local I/O is provided by the scheduler's event loop"}, {"sha": "c72d6c24a7c16ffa5b6cd661c9b8d2698322323c", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "patch": "@@ -71,7 +71,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n     // Note that this increment must happen *before* the spawn in order to\n     // guarantee that if this task exits it will always end up waiting for the\n     // spawned task to exit.\n-    bookkeeping::increment();\n+    let token = bookkeeping::increment();\n \n     // Spawning a new OS thread guarantees that __morestack will never get\n     // triggered, but we must manually set up the actual stack bounds once this\n@@ -93,7 +93,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n         let mut task = task;\n         task.put_runtime(ops);\n         drop(task.run(|| { f.take_unwrap()() }).destroy());\n-        bookkeeping::decrement();\n+        drop(token);\n     })\n }\n "}, {"sha": "dc96aecff8017c7c858934ad3ebb56668f4fb79e", "filename": "src/librustrt/bookkeeping.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibrustrt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibrustrt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fbookkeeping.rs?ref=7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "patch": "@@ -19,14 +19,24 @@\n //! decrement() manually.\n \n use core::atomics;\n+use core::ops::Drop;\n \n use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n static mut TASK_COUNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n static mut TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n-pub fn increment() {\n+pub struct Token { _private: () }\n+\n+impl Drop for Token {\n+    fn drop(&mut self) { decrement() }\n+}\n+\n+/// Increment the number of live tasks, returning a token which will decrement\n+/// the count when dropped.\n+pub fn increment() -> Token {\n     let _ = unsafe { TASK_COUNT.fetch_add(1, atomics::SeqCst) };\n+    Token { _private: () }\n }\n \n pub fn decrement() {"}, {"sha": "e2a5eef0d99e18637ce5ae4e12d479826be21d38", "filename": "src/librustrt/local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibrustrt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibrustrt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal.rs?ref=7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "patch": "@@ -125,8 +125,8 @@ mod test {\n         }).join();\n     }\n \n-    fn cleanup_task(mut t: Box<Task>) {\n-        t.destroyed = true;\n+    fn cleanup_task(t: Box<Task>) {\n+        t.drop();\n     }\n \n }"}, {"sha": "e3d9b7d136ec2e05b6b16816e89dbb29d35418d9", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "patch": "@@ -100,12 +100,21 @@ pub struct Task {\n     pub storage: LocalStorage,\n     pub unwinder: Unwinder,\n     pub death: Death,\n-    pub destroyed: bool,\n     pub name: Option<SendStr>,\n \n+    state: TaskState,\n     imp: Option<Box<Runtime + Send>>,\n }\n \n+// Once a task has entered the `Armed` state it must be destroyed via `drop`,\n+// and no other method. This state is used to track this transition.\n+#[deriving(PartialEq)]\n+enum TaskState {\n+    New,\n+    Armed,\n+    Destroyed,\n+}\n+\n pub struct TaskOpts {\n     /// Invoke this procedure with the result of the task when it finishes.\n     pub on_exit: Option<proc(Result): Send>,\n@@ -159,7 +168,7 @@ impl Task {\n             storage: LocalStorage(None),\n             unwinder: Unwinder::new(),\n             death: Death::new(),\n-            destroyed: false,\n+            state: New,\n             name: None,\n             imp: None,\n         }\n@@ -203,7 +212,7 @@ impl Task {\n     /// }).destroy();\n     /// # }\n     /// ```\n-    pub fn run(self: Box<Task>, f: ||) -> Box<Task> {\n+    pub fn run(mut self: Box<Task>, f: ||) -> Box<Task> {\n         assert!(!self.is_destroyed(), \"cannot re-use a destroyed task\");\n \n         // First, make sure that no one else is in TLS. This does not allow\n@@ -212,6 +221,7 @@ impl Task {\n         if Local::exists(None::<Task>) {\n             fail!(\"cannot run a task recursively inside another\");\n         }\n+        self.state = Armed;\n         Local::put(self);\n \n         // There are two primary reasons that general try/catch is unsafe. The\n@@ -333,12 +343,12 @@ impl Task {\n         // Now that we're done, we remove the task from TLS and flag it for\n         // destruction.\n         let mut task: Box<Task> = Local::take();\n-        task.destroyed = true;\n+        task.state = Destroyed;\n         return task;\n     }\n \n     /// Queries whether this can be destroyed or not.\n-    pub fn is_destroyed(&self) -> bool { self.destroyed }\n+    pub fn is_destroyed(&self) -> bool { self.state == Destroyed }\n \n     /// Inserts a runtime object into this task, transferring ownership to the\n     /// task. It is illegal to replace a previous runtime object in this task\n@@ -453,12 +463,20 @@ impl Task {\n     pub fn can_block(&self) -> bool {\n         self.imp.get_ref().can_block()\n     }\n+\n+    /// Consume this task, flagging it as a candidate for destruction.\n+    ///\n+    /// This function is required to be invoked to destroy a task. A task\n+    /// destroyed through a normal drop will abort.\n+    pub fn drop(mut self) {\n+        self.state = Destroyed;\n+    }\n }\n \n impl Drop for Task {\n     fn drop(&mut self) {\n         rtdebug!(\"called drop for a task: {}\", self as *mut Task as uint);\n-        rtassert!(self.destroyed);\n+        rtassert!(self.state != Armed);\n     }\n }\n \n@@ -634,12 +652,17 @@ mod test {\n         begin_unwind(\"cause\", file!(), line!())\n     }\n \n+    #[test]\n+    fn drop_new_task_ok() {\n+        drop(Task::new());\n+    }\n+\n     // Task blocking tests\n \n     #[test]\n     fn block_and_wake() {\n         let task = box Task::new();\n         let mut task = BlockedTask::block(task).wake().unwrap();\n-        task.destroyed = true;\n+        task.drop();\n     }\n }"}, {"sha": "e1c4a480d1cc17e7ec6ff46bed0893b163e522fd", "filename": "src/test/run-pass/spawn-stack-too-big.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Ftest%2Frun-pass%2Fspawn-stack-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65/src%2Ftest%2Frun-pass%2Fspawn-stack-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-stack-too-big.rs?ref=7a25cf3f30fa5fae2e868fa910ecc850f5e9ee65", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-macos apparently gargantuan mmap requests are ok?\n+\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate green;\n+extern crate native;\n+\n+use std::task::TaskBuilder;\n+use native::NativeTaskBuilder;\n+\n+green_start!(main)\n+\n+fn main() {\n+    test();\n+\n+    let (tx, rx) = channel();\n+    TaskBuilder::new().native().spawn(proc() {\n+        tx.send(test());\n+    });\n+    rx.recv();\n+}\n+\n+#[cfg(not(target_word_size = \"64\"))]\n+fn test() {}\n+\n+#[cfg(target_word_size = \"64\")]\n+fn test() {\n+    let (tx, rx) = channel();\n+    spawn(proc() {\n+        TaskBuilder::new().stack_size(1024 * 1024 * 1024 * 64).spawn(proc() {\n+        });\n+        tx.send(());\n+    });\n+\n+    assert!(rx.recv_opt().is_err());\n+}"}]}