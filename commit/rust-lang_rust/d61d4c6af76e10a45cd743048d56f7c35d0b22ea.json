{"sha": "d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "node_id": "C_kwDOAAsO6NoAKGQ2MWQ0YzZhZjc2ZTEwYTQ1Y2Q3NDMwNDhkNTZmN2MzNWQwYjIyZWE", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-08-11T00:50:36Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-09-11T03:05:41Z"}, "message": "Implement -Zmiri-tag-gc a garbage collector for tags", "tree": {"sha": "2837e64d1da628fa9a9731c882031ef55c388b4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2837e64d1da628fa9a9731c882031ef55c388b4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "html_url": "https://github.com/rust-lang/rust/commit/d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beed5eddb0f73f6721681560c73a51e3f15b8681", "url": "https://api.github.com/repos/rust-lang/rust/commits/beed5eddb0f73f6721681560c73a51e3f15b8681", "html_url": "https://github.com/rust-lang/rust/commit/beed5eddb0f73f6721681560c73a51e3f15b8681"}], "stats": {"total": 248, "additions": 241, "deletions": 7}, "files": [{"sha": "120ce82e60f9cec29b47729eea377da0a7c91eb8", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -323,6 +323,10 @@ environment variable. We first document the most relevant and most commonly used\n   ensure alignment.  (The standard library `align_to` method works fine in both modes; under\n   symbolic alignment it only fills the middle slice when the allocation guarantees sufficient\n   alignment.)\n+* `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n+  is to search for and remove unreachable tags once every `10,000` basic blocks. Setting this to\n+  `0` disables the garbage collector, which causes some programs to have explosive memory usage\n+  and/or super-linear runtime.\n \n The remaining flags are for advanced use only, and more likely to change or be removed.\n Some of these are **unsound**, which means they can lead"}, {"sha": "d9e91951a92291fe67f8ff7b6a6f98b534410084", "filename": "src/bin/miri.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -521,6 +521,12 @@ fn main() {\n                 Err(err) => show_error!(\"-Zmiri-report-progress requires a `u32`: {}\", err),\n             };\n             miri_config.report_progress = Some(interval);\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-tag-gc=\") {\n+            let interval = match param.parse::<u32>() {\n+                Ok(i) => i,\n+                Err(err) => show_error!(\"-Zmiri-tag-gc requires a `u32`: {}\", err),\n+            };\n+            miri_config.gc_interval = interval;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-measureme=\") {\n             miri_config.measureme_out = Some(param.to_string());\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-backtrace=\") {"}, {"sha": "e00406be131674ff3dd5ae1521a7a01d2f369f9b", "filename": "src/concurrency/thread.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fthread.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -289,6 +289,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         &mut self.threads[self.active_thread].stack\n     }\n \n+    pub fn iter(&self) -> impl Iterator<Item = &Thread<'mir, 'tcx>> {\n+        self.threads.iter()\n+    }\n+\n     pub fn all_stacks(\n         &self,\n     ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>]> {"}, {"sha": "8cdb2876f1a1f74398029b3854dd657f06b17c63", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -132,6 +132,8 @@ pub struct MiriConfig {\n     /// The location of a shared object file to load when calling external functions\n     /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory\n     pub external_so_file: Option<PathBuf>,\n+    /// Run a garbage collector for SbTags every N basic blocks.\n+    pub gc_interval: u32,\n }\n \n impl Default for MiriConfig {\n@@ -164,6 +166,7 @@ impl Default for MiriConfig {\n             report_progress: None,\n             retag_fields: false,\n             external_so_file: None,\n+            gc_interval: 10_000,\n         }\n     }\n }"}, {"sha": "4fb6704165be54c110f8049a7e08c2c2a656ff4c", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -62,6 +62,7 @@ mod operator;\n mod range_map;\n mod shims;\n mod stacked_borrows;\n+mod tag_gc;\n \n // Establish a \"crate-wide prelude\": we often import `crate::*`.\n \n@@ -110,6 +111,7 @@ pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n     CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n };\n+pub use crate::tag_gc::EvalContextExt as _;\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "4eb68907337a1cb1943e9ead80c4f363257e2184", "filename": "src/machine.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -394,6 +394,11 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Handle of the optional shared object file for external functions.\n     pub external_so_lib: Option<(libloading::Library, std::path::PathBuf)>,\n+\n+    /// Run a garbage collector for SbTags every N basic blocks.\n+    pub(crate) gc_interval: u32,\n+    /// The number of blocks that passed since the last SbTag GC pass.\n+    pub(crate) since_gc: u32,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n@@ -469,6 +474,8 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n                     lib_file_path.clone(),\n                 )\n             }),\n+            gc_interval: config.gc_interval,\n+            since_gc: 0,\n         }\n     }\n \n@@ -1016,6 +1023,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 });\n             }\n         }\n+\n+        // Search for SbTags to find all live pointers, then remove all other tags from borrow\n+        // stacks.\n+        // When debug assertions are enabled, run the GC as often as possible so that any cases\n+        // where it mistakenly removes an important tag become visible.\n+        if cfg!(debug_assertions)\n+            || (ecx.machine.gc_interval > 0 && ecx.machine.since_gc >= ecx.machine.gc_interval)\n+        {\n+            ecx.machine.since_gc = 0;\n+            ecx.garbage_collect_tags()?;\n+        } else {\n+            ecx.machine.since_gc += 1;\n+        }\n+\n         // These are our preemption points.\n         ecx.maybe_preempt_active_thread();\n         Ok(())"}, {"sha": "343fa05712dcfd6e4d547b1ecd52986c2d33706e", "filename": "src/shims/tls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -233,6 +233,12 @@ impl<'tcx> TlsData<'tcx> {\n             data.remove(&thread_id);\n         }\n     }\n+\n+    pub fn iter(&self, mut visitor: impl FnMut(&Scalar<Provenance>)) {\n+        for scalar in self.keys.values().flat_map(|v| v.data.values()) {\n+            visitor(scalar);\n+        }\n+    }\n }\n \n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}"}, {"sha": "9257628456632a6ef53f83878f741a2e1eabee32", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -80,6 +80,8 @@ pub struct Stacks {\n     history: AllocHistory,\n     /// The set of tags that have been exposed inside this allocation.\n     exposed_tags: FxHashSet<SbTag>,\n+    /// Whether this memory has been modified since the last time the tag GC ran\n+    modified_since_last_gc: bool,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -422,6 +424,7 @@ impl<'tcx> Stack {\n             let item = self.get(idx).unwrap();\n             Stack::item_popped(&item, global, dcx)?;\n         }\n+\n         Ok(())\n     }\n \n@@ -496,6 +499,20 @@ impl<'tcx> Stack {\n }\n // # Stacked Borrows Core End\n \n+/// Integration with the SbTag garbage collector\n+impl Stacks {\n+    pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<SbTag>) {\n+        if self.modified_since_last_gc {\n+            for stack in self.stacks.iter_mut_all() {\n+                if stack.len() > 64 {\n+                    stack.retain(live_tags);\n+                }\n+            }\n+            self.modified_since_last_gc = false;\n+        }\n+    }\n+}\n+\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates a new stack with an initial tag. For diagnostic purposes, we also need to know\n@@ -514,6 +531,7 @@ impl<'tcx> Stacks {\n             stacks: RangeMap::new(size, stack),\n             history: AllocHistory::new(id, item, current_span),\n             exposed_tags: FxHashSet::default(),\n+            modified_since_last_gc: false,\n         }\n     }\n \n@@ -528,6 +546,7 @@ impl<'tcx> Stacks {\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n+        self.modified_since_last_gc = true;\n         for (offset, stack) in self.stacks.iter_mut(range.start, range.size) {\n             let mut dcx = dcx_builder.build(&mut self.history, offset);\n             f(stack, &mut dcx, &mut self.exposed_tags)?;"}, {"sha": "494ea08b56e48b2b594f4fa2725e2b14543613d1", "filename": "src/stacked_borrows/stack.rs", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fstack.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -39,6 +39,61 @@ pub struct Stack {\n     unique_range: Range<usize>,\n }\n \n+impl Stack {\n+    pub fn retain(&mut self, tags: &FxHashSet<SbTag>) {\n+        let mut first_removed = None;\n+\n+        let mut read_idx = 1;\n+        let mut write_idx = 1;\n+        while read_idx < self.borrows.len() {\n+            let left = self.borrows[read_idx - 1];\n+            let this = self.borrows[read_idx];\n+            let should_keep = match this.perm() {\n+                // SharedReadWrite is the simplest case, if it's unreachable we can just remove it.\n+                Permission::SharedReadWrite => tags.contains(&this.tag()),\n+                // Only retain a Disabled tag if it is terminating a SharedReadWrite block.\n+                Permission::Disabled => left.perm() == Permission::SharedReadWrite,\n+                // Unique and SharedReadOnly can terminate a SharedReadWrite block, so only remove\n+                // them if they are both unreachable and not directly after a SharedReadWrite.\n+                Permission::Unique | Permission::SharedReadOnly =>\n+                    left.perm() == Permission::SharedReadWrite || tags.contains(&this.tag()),\n+            };\n+\n+            if should_keep {\n+                if read_idx != write_idx {\n+                    self.borrows[write_idx] = self.borrows[read_idx];\n+                }\n+                write_idx += 1;\n+            } else if first_removed.is_none() {\n+                first_removed = Some(read_idx);\n+            }\n+\n+            read_idx += 1;\n+        }\n+        self.borrows.truncate(write_idx);\n+\n+        #[cfg(not(feature = \"stack-cache\"))]\n+        drop(first_removed); // This is only needed for the stack-cache\n+\n+        #[cfg(feature = \"stack-cache\")]\n+        if let Some(first_removed) = first_removed {\n+            // Either end of unique_range may have shifted, all we really know is that we can't\n+            // have introduced a new Unique.\n+            if !self.unique_range.is_empty() {\n+                self.unique_range = 0..self.len();\n+            }\n+\n+            // Replace any Items which have been collected with the base item, a known-good value.\n+            for i in 0..CACHE_LEN {\n+                if self.cache.idx[i] >= first_removed {\n+                    self.cache.items[i] = self.borrows[0];\n+                    self.cache.idx[i] = 0;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// A very small cache of searches of a borrow stack, mapping `Item`s to their position in said stack.\n ///\n /// It may seem like maintaining this cache is a waste for small stacks, but\n@@ -105,14 +160,11 @@ impl<'tcx> Stack {\n \n         // Check that the unique_range is a valid index into the borrow stack.\n         // This asserts that the unique_range's start <= end.\n-        let uniques = &self.borrows[self.unique_range.clone()];\n+        let _uniques = &self.borrows[self.unique_range.clone()];\n \n-        // Check that the start of the unique_range is precise.\n-        if let Some(first_unique) = uniques.first() {\n-            assert_eq!(first_unique.perm(), Permission::Unique);\n-        }\n-        // We cannot assert that the unique range is exact on the upper end.\n-        // When we pop items within the unique range, setting the end of the range precisely\n+        // We cannot assert that the unique range is precise.\n+        // Both ends may shift around when `Stack::retain` is called. Additionally,\n+        // when we pop items within the unique range, setting the end of the range precisely\n         // requires doing a linear search of the borrow stack, which is exactly the kind of\n         // operation that all this caching exists to avoid.\n     }"}, {"sha": "0402e4d35dd512c24924adf0257b4e223d747c8d", "filename": "src/tag_gc.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d4c6af76e10a45cd743048d56f7c35d0b22ea/src%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftag_gc.rs?ref=d61d4c6af76e10a45cd743048d56f7c35d0b22ea", "patch": "@@ -0,0 +1,117 @@\n+use crate::*;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+    fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        // No reason to do anything at all if stacked borrows is off.\n+        if this.machine.stacked_borrows.is_none() {\n+            return Ok(());\n+        }\n+\n+        let mut tags = FxHashSet::default();\n+\n+        for thread in this.machine.threads.iter() {\n+            if let Some(Scalar::Ptr(\n+                Pointer { provenance: Provenance::Concrete { sb, .. }, .. },\n+                _,\n+            )) = thread.panic_payload\n+            {\n+                tags.insert(sb);\n+            }\n+        }\n+\n+        self.find_tags_in_tls(&mut tags);\n+        self.find_tags_in_memory(&mut tags);\n+        self.find_tags_in_locals(&mut tags)?;\n+\n+        self.remove_unreachable_tags(tags);\n+\n+        Ok(())\n+    }\n+\n+    fn find_tags_in_tls(&mut self, tags: &mut FxHashSet<SbTag>) {\n+        let this = self.eval_context_mut();\n+        this.machine.tls.iter(|scalar| {\n+            if let Scalar::Ptr(Pointer { provenance: Provenance::Concrete { sb, .. }, .. }, _) =\n+                scalar\n+            {\n+                tags.insert(*sb);\n+            }\n+        });\n+    }\n+\n+    fn find_tags_in_memory(&mut self, tags: &mut FxHashSet<SbTag>) {\n+        let this = self.eval_context_mut();\n+        this.memory.alloc_map().iter(|it| {\n+            for (_id, (_kind, alloc)) in it {\n+                for (_size, prov) in alloc.provenance().iter() {\n+                    if let Provenance::Concrete { sb, .. } = prov {\n+                        tags.insert(*sb);\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_tags_in_locals(&mut self, tags: &mut FxHashSet<SbTag>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for frame in this.machine.threads.all_stacks().flatten() {\n+            // Handle the return place of each frame\n+            if let Ok(return_place) = frame.return_place.try_as_mplace() {\n+                if let Some(Provenance::Concrete { sb, .. }) = return_place.ptr.provenance {\n+                    tags.insert(sb);\n+                }\n+            }\n+\n+            for local in frame.locals.iter() {\n+                let LocalValue::Live(value) = local.value else {\n+                continue;\n+            };\n+                match value {\n+                    Operand::Immediate(Immediate::Scalar(Scalar::Ptr(ptr, _))) =>\n+                        if let Provenance::Concrete { sb, .. } = ptr.provenance {\n+                            tags.insert(sb);\n+                        },\n+                    Operand::Immediate(Immediate::ScalarPair(s1, s2)) => {\n+                        if let Scalar::Ptr(ptr, _) = s1 {\n+                            if let Provenance::Concrete { sb, .. } = ptr.provenance {\n+                                tags.insert(sb);\n+                            }\n+                        }\n+                        if let Scalar::Ptr(ptr, _) = s2 {\n+                            if let Provenance::Concrete { sb, .. } = ptr.provenance {\n+                                tags.insert(sb);\n+                            }\n+                        }\n+                    }\n+                    Operand::Indirect(MemPlace { ptr, .. }) => {\n+                        if let Some(Provenance::Concrete { sb, .. }) = ptr.provenance {\n+                            tags.insert(sb);\n+                        }\n+                    }\n+                    Operand::Immediate(Immediate::Uninit)\n+                    | Operand::Immediate(Immediate::Scalar(Scalar::Int(_))) => {}\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn remove_unreachable_tags(&mut self, tags: FxHashSet<SbTag>) {\n+        let this = self.eval_context_mut();\n+        this.memory.alloc_map().iter(|it| {\n+            for (_id, (_kind, alloc)) in it {\n+                alloc\n+                    .extra\n+                    .stacked_borrows\n+                    .as_ref()\n+                    .unwrap()\n+                    .borrow_mut()\n+                    .remove_unreachable_tags(&tags);\n+            }\n+        });\n+    }\n+}"}]}