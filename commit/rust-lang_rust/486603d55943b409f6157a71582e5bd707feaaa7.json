{"sha": "486603d55943b409f6157a71582e5bd707feaaa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NjYwM2Q1NTk0M2I0MDlmNjE1N2E3MTU4MmU1YmQ3MDdmZWFhYTc=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-02T15:10:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-02T15:10:36Z"}, "message": "Show coerced types on type hover", "tree": {"sha": "951e884b174c23a3cc8963cef63dc2303f4e7946", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/951e884b174c23a3cc8963cef63dc2303f4e7946"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/486603d55943b409f6157a71582e5bd707feaaa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/486603d55943b409f6157a71582e5bd707feaaa7", "html_url": "https://github.com/rust-lang/rust/commit/486603d55943b409f6157a71582e5bd707feaaa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/486603d55943b409f6157a71582e5bd707feaaa7/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "432bb222c359a77de3d2bc170960a0bda6f2477f", "url": "https://api.github.com/repos/rust-lang/rust/commits/432bb222c359a77de3d2bc170960a0bda6f2477f", "html_url": "https://github.com/rust-lang/rust/commit/432bb222c359a77de3d2bc170960a0bda6f2477f"}], "stats": {"total": 193, "additions": 120, "deletions": 73}, "files": [{"sha": "e17bd9594cb2475fe969943b47a9ea700ab6bb9a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/486603d55943b409f6157a71582e5bd707feaaa7/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486603d55943b409f6157a71582e5bd707feaaa7/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=486603d55943b409f6157a71582e5bd707feaaa7", "patch": "@@ -225,7 +225,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.type_of_pat(pat)\n     }\n \n-    pub fn type_of_pat_with_coercion(&self, expr: &ast::Pat) -> Option<Type> {\n+    pub fn type_of_pat_with_coercion(&self, expr: &ast::Pat) -> Option<(Type, bool)> {\n         self.imp.type_of_pat_with_coercion(expr)\n     }\n \n@@ -577,7 +577,7 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(pat.syntax()).type_of_pat(self.db, pat)\n     }\n \n-    fn type_of_pat_with_coercion(&self, pat: &ast::Pat) -> Option<Type> {\n+    fn type_of_pat_with_coercion(&self, pat: &ast::Pat) -> Option<(Type, bool)> {\n         self.analyze(pat.syntax()).type_of_pat_with_coercion(self.db, pat)\n     }\n "}, {"sha": "e18d27e722deca9c1c458bc8285a02f89f3819de", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/486603d55943b409f6157a71582e5bd707feaaa7/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486603d55943b409f6157a71582e5bd707feaaa7/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=486603d55943b409f6157a71582e5bd707feaaa7", "patch": "@@ -147,15 +147,15 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         pat: &ast::Pat,\n-    ) -> Option<Type> {\n+    ) -> Option<(Type, bool)> {\n         let pat_id = self.pat_id(pat)?;\n         let infer = self.infer.as_ref()?;\n-        let ty = infer\n+        let (ty, coerced) = infer\n             .pat_adjustments\n             .get(&pat_id)\n-            .and_then(|adjusts| adjusts.last().map(|adjust| &adjust.target))\n-            .unwrap_or_else(|| &infer[pat_id]);\n-        Type::new_with_resolver(db, &self.resolver, ty.clone())\n+            .and_then(|adjusts| adjusts.last().map(|adjust| (&adjust.target, true)))\n+            .unwrap_or_else(|| (&infer[pat_id], false));\n+        Type::new_with_resolver(db, &self.resolver, ty.clone()).zip(Some(coerced))\n     }\n \n     pub(crate) fn type_of_self("}, {"sha": "79541ac134954b06f4b9d1bfee27841d63917cec", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 113, "deletions": 66, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/486603d55943b409f6157a71582e5bd707feaaa7/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486603d55943b409f6157a71582e5bd707feaaa7/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=486603d55943b409f6157a71582e5bd707feaaa7", "patch": "@@ -79,43 +79,27 @@ pub struct HoverResult {\n // image::https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif[]\n pub(crate) fn hover(\n     db: &RootDatabase,\n-    range: FileRange,\n+    FileRange { file_id, range }: FileRange,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     let sema = hir::Semantics::new(db);\n-    let file = sema.parse(range.file_id).syntax().clone();\n+    let file = sema.parse(file_id).syntax().clone();\n \n-    // This means we're hovering over a range.\n-    if !range.range.is_empty() {\n-        let expr = find_node_at_range::<ast::Expr>(&file, range.range)?;\n-        let ty = sema.type_of_expr(&expr)?;\n-\n-        if ty.is_unknown() {\n-            return None;\n-        }\n-\n-        let mut res = HoverResult::default();\n-\n-        res.markup = if config.markdown() {\n-            Markup::fenced_block(&ty.display(db))\n-        } else {\n-            ty.display(db).to_string().into()\n-        };\n-\n-        return Some(RangeInfo::new(range.range, res));\n-    }\n+    let offset = if range.is_empty() {\n+        range.start()\n+    } else {\n+        let expr = find_node_at_range::<ast::Expr>(&file, range).map(Either::Left)?;\n+        return hover_type_info(&sema, config, expr).map(|it| RangeInfo::new(range, it));\n+    };\n \n-    let position = FilePosition { file_id: range.file_id, offset: range.range.start() };\n-    let token = pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n+    let token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n         IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] => 3,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n     })?;\n     let token = sema.descend_into_macros(token);\n \n-    let mut res = HoverResult::default();\n-\n     let node = token.parent()?;\n     let mut range = None;\n     let definition = match_ast! {\n@@ -146,8 +130,8 @@ pub(crate) fn hover(\n                     let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n                     let (idl_range, link, ns) =\n                         extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n-                            let hir::InFile { file_id, value: mapped_range } = doc_mapping.map(range)?;\n-                            (file_id == position.file_id.into() && mapped_range.contains(position.offset)).then(||(mapped_range, link, ns))\n+                            let mapped = doc_mapping.map(range)?;\n+                            (mapped.file_id == file_id.into() && mapped.value.contains(offset)).then(||(mapped.value, link, ns))\n                         })?;\n                     range = Some(idl_range);\n                     resolve_doc_path_for_def(db, def, &link, ns).map(Definition::ModuleDef)\n@@ -173,6 +157,7 @@ pub(crate) fn hover(\n             _ => None,\n         };\n         if let Some(markup) = hover_for_definition(db, definition, famous_defs.as_ref(), config) {\n+            let mut res = HoverResult::default();\n             res.markup = process_markup(sema.db, definition, &markup, config);\n             if let Some(action) = show_implementations_action(db, definition) {\n                 res.actions.push(action);\n@@ -182,7 +167,7 @@ pub(crate) fn hover(\n                 res.actions.push(action);\n             }\n \n-            if let Some(action) = runnable_action(&sema, definition, position.file_id) {\n+            if let Some(action) = runnable_action(&sema, definition, file_id) {\n                 res.actions.push(action);\n             }\n \n@@ -204,27 +189,59 @@ pub(crate) fn hover(\n         .take_while(|it| !ast::Item::can_cast(it.kind()))\n         .find(|n| ast::Expr::can_cast(n.kind()) || ast::Pat::can_cast(n.kind()))?;\n \n-    let ty = match_ast! {\n+    let expr_or_pat = match_ast! {\n         match node {\n-            ast::Expr(it) => sema.type_of_expr(&it)?,\n-            ast::Pat(it) => sema.type_of_pat(&it)?,\n+            ast::Expr(it) => Either::Left(it),\n+            ast::Pat(it) => Either::Right(it),\n             // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n             // (e.g expanding a builtin macro). So we give up here.\n             ast::MacroCall(_it) => return None,\n             _ => return None,\n         }\n     };\n \n-    res.markup = if config.markdown() {\n-        Markup::fenced_block(&ty.display(db))\n-    } else {\n-        ty.display(db).to_string().into()\n-    };\n-\n+    let res = hover_type_info(&sema, config, expr_or_pat)?;\n     let range = sema.original_range(&node).range;\n     Some(RangeInfo::new(range, res))\n }\n \n+fn hover_type_info(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    expr_or_pat: Either<ast::Expr, ast::Pat>,\n+) -> Option<HoverResult> {\n+    let (ty, coerced) = match &expr_or_pat {\n+        Either::Left(expr) => sema.type_of_expr_with_coercion(expr)?,\n+        Either::Right(pat) => sema.type_of_pat_with_coercion(pat)?,\n+    };\n+\n+    let mut res = HoverResult::default();\n+    res.markup = if coerced {\n+        let uncoerced_ty = match &expr_or_pat {\n+            Either::Left(expr) => sema.type_of_expr(expr)?,\n+            Either::Right(pat) => sema.type_of_pat(pat)?,\n+        };\n+        let uncoerced = uncoerced_ty.display(sema.db).to_string();\n+        let coerced = ty.display(sema.db).to_string();\n+        format!(\n+            \"```text\\nType: {:>upad$}\\nCoerced to: {:>cpad$}\\n```\\n\",\n+            uncoerced = uncoerced,\n+            coerced = coerced,\n+            // 6 base padding for static text prefix of each line\n+            upad = 6 + coerced.len().max(uncoerced.len()),\n+            cpad = uncoerced.len(),\n+        )\n+        .into()\n+    } else {\n+        if config.markdown() {\n+            Markup::fenced_block(&ty.display(sema.db))\n+        } else {\n+            ty.display(sema.db).to_string().into()\n+        }\n+    };\n+    Some(res)\n+}\n+\n fn try_hover_for_lint(attr: &ast::Attr, token: &SyntaxToken) -> Option<RangeInfo<HoverResult>> {\n     let (path, tt) = attr.as_simple_call()?;\n     if !tt.syntax().text_range().contains(token.text_range().start()) {\n@@ -1189,7 +1206,7 @@ impl Thing {\n }\n \n fn main() { let foo_$0test = Thing::new(); }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo_test*\n \n@@ -1559,7 +1576,7 @@ fn foo() {\n             fn foo() {\n                 format!(\"hel$0lo {}\", 0);\n             }\n-            \"#,\n+\"#,\n         );\n     }\n \n@@ -1667,7 +1684,7 @@ extern crate st$0d;\n //!\n //! Printed?\n //! abc123\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *std*\n \n@@ -1692,7 +1709,7 @@ extern crate std as ab$0c;\n //!\n //! Printed?\n //! abc123\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *abc*\n \n@@ -2211,7 +2228,7 @@ mod tests$0 {\n struct S{ f1: u32 }\n \n fn main() { let s$0t = S{ f1:0 }; }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n@@ -2290,7 +2307,7 @@ struct Arg(u32);\n struct S<T>{ f1: T }\n \n fn main() { let s$0t = S{ f1: S{ f1: Arg(0) } }; }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n@@ -2479,7 +2496,7 @@ trait Bar {}\n fn foo() -> impl Foo + Bar {}\n \n fn main() { let s$0t = foo(); }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n@@ -2912,7 +2929,7 @@ struct B<T> {}\n struct S {}\n \n fn foo(a$0rg: &impl ImplTrait<B<dyn DynTrait<B<S>>>>) {}\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n@@ -3708,7 +3725,7 @@ mod string {\n     /// This is `alloc::String`.\n     pub struct String;\n }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *String*\n \n@@ -3827,7 +3844,7 @@ pub fn foo() {}\n //- /lib.rs crate:main.rs deps:foo\n #[fo$0o::bar()]\n struct Foo;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3843,7 +3860,7 @@ struct Foo;\n         check(\n             r#\"\n use self as foo$0;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3856,7 +3873,7 @@ use self as foo$0;\n             r#\"\n mod bar {}\n use bar::{self as foo$0};\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3874,7 +3891,7 @@ use bar::{self as foo$0};\n mod bar {\n     use super as foo$0;\n }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3886,7 +3903,7 @@ mod bar {\n         check(\n             r#\"\n use crate as foo$0;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3905,7 +3922,7 @@ use crate as foo$0;\n pub macro Copy {}\n #[derive(Copy$0)]\n struct Foo;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *Copy*\n \n@@ -3926,7 +3943,7 @@ mod foo {\n }\n #[derive(foo::Copy$0)]\n struct Foo;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *Copy*\n \n@@ -3946,7 +3963,7 @@ struct Foo;\n         check_hover_range(\n             r#\"\n fn f() { let expr = $01 + 2 * 3$0 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             i32\n@@ -3956,7 +3973,7 @@ fn f() { let expr = $01 + 2 * 3$0 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = 1 $0+ 2 * $03 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             i32\n@@ -3966,7 +3983,7 @@ fn f() { let expr = 1 $0+ 2 * $03 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = 1 + $02 * 3$0 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             i32\n@@ -3979,7 +3996,7 @@ fn f() { let expr = 1 + $02 * 3$0 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = $0[1, 2, 3, 4]$0 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             [i32; 4]\n@@ -3989,7 +4006,7 @@ fn f() { let expr = $0[1, 2, 3, 4]$0 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = [1, 2, $03, 4]$0 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             [i32; 4]\n@@ -3999,7 +4016,7 @@ fn f() { let expr = [1, 2, $03, 4]$0 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = [1, 2, $03$0, 4] }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             i32\n@@ -4013,7 +4030,7 @@ fn f() { let expr = [1, 2, $03$0, 4] }\n             r#\"\n fn f<T>(a: &[T]) { }\n fn b() { $0f$0(&[1, 2, 3, 4, 5]); }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             fn f<i32>(&[i32])\n@@ -4024,7 +4041,7 @@ fn b() { $0f$0(&[1, 2, 3, 4, 5]); }\n             r#\"\n fn f<T>(a: &[T]) { }\n fn b() { f($0&[1, 2, 3, 4, 5]$0); }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             &[i32; 5]\n@@ -4038,20 +4055,20 @@ fn b() { f($0&[1, 2, 3, 4, 5]$0); }\n             r#\"\n fn f<T>(a: &[T]) { }\n fn b()$0 { f(&[1, 2, 3, 4, 5]); }$0\n-            \"#,\n+\"#,\n         );\n \n         check_hover_range_no_results(\n             r#\"\n fn f<T>$0(a: &[T]) { }\n fn b() { f(&[1, 2, 3,$0 4, 5]); }\n-            \"#,\n+\"#,\n         );\n \n         check_hover_range_no_results(\n             r#\"\n fn $0f() { let expr = [1, 2, 3, 4]$0 }\n-            \"#,\n+\"#,\n         );\n     }\n \n@@ -4061,7 +4078,7 @@ fn $0f() { let expr = [1, 2, 3, 4]$0 }\n             r#\"\n fn f<T>(a: &[T]) { }\n fn b() { $0f(&[1, 2, 3, 4, 5]); }$0\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             ()\n@@ -4071,11 +4088,41 @@ fn b() { $0f(&[1, 2, 3, 4, 5]); }$0\n         check_hover_range(\n             r#\"\n fn f() { let expr$0 = $0[1, 2, 3, 4] }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             ()\n             ```\"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_range_shows_coercions_if_applicable() {\n+        check_hover_range(\n+            r#\"\n+fn foo() {\n+    let x: &u32 = $0&&&&&0$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```\n+                Type:       &&&&&u32\n+                Coerced to:     &u32\n+                ```\n+            \"#]],\n+        );\n+        check_hover_range(\n+            r#\"\n+fn foo() {\n+    let x: *const u32 = $0&0$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```\n+                Type:             &u32\n+                Coerced to: *const u32\n+                ```\n+            \"#]],\n+        );\n+    }\n }"}]}