{"sha": "85fdb34d3acf631d36d493a65d45b7bd7571e55d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZmRiMzRkM2FjZjYzMWQzNmQ0OTNhNjVkNDViN2JkNzU3MWU1NWQ=", "commit": {"author": {"name": "Nadrieril", "email": "Nadrieril@users.noreply.github.com", "date": "2020-12-22T06:09:54Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:24Z"}, "message": "Apply suggestions from code review\n\nCo-authored-by: varkor <github@varkor.com>", "tree": {"sha": "39fd144d6722378f77c5bbda793dd4da3a7d9141", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39fd144d6722378f77c5bbda793dd4da3a7d9141"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85fdb34d3acf631d36d493a65d45b7bd7571e55d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85fdb34d3acf631d36d493a65d45b7bd7571e55d", "html_url": "https://github.com/rust-lang/rust/commit/85fdb34d3acf631d36d493a65d45b7bd7571e55d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85fdb34d3acf631d36d493a65d45b7bd7571e55d/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1", "html_url": "https://github.com/rust-lang/rust/commit/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1"}], "stats": {"total": 29, "additions": 15, "deletions": 14}, "files": [{"sha": "d79dd97a69a75a61e1300ea5b24493f055e55855", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85fdb34d3acf631d36d493a65d45b7bd7571e55d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fdb34d3acf631d36d493a65d45b7bd7571e55d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=85fdb34d3acf631d36d493a65d45b7bd7571e55d", "patch": "@@ -451,7 +451,7 @@ impl Slice {\n ///\n /// A slice pattern `[x, .., y]` behaves like the infinite or-pattern `[x, y] | [x, _, y] | [x, _,\n /// _, y] | ...`. The corresponding value constructors are fixed-length array constructors above a\n-/// given minimum length. We obviously can't list all of this infinity of constructors. Thankfully,\n+/// given minimum length. We obviously can't list this infinitude of constructors. Thankfully,\n /// it turns out that for each finite set of slice patterns, all sufficiently large array lengths\n /// are equivalent.\n ///\n@@ -491,7 +491,7 @@ impl Slice {\n /// middle. This means that the set of witnesses for length `l >= 5` if equivalent to the set for\n /// any other `l' >= 5`: simply add or remove wildcards in the middle to convert between them.\n ///\n-/// This applies to any set of slice patterns: there will be a length `L` above which all length\n+/// This applies to any set of slice patterns: there will be a length `L` above which all lengths\n /// behave the same. This is exactly what we need for constructor splitting. Therefore a\n /// variable-length slice can be split into a variable-length slice of minimal length `L`, and many\n /// fixed-length slices of lengths `< L`.\n@@ -736,8 +736,8 @@ impl<'tcx> Constructor<'tcx> {\n             // ranges check.\n             IntRange(ctor_range) if !ctor_range.is_singleton() => {\n                 let mut split_range = SplitIntRange::new(ctor_range.clone());\n-                let intranges = ctors.filter_map(|ctor| ctor.as_int_range());\n-                split_range.split(intranges.cloned());\n+                let int_ranges = ctors.filter_map(|ctor| ctor.as_int_range());\n+                split_range.split(int_ranges.cloned());\n                 split_range.iter().map(IntRange).collect()\n             }\n             &Slice(Slice { kind: VarLen(self_prefix, self_suffix), array_len }) => {\n@@ -1080,7 +1080,7 @@ impl<'p, 'tcx> FilteredField<'p, 'tcx> {\n ///\n /// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n /// uninhabited. For that, we filter these fields out of the matrix. This is handled automatically\n-/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rare used,\n+/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rarely used,\n /// so we avoid it when possible to preserve performance.\n #[derive(Debug, Clone)]\n pub(super) enum Fields<'p, 'tcx> {"}, {"sha": "803ffc0885e688195e63df6901d8c2a3690f2013", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85fdb34d3acf631d36d493a65d45b7bd7571e55d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fdb34d3acf631d36d493a65d45b7bd7571e55d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=85fdb34d3acf631d36d493a65d45b7bd7571e55d", "patch": "@@ -19,21 +19,21 @@\n //!\n //! The algorithm implemented here is a modified version of the one described in [this\n //! paper](http://moscova.inria.fr/~maranget/papers/warn/index.html). We have however generalized\n-//! it to accomodate the variety of patterns that rust supports. We thus explain our version here,\n+//! it to accommodate the variety of patterns that Rust supports. We thus explain our version here,\n //! without being as rigorous.\n //!\n //!\n //! # Summary\n //!\n //! The core of the algorithm is the notion of \"usefulness\". A pattern `q` is said to be *useful*\n //! relative to another pattern `p` of the same type if there is a value that is matched by `q` and\n-//! not matched by `p`. This generalizes to many `p`s: `q` is useful wrt a list of patterns `p_1 ..\n-//! p_n` if there is a value that is matched by `q` and by none of the `p_i`. We write\n+//! not matched by `p`. This generalizes to many `p`s: `q` is useful w.r.t. a list of patterns\n+//! `p_1 .. p_n` if there is a value that is matched by `q` and by none of the `p_i`. We write\n //! `usefulness(p_1 .. p_n, q)` for a function that returns a list of such values. The aim of this\n //! file is to compute it efficiently.\n //!\n //! This is enough to compute reachability: a pattern in a `match` expression is reachable iff it\n-//! is useful wrt the patterns above it:\n+//! is useful w.r.t. the patterns above it:\n //! ```rust\n //! match x {\n //!     Some(_) => ...,\n@@ -44,8 +44,8 @@\n //! ```\n //!\n //! This is also enough to compute exhaustiveness: a match is exhaustive iff the wildcard `_`\n-//! pattern is _not_ useful wrt the patterns in the match. The values returned by `usefulness` are\n-//! used to tell the user which values are missing.\n+//! pattern is _not_ useful w.r.t. the patterns in the match. The values returned by `usefulness`\n+//! are used to tell the user which values are missing.\n //! ```rust\n //! match x {\n //!     Some(0) => ...,\n@@ -102,7 +102,7 @@\n //!\n //! Note: this constructors/fields distinction may not straightforwardly apply to every Rust type.\n //! For example a value of type `Rc<u64>` can't be deconstructed that way, and `&str` has an\n-//! infinity of constructors. There are also subtleties with visibility of fields and\n+//! infinitude of constructors. There are also subtleties with visibility of fields and\n //! uninhabitedness and various other things. The constructors idea can be extended to handle most\n //! of these subtleties though; caveats are documented where relevant throughout the code.\n //!\n@@ -184,7 +184,8 @@\n //!\n //!   `specialize(c, p0 | p1) := specialize(c, p0) ++ specialize(c, p1)`\n //!\n-//! - We treat the other pattern constructors lik big or-patterns of all the possibilities:\n+//! - We treat the other pattern constructors as if they were a large or-pattern of all the\n+//!   possibilities:\n //!\n //!   `specialize(c, _) := specialize(c, Variant1(_) | Variant2(_, _) | ...)`\n //!\n@@ -193,7 +194,7 @@\n //!   `specialize(c, [p0, .., p1]) := specialize(c, [p0, p1] | [p0, _, p1] | [p0, _, _, p1] | ...)`\n //!\n //! - If `c` is a pattern-only constructor, `specialize` is defined on a case-by-case basis. See\n-//!   the discussion abount constructor splitting in [`super::deconstruct_pat`].\n+//!   the discussion about constructor splitting in [`super::deconstruct_pat`].\n //!\n //!\n //! We then extend this function to work with pattern-stacks as input, by acting on the first"}]}