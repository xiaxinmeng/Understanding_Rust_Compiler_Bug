{"sha": "54151a6afc1e3e5b7894da0635084ad35fc7d3c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MTUxYTZhZmMxZTNlNWI3ODk0ZGEwNjM1MDg0YWQzNWZjN2QzYzI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-14T00:30:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-14T00:30:48Z"}, "message": "Rollup merge of #77897 - GuillaumeGomez:cleanup-passes-mod, r=jyn514\n\nMove `Strip` into a separate rustdoc pass\n\nJust something which was bothering me lately. :)\n\nr? @jyn514", "tree": {"sha": "e84810cd95dc8840d760e886e2e05b9744ecfd94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e84810cd95dc8840d760e886e2e05b9744ecfd94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54151a6afc1e3e5b7894da0635084ad35fc7d3c2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfhka5CRBK7hj4Ov3rIwAAdHIIAAlB2Y7jNgm2aFnAYhrMe6JT\nizODROKsmJ5KotKYKIl3cY3oOd2KjbbqrP2h11NdoW2niJynNJalikMKgxP9TCrb\ny+tg5BUlGTjem5lxdJNMpRVvXXXTPmnlhfeL3WPPaf5Ksh3kBIShey3OLMmO1JAt\n91qODVtfNkMxM9YTl5Lyu1hKIqeSd7ebiM7MqH/55BYU7ViHpwQLAeYNc2hJxoso\nqHXD76agBmxOUR7RrbHGhLh5bJouTZJqPj/9/R3qabejTIfoYlsY2L3vv42uINEF\nkENwVeDPRmD1Wl0zHJTeIuu550C/59Y9eOGYUmpDaB4zLrLvfTLh11QH3bx7bdc=\n=iP7M\n-----END PGP SIGNATURE-----\n", "payload": "tree e84810cd95dc8840d760e886e2e05b9744ecfd94\nparent ed34f82cbc9d293b63cc67a68e067d5e5a55403f\nparent 7beeb07c1e3c7d022373648ac54937dbebb2ed43\nauthor Dylan DPC <dylan.dpc@gmail.com> 1602635448 +0200\ncommitter GitHub <noreply@github.com> 1602635448 +0200\n\nRollup merge of #77897 - GuillaumeGomez:cleanup-passes-mod, r=jyn514\n\nMove `Strip` into a separate rustdoc pass\n\nJust something which was bothering me lately. :)\n\nr? @jyn514\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54151a6afc1e3e5b7894da0635084ad35fc7d3c2", "html_url": "https://github.com/rust-lang/rust/commit/54151a6afc1e3e5b7894da0635084ad35fc7d3c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54151a6afc1e3e5b7894da0635084ad35fc7d3c2/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed34f82cbc9d293b63cc67a68e067d5e5a55403f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed34f82cbc9d293b63cc67a68e067d5e5a55403f", "html_url": "https://github.com/rust-lang/rust/commit/ed34f82cbc9d293b63cc67a68e067d5e5a55403f"}, {"sha": "7beeb07c1e3c7d022373648ac54937dbebb2ed43", "url": "https://api.github.com/repos/rust-lang/rust/commits/7beeb07c1e3c7d022373648ac54937dbebb2ed43", "html_url": "https://github.com/rust-lang/rust/commit/7beeb07c1e3c7d022373648ac54937dbebb2ed43"}], "stats": {"total": 346, "additions": 176, "deletions": 170}, "files": [{"sha": "2591650e3f97fa5359f75e99501b84638e81cd28", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 4, "deletions": 170, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/54151a6afc1e3e5b7894da0635084ad35fc7d3c2/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54151a6afc1e3e5b7894da0635084ad35fc7d3c2/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=54151a6afc1e3e5b7894da0635084ad35fc7d3c2", "patch": "@@ -1,16 +1,15 @@\n //! Contains information about \"passes\", used to modify crate information during the documentation\n //! process.\n \n-use rustc_hir::def_id::{DefId, DefIdSet};\n-use rustc_middle::middle::privacy::AccessLevels;\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n-use std::mem;\n use std::ops::Range;\n \n use self::Condition::*;\n-use crate::clean::{self, DocFragmentKind, GetDefId, Item};\n+use crate::clean::{self, DocFragmentKind};\n use crate::core::DocContext;\n-use crate::fold::{DocFolder, StripItem};\n+\n+mod stripper;\n+pub use stripper::*;\n \n mod collapse_docs;\n pub use self::collapse_docs::COLLAPSE_DOCS;\n@@ -149,171 +148,6 @@ pub fn find_pass(pass_name: &str) -> Option<Pass> {\n     PASSES.iter().find(|p| p.name == pass_name).copied()\n }\n \n-struct Stripper<'a> {\n-    retained: &'a mut DefIdSet,\n-    access_levels: &'a AccessLevels<DefId>,\n-    update_retained: bool,\n-}\n-\n-impl<'a> DocFolder for Stripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::StrippedItem(..) => {\n-                // We need to recurse into stripped modules to strip things\n-                // like impl methods but when doing so we must not add any\n-                // items to the `retained` set.\n-                debug!(\"Stripper: recursing into stripped {:?} {:?}\", i.type_(), i.name);\n-                let old = mem::replace(&mut self.update_retained, false);\n-                let ret = self.fold_item_recur(i);\n-                self.update_retained = old;\n-                return ret;\n-            }\n-            // These items can all get re-exported\n-            clean::OpaqueTyItem(..)\n-            | clean::TypedefItem(..)\n-            | clean::StaticItem(..)\n-            | clean::StructItem(..)\n-            | clean::EnumItem(..)\n-            | clean::TraitItem(..)\n-            | clean::FunctionItem(..)\n-            | clean::VariantItem(..)\n-            | clean::MethodItem(..)\n-            | clean::ForeignFunctionItem(..)\n-            | clean::ForeignStaticItem(..)\n-            | clean::ConstantItem(..)\n-            | clean::UnionItem(..)\n-            | clean::AssocConstItem(..)\n-            | clean::TraitAliasItem(..)\n-            | clean::ForeignTypeItem => {\n-                if i.def_id.is_local() {\n-                    if !self.access_levels.is_exported(i.def_id) {\n-                        debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n-                        return None;\n-                    }\n-                }\n-            }\n-\n-            clean::StructFieldItem(..) => {\n-                if i.visibility != clean::Public {\n-                    return StripItem(i).strip();\n-                }\n-            }\n-\n-            clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != clean::Public {\n-                    debug!(\"Stripper: stripping module {:?}\", i.name);\n-                    let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n-                    self.update_retained = old;\n-                    return ret;\n-                }\n-            }\n-\n-            // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n-\n-            clean::ImplItem(..) => {}\n-\n-            // tymethods/macros have no control over privacy\n-            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n-\n-            // Proc-macros are always public\n-            clean::ProcMacroItem(..) => {}\n-\n-            // Primitives are never stripped\n-            clean::PrimitiveItem(..) => {}\n-\n-            // Associated types are never stripped\n-            clean::AssocTypeItem(..) => {}\n-\n-            // Keywords are never stripped\n-            clean::KeywordItem(..) => {}\n-        }\n-\n-        let fastreturn = match i.inner {\n-            // nothing left to do for traits (don't want to filter their\n-            // methods out, visibility controlled by the trait)\n-            clean::TraitItem(..) => true,\n-\n-            // implementations of traits are always public.\n-            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-            // Struct variant fields have inherited visibility\n-            clean::VariantItem(clean::Variant { kind: clean::VariantKind::Struct(..) }) => true,\n-            _ => false,\n-        };\n-\n-        let i = if fastreturn {\n-            if self.update_retained {\n-                self.retained.insert(i.def_id);\n-            }\n-            return Some(i);\n-        } else {\n-            self.fold_item_recur(i)\n-        };\n-\n-        if let Some(ref i) = i {\n-            if self.update_retained {\n-                self.retained.insert(i.def_id);\n-            }\n-        }\n-        i\n-    }\n-}\n-\n-// This stripper discards all impls which reference stripped items\n-struct ImplStripper<'a> {\n-    retained: &'a DefIdSet,\n-}\n-\n-impl<'a> DocFolder for ImplStripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if let clean::ImplItem(ref imp) = i.inner {\n-            // emptied none trait impls can be stripped\n-            if imp.trait_.is_none() && imp.items.is_empty() {\n-                return None;\n-            }\n-            if let Some(did) = imp.for_.def_id() {\n-                if did.is_local() && !imp.for_.is_generic() && !self.retained.contains(&did) {\n-                    debug!(\"ImplStripper: impl item for stripped type; removing\");\n-                    return None;\n-                }\n-            }\n-            if let Some(did) = imp.trait_.def_id() {\n-                if did.is_local() && !self.retained.contains(&did) {\n-                    debug!(\"ImplStripper: impl item for stripped trait; removing\");\n-                    return None;\n-                }\n-            }\n-            if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n-                for typaram in generics {\n-                    if let Some(did) = typaram.def_id() {\n-                        if did.is_local() && !self.retained.contains(&did) {\n-                            debug!(\n-                                \"ImplStripper: stripped item in trait's generics; removing impl\"\n-                            );\n-                            return None;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        self.fold_item_recur(i)\n-    }\n-}\n-\n-// This stripper discards all private import statements (`use`, `extern crate`)\n-struct ImportStripper;\n-impl DocFolder for ImportStripper {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::ExternCrateItem(..) | clean::ImportItem(..) if i.visibility != clean::Public => {\n-                None\n-            }\n-            _ => self.fold_item_recur(i),\n-        }\n-    }\n-}\n-\n /// Returns a span encompassing all the given attributes.\n crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n     if attrs.doc_strings.is_empty() {"}, {"sha": "9b4f62235f5e8c3457e12a31f62f76077409c936", "filename": "src/librustdoc/passes/stripper.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/54151a6afc1e3e5b7894da0635084ad35fc7d3c2/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54151a6afc1e3e5b7894da0635084ad35fc7d3c2/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=54151a6afc1e3e5b7894da0635084ad35fc7d3c2", "patch": "@@ -0,0 +1,172 @@\n+use rustc_hir::def_id::{DefId, DefIdSet};\n+use rustc_middle::middle::privacy::AccessLevels;\n+use std::mem;\n+\n+use crate::clean::{self, GetDefId, Item};\n+use crate::fold::{DocFolder, StripItem};\n+\n+pub struct Stripper<'a> {\n+    pub retained: &'a mut DefIdSet,\n+    pub access_levels: &'a AccessLevels<DefId>,\n+    pub update_retained: bool,\n+}\n+\n+impl<'a> DocFolder for Stripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::StrippedItem(..) => {\n+                // We need to recurse into stripped modules to strip things\n+                // like impl methods but when doing so we must not add any\n+                // items to the `retained` set.\n+                debug!(\"Stripper: recursing into stripped {:?} {:?}\", i.type_(), i.name);\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = self.fold_item_recur(i);\n+                self.update_retained = old;\n+                return ret;\n+            }\n+            // These items can all get re-exported\n+            clean::OpaqueTyItem(..)\n+            | clean::TypedefItem(..)\n+            | clean::StaticItem(..)\n+            | clean::StructItem(..)\n+            | clean::EnumItem(..)\n+            | clean::TraitItem(..)\n+            | clean::FunctionItem(..)\n+            | clean::VariantItem(..)\n+            | clean::MethodItem(..)\n+            | clean::ForeignFunctionItem(..)\n+            | clean::ForeignStaticItem(..)\n+            | clean::ConstantItem(..)\n+            | clean::UnionItem(..)\n+            | clean::AssocConstItem(..)\n+            | clean::TraitAliasItem(..)\n+            | clean::ForeignTypeItem => {\n+                if i.def_id.is_local() {\n+                    if !self.access_levels.is_exported(i.def_id) {\n+                        debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n+                        return None;\n+                    }\n+                }\n+            }\n+\n+            clean::StructFieldItem(..) => {\n+                if i.visibility != clean::Public {\n+                    return StripItem(i).strip();\n+                }\n+            }\n+\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != clean::Public {\n+                    debug!(\"Stripper: stripping module {:?}\", i.name);\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n+                    self.update_retained = old;\n+                    return ret;\n+                }\n+            }\n+\n+            // handled in the `strip-priv-imports` pass\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n+\n+            clean::ImplItem(..) => {}\n+\n+            // tymethods/macros have no control over privacy\n+            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n+\n+            // Proc-macros are always public\n+            clean::ProcMacroItem(..) => {}\n+\n+            // Primitives are never stripped\n+            clean::PrimitiveItem(..) => {}\n+\n+            // Associated types are never stripped\n+            clean::AssocTypeItem(..) => {}\n+\n+            // Keywords are never stripped\n+            clean::KeywordItem(..) => {}\n+        }\n+\n+        let fastreturn = match i.inner {\n+            // nothing left to do for traits (don't want to filter their\n+            // methods out, visibility controlled by the trait)\n+            clean::TraitItem(..) => true,\n+\n+            // implementations of traits are always public.\n+            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n+            // Struct variant fields have inherited visibility\n+            clean::VariantItem(clean::Variant { kind: clean::VariantKind::Struct(..) }) => true,\n+            _ => false,\n+        };\n+\n+        let i = if fastreturn {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+            return Some(i);\n+        } else {\n+            self.fold_item_recur(i)\n+        };\n+\n+        if let Some(ref i) = i {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+        }\n+        i\n+    }\n+}\n+\n+/// This stripper discards all impls which reference stripped items\n+pub struct ImplStripper<'a> {\n+    pub retained: &'a DefIdSet,\n+}\n+\n+impl<'a> DocFolder for ImplStripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        if let clean::ImplItem(ref imp) = i.inner {\n+            // emptied none trait impls can be stripped\n+            if imp.trait_.is_none() && imp.items.is_empty() {\n+                return None;\n+            }\n+            if let Some(did) = imp.for_.def_id() {\n+                if did.is_local() && !imp.for_.is_generic() && !self.retained.contains(&did) {\n+                    debug!(\"ImplStripper: impl item for stripped type; removing\");\n+                    return None;\n+                }\n+            }\n+            if let Some(did) = imp.trait_.def_id() {\n+                if did.is_local() && !self.retained.contains(&did) {\n+                    debug!(\"ImplStripper: impl item for stripped trait; removing\");\n+                    return None;\n+                }\n+            }\n+            if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n+                for typaram in generics {\n+                    if let Some(did) = typaram.def_id() {\n+                        if did.is_local() && !self.retained.contains(&did) {\n+                            debug!(\n+                                \"ImplStripper: stripped item in trait's generics; removing impl\"\n+                            );\n+                            return None;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+/// This stripper discards all private import statements (`use`, `extern crate`)\n+pub struct ImportStripper;\n+\n+impl DocFolder for ImportStripper {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) if i.visibility != clean::Public => {\n+                None\n+            }\n+            _ => self.fold_item_recur(i),\n+        }\n+    }\n+}"}]}