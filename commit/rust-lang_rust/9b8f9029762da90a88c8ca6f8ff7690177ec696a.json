{"sha": "9b8f9029762da90a88c8ca6f8ff7690177ec696a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOGY5MDI5NzYyZGE5MGE4OGM4Y2E2ZjhmZjc2OTAxNzdlYzY5NmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-11T03:44:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-11T03:44:16Z"}, "message": "Auto merge of #54993 - TimNN:pda-tdl, r=eddyb\n\nSupport for the program data address space option of LLVM's Target Datalayout\n\nThis was introduced recently (specifically, for AVR, cc @dylanmckay).\n\n(I came up with this when attempting to run [avr-rust](https://github.com/avr-rust/rust) rebased on the latest [rust-lang](https://github.com/rust-lang/rust) commits. If this requires a different design, some additional discussions, or is not something to pursue right now, I'd be happy to close this PR).\n\nNote that this somewhat overlaps with @DiamondLovesYou's #51576, I think, although the implementation here is significantly simpler: Since the address space applies to _all_ program data, we can just check the pointee's type whenever we create an LLVM pointer type. If it is a function we use the program data address space; if not we use the default address space.\n\ncc @eddyb, who has been reviewing #51576\n\nRef: https://llvm.org/docs/LangRef.html#data-layout", "tree": {"sha": "56bdc1e737f0b9e7c471a20d1a571506d663aa71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56bdc1e737f0b9e7c471a20d1a571506d663aa71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b8f9029762da90a88c8ca6f8ff7690177ec696a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b8f9029762da90a88c8ca6f8ff7690177ec696a", "html_url": "https://github.com/rust-lang/rust/commit/9b8f9029762da90a88c8ca6f8ff7690177ec696a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b8f9029762da90a88c8ca6f8ff7690177ec696a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6408162ea13446852cb45d9e781e64ba85ec7bb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6408162ea13446852cb45d9e781e64ba85ec7bb1", "html_url": "https://github.com/rust-lang/rust/commit/6408162ea13446852cb45d9e781e64ba85ec7bb1"}, {"sha": "50a2d47b4f57f8f9433b18692fe2d1975f9e84e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/50a2d47b4f57f8f9433b18692fe2d1975f9e84e1", "html_url": "https://github.com/rust-lang/rust/commit/50a2d47b4f57f8f9433b18692fe2d1975f9e84e1"}], "stats": {"total": 33, "additions": 28, "deletions": 5}, "files": [{"sha": "03b0b04d4014694f5571b97745f9cffd48504ef3", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=9b8f9029762da90a88c8ca6f8ff7690177ec696a", "patch": "@@ -19,7 +19,7 @@ use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n \n-use rustc_target::abi::{LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n+use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n \n@@ -277,6 +277,7 @@ pub trait FnTypeExt<'tcx> {\n                       cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi);\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n+    fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: &'ll Value);\n     fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n@@ -658,6 +659,13 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n+    fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMPointerType(self.llvm_type(cx),\n+                                  cx.data_layout().instruction_address_space as c_uint)\n+        }\n+    }\n+\n     fn llvm_cconv(&self) -> llvm::CallConv {\n         match self.conv {\n             Conv::C => llvm::CCallConv,"}, {"sha": "0dc5a4ddde82c538bc820518cff99dfb18b3f5cd", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=9b8f9029762da90a88c8ca6f8ff7690177ec696a", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, fn_ty.llvm_type(bx.cx).ptr_to().ptr_to());\n+        let llvtable = bx.pointercast(llvtable, fn_ty.ptr_to_llvm_type(bx.cx).ptr_to());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(bx.inbounds_gep(llvtable, &[C_usize(bx.cx, self.0)]), ptr_align);\n         bx.nonnull_metadata(ptr);"}, {"sha": "6fb78fe4aa5a4124c590b755153451f3a4fab0c0", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=9b8f9029762da90a88c8ca6f8ff7690177ec696a", "patch": "@@ -234,6 +234,8 @@ impl Type {\n     }\n \n     pub fn ptr_to(&self) -> &Type {\n+        assert_ne!(self.kind(), TypeKind::Function,\n+                   \"don't call ptr_to on function types, use ptr_to_llvm_type on FnType instead\");\n         unsafe {\n             llvm::LLVMPointerType(self, 0)\n         }"}, {"sha": "fea02edf7be01b70748d68f73f53285515b6e5d2", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=9b8f9029762da90a88c8ca6f8ff7690177ec696a", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         ty::ParamEnv::reveal_all(),\n                         &sig,\n                     );\n-                    FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n+                    FnType::new(cx, sig, &[]).ptr_to_llvm_type(cx)\n                 }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO)\n             };"}, {"sha": "15f61a033447fffacc782b2b4bc011f71a1d65ce", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=9b8f9029762da90a88c8ca6f8ff7690177ec696a", "patch": "@@ -35,7 +35,8 @@ pub struct TargetDataLayout {\n     pub aggregate_align: Align,\n \n     /// Alignments for vector types.\n-    pub vector_align: Vec<(Size, Align)>\n+    pub vector_align: Vec<(Size, Align)>,\n+    pub instruction_address_space: u32,\n }\n \n impl Default for TargetDataLayout {\n@@ -57,13 +58,22 @@ impl Default for TargetDataLayout {\n             vector_align: vec![\n                 (Size::from_bits(64), Align::from_bits(64, 64).unwrap()),\n                 (Size::from_bits(128), Align::from_bits(128, 128).unwrap())\n-            ]\n+            ],\n+            instruction_address_space: 0,\n         }\n     }\n }\n \n impl TargetDataLayout {\n     pub fn parse(target: &Target) -> Result<TargetDataLayout, String> {\n+        // Parse an address space index from a string.\n+        let parse_address_space = |s: &str, cause: &str| {\n+            s.parse::<u32>().map_err(|err| {\n+                format!(\"invalid address space `{}` for `{}` in \\\"data-layout\\\": {}\",\n+                        s, cause, err)\n+            })\n+        };\n+\n         // Parse a bit count from a string.\n         let parse_bits = |s: &str, kind: &str, cause: &str| {\n             s.parse::<u64>().map_err(|err| {\n@@ -96,6 +106,9 @@ impl TargetDataLayout {\n             match spec.split(':').collect::<Vec<_>>()[..] {\n                 [\"e\"] => dl.endian = Endian::Little,\n                 [\"E\"] => dl.endian = Endian::Big,\n+                [p] if p.starts_with(\"P\") => {\n+                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n+                }\n                 [\"a\", ref a..] => dl.aggregate_align = align(a, \"a\")?,\n                 [\"f32\", ref a..] => dl.f32_align = align(a, \"f32\")?,\n                 [\"f64\", ref a..] => dl.f64_align = align(a, \"f64\")?,"}]}