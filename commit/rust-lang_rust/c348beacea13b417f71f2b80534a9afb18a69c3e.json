{"sha": "c348beacea13b417f71f2b80534a9afb18a69c3e", "node_id": "C_kwDOAAsO6NoAKGMzNDhiZWFjZWExM2I0MTdmNzFmMmI4MDUzNGE5YWZiMThhNjljM2U", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-26T17:46:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-26T17:46:59Z"}, "message": "Rollup merge of #97140 - joboet:solid_parker, r=m-ou-se\n\nstd: use an event-flag-based thread parker on SOLID\n\n`Mutex` and `Condvar` are being replaced by more efficient implementations, which need thread parking themselves (see #93740). Therefore, the generic `Parker` needs to be replaced on all platforms where the new lock implementation will be used, which, after #96393, are SOLID, SGX and Hermit (more PRs coming soon).\n\nSOLID, conforming to the [\u03bcITRON specification](http://www.ertl.jp/ITRON/SPEC/FILE/mitron-400e.pdf), has event flags, which are a thread parking primitive very similar to `Parker`. However, they do not make any atomic ordering guarantees (even though those can probably be assumed) and necessitate a system call even when the thread token is already available. Hence, this `Parker`, like the Windows parker, uses an extra atomic state variable.\n\nI future-proofed the code by wrapping the event flag in a `WaitFlag` structure, as both SGX and Hermit can share the Parker implementation, they just have slightly different primitives (SGX uses signals and Hermit has a thread blocking API).\n\n`````@kawadakk````` I assume you are the target maintainer? Could you test this for me?", "tree": {"sha": "2b0296643ddbfbef9b2034263354ed34179b7c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b0296643ddbfbef9b2034263354ed34179b7c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c348beacea13b417f71f2b80534a9afb18a69c3e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiuJuUCRBK7hj4Ov3rIwAAV/0IACoz6FqBSyf+iFmFVR2BHbad\nvSGFvQqXCkknT0EHdNY/KtnnPeyYkMFNfZCab+JwVvsFMgu1VDPNiGtnMH4Wi2cj\neLc5xL/Tei8DqkgsZiJRqyfxjjoaxOUvcwUdbVyta1nyR1uMr8XBO5SMhR+ZIEc9\n5Rt75rUQMatETmmuqkGssycq0pQ5WxDYLSIWw14GkU6EU96BnK5JbWT+JDa9nh+P\ngmhFSnXA+YwrCuEP/X7p9JVUjzAM2D/XmCh3nt5pcUzt6xWHFebdEYcAGU/41Knq\nx87Vz2izQWzdTt5YeHAnA+sr6kkPpisOzlwpc5k4PgE6H4qTXzBkt9S4kiWCeG4=\n=3Rjx\n-----END PGP SIGNATURE-----\n", "payload": "tree 2b0296643ddbfbef9b2034263354ed34179b7c14\nparent 788ddedb0d88e40db9cd62b6163d5a471813044b\nparent caff72361f9a3d9938032be703295ef7a0c0dd5d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1656265619 +0200\ncommitter GitHub <noreply@github.com> 1656265619 +0200\n\nRollup merge of #97140 - joboet:solid_parker, r=m-ou-se\n\nstd: use an event-flag-based thread parker on SOLID\n\n`Mutex` and `Condvar` are being replaced by more efficient implementations, which need thread parking themselves (see #93740). Therefore, the generic `Parker` needs to be replaced on all platforms where the new lock implementation will be used, which, after #96393, are SOLID, SGX and Hermit (more PRs coming soon).\n\nSOLID, conforming to the [\u03bcITRON specification](http://www.ertl.jp/ITRON/SPEC/FILE/mitron-400e.pdf), has event flags, which are a thread parking primitive very similar to `Parker`. However, they do not make any atomic ordering guarantees (even though those can probably be assumed) and necessitate a system call even when the thread token is already available. Hence, this `Parker`, like the Windows parker, uses an extra atomic state variable.\n\nI future-proofed the code by wrapping the event flag in a `WaitFlag` structure, as both SGX and Hermit can share the Parker implementation, they just have slightly different primitives (SGX uses signals and Hermit has a thread blocking API).\n\n`````@kawadakk````` I assume you are the target maintainer? Could you test this for me?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c348beacea13b417f71f2b80534a9afb18a69c3e", "html_url": "https://github.com/rust-lang/rust/commit/c348beacea13b417f71f2b80534a9afb18a69c3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c348beacea13b417f71f2b80534a9afb18a69c3e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "788ddedb0d88e40db9cd62b6163d5a471813044b", "url": "https://api.github.com/repos/rust-lang/rust/commits/788ddedb0d88e40db9cd62b6163d5a471813044b", "html_url": "https://github.com/rust-lang/rust/commit/788ddedb0d88e40db9cd62b6163d5a471813044b"}, {"sha": "caff72361f9a3d9938032be703295ef7a0c0dd5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/caff72361f9a3d9938032be703295ef7a0c0dd5d", "html_url": "https://github.com/rust-lang/rust/commit/caff72361f9a3d9938032be703295ef7a0c0dd5d"}], "stats": {"total": 231, "additions": 225, "deletions": 6}, "files": [{"sha": "5eb14bb7e534be11226565e0b243a987bec50588", "filename": "library/std/src/sys/itron/abi.rs", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs?ref=c348beacea13b417f71f2b80534a9afb18a69c3e", "patch": "@@ -30,15 +30,32 @@ pub type ER = int_t;\n /// Error code type, `ID` on success\n pub type ER_ID = int_t;\n \n+/// Service call operational mode\n+pub type MODE = uint_t;\n+\n+/// OR waiting condition for an eventflag\n+pub const TWF_ORW: MODE = 0x01;\n+\n+/// Object attributes\n+pub type ATR = uint_t;\n+\n+/// FIFO wait order\n+pub const TA_FIFO: ATR = 0;\n+/// Only one task is allowed to be in the waiting state for the eventflag\n+pub const TA_WSGL: ATR = 0;\n+/// The eventflag\u2019s bit pattern is cleared when a task is released from the\n+/// waiting state for that eventflag.\n+pub const TA_CLR: ATR = 0x04;\n+\n+/// Bit pattern of an eventflag\n+pub type FLGPTN = uint_t;\n+\n /// Task or interrupt priority\n pub type PRI = int_t;\n \n /// The special value of `PRI` representing the current task's priority.\n pub const TPRI_SELF: PRI = 0;\n \n-/// Object attributes\n-pub type ATR = uint_t;\n-\n /// Use the priority inheritance protocol\n #[cfg(target_os = \"solid_asp3\")]\n pub const TA_INHERIT: ATR = 0x02;\n@@ -90,6 +107,13 @@ pub struct T_CSEM {\n     pub maxsem: uint_t,\n }\n \n+#[derive(Clone, Copy)]\n+#[repr(C)]\n+pub struct T_CFLG {\n+    pub flgatr: ATR,\n+    pub iflgptn: FLGPTN,\n+}\n+\n #[derive(Clone, Copy)]\n #[repr(C)]\n pub struct T_CMTX {\n@@ -139,6 +163,24 @@ extern \"C\" {\n     pub fn sns_dsp() -> bool_t;\n     #[link_name = \"__asp3_get_tim\"]\n     pub fn get_tim(p_systim: *mut SYSTIM) -> ER;\n+    #[link_name = \"__asp3_acre_flg\"]\n+    pub fn acre_flg(pk_cflg: *const T_CFLG) -> ER_ID;\n+    #[link_name = \"__asp3_del_flg\"]\n+    pub fn del_flg(flgid: ID) -> ER;\n+    #[link_name = \"__asp3_set_flg\"]\n+    pub fn set_flg(flgid: ID, setptn: FLGPTN) -> ER;\n+    #[link_name = \"__asp3_clr_flg\"]\n+    pub fn clr_flg(flgid: ID, clrptn: FLGPTN) -> ER;\n+    #[link_name = \"__asp3_wai_flg\"]\n+    pub fn wai_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE, p_flgptn: *mut FLGPTN) -> ER;\n+    #[link_name = \"__asp3_twai_flg\"]\n+    pub fn twai_flg(\n+        flgid: ID,\n+        waiptn: FLGPTN,\n+        wfmode: MODE,\n+        p_flgptn: *mut FLGPTN,\n+        tmout: TMO,\n+    ) -> ER;\n     #[link_name = \"__asp3_acre_mtx\"]\n     pub fn acre_mtx(pk_cmtx: *const T_CMTX) -> ER_ID;\n     #[link_name = \"__asp3_del_mtx\"]"}, {"sha": "e432edd207754e5151252c136a0946d0821d1a6a", "filename": "library/std/src/sys/itron/wait_flag.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs?ref=c348beacea13b417f71f2b80534a9afb18a69c3e", "patch": "@@ -0,0 +1,72 @@\n+use crate::mem::MaybeUninit;\n+use crate::time::Duration;\n+\n+use super::{\n+    abi,\n+    error::{expect_success, fail},\n+    time::with_tmos,\n+};\n+\n+const CLEAR: abi::FLGPTN = 0;\n+const RAISED: abi::FLGPTN = 1;\n+\n+/// A thread parking primitive that is not susceptible to race conditions,\n+/// but provides no atomic ordering guarantees and allows only one `raise` per wait.\n+pub struct WaitFlag {\n+    flag: abi::ID,\n+}\n+\n+impl WaitFlag {\n+    /// Creates a new wait flag.\n+    pub fn new() -> WaitFlag {\n+        let flag = expect_success(\n+            unsafe {\n+                abi::acre_flg(&abi::T_CFLG {\n+                    flgatr: abi::TA_FIFO | abi::TA_WSGL | abi::TA_CLR,\n+                    iflgptn: CLEAR,\n+                })\n+            },\n+            &\"acre_flg\",\n+        );\n+\n+        WaitFlag { flag }\n+    }\n+\n+    /// Wait for the wait flag to be raised.\n+    pub fn wait(&self) {\n+        let mut token = MaybeUninit::uninit();\n+        expect_success(\n+            unsafe { abi::wai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr()) },\n+            &\"wai_flg\",\n+        );\n+    }\n+\n+    /// Wait for the wait flag to be raised or the timeout to occur.\n+    ///\n+    /// Returns whether the flag was raised (`true`) or the operation timed out (`false`).\n+    pub fn wait_timeout(&self, dur: Duration) -> bool {\n+        let mut token = MaybeUninit::uninit();\n+        let res = with_tmos(dur, |tmout| unsafe {\n+            abi::twai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr(), tmout)\n+        });\n+\n+        match res {\n+            abi::E_OK => true,\n+            abi::E_TMOUT => false,\n+            error => fail(error, &\"twai_flg\"),\n+        }\n+    }\n+\n+    /// Raise the wait flag.\n+    ///\n+    /// Calls to this function should be balanced with the number of successful waits.\n+    pub fn raise(&self) {\n+        expect_success(unsafe { abi::set_flg(self.flag, RAISED) }, &\"set_flg\");\n+    }\n+}\n+\n+impl Drop for WaitFlag {\n+    fn drop(&mut self) {\n+        expect_success(unsafe { abi::del_flg(self.flag) }, &\"del_flg\");\n+    }\n+}"}, {"sha": "2d21e4764fc210a21ecb23341ab64c5ed4160811", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=c348beacea13b417f71f2b80534a9afb18a69c3e", "patch": "@@ -15,6 +15,7 @@ mod itron {\n     pub mod thread;\n     pub(super) mod time;\n     use super::unsupported;\n+    pub mod wait_flag;\n }\n \n pub mod alloc;\n@@ -43,6 +44,7 @@ pub mod memchr;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n pub mod time;\n+pub use self::itron::wait_flag;\n \n mod rwlock;\n "}, {"sha": "cbd7832eb7a4c8e0a1cc932a3463d6c6d1249da1", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=c348beacea13b417f71f2b80534a9afb18a69c3e", "patch": "@@ -10,9 +10,10 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         pub use futex::Parker;\n-    } else if #[cfg(windows)] {\n-        pub use crate::sys::thread_parker::Parker;\n-    } else if #[cfg(target_family = \"unix\")] {\n+    } else if #[cfg(target_os = \"solid_asp3\")] {\n+        mod wait_flag;\n+        pub use wait_flag::Parker;\n+    } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;"}, {"sha": "6561c186655a5cbbb61e1f9194394c22b6981211", "filename": "library/std/src/sys_common/thread_parker/wait_flag.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c348beacea13b417f71f2b80534a9afb18a69c3e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fwait_flag.rs?ref=c348beacea13b417f71f2b80534a9afb18a69c3e", "patch": "@@ -0,0 +1,102 @@\n+//! A wait-flag-based thread parker.\n+//!\n+//! Some operating systems provide low-level parking primitives like wait counts,\n+//! event flags or semaphores which are not susceptible to race conditions (meaning\n+//! the wakeup can occur before the wait operation). To implement the `std` thread\n+//! parker on top of these primitives, we only have to ensure that parking is fast\n+//! when the thread token is available, the atomic ordering guarantees are maintained\n+//! and spurious wakeups are minimized.\n+//!\n+//! To achieve this, this parker uses an atomic variable with three states: `EMPTY`,\n+//! `PARKED` and `NOTIFIED`:\n+//! * `EMPTY` means the token has not been made available, but the thread is not\n+//!    currently waiting on it.\n+//! * `PARKED` means the token is not available and the thread is parked.\n+//! * `NOTIFIED` means the token is available.\n+//!\n+//! `park` and `park_timeout` change the state from `EMPTY` to `PARKED` and from\n+//! `NOTIFIED` to `EMPTY`. If the state was `NOTIFIED`, the thread was unparked and\n+//! execution can continue without calling into the OS. If the state was `EMPTY`,\n+//! the token is not available and the thread waits on the primitive (here called\n+//! \"wait flag\").\n+//!\n+//! `unpark` changes the state to `NOTIFIED`. If the state was `PARKED`, the thread\n+//! is or will be sleeping on the wait flag, so we raise it.\n+\n+use crate::pin::Pin;\n+use crate::sync::atomic::AtomicI8;\n+use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n+use crate::sys::wait_flag::WaitFlag;\n+use crate::time::Duration;\n+\n+const EMPTY: i8 = 0;\n+const PARKED: i8 = -1;\n+const NOTIFIED: i8 = 1;\n+\n+pub struct Parker {\n+    state: AtomicI8,\n+    wait_flag: WaitFlag,\n+}\n+\n+impl Parker {\n+    /// Construct a parker for the current thread. The UNIX parker\n+    /// implementation requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        match self.state.fetch_sub(1, Acquire) {\n+            // NOTIFIED => EMPTY\n+            NOTIFIED => return,\n+            // EMPTY => PARKED\n+            EMPTY => (),\n+            _ => panic!(\"inconsistent park state\"),\n+        }\n+\n+        // Avoid waking up from spurious wakeups (these are quite likely, see below).\n+        loop {\n+            self.wait_flag.wait();\n+\n+            match self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Relaxed) {\n+                Ok(_) => return,\n+                Err(PARKED) => (),\n+                Err(_) => panic!(\"inconsistent park state\"),\n+            }\n+        }\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        match self.state.fetch_sub(1, Acquire) {\n+            NOTIFIED => return,\n+            EMPTY => (),\n+            _ => panic!(\"inconsistent park state\"),\n+        }\n+\n+        self.wait_flag.wait_timeout(dur);\n+\n+        // Either a wakeup or a timeout occurred. Wakeups may be spurious, as there can be\n+        // a race condition when `unpark` is performed between receiving the timeout and\n+        // resetting the state, resulting in the eventflag being set unnecessarily. `park`\n+        // is protected against this by looping until the token is actually given, but\n+        // here we cannot easily tell.\n+\n+        // Use `swap` to provide acquire ordering.\n+        match self.state.swap(EMPTY, Acquire) {\n+            NOTIFIED => (),\n+            PARKED => (),\n+            _ => panic!(\"inconsistent park state\"),\n+        }\n+    }\n+\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+\n+        if state == PARKED {\n+            self.wait_flag.raise();\n+        }\n+    }\n+}"}]}