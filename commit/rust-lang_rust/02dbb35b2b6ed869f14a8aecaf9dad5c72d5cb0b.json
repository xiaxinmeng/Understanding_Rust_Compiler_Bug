{"sha": "02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZGJiMzViMmI2ZWQ4NjlmMTRhOGFlY2FmOWRhZDVjNzJkNWNiMGI=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-23T16:41:06Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-03-11T08:10:48Z"}, "message": "Deduplicate and clean up pretty printing logic", "tree": {"sha": "39810e0ae552bae3763abcf960d7ea2e19826f80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39810e0ae552bae3763abcf960d7ea2e19826f80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "html_url": "https://github.com/rust-lang/rust/commit/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15812785344d913d779d9738fe3cca8de56f71d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/15812785344d913d779d9738fe3cca8de56f71d5", "html_url": "https://github.com/rust-lang/rust/commit/15812785344d913d779d9738fe3cca8de56f71d5"}], "stats": {"total": 433, "additions": 286, "deletions": 147}, "files": [{"sha": "d9f49b6784e6768f850c76185274833ab5a0a5c1", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -2562,15 +2562,15 @@ impl<'tcx> Debug for Constant<'tcx> {\n \n impl<'tcx> Display for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        use crate::ty::print::PrettyPrinter;\n         write!(fmt, \"const \")?;\n-        // FIXME make the default pretty printing of raw pointers more detailed. Here we output the\n-        // debug representation of raw pointers, so that the raw pointers in the mir dump output are\n-        // detailed and just not '{pointer}'.\n-        if let ty::RawPtr(_) = self.literal.ty.kind {\n-            write!(fmt, \"{:?} : {}\", self.literal.val, self.literal.ty)\n-        } else {\n-            write!(fmt, \"{}\", self.literal)\n-        }\n+        ty::tls::with(|tcx| {\n+            let literal = tcx.lift(&self.literal).unwrap();\n+            let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n+            cx.print_alloc_ids = true;\n+            cx.pretty_print_const(literal, true)?;\n+            Ok(())\n+        })\n     }\n }\n "}, {"sha": "2f53b62fdecf82fdcf89dd23106f5e41d38de6ca", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 215, "deletions": 77, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -1,7 +1,7 @@\n use crate::hir::map::{DefPathData, DisambiguatedDefPathData};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use crate::middle::region;\n-use crate::mir::interpret::{sign_extend, truncate, ConstValue, Scalar};\n+use crate::mir::interpret::{sign_extend, truncate, AllocId, ConstValue, Pointer, Scalar};\n use crate::ty::layout::{Integer, IntegerExt, Size};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n@@ -457,6 +457,22 @@ pub trait PrettyPrinter<'tcx>:\n         })\n     }\n \n+    fn print_type_ascribed(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.write_str(\"{\")?;\n+        self = f(self)?;\n+        if print_ty {\n+            self.write_str(\": \")?;\n+            self = self.print_type(ty)?;\n+        }\n+        self.write_str(\"}\")?;\n+        Ok(self)\n+    }\n+\n     fn pretty_print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n         define_scoped_cx!(self);\n \n@@ -893,32 +909,49 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n-    fn pretty_print_const_value(\n+    fn pretty_print_const_scalar(\n         mut self,\n-        ct: ConstValue<'tcx>,\n+        scalar: Scalar,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        if self.tcx().sess.verbose() {\n-            p!(write(\"ConstValue({:?}: {:?})\", ct, ty));\n-            return Ok(self);\n-        }\n-\n-        let u8 = self.tcx().types.u8;\n-\n-        match (ct, &ty.kind) {\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Bool) => {\n-                p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }))\n-            }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F32)) => {\n+        match (scalar, &ty.kind) {\n+            // Single element arrays print their element (they are `#[transparent]`) enclosed in\n+            // square brackets.\n+            (_, ty::Array(t, n)) if n.eval_usize(self.tcx(), ty::ParamEnv::empty()) == 1 => {\n+                p!(write(\"[\"));\n+                self = self.pretty_print_const_scalar(scalar, t, print_ty)?;\n+                p!(write(\"]\"));\n+            }\n+            // Byte strings (&[u8; N])\n+            (Scalar::Ptr(ptr), ty::Ref(_, ty::TyS { kind: ty::Array(t, n), .. }, _))\n+                if *t == self.tcx().types.u8 =>\n+            {\n+                let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n+                let byte_str = self\n+                    .tcx()\n+                    .alloc_map\n+                    .lock()\n+                    .unwrap_memory(ptr.alloc_id)\n+                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(n))\n+                    .unwrap();\n+                p!(pretty_print_byte_str(byte_str));\n+            }\n+            // Bool\n+            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(write(\"false\")),\n+            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(write(\"true\")),\n+            (Scalar::Raw { data, .. }, ty::Bool) => p!(write(\"{}_bool\", data)),\n+            // Float\n+            (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F32)) => {\n                 p!(write(\"{}f32\", Single::from_bits(data)))\n             }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F64)) => {\n+            (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F64)) => {\n                 p!(write(\"{}f64\", Double::from_bits(data)))\n             }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Uint(ui)) => {\n+            // Int\n+            (Scalar::Raw { data, .. }, ty::Uint(ui)) => {\n                 let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n                 let max = truncate(u128::MAX, bit_size);\n \n@@ -929,7 +962,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"{}{}\", data, ui_str))\n                 };\n             }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Int(i)) => {\n+            (Scalar::Raw { data, .. }, ty::Int(i)) => {\n                 let bit_size = Integer::from_attr(&self.tcx(), SignedInt(*i)).size().bits() as u128;\n                 let min = 1u128 << (bit_size - 1);\n                 let max = min - 1;\n@@ -943,76 +976,140 @@ pub trait PrettyPrinter<'tcx>:\n                     _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i_str)),\n                 }\n             }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Char) => {\n-                p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap()))\n+            // Char\n+            (Scalar::Raw { data, .. }, ty::Char) => match ::std::char::from_u32(data as u32) {\n+                Some(c) => p!(write(\"{:?}\", c)),\n+                None => p!(write(\"{}_char\", data)),\n+            },\n+            // References and pointers\n+            (Scalar::Raw { data: 0, .. }, ty::RawPtr(_)) => p!(write(\"{{null pointer}}\")),\n+            // This is UB, but we still print it\n+            (Scalar::Raw { data: 0, .. }, ty::Ref(_, ty, _)) => {\n+                p!(write(\"{{null reference to \"), print(ty), write(\"}}\"))\n             }\n-            (ConstValue::Scalar(_), ty::RawPtr(_)) => p!(write(\"{{pointer}}\")),\n-            (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::FnPtr(_)) => {\n+            (Scalar::Raw { data, .. }, ty::Ref(..)) | (Scalar::Raw { data, .. }, ty::RawPtr(_)) => {\n+                let pointer_width = self.tcx().data_layout.pointer_size.bytes();\n+                p!(write(\"0x{:01$x}\", data, pointer_width as usize * 2))\n+            }\n+            (Scalar::Ptr(ptr), ty::FnPtr(_)) => {\n                 let instance = {\n                     let alloc_map = self.tcx().alloc_map.lock();\n                     alloc_map.unwrap_fn(ptr.alloc_id)\n                 };\n                 p!(print_value_path(instance.def_id(), instance.substs));\n             }\n-            _ => {\n-                let printed = if let ty::Ref(_, ref_ty, _) = ty.kind {\n-                    let byte_str = match (ct, &ref_ty.kind) {\n-                        (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n-                            let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n-                            Some(\n-                                self.tcx()\n-                                    .alloc_map\n-                                    .lock()\n-                                    .unwrap_memory(ptr.alloc_id)\n-                                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(n))\n-                                    .unwrap(),\n-                            )\n-                        }\n-                        (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                            // The `inspect` here is okay since we checked the bounds, and there are\n-                            // no relocations (we have an active slice reference here). We don't use\n-                            // this result to affect interpreter execution.\n-                            Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n-                        }\n-                        _ => None,\n-                    };\n+            // For zsts just print their type as their value gives no extra information\n+            (Scalar::Raw { size: 0, .. }, _) => p!(print(ty)),\n+            // Nontrivial types with scalar bit representation\n+            (Scalar::Raw { data, size }, _) => {\n+                self = self.print_type_ascribed(\n+                    |mut this| {\n+                        write!(this, \"0x{:01$x}\", data, size as usize * 2)?;\n+                        Ok(this)\n+                    },\n+                    ty,\n+                    print_ty,\n+                )?\n+            }\n+            // Any pointer values not covered by a branch above\n+            (Scalar::Ptr(p), _) => {\n+                self = self.pretty_print_const_pointer(p, ty, print_ty)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n \n-                    if let Some(byte_str) = byte_str {\n-                        p!(write(\"b\\\"\"));\n-                        for &c in byte_str {\n-                            for e in std::ascii::escape_default(c) {\n-                                self.write_char(e as char)?;\n-                            }\n-                        }\n-                        p!(write(\"\\\"\"));\n-                        true\n-                    } else if let (ConstValue::Slice { data, start, end }, ty::Str) =\n-                        (ct, &ref_ty.kind)\n-                    {\n-                        // The `inspect` here is okay since we checked the bounds, and there are no\n-                        // relocations (we have an active `str` reference here). We don't use this\n-                        // result to affect interpreter execution.\n-                        let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n-                        let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n-                        p!(write(\"{:?}\", s));\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    false\n-                };\n-                if !printed {\n-                    // fallback\n-                    p!(write(\"{:?}\", ct));\n-                    if print_ty {\n-                        p!(write(\": \"), print(ty));\n-                    }\n-                }\n+    /// This is overridden for MIR printing because we only want to hide alloc ids from users, not\n+    /// from MIR where it is actually useful.\n+    fn pretty_print_const_pointer(\n+        self,\n+        _: Pointer,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.print_type_ascribed(\n+            |mut this| {\n+                this.write_str(\"pointer\")?;\n+                Ok(this)\n+            },\n+            ty,\n+            print_ty,\n+        )\n+    }\n+\n+    fn pretty_print_byte_str(mut self, byte_str: &'tcx [u8]) -> Result<Self::Const, Self::Error> {\n+        define_scoped_cx!(self);\n+        p!(write(\"b\\\"\"));\n+        for &c in byte_str {\n+            for e in std::ascii::escape_default(c) {\n+                self.write_char(e as char)?;\n             }\n-        };\n+        }\n+        p!(write(\"\\\"\"));\n         Ok(self)\n     }\n+\n+    fn pretty_print_const_value(\n+        mut self,\n+        ct: ConstValue<'tcx>,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        if self.tcx().sess.verbose() {\n+            p!(write(\"ConstValue({:?}: {:?})\", ct, ty));\n+            return Ok(self);\n+        }\n+\n+        let u8_type = self.tcx().types.u8;\n+\n+        match (ct, &ty.kind) {\n+            (ConstValue::Scalar(scalar), _) => self.pretty_print_const_scalar(scalar, ty, print_ty),\n+            (\n+                ConstValue::Slice { data, start, end },\n+                ty::Ref(_, ty::TyS { kind: ty::Slice(t), .. }, _),\n+            ) if *t == u8_type => {\n+                // The `inspect` here is okay since we checked the bounds, and there are\n+                // no relocations (we have an active slice reference here). We don't use\n+                // this result to affect interpreter execution.\n+                let byte_str = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                self.pretty_print_byte_str(byte_str)\n+            }\n+            (\n+                ConstValue::Slice { data, start, end },\n+                ty::Ref(_, ty::TyS { kind: ty::Str, .. }, _),\n+            ) => {\n+                // The `inspect` here is okay since we checked the bounds, and there are no\n+                // relocations (we have an active `str` reference here). We don't use this\n+                // result to affect interpreter execution.\n+                let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+                p!(write(\"{:?}\", s));\n+                Ok(self)\n+            }\n+            (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n+                let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n+                let n = Size::from_bytes(n);\n+                let ptr = Pointer::new(AllocId(0), offset);\n+\n+                let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();\n+                p!(write(\"*\"));\n+                p!(pretty_print_byte_str(byte_str));\n+                Ok(self)\n+            }\n+            // FIXME(oli-obk): also pretty print arrays and other aggregate constants by reading\n+            // their fields instead of just dumping the memory.\n+            _ => {\n+                // fallback\n+                p!(write(\"{:?}\", ct));\n+                if print_ty {\n+                    p!(write(\": \"), print(ty));\n+                }\n+                Ok(self)\n+            }\n+        }\n+    }\n }\n \n // HACK(eddyb) boxed to avoid moving around a large struct by-value.\n@@ -1024,6 +1121,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n \n     empty_path: bool,\n     in_value: bool,\n+    pub print_alloc_ids: bool,\n \n     used_region_names: FxHashSet<Symbol>,\n     region_index: usize,\n@@ -1054,6 +1152,7 @@ impl<F> FmtPrinter<'a, 'tcx, F> {\n             fmt,\n             empty_path: false,\n             in_value: ns == Namespace::ValueNS,\n+            print_alloc_ids: false,\n             used_region_names: Default::default(),\n             region_index: 0,\n             binder_depth: 0,\n@@ -1382,6 +1481,45 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n             ty::ReStatic | ty::ReEmpty(_) | ty::ReClosureBound(_) => true,\n         }\n     }\n+\n+    fn pretty_print_const_pointer(\n+        self,\n+        p: Pointer,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.print_type_ascribed(\n+            |mut this| {\n+                define_scoped_cx!(this);\n+                if this.print_alloc_ids {\n+                    p!(write(\"{:?}\", p));\n+                } else {\n+                    p!(write(\"pointer\"));\n+                }\n+                Ok(this)\n+            },\n+            ty,\n+            print_ty,\n+        )\n+    }\n+\n+    fn print_type_ascribed(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.write_str(\"{\")?;\n+        self = f(self)?;\n+        if print_ty {\n+            self.write_str(\": \")?;\n+            let was_in_value = std::mem::replace(&mut self.in_value, false);\n+            self = self.print_type(ty)?;\n+            self.in_value = was_in_value;\n+        }\n+        self.write_str(\"}\")?;\n+        Ok(self)\n+    }\n }\n \n // HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`."}, {"sha": "677dc69773516e6687af9a0fb1308a9798ea217c", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -157,6 +157,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n         }\n     }\n }\n+\n impl PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n     fn region_should_not_be_omitted(&self, _region: ty::Region<'_>) -> bool {\n         false"}, {"sha": "512eec6b9f14abf2b530d395fe26415b8260dc4a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -3,18 +3,20 @@\n \n use std::convert::{TryFrom, TryInto};\n \n-use rustc::ty::layout::{\n-    self, HasDataLayout, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n-};\n-use rustc::{mir, ty};\n-\n use super::{InterpCx, MPlaceTy, Machine, MemPlace, Place, PlaceTy};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n use rustc::mir::interpret::{\n     sign_extend, truncate, AllocId, ConstValue, GlobalId, InterpResult, Pointer, Scalar,\n };\n-use rustc_ast::ast;\n+use rustc::ty::layout::{\n+    self, HasDataLayout, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n+};\n+use rustc::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n+use rustc::ty::Ty;\n+use rustc::{mir, ty};\n+use rustc_hir::def::Namespace;\n use rustc_macros::HashStable;\n+use std::fmt::Write;\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n ///\n@@ -92,47 +94,42 @@ pub struct ImmTy<'tcx, Tag = ()> {\n     pub layout: TyLayout<'tcx>,\n }\n \n-// `Tag: Copy` because some methods on `Scalar` consume them by value\n impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n-    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match &self.imm {\n-            // We cannot use `to_bits_or_ptr` as we do not have a `tcx`.\n-            // So we use `is_bits` and circumvent a bunch of sanity checking -- but\n-            // this is anyway only for printing.\n-            Immediate::Scalar(ScalarMaybeUndef::Scalar(s)) if s.is_ptr() => {\n-                fmt.write_str(\"{pointer}\")\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        /// Helper function for printing a scalar to a FmtPrinter\n+        fn p<'a, 'tcx, F: std::fmt::Write, Tag>(\n+            mut cx: FmtPrinter<'a, 'tcx, F>,\n+            s: ScalarMaybeUndef<Tag>,\n+            ty: Ty<'tcx>,\n+        ) -> Result<FmtPrinter<'a, 'tcx, F>, std::fmt::Error> {\n+            match s {\n+                ScalarMaybeUndef::Scalar(s) => {\n+                    cx.pretty_print_const_scalar(s.erase_tag(), ty, true)\n+                }\n+                ScalarMaybeUndef::Undef => {\n+                    cx.write_str(\"{undef \")?;\n+                    cx = cx.print_type(ty)?;\n+                    cx.write_str(\"}\")?;\n+                    Ok(cx)\n+                }\n             }\n-            Immediate::Scalar(ScalarMaybeUndef::Scalar(s)) => {\n-                let s = s.assert_bits(self.layout.size);\n-                match self.layout.ty.kind {\n-                    ty::Int(_) => {\n-                        return write!(fmt, \"{}\", super::sign_extend(s, self.layout.size) as i128,);\n-                    }\n-                    ty::Uint(_) => return write!(fmt, \"{}\", s),\n-                    ty::Bool if s == 0 => return fmt.write_str(\"false\"),\n-                    ty::Bool if s == 1 => return fmt.write_str(\"true\"),\n-                    ty::Char => {\n-                        if let Some(c) = u32::try_from(s).ok().and_then(std::char::from_u32) {\n-                            return write!(fmt, \"{}\", c);\n-                        }\n-                    }\n-                    ty::Float(ast::FloatTy::F32) => {\n-                        if let Ok(u) = u32::try_from(s) {\n-                            return write!(fmt, \"{}\", f32::from_bits(u));\n-                        }\n-                    }\n-                    ty::Float(ast::FloatTy::F64) => {\n-                        if let Ok(u) = u64::try_from(s) {\n-                            return write!(fmt, \"{}\", f64::from_bits(u));\n-                        }\n+        }\n+        ty::tls::with(|tcx| {\n+            match self.imm {\n+                Immediate::Scalar(s) => {\n+                    if let Some(ty) = tcx.lift(&self.layout.ty) {\n+                        let cx = FmtPrinter::new(tcx, f, Namespace::ValueNS);\n+                        p(cx, s, ty)?;\n+                        return Ok(());\n                     }\n-                    _ => {}\n+                    write!(f, \"{:?}: {}\", s.erase_tag(), self.layout.ty)\n+                }\n+                Immediate::ScalarPair(a, b) => {\n+                    // FIXME(oli-obk): at least print tuples and slices nicely\n+                    write!(f, \"({:?}, {:?}): {}\", a.erase_tag(), b.erase_tag(), self.layout.ty,)\n                 }\n-                write!(fmt, \"{:x}\", s)\n             }\n-            Immediate::Scalar(ScalarMaybeUndef::Undef) => fmt.write_str(\"{undef}\"),\n-            Immediate::ScalarPair(..) => fmt.write_str(\"{wide pointer or tuple}\"),\n-        }\n+        })\n     }\n }\n "}, {"sha": "0d4a6d1bafdd21e5437ac486476ab7f955fd693f", "filename": "src/test/mir-opt/const-promotion-extern-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -14,7 +14,7 @@ fn main() {}\n // START rustc.FOO.PromoteTemps.before.mir\n // bb0: {\n // ...\n-//     _5 = const Scalar(alloc1+0) : &i32;\n+//     _5 = const {alloc1+0: &i32};\n //     _4 = &(*_5);\n //     _3 = [move _4];\n //     _2 = &_3;\n@@ -31,7 +31,7 @@ fn main() {}\n // START rustc.BAR.PromoteTemps.before.mir\n // bb0: {\n // ...\n-//     _5 = const Scalar(alloc0+0) : &i32;\n+//     _5 = const {alloc0+0: &i32};\n //     _4 = &(*_5);\n //     _3 = [move _4];\n //     _2 = &_3;"}, {"sha": "b308d06999c8a2a28ce401ad10e227760d9ca4f6", "filename": "src/test/mir-opt/const_prop/discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -31,7 +31,7 @@ fn main() {\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      _3 = const Scalar(0x01) : std::option::Option<bool>;\n+//      _3 = const {0x01: std::option::Option<bool>};\n //      _4 = const 1isize;\n //      switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1];\n //  }"}, {"sha": "f332bb895095bf276e861b72f1c229454306a7a3", "filename": "src/test/mir-opt/const_prop/issue-66971.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -29,7 +29,7 @@ fn main() {\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      _3 = const Scalar(<ZST>) : ();\n+//      _3 = const ();\n //      _2 = (move _3, const 0u8, const 0u8);\n //      ...\n //      _1 = const encode(move _2) -> bb1;"}, {"sha": "d307cebd71539fb3fa37307f6cf27dfcfe59ac8b", "filename": "src/test/mir-opt/const_prop/read_immutable_static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -10,10 +10,10 @@ fn main() {\n // START rustc.main.ConstProp.before.mir\n //  bb0: {\n //      ...\n-//      _3 = const Scalar(alloc0+0) : &u8;\n+//      _3 = const {alloc0+0: &u8};\n //      _2 = (*_3);\n //      ...\n-//      _5 = const Scalar(alloc0+0) : &u8;\n+//      _5 = const {alloc0+0: &u8};\n //      _4 = (*_5);\n //      _1 = Add(move _2, move _4);\n //      ..."}, {"sha": "ca8e60b9e39c82631a4b856a30ebaf4ad437851e", "filename": "src/test/mir-opt/simplify-locals-removes-unused-consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -35,28 +35,28 @@ fn main() {\n // bb0: {\n //   StorageLive(_1);\n //   StorageLive(_2);\n-//   _2 = const Scalar(<ZST>) : ();\n+//   _2 = const ();\n //   StorageLive(_3);\n-//   _3 = const Scalar(<ZST>) : ();\n-//   _1 = const Scalar(<ZST>) : ((), ());\n+//   _3 = const ();\n+//   _1 = const ((), ());\n //   StorageDead(_3);\n //   StorageDead(_2);\n //   StorageDead(_1);\n //   StorageLive(_4);\n //   StorageLive(_6);\n-//   _6 = const Scalar(<ZST>) : ();\n+//   _6 = const ();\n //   StorageLive(_7);\n-//   _7 = const Scalar(<ZST>) : ();\n+//   _7 = const ();\n //   StorageDead(_7);\n //   StorageDead(_6);\n-//   _4 = const use_zst(const Scalar(<ZST>) : ((), ())) -> bb1;\n+//   _4 = const use_zst(const ((), ())) -> bb1;\n // }\n // bb1: {\n //   StorageDead(_4);\n //   StorageLive(_8);\n //   StorageLive(_10);\n //   StorageLive(_11);\n-//   _11 = const Scalar(0x28) : Temp;\n+//   _11 = const {0x28 : Temp};\n //   _10 = const 40u8;\n //   StorageDead(_10);\n //   _8 = const use_u8(const 42u8) -> bb2;\n@@ -75,7 +75,7 @@ fn main() {\n // }\n // bb0: {\n //   StorageLive(_1);\n-//   _1 = const use_zst(const Scalar(<ZST>) : ((), ())) -> bb1;\n+//   _1 = const use_zst(const ((), ())) -> bb1;\n // }\n // bb1: {\n //   StorageDead(_1);"}, {"sha": "f8ae1b3fdc9486fe6f96484a94857b0d22d7dd5a", "filename": "src/test/ui/const-generics/raw-ptr-const-param.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -1,3 +1,6 @@\n+// normalize-stderr-64bit \"0x00000000\" -> \"0x[PREFIX]\"\n+// normalize-stderr-32bit \"0x\" -> \"0x[PREFIX]\"\n+\n #![feature(const_generics, const_compare_raw_pointers)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n "}, {"sha": "850bb89e9565302789723d2d8a3e42041ef0fc5d", "filename": "src/test/ui/const-generics/raw-ptr-const-param.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -1,21 +1,21 @@\n warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n-  --> $DIR/raw-ptr-const-param.rs:1:12\n+  --> $DIR/raw-ptr-const-param.rs:4:12\n    |\n LL | #![feature(const_generics, const_compare_raw_pointers)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0308]: mismatched types\n-  --> $DIR/raw-ptr-const-param.rs:7:38\n+  --> $DIR/raw-ptr-const-param.rs:10:38\n    |\n LL |     let _: Const<{15 as *const _}> = Const::<{10 as *const _}>;\n-   |            -----------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{pointer}`, found `{pointer}`\n+   |            -----------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `0x[PREFIX]0000000f`, found `0x[PREFIX]0000000a`\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `Const<{pointer}>`\n-              found struct `Const<{pointer}>`\n+   = note: expected struct `Const<0x[PREFIX]0000000f>`\n+              found struct `Const<0x[PREFIX]0000000a>`\n \n error: aborting due to previous error\n "}, {"sha": "bbe3344b412b39ed31b1d67c82572ae474a39484", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=02dbb35b2b6ed869f14a8aecaf9dad5c72d5cb0b", "patch": "@@ -43,7 +43,7 @@ error: any use of this value will cause an error\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n-   |           exact_div: 1 cannot be divided by 2 without remainder\n+   |           exact_div: 1isize cannot be divided by 2isize without remainder\n    |           inside call to `std::ptr::const_ptr::<impl *const u16>::offset_from` at $DIR/offset_from_ub.rs:36:14\n    | \n   ::: $DIR/offset_from_ub.rs:31:1"}]}