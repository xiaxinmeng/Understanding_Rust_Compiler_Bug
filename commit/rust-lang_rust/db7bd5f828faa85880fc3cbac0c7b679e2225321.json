{"sha": "db7bd5f828faa85880fc3cbac0c7b679e2225321", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiN2JkNWY4MjhmYWE4NTg4MGZjM2NiYWMwYzdiNjc5ZTIyMjUzMjE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-18T09:32:58Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-23T22:14:26Z"}, "message": "Fallout in other crates.", "tree": {"sha": "dccab4288b8a800d51e9b3d96c7a7967e626c28c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dccab4288b8a800d51e9b3d96c7a7967e626c28c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db7bd5f828faa85880fc3cbac0c7b679e2225321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db7bd5f828faa85880fc3cbac0c7b679e2225321", "html_url": "https://github.com/rust-lang/rust/commit/db7bd5f828faa85880fc3cbac0c7b679e2225321", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db7bd5f828faa85880fc3cbac0c7b679e2225321/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6624dc4045505e942ce219dcc374061cef50e3f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6624dc4045505e942ce219dcc374061cef50e3f1", "html_url": "https://github.com/rust-lang/rust/commit/6624dc4045505e942ce219dcc374061cef50e3f1"}], "stats": {"total": 473, "additions": 287, "deletions": 186}, "files": [{"sha": "ee44c07d3a917c37245f09f9edcfec9959393d10", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 35, "deletions": 152, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -50,7 +50,7 @@\n //! fingerprint for a given set of node parameters.\n \n use crate::hir::map::DefPathHash;\n-use crate::ich::{Fingerprint, StableHashingContext};\n+use crate::ich::Fingerprint;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;\n@@ -62,13 +62,13 @@ use crate::traits::query::{\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::HirId;\n use rustc_span::symbol::Symbol;\n-use std::fmt;\n use std::hash::Hash;\n \n+pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n+\n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e., which sub-expression of the macro we are in) but don't need\n // to actually use any of the arguments.\n@@ -128,7 +128,7 @@ macro_rules! define_dep_nodes {\n \n                             // tuple args\n                             $({\n-                                return <$tuple_arg_ty as DepNodeParams>\n+                                return <$tuple_arg_ty as DepNodeParams<TyCtxt<'_>>>\n                                     ::CAN_RECONSTRUCT_QUERY_KEY;\n                             })*\n \n@@ -212,38 +212,34 @@ macro_rules! define_dep_nodes {\n             )*\n         }\n \n-        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n-                 RustcEncodable, RustcDecodable)]\n-        pub struct DepNode {\n-            pub kind: DepKind,\n-            pub hash: Fingerprint,\n+        pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n+\n+        pub trait DepNodeExt: Sized {\n+            /// Construct a DepNode from the given DepKind and DefPathHash. This\n+            /// method will assert that the given DepKind actually requires a\n+            /// single DefId/DefPathHash parameter.\n+            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n+\n+            /// Used in testing\n+            fn from_label_string(label: &str, def_path_hash: DefPathHash)\n+                -> Result<Self, ()>;\n+\n+            /// Used in testing\n+            fn has_label_string(label: &str) -> bool;\n         }\n \n-        impl DepNode {\n+        impl DepNodeExt for DepNode {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            pub fn from_def_path_hash(def_path_hash: DefPathHash,\n-                                      kind: DepKind)\n-                                      -> DepNode {\n+            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n                 debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n                 DepNode {\n                     kind,\n                     hash: def_path_hash.0,\n                 }\n             }\n \n-            /// Creates a new, parameterless DepNode. This method will assert\n-            /// that the DepNode corresponding to the given DepKind actually\n-            /// does not require any parameters.\n-            pub fn new_no_params(kind: DepKind) -> DepNode {\n-                debug_assert!(!kind.has_params());\n-                DepNode {\n-                    kind,\n-                    hash: Fingerprint::ZERO,\n-                }\n-            }\n-\n             /// Extracts the DefId corresponding to this DepNode. This will work\n             /// if two conditions are met:\n             ///\n@@ -254,20 +250,8 @@ macro_rules! define_dep_nodes {\n             /// DepNode. Condition (2) might not be fulfilled if a DepNode\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n-            pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n-                if self.kind.can_reconstruct_query_key() {\n-                    let def_path_hash = DefPathHash(self.hash);\n-                    tcx.def_path_hash_to_def_id.as_ref()?\n-                        .get(&def_path_hash).cloned()\n-                } else {\n-                    None\n-                }\n-            }\n-\n             /// Used in testing\n-            pub fn from_label_string(label: &str,\n-                                     def_path_hash: DefPathHash)\n-                                     -> Result<DepNode, ()> {\n+            fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n                 let kind = match label {\n                     $(\n                         stringify!($variant) => DepKind::$variant,\n@@ -287,7 +271,7 @@ macro_rules! define_dep_nodes {\n             }\n \n             /// Used in testing\n-            pub fn has_label_string(label: &str) -> bool {\n+            fn has_label_string(label: &str) -> bool {\n                 match label {\n                     $(\n                         stringify!($variant) => true,\n@@ -308,35 +292,6 @@ macro_rules! define_dep_nodes {\n     );\n }\n \n-impl fmt::Debug for DepNode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.kind)?;\n-\n-        if !self.kind.has_params() && !self.kind.is_anon() {\n-            return Ok(());\n-        }\n-\n-        write!(f, \"(\")?;\n-\n-        crate::ty::tls::with_opt(|opt_tcx| {\n-            if let Some(tcx) = opt_tcx {\n-                if let Some(def_id) = self.extract_def_id(tcx) {\n-                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n-                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*self) {\n-                    write!(f, \"{}\", s)?;\n-                } else {\n-                    write!(f, \"{}\", self.hash)?;\n-                }\n-            } else {\n-                write!(f, \"{}\", self.hash)?;\n-            }\n-            Ok(())\n-        })?;\n-\n-        write!(f, \")\")\n-    }\n-}\n-\n rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n@@ -349,58 +304,10 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] CompileCodegenUnit(Symbol),\n ]);\n \n-pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n-\n-    /// This method turns the parameters of a DepNodeConstructor into an opaque\n-    /// Fingerprint to be used in DepNode.\n-    /// Not all DepNodeParams support being turned into a Fingerprint (they\n-    /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: TyCtxt<'tcx>) -> Fingerprint {\n-        panic!(\"Not implemented. Accidentally called on anonymous node?\")\n-    }\n-\n-    fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-\n-    /// This method tries to recover the query key from the given `DepNode`,\n-    /// something which is needed when forcing `DepNode`s during red-green\n-    /// evaluation. The query system will only call this method if\n-    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n-    /// It is always valid to return `None` here, in which case incremental\n-    /// compilation will treat the query as having changed instead of forcing it.\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n-}\n-\n-impl<'tcx, T> DepNodeParams<'tcx> for T\n-where\n-    T: HashStable<StableHashingContext<'tcx>> + fmt::Debug,\n-{\n-    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n-\n-    default fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-\n-        self.hash_stable(&mut hcx, &mut hasher);\n-\n-        hasher.finish()\n-    }\n-\n-    default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-\n-    default fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n-        None\n-    }\n-}\n-\n-impl<'tcx> DepNodeParams<'tcx> for DefId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n     }\n \n@@ -409,14 +316,14 @@ impl<'tcx> DepNodeParams<'tcx> for DefId {\n     }\n \n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx)\n+        tcx.extract_def_id(dep_node)\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for LocalDefId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         self.to_def_id().to_fingerprint(tcx)\n     }\n \n@@ -425,14 +332,14 @@ impl<'tcx> DepNodeParams<'tcx> for LocalDefId {\n     }\n \n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.expect_local())\n+        tcx.extract_def_id(dep_node).map(|id| id.expect_local())\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         tcx.def_path_hash(def_id).0\n     }\n@@ -442,17 +349,17 @@ impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n     }\n \n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.krate)\n+        tcx.extract_def_id(dep_node).map(|id| id.krate)\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let (def_id_0, def_id_1) = *self;\n \n         let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n@@ -468,13 +375,13 @@ impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for HirId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let HirId { owner, local_id } = *self;\n \n         let def_path_hash = tcx.def_path_hash(owner.to_def_id());\n@@ -483,27 +390,3 @@ impl<'tcx> DepNodeParams<'tcx> for HirId {\n         def_path_hash.0.combine(local_id)\n     }\n }\n-\n-/// A \"work product\" corresponds to a `.o` (or other) file that we\n-/// save in between runs. These IDs do not have a `DefId` but rather\n-/// some independent path or string that persists between runs without\n-/// the need to be mapped or unmapped. (This ensures we can serialize\n-/// them even in the absence of a tcx.)\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable)]\n-pub struct WorkProductId {\n-    hash: Fingerprint,\n-}\n-\n-impl WorkProductId {\n-    pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n-        let mut hasher = StableHasher::new();\n-        cgu_name.len().hash(&mut hasher);\n-        cgu_name.hash(&mut hasher);\n-        WorkProductId { hash: hasher.finish() }\n-    }\n-\n-    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n-        WorkProductId { hash: fingerprint }\n-    }\n-}"}, {"sha": "79295b2f8276759202eab7cf9703c002a9b70549", "filename": "src/librustc/dep_graph/mod.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -0,0 +1,233 @@\n+use crate::hir::map::definitions::DefPathHash;\n+use crate::ich::StableHashingContext;\n+use crate::ty::{self, TyCtxt};\n+use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::Diagnostic;\n+use rustc_hir::def_id::DefId;\n+\n+mod dep_node;\n+mod safe;\n+\n+pub(crate) use rustc_query_system::dep_graph::DepNodeParams;\n+pub use rustc_query_system::dep_graph::{\n+    debug, hash_result, DepContext, DepNodeColor, DepNodeIndex, SerializedDepNodeIndex,\n+    WorkProduct, WorkProductFileKind, WorkProductId,\n+};\n+\n+pub use dep_node::{label_strs, DepConstructor, DepKind, DepNode, DepNodeExt};\n+pub use safe::AssertDepGraphSafe;\n+pub use safe::DepGraphSafe;\n+\n+pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n+pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n+pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n+pub type PreviousDepGraph = rustc_query_system::dep_graph::PreviousDepGraph<DepKind>;\n+pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n+\n+impl rustc_query_system::dep_graph::DepKind for DepKind {\n+    fn is_eval_always(&self) -> bool {\n+        DepKind::is_eval_always(self)\n+    }\n+\n+    fn has_params(&self) -> bool {\n+        DepKind::has_params(self)\n+    }\n+\n+    fn debug_node(node: &DepNode, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{:?}\", node.kind)?;\n+\n+        if !node.kind.has_params() && !node.kind.is_anon() {\n+            return Ok(());\n+        }\n+\n+        write!(f, \"(\")?;\n+\n+        ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                if let Some(def_id) = tcx.extract_def_id(node) {\n+                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n+                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*node) {\n+                    write!(f, \"{}\", s)?;\n+                } else {\n+                    write!(f, \"{}\", node.hash)?;\n+                }\n+            } else {\n+                write!(f, \"{}\", node.hash)?;\n+            }\n+            Ok(())\n+        })?;\n+\n+        write!(f, \")\")\n+    }\n+\n+    fn assert_ignored() {\n+        ty::tls::with_context_opt(|icx| {\n+            let icx = if let Some(icx) = icx { icx } else { return };\n+            assert!(icx.task_deps.is_none(), \"expected no task dependency tracking\");\n+        })\n+    }\n+\n+    fn with_ignore_deps<OP, R>(op: OP) -> R\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        ty::tls::with_context(|icx| {\n+            let icx = ty::tls::ImplicitCtxt { task_deps: None, ..icx.clone() };\n+\n+            ty::tls::enter_context(&icx, |_| op())\n+        })\n+    }\n+\n+    fn with_deps<OP, R>(task_deps: Option<&Lock<TaskDeps>>, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        ty::tls::with_context(|icx| {\n+            let icx = ty::tls::ImplicitCtxt { task_deps, ..icx.clone() };\n+\n+            ty::tls::enter_context(&icx, |_| op())\n+        })\n+    }\n+\n+    fn read_deps<OP>(op: OP) -> ()\n+    where\n+        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps>>) -> (),\n+    {\n+        ty::tls::with_context_opt(|icx| {\n+            let icx = if let Some(icx) = icx { icx } else { return };\n+            op(icx.task_deps)\n+        })\n+    }\n+}\n+\n+impl<'tcx> DepContext for TyCtxt<'tcx> {\n+    type DepKind = DepKind;\n+    type StableHashingContext = StableHashingContext<'tcx>;\n+\n+    fn create_stable_hashing_context(&self) -> Self::StableHashingContext {\n+        TyCtxt::create_stable_hashing_context(*self)\n+    }\n+\n+    fn force_from_dep_node(&self, node: &DepNode) -> bool {\n+        ty::query::force_from_dep_node(*self, node)\n+    }\n+\n+    /// Extracts the DefId corresponding to this DepNode. This will work\n+    /// if two conditions are met:\n+    ///\n+    /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+    /// 2. the item that the DefPath refers to exists in the current tcx.\n+    ///\n+    /// Condition (1) is determined by the DepKind variant of the\n+    /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+    /// refers to something from the previous compilation session that\n+    /// has been removed.\n+    fn extract_def_id(&self, node: &DepNode) -> Option<DefId> {\n+        if node.kind.can_reconstruct_query_key() {\n+            let def_path_hash = DefPathHash(node.hash);\n+            self.def_path_hash_to_def_id.as_ref()?.get(&def_path_hash).cloned()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn ensure_node_can_be_forced(&self, dep_dep_node: &DepNode) -> Option<()> {\n+        // FIXME: This match is just a workaround for incremental bugs and should\n+        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n+        // bug that must be fixed before removing this.\n+        match dep_dep_node.kind {\n+            DepKind::hir_owner | DepKind::hir_owner_nodes | DepKind::CrateMetadata => {\n+                if let Some(def_id) = self.extract_def_id(dep_dep_node) {\n+                    if def_id_corresponds_to_hir_dep_node(*self, def_id) {\n+                        if dep_dep_node.kind == DepKind::CrateMetadata {\n+                            // The `DefPath` has corresponding node,\n+                            // and that node should have been marked\n+                            // either red or green in `data.colors`.\n+                            bug!(\n+                                \"DepNode {:?} should have been \\\n+                             pre-marked as red or green but wasn't.\",\n+                                dep_dep_node\n+                            );\n+                        }\n+                    } else {\n+                        // This `DefPath` does not have a\n+                        // corresponding `DepNode` (e.g. a\n+                        // struct field), and the ` DefPath`\n+                        // collided with the `DefPath` of a\n+                        // proper item that existed in the\n+                        // previous compilation session.\n+                        //\n+                        // Since the given `DefPath` does not\n+                        // denote the item that previously\n+                        // existed, we just fail to mark green.\n+                        return None;\n+                    }\n+                } else {\n+                    // If the node does not exist anymore, we\n+                    // just fail to mark green.\n+                    return None;\n+                }\n+            }\n+            _ => {\n+                // For other kinds of nodes it's OK to be\n+                // forced.\n+            }\n+        }\n+        Some(())\n+    }\n+\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool {\n+        self.sess.has_errors_or_delayed_span_bugs()\n+    }\n+\n+    fn diagnostic(&self) -> &rustc_errors::Handler {\n+        self.sess.diagnostic()\n+    }\n+\n+    // Interactions with on_disk_cache\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n+        use crate::mir::interpret::GlobalId;\n+        use crate::ty::query::queries;\n+        use crate::ty::query::QueryDescription;\n+        rustc_dep_node_try_load_from_on_disk_cache!(dep_node, *self)\n+    }\n+\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n+        self.queries.on_disk_cache.load_diagnostics(*self, prev_dep_node_index)\n+    }\n+\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n+        self.queries.on_disk_cache.store_diagnostics(dep_node_index, diagnostics)\n+    }\n+\n+    fn profiler(&self) -> &SelfProfilerRef {\n+        &self.prof\n+    }\n+}\n+\n+fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    def_id.index == hir_id.owner.local_def_index\n+}\n+\n+impl rustc_query_system::HashStableContext for StableHashingContext<'_> {\n+    fn debug_dep_tasks(&self) -> bool {\n+        self.sess().opts.debugging_opts.dep_tasks\n+    }\n+}\n+\n+impl rustc_query_system::HashStableContextProvider<StableHashingContext<'tcx>> for TyCtxt<'tcx> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'tcx> {\n+        self.create_stable_hashing_context()\n+    }\n+}\n+\n+impl rustc_query_system::HashStableContextProvider<StableHashingContext<'a>>\n+    for StableHashingContext<'a>\n+{\n+    fn get_stable_hashing_context(&self) -> Self {\n+        self.clone()\n+    }\n+}"}, {"sha": "47a1c09672ff60aad8fa8c5f84b788d0e34b1b02", "filename": "src/librustc/dep_graph/safe.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -0,0 +1,9 @@\n+//! The `DepGraphSafe` trait\n+\n+use crate::ty::TyCtxt;\n+\n+pub use rustc_query_system::dep_graph::{AssertDepGraphSafe, DepGraphSafe};\n+\n+/// The type context itself can be used to access all kinds of tracked\n+/// state, but those accesses should always generate read events.\n+impl<'tcx> DepGraphSafe for TyCtxt<'tcx> {}"}, {"sha": "4cfd1f8f3c4d95694bb0a7334ad8de2e2862b831", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -191,16 +191,3 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n \n     false\n }\n-\n-impl DepNode {\n-    /// Check whether the query invocation corresponding to the given\n-    /// DepNode is eligible for on-disk-caching. If so, this is method\n-    /// will execute the query corresponding to the given DepNode.\n-    /// Also, as a sanity check, it expects that the corresponding query\n-    /// invocation has been marked as green already.\n-    pub fn try_load_from_on_disk_cache<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n-        use crate::dep_graph::DepKind;\n-\n-        rustc_dep_node_try_load_from_on_disk_cache!(self, tcx)\n-    }\n-}"}, {"sha": "305e0fcc383ad260bfbece88eedeb9d79ae70361", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -35,7 +35,7 @@\n \n use graphviz as dot;\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n-use rustc::dep_graph::{DepGraphQuery, DepKind, DepNode};\n+use rustc::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use rustc_ast::ast;"}, {"sha": "4fe23a9f7aeef5a1c25b0fd6cd6f314d22be03ac", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -13,7 +13,7 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n-use rustc::dep_graph::{label_strs, DepNode};\n+use rustc::dep_graph::{label_strs, DepContext, DepNode, DepNodeExt};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use rustc_ast::ast::{self, Attribute, NestedMetaItem};\n@@ -382,7 +382,7 @@ impl DirtyCleanVisitor<'tcx> {\n     }\n \n     fn dep_node_str(&self, dep_node: &DepNode) -> String {\n-        if let Some(def_id) = dep_node.extract_def_id(self.tcx) {\n+        if let Some(def_id) = self.tcx.extract_def_id(dep_node) {\n             format!(\"{:?}({})\", dep_node.kind, self.tcx.def_path_str(def_id))\n         } else {\n             format!(\"{:?}({:?})\", dep_node.kind, dep_node.hash)"}, {"sha": "4474543466312a776f77f4774c0499093edd1f20", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -430,13 +430,13 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n                 try_load_from_on_disk_cache_stream.extend(quote! {\n                     DepKind::#name => {\n-                        if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n                             debug_assert!($tcx.dep_graph\n                                             .node_color($dep_node)\n                                             .map(|c| c.is_green())\n                                             .unwrap_or(false));\n \n-                            let key = <#arg as DepNodeParams>::recover($tcx, $dep_node).unwrap();\n+                            let key = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node).unwrap();\n                             if queries::#name::cache_on_disk($tcx, key, None) {\n                                 let _ = $tcx.#name(key);\n                             }\n@@ -487,8 +487,8 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             // Add a match arm to force the query given the dep node\n             dep_node_force_stream.extend(quote! {\n                 DepKind::#name => {\n-                    if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n-                        if let Some(key) = <#arg as DepNodeParams>::recover($tcx, $dep_node) {\n+                    if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n                             $tcx.force_query::<crate::ty::query::queries::#name<'_>>(\n                                 key,\n                                 DUMMY_SP,"}, {"sha": "4e086bcbb2d92e1b7a6c3c0c9cd9eed2a6993345", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -4,7 +4,7 @@ use crate::creader::CrateMetadataRef;\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n-use rustc::dep_graph::{self, DepNode, DepNodeIndex};\n+use rustc::dep_graph::{self, DepNode, DepNodeExt, DepNodeIndex};\n use rustc::hir::exports::Export;\n use rustc::middle::cstore::{CrateSource, ExternCrate};\n use rustc::middle::cstore::{ForeignModule, LinkagePreference, NativeLibrary};"}, {"sha": "c6fff2f01643addd479c5d3f1d00b1c1d508b58d", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7bd5f828faa85880fc3cbac0c7b679e2225321/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=db7bd5f828faa85880fc3cbac0c7b679e2225321", "patch": "@@ -126,19 +126,8 @@ where\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n-#[derive(\n-    Clone,\n-    Copy,\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    RustcEncodable,\n-    RustcDecodable,\n-    HashStable_Generic\n-)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable_Generic)]\n pub struct WorkProductId {\n     hash: Fingerprint,\n }"}]}