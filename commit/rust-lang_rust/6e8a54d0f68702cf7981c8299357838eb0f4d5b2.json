{"sha": "6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "node_id": "C_kwDOAAsO6NoAKDZlOGE1NGQwZjY4NzAyY2Y3OTgxYzgyOTkzNTc4MzhlYjBmNGQ1YjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-07T15:22:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-07T15:22:03Z"}, "message": "Auto merge of #13490 - HKalbasi:layout, r=jonas-schievink\n\nCompute data layout of types\n\ncc #4091\n\nThings that aren't working:\n* Closures\n* Generators (so no support for `Future` I think)\n* Opaque types\n* Type alias and associated types which may need normalization\n\nThings that show wrong result:\n* ~Enums with explicit discriminant~\n* SIMD types\n* ~`NonZero*` and similar standard library items which control layout with special attributes~\n\nAt the user level, I didn't put much work, since I wasn't confident about what is the best way to present this information. Currently it shows size and align for ADTs, and size, align, offset for struct fields, in the hover, similar to clangd. I used it some days and I feel I liked it, but we may consider it too noisy and move it to an assist or command.", "tree": {"sha": "28abe627bdd14ae3ee15462d051c29d1645c8106", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28abe627bdd14ae3ee15462d051c29d1645c8106"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "html_url": "https://github.com/rust-lang/rust/commit/6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "url": "https://api.github.com/repos/rust-lang/rust/commits/df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "html_url": "https://github.com/rust-lang/rust/commit/df07c8fafa78ace4c4d2ded82d561f76a35e0ade"}, {"sha": "948a8f030b51543aedf72188cf8d3ab03d5a3025", "url": "https://api.github.com/repos/rust-lang/rust/commits/948a8f030b51543aedf72188cf8d3ab03d5a3025", "html_url": "https://github.com/rust-lang/rust/commit/948a8f030b51543aedf72188cf8d3ab03d5a3025"}], "stats": {"total": 1276, "additions": 1112, "deletions": 164}, "files": [{"sha": "3d9f0d7cc5b22240ecd1636e6358221d434810f0", "filename": "Cargo.lock", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -510,6 +510,8 @@ dependencies = [\n  \"fst\",\n  \"hashbrown\",\n  \"hir-expand\",\n+ \"hkalbasi-rustc-ap-rustc_abi\",\n+ \"hkalbasi-rustc-ap-rustc_index\",\n  \"indexmap\",\n  \"itertools\",\n  \"la-arena\",\n@@ -564,6 +566,7 @@ dependencies = [\n  \"expect-test\",\n  \"hir-def\",\n  \"hir-expand\",\n+ \"hkalbasi-rustc-ap-rustc_index\",\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n@@ -581,6 +584,27 @@ dependencies = [\n  \"typed-arena\",\n ]\n \n+[[package]]\n+name = \"hkalbasi-rustc-ap-rustc_abi\"\n+version = \"0.0.20221125\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"29c8368a30e518c0102d670d8515f7d424d875ee615ec7a7b6d29217b57a0371\"\n+dependencies = [\n+ \"bitflags\",\n+ \"hkalbasi-rustc-ap-rustc_index\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"hkalbasi-rustc-ap-rustc_index\"\n+version = \"0.0.20221125\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c07bba80d7f6a8e1efb0f3e2115ef1eecbf97292dc8cad84e4982226b9aa12e2\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"smallvec\",\n+]\n+\n [[package]]\n name = \"home\"\n version = \"0.5.4\""}, {"sha": "9ecce46601b65f9ccee1da7d686c6b5e33b68a08", "filename": "crates/hir-def/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2FCargo.toml?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -33,6 +33,8 @@ base-db = { path = \"../base-db\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }\n hir-expand = { path = \"../hir-expand\", version = \"0.0.0\" }\n+rustc_abi = { version = \"0.0.20221125\", package = \"hkalbasi-rustc-ap-rustc_abi\", default-features = false }\n+rustc_index = { version = \"0.0.20221125\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n mbe = { path = \"../mbe\", version = \"0.0.0\" }\n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n tt = { path = \"../tt\", version = \"0.0.0\" }"}, {"sha": "db3b419488147c8c748939973b2b783149ea089a", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -1,6 +1,6 @@\n //! Defines hir-level representation of structs, enums and unions\n \n-use std::{num::NonZeroU32, sync::Arc};\n+use std::sync::Arc;\n \n use base_db::CrateId;\n use either::Either;\n@@ -9,6 +9,7 @@ use hir_expand::{\n     HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n+use rustc_abi::{Integer, IntegerType};\n use syntax::ast::{self, HasName, HasVisibility};\n use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n@@ -18,6 +19,7 @@ use crate::{\n     db::DefDatabase,\n     intern::Interned,\n     item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n+    layout::{Align, ReprFlags, ReprOptions},\n     nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n     src::HasSource,\n@@ -34,7 +36,7 @@ use cfg::CfgOptions;\n pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n-    pub repr: Option<ReprData>,\n+    pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n     pub rustc_has_incoherent_inherent_impls: bool,\n }\n@@ -43,7 +45,7 @@ pub struct StructData {\n pub struct EnumData {\n     pub name: Name,\n     pub variants: Arena<EnumVariantData>,\n-    pub repr: Option<ReprData>,\n+    pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n     pub rustc_has_incoherent_inherent_impls: bool,\n }\n@@ -69,80 +71,91 @@ pub struct FieldData {\n     pub visibility: RawVisibility,\n }\n \n-#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n-pub enum ReprKind {\n-    C,\n-    BuiltinInt { builtin: Either<BuiltinInt, BuiltinUint>, is_c: bool },\n-    Transparent,\n-    Default,\n-}\n-\n-#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n-pub struct ReprData {\n-    pub kind: ReprKind,\n-    pub packed: bool,\n-    pub align: Option<NonZeroU32>,\n-}\n-\n fn repr_from_value(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n     item_tree: &ItemTree,\n     of: AttrOwner,\n-) -> Option<ReprData> {\n+) -> Option<ReprOptions> {\n     item_tree.attrs(db, krate, of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n }\n \n-fn parse_repr_tt(tt: &Subtree) -> Option<ReprData> {\n+fn parse_repr_tt(tt: &Subtree) -> Option<ReprOptions> {\n     match tt.delimiter {\n         Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n         _ => return None,\n     }\n \n-    let mut data = ReprData { kind: ReprKind::Default, packed: false, align: None };\n+    let mut flags = ReprFlags::empty();\n+    let mut int = None;\n+    let mut max_align: Option<Align> = None;\n+    let mut min_pack: Option<Align> = None;\n \n     let mut tts = tt.token_trees.iter().peekable();\n     while let Some(tt) = tts.next() {\n         if let TokenTree::Leaf(Leaf::Ident(ident)) = tt {\n-            match &*ident.text {\n+            flags.insert(match &*ident.text {\n                 \"packed\" => {\n-                    data.packed = true;\n-                    if let Some(TokenTree::Subtree(_)) = tts.peek() {\n+                    let pack = if let Some(TokenTree::Subtree(tt)) = tts.peek() {\n                         tts.next();\n-                    }\n+                        if let Some(TokenTree::Leaf(Leaf::Literal(lit))) = tt.token_trees.first() {\n+                            lit.text.parse().unwrap_or_default()\n+                        } else {\n+                            0\n+                        }\n+                    } else {\n+                        0\n+                    };\n+                    let pack = Align::from_bytes(pack).unwrap();\n+                    min_pack =\n+                        Some(if let Some(min_pack) = min_pack { min_pack.min(pack) } else { pack });\n+                    ReprFlags::empty()\n                 }\n                 \"align\" => {\n                     if let Some(TokenTree::Subtree(tt)) = tts.peek() {\n                         tts.next();\n                         if let Some(TokenTree::Leaf(Leaf::Literal(lit))) = tt.token_trees.first() {\n                             if let Ok(align) = lit.text.parse() {\n-                                data.align = Some(align);\n+                                let align = Align::from_bytes(align).ok();\n+                                max_align = max_align.max(align);\n                             }\n                         }\n                     }\n+                    ReprFlags::empty()\n                 }\n-                \"C\" => {\n-                    if let ReprKind::BuiltinInt { is_c, .. } = &mut data.kind {\n-                        *is_c = true;\n-                    } else {\n-                        data.kind = ReprKind::C;\n-                    }\n-                }\n-                \"transparent\" => data.kind = ReprKind::Transparent,\n+                \"C\" => ReprFlags::IS_C,\n+                \"transparent\" => ReprFlags::IS_TRANSPARENT,\n                 repr => {\n-                    let is_c = matches!(data.kind, ReprKind::C);\n                     if let Some(builtin) = BuiltinInt::from_suffix(repr)\n                         .map(Either::Left)\n                         .or_else(|| BuiltinUint::from_suffix(repr).map(Either::Right))\n                     {\n-                        data.kind = ReprKind::BuiltinInt { builtin, is_c };\n+                        int = Some(match builtin {\n+                            Either::Left(bi) => match bi {\n+                                BuiltinInt::Isize => IntegerType::Pointer(true),\n+                                BuiltinInt::I8 => IntegerType::Fixed(Integer::I8, true),\n+                                BuiltinInt::I16 => IntegerType::Fixed(Integer::I16, true),\n+                                BuiltinInt::I32 => IntegerType::Fixed(Integer::I32, true),\n+                                BuiltinInt::I64 => IntegerType::Fixed(Integer::I64, true),\n+                                BuiltinInt::I128 => IntegerType::Fixed(Integer::I128, true),\n+                            },\n+                            Either::Right(bu) => match bu {\n+                                BuiltinUint::Usize => IntegerType::Pointer(false),\n+                                BuiltinUint::U8 => IntegerType::Fixed(Integer::I8, false),\n+                                BuiltinUint::U16 => IntegerType::Fixed(Integer::I16, false),\n+                                BuiltinUint::U32 => IntegerType::Fixed(Integer::I32, false),\n+                                BuiltinUint::U64 => IntegerType::Fixed(Integer::I64, false),\n+                                BuiltinUint::U128 => IntegerType::Fixed(Integer::I128, false),\n+                            },\n+                        });\n                     }\n+                    ReprFlags::empty()\n                 }\n-            }\n+            })\n         }\n     }\n \n-    Some(data)\n+    Some(ReprOptions { int, align: max_align, pack: min_pack, flags, field_shuffle_seed: 0 })\n }\n \n impl StructData {\n@@ -299,10 +312,10 @@ impl EnumData {\n         Some(id)\n     }\n \n-    pub fn variant_body_type(&self) -> Either<BuiltinInt, BuiltinUint> {\n+    pub fn variant_body_type(&self) -> IntegerType {\n         match self.repr {\n-            Some(ReprData { kind: ReprKind::BuiltinInt { builtin, .. }, .. }) => builtin,\n-            _ => Either::Left(BuiltinInt::Isize),\n+            Some(ReprOptions { int: Some(builtin), .. }) => builtin,\n+            _ => IntegerType::Pointer(true),\n         }\n     }\n }"}, {"sha": "a427c464bc02dbe0e30c0ebc295fadcf6ef7d6ee", "filename": "crates/hir-def/src/layout.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-def%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-def%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flayout.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -0,0 +1,96 @@\n+//! Definitions needed for computing data layout of types.\n+\n+use std::cmp;\n+\n+use la_arena::{Idx, RawIdx};\n+pub use rustc_abi::{\n+    Abi, AbiAndPrefAlign, AddressSpace, Align, Endian, FieldsShape, Integer, IntegerType,\n+    LayoutCalculator, Niche, Primitive, ReprFlags, ReprOptions, Scalar, Size, StructKind,\n+    TargetDataLayout, WrappingRange,\n+};\n+\n+use crate::LocalEnumVariantId;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct RustcEnumVariantIdx(pub LocalEnumVariantId);\n+\n+impl rustc_index::vec::Idx for RustcEnumVariantIdx {\n+    fn new(idx: usize) -> Self {\n+        RustcEnumVariantIdx(Idx::from_raw(RawIdx::from(idx as u32)))\n+    }\n+\n+    fn index(self) -> usize {\n+        u32::from(self.0.into_raw()) as usize\n+    }\n+}\n+\n+pub type Layout = rustc_abi::LayoutS<RustcEnumVariantIdx>;\n+pub type TagEncoding = rustc_abi::TagEncoding<RustcEnumVariantIdx>;\n+pub type Variants = rustc_abi::Variants<RustcEnumVariantIdx>;\n+\n+pub trait IntegerExt {\n+    fn repr_discr(\n+        dl: &TargetDataLayout,\n+        repr: &ReprOptions,\n+        min: i128,\n+        max: i128,\n+    ) -> Result<(Integer, bool), LayoutError>;\n+}\n+\n+impl IntegerExt for Integer {\n+    /// Finds the appropriate Integer type and signedness for the given\n+    /// signed discriminant range and `#[repr]` attribute.\n+    /// N.B.: `u128` values above `i128::MAX` will be treated as signed, but\n+    /// that shouldn't affect anything, other than maybe debuginfo.\n+    fn repr_discr(\n+        dl: &TargetDataLayout,\n+        repr: &ReprOptions,\n+        min: i128,\n+        max: i128,\n+    ) -> Result<(Integer, bool), LayoutError> {\n+        // Theoretically, negative values could be larger in unsigned representation\n+        // than the unsigned representation of the signed minimum. However, if there\n+        // are any negative values, the only valid unsigned representation is u128\n+        // which can fit all i128 values, so the result remains unaffected.\n+        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u128, max as u128));\n+        let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n+\n+        if let Some(ity) = repr.int {\n+            let discr = Integer::from_attr(dl, ity);\n+            let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+            if discr < fit {\n+                return Err(LayoutError::UserError(\n+                    \"Integer::repr_discr: `#[repr]` hint too small for \\\n+                      discriminant range of enum \"\n+                        .to_string(),\n+                ));\n+            }\n+            return Ok((discr, ity.is_signed()));\n+        }\n+\n+        let at_least = if repr.c() {\n+            // This is usually I32, however it can be different on some platforms,\n+            // notably hexagon and arm-none/thumb-none\n+            dl.c_enum_min_size\n+        } else {\n+            // repr(Rust) enums try to be as small as possible\n+            Integer::I8\n+        };\n+\n+        // If there are no negative values, we can use the unsigned fit.\n+        Ok(if min >= 0 {\n+            (cmp::max(unsigned_fit, at_least), false)\n+        } else {\n+            (cmp::max(signed_fit, at_least), true)\n+        })\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum LayoutError {\n+    UserError(String),\n+    SizeOverflow,\n+    HasPlaceholder,\n+    NotImplemented,\n+    Unknown,\n+}"}, {"sha": "8267ef09cb0a2e81b39d91def9927dfa541c94a6", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -34,6 +34,7 @@ pub mod adt;\n pub mod data;\n pub mod generics;\n pub mod lang_item;\n+pub mod layout;\n \n pub mod expr;\n pub mod body;"}, {"sha": "beff3f6ad9624ebdf55846253de9d356cd52e15c", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -419,6 +419,7 @@ pub mod known {\n         shr,\n         sub_assign,\n         sub,\n+        unsafe_cell,\n         va_list\n     );\n "}, {"sha": "e4dd244ab858d02b9fffa846e3b77c76fcee3d78", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -25,6 +25,7 @@ chalk-derive = \"0.88.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.15.0\"\n typed-arena = \"2.0.1\"\n+rustc_index = { version = \"0.0.20221125\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n hir-def = { path = \"../hir-def\", version = \"0.0.0\" }"}, {"sha": "23ad335aac759a619b07a05e09a7bc609bf205f7", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -5,8 +5,11 @@ use std::sync::Arc;\n \n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId,\n-    FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n+    db::DefDatabase,\n+    expr::ExprId,\n+    layout::{Layout, LayoutError, TargetDataLayout},\n+    AdtId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId, FunctionId, GenericDefId,\n+    ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n use smallvec::SmallVec;\n@@ -16,7 +19,7 @@ use crate::{\n     consteval::{ComputedExpr, ConstEvalError},\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n     Binders, CallableDefId, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n-    QuantifiedWhereClause, ReturnTypeImplTraits, TraitRef, Ty, TyDefId, ValueTyDefId,\n+    QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -57,6 +60,13 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::field_types_query)]\n     fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Binders<Ty>>>;\n \n+    #[salsa::invoke(crate::layout::layout_of_adt_query)]\n+    #[salsa::cycle(crate::layout::layout_of_adt_recover)]\n+    fn layout_of_adt(&self, def: AdtId, subst: Substitution) -> Result<Layout, LayoutError>;\n+\n+    #[salsa::invoke(crate::layout::current_target_data_layout_query)]\n+    fn current_target_data_layout(&self) -> Arc<TargetDataLayout>;\n+\n     #[salsa::invoke(crate::lower::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDefId) -> PolyFnSig;\n "}, {"sha": "e0905e01b6a1a49cd92fad87bb519b838230e424", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -12,16 +12,16 @@ pub(crate) mod usefulness;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    adt::VariantData, body::Body, expr::PatId, AdtId, EnumVariantId, HasModule, LocalFieldId,\n-    VariantId,\n+    adt::VariantData, body::Body, expr::PatId, AdtId, EnumVariantId, LocalFieldId, VariantId,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::Name;\n use stdx::{always, never};\n \n use crate::{\n     db::HirDatabase,\n     display::{HirDisplay, HirDisplayError, HirFormatter},\n     infer::BindingMode,\n+    lang_items::is_box,\n     InferenceResult, Interner, Substitution, Ty, TyExt, TyKind,\n };\n \n@@ -405,13 +405,6 @@ where\n     }\n }\n \n-fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let owned_box = name![owned_box].to_smol_str();\n-    let krate = adt.module(db.upcast()).krate();\n-    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n-    Some(adt) == box_adt\n-}\n-\n pub(crate) trait PatternFoldable: Sized {\n     fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)"}, {"sha": "874a54fc3ee185717b75f590b43eacd3e29e91fd", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -19,10 +19,11 @@ use std::sync::Arc;\n use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n     body::Body,\n-    builtin_type::BuiltinType,\n+    builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n     expr::{BindingAnnotation, ExprId, PatId},\n     lang_item::LangItemTarget,\n+    layout::Integer,\n     path::{path, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n@@ -70,8 +71,26 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n         DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n         DefWithBodyId::VariantId(v) => {\n             ctx.return_ty = TyBuilder::builtin(match db.enum_data(v.parent).variant_body_type() {\n-                Either::Left(builtin) => BuiltinType::Int(builtin),\n-                Either::Right(builtin) => BuiltinType::Uint(builtin),\n+                hir_def::layout::IntegerType::Pointer(signed) => match signed {\n+                    true => BuiltinType::Int(BuiltinInt::Isize),\n+                    false => BuiltinType::Uint(BuiltinUint::Usize),\n+                },\n+                hir_def::layout::IntegerType::Fixed(size, signed) => match signed {\n+                    true => BuiltinType::Int(match size {\n+                        Integer::I8 => BuiltinInt::I8,\n+                        Integer::I16 => BuiltinInt::I16,\n+                        Integer::I32 => BuiltinInt::I32,\n+                        Integer::I64 => BuiltinInt::I64,\n+                        Integer::I128 => BuiltinInt::I128,\n+                    }),\n+                    false => BuiltinType::Uint(match size {\n+                        Integer::I8 => BuiltinUint::U8,\n+                        Integer::I16 => BuiltinUint::U16,\n+                        Integer::I32 => BuiltinUint::U32,\n+                        Integer::I64 => BuiltinUint::U64,\n+                        Integer::I128 => BuiltinUint::U128,\n+                    }),\n+                },\n             });\n         }\n     }"}, {"sha": "afc54e729f9c3972e2134692eafa748a2ec223dd", "filename": "crates/hir-ty/src/lang_items.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flang_items.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -0,0 +1,20 @@\n+//! Functions to detect special lang items\n+\n+use hir_def::{AdtId, HasModule};\n+use hir_expand::name;\n+\n+use crate::db::HirDatabase;\n+\n+pub fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n+    let owned_box = name![owned_box].to_smol_str();\n+    let krate = adt.module(db.upcast()).krate();\n+    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    Some(adt) == box_adt\n+}\n+\n+pub fn is_unsafe_cell(adt: AdtId, db: &dyn HirDatabase) -> bool {\n+    let owned_box = name![unsafe_cell].to_smol_str();\n+    let krate = adt.module(db.upcast()).krate();\n+    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    Some(adt) == box_adt\n+}"}, {"sha": "3c6489fa97b0010100456ce0b5d48165f95850fa", "filename": "crates/hir-ty/src/layout.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -0,0 +1,272 @@\n+//! Compute the binary representation of a type\n+\n+use std::sync::Arc;\n+\n+use chalk_ir::{AdtId, TyKind};\n+pub(self) use hir_def::layout::*;\n+use hir_def::LocalFieldId;\n+use stdx::never;\n+\n+use crate::{db::HirDatabase, Interner, Substitution, Ty};\n+\n+use self::adt::struct_variant_idx;\n+pub use self::{\n+    adt::{layout_of_adt_query, layout_of_adt_recover},\n+    target::current_target_data_layout_query,\n+};\n+\n+macro_rules! user_error {\n+    ($x: expr) => {\n+        return Err(LayoutError::UserError(format!($x)))\n+    };\n+}\n+\n+mod adt;\n+mod target;\n+\n+struct LayoutCx<'a> {\n+    db: &'a dyn HirDatabase,\n+}\n+\n+impl LayoutCalculator for LayoutCx<'_> {\n+    type TargetDataLayoutRef = Arc<TargetDataLayout>;\n+\n+    fn delay_bug(&self, txt: &str) {\n+        never!(\"{}\", txt);\n+    }\n+\n+    fn current_data_layout(&self) -> Arc<TargetDataLayout> {\n+        self.db.current_target_data_layout()\n+    }\n+}\n+\n+fn scalar_unit(dl: &TargetDataLayout, value: Primitive) -> Scalar {\n+    Scalar::Initialized { value, valid_range: WrappingRange::full(value.size(dl)) }\n+}\n+\n+fn scalar(dl: &TargetDataLayout, value: Primitive) -> Layout {\n+    Layout::scalar(dl, scalar_unit(dl, value))\n+}\n+\n+pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty) -> Result<Layout, LayoutError> {\n+    let dl = &*db.current_target_data_layout();\n+    let cx = LayoutCx { db };\n+    Ok(match ty.kind(Interner) {\n+        TyKind::Adt(AdtId(def), subst) => db.layout_of_adt(*def, subst.clone())?,\n+        TyKind::Scalar(s) => match s {\n+            chalk_ir::Scalar::Bool => Layout::scalar(\n+                dl,\n+                Scalar::Initialized {\n+                    value: Primitive::Int(Integer::I8, false),\n+                    valid_range: WrappingRange { start: 0, end: 1 },\n+                },\n+            ),\n+            chalk_ir::Scalar::Char => Layout::scalar(\n+                dl,\n+                Scalar::Initialized {\n+                    value: Primitive::Int(Integer::I32, false),\n+                    valid_range: WrappingRange { start: 0, end: 0x10FFFF },\n+                },\n+            ),\n+            chalk_ir::Scalar::Int(i) => scalar(\n+                dl,\n+                Primitive::Int(\n+                    match i {\n+                        chalk_ir::IntTy::Isize => dl.ptr_sized_integer(),\n+                        chalk_ir::IntTy::I8 => Integer::I8,\n+                        chalk_ir::IntTy::I16 => Integer::I16,\n+                        chalk_ir::IntTy::I32 => Integer::I32,\n+                        chalk_ir::IntTy::I64 => Integer::I64,\n+                        chalk_ir::IntTy::I128 => Integer::I128,\n+                    },\n+                    false,\n+                ),\n+            ),\n+            chalk_ir::Scalar::Uint(i) => scalar(\n+                dl,\n+                Primitive::Int(\n+                    match i {\n+                        chalk_ir::UintTy::Usize => dl.ptr_sized_integer(),\n+                        chalk_ir::UintTy::U8 => Integer::I8,\n+                        chalk_ir::UintTy::U16 => Integer::I16,\n+                        chalk_ir::UintTy::U32 => Integer::I32,\n+                        chalk_ir::UintTy::U64 => Integer::I64,\n+                        chalk_ir::UintTy::U128 => Integer::I128,\n+                    },\n+                    true,\n+                ),\n+            ),\n+            chalk_ir::Scalar::Float(f) => scalar(\n+                dl,\n+                match f {\n+                    chalk_ir::FloatTy::F32 => Primitive::F32,\n+                    chalk_ir::FloatTy::F64 => Primitive::F64,\n+                },\n+            ),\n+        },\n+        TyKind::Tuple(len, tys) => {\n+            let kind = if *len == 0 { StructKind::AlwaysSized } else { StructKind::MaybeUnsized };\n+\n+            let fields = tys\n+                .iter(Interner)\n+                .map(|k| layout_of_ty(db, k.assert_ty_ref(Interner)))\n+                .collect::<Result<Vec<_>, _>>()?;\n+            let fields = fields.iter().collect::<Vec<_>>();\n+            let fields = fields.iter().collect::<Vec<_>>();\n+            cx.univariant(dl, &fields, &ReprOptions::default(), kind).ok_or(LayoutError::Unknown)?\n+        }\n+        TyKind::Array(element, count) => {\n+            let count = match count.data(Interner).value {\n+                chalk_ir::ConstValue::Concrete(c) => match c.interned {\n+                    hir_def::type_ref::ConstScalar::Int(x) => x as u64,\n+                    hir_def::type_ref::ConstScalar::UInt(x) => x as u64,\n+                    hir_def::type_ref::ConstScalar::Unknown => {\n+                        user_error!(\"unknown const generic parameter\")\n+                    }\n+                    _ => user_error!(\"mismatched type of const generic parameter\"),\n+                },\n+                _ => return Err(LayoutError::HasPlaceholder),\n+            };\n+            let element = layout_of_ty(db, element)?;\n+            let size = element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow)?;\n+\n+            let abi = if count != 0 && matches!(element.abi, Abi::Uninhabited) {\n+                Abi::Uninhabited\n+            } else {\n+                Abi::Aggregate { sized: true }\n+            };\n+\n+            let largest_niche = if count != 0 { element.largest_niche } else { None };\n+\n+            Layout {\n+                variants: Variants::Single { index: struct_variant_idx() },\n+                fields: FieldsShape::Array { stride: element.size, count },\n+                abi,\n+                largest_niche,\n+                align: element.align,\n+                size,\n+            }\n+        }\n+        TyKind::Slice(element) => {\n+            let element = layout_of_ty(db, element)?;\n+            Layout {\n+                variants: Variants::Single { index: struct_variant_idx() },\n+                fields: FieldsShape::Array { stride: element.size, count: 0 },\n+                abi: Abi::Aggregate { sized: false },\n+                largest_niche: None,\n+                align: element.align,\n+                size: Size::ZERO,\n+            }\n+        }\n+        // Potentially-wide pointers.\n+        TyKind::Ref(_, _, pointee) | TyKind::Raw(_, pointee) => {\n+            let mut data_ptr = scalar_unit(dl, Primitive::Pointer);\n+            if matches!(ty.kind(Interner), TyKind::Ref(..)) {\n+                data_ptr.valid_range_mut().start = 1;\n+            }\n+\n+            // let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n+            // if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n+            //     return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n+            // }\n+\n+            let unsized_part = struct_tail_erasing_lifetimes(db, pointee.clone());\n+            let metadata = match unsized_part.kind(Interner) {\n+                TyKind::Slice(_) | TyKind::Str => {\n+                    scalar_unit(dl, Primitive::Int(dl.ptr_sized_integer(), false))\n+                }\n+                TyKind::Dyn(..) => {\n+                    let mut vtable = scalar_unit(dl, Primitive::Pointer);\n+                    vtable.valid_range_mut().start = 1;\n+                    vtable\n+                }\n+                _ => {\n+                    // pointee is sized\n+                    return Ok(Layout::scalar(dl, data_ptr));\n+                }\n+            };\n+\n+            // Effectively a (ptr, meta) tuple.\n+            cx.scalar_pair(data_ptr, metadata)\n+        }\n+        TyKind::FnDef(_, _) => layout_of_unit(&cx, dl)?,\n+        TyKind::Str => Layout {\n+            variants: Variants::Single { index: struct_variant_idx() },\n+            fields: FieldsShape::Array { stride: Size::from_bytes(1), count: 0 },\n+            abi: Abi::Aggregate { sized: false },\n+            largest_niche: None,\n+            align: dl.i8_align,\n+            size: Size::ZERO,\n+        },\n+        TyKind::Never => Layout {\n+            variants: Variants::Single { index: struct_variant_idx() },\n+            fields: FieldsShape::Primitive,\n+            abi: Abi::Uninhabited,\n+            largest_niche: None,\n+            align: dl.i8_align,\n+            size: Size::ZERO,\n+        },\n+        TyKind::Dyn(_) | TyKind::Foreign(_) => {\n+            let mut unit = layout_of_unit(&cx, dl)?;\n+            match unit.abi {\n+                Abi::Aggregate { ref mut sized } => *sized = false,\n+                _ => user_error!(\"bug\"),\n+            }\n+            unit\n+        }\n+        TyKind::Function(_) => {\n+            let mut ptr = scalar_unit(dl, Primitive::Pointer);\n+            ptr.valid_range_mut().start = 1;\n+            Layout::scalar(dl, ptr)\n+        }\n+        TyKind::Closure(_, _)\n+        | TyKind::OpaqueType(_, _)\n+        | TyKind::Generator(_, _)\n+        | TyKind::GeneratorWitness(_, _) => return Err(LayoutError::NotImplemented),\n+        TyKind::AssociatedType(_, _)\n+        | TyKind::Error\n+        | TyKind::Alias(_)\n+        | TyKind::Placeholder(_)\n+        | TyKind::BoundVar(_)\n+        | TyKind::InferenceVar(_, _) => return Err(LayoutError::HasPlaceholder),\n+    })\n+}\n+\n+fn layout_of_unit(cx: &LayoutCx<'_>, dl: &TargetDataLayout) -> Result<Layout, LayoutError> {\n+    cx.univariant::<RustcEnumVariantIdx, &&Layout>(\n+        &dl,\n+        &[],\n+        &ReprOptions::default(),\n+        StructKind::AlwaysSized,\n+    )\n+    .ok_or(LayoutError::Unknown)\n+}\n+\n+fn struct_tail_erasing_lifetimes(db: &dyn HirDatabase, pointee: Ty) -> Ty {\n+    match pointee.kind(Interner) {\n+        TyKind::Adt(AdtId(adt), subst) => match adt {\n+            &hir_def::AdtId::StructId(i) => {\n+                let data = db.struct_data(i);\n+                let mut it = data.variant_data.fields().iter().rev();\n+                match it.next() {\n+                    Some((f, _)) => field_ty(db, i.into(), f, subst),\n+                    None => pointee,\n+                }\n+            }\n+            _ => pointee,\n+        },\n+        _ => pointee,\n+    }\n+}\n+\n+fn field_ty(\n+    db: &dyn HirDatabase,\n+    def: hir_def::VariantId,\n+    fd: LocalFieldId,\n+    subst: &Substitution,\n+) -> Ty {\n+    db.field_types(def)[fd].clone().substitute(Interner, subst)\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "d9791a4b630d0d6bebddc4e878311db363d5e9f0", "filename": "crates/hir-ty/src/layout/adt.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -0,0 +1,133 @@\n+//! Compute the binary representation of structs, unions and enums\n+\n+use std::ops::Bound;\n+\n+use hir_def::{\n+    adt::VariantData,\n+    layout::{Integer, IntegerExt, Layout, LayoutCalculator, LayoutError, RustcEnumVariantIdx},\n+    AdtId, EnumVariantId, LocalEnumVariantId, VariantId,\n+};\n+use la_arena::RawIdx;\n+use rustc_index::vec::IndexVec;\n+\n+use crate::{db::HirDatabase, lang_items::is_unsafe_cell, layout::field_ty, Substitution};\n+\n+use super::{layout_of_ty, LayoutCx};\n+\n+pub(crate) fn struct_variant_idx() -> RustcEnumVariantIdx {\n+    RustcEnumVariantIdx(LocalEnumVariantId::from_raw(RawIdx::from(0)))\n+}\n+\n+pub fn layout_of_adt_query(\n+    db: &dyn HirDatabase,\n+    def: AdtId,\n+    subst: Substitution,\n+) -> Result<Layout, LayoutError> {\n+    let dl = db.current_target_data_layout();\n+    let cx = LayoutCx { db };\n+    let handle_variant = |def: VariantId, var: &VariantData| {\n+        var.fields()\n+            .iter()\n+            .map(|(fd, _)| layout_of_ty(db, &field_ty(db, def, fd, &subst)))\n+            .collect::<Result<Vec<_>, _>>()\n+    };\n+    let (variants, is_enum, is_union, repr) = match def {\n+        AdtId::StructId(s) => {\n+            let data = db.struct_data(s);\n+            let mut r = IndexVec::new();\n+            r.push(handle_variant(s.into(), &data.variant_data)?);\n+            (r, false, false, data.repr.unwrap_or_default())\n+        }\n+        AdtId::UnionId(id) => {\n+            let data = db.union_data(id);\n+            let mut r = IndexVec::new();\n+            r.push(handle_variant(id.into(), &data.variant_data)?);\n+            (r, false, true, data.repr.unwrap_or_default())\n+        }\n+        AdtId::EnumId(e) => {\n+            let data = db.enum_data(e);\n+            let r = data\n+                .variants\n+                .iter()\n+                .map(|(idx, v)| {\n+                    handle_variant(\n+                        EnumVariantId { parent: e, local_id: idx }.into(),\n+                        &v.variant_data,\n+                    )\n+                })\n+                .collect::<Result<IndexVec<RustcEnumVariantIdx, _>, _>>()?;\n+            (r, true, false, data.repr.unwrap_or_default())\n+        }\n+    };\n+    let variants = variants.iter().map(|x| x.iter().collect::<Vec<_>>()).collect::<Vec<_>>();\n+    let variants = variants.iter().map(|x| x.iter().collect()).collect();\n+    if is_union {\n+        cx.layout_of_union(&repr, &variants).ok_or(LayoutError::Unknown)\n+    } else {\n+        cx.layout_of_struct_or_enum(\n+            &repr,\n+            &variants,\n+            is_enum,\n+            is_unsafe_cell(def, db),\n+            layout_scalar_valid_range(db, def),\n+            |min, max| Integer::repr_discr(&dl, &repr, min, max).unwrap_or((Integer::I8, false)),\n+            variants.iter_enumerated().filter_map(|(id, _)| {\n+                let AdtId::EnumId(e) = def else { return None };\n+                let d = match db\n+                    .const_eval_variant(EnumVariantId { parent: e, local_id: id.0 })\n+                    .ok()?\n+                {\n+                    crate::consteval::ComputedExpr::Literal(l) => match l {\n+                        hir_def::expr::Literal::Int(i, _) => i,\n+                        hir_def::expr::Literal::Uint(i, _) => i as i128,\n+                        _ => return None,\n+                    },\n+                    _ => return None,\n+                };\n+                Some((id, d))\n+            }),\n+            // FIXME: The current code for niche-filling relies on variant indices\n+            // instead of actual discriminants, so enums with\n+            // explicit discriminants (RFC #2363) would misbehave and we should disable\n+            // niche optimization for them.\n+            // The code that do it in rustc:\n+            // repr.inhibit_enum_layout_opt() || def\n+            //     .variants()\n+            //     .iter_enumerated()\n+            //     .any(|(i, v)| v.discr != ty::VariantDiscr::Relative(i.as_u32()))\n+            repr.inhibit_enum_layout_opt(),\n+            !is_enum\n+                && variants\n+                    .iter()\n+                    .next()\n+                    .and_then(|x| x.last().map(|x| x.is_unsized()))\n+                    .unwrap_or(true),\n+        )\n+        .ok_or(LayoutError::SizeOverflow)\n+    }\n+}\n+\n+fn layout_scalar_valid_range(db: &dyn HirDatabase, def: AdtId) -> (Bound<u128>, Bound<u128>) {\n+    let attrs = db.attrs(def.into());\n+    let get = |name| {\n+        let attr = attrs.by_key(name).tt_values();\n+        for tree in attr {\n+            if let Some(x) = tree.token_trees.first() {\n+                if let Ok(x) = x.to_string().parse() {\n+                    return Bound::Included(x);\n+                }\n+            }\n+        }\n+        Bound::Unbounded\n+    };\n+    (get(\"rustc_layout_scalar_valid_range_start\"), get(\"rustc_layout_scalar_valid_range_end\"))\n+}\n+\n+pub fn layout_of_adt_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &AdtId,\n+    _: &Substitution,\n+) -> Result<Layout, LayoutError> {\n+    user_error!(\"infinite sized recursive type\");\n+}"}, {"sha": "b76274bb8548516e9fdfac92ca5c45907d690423", "filename": "crates/hir-ty/src/layout/target.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -0,0 +1,46 @@\n+//! Target dependent parameters needed for layouts\n+\n+use std::sync::Arc;\n+\n+use hir_def::layout::TargetDataLayout;\n+\n+use crate::db::HirDatabase;\n+\n+use super::{AbiAndPrefAlign, AddressSpace, Align, Endian, Integer, Size};\n+\n+pub fn current_target_data_layout_query(db: &dyn HirDatabase) -> Arc<TargetDataLayout> {\n+    let crate_graph = db.crate_graph();\n+    let cfg_options = &crate_graph[crate_graph.iter().next().unwrap()].cfg_options;\n+    let endian = match cfg_options.get_cfg_values(\"target_endian\").next() {\n+        Some(x) if x.as_str() == \"big\" => Endian::Big,\n+        _ => Endian::Little,\n+    };\n+    let pointer_size =\n+        Size::from_bytes(match cfg_options.get_cfg_values(\"target_pointer_width\").next() {\n+            Some(x) => match x.as_str() {\n+                \"16\" => 2,\n+                \"32\" => 4,\n+                _ => 8,\n+            },\n+            _ => 8,\n+        });\n+    // FIXME: These values are incorrect for many architectures, at least for aarch64 and riscv64,\n+    // use `rustc +nightly -Z unstable-options --print target-spec-json` or something similar instead.\n+    Arc::new(TargetDataLayout {\n+        endian,\n+        i1_align: AbiAndPrefAlign::new(Align::from_bytes(1).unwrap()),\n+        i8_align: AbiAndPrefAlign::new(Align::from_bytes(1).unwrap()),\n+        i16_align: AbiAndPrefAlign::new(Align::from_bytes(2).unwrap()),\n+        i32_align: AbiAndPrefAlign::new(Align::from_bytes(4).unwrap()),\n+        i64_align: AbiAndPrefAlign::new(Align::from_bytes(8).unwrap()),\n+        i128_align: AbiAndPrefAlign::new(Align::from_bytes(8).unwrap()),\n+        f32_align: AbiAndPrefAlign::new(Align::from_bytes(4).unwrap()),\n+        f64_align: AbiAndPrefAlign::new(Align::from_bytes(8).unwrap()),\n+        pointer_size,\n+        pointer_align: AbiAndPrefAlign::new(Align::from_bytes(pointer_size.bytes()).unwrap()),\n+        aggregate_align: AbiAndPrefAlign::new(Align::from_bytes(1).unwrap()),\n+        vector_align: vec![],\n+        instruction_address_space: AddressSpace(0),\n+        c_enum_min_size: Integer::I32,\n+    })\n+}"}, {"sha": "5d97a69501f018708c89879f4c63695ea037a0c5", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -0,0 +1,196 @@\n+use base_db::fixture::WithFixture;\n+use chalk_ir::{AdtId, TyKind};\n+use hir_def::{\n+    db::DefDatabase,\n+    layout::{Layout, LayoutError},\n+};\n+\n+use crate::{test_db::TestDB, Interner, Substitution};\n+\n+use super::layout_of_ty;\n+\n+fn eval_goal(ra_fixture: &str) -> Result<Layout, LayoutError> {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let module_id = db.module_for_file(file_id);\n+    let def_map = module_id.def_map(&db);\n+    let scope = &def_map[module_id.local_id].scope;\n+    let adt_id = scope\n+        .declarations()\n+        .into_iter()\n+        .find_map(|x| match x {\n+            hir_def::ModuleDefId::AdtId(x) => {\n+                let name = match x {\n+                    hir_def::AdtId::StructId(x) => db.struct_data(x).name.to_string(),\n+                    hir_def::AdtId::UnionId(x) => db.union_data(x).name.to_string(),\n+                    hir_def::AdtId::EnumId(x) => db.enum_data(x).name.to_string(),\n+                };\n+                if name == \"Goal\" {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        })\n+        .unwrap();\n+    let goal_ty = TyKind::Adt(AdtId(adt_id), Substitution::empty(Interner)).intern(Interner);\n+    layout_of_ty(&db, &goal_ty)\n+}\n+\n+fn check_size_and_align(ra_fixture: &str, size: u64, align: u64) {\n+    let l = eval_goal(ra_fixture).unwrap();\n+    assert_eq!(l.size.bytes(), size);\n+    assert_eq!(l.align.abi.bytes(), align);\n+}\n+\n+fn check_fail(ra_fixture: &str, e: LayoutError) {\n+    let r = eval_goal(ra_fixture);\n+    assert_eq!(r, Err(e));\n+}\n+\n+macro_rules! size_and_align {\n+    (minicore: $($x:tt),*;$($t:tt)*) => {\n+        {\n+            #[allow(dead_code)]\n+            $($t)*\n+            check_size_and_align(\n+                &format!(\"//- minicore: {}\\n{}\", stringify!($($x),*), stringify!($($t)*)),\n+                ::std::mem::size_of::<Goal>() as u64,\n+                ::std::mem::align_of::<Goal>() as u64,\n+            );\n+        }\n+    };\n+    ($($t:tt)*) => {\n+        {\n+            #[allow(dead_code)]\n+            $($t)*\n+            check_size_and_align(\n+                stringify!($($t)*),\n+                ::std::mem::size_of::<Goal>() as u64,\n+                ::std::mem::align_of::<Goal>() as u64,\n+            );\n+        }\n+    };\n+}\n+\n+#[test]\n+fn hello_world() {\n+    size_and_align! {\n+        struct Goal(i32);\n+    }\n+}\n+\n+#[test]\n+fn field_order_optimization() {\n+    size_and_align! {\n+        struct Goal(u8, i32, u8);\n+    }\n+    size_and_align! {\n+        #[repr(C)]\n+        struct Goal(u8, i32, u8);\n+    }\n+}\n+\n+#[test]\n+fn recursive() {\n+    size_and_align! {\n+        struct Goal {\n+            left: &'static Goal,\n+            right: &'static Goal,\n+        }\n+    }\n+    size_and_align! {\n+        struct BoxLike<T: ?Sized>(*mut T);\n+        struct Goal(BoxLike<Goal>);\n+    }\n+    check_fail(\n+        r#\"struct Goal(Goal);\"#,\n+        LayoutError::UserError(\"infinite sized recursive type\".to_string()),\n+    );\n+    check_fail(\n+        r#\"\n+        struct Foo<T>(Foo<T>);\n+        struct Goal(Foo<i32>);\n+        \"#,\n+        LayoutError::UserError(\"infinite sized recursive type\".to_string()),\n+    );\n+}\n+\n+#[test]\n+fn generic() {\n+    size_and_align! {\n+        struct Pair<A, B>(A, B);\n+        struct Goal(Pair<Pair<i32, u8>, i64>);\n+    }\n+    size_and_align! {\n+        struct X<const N: usize> {\n+            field1: [i32; N],\n+            field2: [u8; N],\n+        }\n+        struct Goal(X<1000>);\n+    }\n+}\n+\n+#[test]\n+fn enums() {\n+    size_and_align! {\n+        enum Goal {\n+            Quit,\n+            Move { x: i32, y: i32 },\n+            ChangeColor(i32, i32, i32),\n+        }\n+    }\n+}\n+\n+#[test]\n+fn primitives() {\n+    size_and_align! {\n+        struct Goal(i32, i128, isize, usize, f32, f64, bool, char);\n+    }\n+}\n+\n+#[test]\n+fn tuple() {\n+    size_and_align! {\n+        struct Goal((), (i32, u64, bool));\n+    }\n+}\n+\n+#[test]\n+fn non_zero() {\n+    size_and_align! {\n+        minicore: non_zero, option;\n+        use core::num::NonZeroU8;\n+        struct Goal(Option<NonZeroU8>);\n+    }\n+}\n+\n+#[test]\n+fn niche_optimization() {\n+    size_and_align! {\n+        minicore: option;\n+        struct Goal(Option<&'static i32>);\n+    }\n+    size_and_align! {\n+        minicore: option;\n+        struct Goal(Option<Option<bool>>);\n+    }\n+}\n+\n+#[test]\n+fn enums_with_discriminants() {\n+    size_and_align! {\n+        enum Goal {\n+            A = 1000,\n+            B = 2000,\n+            C = 3000,\n+        }\n+    }\n+    size_and_align! {\n+        enum Goal {\n+            A = 254,\n+            B,\n+            C, // implicitly becomes 256, so we need two bytes\n+        }\n+    }\n+}"}, {"sha": "2a41cafba98a5471c7ee4cc6903f3b0a05864bab", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -27,6 +27,8 @@ pub mod display;\n pub mod method_resolution;\n pub mod primitive;\n pub mod traits;\n+pub mod layout;\n+pub mod lang_items;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "316f3938c6ccca3a6bebadc3468f696ac6d09ca4", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -39,12 +39,13 @@ use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId, ProcMacroKind};\n use either::Either;\n use hir_def::{\n-    adt::{ReprData, VariantData},\n+    adt::VariantData,\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n+    layout::{Layout, LayoutError, ReprOptions},\n     nameres::{self, diagnostics::DefDiagnostic},\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n@@ -59,6 +60,7 @@ use hir_ty::{\n     all_super_traits, autoderef,\n     consteval::{unknown_const_as_generic, ComputedExpr, ConstEvalError, ConstExt},\n     diagnostics::BodyValidationDiagnostic,\n+    layout::layout_of_ty,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n     traits::FnTrait,\n@@ -844,6 +846,10 @@ impl Field {\n         self.parent.variant_data(db).fields()[self.id].name.clone()\n     }\n \n+    pub fn index(&self) -> usize {\n+        u32::from(self.id.into_raw()) as usize\n+    }\n+\n     /// Returns the type as in the signature of the struct (i.e., with\n     /// placeholder types for type parameters). Only use this in the context of\n     /// the field definition.\n@@ -859,6 +865,10 @@ impl Field {\n         Type::new(db, var_id, ty)\n     }\n \n+    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n+        layout_of_ty(db, &self.ty(db).ty)\n+    }\n+\n     pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {\n         self.parent\n     }\n@@ -900,7 +910,7 @@ impl Struct {\n         Type::from_def(db, self.id)\n     }\n \n-    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprData> {\n+    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprOptions> {\n         db.struct_data(self.id).repr.clone()\n     }\n \n@@ -984,8 +994,30 @@ impl Enum {\n         Type::new_for_crate(\n             self.id.lookup(db.upcast()).container.krate(),\n             TyBuilder::builtin(match db.enum_data(self.id).variant_body_type() {\n-                Either::Left(builtin) => hir_def::builtin_type::BuiltinType::Int(builtin),\n-                Either::Right(builtin) => hir_def::builtin_type::BuiltinType::Uint(builtin),\n+                hir_def::layout::IntegerType::Pointer(sign) => match sign {\n+                    true => hir_def::builtin_type::BuiltinType::Int(\n+                        hir_def::builtin_type::BuiltinInt::Isize,\n+                    ),\n+                    false => hir_def::builtin_type::BuiltinType::Uint(\n+                        hir_def::builtin_type::BuiltinUint::Usize,\n+                    ),\n+                },\n+                hir_def::layout::IntegerType::Fixed(i, sign) => match sign {\n+                    true => hir_def::builtin_type::BuiltinType::Int(match i {\n+                        hir_def::layout::Integer::I8 => hir_def::builtin_type::BuiltinInt::I8,\n+                        hir_def::layout::Integer::I16 => hir_def::builtin_type::BuiltinInt::I16,\n+                        hir_def::layout::Integer::I32 => hir_def::builtin_type::BuiltinInt::I32,\n+                        hir_def::layout::Integer::I64 => hir_def::builtin_type::BuiltinInt::I64,\n+                        hir_def::layout::Integer::I128 => hir_def::builtin_type::BuiltinInt::I128,\n+                    }),\n+                    false => hir_def::builtin_type::BuiltinType::Uint(match i {\n+                        hir_def::layout::Integer::I8 => hir_def::builtin_type::BuiltinUint::U8,\n+                        hir_def::layout::Integer::I16 => hir_def::builtin_type::BuiltinUint::U16,\n+                        hir_def::layout::Integer::I32 => hir_def::builtin_type::BuiltinUint::U32,\n+                        hir_def::layout::Integer::I64 => hir_def::builtin_type::BuiltinUint::U64,\n+                        hir_def::layout::Integer::I128 => hir_def::builtin_type::BuiltinUint::U128,\n+                    }),\n+                },\n             }),\n         )\n     }\n@@ -1076,6 +1108,13 @@ impl Adt {\n         })\n     }\n \n+    pub fn layout(self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n+        if db.generic_params(self.into()).iter().count() != 0 {\n+            return Err(LayoutError::HasPlaceholder);\n+        }\n+        db.layout_of_adt(self.into(), Substitution::empty(Interner))\n+    }\n+\n     /// Turns this ADT into a type. Any type parameters of the ADT will be\n     /// turned into unknown types, which is good for e.g. finding the most\n     /// general set of completions, but will not look very nice when printed.\n@@ -3033,7 +3072,7 @@ impl Type {\n \n         let adt = adt_id.into();\n         match adt {\n-            Adt::Struct(s) => matches!(s.repr(db), Some(ReprData { packed: true, .. })),\n+            Adt::Struct(s) => s.repr(db).unwrap_or_default().pack.is_some(),\n             _ => false,\n         }\n     }"}, {"sha": "f37c9f4a6d527cfd4a7ae58f84855eb3000d3e10", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -2,7 +2,9 @@\n use std::fmt::Display;\n \n use either::Either;\n-use hir::{AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n+use hir::{\n+    Adt, AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo,\n+};\n use ide_db::{\n     base_db::SourceDatabase,\n     defs::Definition,\n@@ -388,10 +390,30 @@ pub(super) fn definition(\n     let mod_path = definition_mod_path(db, &def);\n     let (label, docs) = match def {\n         Definition::Macro(it) => label_and_docs(db, it),\n-        Definition::Field(it) => label_and_docs(db, it),\n+        Definition::Field(it) => label_and_layout_info_and_docs(db, it, |&it| {\n+            let var_def = it.parent_def(db);\n+            let id = it.index();\n+            let layout = it.layout(db).ok()?;\n+            let offset = match var_def {\n+                hir::VariantDef::Struct(s) => {\n+                    let layout = Adt::from(s).layout(db).ok()?;\n+                    layout.fields.offset(id)\n+                }\n+                _ => return None,\n+            };\n+            Some(format!(\n+                \"size = {}, align = {}, offset = {}\",\n+                layout.size.bytes(),\n+                layout.align.abi.bytes(),\n+                offset.bytes()\n+            ))\n+        }),\n         Definition::Module(it) => label_and_docs(db, it),\n         Definition::Function(it) => label_and_docs(db, it),\n-        Definition::Adt(it) => label_and_docs(db, it),\n+        Definition::Adt(it) => label_and_layout_info_and_docs(db, it, |&it| {\n+            let layout = it.layout(db).ok()?;\n+            Some(format!(\"size = {}, align = {}\", layout.size.bytes(), layout.align.abi.bytes()))\n+        }),\n         Definition::Variant(it) => label_value_and_docs(db, it, |&it| {\n             if !it.parent_enum(db).is_data_carrying(db) {\n                 match it.eval(db) {\n@@ -489,6 +511,25 @@ where\n     (label, docs)\n }\n \n+fn label_and_layout_info_and_docs<D, E, V>(\n+    db: &RootDatabase,\n+    def: D,\n+    value_extractor: E,\n+) -> (String, Option<hir::Documentation>)\n+where\n+    D: HasAttrs + HirDisplay,\n+    E: Fn(&D) -> Option<V>,\n+    V: Display,\n+{\n+    let label = if let Some(value) = value_extractor(&def) {\n+        format!(\"{} // {}\", def.display(db), value)\n+    } else {\n+        def.display(db).to_string()\n+    };\n+    let docs = def.attrs(db).docs();\n+    (label, docs)\n+}\n+\n fn label_value_and_docs<D, E, V>(\n     db: &RootDatabase,\n     def: D,"}, {"sha": "f82fd6d0289c6816f3302f2ccdbeac86206354f0", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 120, "deletions": 99, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -522,6 +522,27 @@ fn main() { }\n     );\n }\n \n+#[test]\n+fn hover_field_offset() {\n+    // Hovering over the field when instantiating\n+    check(\n+        r#\"\n+struct Foo { fiel$0d_a: u8, field_b: i32, field_c: i16 }\n+\"#,\n+        expect![[r#\"\n+            *field_a*\n+\n+            ```rust\n+            test::Foo\n+            ```\n+\n+            ```rust\n+            field_a: u8 // size = 1, align = 1, offset = 4\n+            ```\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_shows_struct_field_info() {\n     // Hovering over the field when instantiating\n@@ -534,16 +555,16 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-                *field_a*\n+            *field_a*\n \n-                ```rust\n-                test::Foo\n-                ```\n+            ```rust\n+            test::Foo\n+            ```\n \n-                ```rust\n-                field_a: u32\n-                ```\n-            \"#]],\n+            ```rust\n+            field_a: u32 // size = 4, align = 4, offset = 0\n+            ```\n+        \"#]],\n     );\n \n     // Hovering over the field in the definition\n@@ -556,16 +577,16 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-                *field_a*\n+            *field_a*\n \n-                ```rust\n-                test::Foo\n-                ```\n+            ```rust\n+            test::Foo\n+            ```\n \n-                ```rust\n-                field_a: u32\n-                ```\n-            \"#]],\n+            ```rust\n+            field_a: u32 // size = 4, align = 4, offset = 0\n+            ```\n+        \"#]],\n     );\n }\n \n@@ -1508,30 +1529,30 @@ struct Bar;\n \n fn foo() { let bar = Ba$0r; }\n \"#,\n-        expect![[r##\"\n-                *Bar*\n+        expect![[r#\"\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                struct Bar\n-                ```\n+            ```rust\n+            struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                This is an example\n-                multiline doc\n+            This is an example\n+            multiline doc\n \n-                # Example\n+            # Example\n \n-                ```\n-                let five = 5;\n+            ```\n+            let five = 5;\n \n-                assert_eq!(6, my_crate::add_one(5));\n-                ```\n-            \"##]],\n+            assert_eq!(6, my_crate::add_one(5));\n+            ```\n+        \"#]],\n     );\n }\n \n@@ -1545,20 +1566,20 @@ struct Bar;\n fn foo() { let bar = Ba$0r; }\n \"#,\n         expect![[r#\"\n-                *Bar*\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                struct Bar\n-                ```\n+            ```rust\n+            struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                bar docs\n-            \"#]],\n+            bar docs\n+        \"#]],\n     );\n }\n \n@@ -1574,22 +1595,22 @@ struct Bar;\n fn foo() { let bar = Ba$0r; }\n \"#,\n         expect![[r#\"\n-                *Bar*\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                struct Bar\n-                ```\n+            ```rust\n+            struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                bar docs 0\n-                bar docs 1\n-                bar docs 2\n-            \"#]],\n+            bar docs 0\n+            bar docs 1\n+            bar docs 2\n+        \"#]],\n     );\n }\n \n@@ -1602,20 +1623,20 @@ pub struct Foo;\n pub struct B$0ar\n \"#,\n         expect![[r#\"\n-                *Bar*\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                pub struct Bar\n-                ```\n+            ```rust\n+            pub struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                [external](https://www.google.com)\n-            \"#]],\n+            [external](https://www.google.com)\n+        \"#]],\n     );\n }\n \n@@ -1629,20 +1650,20 @@ pub struct Foo;\n pub struct B$0ar\n \"#,\n         expect![[r#\"\n-                *Bar*\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                pub struct Bar\n-                ```\n+            ```rust\n+            pub struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                [baz](Baz)\n-            \"#]],\n+            [baz](Baz)\n+        \"#]],\n     );\n }\n \n@@ -2960,7 +2981,7 @@ fn main() {\n             ```\n \n             ```rust\n-            f: i32\n+            f: i32 // size = 4, align = 4, offset = 0\n             ```\n         \"#]],\n     );\n@@ -4203,20 +4224,20 @@ pub fn gimme() -> theitem::TheItem {\n }\n \"#,\n         expect![[r#\"\n-                *[`TheItem`]*\n+            *[`TheItem`]*\n \n-                ```rust\n-                test::theitem\n-                ```\n+            ```rust\n+            test::theitem\n+            ```\n \n-                ```rust\n-                pub struct TheItem\n-                ```\n+            ```rust\n+            pub struct TheItem // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                This is the item. Cool!\n-            \"#]],\n+            This is the item. Cool!\n+        \"#]],\n     );\n }\n \n@@ -4351,20 +4372,20 @@ mod string {\n }\n \"#,\n         expect![[r#\"\n-                *String*\n+            *String*\n \n-                ```rust\n-                main\n-                ```\n+            ```rust\n+            main\n+            ```\n \n-                ```rust\n-                struct String\n-                ```\n+            ```rust\n+            struct String // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                Custom `String` type.\n-            \"#]],\n+            Custom `String` type.\n+        \"#]],\n     )\n }\n \n@@ -5025,7 +5046,7 @@ foo_macro!(\n             ```\n \n             ```rust\n-            pub struct Foo\n+            pub struct Foo // size = 0, align = 1\n             ```\n \n             ---\n@@ -5040,7 +5061,7 @@ fn hover_intra_in_attr() {\n     check(\n         r#\"\n #[doc = \"Doc comment for [`Foo$0`]\"]\n-pub struct Foo;\n+pub struct Foo(i32);\n \"#,\n         expect![[r#\"\n             *[`Foo`]*\n@@ -5050,7 +5071,7 @@ pub struct Foo;\n             ```\n \n             ```rust\n-            pub struct Foo\n+            pub struct Foo // size = 4, align = 4\n             ```\n \n             ---"}, {"sha": "750b64fea6fb9c71b4b62d71f72c26a7b4e81377", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -30,6 +30,7 @@\n //!     index: sized\n //!     iterator: option\n //!     iterators: iterator, fn\n+//!     non_zero:\n //!     option:\n //!     ord: eq, option\n //!     pin:\n@@ -704,6 +705,15 @@ mod macros {\n }\n // endregion:derive\n \n+// region:non_zero\n+pub mod num {\n+    #[repr(transparent)]\n+    #[rustc_layout_scalar_valid_range_start(1)]\n+    #[rustc_nonnull_optimization_guaranteed]\n+    pub struct NonZeroU8(u8);\n+}\n+// endregion:non_zero\n+\n // region:bool_impl\n #[lang = \"bool\"]\n impl bool {"}, {"sha": "b9d491da3c0cffe317eb5de2c598fac1692e0aca", "filename": "lib/la-arena/src/map.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/lib%2Fla-arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8a54d0f68702cf7981c8299357838eb0f4d5b2/lib%2Fla-arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Fmap.rs?ref=6e8a54d0f68702cf7981c8299357838eb0f4d5b2", "patch": "@@ -86,6 +86,14 @@ impl<T, V> ArenaMap<Idx<T>, V> {\n         self.v.iter().enumerate().filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_ref()?)))\n     }\n \n+    /// Returns an iterator over the arena indexes and values in the map.\n+    pub fn iter_mut(&mut self) -> impl Iterator<Item = (Idx<T>, &mut V)> {\n+        self.v\n+            .iter_mut()\n+            .enumerate()\n+            .filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_mut()?)))\n+    }\n+\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     pub fn entry(&mut self, idx: Idx<T>) -> Entry<'_, Idx<T>, V> {\n         let idx = Self::to_idx(idx);"}]}