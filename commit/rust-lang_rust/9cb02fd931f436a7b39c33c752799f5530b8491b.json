{"sha": "9cb02fd931f436a7b39c33c752799f5530b8491b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYjAyZmQ5MzFmNDM2YTdiMzljMzNjNzUyNzk5ZjU1MzBiODQ5MWI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-06T12:16:21Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-06T14:35:57Z"}, "message": "kill old module", "tree": {"sha": "ddd8d882d7aa445457ae75e7c830280eefbc0250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddd8d882d7aa445457ae75e7c830280eefbc0250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cb02fd931f436a7b39c33c752799f5530b8491b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb02fd931f436a7b39c33c752799f5530b8491b", "html_url": "https://github.com/rust-lang/rust/commit/9cb02fd931f436a7b39c33c752799f5530b8491b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cb02fd931f436a7b39c33c752799f5530b8491b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c2cb89087c87f29ad3bc3856625b83017b7a294", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c2cb89087c87f29ad3bc3856625b83017b7a294", "html_url": "https://github.com/rust-lang/rust/commit/3c2cb89087c87f29ad3bc3856625b83017b7a294"}], "stats": {"total": 299, "additions": 66, "deletions": 233}, "files": [{"sha": "eca7d0225627b109d019c2b7750c249489130aca", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=9cb02fd931f436a7b39c33c752799f5530b8491b", "patch": "@@ -1,7 +1,6 @@\n-use ra_db::{CrateId, Cancelable, FileId};\n-use ra_syntax::ast;\n+use ra_db::{CrateId, Cancelable};\n \n-use crate::{Name, db::HirDatabase, DefId, Path, PerNs};\n+use crate::{Name, db::HirDatabase, DefId, Path, PerNs, module::{ModuleSource, ModuleScope}};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -35,7 +34,8 @@ pub struct Module {\n }\n \n impl Module {\n-    pub fn source(&self, db: &impl HirDatabase) -> Cancelable<(FileId, Option<ast::ModuleNode>)> {\n+    // FIXME: what is a module source exactly? It should contain two nodes\n+    pub fn source(&self, db: &impl HirDatabase) -> Cancelable<ModuleSource> {\n         Ok(self.source_impl(db))\n     }\n \n@@ -56,7 +56,10 @@ impl Module {\n     pub fn parent(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         self.parent_impl(db)\n     }\n-\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+        self.scope_impl(db)\n+    }\n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n         self.resolve_path_impl(db, path)\n     }"}, {"sha": "7f5669c8f1a2e83b05e6a73ba17fa6708a804ce2", "filename": "crates/ra_hir/src/code_model_impl.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs?ref=9cb02fd931f436a7b39c33c752799f5530b8491b", "patch": "@@ -1,7 +1,10 @@\n-use ra_db::{CrateId, Cancelable, FileId};\n-use ra_syntax::{AstNode, ast};\n+use ra_db::{CrateId, Cancelable, SourceRootId};\n \n-use crate::{HirFileId, db::HirDatabase, Crate, CrateDependency, AsName, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def};\n+use crate::{\n+    HirFileId, Crate, CrateDependency, AsName, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def, ModuleId,\n+    module::{ModuleSource, ModuleScope},\n+    db::HirDatabase,\n+};\n \n use crate::code_model_api::Module;\n \n@@ -48,21 +51,26 @@ impl Module {\n     pub(crate) fn new(def_id: DefId) -> Self {\n         crate::code_model_api::Module { def_id }\n     }\n+    pub(crate) fn from_module_id(\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Cancelable<Self> {\n+        let module_tree = db.module_tree(source_root_id)?;\n+        let def_loc = DefLoc {\n+            kind: DefKind::Module,\n+            source_root_id,\n+            module_id,\n+            source_item_id: module_id.source(&module_tree).0,\n+        };\n+        let def_id = def_loc.id(db);\n+        let module = Module::new(def_id);\n+        Ok(module)\n+    }\n \n-    pub(crate) fn source_impl(&self, db: &impl HirDatabase) -> (FileId, Option<ast::ModuleNode>) {\n+    pub(crate) fn source_impl(&self, db: &impl HirDatabase) -> ModuleSource {\n         let loc = self.def_id.loc(db);\n-        let source_item_id = loc.source_item_id;\n-        let module = match source_item_id.item_id {\n-            None => None,\n-            Some(_) => {\n-                let syntax_node = db.file_item(source_item_id);\n-                let module = ast::Module::cast(syntax_node.borrowed()).unwrap().owned();\n-                Some(module)\n-            }\n-        };\n-        // FIXME: remove `as_original_file` here\n-        let file_id = source_item_id.file_id.as_original_file();\n-        (file_id, module)\n+        ModuleSource(loc.source_item_id)\n     }\n \n     pub(crate) fn krate_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n@@ -79,41 +87,27 @@ impl Module {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;\n         let module_id = loc.module_id.crate_root(&module_tree);\n-        let def_loc = DefLoc {\n-            module_id,\n-            source_item_id: module_id.source(&module_tree).0,\n-            ..loc\n-        };\n-        let def_id = def_loc.id(db);\n-        let module = Module::new(def_id);\n-        Ok(module)\n+        Module::from_module_id(db, loc.source_root_id, module_id)\n     }\n     /// Finds a child module with the specified name.\n     pub fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;\n         let child_id = ctry!(loc.module_id.child(&module_tree, name));\n-        let def_loc = DefLoc {\n-            module_id: child_id,\n-            source_item_id: child_id.source(&module_tree).0,\n-            ..loc\n-        };\n-        let def_id = def_loc.id(db);\n-        let module = Module::new(def_id);\n-        Ok(Some(module))\n+        Module::from_module_id(db, loc.source_root_id, child_id).map(Some)\n     }\n     pub fn parent_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id)?;\n         let parent_id = ctry!(loc.module_id.parent(&module_tree));\n-        let def_loc = DefLoc {\n-            module_id: parent_id,\n-            source_item_id: parent_id.source(&module_tree).0,\n-            ..loc\n-        };\n-        let def_id = def_loc.id(db);\n-        let module = Module::new(def_id);\n-        Ok(Some(module))\n+        Module::from_module_id(db, loc.source_root_id, parent_id).map(Some)\n+    }\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub fn scope_impl(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+        let loc = self.def_id.loc(db);\n+        let item_map = db.item_map(loc.source_root_id)?;\n+        let res = item_map.per_module[&loc.module_id].clone();\n+        Ok(res)\n     }\n     pub fn resolve_path_impl(\n         &self,"}, {"sha": "c7391ee05606df525b28cfabb55865acf5993187", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=9cb02fd931f436a7b39c33c752799f5530b8491b", "patch": "@@ -2,7 +2,9 @@ use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n-use crate::{HirDatabase, PerNs, ModuleId, Module, Def, Function, Struct, Enum, ImplBlock, Crate};\n+use crate::{HirDatabase, PerNs, ModuleId, Def, Function, Struct, Enum, ImplBlock, Crate};\n+\n+use crate::code_model_api::Module;\n \n /// hir makes a heavy use of ids: integer (u32) handlers to various things. You\n /// can think of id as a pointer (but without a lifetime) or a file descriptor\n@@ -151,7 +153,7 @@ impl DefId {\n         let loc = self.loc(db);\n         let res = match loc.kind {\n             DefKind::Module => {\n-                let module = Module::new(db, loc.source_root_id, loc.module_id)?;\n+                let module = Module::from_module_id(db, loc.source_root_id, loc.module_id)?;\n                 Def::Module(module)\n             }\n             DefKind::Function => {\n@@ -175,12 +177,12 @@ impl DefId {\n     /// For a module, returns that module; for any other def, returns the containing module.\n     pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n         let loc = self.loc(db);\n-        Module::new(db, loc.source_root_id, loc.module_id)\n+        Module::from_module_id(db, loc.source_root_id, loc.module_id)\n     }\n \n     /// Returns the containing crate.\n     pub fn krate(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n-        Ok(self.module(db)?.krate(db))\n+        Ok(self.module(db)?.krate(db)?)\n     }\n \n     /// Returns the containing impl block, if this is an impl item."}, {"sha": "891c93434ea7f271de4e2f3da55a1f943225c0fe", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=9cb02fd931f436a7b39c33c752799f5530b8491b", "patch": "@@ -7,12 +7,14 @@ use ra_db::{LocationIntener, Cancelable, SourceRootId};\n \n use crate::{\n     DefId, DefLoc, DefKind, SourceItemId, SourceFileItems,\n-    Module, Function,\n+    Function,\n     db::HirDatabase,\n     type_ref::TypeRef,\n     module::{ModuleSourceNode, ModuleId},\n };\n \n+use crate::code_model_api::Module;\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImplBlock {\n     module_impl_blocks: Arc<ModuleImplBlocks>,\n@@ -64,7 +66,7 @@ impl ImplData {\n     ) -> Self {\n         let target_trait = node.target_type().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n-        let file_id = module.source().file_id();\n+        let module_loc = module.def_id.loc(db);\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n                 .impl_items()\n@@ -75,14 +77,14 @@ impl ImplData {\n                         ast::ImplItem::TypeDef(..) => DefKind::Item,\n                     };\n                     let item_id = file_items.id_of_unchecked(item_node.syntax());\n+                    let source_item_id = SourceItemId {\n+                        file_id: module_loc.source_item_id.file_id,\n+                        item_id: Some(item_id),\n+                    };\n                     let def_loc = DefLoc {\n                         kind,\n-                        source_root_id: module.source_root_id,\n-                        module_id: module.module_id,\n-                        source_item_id: SourceItemId {\n-                            file_id,\n-                            item_id: Some(item_id),\n-                        },\n+                        source_item_id,\n+                        ..module_loc\n                     };\n                     let def_id = def_loc.id(db);\n                     match item_node {\n@@ -148,13 +150,13 @@ impl ModuleImplBlocks {\n     }\n \n     fn collect(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n-        let module_source_node = module.source().resolve(db);\n+        let module_source_node = module.source(db)?.resolve(db);\n         let node = match &module_source_node {\n             ModuleSourceNode::SourceFile(node) => node.borrowed().syntax(),\n             ModuleSourceNode::Module(node) => node.borrowed().syntax(),\n         };\n \n-        let source_file_items = db.file_items(module.source().file_id());\n+        let source_file_items = db.file_items(module.source(db)?.file_id());\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n             let impl_block = ImplData::from_ast(db, &source_file_items, &module, impl_block_ast);\n@@ -174,7 +176,7 @@ pub(crate) fn impls_in_module(\n     module_id: ModuleId,\n ) -> Cancelable<Arc<ModuleImplBlocks>> {\n     let mut result = ModuleImplBlocks::new();\n-    let module = Module::new(db, source_root_id, module_id)?;\n+    let module = Module::from_module_id(db, source_root_id, module_id)?;\n     result.collect(db, module)?;\n     Ok(Arc::new(result))\n }"}, {"sha": "2fa357fecff6452d60044d66161713e50785790a", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=9cb02fd931f436a7b39c33c752799f5530b8491b", "patch": "@@ -56,6 +56,8 @@ pub use self::{\n \n pub use self::function::FnSignatureInfo;\n \n+pub use self::code_model_api::Module;\n+\n pub enum Def {\n     Module(Module),\n     Function(Function),"}, {"sha": "d1005eab6e31720d9ce3fa6d900002c72b07e617", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 1, "deletions": 171, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=9cb02fd931f436a7b39c33c752799f5530b8491b", "patch": "@@ -1,7 +1,6 @@\n pub(super) mod imp;\n pub(super) mod nameres;\n \n-use std::sync::Arc;\n use log;\n \n use ra_syntax::{\n@@ -10,184 +9,15 @@ use ra_syntax::{\n     SyntaxNode,\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n-use ra_db::{SourceRootId, FileId, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n-    Def, DefKind, DefLoc, DefId,\n-    Name, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n+    Name,  HirDatabase, SourceItemId, SourceFileItemId,\n     HirFileId,\n };\n \n pub use self::nameres::{ModuleScope, Resolution, Namespace, PerNs};\n \n-/// `Module` is API entry point to get all the information\n-/// about a particular module.\n-#[derive(Debug, Clone)]\n-pub struct Module {\n-    tree: Arc<ModuleTree>,\n-    pub(crate) source_root_id: SourceRootId,\n-    pub(crate) module_id: ModuleId,\n-}\n-\n-impl Module {\n-    pub(super) fn new(\n-        db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Cancelable<Module> {\n-        let module_tree = db.module_tree(source_root_id)?;\n-        let res = Module {\n-            tree: module_tree,\n-            source_root_id,\n-            module_id,\n-        };\n-        Ok(res)\n-    }\n-\n-    /// Returns `mod foo;` or `mod foo {}` node whihc declared this module.\n-    /// Returns `None` for the root module\n-    pub fn parent_link_source(&self, db: &impl HirDatabase) -> Option<(FileId, ast::ModuleNode)> {\n-        let link = self.module_id.parent_link(&self.tree)?;\n-        let file_id = link\n-            .owner(&self.tree)\n-            .source(&self.tree)\n-            .file_id()\n-            .as_original_file();\n-        let src = link.bind_source(&self.tree, db);\n-        Some((file_id, src))\n-    }\n-\n-    pub fn file_id(&self) -> FileId {\n-        self.source().file_id().as_original_file()\n-    }\n-\n-    /// Parent module. Returns `None` if this is a root module.\n-    pub fn parent(&self) -> Option<Module> {\n-        let parent_id = self.module_id.parent(&self.tree)?;\n-        Some(Module {\n-            module_id: parent_id,\n-            ..self.clone()\n-        })\n-    }\n-\n-    /// Returns an iterator of all children of this module.\n-    pub fn children<'a>(&'a self) -> impl Iterator<Item = (Name, Module)> + 'a {\n-        self.module_id\n-            .children(&self.tree)\n-            .map(move |(name, module_id)| {\n-                (\n-                    name,\n-                    Module {\n-                        module_id,\n-                        ..self.clone()\n-                    },\n-                )\n-            })\n-    }\n-\n-    /// Returns the crate this module is part of.\n-    pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        let root_id = self.module_id.crate_root(&self.tree);\n-        let file_id = root_id.source(&self.tree).file_id().as_original_file();\n-        let crate_graph = db.crate_graph();\n-        let crate_id = crate_graph.crate_id_for_crate_root(file_id)?;\n-        Some(Crate::new(crate_id))\n-    }\n-\n-    /// Returns the all modules on the way to the root.\n-    pub fn path_to_root(&self) -> Vec<Module> {\n-        generate(Some(self.clone()), move |it| it.parent()).collect::<Vec<Module>>()\n-    }\n-\n-    /// The root of the tree this module is part of\n-    pub fn crate_root(&self) -> Module {\n-        let root_id = self.module_id.crate_root(&self.tree);\n-        Module {\n-            module_id: root_id,\n-            ..self.clone()\n-        }\n-    }\n-\n-    /// `name` is `None` for the crate's root module\n-    pub fn name(&self) -> Option<&Name> {\n-        let link = self.module_id.parent_link(&self.tree)?;\n-        Some(link.name(&self.tree))\n-    }\n-\n-    pub fn def_id(&self, db: &impl HirDatabase) -> DefId {\n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id: self.source_root_id,\n-            module_id: self.module_id,\n-            source_item_id: self.module_id.source(&self.tree).0,\n-        };\n-        def_loc.id(db)\n-    }\n-\n-    /// Finds a child module with the specified name.\n-    pub fn child(&self, name: &Name) -> Option<Module> {\n-        let child_id = self.module_id.child(&self.tree, name)?;\n-        Some(Module {\n-            module_id: child_id,\n-            ..self.clone()\n-        })\n-    }\n-\n-    /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n-        let item_map = db.item_map(self.source_root_id)?;\n-        let res = item_map.per_module[&self.module_id].clone();\n-        Ok(res)\n-    }\n-\n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n-        let mut curr_per_ns = PerNs::types(\n-            match path.kind {\n-                PathKind::Crate => self.crate_root(),\n-                PathKind::Self_ | PathKind::Plain => self.clone(),\n-                PathKind::Super => {\n-                    if let Some(p) = self.parent() {\n-                        p\n-                    } else {\n-                        return Ok(PerNs::none());\n-                    }\n-                }\n-            }\n-            .def_id(db),\n-        );\n-\n-        let segments = &path.segments;\n-        for name in segments.iter() {\n-            let curr = if let Some(r) = curr_per_ns.as_ref().take(Namespace::Types) {\n-                r\n-            } else {\n-                return Ok(PerNs::none());\n-            };\n-            let module = match curr.resolve(db)? {\n-                Def::Module(it) => it,\n-                // TODO here would be the place to handle enum variants...\n-                _ => return Ok(PerNs::none()),\n-            };\n-            let scope = module.scope(db)?;\n-            curr_per_ns = if let Some(r) = scope.get(&name) {\n-                r.def_id\n-            } else {\n-                return Ok(PerNs::none());\n-            };\n-        }\n-        Ok(curr_per_ns)\n-    }\n-\n-    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n-        self.module_id.problems(&self.tree, db)\n-    }\n-\n-    pub(crate) fn source(&self) -> ModuleSource {\n-        self.module_id.source(&self.tree)\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ModuleId(RawId);\n impl_arena_id!(ModuleId);"}, {"sha": "7d5e86c89b99717cd94d1bed8713fe71177ea8b9", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb02fd931f436a7b39c33c752799f5530b8491b/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=9cb02fd931f436a7b39c33c752799f5530b8491b", "patch": "@@ -31,7 +31,7 @@ use crate::{\n     Path, PathKind,\n     HirDatabase, Crate,\n     Name, AsName,\n-    module::{Module, ModuleId, ModuleTree},\n+    module::{ModuleId, ModuleTree},\n };\n \n /// Item map is the result of the name resolution. Item map contains, for each\n@@ -466,7 +466,7 @@ where\n                         if source_root_id == self.source_root {\n                             target_module_id\n                         } else {\n-                            let module = Module::new(self.db, source_root_id, target_module_id)?;\n+                            let module = crate::code_model_api::Module::new(type_def_id);\n                             let path = Path {\n                                 segments: import.path.segments[i + 1..].iter().cloned().collect(),\n                                 kind: PathKind::Crate,"}]}