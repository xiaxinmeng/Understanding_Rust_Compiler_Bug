{"sha": "774d5eb0b07bdb4d3c853159fbcd265de60e7755", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NGQ1ZWIwYjA3YmRiNGQzYzg1MzE1OWZiY2QyNjVkZTYwZTc3NTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-30T07:41:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-30T07:41:11Z"}, "message": "auto merge of #15670 : epdtry/rust/fast-archive-builder, r=alexcrichton\n\nWhen rustc produces an rlib, it includes the contents of each static library required by the crate.  Currently each static library is added individually, by extracting the library with `ar x` and adding the objects to the rlib using `ar r`.  Each `ar r` has significant overhead - it appears to scan through the full contents of the rlib before adding the new files.  This patch avoids most of the overhead by adding all library objects (and other rlib components) at once using a single `ar r`.\r\n\r\nWhen building `librustc` (on Linux, using GNU ar), this patch gives a 60-80% reduction in linking time, from 90s to 10s one machine I tried and 25s to 8s on another.  (Though `librustc` is a bit of a special case - it's a very large crate, so the rlib is large to begin with, and it also relies on a total of 45 static libraries due to the way LLVM is organized.)  More reasonable crates such as `libstd` and `libcore` also get a small reduction in linking time (just from adding metadata, bitcode, and object code in one `ar` invocation instead of three), but this is not very noticeable since the time there is small to begin with (around 1s).", "tree": {"sha": "39c10ef88e6271df5a230b5d738046e4586950c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39c10ef88e6271df5a230b5d738046e4586950c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/774d5eb0b07bdb4d3c853159fbcd265de60e7755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/774d5eb0b07bdb4d3c853159fbcd265de60e7755", "html_url": "https://github.com/rust-lang/rust/commit/774d5eb0b07bdb4d3c853159fbcd265de60e7755", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/774d5eb0b07bdb4d3c853159fbcd265de60e7755/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b0dc6a3fc22b299152e7a29d98896cca7fd6fa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b0dc6a3fc22b299152e7a29d98896cca7fd6fa2", "html_url": "https://github.com/rust-lang/rust/commit/1b0dc6a3fc22b299152e7a29d98896cca7fd6fa2"}, {"sha": "4d8de63fb3159dc31fc3c3f54c4a39794e694edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d8de63fb3159dc31fc3c3f54c4a39794e694edf", "html_url": "https://github.com/rust-lang/rust/commit/4d8de63fb3159dc31fc3c3f54c4a39794e694edf"}], "stats": {"total": 228, "additions": 161, "deletions": 67}, "files": [{"sha": "0a37b960b08ba00d75452d34dfa73dc282de1f50", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/774d5eb0b07bdb4d3c853159fbcd265de60e7755/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/774d5eb0b07bdb4d3c853159fbcd265de60e7755/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=774d5eb0b07bdb4d3c853159fbcd265de60e7755", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::archive::{Archive, ArchiveConfig, METADATA_FILENAME};\n+use super::archive::{Archive, ArchiveBuilder, ArchiveConfig, METADATA_FILENAME};\n use super::rpath;\n use super::rpath::RPathConfig;\n use super::svh::Svh;\n@@ -983,7 +983,7 @@ fn link_binary_output(sess: &Session,\n \n     match crate_type {\n         config::CrateTypeRlib => {\n-            link_rlib(sess, Some(trans), &obj_filename, &out_filename);\n+            link_rlib(sess, Some(trans), &obj_filename, &out_filename).build();\n         }\n         config::CrateTypeStaticlib => {\n             link_staticlib(sess, &obj_filename, &out_filename);\n@@ -1019,7 +1019,7 @@ fn archive_search_paths(sess: &Session) -> Vec<Path> {\n fn link_rlib<'a>(sess: &'a Session,\n                  trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n                  obj_filename: &Path,\n-                 out_filename: &Path) -> Archive<'a> {\n+                 out_filename: &Path) -> ArchiveBuilder<'a> {\n     let handler = &sess.diagnostic().handler;\n     let config = ArchiveConfig {\n         handler: handler,\n@@ -1028,17 +1028,30 @@ fn link_rlib<'a>(sess: &'a Session,\n         os: sess.targ_cfg.os,\n         maybe_ar_prog: sess.opts.cg.ar.clone()\n     };\n-    let mut a = Archive::create(config, obj_filename);\n+    let mut ab = ArchiveBuilder::create(config);\n+    ab.add_file(obj_filename).unwrap();\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                a.add_native_library(l.as_slice()).unwrap();\n+                ab.add_native_library(l.as_slice()).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n     }\n \n+    // After adding all files to the archive, we need to update the\n+    // symbol table of the archive.\n+    ab.update_symbols();\n+\n+    let mut ab = match sess.targ_cfg.os {\n+        // For OSX/iOS, we must be careful to update symbols only when adding\n+        // object files.  We're about to start adding non-object files, so run\n+        // `ar` now to process the object files.\n+        abi::OsMacos | abi::OsiOS => ab.build().extend(),\n+        _ => ab,\n+    };\n+\n     // Note that it is important that we add all of our non-object \"magical\n     // files\" *after* all of the object files in the archive. The reason for\n     // this is as follows:\n@@ -1078,7 +1091,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     sess.abort_if_errors();\n                 }\n             }\n-            a.add_file(&metadata, false);\n+            ab.add_file(&metadata).unwrap();\n             remove(sess, &metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted\n@@ -1105,25 +1118,18 @@ fn link_rlib<'a>(sess: &'a Session,\n                     sess.abort_if_errors()\n                 }\n             }\n-            a.add_file(&bc_deflated, false);\n+            ab.add_file(&bc_deflated).unwrap();\n             remove(sess, &bc_deflated);\n             if !sess.opts.cg.save_temps &&\n                !sess.opts.output_types.contains(&OutputTypeBitcode) {\n                 remove(sess, &bc);\n             }\n-\n-            // After adding all files to the archive, we need to update the\n-            // symbol table of the archive. This currently dies on OSX (see\n-            // #11162), and isn't necessary there anyway\n-            match sess.targ_cfg.os {\n-                abi::OsMacos | abi::OsiOS => {}\n-                _ => { a.update_symbols(); }\n-            }\n         }\n \n         None => {}\n     }\n-    return a;\n+\n+    ab\n }\n \n // Create a static archive\n@@ -1139,9 +1145,13 @@ fn link_rlib<'a>(sess: &'a Session,\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n-    let mut a = link_rlib(sess, None, obj_filename, out_filename);\n-    a.add_native_library(\"morestack\").unwrap();\n-    a.add_native_library(\"compiler-rt\").unwrap();\n+    let ab = link_rlib(sess, None, obj_filename, out_filename);\n+    let mut ab = match sess.targ_cfg.os {\n+        abi::OsMacos | abi::OsiOS => ab.build().extend(),\n+        _ => ab,\n+    };\n+    ab.add_native_library(\"morestack\").unwrap();\n+    ab.add_native_library(\"compiler-rt\").unwrap();\n \n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     let mut all_native_libs = vec![];\n@@ -1155,12 +1165,15 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n                 continue\n             }\n         };\n-        a.add_rlib(&p, name.as_slice(), sess.lto()).unwrap();\n+        ab.add_rlib(&p, name.as_slice(), sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.move_iter());\n     }\n \n+    ab.update_symbols();\n+    let _ = ab.build();\n+\n     if !all_native_libs.is_empty() {\n         sess.warn(\"link against the following native artifacts when linking against \\\n                   this static library\");"}, {"sha": "e2cadf817d5ea1e220f73006b6f070e0b37e5624", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 128, "deletions": 47, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/774d5eb0b07bdb4d3c853159fbcd265de60e7755/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/774d5eb0b07bdb4d3c853159fbcd265de60e7755/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=774d5eb0b07bdb4d3c853159fbcd265de60e7755", "patch": "@@ -36,6 +36,17 @@ pub struct Archive<'a> {\n     maybe_ar_prog: Option<String>\n }\n \n+/// Helper for adding many files to an archive with a single invocation of\n+/// `ar`.\n+#[must_use = \"must call build() to finish building the archive\"]\n+pub struct ArchiveBuilder<'a> {\n+    archive: Archive<'a>,\n+    work_dir: TempDir,\n+    /// Filename of each member that should be added to the archive.\n+    members: Vec<Path>,\n+    should_update_symbols: bool,\n+}\n+\n fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n@@ -85,10 +96,8 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n }\n \n impl<'a> Archive<'a> {\n-    /// Initializes a new static archive with the given object file\n-    pub fn create<'b>(config: ArchiveConfig<'a>, initial_object: &'b Path) -> Archive<'a> {\n+    fn new(config: ArchiveConfig<'a>) -> Archive<'a> {\n         let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n-        run_ar(handler, &maybe_ar_prog, \"crus\", None, [&dst, initial_object]);\n         Archive {\n             handler: handler,\n             dst: dst,\n@@ -100,17 +109,47 @@ impl<'a> Archive<'a> {\n \n     /// Opens an existing static archive\n     pub fn open(config: ArchiveConfig<'a>) -> Archive<'a> {\n-        let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n-        assert!(dst.exists());\n-        Archive {\n-            handler: handler,\n-            dst: dst,\n-            lib_search_paths: lib_search_paths,\n-            os: os,\n-            maybe_ar_prog: maybe_ar_prog\n+        let archive = Archive::new(config);\n+        assert!(archive.dst.exists());\n+        archive\n+    }\n+\n+    /// Removes a file from this archive\n+    pub fn remove_file(&mut self, file: &str) {\n+        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, [&self.dst, &Path::new(file)]);\n+    }\n+\n+    /// Lists all files in an archive\n+    pub fn files(&self) -> Vec<String> {\n+        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, [&self.dst]);\n+        let output = str::from_utf8(output.output.as_slice()).unwrap();\n+        // use lines_any because windows delimits output with `\\r\\n` instead of\n+        // just `\\n`\n+        output.lines_any().map(|s| s.to_string()).collect()\n+    }\n+\n+    /// Creates an `ArchiveBuilder` for adding files to this archive.\n+    pub fn extend(self) -> ArchiveBuilder<'a> {\n+        ArchiveBuilder::new(self)\n+    }\n+}\n+\n+impl<'a> ArchiveBuilder<'a> {\n+    fn new(archive: Archive<'a>) -> ArchiveBuilder<'a> {\n+        ArchiveBuilder {\n+            archive: archive,\n+            work_dir: TempDir::new(\"rsar\").unwrap(),\n+            members: vec![],\n+            should_update_symbols: false,\n         }\n     }\n \n+    /// Create a new static archive, ready for adding files.\n+    pub fn create(config: ArchiveConfig<'a>) -> ArchiveBuilder<'a> {\n+        let archive = Archive::new(config);\n+        ArchiveBuilder::new(archive)\n+    }\n+\n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n@@ -135,48 +174,96 @@ impl<'a> Archive<'a> {\n     }\n \n     /// Adds an arbitrary file to this archive\n-    pub fn add_file(&mut self, file: &Path, has_symbols: bool) {\n-        let cmd = if has_symbols {\"r\"} else {\"rS\"};\n-        run_ar(self.handler, &self.maybe_ar_prog, cmd, None, [&self.dst, file]);\n-    }\n-\n-    /// Removes a file from this archive\n-    pub fn remove_file(&mut self, file: &str) {\n-        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, [&self.dst, &Path::new(file)]);\n+    pub fn add_file(&mut self, file: &Path) -> io::IoResult<()> {\n+        let filename = Path::new(file.filename().unwrap());\n+        let new_file = self.work_dir.path().join(&filename);\n+        try!(fs::copy(file, &new_file));\n+        self.members.push(filename);\n+        Ok(())\n     }\n \n-    /// Updates all symbols in the archive (runs 'ar s' over it)\n+    /// Indicate that the next call to `build` should updates all symbols in\n+    /// the archive (run 'ar s' over it).\n     pub fn update_symbols(&mut self) {\n-        run_ar(self.handler, &self.maybe_ar_prog, \"s\", None, [&self.dst]);\n+        self.should_update_symbols = true;\n     }\n \n-    /// Lists all files in an archive\n-    pub fn files(&self) -> Vec<String> {\n-        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, [&self.dst]);\n-        let output = str::from_utf8(output.output.as_slice()).unwrap();\n-        // use lines_any because windows delimits output with `\\r\\n` instead of\n-        // just `\\n`\n-        output.lines_any().map(|s| s.to_string()).collect()\n+    /// Combine the provided files, rlibs, and native libraries into a single\n+    /// `Archive`.\n+    pub fn build(self) -> Archive<'a> {\n+        // Get an absolute path to the destination, so `ar` will work even\n+        // though we run it from `self.work_dir`.\n+        let abs_dst = os::getcwd().join(&self.archive.dst);\n+        assert!(!abs_dst.is_relative());\n+        let mut args = vec![&abs_dst];\n+        let mut total_len = abs_dst.as_vec().len();\n+\n+        if self.members.is_empty() {\n+            // OSX `ar` does not allow using `r` with no members, but it does\n+            // allow running `ar s file.a` to update symbols only.\n+            if self.should_update_symbols {\n+                run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n+                       \"s\", Some(self.work_dir.path()), args.as_slice());\n+            }\n+            return self.archive;\n+        }\n+\n+        // Don't allow the total size of `args` to grow beyond 32,000 bytes.\n+        // Windows will raise an error if the argument string is longer than\n+        // 32,768, and we leave a bit of extra space for the program name.\n+        static ARG_LENGTH_LIMIT: uint = 32000;\n+\n+        for member_name in self.members.iter() {\n+            let len = member_name.as_vec().len();\n+\n+            // `len + 1` to account for the space that's inserted before each\n+            // argument.  (Windows passes command-line arguments as a single\n+            // string, not an array of strings.)\n+            if total_len + len + 1 > ARG_LENGTH_LIMIT {\n+                // Add the archive members seen so far, without updating the\n+                // symbol table (`S`).\n+                run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n+                       \"cruS\", Some(self.work_dir.path()), args.as_slice());\n+\n+                args.clear();\n+                args.push(&abs_dst);\n+                total_len = abs_dst.as_vec().len();\n+            }\n+\n+            args.push(member_name);\n+            total_len += len + 1;\n+        }\n+\n+        // Add the remaining archive members, and update the symbol table if\n+        // necessary.\n+        let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n+        run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n+               flags, Some(self.work_dir.path()), args.as_slice());\n+\n+        self.archive\n     }\n \n     fn add_archive(&mut self, archive: &Path, name: &str,\n                    skip: &[&str]) -> io::IoResult<()> {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n-        // First, extract the contents of the archive to a temporary directory\n+        // First, extract the contents of the archive to a temporary directory.\n+        // We don't unpack directly into `self.work_dir` due to the possibility\n+        // of filename collisions.\n         let archive = os::make_absolute(archive);\n-        run_ar(self.handler, &self.maybe_ar_prog, \"x\", Some(loc.path()), [&archive]);\n+        run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n+               \"x\", Some(loc.path()), [&archive]);\n \n         // Next, we must rename all of the inputs to \"guaranteed unique names\".\n-        // The reason for this is that archives are keyed off the name of the\n-        // files, so if two files have the same name they will override one\n-        // another in the archive (bad).\n+        // We move each file into `self.work_dir` under its new unique name.\n+        // The reason for this renaming is that archives are keyed off the name\n+        // of the files, so if two files have the same name they will override\n+        // one another in the archive (bad).\n         //\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n         let files = try!(fs::readdir(loc.path()));\n-        let mut inputs = Vec::new();\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n             if skip.iter().any(|s| *s == filename) { continue }\n@@ -192,29 +279,23 @@ impl<'a> Archive<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = file.with_filename(filename);\n+            let new_filename = self.work_dir.path().join(filename.as_slice());\n             try!(fs::rename(file, &new_filename));\n-            inputs.push(new_filename);\n+            self.members.push(Path::new(filename));\n         }\n-        if inputs.len() == 0 { return Ok(()) }\n-\n-        // Finally, add all the renamed files to this archive\n-        let mut args = vec!(&self.dst);\n-        args.extend(inputs.iter());\n-        run_ar(self.handler, &self.maybe_ar_prog, \"r\", None, args.as_slice());\n         Ok(())\n     }\n \n     fn find_library(&self, name: &str) -> Path {\n-        let (osprefix, osext) = match self.os {\n+        let (osprefix, osext) = match self.archive.os {\n             abi::OsWin32 => (\"\", \"lib\"), _ => (\"lib\", \"a\"),\n         };\n         // On Windows, static libraries sometimes show up as libfoo.a and other\n         // times show up as foo.lib\n         let oslibname = format!(\"{}{}.{}\", osprefix, name, osext);\n         let unixlibname = format!(\"lib{}.a\", name);\n \n-        for path in self.lib_search_paths.iter() {\n+        for path in self.archive.lib_search_paths.iter() {\n             debug!(\"looking for {} inside {}\", name, path.display());\n             let test = path.join(oslibname.as_slice());\n             if test.exists() { return test }\n@@ -223,9 +304,9 @@ impl<'a> Archive<'a> {\n                 if test.exists() { return test }\n             }\n         }\n-        self.handler.fatal(format!(\"could not find native static library `{}`, \\\n-                                 perhaps an -L flag is missing?\",\n-                                name).as_slice());\n+        self.archive.handler.fatal(format!(\"could not find native static library `{}`, \\\n+                                            perhaps an -L flag is missing?\",\n+                                           name).as_slice());\n     }\n }\n "}]}