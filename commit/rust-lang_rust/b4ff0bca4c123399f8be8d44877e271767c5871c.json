{"sha": "b4ff0bca4c123399f8be8d44877e271767c5871c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZmYwYmNhNGMxMjMzOTlmOGJlOGQ0NDg3N2UyNzE3NjdjNTg3MWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-03T19:22:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-03T19:22:16Z"}, "message": "auto merge of #8921 : huonw/rust/stability, r=brson\n\nSignificant progress on #6875, enough that I'll open new bugs and turn that into a metabug when this lands.\r\n\r\nDescription & example in the commit message.", "tree": {"sha": "1dce179b3e5f546fb7c4cecb7d042dae88dbcb65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dce179b3e5f546fb7c4cecb7d042dae88dbcb65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4ff0bca4c123399f8be8d44877e271767c5871c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4ff0bca4c123399f8be8d44877e271767c5871c", "html_url": "https://github.com/rust-lang/rust/commit/b4ff0bca4c123399f8be8d44877e271767c5871c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4ff0bca4c123399f8be8d44877e271767c5871c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee90a002ab0841f5fcfdf74eb74b58b1c1a8000", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee90a002ab0841f5fcfdf74eb74b58b1c1a8000", "html_url": "https://github.com/rust-lang/rust/commit/7ee90a002ab0841f5fcfdf74eb74b58b1c1a8000"}, {"sha": "506f69aed7e2f5dfdd2134ae0c74e47559e1c649", "url": "https://api.github.com/repos/rust-lang/rust/commits/506f69aed7e2f5dfdd2134ae0c74e47559e1c649", "html_url": "https://github.com/rust-lang/rust/commit/506f69aed7e2f5dfdd2134ae0c74e47559e1c649"}], "stats": {"total": 748, "additions": 745, "deletions": 3}, "files": [{"sha": "cfe0ff4768f77daebdf4285a75bafb0af0978da6", "filename": "doc/rust.md", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff0bca4c123399f8be8d44877e271767c5871c/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff0bca4c123399f8be8d44877e271767c5871c/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=b4ff0bca4c123399f8be8d44877e271767c5871c", "patch": "@@ -1038,7 +1038,7 @@ code_. They are defined in the same way as any other Rust function,\n except that they have the `extern` modifier.\n \n ~~~\n-// Declares an extern fn, the ABI defaults to \"C\" \n+// Declares an extern fn, the ABI defaults to \"C\"\n extern fn new_vec() -> ~[int] { ~[] }\n \n // Declares an extern fn with \"stdcall\" ABI\n@@ -1723,6 +1723,62 @@ Supported traits for `deriving` are:\n   each constituent field of the type must also implement `ToStr` and will have\n   `field.to_str()` invoked to build up the result.\n \n+### Stability\n+One can indicate the stability of an API using the following attributes:\n+\n+* `deprecated`: This item should no longer be used, e.g. it has been\n+  replaced. No guarantee of backwards-compatibility.\n+* `experimental`: This item was only recently introduced or is\n+  otherwise in a state of flux. It may change significantly, or even\n+  be removed. No guarantee of backwards-compatibility.\n+* `unstable`: This item is still under development, but requires more\n+  testing to be considered stable. No guarantee of backwards-compatibility.\n+* `stable`: This item is considered stable, and will not change\n+  significantly. Guarantee of backwards-compatibility.\n+* `frozen`: This item is very stable, and is unlikely to\n+  change. Guarantee of backwards-compatibility.\n+* `locked`: This item will never change unless a serious bug is\n+  found. Guarantee of backwards-compatibility.\n+\n+These levels are directly inspired by\n+[Node.js' \"stability index\"](http://nodejs.org/api/documentation.html).\n+\n+There are lints for disallowing items marked with certain levels:\n+`deprecated`, `experimental` and `unstable`; the first two will warn\n+by default. Items with not marked with a stability are considered to\n+be unstable for the purposes of the lint. One can give an optional\n+string that will be displayed when the lint flags the use of an item.\n+\n+~~~ {.xfail-test}\n+#[warn(unstable)];\n+\n+#[deprecated=\"replaced by `best`\"]\n+fn bad() {\n+    // delete everything\n+}\n+\n+fn better() {\n+    // delete fewer things\n+}\n+\n+#[stable]\n+fn best() {\n+    // delete nothing\n+}\n+\n+fn main() {\n+    bad(); // \"warning: use of deprecated item: replaced by `best`\"\n+\n+    better(); // \"warning: use of unmarked item\"\n+\n+    best(); // no warning\n+}\n+~~~\n+\n+> **Note:** Currently these are only checked when applied to\n+> individual functions, structs, methods and enum variants, *not* to\n+> entire modules, traits, impls or enums themselves.\n+\n # Statements and expressions\n \n Rust is _primarily_ an expression language. This means that most forms of"}, {"sha": "786d1bf3242518819cb32d1cb45a9ecfc251cbe2", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b4ff0bca4c123399f8be8d44877e271767c5871c", "patch": "@@ -330,6 +330,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, variant.node.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_visibility(ebml_w, variant.node.vis);\n+        encode_attributes(ebml_w, variant.node.attrs);\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args)\n                     if args.len() > 0 && generics.ty_params.len() == 0 => {"}, {"sha": "1e1be5f7a13b7b83508a581b9a184dd066ec2c59", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=b4ff0bca4c123399f8be8d44877e271767c5871c", "patch": "@@ -12,6 +12,7 @@\n use driver::session;\n use middle::ty;\n use middle::pat_util;\n+use metadata::csearch;\n use util::ppaux::{ty_to_str};\n \n use std::cmp;\n@@ -27,7 +28,7 @@ use std::u8;\n use extra::smallintmap::SmallIntMap;\n use syntax::ast_map;\n use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{AttrMetaMethods, AttributeMethods};\n use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::parse::token;\n@@ -97,6 +98,10 @@ pub enum lint {\n     missing_doc,\n     unreachable_code,\n \n+    deprecated,\n+    experimental,\n+    unstable,\n+\n     warnings,\n }\n \n@@ -281,6 +286,27 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n     }),\n \n+    (\"deprecated\",\n+     LintSpec {\n+        lint: deprecated,\n+        desc: \"detects use of #[deprecated] items\",\n+        default: warn\n+    }),\n+\n+    (\"experimental\",\n+     LintSpec {\n+        lint: experimental,\n+        desc: \"detects use of #[experimental] items\",\n+        default: warn\n+    }),\n+\n+    (\"unstable\",\n+     LintSpec {\n+        lint: unstable,\n+        desc: \"detects use of #[unstable] items (incl. items with no stability attribute)\",\n+        default: allow\n+    }),\n+\n     (\"warnings\",\n      LintSpec {\n         lint: warnings,\n@@ -1375,6 +1401,107 @@ fn lint_missing_doc() -> @mut OuterLint {\n     @mut MissingDocLintVisitor { stopping_on_items: false } as @mut OuterLint\n }\n \n+/// Checks for use of items with #[deprecated], #[experimental] and\n+/// #[unstable] (or none of them) attributes.\n+struct StabilityLintVisitor { stopping_on_items: bool }\n+\n+impl StabilityLintVisitor {\n+    fn handle_def(&mut self, sp: Span, def: &ast::Def, cx: @mut Context) {\n+        let id = ast_util::def_id_of_def(*def);\n+\n+        let stability = if ast_util::is_local(id) {\n+            // this crate\n+            match cx.tcx.items.find(&id.node) {\n+                Some(ast_node) => {\n+                    let s = do ast_node.with_attrs |attrs| {\n+                        do attrs.map_move |a| {\n+                            attr::find_stability(a.iter().map(|a| a.meta()))\n+                        }\n+                    };\n+                    match s {\n+                        Some(s) => s,\n+\n+                        // no possibility of having attributes\n+                        // (e.g. it's a local variable), so just\n+                        // ignore it.\n+                        None => return\n+                    }\n+                }\n+                _ => cx.tcx.sess.bug(fmt!(\"handle_def: %? not found\", id))\n+            }\n+        } else {\n+            // cross-crate\n+\n+            let mut s = None;\n+            // run through all the attributes and take the first\n+            // stability one.\n+            do csearch::get_item_attrs(cx.tcx.cstore, id) |meta_items| {\n+                if s.is_none() {\n+                    s = attr::find_stability(meta_items.move_iter())\n+                }\n+            }\n+            s\n+        };\n+\n+        let (lint, label) = match stability {\n+            // no stability attributes == Unstable\n+            None => (unstable, \"unmarked\"),\n+            Some(attr::Stability { level: attr::Unstable, _ }) => (unstable, \"unstable\"),\n+            Some(attr::Stability { level: attr::Experimental, _ }) => {\n+                (experimental, \"experimental\")\n+            }\n+            Some(attr::Stability { level: attr::Deprecated, _ }) => (deprecated, \"deprecated\"),\n+            _ => return\n+        };\n+\n+        let msg = match stability {\n+            Some(attr::Stability { text: Some(ref s), _ }) => {\n+                fmt!(\"use of %s item: %s\", label, *s)\n+            }\n+            _ => fmt!(\"use of %s item\", label)\n+        };\n+\n+        cx.span_lint(lint, sp, msg);\n+    }\n+}\n+\n+impl SubitemStoppableVisitor for StabilityLintVisitor {\n+    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+}\n+\n+impl Visitor<@mut Context> for StabilityLintVisitor {\n+    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n+        self.OVERRIDE_visit_item(i, e);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n+        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    }\n+\n+    fn visit_expr(&mut self, ex: @ast::Expr, cx: @mut Context) {\n+        match ex.node {\n+            ast::ExprMethodCall(*) |\n+            ast::ExprPath(*) |\n+            ast::ExprStruct(*) => {\n+                match cx.tcx.def_map.find(&ex.id) {\n+                    Some(def) => self.handle_def(ex.span, def, cx),\n+                    None => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, ex, cx)\n+    }\n+}\n+\n+outer_lint_boilerplate_impl!(StabilityLintVisitor)\n+\n+fn lint_stability() -> @mut OuterLint {\n+    @mut StabilityLintVisitor { stopping_on_items: false } as @mut OuterLint\n+}\n+\n struct LintCheckVisitor;\n \n impl Visitor<@mut Context> for LintCheckVisitor {\n@@ -1458,6 +1585,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::Crate) {\n     cx.add_old_lint(lint_unused_mut());\n     cx.add_old_lint(lint_unnecessary_allocations());\n     cx.add_old_lint(lint_missing_doc());\n+    cx.add_old_lint(lint_stability());\n     cx.add_lint(lint_session(cx));\n \n     // Actually perform the lint checks (iterating the ast)"}, {"sha": "dc26350d88d42a2bfb46c1085adeda53c45d14a1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b4ff0bca4c123399f8be8d44877e271767c5871c", "patch": "@@ -4706,4 +4706,3 @@ pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n \n     result\n }\n-"}, {"sha": "e3023b919f879ec4751f41af792e88832d675701", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b4ff0bca4c123399f8be8d44877e271767c5871c", "patch": "@@ -80,6 +80,26 @@ pub enum ast_node {\n     node_callee_scope(@Expr)\n }\n \n+impl ast_node {\n+    pub fn with_attrs<T>(&self, f: &fn(Option<&[Attribute]>) -> T) -> T {\n+        let attrs = match *self {\n+            node_item(i, _) => Some(i.attrs.as_slice()),\n+            node_foreign_item(fi, _, _, _) => Some(fi.attrs.as_slice()),\n+            node_trait_method(tm, _, _) => match *tm {\n+                required(ref type_m) => Some(type_m.attrs.as_slice()),\n+                provided(m) => Some(m.attrs.as_slice())\n+            },\n+            node_method(m, _, _) => Some(m.attrs.as_slice()),\n+            node_variant(ref v, _, _) => Some(v.node.attrs.as_slice()),\n+            // unit/tuple structs take the attributes straight from\n+            // the struct definition.\n+            node_struct_ctor(_, strct, _) => Some(strct.attrs.as_slice()),\n+            _ => None\n+        };\n+        f(attrs)\n+    }\n+}\n+\n pub type map = @mut HashMap<NodeId, ast_node>;\n \n pub struct Ctx {"}, {"sha": "fd0887de7224b3f82faa8423953a98463337d4bc", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b4ff0bca4c123399f8be8d44877e271767c5871c", "patch": "@@ -313,6 +313,44 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n     no_cfgs || some_cfg_matches\n }\n \n+/// Represents the #[deprecated=\"foo\"] (etc) attributes.\n+pub struct Stability {\n+    level: StabilityLevel,\n+    text: Option<@str>\n+}\n+\n+/// The available stability levels.\n+#[deriving(Eq,Ord,Clone)]\n+pub enum StabilityLevel {\n+    Deprecated,\n+    Experimental,\n+    Unstable,\n+    Stable,\n+    Frozen,\n+    Locked\n+}\n+\n+/// Find the first stability attribute. `None` if none exists.\n+pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It) -> Option<Stability> {\n+    for m in metas {\n+        let level = match m.name().as_slice() {\n+            \"deprecated\" => Deprecated,\n+            \"experimental\" => Experimental,\n+            \"unstable\" => Unstable,\n+            \"stable\" => Stable,\n+            \"frozen\" => Frozen,\n+            \"locked\" => Locked,\n+            _ => loop // not a stability level\n+        };\n+\n+        return Some(Stability {\n+                level: level,\n+                text: m.value_str()\n+            });\n+    }\n+    None\n+}\n+\n pub fn require_unique_names(diagnostic: @mut span_handler,\n                             metas: &[@MetaItem]) {\n     let mut set = HashSet::new();"}, {"sha": "af00a6876c27dd801394c0a177f019122e9bd4ba", "filename": "src/test/auxiliary/lint_stability.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=b4ff0bca4c123399f8be8d44877e271767c5871c", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#[link(name = \"lint_stability\",\n+       vers = \"0.1\")];\n+#[crate_type = \"lib\"];\n+\n+#[deprecated]\n+pub fn deprecated() {}\n+#[deprecated=\"text\"]\n+pub fn deprecated_text() {}\n+\n+#[experimental]\n+pub fn experimental() {}\n+#[experimental=\"text\"]\n+pub fn experimental_text() {}\n+\n+#[unstable]\n+pub fn unstable() {}\n+#[unstable=\"text\"]\n+pub fn unstable_text() {}\n+\n+pub fn unmarked() {}\n+\n+#[stable]\n+pub fn stable() {}\n+#[stable=\"text\"]\n+pub fn stable_text() {}\n+\n+#[locked]\n+pub fn locked() {}\n+#[locked=\"text\"]\n+pub fn locked_text() {}\n+\n+#[frozen]\n+pub fn frozen() {}\n+#[frozen=\"text\"]\n+pub fn frozen_text() {}\n+\n+#[stable]\n+pub struct MethodTester;\n+\n+impl MethodTester {\n+    #[deprecated]\n+    pub fn method_deprecated(&self) {}\n+    #[deprecated=\"text\"]\n+    pub fn method_deprecated_text(&self) {}\n+\n+    #[experimental]\n+    pub fn method_experimental(&self) {}\n+    #[experimental=\"text\"]\n+    pub fn method_experimental_text(&self) {}\n+\n+    #[unstable]\n+    pub fn method_unstable(&self) {}\n+    #[unstable=\"text\"]\n+    pub fn method_unstable_text(&self) {}\n+\n+    pub fn method_unmarked(&self) {}\n+\n+    #[stable]\n+    pub fn method_stable(&self) {}\n+    #[stable=\"text\"]\n+    pub fn method_stable_text(&self) {}\n+\n+    #[locked]\n+    pub fn method_locked(&self) {}\n+    #[locked=\"text\"]\n+    pub fn method_locked_text(&self) {}\n+\n+    #[frozen]\n+    pub fn method_frozen(&self) {}\n+    #[frozen=\"text\"]\n+    pub fn method_frozen_text(&self) {}\n+}\n+\n+pub trait Trait {\n+    #[deprecated]\n+    fn trait_deprecated(&self) {}\n+    #[deprecated=\"text\"]\n+    fn trait_deprecated_text(&self) {}\n+\n+    #[experimental]\n+    fn trait_experimental(&self) {}\n+    #[experimental=\"text\"]\n+    fn trait_experimental_text(&self) {}\n+\n+    #[unstable]\n+    fn trait_unstable(&self) {}\n+    #[unstable=\"text\"]\n+    fn trait_unstable_text(&self) {}\n+\n+    fn trait_unmarked(&self) {}\n+\n+    #[stable]\n+    fn trait_stable(&self) {}\n+    #[stable=\"text\"]\n+    fn trait_stable_text(&self) {}\n+\n+    #[locked]\n+    fn trait_locked(&self) {}\n+    #[locked=\"text\"]\n+    fn trait_locked_text(&self) {}\n+\n+    #[frozen]\n+    fn trait_frozen(&self) {}\n+    #[frozen=\"text\"]\n+    fn trait_frozen_text(&self) {}\n+}\n+\n+impl Trait for MethodTester {}\n+\n+#[deprecated]\n+pub struct DeprecatedStruct { i: int }\n+#[experimental]\n+pub struct ExperimentalStruct { i: int }\n+#[unstable]\n+pub struct UnstableStruct { i: int }\n+pub struct UnmarkedStruct { i: int }\n+#[stable]\n+pub struct StableStruct { i: int }\n+#[frozen]\n+pub struct FrozenStruct { i: int }\n+#[locked]\n+pub struct LockedStruct { i: int }\n+\n+#[deprecated]\n+pub struct DeprecatedUnitStruct;\n+#[experimental]\n+pub struct ExperimentalUnitStruct;\n+#[unstable]\n+pub struct UnstableUnitStruct;\n+pub struct UnmarkedUnitStruct;\n+#[stable]\n+pub struct StableUnitStruct;\n+#[frozen]\n+pub struct FrozenUnitStruct;\n+#[locked]\n+pub struct LockedUnitStruct;\n+\n+pub enum Enum {\n+    #[deprecated]\n+    DeprecatedVariant,\n+    #[experimental]\n+    ExperimentalVariant,\n+    #[unstable]\n+    UnstableVariant,\n+\n+    UnmarkedVariant,\n+    #[stable]\n+    StableVariant,\n+    #[frozen]\n+    FrozenVariant,\n+    #[locked]\n+    LockedVariant,\n+}"}, {"sha": "2c8b768587584d6f7e414ada966f329caed2109d", "filename": "src/test/compile-fail/lint-stability.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff0bca4c123399f8be8d44877e271767c5871c/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=b4ff0bca4c123399f8be8d44877e271767c5871c", "patch": "@@ -0,0 +1,338 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast aux-build\n+// aux-build:lint_stability.rs\n+\n+#[deny(unstable)];\n+#[deny(deprecated)];\n+#[deny(experimental)];\n+\n+mod cross_crate {\n+    extern mod lint_stability;\n+    use self::lint_stability::*;\n+\n+    fn test() {\n+        // XXX: attributes on methods are not encoded cross crate.\n+        let foo = MethodTester;\n+\n+        deprecated(); //~ ERROR use of deprecated item\n+        foo.method_deprecated(); // ~ ERROR use of deprecated item\n+        foo.trait_deprecated(); // ~ ERROR use of deprecated item\n+\n+        deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); // ~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); // ~ ERROR use of deprecated item: text\n+\n+        experimental(); //~ ERROR use of experimental item\n+        foo.method_experimental(); // ~ ERROR use of experimental item\n+        foo.trait_experimental(); // ~ ERROR use of experimental item\n+\n+        experimental_text(); //~ ERROR use of experimental item: text\n+        foo.method_experimental_text(); // ~ ERROR use of experimental item: text\n+        foo.trait_experimental_text(); // ~ ERROR use of experimental item: text\n+\n+        unstable(); //~ ERROR use of unstable item\n+        foo.method_unstable(); // ~ ERROR use of unstable item\n+        foo.trait_unstable(); // ~ ERROR use of unstable item\n+\n+        unstable_text(); //~ ERROR use of unstable item: text\n+        foo.method_unstable_text(); // ~ ERROR use of unstable item: text\n+        foo.trait_unstable_text(); // ~ ERROR use of unstable item: text\n+\n+        unmarked(); //~ ERROR use of unmarked item\n+        foo.method_unmarked(); // ~ ERROR use of unmarked item\n+        foo.trait_unmarked(); // ~ ERROR use of unmarked item\n+\n+        stable();\n+        foo.method_stable();\n+        foo.trait_stable();\n+\n+        stable_text();\n+        foo.method_stable_text();\n+        foo.trait_stable_text();\n+\n+        frozen();\n+        foo.method_frozen();\n+        foo.trait_frozen();\n+\n+        frozen_text();\n+        foo.method_frozen_text();\n+        foo.trait_frozen_text();\n+\n+        locked();\n+        foo.method_locked();\n+        foo.trait_locked();\n+\n+        locked_text();\n+        foo.method_locked_text();\n+        foo.trait_locked_text();\n+\n+\n+        let _ = DeprecatedStruct { i: 0 }; //~ ERROR use of deprecated item\n+        let _ = ExperimentalStruct { i: 0 }; //~ ERROR use of experimental item\n+        let _ = UnstableStruct { i: 0 }; //~ ERROR use of unstable item\n+        let _ = UnmarkedStruct { i: 0 }; //~ ERROR use of unmarked item\n+        let _ = StableStruct { i: 0 };\n+        let _ = FrozenStruct { i: 0 };\n+        let _ = LockedStruct { i: 0 };\n+\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+        let _ = ExperimentalUnitStruct; //~ ERROR use of experimental item\n+        let _ = UnstableUnitStruct; //~ ERROR use of unstable item\n+        let _ = UnmarkedUnitStruct; //~ ERROR use of unmarked item\n+        let _ = StableUnitStruct;\n+        let _ = FrozenUnitStruct;\n+        let _ = LockedUnitStruct;\n+\n+        let _ = DeprecatedVariant; //~ ERROR use of deprecated item\n+        let _ = ExperimentalVariant; //~ ERROR use of experimental item\n+        let _ = UnstableVariant; //~ ERROR use of unstable item\n+        let _ = UnmarkedVariant; //~ ERROR use of unmarked item\n+        let _ = StableVariant;\n+        let _ = FrozenVariant;\n+        let _ = LockedVariant;\n+    }\n+}\n+\n+mod this_crate {\n+    #[deprecated]\n+    pub fn deprecated() {}\n+    #[deprecated=\"text\"]\n+    pub fn deprecated_text() {}\n+\n+    #[experimental]\n+    pub fn experimental() {}\n+    #[experimental=\"text\"]\n+    pub fn experimental_text() {}\n+\n+    #[unstable]\n+    pub fn unstable() {}\n+    #[unstable=\"text\"]\n+    pub fn unstable_text() {}\n+\n+    pub fn unmarked() {}\n+\n+    #[stable]\n+    pub fn stable() {}\n+    #[stable=\"text\"]\n+    pub fn stable_text() {}\n+\n+    #[locked]\n+    pub fn locked() {}\n+    #[locked=\"text\"]\n+    pub fn locked_text() {}\n+\n+    #[frozen]\n+    pub fn frozen() {}\n+    #[frozen=\"text\"]\n+    pub fn frozen_text() {}\n+\n+    #[stable]\n+    pub struct MethodTester;\n+\n+    impl MethodTester {\n+        #[deprecated]\n+        pub fn method_deprecated(&self) {}\n+        #[deprecated=\"text\"]\n+        pub fn method_deprecated_text(&self) {}\n+\n+        #[experimental]\n+        pub fn method_experimental(&self) {}\n+        #[experimental=\"text\"]\n+        pub fn method_experimental_text(&self) {}\n+\n+        #[unstable]\n+        pub fn method_unstable(&self) {}\n+        #[unstable=\"text\"]\n+        pub fn method_unstable_text(&self) {}\n+\n+        pub fn method_unmarked(&self) {}\n+\n+        #[stable]\n+        pub fn method_stable(&self) {}\n+        #[stable=\"text\"]\n+        pub fn method_stable_text(&self) {}\n+\n+        #[locked]\n+        pub fn method_locked(&self) {}\n+        #[locked=\"text\"]\n+        pub fn method_locked_text(&self) {}\n+\n+        #[frozen]\n+        pub fn method_frozen(&self) {}\n+        #[frozen=\"text\"]\n+        pub fn method_frozen_text(&self) {}\n+    }\n+\n+    pub trait Trait {\n+        #[deprecated]\n+        fn trait_deprecated(&self) {}\n+        #[deprecated=\"text\"]\n+        fn trait_deprecated_text(&self) {}\n+\n+        #[experimental]\n+        fn trait_experimental(&self) {}\n+        #[experimental=\"text\"]\n+        fn trait_experimental_text(&self) {}\n+\n+        #[unstable]\n+        fn trait_unstable(&self) {}\n+        #[unstable=\"text\"]\n+        fn trait_unstable_text(&self) {}\n+\n+        fn trait_unmarked(&self) {}\n+\n+        #[stable]\n+        fn trait_stable(&self) {}\n+        #[stable=\"text\"]\n+        fn trait_stable_text(&self) {}\n+\n+        #[locked]\n+        fn trait_locked(&self) {}\n+        #[locked=\"text\"]\n+        fn trait_locked_text(&self) {}\n+\n+        #[frozen]\n+        fn trait_frozen(&self) {}\n+        #[frozen=\"text\"]\n+        fn trait_frozen_text(&self) {}\n+    }\n+\n+    impl Trait for MethodTester {}\n+\n+    #[deprecated]\n+    pub struct DeprecatedStruct { i: int }\n+    #[experimental]\n+    pub struct ExperimentalStruct { i: int }\n+    #[unstable]\n+    pub struct UnstableStruct { i: int }\n+    pub struct UnmarkedStruct { i: int }\n+    #[stable]\n+    pub struct StableStruct { i: int }\n+    #[frozen]\n+    pub struct FrozenStruct { i: int }\n+    #[locked]\n+    pub struct LockedStruct { i: int }\n+\n+    #[deprecated]\n+    pub struct DeprecatedUnitStruct;\n+    #[experimental]\n+    pub struct ExperimentalUnitStruct;\n+    #[unstable]\n+    pub struct UnstableUnitStruct;\n+    pub struct UnmarkedUnitStruct;\n+    #[stable]\n+    pub struct StableUnitStruct;\n+    #[frozen]\n+    pub struct FrozenUnitStruct;\n+    #[locked]\n+    pub struct LockedUnitStruct;\n+\n+    pub enum Enum {\n+        #[deprecated]\n+        DeprecatedVariant,\n+        #[experimental]\n+        ExperimentalVariant,\n+        #[unstable]\n+        UnstableVariant,\n+\n+        UnmarkedVariant,\n+        #[stable]\n+        StableVariant,\n+        #[frozen]\n+        FrozenVariant,\n+        #[locked]\n+        LockedVariant,\n+    }\n+\n+    fn test() {\n+        let foo = MethodTester;\n+\n+        deprecated(); //~ ERROR use of deprecated item\n+        foo.method_deprecated(); // ~ ERROR use of deprecated item\n+        foo.trait_deprecated(); // ~ ERROR use of deprecated item\n+\n+        deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); // ~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); // ~ ERROR use of deprecated item: text\n+\n+        experimental(); //~ ERROR use of experimental item\n+        foo.method_experimental(); // ~ ERROR use of experimental item\n+        foo.trait_experimental(); // ~ ERROR use of experimental item\n+\n+        experimental_text(); //~ ERROR use of experimental item: text\n+        foo.method_experimental_text(); // ~ ERROR use of experimental item: text\n+        foo.trait_experimental_text(); // ~ ERROR use of experimental item: text\n+\n+        unstable(); //~ ERROR use of unstable item\n+        foo.method_unstable(); // ~ ERROR use of unstable item\n+        foo.trait_unstable(); // ~ ERROR use of unstable item\n+\n+        unstable_text(); //~ ERROR use of unstable item: text\n+        foo.method_unstable_text(); // ~ ERROR use of unstable item: text\n+        foo.trait_unstable_text(); // ~ ERROR use of unstable item: text\n+\n+        unmarked(); //~ ERROR use of unmarked item\n+        foo.method_unmarked(); // ~ ERROR use of unmarked item\n+        foo.trait_unmarked(); // ~ ERROR use of unmarked item\n+\n+        stable();\n+        foo.method_stable();\n+        foo.trait_stable();\n+\n+        stable_text();\n+        foo.method_stable_text();\n+        foo.trait_stable_text();\n+\n+        frozen();\n+        foo.method_frozen();\n+        foo.trait_frozen();\n+\n+        frozen_text();\n+        foo.method_frozen_text();\n+        foo.trait_frozen_text();\n+\n+        locked();\n+        foo.method_locked();\n+        foo.trait_locked();\n+\n+        locked_text();\n+        foo.method_locked_text();\n+        foo.trait_locked_text();\n+\n+\n+        let _ = DeprecatedStruct { i: 0 }; //~ ERROR use of deprecated item\n+        let _ = ExperimentalStruct { i: 0 }; //~ ERROR use of experimental item\n+        let _ = UnstableStruct { i: 0 }; //~ ERROR use of unstable item\n+        let _ = UnmarkedStruct { i: 0 }; //~ ERROR use of unmarked item\n+        let _ = StableStruct { i: 0 };\n+        let _ = FrozenStruct { i: 0 };\n+        let _ = LockedStruct { i: 0 };\n+\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+        let _ = ExperimentalUnitStruct; //~ ERROR use of experimental item\n+        let _ = UnstableUnitStruct; //~ ERROR use of unstable item\n+        let _ = UnmarkedUnitStruct; //~ ERROR use of unmarked item\n+        let _ = StableUnitStruct;\n+        let _ = FrozenUnitStruct;\n+        let _ = LockedUnitStruct;\n+\n+        let _ = DeprecatedVariant; //~ ERROR use of deprecated item\n+        let _ = ExperimentalVariant; //~ ERROR use of experimental item\n+        let _ = UnstableVariant; //~ ERROR use of unstable item\n+        let _ = UnmarkedVariant; //~ ERROR use of unmarked item\n+        let _ = StableVariant;\n+        let _ = FrozenVariant;\n+        let _ = LockedVariant;\n+    }\n+}\n+\n+fn main() {}"}]}