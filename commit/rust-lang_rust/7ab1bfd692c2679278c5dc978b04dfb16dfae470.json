{"sha": "7ab1bfd692c2679278c5dc978b04dfb16dfae470", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYjFiZmQ2OTJjMjY3OTI3OGM1ZGM5NzhiMDRkZmIxNmRmYWU0NzA=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-22T09:16:47Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-22T18:26:24Z"}, "message": "Only make suggestion when type is `Copy`.\n\nThis commit makes the suggestion to dereference when a type implements\n`Deref` only apply if the dereference would succeed (ie. the type is\n`Copy`, otherwise a borrow check error would occur).", "tree": {"sha": "813d67fa414a65a40f2acb39da5e458d04b1d425", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/813d67fa414a65a40f2acb39da5e458d04b1d425"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ab1bfd692c2679278c5dc978b04dfb16dfae470", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAly+B1AACgkQAXYLT59T\n8VQ9lw//T3VFK9aWKBNuapIZCxFHJnhJxFahvfHAJsvulasLQCUWQqv11WZMLgbP\n7O8vB5i2QQKBHNE2htLkK9NSu7Yu9x+maaorQVP3EdyyaWbYYm0CH9SBwp8WahjF\nvwqQbUoloo9mZO2aX+jh7/cTiz5uiTMVSGpMTnT5r2FOdTLinZnegZrwWxQtPMNs\njn3JZNLzwLzTl3rOIDaFn7cOhejC/dXuQ+gzJwF+X55Yp5/TL3gtf2Xw6Mj4oQ05\nP64t65BK7SqFDZZpTnCGISsPa1d/ifZKTdaATbvjk3WjvLw8Yo9JhM6lI7jOOdUY\nEqzFOroNQr8fiU7WVZwcjhS6hexsBkhm8i+Imk5SlOyG28u/1s1t48sWsnbaxM+9\n5lpNe8p7/bdBVYfNB10fK/1YNLzxOttCF9l9g27eqwYZgmB5GlvqTjqv+joc6n+B\n8dn21qN++J2f6z0LKusFEqHTCYxH2M+6LxZSfGvh7Zlr1RfPwNOVdxcq+LTXYR6p\nv0is7XQjOfT2TP1Owb+d2CC7JIw1cU8N25wrAtc0Xy1PodCnxB/jrNOaqlEoegQl\nfCwd/b/eGvVl8ckUHuR6CqpsmsXcK8FZvbTjV5v0tObpesWvERG1IoqWZh1FLU+f\nvbETM1qkuNhCHV5GTU/Re32qGRLwvp1IH36UKNeWbxQ/xB6UINA=\n=Qr8S\n-----END PGP SIGNATURE-----", "payload": "tree 813d67fa414a65a40f2acb39da5e458d04b1d425\nparent fd95ba357465e39386924e40e05efef715a4ad46\nauthor David Wood <david@davidtw.co> 1555924607 +0100\ncommitter David Wood <david@davidtw.co> 1555957584 +0100\n\nOnly make suggestion when type is `Copy`.\n\nThis commit makes the suggestion to dereference when a type implements\n`Deref` only apply if the dereference would succeed (ie. the type is\n`Copy`, otherwise a borrow check error would occur).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ab1bfd692c2679278c5dc978b04dfb16dfae470", "html_url": "https://github.com/rust-lang/rust/commit/7ab1bfd692c2679278c5dc978b04dfb16dfae470", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ab1bfd692c2679278c5dc978b04dfb16dfae470/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd95ba357465e39386924e40e05efef715a4ad46", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd95ba357465e39386924e40e05efef715a4ad46", "html_url": "https://github.com/rust-lang/rust/commit/fd95ba357465e39386924e40e05efef715a4ad46"}], "stats": {"total": 166, "additions": 91, "deletions": 75}, "files": [{"sha": "6ce03025bf23cd769d556cc4cc77b89ebad8a3ec", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 43, "deletions": 62, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -324,8 +324,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             sp,\n         );\n \n-        match (&expected.sty, &checked_ty.sty) {\n-            (&ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n+        // Check the `expn_info()` to see if this is a macro; if so, it's hard to\n+        // extract the text and make a good suggestion, so don't bother.\n+        let is_macro = sp.ctxt().outer().expn_info().is_some();\n+\n+        match (&expr.node, &expected.sty, &checked_ty.sty) {\n+            (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n                 (&ty::Str, &ty::Array(arr, _)) |\n                 (&ty::Str, &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.node {\n@@ -352,7 +356,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 _ => {}\n             },\n-            (&ty::Ref(_, _, mutability), _) => {\n+            (_, &ty::Ref(_, _, mutability), _) => {\n                 // Check if it can work when put into a ref. For example:\n                 //\n                 // ```\n@@ -407,65 +411,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         });\n                     }\n                 }\n-            }\n-            (_, &ty::Ref(_, checked, _)) => {\n+            },\n+            (hir::ExprKind::AddrOf(_, ref expr), _, &ty::Ref(_, checked, _)) if {\n+                self.infcx.can_sub(self.param_env, checked, &expected).is_ok() && !is_macro\n+            } => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n-                // we may want to suggest adding a `*`, or removing\n-                // a `&`.\n-                //\n-                // (But, also check the `expn_info()` to see if this is\n-                // a macro; if so, it's hard to extract the text and make a good\n-                // suggestion, so don't bother.)\n-                if self.infcx.can_sub(self.param_env, checked, &expected).is_ok() &&\n-                   sp.ctxt().outer().expn_info().is_none() {\n-                    match expr.node {\n-                        // Maybe remove `&`?\n-                        hir::ExprKind::AddrOf(_, ref expr) => {\n-                            if !cm.span_to_filename(expr.span).is_real() {\n-                                if let Ok(code) = cm.span_to_snippet(sp) {\n-                                    if code.chars().next() == Some('&') {\n-                                        return Some((\n-                                            sp,\n-                                            \"consider removing the borrow\",\n-                                            code[1..].to_string()),\n-                                        );\n-                                    }\n-                                }\n-                                return None;\n-                            }\n-                            if let Ok(code) = cm.span_to_snippet(expr.span) {\n-                                return Some((sp, \"consider removing the borrow\", code));\n-                            }\n-                        }\n-\n-                        // Maybe add `*`? Only if `T: Copy`.\n-                        _ => {\n-                            if self.infcx.type_is_copy_modulo_regions(self.param_env,\n-                                                                      checked,\n-                                                                      sp) {\n-                                // do not suggest if the span comes from a macro (#52783)\n-                                if let (Ok(code), true) = (\n-                                    cm.span_to_snippet(sp),\n-                                    sp == expr.span,\n-                                ) {\n-                                    return Some((\n-                                        sp,\n-                                        \"consider dereferencing the borrow\",\n-                                        if is_struct_pat_shorthand_field {\n-                                            format!(\"{}: *{}\", code, code)\n-                                        } else {\n-                                            format!(\"*{}\", code)\n-                                        },\n-                                    ));\n-                                }\n-                            }\n+                // we may want to suggest removing a `&`.\n+                if !cm.span_to_filename(expr.span).is_real() {\n+                    if let Ok(code) = cm.span_to_snippet(sp) {\n+                        if code.chars().next() == Some('&') {\n+                            return Some((\n+                                sp,\n+                                \"consider removing the borrow\",\n+                                code[1..].to_string(),\n+                            ));\n                         }\n                     }\n+                    return None;\n                 }\n-            }\n-            _ => {\n-                // If neither type is a reference, then check for `Deref` implementations by\n-                // constructing a predicate to prove: `<T as Deref>::Output == U`\n+                if let Ok(code) = cm.span_to_snippet(expr.span) {\n+                    return Some((sp, \"consider removing the borrow\", code));\n+                }\n+            },\n+            _ if sp == expr.span && !is_macro => {\n+                // Check for `Deref` implementations by constructing a predicate to\n+                // prove: `<T as Deref>::Output == U`\n                 let deref_trait = self.tcx.lang_items().deref_trait().unwrap();\n                 let item_def_id = self.tcx.associated_items(deref_trait).next().unwrap().def_id;\n                 let predicate = ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n@@ -483,17 +453,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty: expected,\n                 }));\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n-                if self.infcx.predicate_may_hold(&obligation) {\n-                    if let (Ok(code), true) = (cm.span_to_snippet(sp), sp == expr.span) {\n-                        let msg = if is_struct_pat_shorthand_field {\n+                let impls_deref = self.infcx.predicate_may_hold(&obligation);\n+\n+                // For a suggestion to make sense, the type would need to be `Copy`.\n+                let is_copy = self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp);\n+\n+                if is_copy && impls_deref {\n+                    if let Ok(code) = cm.span_to_snippet(sp) {\n+                        let message = if checked_ty.is_region_ptr() {\n+                            \"consider dereferencing the borrow\"\n+                        } else {\n+                            \"consider dereferencing the type\"\n+                        };\n+                        let suggestion = if is_struct_pat_shorthand_field {\n                             format!(\"{}: *{}\", code, code)\n                         } else {\n                             format!(\"*{}\", code)\n                         };\n-                        return Some((sp, \"consider dereferencing the type\", msg));\n+                        return Some((sp, message, suggestion));\n                     }\n                 }\n             }\n+            _ => {}\n         }\n         None\n     }"}, {"sha": "a5cc66f4473f289dd0fd943dac18732910f27302", "filename": "src/test/ui/infinite/infinite-autoderef.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -5,7 +5,7 @@ LL |         x = box x;\n    |             ^^^^^\n    |             |\n    |             cyclic type of infinite size\n-   |             help: consider dereferencing the type: `*box x`\n+   |             help: try using a conversion method: `box x.to_string()`\n \n error[E0055]: reached the recursion limit while auto-dereferencing `Foo`\n   --> $DIR/infinite-autoderef.rs:25:5"}, {"sha": "74e29a5aea7289652adf65a406bdfb1a3a0cd2cd", "filename": "src/test/ui/occurs-check-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Foccurs-check-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Foccurs-check-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foccurs-check-2.stderr?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -5,7 +5,7 @@ LL |     f = box g;\n    |         ^^^^^\n    |         |\n    |         cyclic type of infinite size\n-   |         help: consider dereferencing the type: `*box g`\n+   |         help: try using a conversion method: `box g.to_string()`\n \n error: aborting due to previous error\n "}, {"sha": "61ce61b1cbeb69ab5d19d575e96c62106b4f6d58", "filename": "src/test/ui/occurs-check.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Foccurs-check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Foccurs-check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foccurs-check.stderr?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -5,7 +5,7 @@ LL |     f = box f;\n    |         ^^^^^\n    |         |\n    |         cyclic type of infinite size\n-   |         help: consider dereferencing the type: `*box f`\n+   |         help: try using a conversion method: `box f.to_string()`\n \n error: aborting due to previous error\n "}, {"sha": "996d80a07e058ed2d471b7bf7309fe6acb61d9c2", "filename": "src/test/ui/span/coerce-suggestions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -44,7 +44,7 @@ LL |     f = box f;\n    |         ^^^^^\n    |         |\n    |         cyclic type of infinite size\n-   |         help: consider dereferencing the type: `*box f`\n+   |         help: try using a conversion method: `box f.to_string()`\n \n error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:21:9"}, {"sha": "644d2a4e41bafb29a284d598102b805d410b9141", "filename": "src/test/ui/suggestions/issue-59819.fixed", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.fixed?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -7,9 +7,18 @@\n \n struct Foo(i32);\n \n+struct Bar(String);\n+\n impl std::ops::Deref for Foo {\n     type Target = i32;\n-    fn deref(&self) -> &i32 {\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl std::ops::Deref for Bar {\n+    type Target = String;\n+    fn deref(&self) -> &Self::Target {\n         &self.0\n     }\n }\n@@ -19,4 +28,8 @@ fn main() {\n     let y: i32 = *x; //~ ERROR mismatched types\n     let a = &42;\n     let b: i32 = *a; //~ ERROR mismatched types\n+\n+    // Do not make a suggestion when adding a `*` wouldn't actually fix the issue:\n+    let f = Bar(\"bar\".to_string());\n+    let g: String = f.to_string(); //~ ERROR mismatched types\n }"}, {"sha": "8e8ff8372e808362eba24ba39e4b5ab938936da5", "filename": "src/test/ui/suggestions/issue-59819.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.rs?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -7,9 +7,18 @@\n \n struct Foo(i32);\n \n+struct Bar(String);\n+\n impl std::ops::Deref for Foo {\n     type Target = i32;\n-    fn deref(&self) -> &i32 {\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl std::ops::Deref for Bar {\n+    type Target = String;\n+    fn deref(&self) -> &Self::Target {\n         &self.0\n     }\n }\n@@ -19,4 +28,8 @@ fn main() {\n     let y: i32 = x; //~ ERROR mismatched types\n     let a = &42;\n     let b: i32 = a; //~ ERROR mismatched types\n+\n+    // Do not make a suggestion when adding a `*` wouldn't actually fix the issue:\n+    let f = Bar(\"bar\".to_string());\n+    let g: String = f; //~ ERROR mismatched types\n }"}, {"sha": "66898115cbd6de1d308f35693be17dd95471f5c4", "filename": "src/test/ui/suggestions/issue-59819.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.stderr?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-59819.rs:19:18\n+  --> $DIR/issue-59819.rs:28:18\n    |\n LL |     let y: i32 = x;\n    |                  ^\n@@ -11,7 +11,7 @@ LL |     let y: i32 = x;\n               found type `Foo`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-59819.rs:21:18\n+  --> $DIR/issue-59819.rs:30:18\n    |\n LL |     let b: i32 = a;\n    |                  ^\n@@ -22,6 +22,18 @@ LL |     let b: i32 = a;\n    = note: expected type `i32`\n               found type `&{integer}`\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-59819.rs:34:21\n+   |\n+LL |     let g: String = f;\n+   |                     ^\n+   |                     |\n+   |                     expected struct `std::string::String`, found struct `Bar`\n+   |                     help: try using a conversion method: `f.to_string()`\n+   |\n+   = note: expected type `std::string::String`\n+              found type `Bar`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "05b9fb43fe1bcba0bef0e747255c0602fc8ca49a", "filename": "src/test/ui/terr-sorts.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fterr-sorts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ab1bfd692c2679278c5dc978b04dfb16dfae470/src%2Ftest%2Fui%2Fterr-sorts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterr-sorts.stderr?ref=7ab1bfd692c2679278c5dc978b04dfb16dfae470", "patch": "@@ -2,10 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/terr-sorts.rs:10:14\n    |\n LL |     want_foo(b);\n-   |              ^\n-   |              |\n-   |              expected struct `Foo`, found struct `std::boxed::Box`\n-   |              help: consider dereferencing the type: `*b`\n+   |              ^ expected struct `Foo`, found struct `std::boxed::Box`\n    |\n    = note: expected type `Foo`\n               found type `std::boxed::Box<Foo>`"}]}