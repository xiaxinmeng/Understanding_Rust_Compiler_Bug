{"sha": "4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiOWIwZDM0NzRlYzY0MTMzZmU3OTdkOGZjZjhhMDNjODAzYmFjOGE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-15T08:54:27Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-20T12:35:57Z"}, "message": "Refactor `CrateConfig`.", "tree": {"sha": "cb8ea8a759f655a894ed7afb7103ca247491e4c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb8ea8a759f655a894ed7afb7103ca247491e4c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "html_url": "https://github.com/rust-lang/rust/commit/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "html_url": "https://github.com/rust-lang/rust/commit/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f"}], "stats": {"total": 205, "additions": 64, "deletions": 141}, "files": [{"sha": "d22d5d915f6b0b34f03bccf3a5a46e9c0875b105", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "patch": "@@ -25,7 +25,6 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n-use syntax::attr;\n use syntax::parse::{self, token};\n use syntax::parse::token::InternedString;\n use syntax::feature_gate::UnstableFeatures;\n@@ -41,6 +40,7 @@ use std::collections::btree_map::Values as BTreeMapValuesIter;\n use std::fmt;\n use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n+use std::collections::HashSet;\n use std::iter::FromIterator;\n use std::path::PathBuf;\n \n@@ -945,47 +945,39 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n         InternedString::new(\"unix\")\n     };\n \n-    let mk = attr::mk_name_value_item_str;\n-    let mut ret = vec![ // Target bindings.\n-        mk(token::intern(\"target_os\"), intern(os)),\n-        mk(token::intern(\"target_family\"), fam.clone()),\n-        mk(token::intern(\"target_arch\"), intern(arch)),\n-        mk(token::intern(\"target_endian\"), intern(end)),\n-        mk(token::intern(\"target_pointer_width\"), intern(wordsz)),\n-        mk(token::intern(\"target_env\"), intern(env)),\n-        mk(token::intern(\"target_vendor\"), intern(vendor)),\n-    ];\n-    match &fam[..] {\n-        \"windows\" | \"unix\" => ret.push(attr::mk_word_item(token::intern(&fam))),\n-        _ => (),\n+    let mut ret = HashSet::new();\n+    // Target bindings.\n+    ret.insert((token::intern(\"target_os\"), Some(intern(os))));\n+    ret.insert((token::intern(\"target_family\"), Some(fam.clone())));\n+    ret.insert((token::intern(\"target_arch\"), Some(intern(arch))));\n+    ret.insert((token::intern(\"target_endian\"), Some(intern(end))));\n+    ret.insert((token::intern(\"target_pointer_width\"), Some(intern(wordsz))));\n+    ret.insert((token::intern(\"target_env\"), Some(intern(env))));\n+    ret.insert((token::intern(\"target_vendor\"), Some(intern(vendor))));\n+    if &fam == \"windows\" || &fam == \"unix\" {\n+        ret.insert((token::intern(&fam), None));\n     }\n     if sess.target.target.options.has_elf_tls {\n-        ret.push(attr::mk_word_item(token::intern(\"target_thread_local\")));\n+        ret.insert((token::intern(\"target_thread_local\"), None));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i <= max_atomic_width {\n             let s = i.to_string();\n-            ret.push(mk(token::intern(\"target_has_atomic\"), intern(&s)));\n+            ret.insert((token::intern(\"target_has_atomic\"), Some(intern(&s))));\n             if &s == wordsz {\n-                ret.push(mk(token::intern(\"target_has_atomic\"), intern(\"ptr\")));\n+                ret.insert((token::intern(\"target_has_atomic\"), Some(intern(\"ptr\"))));\n             }\n         }\n     }\n     if sess.opts.debug_assertions {\n-        ret.push(attr::mk_word_item(token::intern(\"debug_assertions\")));\n+        ret.insert((token::intern(\"debug_assertions\"), None));\n     }\n     if sess.opts.crate_types.contains(&CrateTypeProcMacro) {\n-        ret.push(attr::mk_word_item(token::intern(\"proc_macro\")));\n+        ret.insert((token::intern(\"proc_macro\"), None));\n     }\n     return ret;\n }\n \n-pub fn append_configuration(cfg: &mut ast::CrateConfig, name: ast::Name) {\n-    if !cfg.iter().any(|mi| mi.name() == name) {\n-        cfg.push(attr::mk_word_item(name))\n-    }\n-}\n-\n pub fn build_configuration(sess: &Session,\n                            mut user_cfg: ast::CrateConfig)\n                            -> ast::CrateConfig {\n@@ -994,11 +986,10 @@ pub fn build_configuration(sess: &Session,\n     let default_cfg = default_configuration(sess);\n     // If the user wants a test runner, then add the test cfg\n     if sess.opts.test {\n-        append_configuration(&mut user_cfg, token::intern(\"test\"))\n+        user_cfg.insert((token::intern(\"test\"), None));\n     }\n-    let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.extend_from_slice(&default_cfg[..]);\n-    v\n+    user_cfg.extend(default_cfg.iter().cloned());\n+    user_cfg\n }\n \n pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n@@ -1244,11 +1235,14 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n         let meta_item = panictry!(parser.parse_meta_item());\n \n         if !parser.reader.is_eof() {\n-            early_error(ErrorOutputType::default(), &format!(\"invalid --cfg argument: {}\",\n-                                                             s))\n+            early_error(ErrorOutputType::default(), &format!(\"invalid --cfg argument: {}\", s))\n+        } else if meta_item.is_meta_item_list() {\n+            let msg =\n+                format!(\"invalid predicate in --cfg command line argument: `{}`\", meta_item.name());\n+            early_error(ErrorOutputType::default(), &msg)\n         }\n \n-        meta_item\n+        (meta_item.name(), meta_item.value_str())\n     }).collect::<ast::CrateConfig>()\n }\n "}, {"sha": "e0a2eb6ae5ec8ae2c6788d191dfa4754a045c735", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 19, "deletions": 45, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "patch": "@@ -95,12 +95,11 @@ use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n-use syntax::{ast, json};\n+use syntax::ast;\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n-use syntax_pos::MultiSpan;\n-use errors::emitter::Emitter;\n+use syntax_pos::{DUMMY_SP, MultiSpan};\n \n #[cfg(test)]\n pub mod test;\n@@ -374,37 +373,11 @@ fn handle_explain(code: &str,\n     }\n }\n \n-fn check_cfg(cfg: &ast::CrateConfig,\n-             output: ErrorOutputType) {\n-    let emitter: Box<Emitter> = match output {\n-        config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(errors::emitter::EmitterWriter::stderr(color_config, None))\n-        }\n-        config::ErrorOutputType::Json => Box::new(json::JsonEmitter::basic()),\n-    };\n-    let handler = errors::Handler::with_emitter(true, false, emitter);\n-\n-    let mut saw_invalid_predicate = false;\n-    for item in cfg.iter() {\n-        if item.is_meta_item_list() {\n-            saw_invalid_predicate = true;\n-            handler.emit(&MultiSpan::new(),\n-                         &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n-                                  item.name()),\n-                            errors::Level::Fatal);\n-        }\n-    }\n-\n-    if saw_invalid_predicate {\n-        panic!(errors::FatalError);\n-    }\n-}\n-\n impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,\n                       _: &config::Options,\n-                      cfg: &ast::CrateConfig,\n+                      _: &ast::CrateConfig,\n                       descriptions: &errors::registry::Registry,\n                       output: ErrorOutputType)\n                       -> Compilation {\n@@ -413,7 +386,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             return Compilation::Stop;\n         }\n \n-        check_cfg(cfg, output);\n         Compilation::Continue\n     }\n \n@@ -640,24 +612,26 @@ impl RustcDefaultCalls {\n                     let allow_unstable_cfg = UnstableFeatures::from_environment()\n                         .is_nightly_build();\n \n-                    for cfg in &sess.parse_sess.config {\n-                        if !allow_unstable_cfg && GatedCfg::gate(cfg).is_some() {\n+                    let mut cfgs = Vec::new();\n+                    for &(name, ref value) in sess.parse_sess.config.iter() {\n+                        let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n+                            node: ast::MetaItemKind::Word(name),\n+                            span: DUMMY_SP,\n+                        });\n+                        if !allow_unstable_cfg && gated_cfg.is_some() {\n                             continue;\n                         }\n \n-                        if cfg.is_word() {\n-                            println!(\"{}\", cfg.name());\n-                        } else if let Some(s) = cfg.value_str() {\n-                            println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n-                        } else if cfg.is_meta_item_list() {\n-                            // Right now there are not and should not be any\n-                            // MetaItemKind::List items in the configuration returned by\n-                            // `build_configuration`.\n-                            panic!(\"Found an unexpected list in cfg attribute '{}'!\", cfg.name())\n+                        cfgs.push(if let &Some(ref value) = value {\n+                            format!(\"{}=\\\"{}\\\"\", name, value)\n                         } else {\n-                            // There also shouldn't be literals.\n-                            panic!(\"Found an unexpected literal in cfg attribute '{}'!\", cfg.name())\n-                        }\n+                            format!(\"{}\", name)\n+                        });\n+                    }\n+\n+                    cfgs.sort();\n+                    for cfg in cfgs {\n+                        println!(\"{}\", cfg);\n                     }\n                 }\n                 PrintRequest::TargetCPUs => {"}, {"sha": "34073dfd24d2aaed85518cddb0d668532b483a30", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::{ast, attr};\n+use syntax::ast;\n use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n use rustc_trans::back::write::create_target_machine;\n@@ -44,7 +44,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.push(attr::mk_name_value_item_str(tf, intern(&feat[..feat.len() - 1])))\n+            cfg.insert((tf, Some(intern(&feat[..feat.len() - 1]))));\n         }\n     }\n \n@@ -73,6 +73,6 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     }\n \n     if crt_static {\n-        cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(\"crt-static\")));\n+        cfg.insert((tf, Some(intern(\"crt-static\"))));\n     }\n }"}, {"sha": "c22416e1120d8d8ec8f9d72edd3c2e7ca9faf286", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "patch": "@@ -48,7 +48,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n use ich::Fingerprint;\n@@ -88,12 +88,11 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-\n     fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, item);\n-                match DepNode::from_label_string(&value[..], def_id) {\n+                match DepNode::from_label_string(&value.as_str(), def_id) {\n                     Ok(def_id) => return def_id,\n                     Err(()) => {\n                         self.tcx.sess.span_fatal(\n@@ -276,13 +275,7 @@ fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n         if item.check_name(CFG) {\n             let value = expect_associated_value(tcx, item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n-            for cfg in &config[..] {\n-                if cfg.check_name(&value[..]) {\n-                    debug!(\"check_config: matched {:?}\", cfg);\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return config.contains(&(value, None));\n         }\n     }\n \n@@ -291,9 +284,9 @@ fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n         &format!(\"no cfg attribute\"));\n }\n \n-fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> InternedString {\n+fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {\n     if let Some(value) = item.value_str() {\n-        value\n+        token::intern(&value)\n     } else {\n         let msg = if let Some(name) = item.name() {\n             format!(\"associated value expected for `{}`\", name)"}, {"sha": "0bdf66e4589bd418eb4e24be0d8f4e7b9f66c284", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "patch": "@@ -29,7 +29,7 @@\n \n use rustc::ty::TyCtxt;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n \n use {ModuleSource, ModuleTranslation};\n \n@@ -77,7 +77,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n \n         let mname = self.field(attr, MODULE);\n-        let mtrans = self.modules.iter().find(|mtrans| &mtrans.name[..] == &mname[..]);\n+        let mtrans = self.modules.iter().find(|mtrans| *mtrans.name == *mname.as_str());\n         let mtrans = match mtrans {\n             Some(m) => m,\n             None => {\n@@ -113,11 +113,11 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n     }\n \n-    fn field(&self, attr: &ast::Attribute, name: &str) -> InternedString {\n+    fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {\n-                    return value;\n+                    return token::intern(&value);\n                 } else {\n                     self.tcx.sess.span_fatal(\n                         item.span,\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         let config = &self.tcx.sess.parse_sess.config;\n         let value = self.field(attr, CFG);\n         debug!(\"check_config(config={:?}, value={:?})\", config, value);\n-        if config.iter().any(|c| c.check_name(&value[..])) {\n+        if config.iter().any(|&(name, _)| name == value) {\n             debug!(\"check_config: matched\");\n             return true;\n         }"}, {"sha": "3664cc8e0643c420a0dcfdc8d1f4f787a6b91cfd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "patch": "@@ -25,6 +25,7 @@ use print::pprust;\n use ptr::P;\n use tokenstream::{TokenTree};\n \n+use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n use std::u32;\n@@ -485,7 +486,7 @@ pub struct WhereEqPredicate {\n \n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n-pub type CrateConfig = Vec<P<MetaItem>>;\n+pub type CrateConfig = HashSet<(Name, Option<InternedString>)>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Crate {\n@@ -519,7 +520,7 @@ pub type MetaItem = Spanned<MetaItemKind>;\n /// A compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n-#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n@@ -535,34 +536,6 @@ pub enum MetaItemKind {\n     NameValue(Name, Lit),\n }\n \n-// can't be derived because the MetaItemKind::List requires an unordered comparison\n-impl PartialEq for MetaItemKind {\n-    fn eq(&self, other: &MetaItemKind) -> bool {\n-        use self::MetaItemKind::*;\n-        match *self {\n-            Word(ref ns) => match *other {\n-                Word(ref no) => (*ns) == (*no),\n-                _ => false\n-            },\n-            List(ref ns, ref miss) => match *other {\n-                List(ref no, ref miso) => {\n-                    ns == no &&\n-                        miss.iter().all(|mi| {\n-                            miso.iter().any(|x| x.node == mi.node)\n-                        })\n-                }\n-                _ => false\n-            },\n-            NameValue(ref ns, ref vs) => match *other {\n-                NameValue(ref no, ref vo) => {\n-                    (*ns) == (*no) && vs.node == vo.node\n-                }\n-                _ => false\n-            },\n-        }\n-    }\n-}\n-\n /// A Block (`{ .. }`).\n ///\n /// E.g. `{ .. }` as in `fn foo() { .. }`"}, {"sha": "f84199fb29eed34eb6fd71b81f1e5988e04da630", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "patch": "@@ -400,18 +400,6 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos, hi: By\n     }\n }\n \n-/* Searching */\n-/// Check if `needle` occurs in `haystack` by a structural\n-/// comparison. This is slightly subtle, and relies on ignoring the\n-/// span included in the `==` comparison a plain MetaItem.\n-pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n-    debug!(\"attr::contains (name={})\", needle.name());\n-    haystack.iter().any(|item| {\n-        debug!(\"  testing: {}\", item.name());\n-        item.node == needle.node\n-    })\n-}\n-\n pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n     debug!(\"attr::list_contains_name (name={})\", name);\n     items.iter().any(|item| {\n@@ -558,7 +546,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n             if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n                 gated_cfg.check_and_emit(sess, feats);\n             }\n-            contains(&sess.config, cfg)\n+            sess.config.contains(&(cfg.name(), cfg.value_str()))\n         }\n     }\n }"}, {"sha": "7feb745259c1b899399cdcd4dbc07e00bb880ce0", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9b0d3474ec64133fe797d8fcf8a03c803bac8a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=4b9b0d3474ec64133fe797d8fcf8a03c803bac8a", "patch": "@@ -22,6 +22,7 @@ use str::char_at;\n use tokenstream;\n \n use std::cell::RefCell;\n+use std::collections::HashSet;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n@@ -64,7 +65,7 @@ impl ParseSess {\n         ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n-            config: Vec::new(),\n+            config: HashSet::new(),\n             included_mod_stack: RefCell::new(vec![]),\n             code_map: code_map\n         }"}]}