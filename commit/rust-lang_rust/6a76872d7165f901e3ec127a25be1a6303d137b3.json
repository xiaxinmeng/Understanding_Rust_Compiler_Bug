{"sha": "6a76872d7165f901e3ec127a25be1a6303d137b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNzY4NzJkNzE2NWY5MDFlM2VjMTI3YTI1YmUxYTYzMDNkMTM3YjM=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-26T10:59:30Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-26T23:21:00Z"}, "message": "Extend linkchecker with anchor checking\n\nThis adds checks to ensure that:\n* link anchors refer to existing id's on the target page\n* id's are unique within an html document\n* page redirects are valid", "tree": {"sha": "244dcfc32d2d4feebe65b30fdfbb8bd883b07d96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/244dcfc32d2d4feebe65b30fdfbb8bd883b07d96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a76872d7165f901e3ec127a25be1a6303d137b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a76872d7165f901e3ec127a25be1a6303d137b3", "html_url": "https://github.com/rust-lang/rust/commit/6a76872d7165f901e3ec127a25be1a6303d137b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a76872d7165f901e3ec127a25be1a6303d137b3/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0f74b605942849b647b0e262fbda1969bd73c2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f74b605942849b647b0e262fbda1969bd73c2a", "html_url": "https://github.com/rust-lang/rust/commit/d0f74b605942849b647b0e262fbda1969bd73c2a"}], "stats": {"total": 277, "additions": 215, "deletions": 62}, "files": [{"sha": "a09640c3055c2ac68bd7cdeab15074100da83a97", "filename": "src/doc/style/features/traits/generics.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md?ref=6a76872d7165f901e3ec127a25be1a6303d137b3", "patch": "@@ -27,8 +27,7 @@ explicitly implement to be used by this generic function.\n * _Inference_. Since the type parameters to generic functions can usually be\n   inferred, generic functions can help cut down on verbosity in code where\n   explicit conversions or other method calls would usually be necessary. See the\n-  [overloading/implicits use case](#use-case-limited-overloading-andor-implicit-conversions)\n-  below.\n+  overloading/implicits use case below.\n * _Precise types_. Because generics give a _name_ to the specific type\n   implementing a trait, it is possible to be precise about places where that\n   exact type is required or produced. For example, a function\n@@ -51,7 +50,7 @@ explicitly implement to be used by this generic function.\n   a `Vec<T>` contains elements of a single concrete type (and, indeed, the\n   vector representation is specialized to lay these out in line). Sometimes\n   heterogeneous collections are useful; see\n-  [trait objects](#use-case-trait-objects) below.\n+  trait objects below.\n * _Signature verbosity_. Heavy use of generics can bloat function signatures.\n   **[Ed. note]** This problem may be mitigated by some language improvements; stay tuned.\n "}, {"sha": "4dbcf7ab4e320b6ef1d68fb13ab10ba1630c2dec", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=6a76872d7165f901e3ec127a25be1a6303d137b3", "patch": "@@ -434,7 +434,7 @@ pub trait Iterator {\n     /// `None`. Once `None` is encountered, `count()` returns the number of\n     /// times it called [`next()`].\n     ///\n-    /// [`next()`]: #method.next\n+    /// [`next()`]: #tymethod.next\n     ///\n     /// # Overflow Behavior\n     ///\n@@ -497,7 +497,7 @@ pub trait Iterator {\n     /// This method will evaluate the iterator `n` times, discarding those elements.\n     /// After it does so, it will call [`next()`] and return its value.\n     ///\n-    /// [`next()`]: #method.next\n+    /// [`next()`]: #tymethod.next\n     ///\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n     /// returns the first value, `nth(1)` the second, and so on."}, {"sha": "5362f7086bd8b0413c90fcd56a8e25d609f9fe9a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=6a76872d7165f901e3ec127a25be1a6303d137b3", "patch": "@@ -1254,7 +1254,7 @@ pub trait BufRead: Read {\n     /// longer be returned. As such, this function may do odd things if\n     /// `fill_buf` isn't called before calling it.\n     ///\n-    /// [fillbuf]: #tymethod.fill_buff\n+    /// [fillbuf]: #tymethod.fill_buf\n     ///\n     /// The `amt` must be `<=` the number of bytes in the buffer returned by\n     /// `fill_buf`."}, {"sha": "f7b1042592d855ad6655a060fc837a311c033edc", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6a76872d7165f901e3ec127a25be1a6303d137b3", "patch": "@@ -190,7 +190,7 @@\n //! [`thread`]: thread/index.html\n //! [`use std::env`]: env/index.html\n //! [`use`]: ../book/crates-and-modules.html#importing-modules-with-use\n-//! [crate root]: ../book/crates-and-modules.html#basic-terminology:-crates-and-modules\n+//! [crate root]: ../book/crates-and-modules.html#basic-terminology-crates-and-modules\n //! [crates.io]: https://crates.io\n //! [deref coercions]: ../book/deref-coercions.html\n //! [files]: fs/struct.File.html"}, {"sha": "38da74b89039b9f03e0d752ff9dc5727b9c3f6b1", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=6a76872d7165f901e3ec127a25be1a6303d137b3", "patch": "@@ -196,7 +196,7 @@ impl TcpStream {\n     ///\n     /// For more information about this option, see [`set_nodelay`][link].\n     ///\n-    /// [link]: #tymethod.set_nodelay\n+    /// [link]: #method.set_nodelay\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn nodelay(&self) -> io::Result<bool> {\n         self.0.nodelay()\n@@ -215,7 +215,7 @@ impl TcpStream {\n     ///\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n-    /// [link]: #tymethod.set_ttl\n+    /// [link]: #method.set_ttl\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -238,7 +238,7 @@ impl TcpStream {\n     ///\n     /// For more information about this option, see [`set_only_v6`][link].\n     ///\n-    /// [link]: #tymethod.set_only_v6\n+    /// [link]: #method.set_only_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n@@ -374,7 +374,7 @@ impl TcpListener {\n     ///\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n-    /// [link]: #tymethod.set_ttl\n+    /// [link]: #method.set_ttl\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -397,7 +397,7 @@ impl TcpListener {\n     ///\n     /// For more information about this option, see [`set_only_v6`][link].\n     ///\n-    /// [link]: #tymethod.set_only_v6\n+    /// [link]: #method.set_only_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()"}, {"sha": "0be9f13e817614bfefb0044be40cbbcbb97a84fc", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=6a76872d7165f901e3ec127a25be1a6303d137b3", "patch": "@@ -155,7 +155,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`set_broadcast`][link].\n     ///\n-    /// [link]: #tymethod.set_broadcast\n+    /// [link]: #method.set_broadcast\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn broadcast(&self) -> io::Result<bool> {\n         self.0.broadcast()\n@@ -175,7 +175,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`set_multicast_loop_v4`][link].\n     ///\n-    /// [link]: #tymethod.set_multicast_loop_v4\n+    /// [link]: #method.set_multicast_loop_v4\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n         self.0.multicast_loop_v4()\n@@ -198,7 +198,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`set_multicast_ttl_v4`][link].\n     ///\n-    /// [link]: #tymethod.set_multicast_ttl_v4\n+    /// [link]: #method.set_multicast_ttl_v4\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n         self.0.multicast_ttl_v4()\n@@ -218,7 +218,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`set_multicast_loop_v6`][link].\n     ///\n-    /// [link]: #tymethod.set_multicast_loop_v6\n+    /// [link]: #method.set_multicast_loop_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n         self.0.multicast_loop_v6()\n@@ -237,7 +237,7 @@ impl UdpSocket {\n     ///\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n-    /// [link]: #tymethod.set_ttl\n+    /// [link]: #method.set_ttl\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -260,7 +260,7 @@ impl UdpSocket {\n     ///\n     /// For more information about this option, see [`set_only_v6`][link].\n     ///\n-    /// [link]: #tymethod.set_only_v6\n+    /// [link]: #method.set_only_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n@@ -293,7 +293,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`join_multicast_v4`][link].\n     ///\n-    /// [link]: #tymethod.join_multicast_v4\n+    /// [link]: #method.join_multicast_v4\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n         self.0.leave_multicast_v4(multiaddr, interface)\n@@ -304,7 +304,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`join_multicast_v6`][link].\n     ///\n-    /// [link]: #tymethod.join_multicast_v6\n+    /// [link]: #method.join_multicast_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n         self.0.leave_multicast_v6(multiaddr, interface)"}, {"sha": "db87bc1fce4be87b146c5e1268eeb06760cafcb6", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 196, "deletions": 42, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a76872d7165f901e3ec127a25be1a6303d137b3/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=6a76872d7165f901e3ec127a25be1a6303d137b3", "patch": "@@ -17,9 +17,9 @@\n //! actually point to a valid place.\n //!\n //! Currently this doesn't actually do any HTML parsing or anything fancy like\n-//! that, it just has a simple \"regex\" to search for `href` tags. These values\n-//! are then translated to file URLs if possible and then the destination is\n-//! asserted to exist.\n+//! that, it just has a simple \"regex\" to search for `href` and `id` tags.\n+//! These values are then translated to file URLs if possible and then the\n+//! destination is asserted to exist.\n //!\n //! A few whitelisted exceptions are allowed as there's known bugs in rustdoc,\n //! but this should catch the majority of \"broken link\" cases.\n@@ -29,14 +29,16 @@ extern crate url;\n use std::env;\n use std::fs::File;\n use std::io::prelude::*;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n+use std::collections::{HashMap, HashSet};\n+use std::collections::hash_map::Entry;\n \n use url::{Url, UrlParser};\n \n macro_rules! t {\n     ($e:expr) => (match $e {\n         Ok(e) => e,\n-        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+        Err(e) => panic!(\"{} failed with {:?}\", stringify!($e), e),\n     })\n }\n \n@@ -45,44 +47,68 @@ fn main() {\n     let docs = env::current_dir().unwrap().join(docs);\n     let mut url = Url::from_file_path(&docs).unwrap();\n     let mut errors = false;\n-    walk(&docs, &docs, &mut url, &mut errors);\n+    walk(&mut HashMap::new(), &docs, &docs, &mut url, &mut errors);\n     if errors {\n         panic!(\"found some broken links\");\n     }\n }\n \n-fn walk(root: &Path, dir: &Path, url: &mut Url, errors: &mut bool) {\n+#[derive(Debug)]\n+pub enum LoadError {\n+    IOError(std::io::Error),\n+    BrokenRedirect(PathBuf, std::io::Error),\n+}\n+\n+struct FileEntry {\n+    source: String,\n+    ids: HashSet<String>,\n+}\n+\n+type Cache = HashMap<PathBuf, FileEntry>;\n+\n+fn walk(cache: &mut Cache,\n+        root: &Path,\n+        dir: &Path,\n+        url: &mut Url,\n+        errors: &mut bool)\n+{\n     for entry in t!(dir.read_dir()).map(|e| t!(e)) {\n         let path = entry.path();\n         let kind = t!(entry.file_type());\n         url.path_mut().unwrap().push(entry.file_name().into_string().unwrap());\n         if kind.is_dir() {\n-            walk(root, &path, url, errors);\n+            walk(cache, root, &path, url, errors);\n         } else {\n-            check(root, &path, url, errors);\n+            check(cache, root, &path, url, errors);\n         }\n         url.path_mut().unwrap().pop();\n     }\n }\n \n-fn check(root: &Path, file: &Path, base: &Url, errors: &mut bool) {\n+fn check(cache: &mut Cache,\n+         root: &Path,\n+         file: &Path,\n+         base: &Url,\n+         errors: &mut bool)\n+{\n     // ignore js files as they are not prone to errors as the rest of the\n     // documentation is and they otherwise bring up false positives.\n     if file.extension().and_then(|s| s.to_str()) == Some(\"js\") {\n         return\n     }\n \n-    let pretty_file = file.strip_prefix(root).unwrap_or(file);\n-\n     // Unfortunately we're not 100% full of valid links today to we need a few\n     // whitelists to get this past `make check` today.\n     // FIXME(#32129)\n-    if file.ends_with(\"std/string/struct.String.html\") {\n+    if file.ends_with(\"std/string/struct.String.html\") ||\n+       file.ends_with(\"collections/string/struct.String.html\") {\n         return\n     }\n     // FIXME(#32130)\n     if file.ends_with(\"btree_set/struct.BTreeSet.html\") ||\n-       file.ends_with(\"collections/struct.BTreeSet.html\") {\n+       file.ends_with(\"collections/struct.BTreeSet.html\") ||\n+       file.ends_with(\"collections/btree_map/struct.BTreeMap.html\") ||\n+       file.ends_with(\"collections/hash_map/struct.HashMap.html\") {\n         return\n     }\n \n@@ -104,15 +130,159 @@ fn check(root: &Path, file: &Path, base: &Url, errors: &mut bool) {\n \n     let mut parser = UrlParser::new();\n     parser.base_url(base);\n+\n+    let res = load_file(cache, root, PathBuf::from(file), false, false);\n+    let (pretty_file, contents) = match res {\n+        Ok(res) => res,\n+        Err(_) => return,\n+    };\n+\n+    // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n+    with_attrs_in_source(&contents, \" href\", |url, i| {\n+        // Once we've plucked out the URL, parse it using our base url and\n+        // then try to extract a file path. If either of these fail then we\n+        // just keep going.\n+        let (parsed_url, path) = match url_to_file_path(&parser, url) {\n+            Some((url, path)) => (url, PathBuf::from(path)),\n+            None => return,\n+        };\n+\n+        // Alright, if we've found a file name then this file had better\n+        // exist! If it doesn't then we register and print an error.\n+        if path.exists() {\n+            if path.is_dir() {\n+                return;\n+            }\n+            let res = load_file(cache, root, path.clone(), true, false);\n+            let (pretty_path, contents) = match res {\n+                Ok(res) => res,\n+                Err(LoadError::IOError(err)) => panic!(format!(\"{}\", err)),\n+                Err(LoadError::BrokenRedirect(target, _)) => {\n+                    print!(\"{}:{}: broken redirect to {}\",\n+                           pretty_file.display(), i + 1, target.display());\n+                    return;\n+                }\n+            };\n+\n+            if let Some(ref fragment) = parsed_url.fragment {\n+                // Fragments like `#1-6` are most likely line numbers to be\n+                // interpreted by javascript, so we're ignoring these\n+                if fragment.splitn(2, '-')\n+                           .all(|f| f.chars().all(|c| c.is_numeric())) {\n+                    return;\n+                }\n+\n+                let ids = &mut cache.get_mut(&pretty_path).unwrap().ids;\n+                if ids.is_empty() {\n+                    // Search for anything that's the regex 'id[ ]*=[ ]*\".*?\"'\n+                    with_attrs_in_source(&contents, \" id\", |fragment, i| {\n+                        let frag = fragment.trim_left_matches(\"#\").to_owned();\n+                        if !ids.insert(frag) {\n+                            *errors = true;\n+                            println!(\"{}:{}: id is not unique: `{}`\",\n+                                     pretty_file.display(), i, fragment);\n+                        }\n+                    });\n+                }\n+                if !ids.contains(fragment) {\n+                    *errors = true;\n+                    print!(\"{}:{}: broken link fragment  \",\n+                           pretty_file.display(), i + 1);\n+                    println!(\"`#{}` pointing to `{}`\",\n+                             fragment, pretty_path.display());\n+                };\n+            }\n+        } else {\n+            *errors = true;\n+            print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n+            let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n+            println!(\"{}\", pretty_path.display());\n+        }\n+    });\n+}\n+\n+fn load_file(cache: &mut Cache,\n+             root: &Path,\n+             file: PathBuf,\n+             follow_redirects: bool,\n+             is_redirect: bool) -> Result<(PathBuf, String), LoadError> {\n+\n     let mut contents = String::new();\n-    if t!(File::open(file)).read_to_string(&mut contents).is_err() {\n-        return\n+    let pretty_file = PathBuf::from(file.strip_prefix(root).unwrap_or(&file));\n+\n+    let maybe_redirect = match cache.entry(pretty_file.clone()) {\n+        Entry::Occupied(entry) => {\n+            contents = entry.get().source.clone();\n+            None\n+        },\n+        Entry::Vacant(entry) => {\n+            let mut fp = try!(File::open(file.clone()).map_err(|err| {\n+                if is_redirect {\n+                    LoadError::BrokenRedirect(file.clone(), err)\n+                } else {\n+                    LoadError::IOError(err)\n+                }\n+            }));\n+            try!(fp.read_to_string(&mut contents)\n+                   .map_err(|err| LoadError::IOError(err)));\n+\n+            let maybe = if follow_redirects {\n+                maybe_redirect(&contents)\n+            } else {\n+                None\n+            };\n+            if maybe.is_none() {\n+                entry.insert(FileEntry {\n+                    source: contents.clone(),\n+                    ids: HashSet::new(),\n+                });\n+            }\n+            maybe\n+        },\n+    };\n+    let base = Url::from_file_path(&file).unwrap();\n+    let mut parser = UrlParser::new();\n+    parser.base_url(&base);\n+\n+    match maybe_redirect.and_then(|url| url_to_file_path(&parser, &url)) {\n+        Some((_, redirect_file)) => {\n+            assert!(follow_redirects);\n+            let path = PathBuf::from(redirect_file);\n+            load_file(cache, root, path, follow_redirects, true)\n+        }\n+        None => Ok((pretty_file, contents))\n     }\n+}\n+\n+fn maybe_redirect(source: &str) -> Option<String> {\n+    const REDIRECT: &'static str = \"<p>Redirecting to <a href=\";\n+\n+    let mut lines = source.lines();\n+    let redirect_line = match lines.nth(6) {\n+        Some(l) => l,\n+        None => return None,\n+    };\n+\n+    redirect_line.find(REDIRECT).map(|i| {\n+        let rest = &redirect_line[(i + REDIRECT.len() + 1)..];\n+        let pos_quote = rest.find('\"').unwrap();\n+        rest[..pos_quote].to_owned()\n+    })\n+}\n \n+fn url_to_file_path(parser: &UrlParser, url: &str) -> Option<(Url, PathBuf)> {\n+    parser.parse(url).ok().and_then(|parsed_url| {\n+        parsed_url.to_file_path().ok().map(|f| (parsed_url, f))\n+    })\n+}\n+\n+fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str,\n+                                               attr: &str,\n+                                               mut f: F)\n+{\n     for (i, mut line) in contents.lines().enumerate() {\n-        // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n-        while let Some(j) = line.find(\" href\") {\n-            let rest = &line[j + 5..];\n+        while let Some(j) = line.find(attr) {\n+            let rest = &line[j + attr.len() ..];\n             line = rest;\n             let pos_equals = match rest.find(\"=\") {\n                 Some(i) => i,\n@@ -121,40 +291,24 @@ fn check(root: &Path, file: &Path, base: &Url, errors: &mut bool) {\n             if rest[..pos_equals].trim_left_matches(\" \") != \"\" {\n                 continue\n             }\n+\n             let rest = &rest[pos_equals + 1..];\n-            let pos_quote = match rest.find(\"\\\"\").or_else(|| rest.find(\"'\")) {\n+\n+            let pos_quote = match rest.find(&['\"', '\\''][..]) {\n                 Some(i) => i,\n                 None => continue,\n             };\n+            let quote_delim = rest.as_bytes()[pos_quote] as char;\n+\n             if rest[..pos_quote].trim_left_matches(\" \") != \"\" {\n                 continue\n             }\n             let rest = &rest[pos_quote + 1..];\n-            let url = match rest.find(\"\\\"\").or_else(|| rest.find(\"'\")) {\n+            let url = match rest.find(quote_delim) {\n                 Some(i) => &rest[..i],\n                 None => continue,\n             };\n-\n-            // Once we've plucked out the URL, parse it using our base url and\n-            // then try to extract a file path. If either if these fail then we\n-            // just keep going.\n-            let parsed_url = match parser.parse(url) {\n-                Ok(url) => url,\n-                Err(..) => continue,\n-            };\n-            let path = match parsed_url.to_file_path() {\n-                Ok(path) => path,\n-                Err(..) => continue,\n-            };\n-\n-            // Alright, if we've found a file name then this file had better\n-            // exist! If it doesn't then we register and print an error.\n-            if !path.exists() {\n-                *errors = true;\n-                print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n-                let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n-                println!(\"{}\", pretty_path.display());\n-            }\n+            f(url, i)\n         }\n     }\n }"}]}