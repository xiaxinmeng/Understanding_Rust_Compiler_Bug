{"sha": "4d6475ada0c4176734f7e7f24cb1be8c5c8d1988", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjQ3NWFkYTBjNDE3NjczNGY3ZTdmMjRjYjFiZThjNWM4ZDE5ODg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-07T10:32:32Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-07T10:32:32Z"}, "message": "refactor if lowering", "tree": {"sha": "ffe6bcecc18f5ace50d31ecb5eba86699ba46363", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffe6bcecc18f5ace50d31ecb5eba86699ba46363"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d6475ada0c4176734f7e7f24cb1be8c5c8d1988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d6475ada0c4176734f7e7f24cb1be8c5c8d1988", "html_url": "https://github.com/rust-lang/rust/commit/4d6475ada0c4176734f7e7f24cb1be8c5c8d1988", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d6475ada0c4176734f7e7f24cb1be8c5c8d1988/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2966944a80c7e017865e9705628e41b5bb4cd14", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2966944a80c7e017865e9705628e41b5bb4cd14", "html_url": "https://github.com/rust-lang/rust/commit/a2966944a80c7e017865e9705628e41b5bb4cd14"}], "stats": {"total": 31, "additions": 14, "deletions": 17}, "files": [{"sha": "9fea70dda632192201aa3bc9b1ae74fe291faa53", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4d6475ada0c4176734f7e7f24cb1be8c5c8d1988/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d6475ada0c4176734f7e7f24cb1be8c5c8d1988/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=4d6475ada0c4176734f7e7f24cb1be8c5c8d1988", "patch": "@@ -558,35 +558,32 @@ where\n         let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n         match expr.kind() {\n             ast::ExprKind::IfExpr(e) => {\n+                let then_branch = self.collect_block_opt(e.then_branch());\n+                let else_branch = e.else_branch().map(|b| match b {\n+                    ast::ElseBranch::Block(it) => self.collect_block(it),\n+                    ast::ElseBranch::IfExpr(elif) => {\n+                        let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n+                        self.collect_expr(expr)\n+                    }\n+                });\n+\n                 if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n                     // if let -- desugar to match\n                     let pat = self.collect_pat(pat);\n                     let match_expr =\n                         self.collect_expr_opt(e.condition().expect(\"checked above\").expr());\n-                    let then_branch = self.collect_block_opt(e.then_branch());\n-                    let else_branch = e\n-                        .else_branch()\n-                        .map(|b| match b {\n-                            ast::ElseBranch::Block(it) => self.collect_block(it),\n-                            ast::ElseBranch::IfExpr(elif) => self.collect_expr(elif.into()),\n-                        })\n-                        .unwrap_or_else(|| self.empty_block());\n                     let placeholder_pat = self.pats.alloc(Pat::Missing);\n                     let arms = vec![\n                         MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n-                        MatchArm { pats: vec![placeholder_pat], expr: else_branch, guard: None },\n+                        MatchArm {\n+                            pats: vec![placeholder_pat],\n+                            expr: else_branch.unwrap_or_else(|| self.empty_block()),\n+                            guard: None,\n+                        },\n                     ];\n                     self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr)\n                 } else {\n                     let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()));\n-                    let then_branch = self.collect_block_opt(e.then_branch());\n-                    let else_branch = e.else_branch().map(|b| match b {\n-                        ast::ElseBranch::Block(it) => self.collect_block(it),\n-                        ast::ElseBranch::IfExpr(elif) => {\n-                            let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n-                            self.collect_expr(expr)\n-                        }\n-                    });\n                     self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n                 }\n             }"}]}