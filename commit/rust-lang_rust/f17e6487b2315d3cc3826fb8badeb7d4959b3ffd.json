{"sha": "f17e6487b2315d3cc3826fb8badeb7d4959b3ffd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxN2U2NDg3YjIzMTVkM2NjMzgyNmZiOGJhZGViN2Q0OTU5YjNmZmQ=", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2020-11-28T19:25:42Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2020-11-28T21:38:58Z"}, "message": "lint-docs: Move free functions into methods of LintExtractor.\n\nThis helps avoid needing to pass so many parameters around.", "tree": {"sha": "edcd3f5295f90bd88e417a1d4068a733adb744cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edcd3f5295f90bd88e417a1d4068a733adb744cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd", "html_url": "https://github.com/rust-lang/rust/commit/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37f25aa3f356546ab851e394d5598fc575eabda", "url": "https://api.github.com/repos/rust-lang/rust/commits/e37f25aa3f356546ab851e394d5598fc575eabda", "html_url": "https://github.com/rust-lang/rust/commit/e37f25aa3f356546ab851e394d5598fc575eabda"}], "stats": {"total": 939, "additions": 470, "deletions": 469}, "files": [{"sha": "db667264d2fd705c26fa3ee18170e2f68d6e1d93", "filename": "src/tools/lint-docs/src/groups.rs", "status": "modified", "additions": 102, "deletions": 90, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs?ref=f17e6487b2315d3cc3826fb8badeb7d4959b3ffd", "patch": "@@ -1,9 +1,8 @@\n-use crate::Lint;\n+use crate::{Lint, LintExtractor};\n use std::collections::{BTreeMap, BTreeSet};\n use std::error::Error;\n use std::fmt::Write;\n use std::fs;\n-use std::path::Path;\n use std::process::Command;\n \n static GROUP_DESCRIPTIONS: &[(&str, &str)] = &[\n@@ -15,100 +14,113 @@ static GROUP_DESCRIPTIONS: &[(&str, &str)] = &[\n     (\"rust-2018-compatibility\", \"Lints used to transition code from the 2015 edition to 2018\"),\n ];\n \n-/// Updates the documentation of lint groups.\n-pub(crate) fn generate_group_docs(\n-    lints: &[Lint],\n-    rustc: crate::Rustc<'_>,\n-    out_path: &Path,\n-) -> Result<(), Box<dyn Error>> {\n-    let groups = collect_groups(rustc)?;\n-    let groups_path = out_path.join(\"groups.md\");\n-    let contents = fs::read_to_string(&groups_path)\n-        .map_err(|e| format!(\"could not read {}: {}\", groups_path.display(), e))?;\n-    let new_contents = contents.replace(\"{{groups-table}}\", &make_groups_table(lints, &groups)?);\n-    // Delete the output because rustbuild uses hard links in its copies.\n-    let _ = fs::remove_file(&groups_path);\n-    fs::write(&groups_path, new_contents)\n-        .map_err(|e| format!(\"could not write to {}: {}\", groups_path.display(), e))?;\n-    Ok(())\n-}\n-\n type LintGroups = BTreeMap<String, BTreeSet<String>>;\n \n-/// Collects the group names from rustc.\n-fn collect_groups(rustc: crate::Rustc<'_>) -> Result<LintGroups, Box<dyn Error>> {\n-    let mut result = BTreeMap::new();\n-    let mut cmd = Command::new(rustc.path);\n-    cmd.arg(\"-Whelp\");\n-    let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n-    if !output.status.success() {\n-        return Err(format!(\n-            \"failed to collect lint info: {:?}\\n--- stderr\\n{}--- stdout\\n{}\\n\",\n-            output.status,\n-            std::str::from_utf8(&output.stderr).unwrap(),\n-            std::str::from_utf8(&output.stdout).unwrap(),\n-        )\n-        .into());\n+impl<'a> LintExtractor<'a> {\n+    /// Updates the documentation of lint groups.\n+    pub(crate) fn generate_group_docs(&self, lints: &[Lint]) -> Result<(), Box<dyn Error>> {\n+        let groups = self.collect_groups()?;\n+        let groups_path = self.out_path.join(\"groups.md\");\n+        let contents = fs::read_to_string(&groups_path)\n+            .map_err(|e| format!(\"could not read {}: {}\", groups_path.display(), e))?;\n+        let new_contents =\n+            contents.replace(\"{{groups-table}}\", &self.make_groups_table(lints, &groups)?);\n+        // Delete the output because rustbuild uses hard links in its copies.\n+        let _ = fs::remove_file(&groups_path);\n+        fs::write(&groups_path, new_contents)\n+            .map_err(|e| format!(\"could not write to {}: {}\", groups_path.display(), e))?;\n+        Ok(())\n     }\n-    let stdout = std::str::from_utf8(&output.stdout).unwrap();\n-    let lines = stdout.lines();\n-    let group_start = lines.skip_while(|line| !line.contains(\"groups provided\")).skip(1);\n-    let table_start = group_start.skip_while(|line| !line.contains(\"----\")).skip(1);\n-    for line in table_start {\n-        if line.is_empty() {\n-            break;\n+\n+    /// Collects the group names from rustc.\n+    fn collect_groups(&self) -> Result<LintGroups, Box<dyn Error>> {\n+        let mut result = BTreeMap::new();\n+        let mut cmd = Command::new(self.rustc_path);\n+        cmd.arg(\"-Whelp\");\n+        let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n+        if !output.status.success() {\n+            return Err(format!(\n+                \"failed to collect lint info: {:?}\\n--- stderr\\n{}--- stdout\\n{}\\n\",\n+                output.status,\n+                std::str::from_utf8(&output.stderr).unwrap(),\n+                std::str::from_utf8(&output.stdout).unwrap(),\n+            )\n+            .into());\n         }\n-        let mut parts = line.trim().splitn(2, ' ');\n-        let name = parts.next().expect(\"name in group\");\n-        if name == \"warnings\" {\n-            // This is special.\n-            continue;\n+        let stdout = std::str::from_utf8(&output.stdout).unwrap();\n+        let lines = stdout.lines();\n+        let group_start = lines.skip_while(|line| !line.contains(\"groups provided\")).skip(1);\n+        let table_start = group_start.skip_while(|line| !line.contains(\"----\")).skip(1);\n+        for line in table_start {\n+            if line.is_empty() {\n+                break;\n+            }\n+            let mut parts = line.trim().splitn(2, ' ');\n+            let name = parts.next().expect(\"name in group\");\n+            if name == \"warnings\" {\n+                // This is special.\n+                continue;\n+            }\n+            let lints = parts\n+                .next()\n+                .ok_or_else(|| format!(\"expected lints following name, got `{}`\", line))?;\n+            let lints = lints.split(',').map(|l| l.trim().to_string()).collect();\n+            assert!(result.insert(name.to_string(), lints).is_none());\n         }\n-        let lints =\n-            parts.next().ok_or_else(|| format!(\"expected lints following name, got `{}`\", line))?;\n-        let lints = lints.split(',').map(|l| l.trim().to_string()).collect();\n-        assert!(result.insert(name.to_string(), lints).is_none());\n-    }\n-    if result.is_empty() {\n-        return Err(\n-            format!(\"expected at least one group in -Whelp output, got:\\n{}\", stdout).into()\n-        );\n+        if result.is_empty() {\n+            return Err(\n+                format!(\"expected at least one group in -Whelp output, got:\\n{}\", stdout).into()\n+            );\n+        }\n+        Ok(result)\n     }\n-    Ok(result)\n-}\n \n-fn make_groups_table(lints: &[Lint], groups: &LintGroups) -> Result<String, Box<dyn Error>> {\n-    let mut result = String::new();\n-    let mut to_link = Vec::new();\n-    result.push_str(\"| Group | Description | Lints |\\n\");\n-    result.push_str(\"|-------|-------------|-------|\\n\");\n-    result.push_str(\"| warnings | All lints that are set to issue warnings | See [warn-by-default] for the default set of warnings |\\n\");\n-    for (group_name, group_lints) in groups {\n-        let description = GROUP_DESCRIPTIONS.iter().find(|(n, _)| n == group_name)\n-            .ok_or_else(|| format!(\"lint group `{}` does not have a description, please update the GROUP_DESCRIPTIONS list\", group_name))?\n-            .1;\n-        to_link.extend(group_lints);\n-        let brackets: Vec<_> = group_lints.iter().map(|l| format!(\"[{}]\", l)).collect();\n-        write!(result, \"| {} | {} | {} |\\n\", group_name, description, brackets.join(\", \")).unwrap();\n-    }\n-    result.push('\\n');\n-    result.push_str(\"[warn-by-default]: listing/warn-by-default.md\\n\");\n-    for lint_name in to_link {\n-        let lint_def =\n-            lints.iter().find(|l| l.name == lint_name.replace(\"-\", \"_\")).ok_or_else(|| {\n-                format!(\n-                    \"`rustc -W help` defined lint `{}` but that lint does not appear to exist\",\n-                    lint_name\n-                )\n-            })?;\n-        write!(\n-            result,\n-            \"[{}]: listing/{}#{}\\n\",\n-            lint_name,\n-            lint_def.level.doc_filename(),\n-            lint_name\n-        )\n-        .unwrap();\n+    fn make_groups_table(\n+        &self,\n+        lints: &[Lint],\n+        groups: &LintGroups,\n+    ) -> Result<String, Box<dyn Error>> {\n+        let mut result = String::new();\n+        let mut to_link = Vec::new();\n+        result.push_str(\"| Group | Description | Lints |\\n\");\n+        result.push_str(\"|-------|-------------|-------|\\n\");\n+        result.push_str(\"| warnings | All lints that are set to issue warnings | See [warn-by-default] for the default set of warnings |\\n\");\n+        for (group_name, group_lints) in groups {\n+            let description = GROUP_DESCRIPTIONS\n+                .iter()\n+                .find(|(n, _)| n == group_name)\n+                .ok_or_else(|| {\n+                    format!(\n+                        \"lint group `{}` does not have a description, \\\n+                         please update the GROUP_DESCRIPTIONS list\",\n+                        group_name\n+                    )\n+                })?\n+                .1;\n+            to_link.extend(group_lints);\n+            let brackets: Vec<_> = group_lints.iter().map(|l| format!(\"[{}]\", l)).collect();\n+            write!(result, \"| {} | {} | {} |\\n\", group_name, description, brackets.join(\", \"))\n+                .unwrap();\n+        }\n+        result.push('\\n');\n+        result.push_str(\"[warn-by-default]: listing/warn-by-default.md\\n\");\n+        for lint_name in to_link {\n+            let lint_def =\n+                lints.iter().find(|l| l.name == lint_name.replace(\"-\", \"_\")).ok_or_else(|| {\n+                    format!(\n+                        \"`rustc -W help` defined lint `{}` but that lint does not appear to exist\",\n+                        lint_name\n+                    )\n+                })?;\n+            write!(\n+                result,\n+                \"[{}]: listing/{}#{}\\n\",\n+                lint_name,\n+                lint_def.level.doc_filename(),\n+                lint_name\n+            )\n+            .unwrap();\n+        }\n+        Ok(result)\n     }\n-    Ok(result)\n }"}, {"sha": "aafd33301ea87afd5390ea986164d03354080195", "filename": "src/tools/lint-docs/src/lib.rs", "status": "modified", "additions": 361, "deletions": 371, "changes": 732, "blob_url": "https://github.com/rust-lang/rust/blob/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs?ref=f17e6487b2315d3cc3826fb8badeb7d4959b3ffd", "patch": "@@ -7,6 +7,20 @@ use walkdir::WalkDir;\n \n mod groups;\n \n+pub struct LintExtractor<'a> {\n+    /// Path to the `src` directory, where it will scan for `.rs` files to\n+    /// find lint declarations.\n+    pub src_path: &'a Path,\n+    /// Path where to save the output.\n+    pub out_path: &'a Path,\n+    /// Path to the `rustc` executable.\n+    pub rustc_path: &'a Path,\n+    /// The target arch to build the docs for.\n+    pub rustc_target: &'a str,\n+    /// Verbose output.\n+    pub verbose: bool,\n+}\n+\n struct Lint {\n     name: String,\n     doc: Vec<String>,\n@@ -26,6 +40,28 @@ impl Lint {\n             .filter(|line| line.starts_with(\"```rust\"))\n             .all(|line| line.contains(\",ignore\"))\n     }\n+\n+    /// Checks the doc style of the lint.\n+    fn check_style(&self) -> Result<(), Box<dyn Error>> {\n+        for &expected in &[\"### Example\", \"### Explanation\", \"{{produces}}\"] {\n+            if expected == \"{{produces}}\" && self.is_ignored() {\n+                continue;\n+            }\n+            if !self.doc_contains(expected) {\n+                return Err(format!(\"lint docs should contain the line `{}`\", expected).into());\n+            }\n+        }\n+        if let Some(first) = self.doc.first() {\n+            if !first.starts_with(&format!(\"The `{}` lint\", self.name)) {\n+                return Err(format!(\n+                    \"lint docs should start with the text \\\"The `{}` lint\\\" to introduce the lint\",\n+                    self.name\n+                )\n+                .into());\n+            }\n+        }\n+        Ok(())\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -45,382 +81,374 @@ impl Level {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-pub struct Rustc<'a> {\n-    pub path: &'a Path,\n-    pub target: &'a str,\n-}\n-\n-/// Collects all lints, and writes the markdown documentation at the given directory.\n-pub fn extract_lint_docs(\n-    src_path: &Path,\n-    out_path: &Path,\n-    rustc: Rustc<'_>,\n-    verbose: bool,\n-) -> Result<(), Box<dyn Error>> {\n-    let mut lints = gather_lints(src_path)?;\n-    for lint in &mut lints {\n-        generate_output_example(lint, rustc, verbose).map_err(|e| {\n-            format!(\n-                \"failed to test example in lint docs for `{}` in {}:{}: {}\",\n-                lint.name,\n-                lint.path.display(),\n-                lint.lineno,\n-                e\n-            )\n-        })?;\n+impl<'a> LintExtractor<'a> {\n+    /// Collects all lints, and writes the markdown documentation at the given directory.\n+    pub fn extract_lint_docs(&self) -> Result<(), Box<dyn Error>> {\n+        let mut lints = self.gather_lints()?;\n+        for lint in &mut lints {\n+            self.generate_output_example(lint).map_err(|e| {\n+                format!(\n+                    \"failed to test example in lint docs for `{}` in {}:{}: {}\",\n+                    lint.name,\n+                    lint.path.display(),\n+                    lint.lineno,\n+                    e\n+                )\n+            })?;\n+        }\n+        self.save_lints_markdown(&lints)?;\n+        self.generate_group_docs(&lints)?;\n+        Ok(())\n     }\n-    save_lints_markdown(&lints, &out_path.join(\"listing\"))?;\n-    groups::generate_group_docs(&lints, rustc, out_path)?;\n-    Ok(())\n-}\n \n-/// Collects all lints from all files in the given directory.\n-fn gather_lints(src_path: &Path) -> Result<Vec<Lint>, Box<dyn Error>> {\n-    let mut lints = Vec::new();\n-    for entry in WalkDir::new(src_path).into_iter().filter_map(|e| e.ok()) {\n-        if !entry.path().extension().map_or(false, |ext| ext == \"rs\") {\n-            continue;\n+    /// Collects all lints from all files in the given directory.\n+    fn gather_lints(&self) -> Result<Vec<Lint>, Box<dyn Error>> {\n+        let mut lints = Vec::new();\n+        for entry in WalkDir::new(self.src_path).into_iter().filter_map(|e| e.ok()) {\n+            if !entry.path().extension().map_or(false, |ext| ext == \"rs\") {\n+                continue;\n+            }\n+            lints.extend(self.lints_from_file(entry.path())?);\n         }\n-        lints.extend(lints_from_file(entry.path())?);\n-    }\n-    if lints.is_empty() {\n-        return Err(\"no lints were found!\".into());\n+        if lints.is_empty() {\n+            return Err(\"no lints were found!\".into());\n+        }\n+        Ok(lints)\n     }\n-    Ok(lints)\n-}\n \n-/// Collects all lints from the given file.\n-fn lints_from_file(path: &Path) -> Result<Vec<Lint>, Box<dyn Error>> {\n-    let mut lints = Vec::new();\n-    let contents = fs::read_to_string(path)\n-        .map_err(|e| format!(\"could not read {}: {}\", path.display(), e))?;\n-    let mut lines = contents.lines().enumerate();\n-    loop {\n-        // Find a lint declaration.\n-        let lint_start = loop {\n-            match lines.next() {\n-                Some((lineno, line)) => {\n-                    if line.trim().starts_with(\"declare_lint!\") {\n-                        break lineno + 1;\n+    /// Collects all lints from the given file.\n+    fn lints_from_file(&self, path: &Path) -> Result<Vec<Lint>, Box<dyn Error>> {\n+        let mut lints = Vec::new();\n+        let contents = fs::read_to_string(path)\n+            .map_err(|e| format!(\"could not read {}: {}\", path.display(), e))?;\n+        let mut lines = contents.lines().enumerate();\n+        loop {\n+            // Find a lint declaration.\n+            let lint_start = loop {\n+                match lines.next() {\n+                    Some((lineno, line)) => {\n+                        if line.trim().starts_with(\"declare_lint!\") {\n+                            break lineno + 1;\n+                        }\n+                    }\n+                    None => return Ok(lints),\n+                }\n+            };\n+            // Read the lint.\n+            let mut doc_lines = Vec::new();\n+            let (doc, name) = loop {\n+                match lines.next() {\n+                    Some((lineno, line)) => {\n+                        let line = line.trim();\n+                        if line.starts_with(\"/// \") {\n+                            doc_lines.push(line.trim()[4..].to_string());\n+                        } else if line.starts_with(\"///\") {\n+                            doc_lines.push(\"\".to_string());\n+                        } else if line.starts_with(\"// \") {\n+                            // Ignore comments.\n+                            continue;\n+                        } else {\n+                            let name = lint_name(line).map_err(|e| {\n+                                format!(\n+                                    \"could not determine lint name in {}:{}: {}, line was `{}`\",\n+                                    path.display(),\n+                                    lineno,\n+                                    e,\n+                                    line\n+                                )\n+                            })?;\n+                            if doc_lines.is_empty() {\n+                                return Err(format!(\n+                                    \"did not find doc lines for lint `{}` in {}\",\n+                                    name,\n+                                    path.display()\n+                                )\n+                                .into());\n+                            }\n+                            break (doc_lines, name);\n+                        }\n+                    }\n+                    None => {\n+                        return Err(format!(\n+                            \"unexpected EOF for lint definition at {}:{}\",\n+                            path.display(),\n+                            lint_start\n+                        )\n+                        .into());\n                     }\n                 }\n-                None => return Ok(lints),\n+            };\n+            // These lints are specifically undocumented. This should be reserved\n+            // for internal rustc-lints only.\n+            if name == \"deprecated_in_future\" {\n+                continue;\n             }\n-        };\n-        // Read the lint.\n-        let mut doc_lines = Vec::new();\n-        let (doc, name) = loop {\n-            match lines.next() {\n-                Some((lineno, line)) => {\n-                    let line = line.trim();\n-                    if line.starts_with(\"/// \") {\n-                        doc_lines.push(line.trim()[4..].to_string());\n-                    } else if line.starts_with(\"///\") {\n-                        doc_lines.push(\"\".to_string());\n-                    } else if line.starts_with(\"// \") {\n-                        // Ignore comments.\n-                        continue;\n-                    } else {\n-                        let name = lint_name(line).map_err(|e| {\n-                            format!(\n-                                \"could not determine lint name in {}:{}: {}, line was `{}`\",\n-                                path.display(),\n-                                lineno,\n-                                e,\n-                                line\n-                            )\n-                        })?;\n-                        if doc_lines.is_empty() {\n+            // Read the level.\n+            let level = loop {\n+                match lines.next() {\n+                    // Ignore comments.\n+                    Some((_, line)) if line.trim().starts_with(\"// \") => {}\n+                    Some((lineno, line)) => match line.trim() {\n+                        \"Allow,\" => break Level::Allow,\n+                        \"Warn,\" => break Level::Warn,\n+                        \"Deny,\" => break Level::Deny,\n+                        _ => {\n                             return Err(format!(\n-                                \"did not find doc lines for lint `{}` in {}\",\n-                                name,\n-                                path.display()\n+                                \"unexpected lint level `{}` in {}:{}\",\n+                                line,\n+                                path.display(),\n+                                lineno\n                             )\n                             .into());\n                         }\n-                        break (doc_lines, name);\n-                    }\n-                }\n-                None => {\n-                    return Err(format!(\n-                        \"unexpected EOF for lint definition at {}:{}\",\n-                        path.display(),\n-                        lint_start\n-                    )\n-                    .into());\n-                }\n-            }\n-        };\n-        // These lints are specifically undocumented. This should be reserved\n-        // for internal rustc-lints only.\n-        if name == \"deprecated_in_future\" {\n-            continue;\n-        }\n-        // Read the level.\n-        let level = loop {\n-            match lines.next() {\n-                // Ignore comments.\n-                Some((_, line)) if line.trim().starts_with(\"// \") => {}\n-                Some((lineno, line)) => match line.trim() {\n-                    \"Allow,\" => break Level::Allow,\n-                    \"Warn,\" => break Level::Warn,\n-                    \"Deny,\" => break Level::Deny,\n-                    _ => {\n+                    },\n+                    None => {\n                         return Err(format!(\n-                            \"unexpected lint level `{}` in {}:{}\",\n-                            line,\n+                            \"expected lint level in {}:{}, got EOF\",\n                             path.display(),\n-                            lineno\n+                            lint_start\n                         )\n                         .into());\n                     }\n-                },\n-                None => {\n-                    return Err(format!(\n-                        \"expected lint level in {}:{}, got EOF\",\n-                        path.display(),\n-                        lint_start\n-                    )\n-                    .into());\n                 }\n-            }\n-        };\n-        // The rest of the lint definition is ignored.\n-        assert!(!doc.is_empty());\n-        lints.push(Lint { name, doc, level, path: PathBuf::from(path), lineno: lint_start });\n-    }\n-}\n-\n-/// Extracts the lint name (removing the visibility modifier, and checking validity).\n-fn lint_name(line: &str) -> Result<String, &'static str> {\n-    // Skip over any potential `pub` visibility.\n-    match line.trim().split(' ').next_back() {\n-        Some(name) => {\n-            if !name.ends_with(',') {\n-                return Err(\"lint name should end with comma\");\n-            }\n-            let name = &name[..name.len() - 1];\n-            if !name.chars().all(|ch| ch.is_uppercase() || ch == '_') || name.is_empty() {\n-                return Err(\"lint name did not have expected format\");\n-            }\n-            Ok(name.to_lowercase().to_string())\n+            };\n+            // The rest of the lint definition is ignored.\n+            assert!(!doc.is_empty());\n+            lints.push(Lint { name, doc, level, path: PathBuf::from(path), lineno: lint_start });\n         }\n-        None => Err(\"could not find lint name\"),\n-    }\n-}\n-\n-/// Mutates the lint definition to replace the `{{produces}}` marker with the\n-/// actual output from the compiler.\n-fn generate_output_example(\n-    lint: &mut Lint,\n-    rustc: Rustc<'_>,\n-    verbose: bool,\n-) -> Result<(), Box<dyn Error>> {\n-    // Explicit list of lints that are allowed to not have an example. Please\n-    // try to avoid adding to this list.\n-    if matches!(\n-        lint.name.as_str(),\n-        \"unused_features\" // broken lint\n-        | \"unstable_features\" // deprecated\n-    ) {\n-        return Ok(());\n-    }\n-    if lint.doc_contains(\"[rustdoc book]\") && !lint.doc_contains(\"{{produces}}\") {\n-        // Rustdoc lints are documented in the rustdoc book, don't check these.\n-        return Ok(());\n     }\n-    check_style(lint)?;\n-    // Unfortunately some lints have extra requirements that this simple test\n-    // setup can't handle (like extern crates). An alternative is to use a\n-    // separate test suite, and use an include mechanism such as mdbook's\n-    // `{{#rustdoc_include}}`.\n-    if !lint.is_ignored() {\n-        replace_produces(lint, rustc, verbose)?;\n-    }\n-    Ok(())\n-}\n \n-/// Checks the doc style of the lint.\n-fn check_style(lint: &Lint) -> Result<(), Box<dyn Error>> {\n-    for &expected in &[\"### Example\", \"### Explanation\", \"{{produces}}\"] {\n-        if expected == \"{{produces}}\" && lint.is_ignored() {\n-            continue;\n+    /// Mutates the lint definition to replace the `{{produces}}` marker with the\n+    /// actual output from the compiler.\n+    fn generate_output_example(&self, lint: &mut Lint) -> Result<(), Box<dyn Error>> {\n+        // Explicit list of lints that are allowed to not have an example. Please\n+        // try to avoid adding to this list.\n+        if matches!(\n+            lint.name.as_str(),\n+            \"unused_features\" // broken lint\n+            | \"unstable_features\" // deprecated\n+        ) {\n+            return Ok(());\n         }\n-        if !lint.doc_contains(expected) {\n-            return Err(format!(\"lint docs should contain the line `{}`\", expected).into());\n+        if lint.doc_contains(\"[rustdoc book]\") && !lint.doc_contains(\"{{produces}}\") {\n+            // Rustdoc lints are documented in the rustdoc book, don't check these.\n+            return Ok(());\n         }\n-    }\n-    if let Some(first) = lint.doc.first() {\n-        if !first.starts_with(&format!(\"The `{}` lint\", lint.name)) {\n-            return Err(format!(\n-                \"lint docs should start with the text \\\"The `{}` lint\\\" to introduce the lint\",\n-                lint.name\n-            )\n-            .into());\n+        lint.check_style()?;\n+        // Unfortunately some lints have extra requirements that this simple test\n+        // setup can't handle (like extern crates). An alternative is to use a\n+        // separate test suite, and use an include mechanism such as mdbook's\n+        // `{{#rustdoc_include}}`.\n+        if !lint.is_ignored() {\n+            self.replace_produces(lint)?;\n         }\n+        Ok(())\n     }\n-    Ok(())\n-}\n \n-/// Mutates the lint docs to replace the `{{produces}}` marker with the actual\n-/// output from the compiler.\n-fn replace_produces(\n-    lint: &mut Lint,\n-    rustc: Rustc<'_>,\n-    verbose: bool,\n-) -> Result<(), Box<dyn Error>> {\n-    let mut lines = lint.doc.iter_mut();\n-    loop {\n-        // Find start of example.\n-        let options = loop {\n-            match lines.next() {\n-                Some(line) if line.starts_with(\"```rust\") => {\n-                    break line[7..].split(',').collect::<Vec<_>>();\n+    /// Mutates the lint docs to replace the `{{produces}}` marker with the actual\n+    /// output from the compiler.\n+    fn replace_produces(&self, lint: &mut Lint) -> Result<(), Box<dyn Error>> {\n+        let mut lines = lint.doc.iter_mut();\n+        loop {\n+            // Find start of example.\n+            let options = loop {\n+                match lines.next() {\n+                    Some(line) if line.starts_with(\"```rust\") => {\n+                        break line[7..].split(',').collect::<Vec<_>>();\n+                    }\n+                    Some(line) if line.contains(\"{{produces}}\") => {\n+                        return Err(\"lint marker {{{{produces}}}} found, \\\n+                            but expected to immediately follow a rust code block\"\n+                            .into());\n+                    }\n+                    Some(_) => {}\n+                    None => return Ok(()),\n                 }\n-                Some(line) if line.contains(\"{{produces}}\") => {\n-                    return Err(\"lint marker {{{{produces}}}} found, \\\n-                        but expected to immediately follow a rust code block\"\n+            };\n+            // Find the end of example.\n+            let mut example = Vec::new();\n+            loop {\n+                match lines.next() {\n+                    Some(line) if line == \"```\" => break,\n+                    Some(line) => example.push(line),\n+                    None => {\n+                        return Err(format!(\n+                            \"did not find end of example triple ticks ```, docs were:\\n{:?}\",\n+                            lint.doc\n+                        )\n                         .into());\n-                }\n-                Some(_) => {}\n-                None => return Ok(()),\n-            }\n-        };\n-        // Find the end of example.\n-        let mut example = Vec::new();\n-        loop {\n-            match lines.next() {\n-                Some(line) if line == \"```\" => break,\n-                Some(line) => example.push(line),\n-                None => {\n-                    return Err(format!(\n-                        \"did not find end of example triple ticks ```, docs were:\\n{:?}\",\n-                        lint.doc\n-                    )\n-                    .into());\n+                    }\n                 }\n             }\n-        }\n-        // Find the {{produces}} line.\n-        loop {\n-            match lines.next() {\n-                Some(line) if line.is_empty() => {}\n-                Some(line) if line == \"{{produces}}\" => {\n-                    let output =\n-                        generate_lint_output(&lint.name, &example, &options, rustc, verbose)?;\n-                    line.replace_range(\n-                        ..,\n-                        &format!(\n-                            \"This will produce:\\n\\\n-                        \\n\\\n-                        ```text\\n\\\n-                        {}\\\n-                        ```\",\n-                            output\n-                        ),\n-                    );\n-                    break;\n+            // Find the {{produces}} line.\n+            loop {\n+                match lines.next() {\n+                    Some(line) if line.is_empty() => {}\n+                    Some(line) if line == \"{{produces}}\" => {\n+                        let output = self.generate_lint_output(&lint.name, &example, &options)?;\n+                        line.replace_range(\n+                            ..,\n+                            &format!(\n+                                \"This will produce:\\n\\\n+                            \\n\\\n+                            ```text\\n\\\n+                            {}\\\n+                            ```\",\n+                                output\n+                            ),\n+                        );\n+                        break;\n+                    }\n+                    // No {{produces}} after example, find next example.\n+                    Some(_line) => break,\n+                    None => return Ok(()),\n                 }\n-                // No {{produces}} after example, find next example.\n-                Some(_line) => break,\n-                None => return Ok(()),\n             }\n         }\n     }\n-}\n \n-/// Runs the compiler against the example, and extracts the output.\n-fn generate_lint_output(\n-    name: &str,\n-    example: &[&mut String],\n-    options: &[&str],\n-    rustc: Rustc<'_>,\n-    verbose: bool,\n-) -> Result<String, Box<dyn Error>> {\n-    if verbose {\n-        eprintln!(\"compiling lint {}\", name);\n-    }\n-    let tempdir = tempfile::TempDir::new()?;\n-    let tempfile = tempdir.path().join(\"lint_example.rs\");\n-    let mut source = String::new();\n-    let needs_main = !example.iter().any(|line| line.contains(\"fn main\"));\n-    // Remove `# ` prefix for hidden lines.\n-    let unhidden =\n-        example.iter().map(|line| if line.starts_with(\"# \") { &line[2..] } else { line });\n-    let mut lines = unhidden.peekable();\n-    while let Some(line) = lines.peek() {\n-        if line.starts_with(\"#!\") {\n+    /// Runs the compiler against the example, and extracts the output.\n+    fn generate_lint_output(\n+        &self,\n+        name: &str,\n+        example: &[&mut String],\n+        options: &[&str],\n+    ) -> Result<String, Box<dyn Error>> {\n+        if self.verbose {\n+            eprintln!(\"compiling lint {}\", name);\n+        }\n+        let tempdir = tempfile::TempDir::new()?;\n+        let tempfile = tempdir.path().join(\"lint_example.rs\");\n+        let mut source = String::new();\n+        let needs_main = !example.iter().any(|line| line.contains(\"fn main\"));\n+        // Remove `# ` prefix for hidden lines.\n+        let unhidden =\n+            example.iter().map(|line| if line.starts_with(\"# \") { &line[2..] } else { line });\n+        let mut lines = unhidden.peekable();\n+        while let Some(line) = lines.peek() {\n+            if line.starts_with(\"#!\") {\n+                source.push_str(line);\n+                source.push('\\n');\n+                lines.next();\n+            } else {\n+                break;\n+            }\n+        }\n+        if needs_main {\n+            source.push_str(\"fn main() {\\n\");\n+        }\n+        for line in lines {\n             source.push_str(line);\n-            source.push('\\n');\n-            lines.next();\n+            source.push('\\n')\n+        }\n+        if needs_main {\n+            source.push_str(\"}\\n\");\n+        }\n+        fs::write(&tempfile, source)\n+            .map_err(|e| format!(\"failed to write {}: {}\", tempfile.display(), e))?;\n+        let mut cmd = Command::new(self.rustc_path);\n+        if options.contains(&\"edition2015\") {\n+            cmd.arg(\"--edition=2015\");\n         } else {\n-            break;\n+            cmd.arg(\"--edition=2018\");\n+        }\n+        cmd.arg(\"--error-format=json\");\n+        cmd.arg(\"--target\").arg(self.rustc_target);\n+        if options.contains(&\"test\") {\n+            cmd.arg(\"--test\");\n+        }\n+        cmd.arg(\"lint_example.rs\");\n+        cmd.current_dir(tempdir.path());\n+        let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n+        let stderr = std::str::from_utf8(&output.stderr).unwrap();\n+        let msgs = stderr\n+            .lines()\n+            .filter(|line| line.starts_with('{'))\n+            .map(serde_json::from_str)\n+            .collect::<Result<Vec<serde_json::Value>, _>>()?;\n+        match msgs\n+            .iter()\n+            .find(|msg| matches!(&msg[\"code\"][\"code\"], serde_json::Value::String(s) if s==name))\n+        {\n+            Some(msg) => {\n+                let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n+                Ok(rendered.to_string())\n+            }\n+            None => {\n+                match msgs.iter().find(\n+                    |msg| matches!(&msg[\"rendered\"], serde_json::Value::String(s) if s.contains(name)),\n+                ) {\n+                    Some(msg) => {\n+                        let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n+                        Ok(rendered.to_string())\n+                    }\n+                    None => {\n+                        let rendered: Vec<&str> =\n+                            msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n+                        let non_json: Vec<&str> =\n+                            stderr.lines().filter(|line| !line.starts_with('{')).collect();\n+                        Err(format!(\n+                            \"did not find lint `{}` in output of example, got:\\n{}\\n{}\",\n+                            name,\n+                            non_json.join(\"\\n\"),\n+                            rendered.join(\"\\n\")\n+                        )\n+                        .into())\n+                    }\n+                }\n+            }\n         }\n     }\n-    if needs_main {\n-        source.push_str(\"fn main() {\\n\");\n-    }\n-    for line in lines {\n-        source.push_str(line);\n-        source.push('\\n')\n-    }\n-    if needs_main {\n-        source.push_str(\"}\\n\");\n-    }\n-    fs::write(&tempfile, source)\n-        .map_err(|e| format!(\"failed to write {}: {}\", tempfile.display(), e))?;\n-    let mut cmd = Command::new(rustc.path);\n-    if options.contains(&\"edition2015\") {\n-        cmd.arg(\"--edition=2015\");\n-    } else {\n-        cmd.arg(\"--edition=2018\");\n-    }\n-    cmd.arg(\"--error-format=json\");\n-    cmd.arg(\"--target\").arg(rustc.target);\n-    if options.contains(&\"test\") {\n-        cmd.arg(\"--test\");\n+\n+    /// Saves the mdbook lint chapters at the given path.\n+    fn save_lints_markdown(&self, lints: &[Lint]) -> Result<(), Box<dyn Error>> {\n+        self.save_level(lints, Level::Allow, ALLOWED_MD)?;\n+        self.save_level(lints, Level::Warn, WARN_MD)?;\n+        self.save_level(lints, Level::Deny, DENY_MD)?;\n+        Ok(())\n     }\n-    cmd.arg(\"lint_example.rs\");\n-    cmd.current_dir(tempdir.path());\n-    let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n-    let stderr = std::str::from_utf8(&output.stderr).unwrap();\n-    let msgs = stderr\n-        .lines()\n-        .filter(|line| line.starts_with('{'))\n-        .map(serde_json::from_str)\n-        .collect::<Result<Vec<serde_json::Value>, _>>()?;\n-    match msgs\n-        .iter()\n-        .find(|msg| matches!(&msg[\"code\"][\"code\"], serde_json::Value::String(s) if s==name))\n-    {\n-        Some(msg) => {\n-            let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n-            Ok(rendered.to_string())\n+\n+    fn save_level(&self, lints: &[Lint], level: Level, header: &str) -> Result<(), Box<dyn Error>> {\n+        let mut result = String::new();\n+        result.push_str(header);\n+        let mut these_lints: Vec<_> = lints.iter().filter(|lint| lint.level == level).collect();\n+        these_lints.sort_unstable_by_key(|lint| &lint.name);\n+        for lint in &these_lints {\n+            write!(result, \"* [`{}`](#{})\\n\", lint.name, lint.name.replace(\"_\", \"-\")).unwrap();\n         }\n-        None => {\n-            match msgs.iter().find(\n-                |msg| matches!(&msg[\"rendered\"], serde_json::Value::String(s) if s.contains(name)),\n-            ) {\n-                Some(msg) => {\n-                    let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n-                    Ok(rendered.to_string())\n-                }\n-                None => {\n-                    let rendered: Vec<&str> =\n-                        msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n-                    let non_json: Vec<&str> =\n-                        stderr.lines().filter(|line| !line.starts_with('{')).collect();\n-                    Err(format!(\n-                        \"did not find lint `{}` in output of example, got:\\n{}\\n{}\",\n-                        name,\n-                        non_json.join(\"\\n\"),\n-                        rendered.join(\"\\n\")\n-                    )\n-                    .into())\n-                }\n+        result.push('\\n');\n+        for lint in &these_lints {\n+            write!(result, \"## {}\\n\\n\", lint.name.replace(\"_\", \"-\")).unwrap();\n+            for line in &lint.doc {\n+                result.push_str(line);\n+                result.push('\\n');\n+            }\n+            result.push('\\n');\n+        }\n+        let out_path = self.out_path.join(\"listing\").join(level.doc_filename());\n+        // Delete the output because rustbuild uses hard links in its copies.\n+        let _ = fs::remove_file(&out_path);\n+        fs::write(&out_path, result)\n+            .map_err(|e| format!(\"could not write to {}: {}\", out_path.display(), e))?;\n+        Ok(())\n+    }\n+}\n+\n+/// Extracts the lint name (removing the visibility modifier, and checking validity).\n+fn lint_name(line: &str) -> Result<String, &'static str> {\n+    // Skip over any potential `pub` visibility.\n+    match line.trim().split(' ').next_back() {\n+        Some(name) => {\n+            if !name.ends_with(',') {\n+                return Err(\"lint name should end with comma\");\n             }\n+            let name = &name[..name.len() - 1];\n+            if !name.chars().all(|ch| ch.is_uppercase() || ch == '_') || name.is_empty() {\n+                return Err(\"lint name did not have expected format\");\n+            }\n+            Ok(name.to_lowercase().to_string())\n         }\n+        None => Err(\"could not find lint name\"),\n     }\n }\n \n@@ -442,41 +470,3 @@ static DENY_MD: &str = r#\"# Deny-by-default lints\n These lints are all set to the 'deny' level by default.\n \n \"#;\n-\n-/// Saves the mdbook lint chapters at the given path.\n-fn save_lints_markdown(lints: &[Lint], out_dir: &Path) -> Result<(), Box<dyn Error>> {\n-    save_level(lints, Level::Allow, out_dir, ALLOWED_MD)?;\n-    save_level(lints, Level::Warn, out_dir, WARN_MD)?;\n-    save_level(lints, Level::Deny, out_dir, DENY_MD)?;\n-    Ok(())\n-}\n-\n-fn save_level(\n-    lints: &[Lint],\n-    level: Level,\n-    out_dir: &Path,\n-    header: &str,\n-) -> Result<(), Box<dyn Error>> {\n-    let mut result = String::new();\n-    result.push_str(header);\n-    let mut these_lints: Vec<_> = lints.iter().filter(|lint| lint.level == level).collect();\n-    these_lints.sort_unstable_by_key(|lint| &lint.name);\n-    for lint in &these_lints {\n-        write!(result, \"* [`{}`](#{})\\n\", lint.name, lint.name.replace(\"_\", \"-\")).unwrap();\n-    }\n-    result.push('\\n');\n-    for lint in &these_lints {\n-        write!(result, \"## {}\\n\\n\", lint.name.replace(\"_\", \"-\")).unwrap();\n-        for line in &lint.doc {\n-            result.push_str(line);\n-            result.push('\\n');\n-        }\n-        result.push('\\n');\n-    }\n-    let out_path = out_dir.join(level.doc_filename());\n-    // Delete the output because rustbuild uses hard links in its copies.\n-    let _ = fs::remove_file(&out_path);\n-    fs::write(&out_path, result)\n-        .map_err(|e| format!(\"could not write to {}: {}\", out_path.display(), e))?;\n-    Ok(())\n-}"}, {"sha": "9b75ab45fca8763fee0a9287195e1a6ac73f49dc", "filename": "src/tools/lint-docs/src/main.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f17e6487b2315d3cc3826fb8badeb7d4959b3ffd/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs?ref=f17e6487b2315d3cc3826fb8badeb7d4959b3ffd", "patch": "@@ -57,13 +57,12 @@ fn doit() -> Result<(), Box<dyn Error>> {\n     if rustc_target.is_none() {\n         return Err(\"--rustc-target must be specified to the rustc target\".into());\n     }\n-    lint_docs::extract_lint_docs(\n-        &src_path.unwrap(),\n-        &out_path.unwrap(),\n-        lint_docs::Rustc {\n-            path: rustc_path.as_deref().unwrap(),\n-            target: rustc_target.as_deref().unwrap(),\n-        },\n+    let le = lint_docs::LintExtractor {\n+        src_path: &src_path.unwrap(),\n+        out_path: &out_path.unwrap(),\n+        rustc_path: &rustc_path.unwrap(),\n+        rustc_target: &rustc_target.unwrap(),\n         verbose,\n-    )\n+    };\n+    le.extract_lint_docs()\n }"}]}