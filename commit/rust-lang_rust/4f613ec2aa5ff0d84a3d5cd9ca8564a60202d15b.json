{"sha": "4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "node_id": "C_kwDOAAsO6NoAKDRmNjEzZWMyYWE1ZmYwZDg0YTNkNWNkOWNhODU2NGE2MDIwMmQxNWI", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-30T08:01:28Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-30T08:01:28Z"}, "message": "Sync from rust 9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "tree": {"sha": "e0589b9aea3d7cbc69f77580b05f9e449e07256f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0589b9aea3d7cbc69f77580b05f9e449e07256f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "html_url": "https://github.com/rust-lang/rust/commit/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d18a3757dd47746e778cc913adb0ffb4e74373cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d18a3757dd47746e778cc913adb0ffb4e74373cd", "html_url": "https://github.com/rust-lang/rust/commit/d18a3757dd47746e778cc913adb0ffb4e74373cd"}, {"sha": "663b8949b79fd28ed0e96e485ef2ca682bf5802a", "url": "https://api.github.com/repos/rust-lang/rust/commits/663b8949b79fd28ed0e96e485ef2ca682bf5802a", "html_url": "https://github.com/rust-lang/rust/commit/663b8949b79fd28ed0e96e485ef2ca682bf5802a"}], "stats": {"total": 50, "additions": 32, "deletions": 18}, "files": [{"sha": "7f4619b5c940b12f3701ca2aebba46e92808a163", "filename": "src/abi/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "patch": "@@ -24,7 +24,7 @@ pub(super) fn add_arg_comment<'tcx>(\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n     params: &[Value],\n-    arg_abi_mode: PassMode,\n+    arg_abi_mode: &PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n     if !fx.clif_comments.enabled() {"}, {"sha": "96e25d3a8d4c9423ba85eea5de2006e4db2a6cd4", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "patch": "@@ -38,7 +38,7 @@ fn apply_arg_attrs_to_abi_param(mut param: AbiParam, arg_attrs: ArgAttributes) -\n     param\n }\n \n-fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+fn cast_target_to_abi_params(cast: &CastTarget) -> SmallVec<[AbiParam; 2]> {\n     let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n         (0, 0)\n     } else {\n@@ -100,7 +100,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n+            PassMode::Cast(ref cast, pad_i32) => {\n+                assert!(!pad_i32, \"padding support not yet implemented\");\n+                cast_target_to_abi_params(cast)\n+            }\n             PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     // Abi requires aligning struct size to pointer size\n@@ -145,7 +148,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n+            PassMode::Cast(ref cast, _) => {\n+                (None, cast_target_to_abi_params(cast).into_iter().collect())\n+            }\n             PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n                 (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n@@ -160,7 +165,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n pub(super) fn to_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> SmallVec<[Value; 2]> {\n     let (ptr, meta) = arg.force_stack(fx);\n     assert!(meta.is_none());\n@@ -179,7 +184,7 @@ pub(super) fn from_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n     let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n@@ -224,7 +229,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             smallvec![a, b]\n         }\n-        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Cast(ref cast, _) => to_casted_value(fx, arg, cast),\n         PassMode::Indirect { .. } => {\n             if is_owned {\n                 match arg.force_stack(fx) {\n@@ -268,7 +273,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n         local,\n         local_field,\n         &block_params,\n-        arg_abi.mode,\n+        &arg_abi.mode,\n         arg_abi.layout,\n     );\n \n@@ -282,7 +287,9 @@ pub(super) fn cvalue_for_param<'tcx>(\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n-        PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n+        PassMode::Cast(ref cast, _) => {\n+            Some(from_casted_value(fx, &block_params, arg_abi.layout, cast))\n+        }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n             Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))"}, {"sha": "aaa1418767a357680ef3b2cd5b2ad8a2d970c015", "filename": "src/abi/returning.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "patch": "@@ -13,7 +13,7 @@ pub(super) fn codegen_return_param<'tcx>(\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(\n@@ -44,7 +44,7 @@ pub(super) fn codegen_return_param<'tcx>(\n         Some(RETURN_PLACE),\n         None,\n         &ret_param,\n-        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        &fx.fn_abi.as_ref().unwrap().ret.mode,\n         fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n@@ -75,7 +75,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n-        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => (None, None),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => (None, None),\n     };\n \n     let call_inst = f(fx, return_ptr);\n@@ -92,7 +92,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n             ret_place\n                 .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let results =\n                 fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n             let result =\n@@ -131,7 +131,7 @@ pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx);\n             let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);"}, {"sha": "0cbb9f3ec2d80512d6277be4ab8463d07932e2bc", "filename": "src/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n         })\n         .collect::<IndexVec<Local, SsaKind>>();\n \n-    for bb in fx.mir.basic_blocks().iter() {\n+    for bb in fx.mir.basic_blocks.iter() {\n         for stmt in bb.statements.iter() {\n             match &stmt.kind {\n                 Assign(place_and_rval) => match &place_and_rval.1 {"}, {"sha": "3011813c7035b56ae39bbc80fd1852fbae466154", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     // Predefine blocks\n     let start_block = bcx.create_block();\n     let block_map: IndexVec<BasicBlock, Block> =\n-        (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n+        (0..mir.basic_blocks.len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n     let target_config = module.target_config();\n@@ -271,7 +271,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n     }\n     fx.tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(fx, start_block));\n \n-    for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n+    for (bb, bb_data) in fx.mir.basic_blocks.iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n "}, {"sha": "d2a6b1a5465cb928ecd226356e6f7fa42490a198", "filename": "src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "patch": "@@ -505,7 +505,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                 return None;\n             }\n             let mut computed_const_val = None;\n-            for bb_data in fx.mir.basic_blocks() {\n+            for bb_data in fx.mir.basic_blocks.iter() {\n                 for stmt in &bb_data.statements {\n                     match &stmt.kind {\n                         StatementKind::Assign(local_and_rvalue) if &local_and_rvalue.0 == place => {"}, {"sha": "95239f415a99b5e88c965b37aab3cc860cdf97a3", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=4f613ec2aa5ff0d84a3d5cd9ca8564a60202d15b", "patch": "@@ -577,6 +577,13 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(res, base.layout()));\n         }\n \n+        sym::ptr_mask => {\n+            intrinsic_args!(fx, args => (ptr, mask); intrinsic);\n+            let ptr = ptr.load_scalar(fx);\n+            let mask = mask.load_scalar(fx);\n+            fx.bcx.ins().band(ptr, mask);\n+        }\n+\n         sym::transmute => {\n             intrinsic_args!(fx, args => (from); intrinsic);\n "}]}