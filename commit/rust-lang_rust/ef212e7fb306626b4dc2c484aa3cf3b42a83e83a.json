{"sha": "ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "node_id": "C_kwDOAAsO6NoAKGVmMjEyZTdmYjMwNjYyNmI0ZGMyYzQ4NGFhM2NmM2I0MmE4M2U4M2E", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-10-01T13:05:17Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-10-24T18:33:04Z"}, "message": "Point at overlapping impls when type annotations are needed", "tree": {"sha": "bf69c7d6ae4d297c255d52b2832700e560199eb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf69c7d6ae4d297c255d52b2832700e560199eb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "html_url": "https://github.com/rust-lang/rust/commit/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed08a67566d7d1d9dd2ad928ff21c23e841a4345", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed08a67566d7d1d9dd2ad928ff21c23e841a4345", "html_url": "https://github.com/rust-lang/rust/commit/ed08a67566d7d1d9dd2ad928ff21c23e841a4345"}], "stats": {"total": 707, "additions": 624, "deletions": 83}, "files": [{"sha": "6570d8e15679da6143c74ec0324fe8095f885e6e", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -440,16 +440,28 @@ pub struct DerivedObligationCause<'tcx> {\n \n #[derive(Clone, Debug, TypeFoldable, Lift)]\n pub enum SelectionError<'tcx> {\n+    /// The trait is not implemented.\n     Unimplemented,\n+    /// After a closure impl has selected, its \"outputs\" were evaluated\n+    /// (which for closures includes the \"input\" type params) and they\n+    /// didn't resolve. See `confirm_poly_trait_refs` for more.\n     OutputTypeParameterMismatch(\n         ty::PolyTraitRef<'tcx>,\n         ty::PolyTraitRef<'tcx>,\n         ty::error::TypeError<'tcx>,\n     ),\n+    /// The trait pointed by `DefId` is not object safe.\n     TraitNotObjectSafe(DefId),\n+    /// A given constant couldn't be evaluated.\n     NotConstEvaluatable(NotConstEvaluatable),\n+    /// Exceeded the recursion depth during type projection.\n     Overflow,\n+    /// Signaling that an error has already been emitted, to avoid\n+    /// multiple errors being shown.\n     ErrorReporting,\n+    /// Multiple applicable `impl`s where found. The `DefId`s correspond to\n+    /// all the `impl`s' Items.\n+    Ambiguous(Vec<DefId>),\n }\n \n /// When performing resolution, it is typically the case that there"}, {"sha": "8396e3263f9a469e46cddf878e8b00ba60a54ce8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 152, "deletions": 11, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -34,6 +34,7 @@ use std::iter;\n \n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n+use crate::traits::specialize::to_pretty_impl_header;\n use on_unimplemented::InferCtxtExt as _;\n use suggestions::InferCtxtExt as _;\n \n@@ -241,6 +242,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut span = obligation.cause.span;\n \n         let mut err = match *error {\n+            SelectionError::Ambiguous(ref impls) => {\n+                let mut err = self.tcx.sess.struct_span_err(\n+                    obligation.cause.span,\n+                    &format!(\"multiple applicable `impl`s for `{}`\", obligation.predicate),\n+                );\n+                self.annotate_source_of_ambiguity(&mut err, impls, obligation.predicate);\n+                err.emit();\n+                return;\n+            }\n             SelectionError::Unimplemented => {\n                 // If this obligation was generated as a result of well-formedness checking, see if we\n                 // can get a better error message by performing HIR-based well-formedness checking.\n@@ -1138,6 +1148,13 @@ trait InferCtxtPrivExt<'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n+    fn annotate_source_of_ambiguity(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        impls: &[DefId],\n+        predicate: ty::Predicate<'tcx>,\n+    );\n+\n     fn maybe_suggest_unsized_generics(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -1549,11 +1566,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ?predicate, ?obligation.cause.code,\n         );\n \n-        // Ambiguity errors are often caused as fallout from earlier\n-        // errors. So just ignore them if this infcx is tainted.\n-        if self.is_tainted_by_errors() {\n-            return;\n-        }\n+        // Ambiguity errors are often caused as fallout from earlier errors.\n+        // We ignore them if this `infcx` is tainted in some cases below.\n \n         let bound_predicate = predicate.kind();\n         let mut err = match bound_predicate.skip_binder() {\n@@ -1601,10 +1615,19 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // check upstream for type errors and don't add the obligations to\n                 // begin with in those cases.\n                 if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n-                    self.emit_inference_failure_err(body_id, span, subst, vec![], ErrorCode::E0282)\n+                    if !self.is_tainted_by_errors() {\n+                        self.emit_inference_failure_err(\n+                            body_id,\n+                            span,\n+                            subst,\n+                            vec![],\n+                            ErrorCode::E0282,\n+                        )\n                         .emit();\n+                    }\n                     return;\n                 }\n+\n                 let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n                 let mut err = self.emit_inference_failure_err(\n                     body_id,\n@@ -1613,7 +1636,29 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     impl_candidates,\n                     ErrorCode::E0283,\n                 );\n-                err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+\n+                let obligation = Obligation::new(\n+                    obligation.cause.clone(),\n+                    obligation.param_env,\n+                    trait_ref.to_poly_trait_predicate(),\n+                );\n+                let mut selcx = SelectionContext::with_query_mode(\n+                    &self,\n+                    crate::traits::TraitQueryMode::Standard,\n+                );\n+                match selcx.select_from_obligation(&obligation) {\n+                    Err(SelectionError::Ambiguous(impls)) if impls.len() > 1 => {\n+                        self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n+                    }\n+                    _ => {\n+                        if self.is_tainted_by_errors() {\n+                            err.cancel();\n+                            return;\n+                        }\n+                        err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+                    }\n+                }\n+\n                 if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n                     self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n                 } else if let (\n@@ -1674,15 +1719,21 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ty::PredicateKind::WellFormed(arg) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n-                if arg.references_error() || self.tcx.sess.has_errors() {\n+                if arg.references_error()\n+                    || self.tcx.sess.has_errors()\n+                    || self.is_tainted_by_errors()\n+                {\n                     return;\n                 }\n \n                 self.emit_inference_failure_err(body_id, span, arg, vec![], ErrorCode::E0282)\n             }\n \n             ty::PredicateKind::Subtype(data) => {\n-                if data.references_error() || self.tcx.sess.has_errors() {\n+                if data.references_error()\n+                    || self.tcx.sess.has_errors()\n+                    || self.is_tainted_by_errors()\n+                {\n                     // no need to overload user in such cases\n                     return;\n                 }\n@@ -1694,7 +1745,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ty::PredicateKind::Projection(data) => {\n                 let self_ty = data.projection_ty.self_ty();\n                 let ty = data.ty;\n-                if predicate.references_error() {\n+                if predicate.references_error() || self.is_tainted_by_errors() {\n                     return;\n                 }\n                 if self_ty.needs_infer() && ty.needs_infer() {\n@@ -1722,7 +1773,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n \n             _ => {\n-                if self.tcx.sess.has_errors() {\n+                if self.tcx.sess.has_errors() || self.is_tainted_by_errors() {\n                     return;\n                 }\n                 let mut err = struct_span_err!(\n@@ -1740,6 +1791,96 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n+    fn annotate_source_of_ambiguity(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        impls: &[DefId],\n+        predicate: ty::Predicate<'tcx>,\n+    ) {\n+        let mut spans = vec![];\n+        let mut crates = vec![];\n+        let mut post = vec![];\n+        for def_id in impls {\n+            match self.tcx.span_of_impl(*def_id) {\n+                Ok(span) => spans.push(self.tcx.sess.source_map().guess_head_span(span)),\n+                Err(name) => {\n+                    crates.push(name);\n+                    if let Some(header) = to_pretty_impl_header(self.tcx, *def_id) {\n+                        post.push(header);\n+                    }\n+                }\n+            }\n+        }\n+        let msg = format!(\"multiple `impl`s satisfying `{}` found\", predicate);\n+        let mut crate_names: Vec<_> = crates.iter().map(|n| format!(\"`{}`\", n)).collect();\n+        crate_names.sort();\n+        crate_names.dedup();\n+        post.sort();\n+        post.dedup();\n+\n+        if self.is_tainted_by_errors()\n+            && crate_names.len() == 1\n+            && crate_names[0] == \"`core`\"\n+            && spans.len() == 0\n+        {\n+            // Avoid complaining about other inference issues for expressions like\n+            // `42 >> 1`, where the types are still `{integer}`, but we want to\n+            // Do we need `trait_ref.skip_binder().self_ty().is_numeric() &&` too?\n+            err.cancel();\n+            return;\n+        }\n+        let post = if post.len() > 4 {\n+            format!(\n+                \":\\n{}\\nand {} more\",\n+                post.iter().map(|p| format!(\"- {}\", p)).take(4).collect::<Vec<_>>().join(\"\\n\"),\n+                post.len() - 4,\n+            )\n+        } else if post.len() > 1 || (post.len() == 1 && post[0].contains(\"\\n\")) {\n+            format!(\":\\n{}\", post.iter().map(|p| format!(\"- {}\", p)).collect::<Vec<_>>().join(\"\\n\"),)\n+        } else if post.len() == 1 {\n+            format!(\": `{}`\", post[0])\n+        } else {\n+            String::new()\n+        };\n+\n+        match (spans.len(), crates.len(), crate_names.len()) {\n+            (0, 0, 0) => {\n+                err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+            }\n+            (0, _, 1) => {\n+                err.note(&format!(\"{} in the `{}` crate{}\", msg, crates[0], post,));\n+            }\n+            (0, _, _) => {\n+                err.note(&format!(\n+                    \"{} in the following crates: {}{}\",\n+                    msg,\n+                    crate_names.join(\", \"),\n+                    post,\n+                ));\n+            }\n+            (_, 0, 0) => {\n+                let span: MultiSpan = spans.into();\n+                err.span_note(span, &msg);\n+            }\n+            (_, 1, 1) => {\n+                let span: MultiSpan = spans.into();\n+                err.span_note(span, &msg);\n+                err.note(\n+                    &format!(\"and another `impl` found in the `{}` crate{}\", crates[0], post,),\n+                );\n+            }\n+            _ => {\n+                let span: MultiSpan = spans.into();\n+                err.span_note(span, &msg);\n+                err.note(&format!(\n+                    \"and more `impl`s found in the following crates: {}{}\",\n+                    crate_names.join(\", \"),\n+                    post,\n+                ));\n+            }\n+        }\n+    }\n+\n     /// Returns `true` if the trait predicate may apply for *some* assignment\n     /// to the type parameters.\n     fn predicate_can_apply("}, {"sha": "b4fd851f456361d5e841a59ad5c1bdfeb2fe3fd2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -299,18 +299,15 @@ fn suggest_restriction(\n                 generics,\n                 trait_ref.without_const().to_predicate(tcx).to_string(),\n             ),\n-            (None, Some((ident, []))) => (\n-                ident.span.shrink_to_hi(),\n-                format!(\": {}\", trait_ref.print_only_trait_path().to_string()),\n-            ),\n-            (_, Some((_, [.., bounds]))) => (\n-                bounds.span().shrink_to_hi(),\n-                format!(\" + {}\", trait_ref.print_only_trait_path().to_string()),\n-            ),\n-            (Some(_), Some((_, []))) => (\n-                generics.span.shrink_to_hi(),\n-                format!(\": {}\", trait_ref.print_only_trait_path().to_string()),\n-            ),\n+            (None, Some((ident, []))) => {\n+                (ident.span.shrink_to_hi(), format!(\": {}\", trait_ref.print_only_trait_path()))\n+            }\n+            (_, Some((_, [.., bounds]))) => {\n+                (bounds.span().shrink_to_hi(), format!(\" + {}\", trait_ref.print_only_trait_path()))\n+            }\n+            (Some(_), Some((_, []))) => {\n+                (generics.span.shrink_to_hi(), format!(\": {}\", trait_ref.print_only_trait_path()))\n+            }\n         };\n \n         err.span_suggestion_verbose("}, {"sha": "1d0c54f86dea8bef96e9edb4f930df885799f9ad", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -18,7 +18,7 @@ use crate::traits;\n use crate::traits::coherence::Conflict;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{util, SelectionResult};\n-use crate::traits::{ErrorReporting, Overflow, Unimplemented};\n+use crate::traits::{Ambiguous, ErrorReporting, Overflow, Unimplemented};\n \n use super::BuiltinImplConditions;\n use super::IntercrateAmbiguityCause;\n@@ -197,7 +197,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // and report ambiguity.\n                     if i > 1 {\n                         debug!(\"multiple matches, ambig\");\n-                        return Ok(None);\n+                        return Err(Ambiguous(\n+                            candidates\n+                                .into_iter()\n+                                .filter_map(|c| match c.candidate {\n+                                    SelectionCandidate::ImplCandidate(def_id) => Some(def_id),\n+                                    _ => None,\n+                                })\n+                                .collect(),\n+                        ));\n                     }\n                 }\n             }"}, {"sha": "1b26e38fe0e4d437b0f5245d16949e8c6c72fc87", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -357,18 +357,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> SelectionResult<'tcx, Selection<'tcx>> {\n-        debug_assert!(!obligation.predicate.has_escaping_bound_vars());\n-\n-        let pec = &ProvisionalEvaluationCache::default();\n-        let stack = self.push_stack(TraitObligationStackList::empty(pec), obligation);\n-\n-        let candidate = match self.candidate_from_obligation(&stack) {\n+        let candidate = match self.select_from_obligation(obligation) {\n             Err(SelectionError::Overflow) => {\n                 // In standard mode, overflow must have been caught and reported\n                 // earlier.\n                 assert!(self.query_mode == TraitQueryMode::Canonical);\n                 return Err(SelectionError::Overflow);\n             }\n+            Err(SelectionError::Ambiguous(_)) => {\n+                return Ok(None);\n+            }\n             Err(e) => {\n                 return Err(e);\n             }\n@@ -391,6 +389,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    crate fn select_from_obligation(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        debug_assert!(!obligation.predicate.has_escaping_bound_vars());\n+\n+        let pec = &ProvisionalEvaluationCache::default();\n+        let stack = self.push_stack(TraitObligationStackList::empty(pec), obligation);\n+\n+        self.candidate_from_obligation(&stack)\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n@@ -915,6 +925,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n+            Err(SelectionError::Ambiguous(_)) => Ok(EvaluatedToAmbig),\n             Ok(None) => Ok(EvaluatedToAmbig),\n             Err(Overflow) => Err(OverflowError::Canonical),\n             Err(ErrorReporting) => Err(OverflowError::ErrorReporting),"}, {"sha": "f9867f0671e59fbd7478629fcd114f4dfea652de", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -464,7 +464,7 @@ fn report_conflicting_impls(\n \n /// Recovers the \"impl X for Y\" signature from `impl_def_id` and returns it as a\n /// string.\n-fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n+crate fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n     use std::fmt::Write;\n \n     let trait_ref = tcx.impl_trait_ref(impl_def_id)?;"}, {"sha": "ad65a0ba62a8cc8b0372214abbc2da99f575a96c", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -185,9 +185,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 debug!(\"coerce: unsize not object safe\");\n                 return Err(TypeError::ObjectUnsafeCoercion(did));\n             }\n-            Err(_) => {}\n+            Err(error) => {\n+                debug!(?error, \"coerce: unsize failed\");\n+            }\n         }\n-        debug!(\"coerce: unsize failed\");\n \n         // Examine the supertype and consider auto-borrowing.\n         match *b.kind() {"}, {"sha": "affc58b84d46ded6d232956c3f530359c979c0c0", "filename": "src/test/ui/coherence/coherence-overlap-trait-alias.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -4,7 +4,14 @@ error[E0283]: type annotations needed\n LL | impl C for u32 {}\n    |      ^ cannot infer type for type `u32`\n    |\n-   = note: cannot satisfy `u32: C`\n+note: multiple `impl`s satisfying `u32: C` found\n+  --> $DIR/coherence-overlap-trait-alias.rs:13:1\n+   |\n+LL | impl<T: AB> C for T {}\n+   | ^^^^^^^^^^^^^^^^^^^\n+LL | #[rustc_strict_coherence]\n+LL | impl C for u32 {}\n+   | ^^^^^^^^^^^^^^\n note: required by a bound in `C`\n   --> $DIR/coherence-overlap-trait-alias.rs:11:1\n    |"}, {"sha": "95437bf11adecf9229393d7e458e5346214b640f", "filename": "src/test/ui/error-codes/E0283.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -21,7 +21,14 @@ LL |     let bar = foo_impl.into() * 1u32;\n    |               this method call resolves to `T`\n    |               help: use the fully qualified path for the potential candidate: `<Impl as Into<u32>>::into(foo_impl)`\n    |\n-   = note: cannot satisfy `Impl: Into<_>`\n+note: multiple `impl`s satisfying `Impl: Into<_>` found\n+  --> $DIR/E0283.rs:17:1\n+   |\n+LL | impl Into<u32> for Impl {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: and another `impl` found in the `core` crate:\n+           - impl<T, U> Into<U> for T\n+             where U: From<T>;\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9610618ca11f65f47880ea724d092bed83d6d31b", "filename": "src/test/ui/impl-trait/equality.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -17,7 +17,7 @@ fn two(x: bool) -> impl Foo {\n     //~| expected `i32`, found `u32`\n }\n \n-fn sum_to(n: u32) -> impl Foo {\n+fn sum_to(n: u32) -> impl Foo { //~ ERROR type annotations needed\n     if n == 0 {\n         0\n     } else {"}, {"sha": "d9819484a96126123a268201d97d08ef87b8e2b9", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -34,7 +34,22 @@ LL |         n + sum_to(n - 1)\n    |\n    = help: the trait `Add<impl Foo>` is not implemented for `u32`\n \n-error: aborting due to 2 previous errors; 1 warning emitted\n+error[E0283]: type annotations needed\n+  --> $DIR/equality.rs:20:22\n+   |\n+LL | fn sum_to(n: u32) -> impl Foo {\n+   |                      ^^^^^^^^ cannot infer type for type `{integer}`\n+   |\n+   = note: multiple `impl`s satisfying `{integer}: ToString` found in the `alloc` crate:\n+           - impl ToString for i8;\n+           - impl ToString for u8;\n+note: required because of the requirements on the impl of `Foo` for `{integer}`\n+  --> $DIR/equality.rs:5:26\n+   |\n+LL | impl<T: Copy + ToString> Foo for T {}\n+   |                          ^^^     ^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n \n-Some errors have detailed explanations: E0277, E0308.\n+Some errors have detailed explanations: E0277, E0283, E0308.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "739847c5cd5405e79143c0d8af9a20347ed22857", "filename": "src/test/ui/inference/issue-71732.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -6,7 +6,10 @@ LL |         .get(&\"key\".into())\n    |          |\n    |          cannot infer type for type parameter `Q` declared on the associated function `get`\n    |\n-   = note: cannot satisfy `String: Borrow<_>`\n+   = note: multiple `impl`s satisfying `String: Borrow<_>` found in the following crates: `alloc`, `core`:\n+           - impl Borrow<str> for String;\n+           - impl<T> Borrow<T> for T\n+             where T: ?Sized;\n \n error: aborting due to previous error\n "}, {"sha": "0077c73474818e181af889ba661ee676e9946eae", "filename": "src/test/ui/inference/issue-72616.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -6,7 +6,11 @@ LL |         if String::from(\"a\") == \"a\".try_into().unwrap() {}\n    |                              |\n    |                              cannot infer type\n    |\n-   = note: cannot satisfy `String: PartialEq<_>`\n+   = note: multiple `impl`s satisfying `String: PartialEq<_>` found in the `alloc` crate:\n+           - impl PartialEq for String;\n+           - impl<'a, 'b> PartialEq<&'a str> for String;\n+           - impl<'a, 'b> PartialEq<Cow<'a, str>> for String;\n+           - impl<'a, 'b> PartialEq<str> for String;\n \n error: aborting due to previous error\n "}, {"sha": "3b011f58b259d798ae98367bffa3d6df956d6c46", "filename": "src/test/ui/issues/issue-29147.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -4,7 +4,13 @@ error[E0283]: type annotations needed\n LL |     let _ = <S5<_>>::xxx;\n    |             ^^^^^^^^^^^^ cannot infer type for struct `S5<_>`\n    |\n-   = note: cannot satisfy `S5<_>: Foo`\n+note: multiple `impl`s satisfying `S5<_>: Foo` found\n+  --> $DIR/issue-29147.rs:17:1\n+   |\n+LL | impl Foo for S5<u32> { fn xxx(&self) {} }\n+   | ^^^^^^^^^^^^^^^^^^^^\n+LL | impl Foo for S5<u64> { fn xxx(&self) {} }\n+   | ^^^^^^^^^^^^^^^^^^^^\n note: required by `Foo::xxx`\n   --> $DIR/issue-29147.rs:10:13\n    |"}, {"sha": "a53aadcfad0240eb41c132986970b597da111c77", "filename": "src/test/ui/issues/issue-69455.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -27,4 +27,5 @@ impl Test<u64> for u64 {\n fn main() {\n     let xs: Vec<u64> = vec![1, 2, 3];\n     println!(\"{}\", 23u64.test(xs.iter().sum())); //~ ERROR: type annotations needed\n+    //~^ ERROR type annotations needed\n }"}, {"sha": "da84a6b52da2bd28e6bdc888aea7619f450943ce", "filename": "src/test/ui/issues/issue-69455.stderr", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -4,6 +4,26 @@ error[E0284]: type annotations needed: cannot satisfy `<u64 as Test<_>>::Output\n LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n    |                          ^^^^ cannot satisfy `<u64 as Test<_>>::Output == _`\n \n-error: aborting due to previous error\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-69455.rs:29:26\n+   |\n+LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n+   |                          ^^^^ cannot infer type for type parameter `Rhs` declared on the trait `Test`\n+   |\n+note: multiple `impl`s satisfying `u64: Test<_>` found\n+  --> $DIR/issue-69455.rs:11:1\n+   |\n+LL | impl Test<u32> for u64 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Test<u64> for u64 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+help: consider specifying the type argument in the method call\n+   |\n+LL |     println!(\"{}\", 23u64.test(xs.iter().sum::<S>()));\n+   |                                            +++++\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0284`.\n+Some errors have detailed explanations: E0283, E0284.\n+For more information about an error, try `rustc --explain E0283`."}, {"sha": "7a76e9ef205ff18c73bf3f1538331d51f1a1d67c", "filename": "src/test/ui/issues/issue-69683.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-69683.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-69683.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69683.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -28,5 +28,6 @@ fn main() {\n     let b: [u8; 3] = [0u8; 3];\n \n     0u16.foo(b); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n     //<u16 as Foo<[(); 3]>>::foo(0u16, b);\n }"}, {"sha": "ecf78e48e0e2af68b276a8b26cc8a8dbece5b730", "filename": "src/test/ui/issues/issue-69683.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-69683.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-69683.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69683.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -4,6 +4,22 @@ error[E0284]: type annotations needed: cannot satisfy `<u8 as Element<_>>::Array\n LL |     0u16.foo(b);\n    |          ^^^ cannot satisfy `<u8 as Element<_>>::Array == [u8; 3]`\n \n-error: aborting due to previous error\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-69683.rs:30:10\n+   |\n+LL |     0u16.foo(b);\n+   |          ^^^ cannot infer type for type parameter `I` declared on the trait `Foo`\n+   |\n+note: multiple `impl`s satisfying `u8: Element<_>` found\n+  --> $DIR/issue-69683.rs:5:1\n+   |\n+LL | impl<T> Element<()> for T {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl<T: Element<S>, S> Element<[S; 3]> for T {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0284`.\n+Some errors have detailed explanations: E0283, E0284.\n+For more information about an error, try `rustc --explain E0283`."}, {"sha": "916a7832c6886e537174f895792a9d166e959f97", "filename": "src/test/ui/issues/issue-72690.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-72690.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-72690.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72690.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -5,10 +5,13 @@ fn no_err() {\n \n fn err() {\n     String::from(\"x\".as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n }\n \n fn arg_pat_closure_err() {\n     |x| String::from(\"x\".as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n+    //~| ERROR type annotations needed\n }\n \n fn local_pat_closure_err() {\n@@ -17,12 +20,14 @@ fn local_pat_closure_err() {\n \n fn err_first_arg_pat() {\n     String::from(\"x\".as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n     |x: String| x;\n }\n \n fn err_second_arg_pat() {\n     |x: String| x;\n     String::from(\"x\".as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n }\n \n fn err_mid_arg_pat() {\n@@ -31,6 +36,7 @@ fn err_mid_arg_pat() {\n     |x: String| x;\n     |x: String| x;\n     String::from(\"x\".as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n     |x: String| x;\n     |x: String| x;\n     |x: String| x;\n@@ -39,12 +45,14 @@ fn err_mid_arg_pat() {\n \n fn err_first_local_pat() {\n     String::from(\"x\".as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n     let _ = String::from(\"x\");\n }\n \n fn err_second_local_pat() {\n     let _ = String::from(\"x\");\n     String::from(\"x\".as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n }\n \n fn err_mid_local_pat() {\n@@ -53,6 +61,7 @@ fn err_mid_local_pat() {\n     let _ = String::from(\"x\");\n     let _ = String::from(\"x\");\n     String::from(\"x\".as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n     let _ = String::from(\"x\");\n     let _ = String::from(\"x\");\n     let _ = String::from(\"x\");"}, {"sha": "1747ca5bb04b89c15ac765404186f42f942cbfdd", "filename": "src/test/ui/issues/issue-72690.stderr", "status": "modified", "additions": 170, "deletions": 17, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-72690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fissues%2Fissue-72690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72690.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -4,108 +4,261 @@ error[E0283]: type annotations needed\n LL |     String::from(\"x\".as_ref());\n    |     ^^^^^^^^^^^^ cannot infer type for reference `&_`\n    |\n-   = note: cannot satisfy `String: From<&_>`\n+   = note: multiple `impl`s satisfying `String: From<&_>` found in the `alloc` crate:\n+           - impl<> From<&String> for String;\n+           - impl<> From<&str> for String;\n note: required by `from`\n   --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n    |\n LL |     fn from(_: T) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:7:22\n+   |\n+LL |     String::from(\"x\".as_ref());\n+   |                  ----^^^^^^--\n+   |                  |   |\n+   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |                  this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n+\n error[E0282]: type annotations needed\n-  --> $DIR/issue-72690.rs:11:6\n+  --> $DIR/issue-72690.rs:12:6\n    |\n LL |     |x| String::from(\"x\".as_ref());\n    |      ^ consider giving this closure parameter a type\n \n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:12:9\n+   |\n+LL |     |x| String::from(\"x\".as_ref());\n+   |         ^^^^^^^^^^^^ cannot infer type for reference `&_`\n+   |\n+   = note: multiple `impl`s satisfying `String: From<&_>` found in the `alloc` crate:\n+           - impl<> From<&String> for String;\n+           - impl<> From<&str> for String;\n+note: required by `from`\n+  --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+   |\n+LL |     fn from(_: T) -> Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:12:26\n+   |\n+LL |     |x| String::from(\"x\".as_ref());\n+   |                      ----^^^^^^--\n+   |                      |   |\n+   |                      |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |                      this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n+\n error[E0283]: type annotations needed for `&T`\n-  --> $DIR/issue-72690.rs:15:17\n+  --> $DIR/issue-72690.rs:18:17\n    |\n LL |     let _ = \"x\".as_ref();\n    |         -       ^^^^^^ cannot infer type for type parameter `T` declared on the trait `AsRef`\n    |         |\n    |         consider giving this pattern the explicit type `&T`, where the type parameter `T` is specified\n    |\n-   = note: cannot satisfy `str: AsRef<_>`\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-72690.rs:19:5\n+  --> $DIR/issue-72690.rs:22:5\n    |\n LL |     String::from(\"x\".as_ref());\n    |     ^^^^^^^^^^^^ cannot infer type for reference `&_`\n    |\n-   = note: cannot satisfy `String: From<&_>`\n+   = note: multiple `impl`s satisfying `String: From<&_>` found in the `alloc` crate:\n+           - impl<> From<&String> for String;\n+           - impl<> From<&str> for String;\n note: required by `from`\n   --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n    |\n LL |     fn from(_: T) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-72690.rs:25:5\n+  --> $DIR/issue-72690.rs:22:22\n+   |\n+LL |     String::from(\"x\".as_ref());\n+   |                  ----^^^^^^--\n+   |                  |   |\n+   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |                  this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:29:5\n    |\n LL |     String::from(\"x\".as_ref());\n    |     ^^^^^^^^^^^^ cannot infer type for reference `&_`\n    |\n-   = note: cannot satisfy `String: From<&_>`\n+   = note: multiple `impl`s satisfying `String: From<&_>` found in the `alloc` crate:\n+           - impl<> From<&String> for String;\n+           - impl<> From<&str> for String;\n note: required by `from`\n   --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n    |\n LL |     fn from(_: T) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-72690.rs:33:5\n+  --> $DIR/issue-72690.rs:29:22\n+   |\n+LL |     String::from(\"x\".as_ref());\n+   |                  ----^^^^^^--\n+   |                  |   |\n+   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |                  this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:38:5\n    |\n LL |     String::from(\"x\".as_ref());\n    |     ^^^^^^^^^^^^ cannot infer type for reference `&_`\n    |\n-   = note: cannot satisfy `String: From<&_>`\n+   = note: multiple `impl`s satisfying `String: From<&_>` found in the `alloc` crate:\n+           - impl<> From<&String> for String;\n+           - impl<> From<&str> for String;\n note: required by `from`\n   --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n    |\n LL |     fn from(_: T) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-72690.rs:41:5\n+  --> $DIR/issue-72690.rs:38:22\n+   |\n+LL |     String::from(\"x\".as_ref());\n+   |                  ----^^^^^^--\n+   |                  |   |\n+   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |                  this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:47:5\n    |\n LL |     String::from(\"x\".as_ref());\n    |     ^^^^^^^^^^^^ cannot infer type for reference `&_`\n    |\n-   = note: cannot satisfy `String: From<&_>`\n+   = note: multiple `impl`s satisfying `String: From<&_>` found in the `alloc` crate:\n+           - impl<> From<&String> for String;\n+           - impl<> From<&str> for String;\n note: required by `from`\n   --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n    |\n LL |     fn from(_: T) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-72690.rs:47:5\n+  --> $DIR/issue-72690.rs:47:22\n+   |\n+LL |     String::from(\"x\".as_ref());\n+   |                  ----^^^^^^--\n+   |                  |   |\n+   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |                  this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:54:5\n    |\n LL |     String::from(\"x\".as_ref());\n    |     ^^^^^^^^^^^^ cannot infer type for reference `&_`\n    |\n-   = note: cannot satisfy `String: From<&_>`\n+   = note: multiple `impl`s satisfying `String: From<&_>` found in the `alloc` crate:\n+           - impl<> From<&String> for String;\n+           - impl<> From<&str> for String;\n note: required by `from`\n   --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n    |\n LL |     fn from(_: T) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-72690.rs:55:5\n+  --> $DIR/issue-72690.rs:54:22\n+   |\n+LL |     String::from(\"x\".as_ref());\n+   |                  ----^^^^^^--\n+   |                  |   |\n+   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |                  this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:63:5\n    |\n LL |     String::from(\"x\".as_ref());\n    |     ^^^^^^^^^^^^ cannot infer type for reference `&_`\n    |\n-   = note: cannot satisfy `String: From<&_>`\n+   = note: multiple `impl`s satisfying `String: From<&_>` found in the `alloc` crate:\n+           - impl<> From<&String> for String;\n+           - impl<> From<&str> for String;\n note: required by `from`\n   --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n    |\n LL |     fn from(_: T) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72690.rs:63:22\n+   |\n+LL |     String::from(\"x\".as_ref());\n+   |                  ----^^^^^^--\n+   |                  |   |\n+   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |                  this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n+           - impl AsRef<OsStr> for str;\n+           - impl AsRef<Path> for str;\n+           - impl AsRef<[u8]> for str;\n+           - impl AsRef<str> for str;\n+\n+error: aborting due to 18 previous errors\n \n Some errors have detailed explanations: E0282, E0283.\n For more information about an error, try `rustc --explain E0282`."}, {"sha": "c1cc6cdaf53fa3b4106d0886751de0480102f3d8", "filename": "src/test/ui/marker_trait_attr/region-overlap.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fregion-overlap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fregion-overlap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fregion-overlap.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -4,7 +4,13 @@ error[E0283]: type annotations needed\n LL | impl<'a> A for (&'static (), &'a ()) {}\n    |          ^ cannot infer type for tuple `(&'static (), &'a ())`\n    |\n-   = note: cannot satisfy `(&'static (), &'a ()): A`\n+note: multiple `impl`s satisfying `(&'static (), &'a ()): A` found\n+  --> $DIR/region-overlap.rs:5:1\n+   |\n+LL | impl<'a> A for (&'static (), &'a ()) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl<'a> A for (&'a (), &'static ()) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: required by a bound in `A`\n   --> $DIR/region-overlap.rs:4:1\n    |\n@@ -17,7 +23,13 @@ error[E0283]: type annotations needed\n LL | impl<'a> A for (&'a (), &'static ()) {}\n    |          ^ cannot infer type for tuple `(&'a (), &'static ())`\n    |\n-   = note: cannot satisfy `(&'a (), &'static ()): A`\n+note: multiple `impl`s satisfying `(&'a (), &'static ()): A` found\n+  --> $DIR/region-overlap.rs:5:1\n+   |\n+LL | impl<'a> A for (&'static (), &'a ()) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl<'a> A for (&'a (), &'static ()) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: required by a bound in `A`\n   --> $DIR/region-overlap.rs:4:1\n    |"}, {"sha": "7b2fc34e1af12637ec8d6e77255d58f4119eb9dc", "filename": "src/test/ui/methods/method-ambig-one-trait-unknown-int-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -23,7 +23,7 @@ fn m1() {\n     // we couldn't infer the type of the vector just based on calling foo()...\n     let mut x = Vec::new();\n     //~^ ERROR type annotations needed\n-    x.foo();\n+    x.foo(); //~ ERROR type annotations needed\n }\n \n fn m2() {"}, {"sha": "f33672433dee41c028d158f99d364d79c5d37ca3", "filename": "src/test/ui/methods/method-ambig-one-trait-unknown-int-type.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -6,6 +6,21 @@ LL |     let mut x = Vec::new();\n    |         |\n    |         consider giving `x` the explicit type `Vec<T>`, where the type parameter `T` is specified\n \n+error[E0283]: type annotations needed\n+  --> $DIR/method-ambig-one-trait-unknown-int-type.rs:26:7\n+   |\n+LL |     x.foo();\n+   |       ^^^ cannot infer type for struct `Vec<_>`\n+   |\n+note: multiple `impl`s satisfying `Vec<_>: Foo` found\n+  --> $DIR/method-ambig-one-trait-unknown-int-type.rs:9:1\n+   |\n+LL | impl Foo for Vec<usize> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Foo for Vec<isize> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+\n error[E0308]: mismatched types\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:33:20\n    |\n@@ -19,7 +34,7 @@ help: you can convert an `isize` to a `usize` and panic if the converted value d\n LL |     let y: usize = x.foo().try_into().unwrap();\n    |                           ++++++++++++++++++++\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0282, E0308.\n+Some errors have detailed explanations: E0282, E0283, E0308.\n For more information about an error, try `rustc --explain E0282`."}, {"sha": "f5be6cf21c1cc3dd24a72f1374d7cbfc2900e1a8", "filename": "src/test/ui/traits/issue-77982.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -6,6 +6,7 @@ fn what() {\n     let opt = String::new();\n \n     opts.get(opt.as_ref()); //~ ERROR type annotations needed\n+    //~^ ERROR type annotations needed\n }\n \n fn main() {"}, {"sha": "c45bd76524fddd1c05d309b9585dbf7d9eaa3a18", "filename": "src/test/ui/traits/issue-77982.stderr", "status": "modified", "additions": 53, "deletions": 8, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -6,43 +6,88 @@ LL |     opts.get(opt.as_ref());\n    |          |\n    |          cannot infer type for type parameter `Q` declared on the associated function `get`\n    |\n-   = note: cannot satisfy `String: Borrow<_>`\n+   = note: multiple `impl`s satisfying `String: Borrow<_>` found in the following crates: `alloc`, `core`:\n+           - impl Borrow<str> for String;\n+           - impl<T> Borrow<T> for T\n+             where T: ?Sized;\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-77982.rs:12:44\n+  --> $DIR/issue-77982.rs:8:18\n+   |\n+LL |     opts.get(opt.as_ref());\n+   |              ----^^^^^^--\n+   |              |   |\n+   |              |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n+   |              this method call resolves to `&T`\n+   |\n+   = note: multiple `impl`s satisfying `String: AsRef<_>` found in the following crates: `alloc`, `std`:\n+           - impl AsRef<OsStr> for String;\n+           - impl AsRef<Path> for String;\n+           - impl AsRef<[u8]> for String;\n+           - impl AsRef<str> for String;\n+help: use the fully qualified path for the potential candidates\n+   |\n+LL |     opts.get(<String as AsRef<OsStr>>::as_ref(opt));\n+   |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     opts.get(<String as AsRef<Path>>::as_ref(opt));\n+   |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     opts.get(<String as AsRef<str>>::as_ref(opt));\n+   |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     opts.get(<String as AsRef<[u8]>>::as_ref(opt));\n+   |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-77982.rs:13:44\n    |\n LL |     let ips: Vec<_> = (0..100_000).map(|_| u32::from(0u32.into())).collect();\n    |                                            ^^^^^^^^^ ----------- this method call resolves to `T`\n    |                                            |\n    |                                            cannot infer type for type parameter `T` declared on the trait `From`\n    |\n-   = note: cannot satisfy `u32: From<_>`\n+   = note: multiple `impl`s satisfying `u32: From<_>` found in the following crates: `core`, `std`:\n+           - impl From<Ipv4Addr> for u32;\n+           - impl From<NonZeroU32> for u32;\n+           - impl From<bool> for u32;\n+           - impl From<char> for u32;\n+           and 3 more\n note: required by `from`\n   --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n    |\n LL |     fn from(_: T) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0283]: type annotations needed for `Box<T>`\n-  --> $DIR/issue-77982.rs:35:16\n+  --> $DIR/issue-77982.rs:36:16\n    |\n LL |     let _ = ().foo();\n    |         -      ^^^ cannot infer type for type parameter `T` declared on the trait `Foo`\n    |         |\n    |         consider giving this pattern the explicit type `Box<T>`, where the type parameter `T` is specified\n    |\n-   = note: cannot satisfy `(): Foo<'_, _>`\n+note: multiple `impl`s satisfying `(): Foo<'_, _>` found\n+  --> $DIR/issue-77982.rs:29:1\n+   |\n+LL | impl Foo<'static, u32> for () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl<'a> Foo<'a, i16> for () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0283]: type annotations needed for `Box<T>`\n-  --> $DIR/issue-77982.rs:39:19\n+  --> $DIR/issue-77982.rs:40:19\n    |\n LL |     let _ = (&()).bar();\n    |         -         ^^^ cannot infer type for type parameter `T` declared on the trait `Bar`\n    |         |\n    |         consider giving this pattern the explicit type `Box<T>`, where the type parameter `T` is specified\n    |\n-   = note: cannot satisfy `&(): Bar<'_, _>`\n+note: multiple `impl`s satisfying `&(): Bar<'_, _>` found\n+  --> $DIR/issue-77982.rs:32:1\n+   |\n+LL | impl<'a> Bar<'static, u32> for &'a () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl<'a> Bar<'a, i16> for &'a () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0283`."}, {"sha": "aa74e11c36256d847e0393c64aa4f4ecf274e06d", "filename": "src/test/ui/traits/multidispatch-convert-ambig-dest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -24,7 +24,8 @@ where T : Convert<U>\n \n fn a() {\n     test(22, std::default::Default::default());\n-    //~^ ERROR type annotations needed [E0282]\n+    //~^ ERROR type annotations needed\n+    //~| ERROR type annotations needed\n }\n \n fn main() {}"}, {"sha": "9fd81b56bf153c34ff62aa8ce02ec03769da88b2", "filename": "src/test/ui/traits/multidispatch-convert-ambig-dest.stderr", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -4,6 +4,33 @@ error[E0282]: type annotations needed\n LL |     test(22, std::default::Default::default());\n    |     ^^^^ cannot infer type for type parameter `U` declared on the function `test`\n \n-error: aborting due to previous error\n+error[E0283]: type annotations needed\n+  --> $DIR/multidispatch-convert-ambig-dest.rs:26:5\n+   |\n+LL |     test(22, std::default::Default::default());\n+   |     ^^^^ cannot infer type for type parameter `U` declared on the function `test`\n+   |\n+note: multiple `impl`s satisfying `i32: Convert<_>` found\n+  --> $DIR/multidispatch-convert-ambig-dest.rs:8:1\n+   |\n+LL | impl Convert<i8> for i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Convert<i16> for i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: required by a bound in `test`\n+  --> $DIR/multidispatch-convert-ambig-dest.rs:21:11\n+   |\n+LL | fn test<T,U>(_: T, _: U)\n+   |    ---- required by a bound in this\n+LL | where T : Convert<U>\n+   |           ^^^^^^^^^^ required by this bound in `test`\n+help: consider specifying the type arguments in the function call\n+   |\n+LL |     test::<T, U>(22, std::default::Default::default());\n+   |         ++++++++\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0282`.\n+Some errors have detailed explanations: E0282, E0283.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "d062de25ac8c1d0bb5d3485ba53c12b888640d91", "filename": "src/test/ui/traits/test-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Ftest-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Ftest-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftest-2.rs?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -6,9 +6,9 @@ impl bar for i32 { fn dup(&self) -> i32 { *self } fn blah<X>(&self) {} }\n impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n \n fn main() {\n-    10.dup::<i32>();\n+    10.dup::<i32>(); //~ ERROR type annotations needed\n     //~^ ERROR this associated function takes 0 generic arguments but 1\n-    10.blah::<i32, i32>();\n+    10.blah::<i32, i32>(); //~ ERROR type annotations needed\n     //~^ ERROR this associated function takes 1 generic argument but 2\n     (Box::new(10) as Box<dyn bar>).dup();\n     //~^ ERROR E0038"}, {"sha": "5eec012458450af92fef905ae1913d529728b537", "filename": "src/test/ui/traits/test-2.stderr", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Ftest-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef212e7fb306626b4dc2c484aa3cf3b42a83e83a/src%2Ftest%2Fui%2Ftraits%2Ftest-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftest-2.stderr?ref=ef212e7fb306626b4dc2c484aa3cf3b42a83e83a", "patch": "@@ -79,7 +79,35 @@ LL | trait bar { fn dup(&self) -> Self; fn blah<X>(&self); }\n    = note: required because of the requirements on the impl of `CoerceUnsized<Box<dyn bar>>` for `Box<{integer}>`\n    = note: required by cast to type `Box<dyn bar>`\n \n-error: aborting due to 5 previous errors\n+error[E0283]: type annotations needed\n+  --> $DIR/test-2.rs:9:8\n+   |\n+LL |     10.dup::<i32>();\n+   |        ^^^ cannot infer type for type `{integer}`\n+   |\n+note: multiple `impl`s satisfying `{integer}: bar` found\n+  --> $DIR/test-2.rs:5:1\n+   |\n+LL | impl bar for i32 { fn dup(&self) -> i32 { *self } fn blah<X>(&self) {} }\n+   | ^^^^^^^^^^^^^^^^\n+LL | impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n+   | ^^^^^^^^^^^^^^^^\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/test-2.rs:11:8\n+   |\n+LL |     10.blah::<i32, i32>();\n+   |        ^^^^ cannot infer type for type `{integer}`\n+   |\n+note: multiple `impl`s satisfying `{integer}: bar` found\n+  --> $DIR/test-2.rs:5:1\n+   |\n+LL | impl bar for i32 { fn dup(&self) -> i32 { *self } fn blah<X>(&self) {} }\n+   | ^^^^^^^^^^^^^^^^\n+LL | impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n+   | ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0038, E0107.\n+Some errors have detailed explanations: E0038, E0107, E0283.\n For more information about an error, try `rustc --explain E0038`."}]}