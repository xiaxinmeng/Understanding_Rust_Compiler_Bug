{"sha": "792c645ca7d11a8d254df307d019c5bf01445c37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MmM2NDVjYTdkMTFhOGQyNTRkZjMwN2QwMTljNWJmMDE0NDVjMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-17T20:51:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-17T20:51:59Z"}, "message": "Auto merge of #75145 - davidtwco:issue-60607-preallocate-defid-for-lang-items, r=petrochenkov\n\nReference lang items during AST lowering\n\nFixes #60607 and fixes #61019.\n\nThis PR introduces `QPath::LangItem` to the HIR and uses it in AST lowering instead of constructing a `hir::Path` from a slice of symbols:\n\n- Credit for much of this work goes to @matthewjasper, I basically just [rebased their earlier work](https://github.com/matthewjasper/rust/commit/a227c706b7809ff07021baf3856b7540d5b57f8a#diff-c0f791ead38d2d02916faaad0f56f41d).\n- ~~Changes to Clippy might not be correct, they compile but attempting to run tests through `./x.py` produced failures which appeared spurious, so I didn't run any clippy tests.~~\n- Changes to save analysis might not be correct - tests pass but I don't have a lot of confidence in those changes being correct.\n- I've used `GenericBounds::LangItemTrait` rather than changing `PolyTraitRef`, as suggested by @matthewjasper [in this comment](https://github.com/matthewjasper/rust/commit/a227c706b7809ff07021baf3856b7540d5b57f8a#r40107992) but I'd prefer that be left for a follow-up.\n- I've split things into smaller commits fairly arbitrarily to make the diff easier to review, each commit should compile but might not pass tests until the final commit.\n\nr? @oli-obk\ncc @matthewjasper", "tree": {"sha": "0d3b37228ed6a094e0ac3bd3b3746b4607a498f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d3b37228ed6a094e0ac3bd3b3746b4607a498f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/792c645ca7d11a8d254df307d019c5bf01445c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/792c645ca7d11a8d254df307d019c5bf01445c37", "html_url": "https://github.com/rust-lang/rust/commit/792c645ca7d11a8d254df307d019c5bf01445c37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/792c645ca7d11a8d254df307d019c5bf01445c37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33c96b4d9782cf6364e47cb2c904e66b06c22bb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/33c96b4d9782cf6364e47cb2c904e66b06c22bb4", "html_url": "https://github.com/rust-lang/rust/commit/33c96b4d9782cf6364e47cb2c904e66b06c22bb4"}, {"sha": "f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "html_url": "https://github.com/rust-lang/rust/commit/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e"}], "stats": {"total": 1046, "additions": 588, "deletions": 458}, "files": [{"sha": "fcd07befae50458dcc8661a1a79617394265f500", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -385,6 +385,7 @@ pub trait Into<T>: Sized {\n ))]\n pub trait From<T>: Sized {\n     /// Performs the conversion.\n+    #[cfg_attr(not(bootstrap), lang = \"from\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from(_: T) -> Self;\n }"}, {"sha": "8169c146137c224b4ee8016c69e3e3b76dfd5ee4", "filename": "library/core/src/future/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -96,6 +96,7 @@ pub trait Future {\n     /// [`Context`]: ../task/struct.Context.html\n     /// [`Waker`]: ../task/struct.Waker.html\n     /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n+    #[cfg_attr(not(bootstrap), lang = \"poll\")]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n }"}, {"sha": "d44ef857c133a298e09c7b74e845335b8e9705da", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -53,6 +53,7 @@ unsafe impl Sync for ResumeTy {}\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n // This is `const` to avoid extra errors after we recover from `const async fn`\n+#[cfg_attr(not(bootstrap), lang = \"from_generator\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n@@ -85,6 +86,7 @@ where\n     GenFuture(gen)\n }\n \n+#[cfg_attr(not(bootstrap), lang = \"get_context\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]"}, {"sha": "84c7787a18fd17393d372c721708834ed34fb714", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -235,6 +235,7 @@ pub trait IntoIterator {\n     /// assert_eq!(Some(3), iter.next());\n     /// assert_eq!(None, iter.next());\n     /// ```\n+    #[cfg_attr(not(bootstrap), lang = \"into_iter\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_iter(self) -> Self::IntoIter;\n }"}, {"sha": "81d8f27ec19b04fc2e8cfe27fa72d06b51e72d8a", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -129,6 +129,7 @@ pub trait Iterator {\n     /// assert_eq!(None, iter.next());\n     /// assert_eq!(None, iter.next());\n     /// ```\n+    #[cfg_attr(not(bootstrap), lang = \"next\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n "}, {"sha": "e9ab82b5398496d2996d8355b55090db6e0f33d9", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -38,6 +38,7 @@ use crate::hash::Hash;\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n /// [slicing index]: ../slice/trait.SliceIndex.html\n+#[cfg_attr(not(bootstrap), lang = \"RangeFull\")]\n #[doc(alias = \"..\")]\n #[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -70,6 +71,7 @@ impl fmt::Debug for RangeFull {\n /// assert_eq!(arr[1.. 3], [  1,2    ]);  // Range\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n+#[cfg_attr(not(bootstrap), lang = \"Range\")]\n #[doc(alias = \"..\")]\n #[derive(Clone, Default, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -178,6 +180,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n /// ```\n ///\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n+#[cfg_attr(not(bootstrap), lang = \"RangeFrom\")]\n #[doc(alias = \"..\")]\n #[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -260,6 +263,7 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n /// [slicing index]: ../slice/trait.SliceIndex.html\n+#[cfg_attr(not(bootstrap), lang = \"RangeTo\")]\n #[doc(alias = \"..\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -328,6 +332,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1.. 3], [  1,2    ]);\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n /// ```\n+#[cfg_attr(not(bootstrap), lang = \"RangeInclusive\")]\n #[doc(alias = \"..=\")]\n #[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n@@ -359,6 +364,7 @@ impl<Idx> RangeInclusive<Idx> {\n     ///\n     /// assert_eq!(3..=5, RangeInclusive::new(3, 5));\n     /// ```\n+    #[cfg_attr(not(bootstrap), lang = \"range_inclusive_new\")]\n     #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n     #[inline]\n     #[rustc_promotable]\n@@ -555,6 +561,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n /// [slicing index]: ../slice/trait.SliceIndex.html\n+#[cfg_attr(not(bootstrap), lang = \"RangeToInclusive\")]\n #[doc(alias = \"..=\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]"}, {"sha": "e6b05cc641e35308b4a2e4b119ccb52ae8f46fc6", "filename": "library/core/src/ops/try.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -43,16 +43,19 @@ pub trait Try {\n     /// in the return type of the enclosing scope (which must itself implement\n     /// `Try`). Specifically, the value `X::from_error(From::from(e))`\n     /// is returned, where `X` is the return type of the enclosing function.\n+    #[cfg_attr(not(bootstrap), lang = \"into_result\")]\n     #[unstable(feature = \"try_trait\", issue = \"42327\")]\n     fn into_result(self) -> Result<Self::Ok, Self::Error>;\n \n     /// Wrap an error value to construct the composite result. For example,\n     /// `Result::Err(x)` and `Result::from_error(x)` are equivalent.\n+    #[cfg_attr(not(bootstrap), lang = \"from_error\")]\n     #[unstable(feature = \"try_trait\", issue = \"42327\")]\n     fn from_error(v: Self::Error) -> Self;\n \n     /// Wrap an OK value to construct the composite result. For example,\n     /// `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.\n+    #[cfg_attr(not(bootstrap), lang = \"from_ok\")]\n     #[unstable(feature = \"try_trait\", issue = \"42327\")]\n     fn from_ok(v: Self::Ok) -> Self;\n }"}, {"sha": "b6aa2c6697123ec6562e8fdf6ce5f77b224200e1", "filename": "library/core/src/option.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -144,9 +144,11 @@ use crate::{\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value\n+    #[cfg_attr(not(bootstrap), lang = \"None\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     None,\n     /// Some value `T`\n+    #[cfg_attr(not(bootstrap), lang = \"Some\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n }"}, {"sha": "b63219a440392bce543484660b133655f4c4a564", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -569,6 +569,7 @@ impl<P: Deref> Pin<P> {\n     ///  ```\n     ///\n     /// [`mem::swap`]: ../../std/mem/fn.swap.html\n+    #[cfg_attr(not(bootstrap), lang = \"new_unchecked\")]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {"}, {"sha": "5eddcb2172abe7ac6ba91fffdd2255edf18f4bca", "filename": "library/core/src/result.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -246,10 +246,12 @@ use crate::{convert, fmt};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Result<T, E> {\n     /// Contains the success value\n+    #[cfg_attr(not(bootstrap), lang = \"Ok\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n \n     /// Contains the error value\n+    #[cfg_attr(not(bootstrap), lang = \"Err\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n }"}, {"sha": "fea396d20ff4b8259fa66e6d1a6633ba4d0c8382", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -10,6 +10,7 @@ use crate::result::Result;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready.\n+    #[cfg_attr(not(bootstrap), lang = \"Ready\")]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     Ready(#[stable(feature = \"futures_api\", since = \"1.36.0\")] T),\n \n@@ -18,6 +19,7 @@ pub enum Poll<T> {\n     /// When a function returns `Pending`, the function *must* also\n     /// ensure that the current task is scheduled to be awoken when\n     /// progress can be made.\n+    #[cfg_attr(not(bootstrap), lang = \"Pending\")]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     Pending,\n }"}, {"sha": "65c9cd2e203d18038549203e0c5753a9976cd0b5", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 60, "deletions": 101, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -449,7 +449,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             // `::std::ops::Try::from_ok($tail_expr)`\n             block.expr = Some(this.wrap_in_try_constructor(\n-                sym::from_ok,\n+                hir::LangItem::TryFromOk,\n                 try_span,\n                 tail_expr,\n                 ok_wrapped_span,\n@@ -461,14 +461,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn wrap_in_try_constructor(\n         &mut self,\n-        method: Symbol,\n+        lang_item: hir::LangItem,\n         method_span: Span,\n         expr: &'hir hir::Expr<'hir>,\n         overall_span: Span,\n     ) -> &'hir hir::Expr<'hir> {\n-        let path = &[sym::ops, sym::Try, method];\n         let constructor =\n-            self.arena.alloc(self.expr_std_path(method_span, path, None, ThinVec::new()));\n+            self.arena.alloc(self.expr_lang_item_path(method_span, lang_item, ThinVec::new()));\n         self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n     }\n \n@@ -558,12 +557,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `future::from_generator`:\n         let unstable_span =\n             self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-        let gen_future = self.expr_std_path(\n-            unstable_span,\n-            &[sym::future, sym::from_generator],\n-            None,\n-            ThinVec::new(),\n-        );\n+        let gen_future =\n+            self.expr_lang_item_path(unstable_span, hir::LangItem::FromGenerator, ThinVec::new());\n \n         // `future::from_generator(generator)`:\n         hir::ExprKind::Call(self.arena.alloc(gen_future), arena_vec![self; generator])\n@@ -630,23 +625,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Use of `await` outside of an async context, we cannot use `task_context` here.\n                 self.expr_err(span)\n             };\n-            let pin_ty_id = self.next_id();\n-            let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n-                pin_ty_id,\n+            let new_unchecked = self.expr_call_lang_item_fn_mut(\n                 span,\n-                &[sym::pin, sym::Pin],\n-                \"new_unchecked\",\n+                hir::LangItem::PinNewUnchecked,\n                 arena_vec![self; ref_mut_pinned],\n             );\n-            let new_unchecked = self.expr(span, new_unchecked_expr_kind, ThinVec::new());\n-            let get_context = self.expr_call_std_path_mut(\n+            let get_context = self.expr_call_lang_item_fn_mut(\n                 gen_future_span,\n-                &[sym::future, sym::get_context],\n+                hir::LangItem::GetContext,\n                 arena_vec![self; task_context],\n             );\n-            let call = self.expr_call_std_path(\n+            let call = self.expr_call_lang_item_fn(\n                 span,\n-                &[sym::future, sym::Future, sym::poll],\n+                hir::LangItem::FuturePoll,\n                 arena_vec![self; new_unchecked, get_context],\n             );\n             self.arena.alloc(self.expr_unsafe(call))\n@@ -659,11 +650,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let x_ident = Ident::with_dummy_span(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n             let x_expr = self.expr_ident(span, x_ident, x_pat_hid);\n-            let ready_pat = self.pat_std_enum(\n-                span,\n-                &[sym::task, sym::Poll, sym::Ready],\n-                arena_vec![self; x_pat],\n-            );\n+            let ready_field = self.single_pat_field(span, x_pat);\n+            let ready_pat = self.pat_lang_item_variant(span, hir::LangItem::PollReady, ready_field);\n             let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n@@ -674,7 +662,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `::std::task::Poll::Pending => {}`\n         let pending_arm = {\n-            let pending_pat = self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Pending], &[]);\n+            let pending_pat = self.pat_lang_item_variant(span, hir::LangItem::PollPending, &[]);\n             let empty_block = self.expr_block_empty(span);\n             self.arm(pending_pat, empty_block)\n         };\n@@ -842,16 +830,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n     fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind<'hir> {\n-        let id = self.next_id();\n         let e1 = self.lower_expr_mut(e1);\n         let e2 = self.lower_expr_mut(e2);\n-        self.expr_call_std_assoc_fn(\n-            id,\n-            span,\n-            &[sym::ops, sym::RangeInclusive],\n-            \"new\",\n-            arena_vec![self; e1, e2],\n-        )\n+        let fn_path = hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, span);\n+        let fn_expr =\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+        hir::ExprKind::Call(fn_expr, arena_vec![self; e1, e2])\n     }\n \n     fn lower_expr_range(\n@@ -863,12 +847,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         use rustc_ast::ast::RangeLimits::*;\n \n-        let path = match (e1, e2, lims) {\n-            (None, None, HalfOpen) => sym::RangeFull,\n-            (Some(..), None, HalfOpen) => sym::RangeFrom,\n-            (None, Some(..), HalfOpen) => sym::RangeTo,\n-            (Some(..), Some(..), HalfOpen) => sym::Range,\n-            (None, Some(..), Closed) => sym::RangeToInclusive,\n+        let lang_item = match (e1, e2, lims) {\n+            (None, None, HalfOpen) => hir::LangItem::RangeFull,\n+            (Some(..), None, HalfOpen) => hir::LangItem::RangeFrom,\n+            (None, Some(..), HalfOpen) => hir::LangItem::RangeTo,\n+            (Some(..), Some(..), HalfOpen) => hir::LangItem::Range,\n+            (None, Some(..), Closed) => hir::LangItem::RangeToInclusive,\n             (Some(..), Some(..), Closed) => unreachable!(),\n             (_, None, Closed) => {\n                 self.diagnostic().span_fatal(span, \"inclusive range with no end\").raise()\n@@ -883,16 +867,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }),\n         );\n \n-        let is_unit = fields.is_empty();\n-        let struct_path = [sym::ops, path];\n-        let struct_path = self.std_path(span, &struct_path, None, is_unit);\n-        let struct_path = hir::QPath::Resolved(None, struct_path);\n-\n-        if is_unit {\n-            hir::ExprKind::Path(struct_path)\n-        } else {\n-            hir::ExprKind::Struct(self.arena.alloc(struct_path), fields, None)\n-        }\n+        hir::ExprKind::Struct(self.arena.alloc(hir::QPath::LangItem(lang_item, span)), fields, None)\n     }\n \n     fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n@@ -1412,9 +1387,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let match_expr = {\n             let iter = self.expr_ident(desugared_span, iter, iter_pat_nid);\n             let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n-            let next_path = &[sym::iter, sym::Iterator, sym::next];\n-            let next_expr =\n-                self.expr_call_std_path(desugared_span, next_path, arena_vec![self; ref_mut_iter]);\n+            let next_expr = self.expr_call_lang_item_fn(\n+                desugared_span,\n+                hir::LangItem::IteratorNext,\n+                arena_vec![self; ref_mut_iter],\n+            );\n             let arms = arena_vec![self; pat_arm, break_arm];\n \n             self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n@@ -1472,8 +1449,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n-            let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            self.expr_call_std_path(into_iter_span, into_iter_path, arena_vec![self; head])\n+            self.expr_call_lang_item_fn(\n+                into_iter_span,\n+                hir::LangItem::IntoIterIntoIter,\n+                arena_vec![self; head],\n+            )\n         };\n \n         let match_expr = self.arena.alloc(self.expr_match(\n@@ -1521,8 +1501,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             // expand <expr>\n             let sub_expr = self.lower_expr_mut(sub_expr);\n \n-            let path = &[sym::ops, sym::Try, sym::into_result];\n-            self.expr_call_std_path(unstable_span, path, arena_vec![self; sub_expr])\n+            self.expr_call_lang_item_fn(\n+                unstable_span,\n+                hir::LangItem::TryIntoResult,\n+                arena_vec![self; sub_expr],\n+            )\n         };\n \n         // `#[allow(unreachable_code)]`\n@@ -1558,12 +1541,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let err_ident = Ident::with_dummy_span(sym::err);\n             let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n             let from_expr = {\n-                let from_path = &[sym::convert, sym::From, sym::from];\n                 let err_expr = self.expr_ident_mut(try_span, err_ident, err_local_nid);\n-                self.expr_call_std_path(try_span, from_path, arena_vec![self; err_expr])\n+                self.expr_call_lang_item_fn(\n+                    try_span,\n+                    hir::LangItem::FromFrom,\n+                    arena_vec![self; err_expr],\n+                )\n             };\n-            let from_err_expr =\n-                self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n+            let from_err_expr = self.wrap_in_try_constructor(\n+                hir::LangItem::TryFromError,\n+                unstable_span,\n+                from_expr,\n+                try_span,\n+            );\n             let thin_attrs = ThinVec::from(attrs);\n             let catch_scope = self.catch_scopes.last().copied();\n             let ret_expr = if let Some(catch_node) = catch_scope {\n@@ -1674,63 +1664,32 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.arena.alloc(self.expr_call_mut(span, e, args))\n     }\n \n-    // Note: associated functions must use `expr_call_std_path`.\n-    fn expr_call_std_path_mut(\n+    fn expr_call_lang_item_fn_mut(\n         &mut self,\n         span: Span,\n-        path_components: &[Symbol],\n+        lang_item: hir::LangItem,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n-        let path =\n-            self.arena.alloc(self.expr_std_path(span, path_components, None, ThinVec::new()));\n+        let path = self.arena.alloc(self.expr_lang_item_path(span, lang_item, ThinVec::new()));\n         self.expr_call_mut(span, path, args)\n     }\n \n-    fn expr_call_std_path(\n+    fn expr_call_lang_item_fn(\n         &mut self,\n         span: Span,\n-        path_components: &[Symbol],\n+        lang_item: hir::LangItem,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr_call_std_path_mut(span, path_components, args))\n-    }\n-\n-    // Create an expression calling an associated function of an std type.\n-    //\n-    // Associated functions cannot be resolved through the normal `std_path` function,\n-    // as they are resolved differently and so cannot use `expr_call_std_path`.\n-    //\n-    // This function accepts the path component (`ty_path_components`) separately from\n-    // the name of the associated function (`assoc_fn_name`) in order to facilitate\n-    // separate resolution of the type and creation of a path referring to its associated\n-    // function.\n-    fn expr_call_std_assoc_fn(\n-        &mut self,\n-        ty_path_id: hir::HirId,\n-        span: Span,\n-        ty_path_components: &[Symbol],\n-        assoc_fn_name: &str,\n-        args: &'hir [hir::Expr<'hir>],\n-    ) -> hir::ExprKind<'hir> {\n-        let ty_path = self.std_path(span, ty_path_components, None, false);\n-        let ty =\n-            self.arena.alloc(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n-        let fn_seg = self.arena.alloc(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n-        let fn_path = hir::QPath::TypeRelative(ty, fn_seg);\n-        let fn_expr =\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n-        hir::ExprKind::Call(fn_expr, args)\n+        self.arena.alloc(self.expr_call_lang_item_fn_mut(span, lang_item, args))\n     }\n \n-    fn expr_std_path(\n+    fn expr_lang_item_path(\n         &mut self,\n         span: Span,\n-        components: &[Symbol],\n-        params: Option<&'hir hir::GenericArgs<'hir>>,\n+        lang_item: hir::LangItem,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n-        let path = self.std_path(span, components, params, true);\n-        self.expr(span, hir::ExprKind::Path(hir::QPath::Resolved(None, path)), attrs)\n+        self.expr(span, hir::ExprKind::Path(hir::QPath::LangItem(lang_item, span)), attrs)\n     }\n \n     pub(super) fn expr_ident("}, {"sha": "a2962008a6bd453facf6c28380ba2df4d26af186", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 34, "deletions": 76, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -85,8 +85,6 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n rustc_hir::arena_types!(rustc_arena::declare_arena, [], 'tcx);\n \n struct LoweringContext<'a, 'hir: 'a> {\n-    crate_root: Option<Symbol>,\n-\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n@@ -189,16 +187,6 @@ pub trait ResolverAstLowering {\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n \n-    /// Given suffix `[\"b\", \"c\", \"d\"]`, creates an AST path for `[::crate_root]::b::c::d` and\n-    /// resolves it based on `is_value`.\n-    fn resolve_str_path(\n-        &mut self,\n-        span: Span,\n-        crate_root: Option<Symbol>,\n-        components: &[Symbol],\n-        ns: Namespace,\n-    ) -> (ast::Path, Res<NodeId>);\n-\n     fn lint_buffer(&mut self) -> &mut LintBuffer;\n \n     fn next_node_id(&mut self) -> NodeId;\n@@ -305,7 +293,6 @@ pub fn lower_crate<'a, 'hir>(\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n     LoweringContext {\n-        crate_root: sess.parse_sess.injected_crate_name.get().copied(),\n         sess,\n         resolver,\n         nt_to_tokenstream,\n@@ -2064,23 +2051,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n \n         // \"<Output = T>\"\n-        let future_params = self.arena.alloc(hir::GenericArgs {\n+        let future_args = self.arena.alloc(hir::GenericArgs {\n             args: &[],\n             bindings: arena_vec![self; self.output_ty_binding(span, output_ty)],\n             parenthesized: false,\n         });\n \n-        // ::std::future::Future<future_params>\n-        let future_path =\n-            self.std_path(span, &[sym::future, sym::Future], Some(future_params), false);\n-\n-        hir::GenericBound::Trait(\n-            hir::PolyTraitRef {\n-                trait_ref: hir::TraitRef { path: future_path, hir_ref_id: self.next_id() },\n-                bound_generic_params: &[],\n-                span,\n-            },\n-            hir::TraitBoundModifier::None,\n+        hir::GenericBound::LangItemTrait(\n+            // ::std::future::Future<future_params>\n+            hir::LangItem::FutureTraitLangItem,\n+            span,\n+            self.next_id(),\n+            future_args,\n         )\n     }\n \n@@ -2480,35 +2462,47 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], arena_vec![self; pat])\n+        let field = self.single_pat_field(span, pat);\n+        self.pat_lang_item_variant(span, hir::LangItem::ResultOk, field)\n     }\n \n     fn pat_err(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], arena_vec![self; pat])\n+        let field = self.single_pat_field(span, pat);\n+        self.pat_lang_item_variant(span, hir::LangItem::ResultErr, field)\n     }\n \n     fn pat_some(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], arena_vec![self; pat])\n+        let field = self.single_pat_field(span, pat);\n+        self.pat_lang_item_variant(span, hir::LangItem::OptionSome, field)\n     }\n \n     fn pat_none(&mut self, span: Span) -> &'hir hir::Pat<'hir> {\n-        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], &[])\n+        self.pat_lang_item_variant(span, hir::LangItem::OptionNone, &[])\n     }\n \n-    fn pat_std_enum(\n+    fn single_pat_field(\n         &mut self,\n         span: Span,\n-        components: &[Symbol],\n-        subpats: &'hir [&'hir hir::Pat<'hir>],\n-    ) -> &'hir hir::Pat<'hir> {\n-        let path = self.std_path(span, components, None, true);\n-        let qpath = hir::QPath::Resolved(None, path);\n-        let pt = if subpats.is_empty() {\n-            hir::PatKind::Path(qpath)\n-        } else {\n-            hir::PatKind::TupleStruct(qpath, subpats, None)\n+        pat: &'hir hir::Pat<'hir>,\n+    ) -> &'hir [hir::FieldPat<'hir>] {\n+        let field = hir::FieldPat {\n+            hir_id: self.next_id(),\n+            ident: Ident::new(sym::integer(0), span),\n+            is_shorthand: false,\n+            pat,\n+            span,\n         };\n-        self.pat(span, pt)\n+        arena_vec![self; field]\n+    }\n+\n+    fn pat_lang_item_variant(\n+        &mut self,\n+        span: Span,\n+        lang_item: hir::LangItem,\n+        fields: &'hir [hir::FieldPat<'hir>],\n+    ) -> &'hir hir::Pat<'hir> {\n+        let qpath = hir::QPath::LangItem(lang_item, span);\n+        self.pat(span, hir::PatKind::Struct(qpath, fields, false))\n     }\n \n     fn pat_ident(&mut self, span: Span, ident: Ident) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n@@ -2541,42 +2535,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.arena.alloc(hir::Pat { hir_id: self.next_id(), kind, span })\n     }\n \n-    /// Given a suffix `[\"b\", \"c\", \"d\"]`, returns path `::std::b::c::d` when\n-    /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-    /// The path is also resolved according to `is_value`.\n-    fn std_path(\n-        &mut self,\n-        span: Span,\n-        components: &[Symbol],\n-        params: Option<&'hir hir::GenericArgs<'hir>>,\n-        is_value: bool,\n-    ) -> &'hir hir::Path<'hir> {\n-        let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n-        let (path, res) = self.resolver.resolve_str_path(span, self.crate_root, components, ns);\n-\n-        let mut segments: Vec<_> = path\n-            .segments\n-            .iter()\n-            .map(|segment| {\n-                let res = self.expect_full_res(segment.id);\n-                hir::PathSegment {\n-                    ident: segment.ident,\n-                    hir_id: Some(self.lower_node_id(segment.id)),\n-                    res: Some(self.lower_res(res)),\n-                    infer_args: true,\n-                    args: None,\n-                }\n-            })\n-            .collect();\n-        segments.last_mut().unwrap().args = params;\n-\n-        self.arena.alloc(hir::Path {\n-            span,\n-            res: res.map_id(|_| panic!(\"unexpected `NodeId`\")),\n-            segments: self.arena.alloc_from_iter(segments),\n-        })\n-    }\n-\n     fn ty_path(\n         &mut self,\n         mut hir_id: hir::HirId,"}, {"sha": "bfcb506f1326f46c3fc710baf35fafc1ba058d57", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1,7 +1,7 @@\n use crate::def::{DefKind, Namespace, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n-use crate::itemlikevisit;\n+use crate::{itemlikevisit, LangItem};\n \n use rustc_ast::ast::{self, CrateSugar, LlvmAsmDialect};\n use rustc_ast::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n@@ -13,7 +13,7 @@ use rustc_ast::util::parser::ExprPrecedence;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_macros::HashStable_Generic;\n use rustc_span::def_id::LocalDefId;\n-use rustc_span::source_map::{SourceMap, Spanned};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n@@ -363,6 +363,8 @@ pub enum TraitBoundModifier {\n #[derive(Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n+    // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n+    LangItemTrait(LangItem, Span, HirId, &'hir GenericArgs<'hir>),\n     Outlives(Lifetime),\n }\n \n@@ -377,6 +379,7 @@ impl GenericBound<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n             &GenericBound::Trait(ref t, ..) => t.span,\n+            &GenericBound::LangItemTrait(_, span, ..) => span,\n             &GenericBound::Outlives(ref l) => l.span,\n         }\n     }\n@@ -1419,10 +1422,10 @@ impl Expr<'_> {\n         self.is_place_expr(|_| true)\n     }\n \n-    // Whether this is a place expression.\n-    // `allow_projections_from` should return `true` if indexing a field or\n-    // index expression based on the given expression should be considered a\n-    // place expression.\n+    /// Whether this is a place expression.\n+    ///\n+    /// `allow_projections_from` should return `true` if indexing a field or index expression based\n+    /// on the given expression should be considered a place expression.\n     pub fn is_place_expr(&self, mut allow_projections_from: impl FnMut(&Self) -> bool) -> bool {\n         match self.kind {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => match path.res {\n@@ -1441,6 +1444,9 @@ impl Expr<'_> {\n                 allow_projections_from(base) || base.is_place_expr(allow_projections_from)\n             }\n \n+            // Lang item paths cannot currently be local variables or statics.\n+            ExprKind::Path(QPath::LangItem(..)) => false,\n+\n             // Partially qualified paths in expressions can only legally\n             // refer to associated items which are always rvalues.\n             ExprKind::Path(QPath::TypeRelative(..))\n@@ -1489,58 +1495,28 @@ impl Expr<'_> {\n \n /// Checks if the specified expression is a built-in range literal.\n /// (See: `LoweringContext::lower_expr()`).\n-///\n-/// FIXME(#60607): This function is a hack. If and when we have `QPath::Lang(...)`,\n-/// we can use that instead as simpler, more reliable mechanism, as opposed to using `SourceMap`.\n-pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n-    // Returns whether the given path represents a (desugared) range,\n-    // either in std or core, i.e. has either a `::std::ops::Range` or\n-    // `::core::ops::Range` prefix.\n-    fn is_range_path(path: &Path<'_>) -> bool {\n-        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n-        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n-\n-        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n-        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n-            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n-        } else {\n-            false\n-        }\n-    };\n-\n-    // Check whether a span corresponding to a range expression is a\n-    // range literal, rather than an explicit struct or `new()` call.\n-    fn is_lit(sm: &SourceMap, span: &Span) -> bool {\n-        sm.span_to_snippet(*span).map(|range_src| range_src.contains(\"..\")).unwrap_or(false)\n-    };\n-\n+pub fn is_range_literal(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n-        ExprKind::Struct(ref qpath, _, _) => {\n-            if let QPath::Resolved(None, ref path) = **qpath {\n-                return is_range_path(&path) && is_lit(sm, &expr.span);\n-            }\n-        }\n-\n-        // `..` desugars to its struct path.\n-        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-            return is_range_path(&path) && is_lit(sm, &expr.span);\n-        }\n+        ExprKind::Struct(ref qpath, _, _) => matches!(\n+            **qpath,\n+            QPath::LangItem(\n+                LangItem::Range\n+                | LangItem::RangeTo\n+                | LangItem::RangeFrom\n+                | LangItem::RangeFull\n+                | LangItem::RangeToInclusive,\n+                _,\n+            )\n+        ),\n \n         // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n         ExprKind::Call(ref func, _) => {\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n-                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n-                    let new_call = segment.ident.name == sym::new;\n-                    return is_range_path(&path) && is_lit(sm, &expr.span) && new_call;\n-                }\n-            }\n+            matches!(func.kind, ExprKind::Path(QPath::LangItem(LangItem::RangeInclusiveNew, _)))\n         }\n \n-        _ => {}\n+        _ => false,\n     }\n-\n-    false\n }\n \n #[derive(Debug, HashStable_Generic)]\n@@ -1677,6 +1653,40 @@ pub enum QPath<'hir> {\n     /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n     /// the `X` and `Y` nodes each being a `TyKind::Path(QPath::TypeRelative(..))`.\n     TypeRelative(&'hir Ty<'hir>, &'hir PathSegment<'hir>),\n+\n+    /// Reference to a `#[lang = \"foo\"]` item.\n+    LangItem(LangItem, Span),\n+}\n+\n+impl<'hir> QPath<'hir> {\n+    /// Returns the span of this `QPath`.\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            QPath::Resolved(_, path) => path.span,\n+            QPath::TypeRelative(_, ps) => ps.ident.span,\n+            QPath::LangItem(_, span) => span,\n+        }\n+    }\n+\n+    /// Returns the span of the qself of this `QPath`. For example, `()` in\n+    /// `<() as Trait>::method`.\n+    pub fn qself_span(&self) -> Span {\n+        match *self {\n+            QPath::Resolved(_, path) => path.span,\n+            QPath::TypeRelative(qself, _) => qself.span,\n+            QPath::LangItem(_, span) => span,\n+        }\n+    }\n+\n+    /// Returns the span of the last segment of this `QPath`. For example, `method` in\n+    /// `<() as Trait>::method`.\n+    pub fn last_segment_span(&self) -> Span {\n+        match *self {\n+            QPath::Resolved(_, path) => path.segments.last().unwrap().ident.span,\n+            QPath::TypeRelative(_, segment) => segment.ident.span,\n+            QPath::LangItem(_, span) => span,\n+        }\n+    }\n }\n \n /// Hints at the original code for a let statement."}, {"sha": "66ef017713447938fed8def1c8a2a2354745c3a5", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -724,6 +724,7 @@ pub fn walk_qpath<'v, V: Visitor<'v>>(\n             visitor.visit_ty(qself);\n             visitor.visit_path_segment(span, segment);\n         }\n+        QPath::LangItem(..) => {}\n     }\n }\n \n@@ -838,6 +839,10 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericB\n         GenericBound::Trait(ref typ, modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n+        GenericBound::LangItemTrait(_, span, hir_id, args) => {\n+            visitor.visit_id(hir_id);\n+            visitor.visit_generic_args(span, args);\n+        }\n         GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n     }\n }"}, {"sha": "d6c295f0ddb61b88880a35d63069f7a5149597d3", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -10,7 +10,7 @@\n pub use self::LangItem::*;\n \n use crate::def_id::DefId;\n-use crate::Target;\n+use crate::{MethodKind, Target};\n \n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n@@ -307,4 +307,38 @@ language_item_table! {\n     CountCodeRegionFnLangItem,         sym::count_code_region,         count_code_region_fn,         Target::Fn;\n     CoverageCounterAddFnLangItem,      sym::coverage_counter_add,      coverage_counter_add_fn,      Target::Fn;\n     CoverageCounterSubtractFnLangItem, sym::coverage_counter_subtract, coverage_counter_subtract_fn, Target::Fn;\n+\n+    // Language items from AST lowering\n+    TryFromError,                  sym::from_error,         from_error_fn,           Target::Method(MethodKind::Trait { body: false });\n+    TryFromOk,                     sym::from_ok,            from_ok_fn,              Target::Method(MethodKind::Trait { body: false });\n+    TryIntoResult,                 sym::into_result,        into_result_fn,          Target::Method(MethodKind::Trait { body: false });\n+\n+    PollReady,                     sym::Ready,              poll_ready_variant,      Target::Variant;\n+    PollPending,                   sym::Pending,            poll_pending_variant,    Target::Variant;\n+\n+    FromGenerator,                 sym::from_generator,     from_generator_fn,       Target::Fn;\n+    GetContext,                    sym::get_context,        get_context_fn,          Target::Fn;\n+\n+    FuturePoll,                    sym::poll,               future_poll_fn,          Target::Method(MethodKind::Trait { body: false });\n+\n+    FromFrom,                      sym::from,               from_fn,                 Target::Method(MethodKind::Trait { body: false });\n+\n+    OptionSome,                    sym::Some,               option_some_variant,     Target::Variant;\n+    OptionNone,                    sym::None,               option_none_variant,     Target::Variant;\n+\n+    ResultOk,                      sym::Ok,                 result_ok_variant,       Target::Variant;\n+    ResultErr,                     sym::Err,                result_err_variant,      Target::Variant;\n+\n+    IntoIterIntoIter,              sym::into_iter,          into_iter_fn,            Target::Method(MethodKind::Trait { body: false });\n+    IteratorNext,                  sym::next,               next_fn,                 Target::Method(MethodKind::Trait { body: false});\n+\n+    PinNewUnchecked,               sym::new_unchecked,      new_unchecked_fn,        Target::Method(MethodKind::Inherent);\n+\n+    RangeFrom,                     sym::RangeFrom,           range_from_struct,          Target::Struct;\n+    RangeFull,                     sym::RangeFull,           range_full_struct,          Target::Struct;\n+    RangeInclusiveStruct,          sym::RangeInclusive,      range_inclusive_struct,     Target::Struct;\n+    RangeInclusiveNew,             sym::range_inclusive_new, range_inclusive_new_method, Target::Method(MethodKind::Inherent);\n+    Range,                         sym::Range,               range_struct,               Target::Struct;\n+    RangeToInclusive,              sym::RangeToInclusive,    range_to_inclusive_struct,  Target::Struct;\n+    RangeTo,                       sym::RangeTo,             range_to_struct,            Target::Struct;\n }"}, {"sha": "1efc8bc3124b6ca6919e2073e5dd1ba590e2ee9b", "filename": "src/librustc_hir/target.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Ftarget.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -29,6 +29,7 @@ pub enum Target {\n     TyAlias,\n     OpaqueTy,\n     Enum,\n+    Variant,\n     Struct,\n     Union,\n     Trait,\n@@ -62,6 +63,7 @@ impl Display for Target {\n                 Target::TyAlias => \"type alias\",\n                 Target::OpaqueTy => \"opaque type\",\n                 Target::Enum => \"enum\",\n+                Target::Variant => \"enum variant\",\n                 Target::Struct => \"struct\",\n                 Target::Union => \"union\",\n                 Target::Trait => \"trait\","}, {"sha": "e124db9e355dd4db3abde6d96cca2cea039e9f53", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1729,6 +1729,11 @@ impl<'a> State<'a> {\n                     colons_before_params,\n                 )\n             }\n+            hir::QPath::LangItem(lang_item, span) => {\n+                self.s.word(\"#[lang = \\\"\");\n+                self.print_ident(Ident::new(lang_item.name(), span));\n+                self.s.word(\"\\\"]\");\n+            }\n         }\n     }\n \n@@ -2142,6 +2147,11 @@ impl<'a> State<'a> {\n                     }\n                     self.print_poly_trait_ref(tref);\n                 }\n+                GenericBound::LangItemTrait(lang_item, span, ..) => {\n+                    self.s.word(\"#[lang = \\\"\");\n+                    self.print_ident(Ident::new(lang_item.name(), *span));\n+                    self.s.word(\"\\\"]\");\n+                }\n                 GenericBound::Outlives(lt) => {\n                     self.print_lifetime(lt);\n                 }"}, {"sha": "97830e6c86f39eef373c547ee2515fb35f6c93c0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1057,7 +1057,7 @@ impl TypeAliasBounds {\n                     _ => false,\n                 }\n             }\n-            hir::QPath::Resolved(..) => false,\n+            hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => false,\n         }\n     }\n "}, {"sha": "5b91b77e4f02dc074e42c3ee8767c95dde998110", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -703,7 +703,7 @@ impl<'tcx> LateContext<'tcx> {\n     pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.res,\n-            hir::QPath::TypeRelative(..) => self\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n                 .maybe_typeck_results()\n                 .and_then(|typeck_results| typeck_results.type_dependent_def(id))\n                 .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),"}, {"sha": "a1c9b05a684dd4bc85eead2512a95750d0da0e78", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -258,7 +258,7 @@ fn lint_int_literal<'tcx>(\n         let par_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n             if let hir::ExprKind::Struct(..) = par_e.kind {\n-                if is_range_literal(cx.sess().source_map(), par_e)\n+                if is_range_literal(par_e)\n                     && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t.name_str())\n                 {\n                     // The overflowing literal lint was overridden.\n@@ -317,7 +317,7 @@ fn lint_uint_literal<'tcx>(\n                         return;\n                     }\n                 }\n-                hir::ExprKind::Struct(..) if is_range_literal(cx.sess().source_map(), par_e) => {\n+                hir::ExprKind::Struct(..) if is_range_literal(par_e) => {\n                     let t = t.name_str();\n                     if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n                         // The overflowing literal lint was overridden."}, {"sha": "ede7d85ebb4385a8fcb33f9b6c1296d6d8ced9af", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -452,7 +452,7 @@ impl<'tcx> TypeckResults<'tcx> {\n     pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.res,\n-            hir::QPath::TypeRelative(..) => self\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n                 .type_dependent_def(id)\n                 .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n         }"}, {"sha": "9ec47d2d9ab5c8f324802a3b956f5ca580f91f82", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -30,7 +30,13 @@ struct LanguageItemCollector<'tcx> {\n \n impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.check_for_lang(Target::from_item(item), item.hir_id, item.attrs)\n+        self.check_for_lang(Target::from_item(item), item.hir_id, item.attrs);\n+\n+        if let hir::ItemKind::Enum(def, ..) = &item.kind {\n+            for variant in def.variants {\n+                self.check_for_lang(Target::Variant, variant.id, variant.attrs);\n+            }\n+        }\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {"}, {"sha": "62c8680a8579899f50ae9fe30cee6994a29cc51e", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -526,7 +526,8 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n         | hir::ExprKind::Yield(..)\n         | hir::ExprKind::Type(..)\n         | hir::ExprKind::Err\n-        | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => {\n+        | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n+        | hir::ExprKind::Path(hir::QPath::LangItem(..)) => {\n             intravisit::walk_expr(ir, expr);\n         }\n     }\n@@ -1310,7 +1311,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Lit(..)\n             | hir::ExprKind::Err\n-            | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => succ,\n+            | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n+            | hir::ExprKind::Path(hir::QPath::LangItem(..)) => succ,\n \n             // Note that labels have been resolved, so we don't need to look\n             // at the label ident"}, {"sha": "deb4277cb3854bce0ca3630f5fe831b3e0864266", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1325,7 +1325,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 Res::Def(kind, def_id) => Some((kind, def_id)),\n                 _ => None,\n             },\n-            hir::QPath::TypeRelative(..) => self\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n                 .maybe_typeck_results\n                 .and_then(|typeck_results| typeck_results.type_dependent_def(id)),\n         };\n@@ -1340,7 +1340,9 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 let sess = self.tcx.sess;\n                 let sm = sess.source_map();\n                 let name = match qpath {\n-                    hir::QPath::Resolved(_, path) => sm.span_to_snippet(path.span).ok(),\n+                    hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => {\n+                        sm.span_to_snippet(qpath.span()).ok()\n+                    }\n                     hir::QPath::TypeRelative(_, segment) => Some(segment.ident.to_string()),\n                 };\n                 let kind = kind.descr(def_id);"}, {"sha": "31360d474736a813ea0f448bdbe2b54378e55fe7", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -941,6 +941,24 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_param_bound(&mut self, bound: &'tcx hir::GenericBound<'tcx>) {\n+        match bound {\n+            hir::GenericBound::LangItemTrait { .. } if !self.trait_ref_hack => {\n+                let scope = Scope::Binder {\n+                    lifetimes: FxHashMap::default(),\n+                    s: self.scope,\n+                    next_early_index: self.next_early_index(),\n+                    track_lifetime_uses: true,\n+                    opaque_type_parent: false,\n+                };\n+                self.with(scope, |_, this| {\n+                    intravisit::walk_param_bound(this, bound);\n+                });\n+            }\n+            _ => intravisit::walk_param_bound(self, bound),\n+        }\n+    }\n+\n     fn visit_poly_trait_ref(\n         &mut self,\n         trait_ref: &'tcx hir::PolyTraitRef<'tcx>,\n@@ -2296,6 +2314,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 self.outer_index.shift_out(1);\n             }\n \n+            fn visit_param_bound(&mut self, bound: &hir::GenericBound<'_>) {\n+                if let hir::GenericBound::LangItemTrait { .. } = bound {\n+                    self.outer_index.shift_in(1);\n+                    intravisit::walk_param_bound(self, bound);\n+                    self.outer_index.shift_out(1);\n+                } else {\n+                    intravisit::walk_param_bound(self, bound);\n+                }\n+            }\n+\n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n                 if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n                     match lifetime {"}, {"sha": "32b8ea410ad22c5b837173a379eea1524074df80", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1076,37 +1076,6 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.cstore().item_generics_num_lifetimes(def_id, sess)\n     }\n \n-    fn resolve_str_path(\n-        &mut self,\n-        span: Span,\n-        crate_root: Option<Symbol>,\n-        components: &[Symbol],\n-        ns: Namespace,\n-    ) -> (ast::Path, Res) {\n-        let root = if crate_root.is_some() { kw::PathRoot } else { kw::Crate };\n-        let segments = iter::once(Ident::with_dummy_span(root))\n-            .chain(\n-                crate_root\n-                    .into_iter()\n-                    .chain(components.iter().cloned())\n-                    .map(Ident::with_dummy_span),\n-            )\n-            .map(|i| self.new_ast_path_segment(i))\n-            .collect::<Vec<_>>();\n-\n-        let path = ast::Path { span, segments };\n-\n-        let parent_scope = &ParentScope::module(self.graph_root);\n-        let res = match self.resolve_ast_path(&path, ns, parent_scope) {\n-            Ok(res) => res,\n-            Err((span, error)) => {\n-                self.report_error(span, error);\n-                Res::Err\n-            }\n-        };\n-        (path, res)\n-    }\n-\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n         self.partial_res_map.get(&id).cloned()\n     }"}, {"sha": "6e56e3b9ebb70df1ac4ee287cb2015e8983a2814", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -702,14 +702,18 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n-            let trait_ref = match *super_bound {\n-                hir::GenericBound::Trait(ref trait_ref, _) => trait_ref,\n+            let (def_id, sub_span) = match *super_bound {\n+                hir::GenericBound::Trait(ref trait_ref, _) => (\n+                    self.lookup_def_id(trait_ref.trait_ref.hir_ref_id),\n+                    trait_ref.trait_ref.path.segments.last().unwrap().ident.span,\n+                ),\n+                hir::GenericBound::LangItemTrait(lang_item, span, _, _) => {\n+                    (Some(self.tcx.require_lang_item(lang_item, Some(span))), span)\n+                }\n                 hir::GenericBound::Outlives(..) => continue,\n             };\n \n-            let trait_ref = &trait_ref.trait_ref;\n-            if let Some(id) = self.lookup_def_id(trait_ref.hir_ref_id) {\n-                let sub_span = trait_ref.path.segments.last().unwrap().ident.span;\n+            if let Some(id) = def_id {\n                 if !self.span.filter_generated(sub_span) {\n                     let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {\n@@ -762,11 +766,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     }\n \n     fn process_path(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n-        let span = match path {\n-            hir::QPath::Resolved(_, path) => path.span,\n-            hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n-        };\n-        if self.span.filter_generated(span) {\n+        if self.span.filter_generated(path.span()) {\n             return;\n         }\n         self.dump_path_ref(id, path);\n@@ -783,6 +783,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.visit_ty(ty);\n                 std::slice::from_ref(*segment)\n             }\n+            hir::QPath::LangItem(..) => return,\n         };\n         for seg in segments {\n             if let Some(ref generic_args) = seg.args {\n@@ -1355,10 +1356,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 }\n \n                 if let Some(id) = self.lookup_def_id(t.hir_id) {\n-                    let sub_span = match path {\n-                        hir::QPath::Resolved(_, path) => path.segments.last().unwrap().ident.span,\n-                        hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n-                    };\n+                    let sub_span = path.last_segment_span();\n                     let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {\n                         kind: RefKind::Type,"}, {"sha": "fc8a5384739deea43e7c5b8607ef3c87287f5f41", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -551,28 +551,22 @@ impl<'tcx> SaveContext<'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::Struct(qpath, ..) => {\n-                let segment = match qpath {\n-                    hir::QPath::Resolved(_, path) => path.segments.last().unwrap(),\n-                    hir::QPath::TypeRelative(_, segment) => segment,\n-                };\n-                match ty.kind {\n-                    ty::Adt(def, _) => {\n-                        let sub_span = segment.ident.span;\n-                        filter!(self.span_utils, sub_span);\n-                        let span = self.span_from_span(sub_span);\n-                        Some(Data::RefData(Ref {\n-                            kind: RefKind::Type,\n-                            span,\n-                            ref_id: id_from_def_id(def.did),\n-                        }))\n-                    }\n-                    _ => {\n-                        debug!(\"expected adt, found {:?}\", ty);\n-                        None\n-                    }\n+            hir::ExprKind::Struct(qpath, ..) => match ty.kind {\n+                ty::Adt(def, _) => {\n+                    let sub_span = qpath.last_segment_span();\n+                    filter!(self.span_utils, sub_span);\n+                    let span = self.span_from_span(sub_span);\n+                    Some(Data::RefData(Ref {\n+                        kind: RefKind::Type,\n+                        span,\n+                        ref_id: id_from_def_id(def.did),\n+                    }))\n                 }\n-            }\n+                _ => {\n+                    debug!(\"expected adt, found {:?}\", ty);\n+                    None\n+                }\n+            },\n             hir::ExprKind::MethodCall(ref seg, ..) => {\n                 let method_id = match self.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     Some(id) => id,\n@@ -636,7 +630,7 @@ impl<'tcx> SaveContext<'tcx> {\n             })\n             | Node::Ty(&hir::Ty { kind: hir::TyKind::Path(ref qpath), .. }) => match qpath {\n                 hir::QPath::Resolved(_, path) => path.res,\n-                hir::QPath::TypeRelative(..) => self\n+                hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n                     .maybe_typeck_results\n                     .map_or(Res::Err, |typeck_results| typeck_results.qpath_res(qpath, hir_id)),\n             },\n@@ -653,6 +647,7 @@ impl<'tcx> SaveContext<'tcx> {\n         let segment = match path {\n             hir::QPath::Resolved(_, path) => path.segments.last(),\n             hir::QPath::TypeRelative(_, segment) => Some(*segment),\n+            hir::QPath::LangItem(..) => None,\n         };\n         segment.and_then(|seg| {\n             self.get_path_segment_data(seg).or_else(|| self.get_path_segment_data_with_id(seg, id))"}, {"sha": "f6869cbbfd2aa4545a2e0587db384b5aeac49435", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -286,6 +286,9 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                     refs: vec![SigElement { id, start, end }],\n                 })\n             }\n+            hir::TyKind::Path(hir::QPath::LangItem(lang_item, _)) => {\n+                Ok(text_sig(format!(\"#[lang = \\\"{}\\\"]\", lang_item.name())))\n+            }\n             hir::TyKind::TraitObject(bounds, ..) => {\n                 // FIXME recurse into bounds\n                 let bounds: Vec<hir::GenericBound<'_>> = bounds"}, {"sha": "bc7efd26f467bc3ce9f4751844998e113d253235", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -706,6 +706,7 @@ symbols! {\n         never_type,\n         never_type_fallback,\n         new,\n+        new_unchecked,\n         next,\n         nll,\n         no,\n@@ -828,6 +829,7 @@ symbols! {\n         quad_precision_float,\n         question_mark,\n         quote,\n+        range_inclusive_new,\n         raw_dylib,\n         raw_identifiers,\n         raw_ref_op,"}, {"sha": "5e52a5ef16fb55690cd70e9fe1eb6997f36480ec", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1202,6 +1202,36 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n+    pub fn instantiate_lang_item_trait_ref(\n+        &self,\n+        lang_item: hir::LangItem,\n+        span: Span,\n+        hir_id: hir::HirId,\n+        args: &GenericArgs<'_>,\n+        self_ty: Ty<'tcx>,\n+        bounds: &mut Bounds<'tcx>,\n+    ) {\n+        let trait_def_id = self.tcx().require_lang_item(lang_item, Some(span));\n+\n+        let (substs, assoc_bindings, _) =\n+            self.create_substs_for_ast_path(span, trait_def_id, &[], args, false, Some(self_ty));\n+        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n+        bounds.trait_bounds.push((poly_trait_ref, span, Constness::NotConst));\n+\n+        let mut dup_bindings = FxHashMap::default();\n+        for binding in assoc_bindings {\n+            let _: Result<_, ErrorReported> = self.add_predicates_for_ast_type_binding(\n+                hir_id,\n+                poly_trait_ref,\n+                &binding,\n+                bounds,\n+                false,\n+                &mut dup_bindings,\n+                span,\n+            );\n+        }\n+    }\n+\n     fn ast_path_to_mono_trait_ref(\n         &self,\n         span: Span,\n@@ -1392,6 +1422,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     trait_bounds.push((b, Constness::NotConst))\n                 }\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n+                hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n+                    .instantiate_lang_item_trait_ref(\n+                        lang_item, span, hir_id, args, param_ty, bounds,\n+                    ),\n                 hir::GenericBound::Outlives(ref l) => region_bounds.push(l),\n             }\n         }\n@@ -2960,6 +2994,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .map(|(ty, _, _)| ty)\n                     .unwrap_or_else(|_| tcx.ty_error())\n             }\n+            hir::TyKind::Path(hir::QPath::LangItem(lang_item, span)) => {\n+                let def_id = tcx.require_lang_item(lang_item, Some(span));\n+                let (substs, _, _) = self.create_substs_for_ast_path(\n+                    span,\n+                    def_id,\n+                    &[],\n+                    &GenericArgs::none(),\n+                    true,\n+                    None,\n+                );\n+                self.normalize_ty(span, tcx.at(span).type_of(def_id).subst(tcx, substs))\n+            }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.hir_id);\n                 let length = ty::Const::from_anon_const(tcx, length_def_id);"}, {"sha": "ad97dbe63d8b37f17c9ece84038d9e7f9c6601d9", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -485,7 +485,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // parenthesize if needed (Issue #46756)\n                             hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => true,\n                             // parenthesize borrows of range literals (Issue #54505)\n-                            _ if is_range_literal(self.tcx.sess.source_map(), expr) => true,\n+                            _ if is_range_literal(expr) => true,\n                             _ => false,\n                         };\n                         let sugg_expr = if needs_parens { format!(\"({})\", src) } else { src };"}, {"sha": "e2c90cce178fe01b1a396a1002d7306e7ea8e0a9", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -236,6 +236,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n+            ExprKind::Path(QPath::LangItem(lang_item, _)) => {\n+                self.check_lang_item_path(lang_item, expr)\n+            }\n             ExprKind::Path(ref qpath) => self.check_expr_path(qpath, expr),\n             ExprKind::InlineAsm(asm) => self.check_expr_asm(asm),\n             ExprKind::LlvmInlineAsm(ref asm) => {\n@@ -447,6 +450,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn check_lang_item_path(\n+        &self,\n+        lang_item: hir::LangItem,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Ty<'tcx> {\n+        self.resolve_lang_item_path(lang_item, expr.span, expr.hir_id).1\n+    }\n+\n     fn check_expr_path(&self, qpath: &hir::QPath<'_>, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n@@ -1077,11 +1088,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return self.tcx.ty_error();\n         };\n \n-        let path_span = match *qpath {\n-            QPath::Resolved(_, ref path) => path.span,\n-            QPath::TypeRelative(ref qself, _) => qself.span,\n-        };\n-\n         // Prohibit struct expressions when non-exhaustive flag is set.\n         let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n         if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n@@ -1099,7 +1105,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             adt_ty,\n             expected,\n             expr.hir_id,\n-            path_span,\n+            qpath.span(),\n             variant,\n             fields,\n             base_expr.is_none(),"}, {"sha": "c46d2388f3d93e47582ce3507801d49458e48ca7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -122,10 +122,9 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::subst::{GenericArgKind, UserSelfTy, UserSubsts};\n use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n-use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, Const, GenericParamDefKind, RegionKind, ToPolyTraitRef,\n-    ToPredicate, Ty, TyCtxt, UserType, WithConstness,\n-};\n+use rustc_middle::ty::WithConstness;\n+use rustc_middle::ty::{self, AdtKind, CanonicalUserType, Const, DefIdTree, GenericParamDefKind};\n+use rustc_middle::ty::{RegionKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, UserType};\n use rustc_session::config::{self, EntryFnType};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -4430,10 +4429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         qpath: &QPath<'_>,\n         hir_id: hir::HirId,\n     ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n-        let path_span = match *qpath {\n-            QPath::Resolved(_, ref path) => path.span,\n-            QPath::TypeRelative(ref qself, _) => qself.span,\n-        };\n+        let path_span = qpath.qself_span();\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Res::Err => {\n@@ -4511,9 +4507,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 (result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err), ty)\n             }\n+            QPath::LangItem(lang_item, span) => {\n+                self.resolve_lang_item_path(lang_item, span, hir_id)\n+            }\n         }\n     }\n \n+    fn resolve_lang_item_path(\n+        &self,\n+        lang_item: hir::LangItem,\n+        span: Span,\n+        hir_id: hir::HirId,\n+    ) -> (Res, Ty<'tcx>) {\n+        let def_id = self.tcx.require_lang_item(lang_item, Some(span));\n+        let def_kind = self.tcx.def_kind(def_id);\n+\n+        let item_ty = if let DefKind::Variant = def_kind {\n+            self.tcx.type_of(self.tcx.parent(def_id).expect(\"variant w/out parent\"))\n+        } else {\n+            self.tcx.type_of(def_id)\n+        };\n+        let substs = self.infcx.fresh_substs_for_item(span, def_id);\n+        let ty = item_ty.subst(self.tcx, substs);\n+\n+        self.write_resolution(hir_id, Ok((def_kind, def_id)));\n+        self.add_required_obligations(span, def_id, &substs);\n+        (Res::Def(def_kind, def_id), ty)\n+    }\n+\n     /// Resolves an associated value path into a base type and associated constant, or method\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_res_ufcs<'b>(\n@@ -4532,6 +4553,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n             QPath::TypeRelative(ref qself, ref segment) => (self.to_ty(qself), qself, segment),\n+            QPath::LangItem(..) => bug!(\"`resolve_ty_and_res_ufcs` called on `LangItem`\"),\n         };\n         if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n         {"}, {"sha": "35c7b7a703cc07f4a2ae27f51735eb87afc24f3b", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -947,13 +947,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 //   |\n                 // L |     let A(()) = A(());\n                 //   |          ^  ^\n-                [] => {\n-                    let qpath_span = match qpath {\n-                        hir::QPath::Resolved(_, path) => path.span,\n-                        hir::QPath::TypeRelative(_, ps) => ps.ident.span,\n-                    };\n-                    (qpath_span.shrink_to_hi(), pat_span)\n-                }\n+                [] => (qpath.span().shrink_to_hi(), pat_span),\n                 // Easy case. Just take the \"lo\" of the first sub-pattern and the \"hi\" of the\n                 // last sub-pattern. In the case of `A(x)` the first and last may coincide.\n                 // This looks like:"}, {"sha": "15743b0643662a3c16b14e57f13b9fea35d68063", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1959,6 +1959,20 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                             predicates.extend(bounds.predicates(tcx, ty));\n                         }\n \n+                        &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n+                            let mut bounds = Bounds::default();\n+                            AstConv::instantiate_lang_item_trait_ref(\n+                                &icx,\n+                                lang_item,\n+                                span,\n+                                hir_id,\n+                                args,\n+                                ty,\n+                                &mut bounds,\n+                            );\n+                            predicates.extend(bounds.predicates(tcx, ty));\n+                        }\n+\n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             predicates.push((\n@@ -2108,6 +2122,18 @@ fn predicates_from_bound<'tcx>(\n             let _ = astconv.instantiate_poly_trait_ref(tr, constness, param_ty, &mut bounds);\n             bounds.predicates(astconv.tcx(), param_ty)\n         }\n+        hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n+            let mut bounds = Bounds::default();\n+            astconv.instantiate_lang_item_trait_ref(\n+                lang_item,\n+                span,\n+                hir_id,\n+                args,\n+                param_ty,\n+                &mut bounds,\n+            );\n+            bounds.predicates(astconv.tcx(), param_ty)\n+        }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(param_ty, region))"}, {"sha": "bf385fd79b0f2e4c7f58a30b66ecae890da61118", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -17,6 +17,7 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n+use rustc_middle::bug;\n use rustc_middle::middle::resolve_lifetime as rl;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fold::TypeFolder;\n@@ -291,6 +292,22 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n+            hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n+                let def_id = cx.tcx.require_lang_item(lang_item, Some(span));\n+\n+                let trait_ref = ty::TraitRef::identity(cx.tcx, def_id);\n+\n+                let generic_args = generic_args.clean(cx);\n+                let bindings = match generic_args {\n+                    GenericArgs::AngleBracketed { bindings, .. } => bindings,\n+                    _ => bug!(\"clean: parenthesized `GenericBound::LangItemTrait`\"),\n+                };\n+\n+                GenericBound::TraitBound(\n+                    PolyTrait { trait_: (trait_ref, &*bindings).clean(cx), generic_params: vec![] },\n+                    hir::TraitBoundModifier::None,\n+                )\n+            }\n             hir::GenericBound::Trait(ref t, modifier) => {\n                 GenericBound::TraitBound(t.clean(cx), modifier)\n             }\n@@ -1504,6 +1521,9 @@ impl Clean<Type> for hir::Ty<'_> {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.hir_id),\n                 }\n             }\n+            TyKind::Path(hir::QPath::LangItem(..)) => {\n+                bug!(\"clean: requiring documentation of lang item\")\n+            }\n             TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 match bounds[0].clean(cx).trait_ {\n                     ResolvedPath { path, param_names: None, did, is_generic } => {"}, {"sha": "a502a27948e29f2bad24c68c4b7edd7a3d162cf8", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -335,6 +335,7 @@ pub fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     let segments = match *p {\n         hir::QPath::Resolved(_, ref path) => &path.segments,\n         hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n+        hir::QPath::LangItem(lang_item, ..) => return lang_item.name().to_string(),\n     };\n \n     let mut s = String::new();"}, {"sha": "c26cf5fdb5b050cb5944633f62193d2000eec2a4", "filename": "src/test/ui/hygiene/hir-res-hygiene.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// edition:2018\n+// aux-build:not-libstd.rs\n+\n+// Check that paths created in HIR are not affected by in scope names.\n+\n+extern crate not_libstd as std;\n+\n+async fn the_future() {\n+    async {}.await;\n+}\n+\n+fn main() -> Result<(), ()> {\n+    for i in 0..10 {}\n+    for j in 0..=10 {}\n+    Ok(())?;\n+    Ok(())\n+}"}, {"sha": "11cb72fa2b6f88260fd6ae3042d6917f1cf817ae", "filename": "src/test/ui/range/range-1.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-1.stderr?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -17,9 +17,13 @@ error[E0277]: the size for values of type `[{integer}]` cannot be known at compi\n    |\n LL |     let range = *arr..;\n    |                 ^^^^^^ doesn't have a size known at compile-time\n+   | \n+  ::: $SRC_DIR/core/src/ops/range.rs:LL:COL\n+   |\n+LL | pub struct RangeFrom<Idx> {\n+   |                      --- required by this bound in `std::ops::RangeFrom`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[{integer}]`\n-   = note: required by `std::ops::RangeFrom`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "067ea903bdd96bf77f06820625449835d287f01d", "filename": "src/tools/clippy/clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n                             );\n                          }\n                     },\n-                    QPath::TypeRelative(..) => {},\n+                    QPath::TypeRelative(..) | QPath::LangItem(..) => {},\n                 }\n             }\n         }"}, {"sha": "90b1a529be79dc310e7cd3a35f1129a944e5168e", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(ref array, ref index) = &expr.kind {\n             let ty = cx.typeck_results().expr_ty(array);\n-            if let Some(range) = higher::range(cx, index) {\n+            if let Some(range) = higher::range(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind {\n                     let size: u128 = if let Some(size) = s.try_eval_usize(cx.tcx, cx.param_env) {"}, {"sha": "129abd7d89749342e89da0f41d695ed2732fecbf", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -171,7 +171,7 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 Finite\n             }\n         },\n-        ExprKind::Struct(..) => higher::range(cx, expr).map_or(false, |r| r.end.is_none()).into(),\n+        ExprKind::Struct(..) => higher::range(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }\n }"}, {"sha": "e5daa30f8ca15745759706c41534552cb355d8d8", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -262,7 +262,7 @@ fn check_len(\n fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     /// Special case ranges until `range_is_empty` is stabilized. See issue 3807.\n     fn should_skip_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-        higher::range(cx, expr).map_or(false, |_| {\n+        higher::range(expr).map_or(false, |_| {\n             !cx.tcx\n                 .features()\n                 .declared_lib_features"}, {"sha": "8ffcd417d1df1848e59a035a3480a28b907e38b6", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1003,7 +1003,7 @@ fn detect_manual_memcpy<'tcx>(\n         start: Some(start),\n         end: Some(end),\n         limits,\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n@@ -1177,7 +1177,7 @@ fn check_for_loop_range<'tcx>(\n         start: Some(start),\n         ref end,\n         limits,\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n@@ -1679,7 +1679,7 @@ fn check_for_mut_range_bound(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'\n         start: Some(start),\n         end: Some(end),\n         ..\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n         if mut_ids[0].is_some() || mut_ids[1].is_some() {"}, {"sha": "faa20687ef61f3c938e7853f9783ced3c97552af", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1,7 +1,8 @@\n-use crate::utils::{self, is_type_diagnostic_item, match_type, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{is_type_diagnostic_item, is_type_lang_item, snippet, span_lint_and_sugg};\n+use crate::utils::walk_ptrs_ty;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_hir::{Expr, ExprKind, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -96,5 +97,5 @@ fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n-    match_type(cx, ty, &utils::paths::RANGE_FULL)\n+    is_type_lang_item(cx, ty, LangItem::RangeFull)\n }"}, {"sha": "2265a1888556af0ed9150af0ecb3e97c9a7f2f1b", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -2271,7 +2271,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n         if_chain! {\n             if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n             if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n-                = higher::range(cx, index_expr);\n+                = higher::range(index_expr);\n             if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n             if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n             then {"}, {"sha": "482a563572db270fa63a436879cb4348a3a3f79f", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -433,6 +433,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             return;\n         }\n         let binding = match expr.kind {\n+            ExprKind::Path(hir::QPath::LangItem(..)) => None,\n             ExprKind::Path(ref qpath) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&"}, {"sha": "7a75fc125d0ad0eb42f3c4b8f5f154466eabf41d", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -147,7 +147,7 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n                     if let ExprKind::MethodCall(ref iter_path, _, ref iter_args , _) = *iter;\n                     if iter_path.ident.name == sym!(iter);\n                     // range expression in `.zip()` call: `0..x.len()`\n-                    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n+                    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n                     if is_integer_const(cx, start, 0);\n                     // `.len()` call\n                     if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n@@ -180,7 +180,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             start,\n             end: Some(end),\n             limits: RangeLimits::HalfOpen\n-        }) = higher::range(cx, expr);\n+        }) = higher::range(expr);\n         if let Some(y) = y_plus_one(cx, end);\n         then {\n             let span = if expr.span.from_expansion() {\n@@ -225,7 +225,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n // inclusive range minus one: `x..=(y-1)`\n fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(cx, expr);\n+        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(expr);\n         if let Some(y) = y_minus_one(cx, end);\n         then {\n             span_lint_and_then(\n@@ -279,7 +279,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n \n     if_chain! {\n-        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(cx, expr);\n+        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind;\n         if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);"}, {"sha": "a74104e92820a3ca7288b008edebbd46848ab3ad", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1,10 +1,10 @@\n use crate::utils::{\n-    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet, snippet_with_macro_callsite,\n-    span_lint_and_sugg,\n+    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet,\n+    snippet_with_macro_callsite, span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_hir::{Expr, ExprKind, QPath, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n             if let ExprKind::Match(ref match_arg, _, MatchSource::TryDesugar) = expr.kind;\n             if let ExprKind::Call(ref match_fun, ref try_args) = match_arg.kind;\n             if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n-            if match_qpath(match_fun_path, &paths::TRY_INTO_RESULT);\n+            if matches!(match_fun_path, QPath::LangItem(LangItem::TryIntoResult, _));\n             if let Some(ref try_arg) = try_args.get(0);\n             if let ExprKind::Call(ref err_fun, ref err_args) = try_arg.kind;\n             if let Some(ref err_arg) = err_args.get(0);"}, {"sha": "d1a7886a47effab9afb8831f6cd3c3c5e63e2b6d", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -475,6 +475,7 @@ impl Types {\n                             }\n                         }\n                     },\n+                    QPath::LangItem(..) => {},\n                 }\n             },\n             TyKind::Rptr(ref lt, ref mut_ty) => self.check_ty_rptr(cx, hir_ty, is_local, lt, mut_ty),"}, {"sha": "43166d26787a71258ab4c615e4d641f5b4ed50f1", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_try, match_qpath, match_trait_method, paths, span_lint};\n+use crate::utils::{is_try, match_trait_method, paths, span_lint};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -42,10 +42,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n         match expr.kind {\n             hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n                 if let hir::ExprKind::Call(ref func, ref args) = res.kind {\n-                    if let hir::ExprKind::Path(ref path) = func.kind {\n-                        if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n-                            check_method_call(cx, &args[0], expr);\n-                        }\n+                    if matches!(\n+                        func.kind,\n+                        hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::TryIntoResult, _))\n+                    ) {\n+                        check_method_call(cx, &args[0], expr);\n                     }\n                 } else {\n                     check_method_call(cx, res, expr);"}, {"sha": "9b7a268c6287c1fffd8b2fab131bb2d53bbeb175", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -175,9 +175,19 @@ impl PrintVisitor {\n     }\n \n     fn print_qpath(&mut self, path: &QPath<'_>) {\n-        print!(\"    if match_qpath({}, &[\", self.current);\n-        print_path(path, &mut true);\n-        println!(\"]);\");\n+        match  *path {\n+            QPath::LangItem(lang_item, _) => {\n+                println!(\n+                    \"    if matches!({}, QPath::LangItem(LangItem::{:?}, _));\",\n+                   self.current, lang_item,\n+                );\n+            },\n+            _ => {\n+                print!(\"    if match_qpath({}, &[\", self.current);\n+                print_path(path, &mut true);\n+                println!(\"]);\");\n+            },\n+        }\n     }\n }\n \n@@ -760,5 +770,6 @@ fn print_path(path: &QPath<'_>, first: &mut bool) {\n             },\n             ref other => print!(\"/* unimplemented: {:?}*/\", other),\n         },\n+        QPath::LangItem(..) => panic!(\"print_path: called for lang item qpath\"),\n     }\n }"}, {"sha": "ba15456014d35e730a7876b0077600ec59d13867", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 23, "deletions": 75, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -3,12 +3,11 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{is_expn_of, match_def_path, match_qpath, paths};\n+use crate::utils::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n #[must_use]\n@@ -47,7 +46,7 @@ pub struct Range<'a> {\n }\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n-pub fn range<'a, 'tcx>(cx: &LateContext<'tcx>, expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n+pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n     /// Finds the field named `name` in the field. Always return `Some` for\n     /// convenience.\n     fn get_field<'c>(name: &str, fields: &'c [hir::Field<'_>]) -> Option<&'c hir::Expr<'c>> {\n@@ -56,94 +55,43 @@ pub fn range<'a, 'tcx>(cx: &LateContext<'tcx>, expr: &'a hir::Expr<'_>) -> Optio\n         Some(expr)\n     }\n \n-    let def_path = match cx.typeck_results().expr_ty(expr).kind {\n-        ty::Adt(def, _) => cx.tcx.def_path(def.did),\n-        _ => return None,\n-    };\n-\n-    // sanity checks for std::ops::RangeXXXX\n-    if def_path.data.len() != 3 {\n-        return None;\n-    }\n-    if def_path.data.get(0)?.data.as_symbol() != sym!(ops) {\n-        return None;\n-    }\n-    if def_path.data.get(1)?.data.as_symbol() != sym!(range) {\n-        return None;\n-    }\n-    let type_name = def_path.data.get(2)?.data.as_symbol();\n-    let range_types = [\n-        \"RangeFrom\",\n-        \"RangeFull\",\n-        \"RangeInclusive\",\n-        \"Range\",\n-        \"RangeTo\",\n-        \"RangeToInclusive\",\n-    ];\n-    if !range_types.contains(&&*type_name.as_str()) {\n-        return None;\n-    }\n-\n-    // The range syntax is expanded to literal paths starting with `core` or `std`\n-    // depending on\n-    // `#[no_std]`. Testing both instead of resolving the paths.\n-\n     match expr.kind {\n-        hir::ExprKind::Path(ref path) => {\n-            if match_qpath(path, &paths::RANGE_FULL_STD) || match_qpath(path, &paths::RANGE_FULL) {\n-                Some(Range {\n+        hir::ExprKind::Call(ref path, ref args) if matches!(\n+            path.kind,\n+            hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n+        ) => Some(Range {\n+            start: Some(&args[0]),\n+            end: Some(&args[1]),\n+            limits: ast::RangeLimits::Closed,\n+        }),\n+        hir::ExprKind::Struct(ref path, ref fields, None) => {\n+            match path {\n+                hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n                     start: None,\n                     end: None,\n                     limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n-            }\n-        },\n-        hir::ExprKind::Call(ref path, ref args) => {\n-            if let hir::ExprKind::Path(ref path) = path.kind {\n-                if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW) || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW)\n-                {\n-                    Some(Range {\n-                        start: Some(&args[0]),\n-                        end: Some(&args[1]),\n-                        limits: ast::RangeLimits::Closed,\n-                    })\n-                } else {\n-                    None\n-                }\n-            } else {\n-                None\n-            }\n-        },\n-        hir::ExprKind::Struct(ref path, ref fields, None) => {\n-            if match_qpath(path, &paths::RANGE_FROM_STD) || match_qpath(path, &paths::RANGE_FROM) {\n-                Some(Range {\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n                     start: Some(get_field(\"start\", fields)?),\n                     end: None,\n                     limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_STD) || match_qpath(path, &paths::RANGE) {\n-                Some(Range {\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n                     start: Some(get_field(\"start\", fields)?),\n                     end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_qpath(path, &paths::RANGE_TO_INCLUSIVE)\n-            {\n-                Some(Range {\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n                     start: None,\n                     end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::Closed,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_TO_STD) || match_qpath(path, &paths::RANGE_TO) {\n-                Some(Range {\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n                     start: None,\n                     end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n+                }),\n+                _ => None,\n             }\n         },\n         _ => None,"}, {"sha": "2eefd4a38a67a5056981c2622deaebedc78cc348", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -3,9 +3,9 @@ use crate::utils::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::{\n-    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FnRetTy, GenericArg,\n-    GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path, PathSegment, QPath,\n-    Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat,\n+    FnRetTy, GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName,\n+    Pat, PatKind, Path, PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ich::StableHashingContextProvider;\n@@ -185,10 +185,20 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         left.name == right.name\n     }\n \n+    pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n+        match (&left, &right) {\n+            (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) =>\n+                li.name.as_str() == ri.name.as_str() && self.eq_pat(lp, rp),\n+        }\n+    }\n+\n     /// Checks whether two patterns are the same.\n     pub fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n+            (&PatKind::Struct(ref lp, ref la, ..), &PatKind::Struct(ref rp, ref ra, ..)) => {\n+                self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_fieldpat(l, r))\n+            },\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n@@ -223,6 +233,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n                 self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n             },\n+            (&QPath::LangItem(llang_item, _), &QPath::LangItem(rlang_item, _)) =>\n+                llang_item == rlang_item,\n             _ => false,\n         }\n     }\n@@ -601,6 +613,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             QPath::TypeRelative(_, ref path) => {\n                 self.hash_name(path.ident.name);\n             },\n+            QPath::LangItem(lang_item, ..) => {\n+                lang_item.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+            }\n         }\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n@@ -710,6 +725,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_ty(ty);\n                     segment.ident.name.hash(&mut self.s);\n                 },\n+                QPath::LangItem(lang_item, ..) => {\n+                    lang_item.hash(&mut self.s);\n+                }\n             },\n             TyKind::OpaqueDef(_, arg_list) => {\n                 self.hash_generic_args(arg_list);"}, {"sha": "4701a3f26e6f7dbc58a18c436745b77e4acf2336", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -266,6 +266,9 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n+        hir::ExprKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n+            println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n+        },\n         hir::ExprKind::AddrOf(kind, ref muta, ref e) => {\n             println!(\"{}AddrOf\", ind);\n             println!(\"kind: {:?}\", kind);\n@@ -488,6 +491,9 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n+        hir::PatKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n+            println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n+        },\n         hir::PatKind::Tuple(pats, opt_dots_position) => {\n             println!(\"{}Tuple\", ind);\n             if let Some(dot_position) = opt_dots_position {"}, {"sha": "a56b8203513e6d2c8945a5b520cb9093d4483b40", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -142,6 +142,14 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n     }\n }\n \n+/// Checks if the type is equal to a lang item\n+pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n+    match ty.kind {\n+        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).unwrap() == adt.did,\n+        _ => false,\n+    }\n+}\n+\n /// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n@@ -163,13 +171,15 @@ pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     match *path {\n         QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n         QPath::TypeRelative(_, ref seg) => seg,\n+        QPath::LangItem(..) => panic!(\"last_path_segment: lang item has no path segments\"),\n     }\n }\n \n pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n     match *path {\n         QPath::Resolved(_, ref path) => path.segments.get(0),\n         QPath::TypeRelative(_, ref seg) => Some(seg),\n+        QPath::LangItem(..) => None,\n     }\n }\n \n@@ -196,6 +206,7 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n             },\n             _ => false,\n         },\n+        QPath::LangItem(..) => false,\n     }\n }\n \n@@ -277,7 +288,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n     match qpath {\n         hir::QPath::Resolved(_, path) => path.res,\n-        hir::QPath::TypeRelative(..) => {\n+        hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => {\n             if cx.tcx.has_typeck_results(id.owner.to_def_id()) {\n                 cx.tcx.typeck(id.owner.to_def_id().expect_local()).qpath_res(qpath, id)\n             } else {"}, {"sha": "9c28d63d414c525b2ae5e3013be44ab07fef0255", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -84,19 +84,7 @@ pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n-pub const RANGE: [&str; 3] = [\"core\", \"ops\", \"Range\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n-pub const RANGE_FROM: [&str; 3] = [\"core\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FROM_STD: [&str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FULL: [&str; 4] = [\"core\", \"ops\", \"range\", \"RangeFull\"];\n-pub const RANGE_FULL_STD: [&str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n-pub const RANGE_INCLUSIVE_NEW: [&str; 4] = [\"core\", \"ops\", \"RangeInclusive\", \"new\"];\n-pub const RANGE_INCLUSIVE_STD_NEW: [&str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"new\"];\n-pub const RANGE_STD: [&str; 3] = [\"std\", \"ops\", \"Range\"];\n-pub const RANGE_TO: [&str; 3] = [\"core\", \"ops\", \"RangeTo\"];\n-pub const RANGE_TO_INCLUSIVE: [&str; 3] = [\"core\", \"ops\", \"RangeToInclusive\"];\n-pub const RANGE_TO_INCLUSIVE_STD: [&str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n-pub const RANGE_TO_STD: [&str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n@@ -130,7 +118,6 @@ pub const TO_STRING: [&str; 3] = [\"alloc\", \"string\", \"ToString\"];\n pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n-pub const TRY_INTO_RESULT: [&str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n pub const TRY_INTO_TRAIT: [&str; 3] = [\"core\", \"convert\", \"TryInto\"];\n pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];"}, {"sha": "2955f8d8e591984dc4004595aeda7bff29d40a7d", "filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -42,7 +42,7 @@ impl<'a> Sugg<'a> {\n     pub fn hir_opt(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n-            Self::hir_from_snippet(cx, expr, snippet)\n+            Self::hir_from_snippet(expr, snippet)\n         })\n     }\n \n@@ -80,13 +80,13 @@ impl<'a> Sugg<'a> {\n     pub fn hir_with_macro_callsite(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n         let snippet = snippet_with_macro_callsite(cx, expr.span, default);\n \n-        Self::hir_from_snippet(cx, expr, snippet)\n+        Self::hir_from_snippet(expr, snippet)\n     }\n \n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n-    fn hir_from_snippet(cx: &LateContext<'_>, expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n-        if let Some(range) = higher::range(cx, expr) {\n+    fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n+        if let Some(range) = higher::range(expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,\n                 ast::RangeLimits::Closed => AssocOp::DotDotEq,"}, {"sha": "3bf7607c62f0b27011f8a1cea0603089a6440f7c", "filename": "src/tools/clippy/tests/ui/author/for_loop.stdout", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/792c645ca7d11a8d254df307d019c5bf01445c37/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=792c645ca7d11a8d254df307d019c5bf01445c37", "patch": "@@ -3,10 +3,10 @@ if_chain! {\n     if let ExprKind::Match(ref expr1, ref arms, MatchSource::ForLoopDesugar) = expr.kind;\n     if let ExprKind::Call(ref func, ref args) = expr1.kind;\n     if let ExprKind::Path(ref path) = func.kind;\n-    if match_qpath(path, &[\"{{root}}\", \"std\", \"iter\", \"IntoIterator\", \"into_iter\"]);\n+    if matches!(path, QPath::LangItem(LangItem::IntoIterIntoIter, _));\n     if args.len() == 1;\n     if let ExprKind::Struct(ref path1, ref fields, None) = args[0].kind;\n-    if match_qpath(path1, &[\"{{root}}\", \"std\", \"ops\", \"Range\"]);\n+    if matches!(path1, QPath::LangItem(LangItem::Range, _));\n     if fields.len() == 2;\n     // unimplemented: field checks\n     if arms.len() == 1;\n@@ -20,7 +20,7 @@ if_chain! {\n     if let ExprKind::Match(ref expr2, ref arms1, MatchSource::ForLoopDesugar) = e.kind;\n     if let ExprKind::Call(ref func1, ref args1) = expr2.kind;\n     if let ExprKind::Path(ref path2) = func1.kind;\n-    if match_qpath(path2, &[\"{{root}}\", \"std\", \"iter\", \"Iterator\", \"next\"]);\n+    if matches!(path2, QPath::LangItem(LangItem::IteratorNext, _));\n     if args1.len() == 1;\n     if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, ref inner) = args1[0].kind;\n     if let ExprKind::Path(ref path3) = inner.kind;\n@@ -31,13 +31,15 @@ if_chain! {\n     if match_qpath(path4, &[\"__next\"]);\n     if let ExprKind::Path(ref path5) = value.kind;\n     if match_qpath(path5, &[\"val\"]);\n-    if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pat.kind;\n-    if match_qpath(path6, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"Some\"]);\n+    if let PatKind::Struct(ref path6, ref fields1, false) = arms1[0].pat.kind;\n+    if matches!(path6, QPath::LangItem(LangItem::OptionSome, _));\n     if fields1.len() == 1;\n     // unimplemented: field checks\n     if let ExprKind::Break(ref destination, None) = arms1[1].body.kind;\n-    if let PatKind::Path(ref path7) = arms1[1].pat.kind;\n-    if match_qpath(path7, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n+    if let PatKind::Struct(ref path7, ref fields2, false) = arms1[1].pat.kind;\n+    if matches!(path7, QPath::LangItem(LangItem::OptionNone, _));\n+    if fields2.len() == 0;\n+    // unimplemented: field checks\n     if let StmtKind::Local(ref local1) = body.stmts[2].kind;\n     if let Some(ref init) = local1.init;\n     if let ExprKind::Path(ref path8) = init.kind;"}]}