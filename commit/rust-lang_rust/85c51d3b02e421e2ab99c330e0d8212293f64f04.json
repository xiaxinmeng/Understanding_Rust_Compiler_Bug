{"sha": "85c51d3b02e421e2ab99c330e0d8212293f64f04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YzUxZDNiMDJlNDIxZTJhYjk5YzMzMGUwZDgyMTIyOTNmNjRmMDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-10-29T09:25:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-08T22:22:38Z"}, "message": "Introduce ty_fold mechanism and port our various folders to use\nit. This should eventually be merged with the Subst trait.", "tree": {"sha": "490ff17586a66299245d3eff10f5ec2b4a0b8904", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/490ff17586a66299245d3eff10f5ec2b4a0b8904"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85c51d3b02e421e2ab99c330e0d8212293f64f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85c51d3b02e421e2ab99c330e0d8212293f64f04", "html_url": "https://github.com/rust-lang/rust/commit/85c51d3b02e421e2ab99c330e0d8212293f64f04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85c51d3b02e421e2ab99c330e0d8212293f64f04/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e1de17757a204948b8d0ead4990b2602bc81298", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e1de17757a204948b8d0ead4990b2602bc81298", "html_url": "https://github.com/rust-lang/rust/commit/8e1de17757a204948b8d0ead4990b2602bc81298"}], "stats": {"total": 745, "additions": 411, "deletions": 334}, "files": [{"sha": "a13248f2480d123054f23442fb4760a3b2d66e6f", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/85c51d3b02e421e2ab99c330e0d8212293f64f04/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c51d3b02e421e2ab99c330e0d8212293f64f04/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=85c51d3b02e421e2ab99c330e0d8212293f64f04", "patch": "@@ -10,10 +10,11 @@\n \n // Type substitutions.\n \n-\n use middle::ty;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFolder;\n use syntax::opt_vec::OptVec;\n-use util::ppaux::Repr;\n+use std::at_vec;\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n@@ -33,39 +34,43 @@ pub trait Subst {\n // to all subst methods but ran into trouble due to the limitations of\n // our current method/trait matching algorithm. - Niko\n \n-trait EffectfulSubst {\n-    fn effectfulSubst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Self;\n-}\n-\n impl Subst for ty::t {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::t {\n         if ty::substs_is_noop(substs) {\n-            return *self;\n+            *self\n         } else {\n-            return self.effectfulSubst(tcx, substs);\n+            let mut folder = SubstFolder {tcx: tcx, substs: substs};\n+            folder.fold_ty(*self)\n         }\n     }\n }\n \n-impl EffectfulSubst for ty::t {\n-    fn effectfulSubst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::t {\n-        if !ty::type_needs_subst(*self) {\n-            return *self;\n+struct SubstFolder<'self> {\n+    tcx: ty::ctxt,\n+    substs: &'self ty::substs\n+}\n+\n+impl<'self> TypeFolder for SubstFolder<'self> {\n+    fn tcx(&self) -> ty::ctxt { self.tcx }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        r.subst(self.tcx, self.substs)\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        if !ty::type_needs_subst(t) {\n+            return t;\n         }\n \n-        match ty::get(*self).sty {\n+        match ty::get(t).sty {\n             ty::ty_param(p) => {\n-                substs.tps[p.idx]\n+                self.substs.tps[p.idx]\n             }\n             ty::ty_self(_) => {\n-                substs.self_ty.expect(\"ty_self not found in substs\")\n+                self.substs.self_ty.expect(\"ty_self not found in substs\")\n             }\n             _ => {\n-                ty::fold_regions_and_ty(\n-                    tcx, *self,\n-                    |r| r.subst(tcx, substs),\n-                    |t| t.effectfulSubst(tcx, substs),\n-                    |t| t.effectfulSubst(tcx, substs))\n+                ty_fold::super_fold_ty(self, t)\n             }\n         }\n     }\n@@ -80,6 +85,12 @@ impl<T:Subst> Subst for ~[T] {\n     }\n }\n \n+impl<T:Subst> Subst for @[T] {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> @[T] {\n+        at_vec::map(*self, |t| t.subst(tcx, substs))\n+    }\n+}\n+\n impl<T:Subst> Subst for OptVec<T> {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> OptVec<T> {\n         self.map(|t| t.subst(tcx, substs))\n@@ -134,7 +145,8 @@ impl Subst for ty::RegionSubsts {\n \n impl Subst for ty::BareFnTy {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::BareFnTy {\n-        ty::fold_bare_fn_ty(self, |t| t.subst(tcx, substs))\n+        let mut folder = SubstFolder {tcx: tcx, substs: substs};\n+        folder.fold_bare_fn_ty(self)\n     }\n }\n "}, {"sha": "9d6ad4d8bf6944d8e0ba13ab4d5c43bc1a5e9dcd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 92, "deletions": 313, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/85c51d3b02e421e2ab99c330e0d8212293f64f04/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c51d3b02e421e2ab99c330e0d8212293f64f04/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=85c51d3b02e421e2ab99c330e0d8212293f64f04", "patch": "@@ -21,6 +21,8 @@ use middle::resolve_lifetime;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFolder;\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n@@ -983,7 +985,7 @@ pub fn mk_ctxt(s: session::Session,\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-fn mk_t(cx: ctxt, st: sty) -> t {\n+pub fn mk_t(cx: ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n         ty_nil => return mk_nil(),\n@@ -992,6 +994,8 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n         ty_int(i) => return mk_mach_int(i),\n         ty_uint(u) => return mk_mach_uint(u),\n         ty_float(f) => return mk_mach_float(f),\n+        ty_char => return mk_char(),\n+        ty_bot => return mk_bot(),\n         _ => {}\n     };\n \n@@ -1338,224 +1342,70 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n     }\n }\n \n-pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: &fn(t) -> t) -> t {\n-    mk_t(tcx, fold_sty(sty, foldop))\n+// Folds types from the bottom up.\n+pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n+    let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n+    f.fold_ty(t0)\n }\n \n-pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n-    let args = sig.inputs.map(|arg| fldop(*arg));\n-\n-    FnSig {\n-        bound_lifetime_names: sig.bound_lifetime_names.clone(),\n-        inputs: args,\n-        output: fldop(sig.output),\n-        variadic: sig.variadic\n-    }\n+pub fn walk_regions_and_ty(cx: ctxt,\n+                           ty: t,\n+                           fldr: &fn(r: Region),\n+                           fldt: &fn(t: t))\n+                           -> t {\n+    ty_fold::RegionFolder::general(cx,\n+                                   |r| { fldr(r); r },\n+                                   |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-pub fn fold_bare_fn_ty(fty: &BareFnTy, fldop: &fn(t) -> t) -> BareFnTy {\n-    BareFnTy {sig: fold_sig(&fty.sig, fldop),\n-              abis: fty.abis,\n-              purity: fty.purity}\n+pub fn fold_regions(cx: ctxt,\n+                    ty: t,\n+                    fldr: &fn(r: Region) -> Region)\n+                    -> t {\n+    ty_fold::RegionFolder::regions(cx, fldr).fold_ty(ty)\n }\n \n-fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n-    fn fold_substs(substs: &substs, fldop: &fn(t) -> t) -> substs {\n-        substs {regions: substs.regions.clone(),\n-                self_ty: substs.self_ty.map(|t| fldop(t)),\n-                tps: substs.tps.map(|t| fldop(*t))}\n-    }\n+// Substitute *only* type parameters.  Used in trans where regions are erased.\n+pub fn subst_tps(tcx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n+    let mut subst = TpsSubst { tcx: tcx, self_ty_opt: self_ty_opt, tps: tps };\n+    return subst.fold_ty(typ);\n \n-    match *sty {\n-        ty_box(ref tm) => {\n-            ty_box(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_uniq(ref tm) => {\n-            ty_uniq(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_ptr(ref tm) => {\n-            ty_ptr(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_unboxed_vec(ref tm) => {\n-            ty_unboxed_vec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_evec(ref tm, vst) => {\n-            ty_evec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n-        }\n-        ty_enum(tid, ref substs) => {\n-            ty_enum(tid, fold_substs(substs, fldop))\n-        }\n-        ty_trait(did, ref substs, st, mutbl, bounds) => {\n-            ty_trait(did, fold_substs(substs, fldop), st, mutbl, bounds)\n-        }\n-        ty_tup(ref ts) => {\n-            let new_ts = ts.map(|tt| fldop(*tt));\n-            ty_tup(new_ts)\n-        }\n-        ty_bare_fn(ref f) => {\n-            ty_bare_fn(fold_bare_fn_ty(f, fldop))\n-        }\n-        ty_closure(ref f) => {\n-            let sig = fold_sig(&f.sig, fldop);\n-            ty_closure(ClosureTy {\n-                sig: sig,\n-                purity: f.purity,\n-                sigil: f.sigil,\n-                onceness: f.onceness,\n-                region: f.region,\n-                bounds: f.bounds,\n-            })\n-        }\n-        ty_rptr(r, ref tm) => {\n-            ty_rptr(r, mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_struct(did, ref substs) => {\n-            ty_struct(did, fold_substs(substs, fldop))\n-        }\n-        ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) | ty_err |\n-        ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self(_) => {\n-            (*sty).clone()\n-        }\n+    pub struct TpsSubst<'self> {\n+        tcx: ctxt,\n+        self_ty_opt: Option<t>,\n+        tps: &'self [t],\n     }\n-}\n \n-// Folds types from the bottom up.\n-pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n-    let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), |t| fldop(t)));\n-    fldop(mk_t(cx, sty))\n-}\n-\n-pub fn walk_regions_and_ty(\n-    cx: ctxt,\n-    ty: t,\n-    walkr: &fn(r: Region),\n-    walkt: &fn(t: t) -> bool) {\n-\n-    if (walkt(ty)) {\n-        fold_regions_and_ty(\n-            cx, ty,\n-            |r| { walkr(r); r },\n-            |t| { walk_regions_and_ty(cx, t, |r| walkr(r), |t| walkt(t)); t },\n-            |t| { walk_regions_and_ty(cx, t, |r| walkr(r), |t| walkt(t)); t });\n-    }\n-}\n+    impl<'self> TypeFolder for TpsSubst<'self> {\n+        fn tcx(&self) -> ty::ctxt { self.tcx }\n \n-pub fn fold_regions_and_ty(\n-    cx: ctxt,\n-    ty: t,\n-    fldr: &fn(r: Region) -> Region,\n-    fldfnt: &fn(t: t) -> t,\n-    fldt: &fn(t: t) -> t) -> t {\n-\n-    fn fold_substs(\n-        substs: &substs,\n-        fldr: &fn(r: Region) -> Region,\n-        fldt: &fn(t: t) -> t)\n-     -> substs {\n-        let regions = match substs.regions {\n-            ErasedRegions => ErasedRegions,\n-            NonerasedRegions(ref regions) => {\n-                NonerasedRegions(regions.map(|r| fldr(*r)))\n+        fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+            if self.tps.len() == 0u && self.self_ty_opt.is_none() {\n+                return t;\n             }\n-        };\n \n-        substs {\n-            regions: regions,\n-            self_ty: substs.self_ty.map(|t| fldt(t)),\n-            tps: substs.tps.map(|t| fldt(*t))\n-        }\n-    }\n+            let tb = ty::get(t);\n+            if self.self_ty_opt.is_none() && !tbox_has_flag(tb, has_params) {\n+                return t;\n+            }\n \n-    let tb = ty::get(ty);\n-    match tb.sty {\n-      ty::ty_rptr(r, mt) => {\n-        let m_r = fldr(r);\n-        let m_t = fldt(mt.ty);\n-        ty::mk_rptr(cx, m_r, mt {ty: m_t, mutbl: mt.mutbl})\n-      }\n-      ty_estr(vstore_slice(r)) => {\n-        let m_r = fldr(r);\n-        ty::mk_estr(cx, vstore_slice(m_r))\n-      }\n-      ty_evec(mt, vstore_slice(r)) => {\n-        let m_r = fldr(r);\n-        let m_t = fldt(mt.ty);\n-        ty::mk_evec(cx, mt {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n-      }\n-      ty_enum(def_id, ref substs) => {\n-        ty::mk_enum(cx, def_id, fold_substs(substs, fldr, fldt))\n-      }\n-      ty_struct(def_id, ref substs) => {\n-        ty::mk_struct(cx, def_id, fold_substs(substs, fldr, fldt))\n-      }\n-      ty_trait(def_id, ref substs, st, mutbl, bounds) => {\n-        let st = match st {\n-            RegionTraitStore(region) => RegionTraitStore(fldr(region)),\n-            st => st,\n-        };\n-        ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), st, mutbl, bounds)\n-      }\n-      ty_bare_fn(ref f) => {\n-          ty::mk_bare_fn(cx, BareFnTy {\n-            sig: fold_sig(&f.sig, fldfnt),\n-            purity: f.purity,\n-            abis: f.abis.clone(),\n-          })\n-      }\n-      ty_closure(ref f) => {\n-          ty::mk_closure(cx, ClosureTy {\n-            region: fldr(f.region),\n-            sig: fold_sig(&f.sig, fldfnt),\n-            purity: f.purity,\n-            sigil: f.sigil,\n-            onceness: f.onceness,\n-            bounds: f.bounds,\n-          })\n-      }\n-      ref sty => {\n-        fold_sty_to_ty(cx, sty, |t| fldt(t))\n-      }\n-    }\n-}\n+            match ty::get(t).sty {\n+                ty_param(p) => {\n+                    self.tps[p.idx]\n+                }\n \n-// n.b. this function is intended to eventually replace fold_region() below,\n-// that is why its name is so similar.\n-pub fn fold_regions(\n-    cx: ctxt,\n-    ty: t,\n-    fldr: &fn(r: Region, in_fn: bool) -> Region) -> t {\n-    fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n-               fldr: &fn(Region, bool) -> Region) -> t {\n-        debug!(\"do_fold(ty={}, in_fn={})\", ty_to_str(cx, ty), in_fn);\n-        if !type_has_regions(ty) { return ty; }\n-        fold_regions_and_ty(\n-            cx, ty,\n-            |r| fldr(r, in_fn),\n-            |t| do_fold(cx, t, true,  |r,b| fldr(r,b)),\n-            |t| do_fold(cx, t, in_fn, |r,b| fldr(r,b)))\n-    }\n-    do_fold(cx, ty, false, fldr)\n-}\n+                ty_self(_) => {\n+                    match self.self_ty_opt {\n+                        None => self.tcx.sess.bug(\"ty_self unexpected here\"),\n+                        Some(self_ty) => self_ty\n+                    }\n+                }\n \n-// Substitute *only* type parameters.  Used in trans where regions are erased.\n-pub fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n-    if tps.len() == 0u && self_ty_opt.is_none() { return typ; }\n-    let tb = ty::get(typ);\n-    if self_ty_opt.is_none() && !tbox_has_flag(tb, has_params) { return typ; }\n-    match tb.sty {\n-        ty_param(p) => tps[p.idx],\n-        ty_self(_) => {\n-            match self_ty_opt {\n-                None => cx.sess.bug(\"ty_self unexpected here\"),\n-                Some(self_ty) => {\n-                    subst_tps(cx, tps, self_ty_opt, self_ty)\n+                _ => {\n+                    ty_fold::super_fold_ty(self, t)\n                 }\n             }\n         }\n-        ref sty => {\n-            fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, self_ty_opt, t))\n-        }\n     }\n }\n \n@@ -2727,55 +2577,6 @@ pub fn index_sty(sty: &sty) -> Option<mt> {\n     }\n }\n \n-/**\n- * Enforces an arbitrary but consistent total ordering over\n- * free regions.  This is needed for establishing a consistent\n- * LUB in region_inference. */\n-impl cmp::TotalOrd for FreeRegion {\n-    fn cmp(&self, other: &FreeRegion) -> Ordering {\n-        cmp::cmp2(&self.scope_id, &self.bound_region,\n-                  &other.scope_id, &other.bound_region)\n-    }\n-}\n-\n-impl cmp::TotalEq for FreeRegion {\n-    fn equals(&self, other: &FreeRegion) -> bool {\n-        *self == *other\n-    }\n-}\n-\n-/**\n- * Enforces an arbitrary but consistent total ordering over\n- * bound regions.  This is needed for establishing a consistent\n- * LUB in region_inference. */\n-impl cmp::TotalOrd for bound_region {\n-    fn cmp(&self, other: &bound_region) -> Ordering {\n-        match (self, other) {\n-            (&ty::br_self, &ty::br_self) => cmp::Equal,\n-            (&ty::br_self, _) => cmp::Less,\n-\n-            (&ty::br_anon(ref a1), &ty::br_anon(ref a2)) => a1.cmp(a2),\n-            (&ty::br_anon(*), _) => cmp::Less,\n-\n-            (&ty::br_named(ref a1), &ty::br_named(ref a2)) => a1.name.cmp(&a2.name),\n-            (&ty::br_named(*), _) => cmp::Less,\n-\n-            (&ty::br_cap_avoid(ref a1, @ref b1),\n-             &ty::br_cap_avoid(ref a2, @ref b2)) => cmp::cmp2(a1, b1, a2, b2),\n-            (&ty::br_cap_avoid(*), _) => cmp::Less,\n-\n-            (&ty::br_fresh(ref a1), &ty::br_fresh(ref a2)) => a1.cmp(a2),\n-            (&ty::br_fresh(*), _) => cmp::Less,\n-        }\n-    }\n-}\n-\n-impl cmp::TotalEq for bound_region {\n-    fn equals(&self, other: &bound_region) -> bool {\n-        *self == *other\n-    }\n-}\n-\n pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n        Some(&t) => t,\n@@ -3684,7 +3485,6 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     load_external: &fn() -> V) -> V\n {\n     /*!\n-     *\n      * Helper for looking things up in the various maps\n      * that are populated during typeck::collect (e.g.,\n      * `cx.methods`, `cx.tcache`, etc).  All of these share\n@@ -3694,8 +3494,8 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n      * the crate loading code (and cache the result for the future).\n      */\n \n-    match map.find(&def_id) {\n-        Some(&ref v) => { return (*v).clone(); }\n+    match map.find_copy(&def_id) {\n+        Some(v) => { return v; }\n         None => { }\n     }\n \n@@ -3733,7 +3533,7 @@ pub fn method(cx: ctxt, id: ast::DefId) -> @Method {\n \n pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @~[DefId] {\n     lookup_locally_or_in_crate_store(\n-        \"methods\", id, cx.trait_method_def_ids,\n+        \"trait_method_def_ids\", id, cx.trait_method_def_ids,\n         || @csearch::get_trait_method_def_ids(cx.cstore, id))\n }\n \n@@ -4359,77 +4159,56 @@ pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> ~[t] {\n \n /// Returns an equivalent type with all the typedefs and self regions removed.\n pub fn normalize_ty(cx: ctxt, t: t) -> t {\n-    fn normalize_mt(cx: ctxt, mt: mt) -> mt {\n-        mt { ty: normalize_ty(cx, mt.ty), mutbl: mt.mutbl }\n-    }\n-    fn normalize_vstore(vstore: vstore) -> vstore {\n-        match vstore {\n-            vstore_fixed(*) | vstore_uniq | vstore_box => vstore,\n-            vstore_slice(_) => vstore_slice(re_static)\n-        }\n-    }\n-\n-    match cx.normalized_cache.find(&t) {\n-      Some(&t) => return t,\n-      None => ()\n-    }\n-\n-    let t = match get(t).sty {\n-        ty_evec(mt, vstore) =>\n-            // This type has a vstore. Get rid of it\n-            mk_evec(cx, normalize_mt(cx, mt), normalize_vstore(vstore)),\n+    let u = TypeNormalizer(cx).fold_ty(t);\n+    return u;\n \n-        ty_estr(vstore) =>\n-            // This type has a vstore. Get rid of it\n-            mk_estr(cx, normalize_vstore(vstore)),\n+    struct TypeNormalizer(ctxt);\n \n-        ty_rptr(_, mt) =>\n-            // This type has a region. Get rid of it\n-            mk_rptr(cx, re_static, normalize_mt(cx, mt)),\n+    impl TypeFolder for TypeNormalizer {\n+        fn tcx(&self) -> ty::ctxt { **self }\n \n-        ty_closure(ref closure_ty) => {\n-            mk_closure(cx, ClosureTy {\n-                region: ty::re_static,\n-                ..(*closure_ty).clone()\n-            })\n-        }\n-\n-        ty_enum(did, ref r) => {\n-            match (*r).regions {\n-                NonerasedRegions(_) => {\n-                    // trans doesn't care about regions\n-                    mk_enum(cx, did, substs {regions: ty::ErasedRegions,\n-                                             self_ty: None,\n-                                             tps: (*r).tps.clone()})\n+        fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+            match self.tcx().normalized_cache.find_copy(&t) {\n+                Some(u) => {\n+                    return u;\n                 }\n-                ErasedRegions => {\n-                    t\n+                None => {\n+                    let t_norm = ty_fold::super_fold_ty(self, t);\n+                    self.tcx().normalized_cache.insert(t, t_norm);\n+                    return t_norm;\n                 }\n             }\n         }\n \n-        ty_struct(did, ref r) => {\n-            match (*r).regions {\n-                NonerasedRegions(_) => {\n-                    // Ditto.\n-                    mk_struct(cx, did, substs {regions: ty::ErasedRegions,\n-                                               self_ty: None,\n-                                               tps: (*r).tps.clone()})\n-                }\n-                ErasedRegions => {\n-                    t\n-                }\n+        fn fold_vstore(&mut self, vstore: vstore) -> vstore {\n+            match vstore {\n+                vstore_fixed(*) | vstore_uniq | vstore_box => vstore,\n+                vstore_slice(_) => vstore_slice(re_static)\n             }\n         }\n \n-        _ =>\n-            t\n-    };\n+        fn fold_region(&mut self, _: ty::Region) -> ty::Region {\n+            ty::re_static\n+        }\n+\n+        fn fold_substs(&mut self,\n+                       substs: &substs)\n+                       -> substs {\n+            substs { regions: ErasedRegions,\n+                     self_ty: ty_fold::fold_opt_ty(self, substs.self_ty),\n+                     tps: ty_fold::fold_ty_vec(self, substs.tps) }\n+        }\n \n-    let sty = fold_sty(&get(t).sty, |t| { normalize_ty(cx, t) });\n-    let t_norm = mk_t(cx, sty);\n-    cx.normalized_cache.insert(t, t_norm);\n-    return t_norm;\n+        fn fold_sig(&mut self,\n+                    sig: &ty::FnSig)\n+                    -> ty::FnSig {\n+            // The binder-id is only relevant to bound regions, which\n+            // are erased at trans time.\n+            ty::FnSig { binder_id: ast::DUMMY_NODE_ID,\n+                        inputs: ty_fold::fold_ty_vec(self, sig.inputs),\n+                        output: self.fold_ty(sig.output) }\n+        }\n+    }\n }\n \n pub trait ExprTyProvider {"}, {"sha": "dc4fca0176a5f94ca938af46ca3260349bf7fbef", "filename": "src/librustc/middle/ty_fold.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/85c51d3b02e421e2ab99c330e0d8212293f64f04/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c51d3b02e421e2ab99c330e0d8212293f64f04/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=85c51d3b02e421e2ab99c330e0d8212293f64f04", "patch": "@@ -0,0 +1,286 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Generalized type folding mechanism.\n+\n+use middle::ty;\n+use util::ppaux::Repr;\n+\n+pub trait TypeFolder {\n+    fn tcx(&self) -> ty::ctxt;\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        super_fold_ty(self, t)\n+    }\n+\n+    fn fold_mt(&mut self, t: &ty::mt) -> ty::mt {\n+        super_fold_mt(self, t)\n+    }\n+\n+    fn fold_trait_ref(&mut self, t: &ty::TraitRef) -> ty::TraitRef {\n+        super_fold_trait_ref(self, t)\n+    }\n+\n+    fn fold_sty(&mut self, sty: &ty::sty) -> ty::sty {\n+        super_fold_sty(self, sty)\n+    }\n+\n+    fn fold_substs(&mut self,\n+                   substs: &ty::substs)\n+                   -> ty::substs {\n+        super_fold_substs(self, substs)\n+    }\n+\n+    fn fold_sig(&mut self,\n+                sig: &ty::FnSig)\n+                -> ty::FnSig {\n+        super_fold_sig(self, sig)\n+    }\n+\n+    fn fold_bare_fn_ty(&mut self,\n+                       fty: &ty::BareFnTy)\n+                       -> ty::BareFnTy {\n+        ty::BareFnTy { sig: self.fold_sig(&fty.sig),\n+                       abis: fty.abis,\n+                       purity: fty.purity }\n+    }\n+\n+    fn fold_closure_ty(&mut self,\n+                       fty: &ty::ClosureTy)\n+                       -> ty::ClosureTy {\n+        ty::ClosureTy {\n+            region: self.fold_region(fty.region),\n+            sig: self.fold_sig(&fty.sig),\n+            purity: fty.purity,\n+            sigil: fty.sigil,\n+            onceness: fty.onceness,\n+            bounds: fty.bounds,\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        r\n+    }\n+\n+    fn fold_vstore(&mut self, vstore: ty::vstore) -> ty::vstore {\n+        super_fold_vstore(self, vstore)\n+    }\n+\n+    fn fold_trait_store(&mut self, s: ty::TraitStore) -> ty::TraitStore {\n+        super_fold_trait_store(self, s)\n+    }\n+}\n+\n+pub fn fold_opt_ty<T:TypeFolder>(this: &mut T,\n+                                 t: Option<ty::t>)\n+                                 -> Option<ty::t> {\n+    t.map(|t| this.fold_ty(t))\n+}\n+\n+pub fn fold_ty_vec<T:TypeFolder>(this: &mut T,\n+                                 tys: &[ty::t])\n+                                 -> ~[ty::t] {\n+    tys.map(|t| this.fold_ty(*t))\n+}\n+\n+pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n+                                   t: ty::t)\n+                                   -> ty::t {\n+    ty::mk_t(this.tcx(), this.fold_sty(&ty::get(t).sty))\n+}\n+\n+pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n+                                       substs: &ty::substs)\n+                                       -> ty::substs {\n+    let regions = match substs.regions {\n+        ty::ErasedRegions => {\n+            ty::ErasedRegions\n+        }\n+        ty::NonerasedRegions(ref regions) => {\n+            ty::NonerasedRegions(regions.map(|r| this.fold_region(*r)))\n+        }\n+    };\n+\n+    ty::substs { regions: regions,\n+                 self_ty: fold_opt_ty(this, substs.self_ty),\n+                 tps: fold_ty_vec(this, substs.tps), }\n+}\n+\n+pub fn super_fold_sig<T:TypeFolder>(this: &mut T,\n+                                    sig: &ty::FnSig)\n+                                    -> ty::FnSig {\n+    ty::FnSig { binder_id: sig.binder_id,\n+                inputs: fold_ty_vec(this, sig.inputs),\n+                output: this.fold_ty(sig.output),\n+                variadic: sig.variadic }\n+}\n+\n+pub fn super_fold_trait_ref<T:TypeFolder>(this: &mut T,\n+                                          t: &ty::TraitRef)\n+                                          -> ty::TraitRef {\n+    ty::TraitRef {\n+        def_id: t.def_id,\n+        substs: this.fold_substs(&t.substs)\n+    }\n+}\n+\n+pub fn super_fold_mt<T:TypeFolder>(this: &mut T,\n+                                   mt: &ty::mt) -> ty::mt {\n+    ty::mt {ty: this.fold_ty(mt.ty),\n+            mutbl: mt.mutbl}\n+}\n+\n+pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n+                                    sty: &ty::sty) -> ty::sty {\n+    match *sty {\n+        ty::ty_box(ref tm) => {\n+            ty::ty_box(this.fold_mt(tm))\n+        }\n+        ty::ty_uniq(ref tm) => {\n+            ty::ty_uniq(this.fold_mt(tm))\n+        }\n+        ty::ty_ptr(ref tm) => {\n+            ty::ty_ptr(this.fold_mt(tm))\n+        }\n+        ty::ty_unboxed_vec(ref tm) => {\n+            ty::ty_unboxed_vec(this.fold_mt(tm))\n+        }\n+        ty::ty_evec(ref tm, vst) => {\n+            ty::ty_evec(this.fold_mt(tm),\n+                        this.fold_vstore(vst))\n+        }\n+        ty::ty_enum(tid, ref substs) => {\n+            ty::ty_enum(tid, this.fold_substs(substs))\n+        }\n+        ty::ty_trait(did, ref substs, st, mutbl, bounds) => {\n+            ty::ty_trait(did,\n+                     this.fold_substs(substs),\n+                     this.fold_trait_store(st),\n+                     mutbl,\n+                     bounds)\n+        }\n+        ty::ty_tup(ref ts) => {\n+            ty::ty_tup(fold_ty_vec(this, *ts))\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            ty::ty_bare_fn(this.fold_bare_fn_ty(f))\n+        }\n+        ty::ty_closure(ref f) => {\n+            ty::ty_closure(this.fold_closure_ty(f))\n+        }\n+        ty::ty_rptr(r, ref tm) => {\n+            ty::ty_rptr(this.fold_region(r),\n+                        ty::mt {ty: this.fold_ty(tm.ty),\n+                                mutbl: tm.mutbl})\n+        }\n+        ty::ty_struct(did, ref substs) => {\n+            ty::ty_struct(did,\n+                          this.fold_substs(substs))\n+        }\n+        ty::ty_estr(vst) => {\n+            ty::ty_estr(this.fold_vstore(vst))\n+        }\n+        ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char |\n+        ty::ty_int(_) | ty::ty_uint(_) |\n+        ty::ty_float(_) | ty::ty_type |\n+        ty::ty_opaque_closure_ptr(_) |\n+        ty::ty_err | ty::ty_opaque_box | ty::ty_infer(_) |\n+        ty::ty_param(*) | ty::ty_self(_) => {\n+            (*sty).clone()\n+        }\n+    }\n+}\n+\n+pub fn super_fold_vstore<T:TypeFolder>(this: &mut T,\n+                                       vstore: ty::vstore)\n+                                       -> ty::vstore {\n+    match vstore {\n+        ty::vstore_fixed(i) => ty::vstore_fixed(i),\n+        ty::vstore_uniq => ty::vstore_uniq,\n+        ty::vstore_box => ty::vstore_box,\n+        ty::vstore_slice(r) => ty::vstore_slice(this.fold_region(r)),\n+    }\n+}\n+\n+pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n+                                            trait_store: ty::TraitStore)\n+                                            -> ty::TraitStore {\n+    match trait_store {\n+        ty::UniqTraitStore      => ty::UniqTraitStore,\n+        ty::BoxTraitStore       => ty::BoxTraitStore,\n+        ty::RegionTraitStore(r) => ty::RegionTraitStore(this.fold_region(r)),\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Some sample folders\n+\n+pub struct BottomUpFolder<'self> {\n+    tcx: ty::ctxt,\n+    fldop: &'self fn(ty::t) -> ty::t,\n+}\n+\n+impl<'self> TypeFolder for BottomUpFolder<'self> {\n+    fn tcx(&self) -> ty::ctxt { self.tcx }\n+\n+    fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n+        let t1 = super_fold_ty(self, ty);\n+        (self.fldop)(t1)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Region folder\n+\n+pub struct RegionFolder<'self> {\n+    tcx: ty::ctxt,\n+    fld_t: &'self fn(ty::t) -> ty::t,\n+    fld_r: &'self fn(ty::Region) -> ty::Region,\n+}\n+\n+impl<'self> RegionFolder<'self> {\n+    pub fn general(tcx: ty::ctxt,\n+                   fld_r: &'self fn(ty::Region) -> ty::Region,\n+                   fld_t: &'self fn(ty::t) -> ty::t)\n+                   -> RegionFolder<'self> {\n+        RegionFolder {\n+            tcx: tcx,\n+            fld_t: fld_t,\n+            fld_r: fld_r\n+        }\n+    }\n+\n+    pub fn regions(tcx: ty::ctxt,\n+                   fld_r: &'self fn(ty::Region) -> ty::Region)\n+                   -> RegionFolder<'self> {\n+        fn noop(t: ty::t) -> ty::t { t }\n+\n+        RegionFolder {\n+            tcx: tcx,\n+            fld_t: noop,\n+            fld_r: fld_r\n+        }\n+    }\n+}\n+\n+impl<'self> TypeFolder for RegionFolder<'self> {\n+    fn tcx(&self) -> ty::ctxt { self.tcx }\n+\n+    fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n+        debug!(\"RegionFolder.fold_ty({})\", ty.repr(self.tcx()));\n+        let t1 = super_fold_ty(self, ty);\n+        (self.fld_t)(t1)\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        debug!(\"RegionFolder.fold_region({})\", r.repr(self.tcx()));\n+        (self.fld_r)(r)\n+    }\n+}"}]}