{"sha": "a530cc9706324ad44dba464d541a807eb5afdb08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MzBjYzk3MDYzMjRhZDQ0ZGJhNDY0ZDU0MWE4MDdlYjVhZmRiMDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-28T03:59:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-28T03:59:14Z"}, "message": "Auto merge of #21248 - brson:feature-staging, r=alexcrichton\n\nThis implements the remaining bits of 'feature staging', as described in [RFC 507](https://github.com/rust-lang/rfcs/blob/master/text/0507-release-channels.md).\r\n\r\nThis is not quite done, but the substance of the work is complete so submitting for early review.\r\n\r\nKey changes:\r\n* `unstable`, `stable` and `deprecated` attributes all require 'feature' and 'since', and support an optional 'reason'.\r\n* The `unstable` lint is removed.\r\n* A new 'stability checking' pass warns when a used unstable library feature has not been activated with the `feature` attribute. At 1.0 beta this will become an error.\r\n* A new 'unused feature checking' pass emits a lint ('unused_feature', renamed from 'unknown_feature') for any features that were activated but not used.\r\n* A new tidy script `featureck.py` performs some global sanity checking, particularly that 'since' numbers agree, and also prints out a summary of features.\r\n\r\nDifferences from RFC:\r\n* As implemented `unstable` requires a `since` attribute. I do not know if this is useful. I included it in the original sed script and just left it.\r\n* RFC didn't specify the name of the optional 'reason' attribute.\r\n* This continues to use 'unstable', 'stable' and 'deprecated' names (the 'nice' names) instead of 'staged_unstable', but only activates them with the crate-level 'staged_api' attribute.\r\n\r\nI intend to update the RFC based on the outcome of this PR.\r\n\r\nIssues:\r\n* The unused feature check doesn't account for language features - i.e. you can activate a language feature, not use it, and not get the error.\r\n\r\nOpen questions:\r\n* All unstable and deprecated features are named 'unnamed_feature', which i picked just because it is uniquely greppable. This is the 'catch-all' feature. What should it be?\r\n* All stable features are named 'grandfathered'. What should this be?\r\n\r\nTODO:\r\n* Add check that all `deprecated` attributes are paired with a `stable` attribute in order to preserve the knowledge about when a feature became stable.\r\n* Update rustdoc in various ways.\r\n* Remove obsolete stability discussion from reference.\r\n* Add features for 'path', 'io', 'os', 'hash' and 'rand'.\r\n\r\ncc #20445 @alexcrichton @aturon", "tree": {"sha": "a8f9e5444cf2378b9c3d5a193484a3f6c9873a06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8f9e5444cf2378b9c3d5a193484a3f6c9873a06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a530cc9706324ad44dba464d541a807eb5afdb08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a530cc9706324ad44dba464d541a807eb5afdb08", "html_url": "https://github.com/rust-lang/rust/commit/a530cc9706324ad44dba464d541a807eb5afdb08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a530cc9706324ad44dba464d541a807eb5afdb08/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92ff8ea52816982ad4cbfac8168e216d32d74c77", "url": "https://api.github.com/repos/rust-lang/rust/commits/92ff8ea52816982ad4cbfac8168e216d32d74c77", "html_url": "https://github.com/rust-lang/rust/commit/92ff8ea52816982ad4cbfac8168e216d32d74c77"}, {"sha": "71223050538939ed758fcd3b9114f71abff20bb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/71223050538939ed758fcd3b9114f71abff20bb2", "html_url": "https://github.com/rust-lang/rust/commit/71223050538939ed758fcd3b9114f71abff20bb2"}], "stats": {"total": 7472, "additions": 4327, "deletions": 3145}, "files": [{"sha": "e28f56fffe41b3d547f7c82ed3f1b86ef2b18725", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -301,6 +301,7 @@ tidy:\n \t\t| grep '^$(S)src/rust-installer' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n \t\t$(Q) $(CFG_PYTHON) $(S)src/etc/errorck.py $(S)src/\n+\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/featureck.py $(S)src/\n \n \n endif"}, {"sha": "eedff1d11760ca70ac9160593dc5ae4b9779f9a8", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -13,7 +13,15 @@\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(box_syntax)]\n #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(test)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(path)]\n+#![feature(io)]\n+#![feature(core)]\n+#![feature(collections)]\n+#![feature(os)]\n+#![feature(unicode)]\n \n #![deny(warnings)]\n "}, {"sha": "a52100c4cdd4e3141f229061e6747b35298f8fe2", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -2359,77 +2359,6 @@ Supported traits for `derive` are:\n * `Show`, to format a value using the `{}` formatter.\n * `Zero`, to create a zero instance of a numeric data type.\n \n-### Stability\n-\n-One can indicate the stability of an API using the following attributes:\n-\n-* `deprecated`: This item should no longer be used, e.g. it has been\n-  replaced. No guarantee of backwards-compatibility.\n-* `experimental`: This item was only recently introduced or is\n-  otherwise in a state of flux. It may change significantly, or even\n-  be removed. No guarantee of backwards-compatibility.\n-* `unstable`: This item is still under development, but requires more\n-  testing to be considered stable. No guarantee of backwards-compatibility.\n-* `stable`: This item is considered stable, and will not change\n-  significantly. Guarantee of backwards-compatibility.\n-* `frozen`: This item is very stable, and is unlikely to\n-  change. Guarantee of backwards-compatibility.\n-* `locked`: This item will never change unless a serious bug is\n-  found. Guarantee of backwards-compatibility.\n-\n-These levels are directly inspired by\n-[Node.js' \"stability index\"](http://nodejs.org/api/documentation.html).\n-\n-Stability levels are inherited, so an item's stability attribute is the default\n-stability for everything nested underneath it.\n-\n-There are lints for disallowing items marked with certain levels: `deprecated`,\n-`experimental` and `unstable`. For now, only `deprecated` warns by default, but\n-this will change once the standard library has been stabilized. Stability\n-levels are meant to be promises at the crate level, so these lints only apply\n-when referencing items from an _external_ crate, not to items defined within\n-the current crate. Items with no stability level are considered to be unstable\n-for the purposes of the lint. One can give an optional string that will be\n-displayed when the lint flags the use of an item.\n-\n-For example, if we define one crate called `stability_levels`:\n-\n-```{.ignore}\n-#[deprecated=\"replaced by `best`\"]\n-pub fn bad() {\n-    // delete everything\n-}\n-\n-pub fn better() {\n-    // delete fewer things\n-}\n-\n-#[stable]\n-pub fn best() {\n-    // delete nothing\n-}\n-```\n-\n-then the lints will work as follows for a client crate:\n-\n-```{.ignore}\n-#![warn(unstable)]\n-extern crate stability_levels;\n-use stability_levels::{bad, better, best};\n-\n-fn main() {\n-    bad(); // \"warning: use of deprecated item: replaced by `best`\"\n-\n-    better(); // \"warning: use of unmarked item\"\n-\n-    best(); // no warning\n-}\n-```\n-\n-> **Note:** Currently these are only checked when applied to individual\n-> functions, structs, methods and enum variants, *not* to entire modules,\n-> traits, impls or enums themselves.\n-\n ### Compiler Features\n \n Certain aspects of Rust may be implemented in the compiler, but they're not"}, {"sha": "601f130341bf95cb3a436bc45c659248c8561460", "filename": "src/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unstable)]\n+#![allow(unknown_features)]\n+#![cfg_attr(rustc, feature(rustc_private))]\n+#![cfg_attr(rustdoc, feature(rustdoc))]\n \n #[cfg(rustdoc)]\n extern crate \"rustdoc\" as this;"}, {"sha": "064cf1d40ab36ce881aad53dad4d0ff841323284", "filename": "src/etc/featureck.py", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fetc%2Ffeatureck.py", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fetc%2Ffeatureck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ffeatureck.py?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -0,0 +1,243 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# This script does a tree-wide sanity checks against stability\n+# attributes, currently:\n+#   * For all feature_name/level pairs the 'since' field is the same\n+#   * That no features are both stable and unstable.\n+#   * That lib features don't have the same name as lang features\n+#     unless they are on the 'joint_features' whitelist\n+#   * That features that exist in both lang and lib and are stable\n+#     since the same version\n+#   * Prints information about features\n+\n+import sys, os, re\n+\n+src_dir = sys.argv[1]\n+\n+# Features that are allowed to exist in both the language and the library\n+joint_features = [ ]\n+\n+# Grab the list of language features from the compiler\n+language_gate_statuses = [ \"Active\", \"Deprecated\", \"Removed\", \"Accepted\" ]\n+feature_gate_source = os.path.join(src_dir, \"libsyntax\", \"feature_gate.rs\")\n+language_features = []\n+language_feature_names = []\n+with open(feature_gate_source, 'r') as f:\n+    for line in f:\n+        original_line = line\n+        line = line.strip()\n+        is_feature_line = False\n+        for status in language_gate_statuses:\n+            if status in line and line.startswith(\"(\"):\n+                is_feature_line = True\n+\n+        if is_feature_line:\n+            line = line.replace(\"(\", \"\").replace(\"),\", \"\").replace(\")\", \"\")\n+            parts = line.split(\",\")\n+            if len(parts) != 3:\n+                print \"error: unexpected number of components in line: \" + original_line\n+                sys.exit(1)\n+            feature_name = parts[0].strip().replace('\"', \"\")\n+            since = parts[1].strip().replace('\"', \"\")\n+            status = parts[2].strip()\n+            assert len(feature_name) > 0\n+            assert len(since) > 0\n+            assert len(status) > 0\n+\n+            language_feature_names += [feature_name]\n+            language_features += [(feature_name, since, status)]\n+\n+assert len(language_features) > 0\n+\n+errors = False\n+\n+lib_features = { }\n+lib_features_and_level = { }\n+for (dirpath, dirnames, filenames) in os.walk(src_dir):\n+    # Don't look for feature names in tests\n+    if \"src/test\" in dirpath:\n+        continue\n+\n+    # Takes a long time to traverse LLVM\n+    if \"src/llvm\" in dirpath:\n+        continue\n+\n+    for filename in filenames:\n+        if not filename.endswith(\".rs\"):\n+            continue\n+\n+        path = os.path.join(dirpath, filename)\n+        with open(path, 'r') as f:\n+            line_num = 0\n+            for line in f:\n+                line_num += 1\n+                level = None\n+                if \"[unstable(\" in line:\n+                    level = \"unstable\"\n+                elif \"[stable(\" in line:\n+                    level = \"stable\"\n+                else:\n+                    continue\n+\n+                # This is a stability attribute. For the purposes of this\n+                # script we expect both the 'feature' and 'since' attributes on\n+                # the same line, e.g.\n+                # `#[unstable(feature = \"foo\", since = \"1.0.0\")]`\n+\n+                p = re.compile('(unstable|stable).*feature *= *\"(\\w*)\"')\n+                m = p.search(line)\n+                if not m is None:\n+                    feature_name = m.group(2)\n+                    since = None\n+                    if re.compile(\"\\[ *stable\").search(line) is not None:\n+                        pp = re.compile('since *= *\"([\\w\\.]*)\"')\n+                        mm = pp.search(line)\n+                        if not mm is None:\n+                            since = mm.group(1)\n+                        else:\n+                            print \"error: misformed stability attribute\"\n+                            print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                            print line\n+                            errors = True\n+\n+                    lib_features[feature_name] = feature_name\n+                    if lib_features_and_level.get((feature_name, level)) is None:\n+                        # Add it to the observed features\n+                        lib_features_and_level[(feature_name, level)] = \\\n+                            (since, path, line_num, line)\n+                    else:\n+                        # Verify that for this combination of feature_name and level the 'since'\n+                        # attribute matches.\n+                        (expected_since, source_path, source_line_num, source_line) = \\\n+                            lib_features_and_level.get((feature_name, level))\n+                        if since != expected_since:\n+                            print \"error: mismatch in \" + level + \" feature '\" + feature_name + \"'\"\n+                            print \"line \" + str(source_line_num) + \" of \" + source_path + \":\"\n+                            print source_line\n+                            print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                            print line\n+                            errors = True\n+\n+                    # Verify that this lib feature doesn't duplicate a lang feature\n+                    if feature_name in language_feature_names:\n+                        print \"error: lib feature '\" + feature_name + \"' duplicates a lang feature\"\n+                        print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                        print line\n+                        errors = True\n+\n+                else:\n+                    print \"error: misformed stability attribute\"\n+                    print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                    print line\n+                    errors = True\n+\n+# Merge data about both lists\n+# name, lang, lib, status, stable since\n+\n+language_feature_stats = {}\n+\n+for f in language_features:\n+    name = f[0]\n+    lang = True\n+    lib = False\n+    status = \"unstable\"\n+    stable_since = None\n+\n+    if f[2] == \"Accepted\":\n+        status = \"stable\"\n+    if status == \"stable\":\n+        stable_since = f[1]\n+\n+    language_feature_stats[name] = (name, lang, lib, status, stable_since)\n+\n+lib_feature_stats = {}\n+\n+for f in lib_features:\n+    name = f\n+    lang = False\n+    lib = True\n+    status = \"unstable\"\n+    stable_since = None\n+\n+    is_stable = lib_features_and_level.get((name, \"stable\")) is not None\n+    is_unstable = lib_features_and_level.get((name, \"unstable\")) is not None\n+\n+    if is_stable and is_unstable:\n+        print \"error: feature '\" + name + \"' is both stable and unstable\"\n+        errors = True\n+\n+    if is_stable:\n+        status = \"stable\"\n+        stable_since = lib_features_and_level[(name, \"stable\")][0]\n+    elif is_unstable:\n+        status = \"unstable\"\n+\n+    lib_feature_stats[name] = (name, lang, lib, status, stable_since)\n+\n+# Check for overlap in two sets\n+merged_stats = { }\n+\n+for name in lib_feature_stats:\n+    if language_feature_stats.get(name) is not None:\n+        if not name in joint_features:\n+            print \"error: feature '\" + name + \"' is both a lang and lib feature but not whitelisted\"\n+            errors = True\n+        lang_status = lang_feature_stats[name][3]\n+        lib_status = lib_feature_stats[name][3]\n+        lang_stable_since = lang_feature_stats[name][4]\n+        lib_stable_since = lib_feature_stats[name][4]\n+\n+        if lang_status != lib_status and lib_status != \"deprecated\":\n+            print \"error: feature '\" + name + \"' has lang status \" + lang_status + \\\n+                  \" but lib status \" + lib_status\n+            errors = True\n+\n+        if lang_stable_since != lib_stable_since:\n+            print \"error: feature '\" + name + \"' has lang stable since \" + lang_stable_since + \\\n+                  \" but lib stable since \" + lib_stable_since\n+            errors = True\n+\n+        merged_stats[name] = (name, True, True, lang_status, lang_stable_since)\n+\n+        del language_feature_stats[name]\n+        del lib_feature_stats[name]\n+\n+if errors:\n+    sys.exit(1)\n+\n+# Finally, display the stats\n+stats = {}\n+stats.update(language_feature_stats)\n+stats.update(lib_feature_stats)\n+stats.update(merged_stats)\n+lines = []\n+for s in stats:\n+    s = stats[s]\n+    type_ = \"lang\"\n+    if s[1] and s[2]:\n+        type_ = \"lang/lib\"\n+    elif s[2]:\n+        type_ = \"lib\"\n+    line = \"{: <32}\".format(s[0]) + \\\n+           \"{: <8}\".format(type_) + \\\n+           \"{: <12}\".format(s[3]) + \\\n+           \"{: <8}\".format(str(s[4]))\n+    lines += [line]\n+\n+lines.sort()\n+\n+print\n+print \"Rust feature summary:\"\n+print\n+for line in lines:\n+    print line\n+print\n+"}, {"sha": "1b75289c64f9fa57dfa43764ba2b549a7990d171", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n@@ -110,7 +110,7 @@ use heap::deallocate;\n /// }\n /// ```\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -126,7 +126,8 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n /// between `Arc` pointers.\n #[unsafe_no_drop_flag]\n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -156,7 +157,7 @@ impl<T> Arc<T> {\n     /// let five = Arc::new(5i);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(data: T) -> Arc<T> {\n         // Start the weak pointer count as 1 which is the weak pointer that's\n         // held by all the strong pointers (kinda), see std/rc.rs for more info\n@@ -179,7 +180,8 @@ impl<T> Arc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[unstable = \"Weak pointers may not belong in this module.\"]\n+    #[unstable(feature = \"alloc\",\n+               reason = \"Weak pointers may not belong in this module.\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n         self.inner().weak.fetch_add(1, Relaxed);\n@@ -200,15 +202,15 @@ impl<T> Arc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Arc<T> {\n     /// Makes a clone of the `Arc<T>`.\n     ///\n@@ -245,7 +247,7 @@ impl<T> BorrowFrom<Arc<T>> for T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Arc<T> {\n     type Target = T;\n \n@@ -271,7 +273,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"alloc\")]\n     pub fn make_unique(&mut self) -> &mut T {\n         // Note that we hold a strong reference, which also counts as a weak reference, so we only\n         // clone if there is an additional reference of either kind.\n@@ -289,7 +291,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Sync + Send> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n@@ -355,7 +357,8 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T: Sync + Send> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -393,7 +396,8 @@ impl<T: Sync + Send> Weak<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T: Sync + Send> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -417,7 +421,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Sync + Send> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n@@ -460,7 +464,7 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc<T>`s.\n     ///\n@@ -492,7 +496,7 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// Partial comparison for two `Arc<T>`s.\n     ///\n@@ -571,30 +575,30 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Arc<T> {\n     fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Arc<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display> fmt::Display for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default + Sync + Send> Default for Arc<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n@@ -605,7 +609,6 @@ impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n }\n \n #[cfg(test)]\n-#[allow(unstable)]\n mod tests {\n     use std::clone::Clone;\n     use std::sync::mpsc::channel;"}, {"sha": "51e5fc5820cbf9002e9251b219a780dd87ed5024", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -43,7 +43,7 @@\n //!\n //! This will print `Cons(1i32, Box(Cons(2i32, Box(Nil))))`.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::any::Any;\n use core::clone::Clone;\n@@ -77,14 +77,15 @@ use core::result::Result;\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n-#[unstable = \"may be renamed; uncertain about custom allocator design\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"may be renamed; uncertain about custom allocator design\")]\n pub static HEAP: () = ();\n \n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n@@ -95,25 +96,25 @@ impl<T> Box<T> {\n     /// ```\n     /// let x = Box::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(x: T) -> Box<T> {\n         box x\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Box<T> { box Default::default() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Box<[T]> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Box<[T]> { box [] }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for Box<T> {\n     /// Returns a new box with a `clone()` of this box's contents.\n     ///\n@@ -144,14 +145,14 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n@@ -166,14 +167,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n@@ -184,19 +185,20 @@ impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n }\n \n /// Extension methods for an owning `Any` trait object.\n-#[unstable = \"this trait will likely disappear once compiler bugs blocking \\\n-              a direct impl on `Box<Any>` have been fixed \"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"this trait will likely disappear once compiler bugs blocking \\\n+                     a direct impl on `Box<Any>` have been fixed \")]\n // FIXME(#18737): this should be a direct impl on `Box<Any>`. If you're\n //                removing this please make sure that you can downcase on\n //                `Box<Any + Send>` as well as `Box<Any>`\n pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Self>;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BoxAny for Box<Any> {\n     #[inline]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n@@ -215,35 +217,35 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Box<Any> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Box<Any>\")\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { &**self }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }"}, {"sha": "dcbd4d57cf990399ca0feae11b623b4340bdc398", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -80,7 +80,7 @@ pub fn usable_size(size: uint, align: uint) -> uint {\n ///\n /// These statistics may be inconsistent if other threads use the allocator\n /// during the call.\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn stats_print() {\n     imp::stats_print();\n }"}, {"sha": "6830a1c33dfabe0d830fcdaa327515a149f89d00", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -57,7 +57,8 @@\n //! default global allocator. It is not compatible with the libc allocator API.\n \n #![crate_name = \"alloc\"]\n-#![unstable]\n+#![unstable(feature = \"alloc\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -66,13 +67,15 @@\n \n #![no_std]\n #![allow(unknown_features)]\n-#![allow(unstable)]\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n // FIXME(#21363) remove `old_impl_check` when bug is fixed\n #![feature(old_impl_check)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(core)]\n+#![feature(hash)]\n+#![feature(libc)]\n \n #[macro_use]\n extern crate core;"}, {"sha": "d41673f56edda2cb2a7e13b625fac3d5d4cbac80", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -142,7 +142,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::borrow::BorrowFrom;\n use core::cell::Cell;\n@@ -173,7 +173,7 @@ struct RcBox<T> {\n ///\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n     // type via Deref\n@@ -185,7 +185,6 @@ impl<T> !marker::Send for Rc<T> {}\n impl<T> !marker::Sync for Rc<T> {}\n \n impl<T> Rc<T> {\n-\n     /// Constructs a new `Rc<T>`.\n     ///\n     /// # Examples\n@@ -195,7 +194,7 @@ impl<T> Rc<T> {\n     ///\n     /// let five = Rc::new(5i);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -222,7 +221,8 @@ impl<T> Rc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[unstable = \"Weak pointers may not belong in this module\"]\n+    #[unstable(feature = \"alloc\",\n+               reason = \"Weak pointers may not belong in this module\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak { _ptr: self._ptr }\n@@ -231,12 +231,12 @@ impl<T> Rc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n@@ -252,7 +252,7 @@ pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n /// rc::is_unique(&five);\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n     weak_count(rc) == 0 && strong_count(rc) == 1\n }\n@@ -274,7 +274,7 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4u)));\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n     if is_unique(&rc) {\n         unsafe {\n@@ -308,7 +308,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// assert!(rc::get_mut(&mut x).is_none());\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"alloc\")]\n pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n     if is_unique(rc) {\n         let inner = unsafe { &mut **rc._ptr };\n@@ -334,7 +334,7 @@ impl<T: Clone> Rc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"alloc\")]\n     pub fn make_unique(&mut self) -> &mut T {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n@@ -354,7 +354,7 @@ impl<T> BorrowFrom<Rc<T>> for T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n \n@@ -365,7 +365,7 @@ impl<T> Deref for Rc<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n     ///\n@@ -413,7 +413,7 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Rc<T> {\n \n     /// Makes a clone of the `Rc<T>`.\n@@ -436,7 +436,7 @@ impl<T> Clone for Rc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Rc<T> {\n     /// Creates a new `Rc<T>`, with the `Default` value for `T`.\n     ///\n@@ -449,13 +449,13 @@ impl<T: Default> Default for Rc<T> {\n     /// let x: Rc<int> = Default::default();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Rc<T> {\n         Rc::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc<T>`s.\n     ///\n@@ -490,10 +490,10 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Rc<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// Partial comparison for two `Rc<T>`s.\n     ///\n@@ -578,7 +578,7 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Rc<T> {\n     /// Comparison for two `Rc<T>`s.\n     ///\n@@ -605,14 +605,14 @@ impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n@@ -625,21 +625,21 @@ impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n ///\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n-#[allow(unstable)]\n impl<T> !marker::Send for Weak<T> {}\n \n-#[allow(unstable)]\n impl<T> !marker::Sync for Weak<T> {}\n \n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Weak<T> {\n \n     /// Upgrades a weak reference to a strong reference.\n@@ -670,7 +670,7 @@ impl<T> Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n@@ -713,7 +713,8 @@ impl<T> Drop for Weak<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Clone for Weak<T> {\n \n     /// Makes a clone of the `Weak<T>`.\n@@ -736,7 +737,7 @@ impl<T> Clone for Weak<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n@@ -777,7 +778,6 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n }\n \n #[cfg(test)]\n-#[allow(unstable)]\n mod tests {\n     use super::{Rc, Weak, weak_count, strong_count};\n     use std::cell::RefCell;"}, {"sha": "9396e2d6fb2f9d4cfb948be9e9d38eb26b7695d0", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -20,7 +20,8 @@\n //! more complex, slower arena which can hold objects of any type.\n \n #![crate_name = \"arena\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -34,7 +35,10 @@\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(missing_docs)]\n-#![allow(unstable)]\n+#![feature(alloc)]\n+#![feature(core)]\n+#![cfg_attr(test, feature(test))]\n+#![cfg_attr(test, feature(collections))]\n \n extern crate alloc;\n "}, {"sha": "13a37882ed9c9face4d283983106b297e1e7b63b", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -148,7 +148,7 @@\n //! ```\n \n #![allow(missing_docs)]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -164,12 +164,12 @@ use vec::{self, Vec};\n ///\n /// This will be a max-heap.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n     fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n@@ -185,7 +185,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n@@ -200,7 +200,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::with_capacity(10);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n@@ -238,7 +238,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.data.iter() }\n     }\n@@ -259,7 +259,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { iter: self.data.into_iter() }\n     }\n@@ -279,7 +279,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.peek(), Some(&5));\n     ///\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n     }\n@@ -294,7 +294,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -317,7 +317,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.data.reserve_exact(additional);\n     }\n@@ -338,13 +338,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.data.reserve(additional);\n     }\n \n     /// Discards as much additional capacity as possible.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();\n     }\n@@ -362,7 +362,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n@@ -387,7 +387,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.len(), 3);\n     /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n@@ -542,40 +542,41 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the binary heap.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.data.len() }\n \n     /// Checks if the binary heap is empty.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain() }\n     }\n \n     /// Drops all items from the binary heap.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.drain(); }\n }\n \n /// `BinaryHeap` iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter <'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter { iter: self.iter.clone() }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -586,22 +587,22 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: vec::IntoIter<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -612,22 +613,22 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n-#[unstable = \"recent addition\"]\n+#[unstable(feature = \"collections\", reason = \"recent addition\")]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -638,23 +639,23 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BinaryHeap<T> {\n         BinaryHeap::from_vec(iter.collect())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();"}, {"sha": "2c9a502a20987bb298155c4a3b588c4bd6faaea6", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 72, "deletions": 69, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -156,7 +156,8 @@ static FALSE: bool = false;\n /// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"RFC 509\")]\n pub struct Bitv {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n@@ -252,7 +253,7 @@ impl Bitv {\n     /// use std::collections::Bitv;\n     /// let mut bv = Bitv::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n@@ -288,7 +289,7 @@ impl Bitv {\n     ///\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(nbits: uint) -> Bitv {\n         Bitv {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n@@ -374,7 +375,7 @@ impl Bitv {\n     /// assert_eq!(bv[1], true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, i: uint) -> Option<bool> {\n         if i >= self.nbits {\n             return None;\n@@ -402,7 +403,8 @@ impl Bitv {\n     /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n-    #[unstable = \"panic semantics are likely to change in the future\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n@@ -585,7 +587,7 @@ impl Bitv {\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n         Iter { bitv: self, next_idx: 0, end_idx: self.nbits }\n     }\n@@ -706,7 +708,7 @@ impl Bitv {\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n@@ -733,7 +735,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -763,7 +765,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -785,7 +787,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n     }\n@@ -856,7 +858,7 @@ impl Bitv {\n     /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<bool> {\n         if self.is_empty() {\n             None\n@@ -886,7 +888,7 @@ impl Bitv {\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, elem: bool) {\n         if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n@@ -898,29 +900,29 @@ impl Bitv {\n \n     /// Return the total number of bits in this vector\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears all bits in this vector.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         for w in self.storage.iter_mut() { *w = 0u32; }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for Bitv {\n     #[inline]\n     fn default() -> Bitv { Bitv::new() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<bool> for Bitv {\n     fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv {\n         let mut ret = Bitv::new();\n@@ -929,7 +931,7 @@ impl FromIterator<bool> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<bool> for Bitv {\n     #[inline]\n     fn extend<I: Iterator<Item=bool>>(&mut self, mut iterator: I) {\n@@ -941,7 +943,7 @@ impl Extend<bool> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for Bitv {\n     #[inline]\n     fn clone(&self) -> Bitv {\n@@ -955,23 +957,23 @@ impl Clone for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Bitv {\n     #[inline]\n     fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for Bitv {\n     #[inline]\n     fn cmp(&self, other: &Bitv) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n@@ -981,7 +983,7 @@ impl fmt::Debug for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n@@ -991,7 +993,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for Bitv {\n     #[inline]\n     fn eq(&self, other: &Bitv) -> bool {\n@@ -1002,19 +1004,19 @@ impl cmp::PartialEq for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for Bitv {}\n \n /// An iterator for `Bitv`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Iter<'a> {\n     bitv: &'a Bitv,\n     next_idx: uint,\n     end_idx: uint,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Iter<'a> {\n     type Item = bool;\n \n@@ -1035,7 +1037,7 @@ impl<'a> Iterator for Iter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Iter<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<bool> {\n@@ -1048,10 +1050,10 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> ExactSizeIterator for Iter<'a> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> RandomAccessIterator for Iter<'a> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1107,18 +1109,19 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"RFC 509\")]\n pub struct BitvSet {\n     bitv: Bitv,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for BitvSet {\n     #[inline]\n     fn default() -> BitvSet { BitvSet::new() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<uint> for BitvSet {\n     fn from_iter<I:Iterator<Item=uint>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n@@ -1127,7 +1130,7 @@ impl FromIterator<uint> for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<uint> for BitvSet {\n     #[inline]\n     fn extend<I: Iterator<Item=uint>>(&mut self, mut iterator: I) {\n@@ -1137,7 +1140,7 @@ impl Extend<uint> for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for BitvSet {\n     #[inline]\n     fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n@@ -1146,7 +1149,7 @@ impl PartialOrd for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for BitvSet {\n     #[inline]\n     fn cmp(&self, other: &BitvSet) -> Ordering {\n@@ -1155,7 +1158,7 @@ impl Ord for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for BitvSet {\n     #[inline]\n     fn eq(&self, other: &BitvSet) -> bool {\n@@ -1164,7 +1167,7 @@ impl cmp::PartialEq for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {\n@@ -1178,7 +1181,7 @@ impl BitvSet {\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BitvSet {\n         BitvSet { bitv: Bitv::new() }\n     }\n@@ -1195,7 +1198,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n@@ -1233,7 +1236,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.bitv.capacity()\n     }\n@@ -1254,7 +1257,7 @@ impl BitvSet {\n     /// s.reserve_len(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1280,7 +1283,7 @@ impl BitvSet {\n     /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1374,7 +1377,7 @@ impl BitvSet {\n     /// println!(\"new capacity: {}\", s.capacity());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         let bitv = &mut self.bitv;\n         // Obtain original length\n@@ -1402,7 +1405,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> bitv_set::Iter {\n         SetIter {set: self, next_idx: 0u}\n     }\n@@ -1424,7 +1427,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n@@ -1454,7 +1457,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n         let min = cmp::min(self.bitv.len(), other.bitv.len());\n@@ -1491,7 +1494,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n@@ -1522,7 +1525,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n@@ -1639,28 +1642,28 @@ impl BitvSet {\n \n     /// Return the number of set bits in this set.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint  {\n         self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.bitv.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains(&self, value: &uint) -> bool {\n         let bitv = &self.bitv;\n         *value < bitv.nbits && bitv[*value]\n@@ -1669,14 +1672,14 @@ impl BitvSet {\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n         let self_bitv = &self.bitv;\n         let other_bitv = &other.bitv;\n@@ -1690,14 +1693,14 @@ impl BitvSet {\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: uint) -> bool {\n         if self.contains(&value) {\n             return false;\n@@ -1715,7 +1718,7 @@ impl BitvSet {\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;\n@@ -1752,7 +1755,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n \n /// An iterator for `BitvSet`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n     set: &'a BitvSet,\n     next_idx: uint\n@@ -1768,16 +1771,16 @@ struct TwoBitPositions<'a> {\n     next_idx: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a>(TwoBitPositions<'a>);\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a>(TwoBitPositions<'a>);\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SetIter<'a> {\n     type Item = uint;\n \n@@ -1800,7 +1803,7 @@ impl<'a> Iterator for SetIter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for TwoBitPositions<'a> {\n     type Item = uint;\n \n@@ -1838,31 +1841,31 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Union<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Intersection<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Difference<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SymmetricDifference<'a> {\n     type Item = uint;\n "}, {"sha": "17d26ed1a21e80908e942af4a16288343e198a6a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -81,7 +81,7 @@ use super::node::{self, Node, Found, GoDown};\n /// done on each operation isn't *catastrophic*, and *is* still bounded by O(B log<sub>B</sub>n),\n /// it is certainly much slower when it does.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n     length: uint,\n@@ -96,31 +96,31 @@ struct AbsIter<T> {\n }\n \n /// An iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -136,7 +136,8 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n     Vacant(VacantEntry<'a, K, V>),\n@@ -145,21 +146,23 @@ pub enum Entry<'a, K:'a, V:'a> {\n }\n \n /// A vacant Entry.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n         //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n@@ -190,7 +193,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n@@ -220,7 +223,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n@@ -252,7 +255,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n@@ -276,7 +279,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n@@ -337,7 +340,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n@@ -446,7 +449,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n@@ -807,7 +810,7 @@ mod stack {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n@@ -816,7 +819,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n     fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n@@ -826,7 +829,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n         for elt in self.iter() {\n@@ -835,42 +838,42 @@ impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeMap {{\"));\n@@ -884,7 +887,7 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -895,7 +898,7 @@ impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -1006,75 +1009,75 @@ impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n impl<'a, K, V> Iterator for Range<'a, K, V> {\n@@ -1096,7 +1099,8 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n@@ -1109,41 +1113,47 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         self.stack.insert(self.key, value)\n     }\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn remove(self) -> V {\n         self.stack.remove()\n     }\n@@ -1169,7 +1179,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let (first_key, first_value) = map.iter().next().unwrap();\n     /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n         // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n@@ -1202,7 +1212,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n         let mut lca = RingBuf::new();\n@@ -1231,7 +1241,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n         let mut lca = RingBuf::new();\n@@ -1258,7 +1268,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let keys: Vec<uint> = a.keys().cloned().collect();\n     /// assert_eq!(keys, vec![1u,2,]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n@@ -1280,7 +1290,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let values: Vec<&str> = a.values().cloned().collect();\n     /// assert_eq!(values, vec![\"a\",\"b\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n@@ -1300,7 +1310,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -1315,7 +1325,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n@@ -1470,7 +1480,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// }\n     /// assert_eq!(Some((&5u, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&K>, max: Bound<&K>) -> Range<'a, K, V> {\n         range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n     }\n@@ -1496,7 +1507,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     println!(\"{} => {}\", name, balance);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range_mut<'a>(&'a mut self, min: Bound<&K>, max: Bound<&K>) -> RangeMut<'a, K, V> {\n         range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,\n                                                                       edges_mut, [mut])\n@@ -1528,7 +1540,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3u);\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n-    #[unstable = \"precise API still under development\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"precise API still under development\")]\n     pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);"}, {"sha": "95e424fb7a03cd04bcee56099299dc696ffbc91e", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -420,7 +420,7 @@ impl<K, V> Node<K, V> {\n }\n \n // FIXME(gereeter) Write an efficient clone_from\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Clone, V: Clone> Clone for Node<K, V> {\n     fn clone(&self) -> Node<K, V> {\n         let mut ret = if self.is_leaf() {"}, {"sha": "e95087fa84689409eb6d4baed25336b5a44b7869", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -31,19 +31,19 @@ use Bound;\n /// See BTreeMap's documentation for a detailed discussion of this collection's performance\n /// benefits and drawbacks.\n #[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeSet<T>{\n     map: BTreeMap<T, ()>,\n }\n \n /// An iterator over a BTreeSet's items.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>\n }\n \n /// An owning iterator over a BTreeSet's items.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n@@ -54,28 +54,28 @@ pub struct Range<'a, T: 'a> {\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n@@ -91,15 +91,16 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n     /// Makes a new BTreeSet with the given B.\n     ///\n     /// B cannot be less than 2.\n-    #[unstable = \"probably want this to be on the type, eventually\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"probably want this to be on the type, eventually\")]\n     pub fn with_b(b: uint) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }\n@@ -122,7 +123,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.iter().map(|&x| x).collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n@@ -139,7 +140,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.into_iter().collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n@@ -169,7 +170,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// }\n     /// assert_eq!(Some(&5u), set.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&T>, max: Bound<&T>) -> Range<'a, T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a T, &'a ())) -> &'a T = first; // coerce to fn pointer\n@@ -197,7 +199,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let diff: Vec<uint> = a.difference(&b).cloned().collect();\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n         Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -220,7 +222,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let sym_diff: Vec<uint> = a.symmetric_difference(&b).cloned().collect();\n     /// assert_eq!(sym_diff, vec![1u,3]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> SymmetricDifference<'a, T> {\n         SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -244,7 +246,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let intersection: Vec<uint> = a.intersection(&b).cloned().collect();\n     /// assert_eq!(intersection, vec![2u]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> Intersection<'a, T> {\n         Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -266,7 +268,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let union: Vec<uint> = a.union(&b).cloned().collect();\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n         Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -283,7 +285,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -298,7 +300,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -313,7 +315,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.map.clear()\n     }\n@@ -333,7 +335,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n@@ -355,7 +357,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -376,7 +378,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Stolen from TreeMap\n         let mut x = self.iter();\n@@ -421,7 +423,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -440,7 +442,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.insert(2i), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool {\n         self.map.insert(value, ()).is_none()\n     }\n@@ -463,13 +465,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n@@ -478,7 +480,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n@@ -488,15 +490,15 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BTreeSet<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -519,7 +521,7 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -542,7 +544,7 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -565,7 +567,7 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -588,7 +590,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeSet {{\"));\n@@ -602,33 +604,33 @@ impl<T: Debug> Debug for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n \n@@ -651,7 +653,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     type Item = &'a T;\n \n@@ -666,7 +668,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     type Item = &'a T;\n \n@@ -681,7 +683,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     type Item = &'a T;\n \n@@ -702,7 +704,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n "}, {"sha": "08f7cea4e92453063bbceb3614309bcb6b4d52cb", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -19,7 +19,7 @@\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -33,7 +33,7 @@ use core::mem;\n use core::ptr;\n \n /// A doubly-linked list.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct DList<T> {\n     length: uint,\n     list_head: Link<T>,\n@@ -57,15 +57,15 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n // FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter {\n@@ -77,7 +77,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n }\n \n /// An iterator over mutable references to the items of a `DList`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n@@ -87,7 +87,7 @@ pub struct IterMut<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     list: DList<T>\n }\n@@ -206,17 +206,17 @@ impl<T> DList<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for DList<T> {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> DList<T> { DList::new() }\n }\n \n impl<T> DList<T> {\n     /// Creates an empty `DList`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n@@ -273,14 +273,14 @@ impl<T> DList<T> {\n \n     /// Provides a forward iterator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n@@ -296,7 +296,7 @@ impl<T> DList<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter{list: self}\n     }\n@@ -317,7 +317,7 @@ impl<T> DList<T> {\n     /// assert!(!dl.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n     }\n@@ -344,7 +344,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint {\n         self.length\n     }\n@@ -371,7 +371,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         *self = DList::new()\n     }\n@@ -392,7 +392,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n@@ -419,7 +419,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n@@ -440,7 +440,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n@@ -467,7 +467,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n@@ -490,7 +490,7 @@ impl<T> DList<T> {\n     /// assert_eq!(dl.front().unwrap(), &1);\n     ///\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n     }\n@@ -516,7 +516,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     ///\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n@@ -533,7 +533,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, elt: T) {\n         self.push_back_node(box Node::new(elt))\n     }\n@@ -552,7 +552,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n@@ -577,7 +577,7 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), Some(1));\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn split_off(&mut self, at: uint) -> DList<T> {\n         let len = self.len();\n         assert!(at < len, \"Cannot split off at a nonexistent index\");\n@@ -620,7 +620,7 @@ impl<T> DList<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for DList<T> {\n     fn drop(&mut self) {\n         // Dissolve the dlist in backwards direction\n@@ -642,7 +642,7 @@ impl<T> Drop for DList<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -664,7 +664,7 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n@@ -679,10 +679,10 @@ impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n     #[inline]\n@@ -706,7 +706,7 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n@@ -721,7 +721,7 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n // private methods for IterMut\n@@ -770,7 +770,8 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"this is probably better handled by a cursor type -- we'll see\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n     }\n@@ -791,7 +792,8 @@ impl<'a, A> IterMut<'a, A> {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// ```\n     #[inline]\n-    #[unstable = \"this is probably better handled by a cursor type -- we'll see\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n             return None\n@@ -800,7 +802,7 @@ impl<'a, A> IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -813,13 +815,13 @@ impl<A> Iterator for IntoIter<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for DList<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> {\n         let mut ret = DList::new();\n@@ -828,14 +830,14 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for DList<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n@@ -848,32 +850,32 @@ impl<A: PartialEq> PartialEq for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for DList<A> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for DList<A> {\n     fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Ord> Ord for DList<A> {\n     #[inline]\n     fn cmp(&self, other: &DList<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Clone for DList<A> {\n     fn clone(&self) -> DList<A> {\n         self.iter().map(|x| x.clone()).collect()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: fmt::Debug> fmt::Debug for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"DList [\"));\n@@ -887,7 +889,7 @@ impl<A: fmt::Debug> fmt::Debug for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);"}, {"sha": "f36da6f82eb730047323e4a42b02a74025855008", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -82,19 +82,22 @@ fn bit<E:CLike>(e: &E) -> uint {\n \n impl<E:CLike> EnumSet<E> {\n     /// Returns an empty `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn new() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn len(&self) -> uint {\n         self.bits.count_ones()\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n@@ -104,19 +107,22 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == 0\n     }\n \n     /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == other.bits\n     }\n \n     /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n         other.is_superset(self)\n     }\n@@ -132,29 +138,33 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, e: E) -> bool {\n         let result = !self.contains(&e);\n         self.bits |= bit(&e);\n         result\n     }\n \n     /// Removes an enum from the EnumSet\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn remove(&mut self, e: &E) -> bool {\n         let result = self.contains(e);\n         self.bits &= !bit(e);\n         result\n     }\n \n     /// Returns `true` if an `EnumSet` contains a given enum.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn contains(&self, e: &E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n     /// Returns an iterator over an `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn iter(&self) -> Iter<E> {\n         Iter::new(self.bits)\n     }"}, {"sha": "954de14a50a9314444518eda481885b10220d763", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,8 @@\n \n \n #![crate_name = \"collections\"]\n-#![unstable]\n+#![unstable(feature = \"collections\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -27,8 +28,12 @@\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![no_std]\n+#![feature(core)]\n+#![feature(alloc)]\n+#![feature(unicode)]\n+#![feature(hash)]\n+#![cfg_attr(test, feature(test))]\n \n #[macro_use]\n extern crate core;\n@@ -70,23 +75,25 @@ pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"RFC 509\")]\n pub mod bitv {\n     pub use bit::{Bitv, Iter};\n }\n \n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"RFC 509\")]\n pub mod bitv_set {\n     pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_map {\n     pub use btree::map::*;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_set {\n     pub use btree::set::*;\n }"}, {"sha": "15048998592a9dcf6a050d6db0306a06722b2642", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n /// Creates a `Vec` containing the arguments.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! vec {\n     ($x:expr; $y:expr) => (\n         <[_] as $crate::slice::SliceExt>::into_vec("}, {"sha": "2e3f61981122ee6dcadd36ee0df7a8003d820611", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 73, "deletions": 65, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,7 @@\n //! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n //! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -36,7 +36,7 @@ static INITIAL_CAPACITY: uint = 7u; // 2^3 - 1\n static MINIMUM_CAPACITY: uint = 1u; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RingBuf<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n@@ -50,21 +50,21 @@ pub struct RingBuf<T> {\n     ptr: *mut T\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Send> Send for RingBuf<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for RingBuf<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n         self.iter().map(|t| t.clone()).collect()\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for RingBuf<T> {\n     fn drop(&mut self) {\n         self.clear();\n@@ -78,7 +78,7 @@ impl<T> Drop for RingBuf<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for RingBuf<T> {\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n@@ -146,13 +146,13 @@ impl<T> RingBuf<T> {\n \n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> RingBuf<T> {\n         RingBuf::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n@@ -191,7 +191,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(5);\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, i: uint) -> Option<&T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -221,7 +221,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// assert_eq!(buf[1], 7);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -250,7 +250,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n@@ -273,7 +273,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -296,7 +296,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.reserve(additional);\n     }\n@@ -317,7 +317,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_len = self.len() + additional;\n         assert!(new_len + 1 > self.len(), \"capacity overflow\");\n@@ -480,7 +480,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.len(), 1);\n     /// assert_eq!(Some(&5), buf.get(0));\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn truncate(&mut self, len: uint) {\n         for _ in range(len, self.len()) {\n             self.pop_back();\n@@ -501,7 +502,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&5, &3, &4];\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n             tail: self.tail,\n@@ -527,7 +528,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n     /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         IterMut {\n             tail: self.tail,\n@@ -539,7 +540,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Consumes the list into an iterator yielding elements by value.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter {\n             inner: self,\n@@ -549,7 +550,8 @@ impl<T> RingBuf<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `RingBuf`.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n@@ -568,7 +570,8 @@ impl<T> RingBuf<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `RingBuf`.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n@@ -600,7 +603,7 @@ impl<T> RingBuf<T> {\n     /// v.push_back(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n@@ -615,7 +618,7 @@ impl<T> RingBuf<T> {\n     /// v.push_front(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Creates a draining iterator that clears the `RingBuf` and iterates over\n@@ -632,7 +635,8 @@ impl<T> RingBuf<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain {\n             inner: self,\n@@ -651,7 +655,7 @@ impl<T> RingBuf<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -672,7 +676,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n@@ -696,7 +700,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n@@ -716,7 +720,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n@@ -740,7 +744,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n         if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n@@ -762,7 +766,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(d.pop_front(), Some(2i));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -785,7 +789,7 @@ impl<T> RingBuf<T> {\n     /// d.push_front(2i);\n     /// assert_eq!(d.front(), Some(&2i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -809,7 +813,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -835,7 +839,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -872,7 +876,8 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(10);\n     /// assert_eq!(buf.swap_back_remove(1), Some(99));\n     /// ```\n-    #[unstable = \"the naming of this function may be altered\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"the naming of this function may be altered\")]\n     pub fn swap_back_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n@@ -904,7 +909,8 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(20i);\n     /// assert_eq!(buf.swap_front_remove(3), Some(99));\n     /// ```\n-    #[unstable = \"the naming of this function may be altered\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"the naming of this function may be altered\")]\n     pub fn swap_front_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length && index != 0 {\n@@ -1137,7 +1143,7 @@ impl<T> RingBuf<T> {\n     /// buf.remove(2);\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, i: uint) -> Option<T> {\n         if self.is_empty() || self.len() <= i {\n             return None;\n@@ -1304,7 +1310,8 @@ impl<T: Clone> RingBuf<T> {\n     ///     assert_eq!(a, b);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn resize(&mut self, new_len: uint, value: T) {\n         let len = self.len();\n \n@@ -1331,7 +1338,7 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n@@ -1349,7 +1356,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -1370,7 +1377,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n@@ -1382,10 +1389,10 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1408,7 +1415,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n@@ -1417,7 +1424,7 @@ pub struct IterMut<'a, T:'a> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -1441,7 +1448,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n@@ -1456,16 +1463,16 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// A by-value RingBuf iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     inner: RingBuf<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1481,25 +1488,26 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n     inner: &'a mut RingBuf<T>,\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in *self {}\n@@ -1508,7 +1516,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1524,44 +1532,44 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for RingBuf<A> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n     fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Ord> Ord for RingBuf<A> {\n     #[inline]\n     fn cmp(&self, other: &RingBuf<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n@@ -1571,7 +1579,7 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Index<uint> for RingBuf<A> {\n     type Output = A;\n \n@@ -1581,7 +1589,7 @@ impl<A> Index<uint> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<uint> for RingBuf<A> {\n     type Output = A;\n \n@@ -1591,7 +1599,7 @@ impl<A> IndexMut<uint> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for RingBuf<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> {\n         let (lower, _) = iterator.size_hint();\n@@ -1601,7 +1609,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n@@ -1610,7 +1618,7 @@ impl<A> Extend<A> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"RingBuf [\"));"}, {"sha": "dff95711d49e16651980b3d5fe74e9b48487adcf", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 88, "deletions": 70, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -86,7 +86,7 @@\n //! * Further iterators exist that split, chunk or permute the slice.\n \n #![doc(primitive = \"slice\")]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n@@ -120,9 +120,9 @@ pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Allocating extension methods for slices.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait SliceExt {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n     /// Sorts the slice, in place, using `compare` to compare\n@@ -142,7 +142,7 @@ pub trait SliceExt {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n@@ -166,19 +166,26 @@ pub trait SliceExt {\n     /// assert_eq!(num_moved, 3);\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n-    #[unstable = \"uncertain about this API approach\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain about this API approach\")]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n     /// Deprecated: use `&s[start .. end]` notation instead.\n-    #[deprecated = \"use &s[start .. end] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n     /// Deprecated: use `&s[start..]` notation instead.\n-    #[deprecated = \"use &s[start..] isntead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] isntead\")]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n     /// Deprecated: use `&s[..end]` notation instead.\n-    #[deprecated = \"use &s[..end] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n@@ -188,31 +195,31 @@ pub trait SliceExt {\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n     /// Panics if `mid > len`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn iter(&self) -> Iter<Self::Item>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n                 where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n                  where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n                   where F: FnMut(&Self::Item) -> bool;\n \n@@ -235,7 +242,7 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn windows(&self, size: uint) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n@@ -258,33 +265,33 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn get(&self, index: uint) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n \n     /// Returns all but the first element of a slice.\n-    #[unstable = \"likely to be renamed\"]\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n     fn tail(&self) -> &[Self::Item];\n \n     /// Returns all but the last element of a slice.\n-    #[unstable = \"likely to be renamed\"]\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n     fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(&self) -> Option<&Self::Item>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n \n     /// Returns an unsafe pointer to the slice's buffer\n@@ -294,7 +301,7 @@ pub trait SliceExt {\n     ///\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n \n     /// Binary search a sorted slice with a comparator function.\n@@ -329,7 +336,7 @@ pub trait SliceExt {\n     /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n         F: FnMut(&Self::Item) -> Ordering;\n \n@@ -341,7 +348,7 @@ pub trait SliceExt {\n     /// let a = [1i, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len(&self) -> uint;\n \n     /// Returns true if the slice has a length of 0\n@@ -353,68 +360,76 @@ pub trait SliceExt {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[start .. end]` instead.\n-    #[deprecated = \"use &mut s[start .. end] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[start ..]` instead.\n-    #[deprecated = \"use &mut s[start ..] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[.. end]` instead.\n-    #[deprecated = \"use &mut s[.. end] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns all but the first element of a mutable slice\n-    #[unstable = \"likely to be renamed or removed\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be renamed or removed\")]\n     fn tail_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns all but the last element of a mutable slice\n-    #[unstable = \"likely to be renamed or removed\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be renamed or removed\")]\n     fn init_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable pointer to the last item in the slice.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n                     where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n                       where F: FnMut(&Self::Item) -> bool;\n \n@@ -426,7 +441,7 @@ pub trait SliceExt {\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n@@ -447,7 +462,7 @@ pub trait SliceExt {\n     /// v.swap(1, 3);\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn swap(&mut self, a: uint, b: uint);\n \n     /// Divides one `&mut` into two at an index.\n@@ -484,7 +499,7 @@ pub trait SliceExt {\n     ///     assert!(right == []);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n@@ -496,11 +511,11 @@ pub trait SliceExt {\n     /// v.reverse();\n     /// assert!(v == [3i, 2, 1]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn reverse(&mut self);\n \n     /// Returns an unsafe mutable pointer to the element in index\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n \n     /// Return an unsafe mutable pointer to the slice's buffer.\n@@ -511,11 +526,11 @@ pub trait SliceExt {\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n     /// Copies `self` into a new `Vec`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n \n     /// Creates an iterator that yields every possible permutation of the\n@@ -542,7 +557,7 @@ pub trait SliceExt {\n     /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n     /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n \n     /// Copies as many elements from `src` as it can into `self` (the\n@@ -562,7 +577,7 @@ pub trait SliceExt {\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n \n     /// Sorts the slice, in place.\n@@ -577,7 +592,7 @@ pub trait SliceExt {\n     /// v.sort();\n     /// assert!(v == [-5i, -3, 1, 2, 4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sort(&mut self) where Self::Item: Ord;\n \n     /// Binary search a sorted slice for a given element.\n@@ -603,11 +618,12 @@ pub trait SliceExt {\n     /// let r = s.binary_search(&1);\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n \n     /// Deprecated: use `binary_search` instead.\n-    #[deprecated = \"use binary_search instead\"]\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use binary_search instead\")]\n     fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n         self.binary_search(x)\n     }\n@@ -628,7 +644,8 @@ pub trait SliceExt {\n     /// let b: &mut [_] = &mut [1i, 0, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain if this merits inclusion in std\")]\n     fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n \n     /// Mutates the slice to the previous lexicographic permutation.\n@@ -647,35 +664,36 @@ pub trait SliceExt {\n     /// let b: &mut [_] = &mut [0i, 1, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain if this merits inclusion in std\")]\n     fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n \n     /// Find the first index containing a matching value.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Find the last index containing a matching value.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Return true if the slice contains an element with the given value.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a prefix of the slice.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a suffix of the slice.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Convert `self` into a vector without clones or allocation.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -963,7 +981,7 @@ impl<T> SliceExt for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable = \"U should be an associated type\"]\n+#[unstable(feature = \"collections\", reason = \"U should be an associated type\")]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n@@ -977,7 +995,7 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n     ///\n     /// println!(\"{}\", s); // prints \"helloworld\"\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn concat(&self) -> U;\n \n     /// Flattens a slice of `T` into a single value `U`, placing a given separator between each.\n@@ -991,7 +1009,7 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n     ///\n     /// println!(\"{}\", s); // prints \"hello world\"\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn connect(&self, sep: &T) -> U;\n }\n \n@@ -1027,7 +1045,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n ///\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n #[derive(Clone)]\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n@@ -1039,7 +1057,7 @@ pub struct ElementSwaps {\n \n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     pub fn new(length: uint) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n@@ -1056,17 +1074,17 @@ impl ElementSwaps {\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T> BorrowFrom<Vec<T>> for [T] {\n     fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n     fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T: Clone> ToOwned<Vec<T>> for [T] {\n     fn to_owned(&self) -> Vec<T> { self.to_vec() }\n }\n@@ -1085,7 +1103,7 @@ struct SizeDirection {\n     dir: Direction,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ElementSwaps {\n     type Item = (uint, uint);\n \n@@ -1148,13 +1166,13 @@ impl Iterator for ElementSwaps {\n /// swap applied.\n ///\n /// Generates even and odd permutations alternately.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Permutations<T> {\n     swaps: ElementSwaps,\n     v: Vec<T>,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T: Clone> Iterator for Permutations<T> {\n     type Item = Vec<T>;\n "}, {"sha": "63ae743b421b0ac15bdeb0d8587cb48693114b1e", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 93, "deletions": 64, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -50,7 +50,7 @@\n //! is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::RecompositionState::*;\n use self::DecompositionType::*;\n@@ -165,15 +165,15 @@ enum DecompositionType {\n /// External iterator for a string's decomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Decompositions<'a> {\n     kind: DecompositionType,\n     iter: Chars<'a>,\n     buffer: Vec<(char, u8)>,\n     sorted: bool\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Decompositions<'a> {\n     type Item = char;\n \n@@ -255,7 +255,7 @@ enum RecompositionState {\n /// External iterator for a string's recomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n@@ -264,7 +264,7 @@ pub struct Recompositions<'a> {\n     last_ccc: Option<u8>\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Recompositions<'a> {\n     type Item = char;\n \n@@ -352,12 +352,12 @@ impl<'a> Iterator for Recompositions<'a> {\n /// External iterator for a string's UTF16 codeunits.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Utf16Units<'a> {\n     type Item = u16;\n \n@@ -384,12 +384,12 @@ macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl BorrowFrom<String> for str {\n     fn borrow_from(owned: &String) -> &str { &owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl ToOwned<String> for str {\n     fn to_owned(&self) -> String {\n         unsafe {\n@@ -407,16 +407,18 @@ Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait StrExt: Index<FullRange, Output = str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n-    #[unstable = \"return type may change to be an iterator\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"return type may change to be an iterator\")]\n     fn escape_default(&self) -> String {\n         self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n-    #[unstable = \"return type may change to be an iterator\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"return type may change to be an iterator\")]\n     fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n@@ -445,7 +447,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn replace(&self, from: &str, to: &str) -> String {\n         let mut result = String::new();\n         let mut last_end = 0;\n@@ -461,7 +463,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n             iter: self[].chars(),\n@@ -474,7 +477,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n             iter: self[].chars(),\n@@ -487,7 +491,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -501,7 +506,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -523,7 +529,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"bananas\".contains(\"nana\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, pat: &str) -> bool {\n         core_str::StrExt::contains(&self[], pat)\n     }\n@@ -539,7 +545,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"hello\".contains_char('e'));\n     /// ```\n-    #[unstable = \"might get removed in favour of a more generic contains()\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"might get removed in favour of a more generic contains()\")]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n         core_str::StrExt::contains_char(&self[], pat)\n     }\n@@ -553,7 +560,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n         core_str::StrExt::chars(&self[])\n     }\n@@ -566,13 +573,13 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<u8> = \"bors\".bytes().collect();\n     /// assert_eq!(v, b\"bors\".to_vec());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(&self) -> Bytes {\n         core_str::StrExt::bytes(&self[])\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn char_indices(&self) -> CharIndices {\n         core_str::StrExt::char_indices(&self[])\n     }\n@@ -595,7 +602,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n         core_str::StrExt::split(&self[], pat)\n     }\n@@ -622,7 +629,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n         core_str::StrExt::splitn(&self[], count, pat)\n     }\n@@ -651,7 +658,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    #[unstable = \"might get removed\"]\n+    #[unstable(feature = \"collections\", reason = \"might get removed\")]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n         core_str::StrExt::split_terminator(&self[], pat)\n     }\n@@ -672,7 +679,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n         core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n@@ -697,7 +704,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n-    #[unstable = \"might have its iterator type changed\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"might have its iterator type changed\")]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n         core_str::StrExt::match_indices(&self[], pat)\n     }\n@@ -713,7 +721,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n-    #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"might get removed in the future in favor of a more generic split()\")]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n         core_str::StrExt::split_str(&self[], pat)\n     }\n@@ -729,7 +738,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n         core_str::StrExt::lines(&self[])\n     }\n@@ -745,21 +754,27 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines_any(&self) -> LinesAny {\n         core_str::StrExt::lines_any(&self[])\n     }\n \n     /// Deprecated: use `s[a .. b]` instead.\n-    #[deprecated = \"use slice notation [a..b] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n     fn slice(&self, begin: uint, end: uint) -> &str;\n \n     /// Deprecated: use `s[a..]` instead.\n-    #[deprecated = \"use slice notation [a..] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n     fn slice_from(&self, begin: uint) -> &str;\n \n     /// Deprecated: use `s[..a]` instead.\n-    #[deprecated = \"use slice notation [..a] instead\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n     fn slice_to(&self, end: uint) -> &str;\n \n     /// Returns a slice of the string from the character range\n@@ -785,7 +800,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n-    #[unstable = \"may have yet to prove its worth\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"may have yet to prove its worth\")]\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice_chars(&self[], begin, end)\n     }\n@@ -796,7 +812,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// Caller must check both UTF-8 character boundaries and the boundaries of\n     /// the entire slice as well.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n@@ -808,7 +824,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"banana\".starts_with(\"ba\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, pat: &str) -> bool {\n         core_str::StrExt::starts_with(&self[], pat)\n     }\n@@ -820,7 +836,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"banana\".ends_with(\"nana\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, pat: &str) -> bool {\n         core_str::StrExt::ends_with(&self[], pat)\n     }\n@@ -840,7 +856,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|&: c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_matches(&self[], pat)\n     }\n@@ -860,7 +876,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_left_matches(&self[], pat)\n     }\n@@ -880,7 +896,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_right_matches(&self[], pat)\n     }\n@@ -908,7 +924,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         core_str::StrExt::is_char_boundary(&self[], index)\n     }\n@@ -966,7 +983,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at(&self, start: uint) -> CharRange {\n         core_str::StrExt::char_range_at(&self[], start)\n     }\n@@ -981,7 +999,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[], start)\n     }\n@@ -1001,7 +1020,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_at(&self, i: uint) -> char {\n         core_str::StrExt::char_at(&self[], i)\n     }\n@@ -1012,7 +1032,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_at_reverse(&self, i: uint) -> char {\n         core_str::StrExt::char_at_reverse(&self[], i)\n     }\n@@ -1024,7 +1045,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8] {\n         core_str::StrExt::as_bytes(&self[])\n     }\n@@ -1052,7 +1073,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.find(x), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n         core_str::StrExt::find(&self[], pat)\n     }\n@@ -1080,7 +1101,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n         core_str::StrExt::rfind(&self[], pat)\n     }\n@@ -1104,7 +1125,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n     /// assert_eq!(s.find_str(\"muffin man\"), None);\n     /// ```\n-    #[unstable = \"might get removed in favor of a more generic find in the future\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"might get removed in favor of a more generic find in the future\")]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n         core_str::StrExt::find_str(&self[], needle)\n     }\n@@ -1127,7 +1149,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    #[unstable = \"awaiting conventions about shifting and slices\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"awaiting conventions about shifting and slices\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(&self[])\n     }\n@@ -1146,7 +1169,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n     /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n     /// ```\n-    #[unstable = \"awaiting convention about comparability of arbitrary slices\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"awaiting convention about comparability of arbitrary slices\")]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         core_str::StrExt::subslice_offset(&self[], inner)\n     }\n@@ -1156,14 +1180,15 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// The caller must ensure that the string outlives this pointer,\n     /// and that it is not reallocated (e.g. by pushing to the\n     /// string).\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n         core_str::StrExt::as_ptr(&self[])\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn utf16_units(&self) -> Utf16Units {\n         Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n     }\n@@ -1176,7 +1201,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"foo\".len(), 3);\n     /// assert_eq!(\"\u0192oo\".len(), 4);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn len(&self) -> uint {\n         core_str::StrExt::len(&self[])\n@@ -1190,7 +1215,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert!(\"\".is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool {\n         core_str::StrExt::is_empty(&self[])\n     }\n@@ -1204,7 +1229,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"j\".parse::<u32>(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"this method was just created\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this method was just created\")]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n         core_str::StrExt::parse(&self[])\n     }\n@@ -1228,7 +1254,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n         UnicodeStr::graphemes(&self[], is_extended)\n     }\n@@ -1243,7 +1270,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         UnicodeStr::grapheme_indices(&self[], is_extended)\n     }\n@@ -1259,7 +1287,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = some_words.words().collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn words(&self) -> Words {\n         UnicodeStr::words(&self[])\n     }\n@@ -1273,31 +1301,32 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the locale is unknown.\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn width(&self, is_cjk: bool) -> uint {\n         UnicodeStr::width(&self[], is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str {\n         UnicodeStr::trim(&self[])\n     }\n \n     /// Returns a string with leading whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str {\n         UnicodeStr::trim_left(&self[])\n     }\n \n     /// Returns a string with trailing whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(&self[])\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl StrExt for str {\n     fn slice(&self, begin: uint, end: uint) -> &str {\n         &self[begin..end]"}, {"sha": "5189b825f1615230e384ea1fb4c3ad4914d68e52", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 64, "deletions": 60, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,7 @@\n \n //! An owned, growable string that enforces that its contents are valid UTF-8.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -34,21 +34,21 @@ use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n #[derive(Clone, PartialOrd, Eq, Ord)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct String {\n     vec: Vec<u8>,\n }\n \n /// A possible error value from the `String::from_utf8` function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Show)]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n }\n \n /// A possible error value from the `String::from_utf16` function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(missing_copy_implementations)]\n #[derive(Show)]\n pub struct FromUtf16Error(());\n@@ -62,7 +62,7 @@ impl String {\n     /// let mut s = String::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> String {\n         String {\n             vec: Vec::new(),\n@@ -79,7 +79,7 @@ impl String {\n     /// let mut s = String::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> String {\n         String {\n             vec: Vec::with_capacity(capacity),\n@@ -95,7 +95,8 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n-    #[unstable = \"needs investigation to see if to_string() can match perf\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"needs investigation to see if to_string() can match perf\")]\n     pub fn from_str(string: &str) -> String {\n         String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n     }\n@@ -123,7 +124,7 @@ impl String {\n     /// assert_eq!(s.into_bytes(), vec![240, 144, 128]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(vec.as_slice()) {\n             Ok(..) => Ok(String { vec: vec }),\n@@ -141,7 +142,7 @@ impl String {\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n         let mut i = 0;\n         match str::from_utf8(v) {\n@@ -279,7 +280,7 @@ impl String {\n     /// v[4] = 0xD800;\n     /// assert!(String::from_utf16(v).is_err());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n         let mut s = String::with_capacity(v.len());\n         for c in unicode_str::utf16_items(v) {\n@@ -306,7 +307,7 @@ impl String {\n     ///            \"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\".to_string());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n         unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n@@ -317,7 +318,7 @@ impl String {\n     /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n         String {\n             vec: Vec::from_raw_parts(buf, length, capacity),\n@@ -328,7 +329,7 @@ impl String {\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n         String { vec: bytes }\n     }\n@@ -343,7 +344,7 @@ impl String {\n     /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.vec\n     }\n@@ -358,7 +359,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"foobar\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n@@ -373,7 +374,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n@@ -394,7 +395,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.vec.reserve(additional)\n     }\n@@ -419,7 +420,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.vec.reserve_exact(additional)\n     }\n@@ -436,7 +437,7 @@ impl String {\n     /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n@@ -453,7 +454,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"abc123\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, ch: char) {\n         if (ch as u32) < 0x80 {\n             self.vec.push(ch as u8);\n@@ -486,7 +487,7 @@ impl String {\n     /// assert_eq!(s.as_bytes(), b);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.vec.as_slice()\n     }\n@@ -506,7 +507,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, new_len: uint) {\n         assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n@@ -525,7 +526,7 @@ impl String {\n     /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n@@ -561,7 +562,7 @@ impl String {\n     /// assert_eq!(s.remove(0), 'o');\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, idx: uint) -> char {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -588,7 +589,7 @@ impl String {\n     /// If `idx` does not lie on a character boundary or is out of bounds, then\n     /// this function will panic.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -625,7 +626,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n@@ -639,7 +640,7 @@ impl String {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.vec.len() }\n \n     /// Returns true if the string contains no bytes\n@@ -653,7 +654,7 @@ impl String {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Truncates the string, returning it to 0 length.\n@@ -666,7 +667,7 @@ impl String {\n     /// assert!(s.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.vec.clear()\n     }\n@@ -675,39 +676,39 @@ impl String {\n impl FromUtf8Error {\n     /// Consume this error, returning the bytes that were attempted to make a\n     /// `String` with.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n \n     /// Access the underlying UTF8-error that was the cause of this error.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn utf8_error(&self) -> Utf8Error { self.error }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.error, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for FromUtf8Error {\n     fn description(&self) -> &str { \"invalid utf-8\" }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for FromUtf16Error {\n     fn description(&self) -> &str { \"invalid utf-16\" }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -716,7 +717,7 @@ impl FromIterator<char> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n     fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -725,7 +726,8 @@ impl<'a> FromIterator<&'a str> for String {\n     }\n }\n \n-#[unstable = \"waiting on Extend stabilization\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"waiting on Extend stabilization\")]\n impl Extend<char> for String {\n     fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) {\n         let (lower_bound, _) = iterator.size_hint();\n@@ -736,7 +738,8 @@ impl Extend<char> for String {\n     }\n }\n \n-#[unstable = \"waiting on Extend stabilization\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"waiting on Extend stabilization\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) {\n         // A guess that at least one byte per iterator element will be needed.\n@@ -748,7 +751,7 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for String {\n     #[inline]\n     fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -758,15 +761,15 @@ impl PartialEq for String {\n \n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -780,65 +783,66 @@ macro_rules! impl_eq {\n impl_eq! { String, &'a str }\n impl_eq! { CowString<'a>, String }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n     #[inline]\n     fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n     #[inline]\n     fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[unstable = \"waiting on Str stabilization\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n impl Str for String {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for String {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> String {\n         String::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-#[unstable = \"waiting on Hash stabilization\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Hash stabilization\")]\n impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n \n-#[unstable = \"recent addition, needs more experience\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"recent addition, needs more experience\")]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n \n@@ -849,31 +853,31 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::Range<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n         &self[][*index]\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeTo<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n         &self[][*index]\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFrom<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n         &self[][*index]\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::FullRange> for String {\n     type Output = str;\n     #[inline]\n@@ -882,7 +886,7 @@ impl ops::Index<ops::FullRange> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for String {\n     type Target = str;\n \n@@ -893,7 +897,7 @@ impl ops::Deref for String {\n }\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n@@ -921,7 +925,7 @@ impl<'a> Deref for DerefString<'a> {\n /// let string = as_string(\"foo\").clone();\n /// string_consumer(string);\n /// ```\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n@@ -965,7 +969,7 @@ impl<'a> IntoCow<'a, String, str> for &'a str {\n }\n \n /// A clone-on-write string\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type CowString<'a> = Cow<'a, String, str>;\n \n impl<'a> Str for CowString<'a> {"}, {"sha": "c44dfff9117d9f807e08489fb44595af4e3c1476", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 81, "deletions": 71, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -44,7 +44,7 @@\n //! let two = xs.pop();\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -134,7 +134,7 @@ use core::uint;\n /// to reallocate, which can be slow. For this reason, it is recommended to use\n /// `Vec::with_capacity` whenever possible to specify how big the vector is expected to get.\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     ptr: NonZero<*mut T>,\n     len: uint,\n@@ -159,7 +159,7 @@ impl<T> Vec<T> {\n     /// let mut vec: Vec<int> = Vec::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Vec<T> {\n         // We want ptr to never be NULL so instead we set it to some arbitrary\n         // non-null value which is fine since we never call deallocate on the ptr\n@@ -194,7 +194,7 @@ impl<T> Vec<T> {\n     /// vec.push(11);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n             Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: uint::MAX }\n@@ -243,7 +243,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n@@ -255,7 +255,8 @@ impl<T> Vec<T> {\n     /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n     /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable = \"may be better expressed via composition\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"may be better expressed via composition\")]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n@@ -273,7 +274,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.cap\n     }\n@@ -292,7 +293,7 @@ impl<T> Vec<T> {\n     /// vec.reserve(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n             let err_msg = \"Vec::reserve: `uint` overflow\";\n@@ -321,7 +322,7 @@ impl<T> Vec<T> {\n     /// vec.reserve_exact(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n             match self.len.checked_add(additional) {\n@@ -345,7 +346,7 @@ impl<T> Vec<T> {\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -376,7 +377,7 @@ impl<T> Vec<T> {\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n     /// `shrink_to_fit()`.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n@@ -398,7 +399,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -422,7 +423,7 @@ impl<T> Vec<T> {\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -446,7 +447,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = *self.ptr;\n@@ -477,7 +478,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n     }\n@@ -503,7 +504,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap_remove(&mut self, index: uint) -> T {\n         let length = self.len();\n         self.swap(index, length - 1);\n@@ -527,7 +528,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -563,7 +564,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v.remove(1), 2);\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: uint) -> T {\n         let len = self.len();\n         assert!(index < len);\n@@ -597,7 +598,7 @@ impl<T> Vec<T> {\n     /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n         let mut del = 0u;\n@@ -631,7 +632,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the\n@@ -669,7 +670,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         if self.len == 0 {\n             None\n@@ -696,7 +697,8 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec2, vec![]);\n     /// ```\n     #[inline]\n-    #[unstable = \"new API, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the\n@@ -732,7 +734,8 @@ impl<T> Vec<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n             let begin = *self.ptr as *const T;\n@@ -762,7 +765,7 @@ impl<T> Vec<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.truncate(0)\n     }\n@@ -776,7 +779,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.len }\n \n     /// Returns `true` if the vector contains no elements.\n@@ -790,7 +793,7 @@ impl<T> Vec<T> {\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n@@ -814,7 +817,8 @@ impl<T> Vec<T> {\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n     /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n-    #[unstable = \"API may change to provide stronger guarantees\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"API may change to provide stronger guarantees\")]\n     pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n         // FIXME: Assert statically that the types `T` and `U` have the same\n         // size.\n@@ -1008,7 +1012,8 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification; waiting for dust to settle\")]\n     pub fn resize(&mut self, new_len: uint, value: T) {\n         let len = self.len();\n \n@@ -1032,7 +1037,8 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[unstable = \"likely to be replaced by a more optimized extend\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be replaced by a more optimized extend\")]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n@@ -1066,7 +1072,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1200,7 +1206,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }\n \n@@ -1229,7 +1235,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1239,7 +1245,7 @@ impl<T> Index<uint> for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IndexMut<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1250,31 +1256,31 @@ impl<T> IndexMut<uint> for Vec<T> {\n }\n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1283,31 +1289,31 @@ impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1316,19 +1322,19 @@ impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n     fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n@@ -1341,7 +1347,7 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on Extend stability\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n@@ -1416,18 +1422,19 @@ macro_rules! impl_eq_for_cowvec {\n impl_eq_for_cowvec! { &'b [B] }\n impl_eq_for_cowvec! { &'b mut [B] }\n \n-#[unstable = \"waiting on PartialOrd stability\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"waiting on PartialOrd stability\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(other.as_slice())\n     }\n }\n \n-#[unstable = \"waiting on Eq stability\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Eq stability\")]\n impl<T: Eq> Eq for Vec<T> {}\n \n-#[unstable = \"waiting on Ord stability\"]\n+#[unstable(feature = \"collections\", reason = \"waiting on Ord stability\")]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n@@ -1447,7 +1454,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -1458,7 +1465,8 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n-#[unstable = \"recent addition, needs more experience\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"recent addition, needs more experience\")]\n impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n     type Output = Vec<T>;\n \n@@ -1470,7 +1478,7 @@ impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n@@ -1486,15 +1494,15 @@ impl<T> Drop for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Vec<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Vec<T> {\n         Vec::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(self.as_slice(), f)\n@@ -1512,11 +1520,12 @@ impl<'a> fmt::Writer for Vec<u8> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"unclear how valuable this alias is\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"unclear how valuable this alias is\")]\n /// A clone-on-write vector\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n     fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n         Cow::Owned(FromIterator::from_iter(it))\n@@ -1540,7 +1549,7 @@ impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// An iterator that moves out of a vector.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n@@ -1554,7 +1563,7 @@ unsafe impl<T: Sync> Sync for IntoIter<T> { }\n impl<T> IntoIter<T> {\n     #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n-    #[unstable]\n+    #[unstable(feature = \"collections\")]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n@@ -1565,7 +1574,7 @@ impl<T> IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1602,7 +1611,7 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n@@ -1626,11 +1635,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n@@ -1645,14 +1654,15 @@ impl<T> Drop for IntoIter<T> {\n \n /// An iterator that drains a vector.\n #[unsafe_no_drop_flag]\n-#[unstable = \"recently added as part of collections reform 2\"]\n+#[unstable(feature = \"collections\",\n+           reason = \"recently added as part of collections reform 2\")]\n pub struct Drain<'a, T> {\n     ptr: *const T,\n     end: *const T,\n     marker: ContravariantLifetime<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1689,7 +1699,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n@@ -1713,11 +1723,11 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // self.ptr == self.end == null if drop has already been called,\n@@ -1733,13 +1743,13 @@ impl<'a, T> Drop for Drain<'a, T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct DerefVec<'a, T> {\n     x: Vec<T>,\n     l: ContravariantLifetime<'a>\n }\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<'a, T> Deref for DerefVec<'a, T> {\n     type Target = Vec<T>;\n \n@@ -1750,7 +1760,7 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;\n@@ -1759,7 +1769,7 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n }\n \n /// Convert a slice to a wrapper type providing a `&Vec<T>` reference.\n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {"}, {"sha": "3d28284c9bf97e55245fea7c0f6d68e6805bb9a3", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -66,9 +66,9 @@ pub struct VecMap<V> {\n     v: Vec<Option<V>>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Default for VecMap<V> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn default() -> VecMap<V> { VecMap::new() }\n }\n@@ -107,7 +107,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> VecMap<V> { VecMap { v: vec![] } }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n@@ -119,7 +119,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n@@ -135,7 +135,7 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.v.capacity()\n     }\n@@ -154,7 +154,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -178,7 +178,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len_exact(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -188,7 +188,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all keys in ascending order of the keys.\n     /// The iterator's element type is `uint`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n@@ -198,7 +198,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all values in ascending order of the keys.\n     /// The iterator's element type is `&'r V`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n@@ -224,7 +224,7 @@ impl<V> VecMap<V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n         Iter {\n             front: 0,\n@@ -255,7 +255,7 @@ impl<V> VecMap<V> {\n     ///     assert_eq!(value, &\"x\");\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n         IterMut {\n             front: 0,\n@@ -282,7 +282,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n@@ -310,7 +310,8 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n@@ -332,7 +333,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n@@ -349,7 +350,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n@@ -366,7 +367,7 @@ impl<V> VecMap<V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.v.clear() }\n \n     /// Returns a reference to the value corresponding to the key.\n@@ -381,7 +382,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, key: &uint) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -406,7 +407,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key(&self, key: &uint) -> bool {\n         self.get(key).is_some()\n     }\n@@ -426,7 +427,7 @@ impl<V> VecMap<V> {\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n@@ -454,7 +455,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n@@ -476,7 +477,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, key: &uint) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n@@ -486,33 +487,33 @@ impl<V> VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: PartialEq> PartialEq for VecMap<V> {\n     fn eq(&self, other: &VecMap<V>) -> bool {\n         iter::order::eq(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: Eq> Eq for VecMap<V> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: PartialOrd> PartialOrd for VecMap<V> {\n     #[inline]\n     fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: Ord> Ord for VecMap<V> {\n     #[inline]\n     fn cmp(&self, other: &VecMap<V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"VecMap {{\"));\n@@ -526,7 +527,7 @@ impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     fn from_iter<Iter: Iterator<Item=(uint, V)>>(iter: Iter) -> VecMap<V> {\n         let mut map = VecMap::new();\n@@ -535,7 +536,7 @@ impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {\n         for (k, v) in iter {\n@@ -553,7 +554,7 @@ impl<V> Index<uint> for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> IndexMut<uint> for VecMap<V> {\n     type Output = V;\n \n@@ -565,7 +566,7 @@ impl<V> IndexMut<uint> for VecMap<V> {\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, V> Iterator for $name<'a, V> {\n             type Item = $elem;\n \n@@ -600,7 +601,7 @@ macro_rules! iterator {\n \n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, V> DoubleEndedIterator for $name<'a, V> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -626,7 +627,7 @@ macro_rules! double_ended_iterator {\n }\n \n /// An iterator over the key-value pairs of a map.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -649,7 +650,7 @@ double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -660,7 +661,7 @@ iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, V: 'a> {\n     iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n@@ -675,7 +676,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n }\n \n /// An iterator over the values of a map.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, V: 'a> {\n     iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n@@ -690,7 +691,7 @@ impl<'a, V> Clone for Values<'a, V> {\n }\n \n /// A consuming iterator over the key-value pairs of a map.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -699,7 +700,7 @@ pub struct IntoIter<V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n pub struct Drain<'a, V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -708,51 +709,51 @@ pub struct Drain<'a, V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<'a, V> Iterator for Drain<'a, V> {\n     type Item = (uint, V);\n \n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable]\n+#[unstable(feature = \"collections\")]\n impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Keys<'a, V> {\n     type Item = uint;\n \n     fn next(&mut self) -> Option<uint> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Keys<'a, V> {\n     fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Values<'a, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Iterator for IntoIter<V> {\n     type Item = (uint, V);\n \n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> DoubleEndedIterator for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }"}, {"sha": "87030ed778da767d7139dffd54a6d1c85b2785db", "filename": "src/libcore/any.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -69,7 +69,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use mem::transmute;\n use option::Option::{self, Some, None};\n@@ -86,10 +86,11 @@ use marker::Sized;\n ///\n /// Every type with no non-`'static` references implements `Any`, so `Any` can\n /// be used as a trait object to emulate the effects dynamic typing.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n-    #[unstable = \"this method will likely be replaced by an associated static\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;\n }\n \n@@ -103,7 +104,7 @@ impl<T: 'static> Any for T {\n \n impl Any {\n     /// Returns true if the boxed type is the same as `T`\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: 'static>(&self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n@@ -118,7 +119,7 @@ impl Any {\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n         if self.is::<T>() {\n@@ -136,7 +137,7 @@ impl Any {\n \n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n@@ -167,15 +168,16 @@ impl Any {\n /// but this limitation may be removed in the future.\n #[cfg_attr(stage0, lang = \"type_id\")]\n #[derive(Clone, Copy, PartialEq, Eq, Show, Hash)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,\n }\n \n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with\n-    #[unstable = \"may grow a `Reflect` bound soon via marker traits\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"may grow a `Reflect` bound soon via marker traits\")]\n     pub fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },"}, {"sha": "44541c34ee278fb6637a586502994b4ac716424d", "filename": "src/libcore/array.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,7 @@\n //! up to a certain length. Eventually we should able to generalize\n //! to all lengths.\n \n-#![unstable] // not yet reviewed\n+#![unstable(feature = \"core\")] // not yet reviewed\n \n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n@@ -26,7 +26,7 @@ use option::Option;\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {\n                     *self\n@@ -39,14 +39,14 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                     fmt::Debug::fmt(&&self[], f)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n@@ -58,7 +58,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; $N] where\n                 A: PartialEq<B>,\n                 Rhs: Deref<Target=[B]>,\n@@ -73,7 +73,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<'a, A, B, Lhs> PartialEq<[B; $N]> for Lhs where\n                 A: PartialEq<B>,\n                 Lhs: Deref<Target=[A]>\n@@ -88,10 +88,10 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Eq> Eq for [T; $N] { }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n@@ -115,7 +115,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {"}, {"sha": "cf2854be016e1da9b9c9d17fab2e136d0b299743", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -68,7 +68,7 @@\n //! println!(\"live tasks: {}\", old_task_count + 1);\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Ordering::*;\n \n@@ -78,31 +78,31 @@ use intrinsics;\n use cell::UnsafeCell;\n \n /// A boolean type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicBool {\n     v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicBool {}\n \n /// A signed integer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicIsize {\n     v: UnsafeCell<isize>,\n }\n \n unsafe impl Sync for AtomicIsize {}\n \n /// An unsigned integer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicUsize {\n     v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicUsize {}\n \n /// A raw pointer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<usize>,\n }\n@@ -119,42 +119,42 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n ///\n /// Rust's memory orderings are [the same as\n /// C++'s](http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n     /// on the same value.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n     /// in another thread.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n     /// `Release` ordering.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n }\n \n /// An `AtomicBool` initialized to `false`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicIsize` initialized to `0`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_ISIZE_INIT: AtomicIsize =\n         AtomicIsize { v: UnsafeCell { value: 0 } };\n /// An `AtomicUsize` initialized to `0`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_USIZE_INIT: AtomicUsize =\n         AtomicUsize { v: UnsafeCell { value: 0, } };\n \n@@ -173,7 +173,7 @@ impl AtomicBool {\n     /// let atomic_false = AtomicBool::new(false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val) }\n@@ -197,7 +197,7 @@ impl AtomicBool {\n     /// let value = some_bool.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get(), order) > 0 }\n     }\n@@ -220,7 +220,7 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -241,7 +241,7 @@ impl AtomicBool {\n     /// let value = some_bool.swap(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -265,7 +265,7 @@ impl AtomicBool {\n     /// let value = some_bool.store(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n@@ -298,7 +298,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -331,7 +331,7 @@ impl AtomicBool {\n     /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -363,7 +363,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -395,15 +395,15 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AtomicIsize {\n     /// Creates a new `AtomicIsize`.\n     ///\n@@ -580,7 +580,7 @@ impl AtomicIsize {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AtomicUsize {\n     /// Creates a new `AtomicUsize`.\n     ///\n@@ -769,7 +769,7 @@ impl<T> AtomicPtr<T> {\n     /// let atomic_ptr  = AtomicPtr::new(ptr);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as usize) }\n     }\n@@ -793,7 +793,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_load(self.p.get(), order) as *mut T\n@@ -821,7 +821,7 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(self.p.get(), ptr as usize, order); }\n     }\n@@ -843,7 +843,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as usize, order) as *mut T }\n     }\n@@ -869,7 +869,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_compare_and_swap(self.p.get(), old as usize,\n@@ -890,7 +890,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n@@ -902,7 +902,7 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -915,7 +915,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -928,7 +928,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -940,7 +940,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n@@ -952,7 +952,7 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -964,7 +964,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -977,7 +977,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -990,7 +990,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -1023,7 +1023,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// Panics if `order` is `Relaxed`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn fence(order: Ordering) {\n     unsafe {\n         match order {\n@@ -1036,27 +1036,35 @@ pub fn fence(order: Ordering) {\n     }\n }\n \n-#[deprecated=\"renamed to AtomicIsize\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"renamed to AtomicIsize\")]\n #[allow(missing_docs)]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n }\n \n unsafe impl Sync for AtomicInt {}\n \n-#[deprecated=\"renamed to AtomicUsize\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"renamed to AtomicUsize\")]\n #[allow(missing_docs)]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n }\n \n unsafe impl Sync for AtomicUint {}\n \n-#[deprecated=\"use ATOMIC_ISIZE_INIT instead\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use ATOMIC_ISIZE_INIT instead\")]\n #[allow(missing_docs, deprecated)]\n pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n-#[deprecated=\"use ATOMIC_USIZE_INIT instead\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use ATOMIC_USIZE_INIT instead\")]\n #[allow(missing_docs, deprecated)]\n pub const ATOMIC_UINT_INIT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, } };"}, {"sha": "be144b052c7867056ab49a61770531a4b1aedf46", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -42,7 +42,8 @@\n //! is desired, `to_mut` will obtain a mutable references to an owned\n //! value, cloning if necessary.\n \n-#![unstable = \"recently added as part of collections reform\"]\n+#![unstable(feature = \"core\",\n+            reason = \"recently added as part of collections reform\")]\n \n use clone::Clone;\n use cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n@@ -141,7 +142,7 @@ pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n         match *self {\n@@ -195,7 +196,7 @@ impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     type Target = B;\n \n@@ -207,18 +208,18 @@ impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n@@ -229,15 +230,15 @@ impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T,\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> fmt::Debug for Cow<'a, T, B> where\n     B: fmt::Debug + ToOwned<T>,\n     T: fmt::Debug,\n@@ -250,7 +251,7 @@ impl<'a, T, B: ?Sized> fmt::Debug for Cow<'a, T, B> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> fmt::Display for Cow<'a, T, B> where\n     B: fmt::Display + ToOwned<T>,\n     T: fmt::Display,"}, {"sha": "02cc4038a69bc7b140bcf527a81d58d87bb4374a", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -139,7 +139,7 @@\n //! ```\n //!\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n use cmp::PartialEq;\n@@ -152,7 +152,7 @@ use option::Option::{None, Some};\n /// A mutable memory location that admits only `Copy` data.\n ///\n /// See the [module-level documentation](../index.html) for more.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n }\n@@ -167,7 +167,7 @@ impl<T:Copy> Cell<T> {\n     ///\n     /// let c = Cell::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n@@ -186,7 +186,7 @@ impl<T:Copy> Cell<T> {\n     /// let five = c.get();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n@@ -203,7 +203,7 @@ impl<T:Copy> Cell<T> {\n     /// c.set(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set(&self, value: T) {\n         unsafe {\n             *self.value.get() = value;\n@@ -226,31 +226,31 @@ impl<T:Copy> Cell<T> {\n     /// let uc = unsafe { c.as_unsafe_cell() };\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for Cell<T> where T: Send {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Copy> Clone for Cell<T> {\n     fn clone(&self) -> Cell<T> {\n         Cell::new(self.get())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default + Copy> Default for Cell<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Cell<T> {\n         Cell::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n         self.get() == other.get()\n@@ -260,7 +260,7 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n /// A mutable memory location with dynamically checked borrow rules\n ///\n /// See the [module-level documentation](../index.html) for more.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n@@ -282,7 +282,7 @@ impl<T> RefCell<T> {\n     ///\n     /// let c = RefCell::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n@@ -301,7 +301,7 @@ impl<T> RefCell<T> {\n     ///\n     /// let five = c.into_inner();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n         // compiler statically verifies that it is not currently borrowed.\n@@ -316,7 +316,7 @@ impl<T> RefCell<T> {\n     /// immutable borrows can be taken out at the same time.\n     ///\n     /// Returns `None` if the value is currently mutably borrowed.\n-    #[unstable = \"may be renamed or removed\"]\n+    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n@@ -359,7 +359,7 @@ impl<T> RefCell<T> {\n     ///\n     /// assert!(result.is_err());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n             Some(ptr) => ptr,\n@@ -373,7 +373,7 @@ impl<T> RefCell<T> {\n     /// cannot be borrowed while this borrow is active.\n     ///\n     /// Returns `None` if the value is currently borrowed.\n-    #[unstable = \"may be renamed or removed\"]\n+    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n@@ -415,7 +415,7 @@ impl<T> RefCell<T> {\n     ///\n     /// assert!(result.is_err());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n             Some(ptr) => ptr,\n@@ -429,31 +429,31 @@ impl<T> RefCell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for RefCell<T> where T: Send {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default> Default for RefCell<T> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> RefCell<T> {\n         RefCell::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for RefCell<T> {\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -496,18 +496,19 @@ impl<'b> Clone for BorrowRef<'b> {\n     }\n }\n \n+/// Wraps a borrowed reference to a value in a `RefCell` box.\n /// A wrapper type for an immutably borrowed value from a `RefCell<T>`.\n ///\n /// See the [module-level documentation](../index.html) for more.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b T,\n     _borrow: BorrowRef<'b>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> Deref for Ref<'b, T> {\n     type Target = T;\n \n@@ -523,7 +524,8 @@ impl<'b, T> Deref for Ref<'b, T> {\n ///\n /// A `Clone` implementation would interfere with the widespread\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n-#[unstable = \"likely to be moved to a method, pending language changes\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be moved to a method, pending language changes\")]\n pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     Ref {\n         _value: orig._value,\n@@ -559,15 +561,15 @@ impl<'b> BorrowRefMut<'b> {\n /// A wrapper type for a mutably borrowed value from a `RefCell<T>`.\n ///\n /// See the [module-level documentation](../index.html) for more.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b mut T,\n     _borrow: BorrowRefMut<'b>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> Deref for RefMut<'b, T> {\n     type Target = T;\n \n@@ -577,7 +579,7 @@ impl<'b, T> Deref for RefMut<'b, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n@@ -619,13 +621,13 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n /// **NOTE:** `UnsafeCell<T>`'s fields are public to allow static initializers. It is not\n /// recommended to access its fields directly, `get` should be used instead.\n #[lang=\"unsafe\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UnsafeCell<T> {\n     /// Wrapped value\n     ///\n     /// This field should not be accessed directly, it is made public for static\n     /// initializers.\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub value: T,\n }\n \n@@ -643,7 +645,7 @@ impl<T> UnsafeCell<T> {\n     ///\n     /// let uc = UnsafeCell::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n@@ -660,7 +662,7 @@ impl<T> UnsafeCell<T> {\n     /// let five = uc.get();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n@@ -680,6 +682,6 @@ impl<T> UnsafeCell<T> {\n     /// let five = unsafe { uc.into_inner() };\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn into_inner(self) -> T { self.value }\n }"}, {"sha": "22bfd47893c973700a20b7529a86af892cfd04c6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -64,12 +64,12 @@ static MAX_THREE_B: u32 =  0x10000u32;\n */\n \n /// The highest valid code point\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: char = '\\u{10ffff}';\n \n /// Converts from `u32` to a `char`\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_u32(i: u32) -> Option<char> {\n     // catch out-of-bounds and surrogates\n     if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n@@ -92,7 +92,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// Panics if given an `radix` > 36.\n ///\n #[inline]\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n@@ -111,7 +111,7 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n }\n \n /// Basic `char` manipulations.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CharExt {\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -126,7 +126,8 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool;\n \n     /// Converts a character to the corresponding digit.\n@@ -140,7 +141,8 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape\n@@ -149,7 +151,7 @@ pub trait CharExt {\n     /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n     /// where `NNNN` is the shortest hexadecimal representation of the code\n     /// point.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n@@ -164,44 +166,46 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool {\n         self.to_digit(radix).is_some()\n     }\n \n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint> {\n         if radix > 36 {\n             panic!(\"to_digit: radix is too high (maximum 36)\");\n@@ -216,12 +220,12 @@ impl CharExt for char {\n         else { None }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode {\n         EscapeUnicode { c: self, state: EscapeUnicodeState::Backslash }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault {\n         let init_state = match self {\n             '\\t' => EscapeDefaultState::Backslash('t'),\n@@ -237,7 +241,7 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint {\n         let code = self as u32;\n         match () {\n@@ -249,20 +253,22 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint {\n         let ch = self as u32;\n         if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n     }\n \n     #[inline]\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n         encode_utf8_raw(self as u32, dst)\n     }\n \n     #[inline]\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n         encode_utf16_raw(self as u32, dst)\n     }\n@@ -274,7 +280,7 @@ impl CharExt for char {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if code < MAX_ONE_B && dst.len() >= 1 {\n@@ -306,7 +312,7 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n@@ -327,14 +333,14 @@ pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n /// An iterator over the characters that represent a `char`, as escaped by\n /// Rust's unicode escaping rules.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeUnicode {\n     c: char,\n     state: EscapeUnicodeState\n }\n \n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -344,7 +350,7 @@ enum EscapeUnicodeState {\n     Done,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeUnicode {\n     type Item = char;\n \n@@ -390,21 +396,21 @@ impl Iterator for EscapeUnicode {\n /// An iterator over the characters that represent a `char`, escaped\n /// for maximum portability.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n     state: EscapeDefaultState\n }\n \n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),\n     Done,\n     Unicode(EscapeUnicode),\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeDefault {\n     type Item = char;\n "}, {"sha": "28c306fc0099f2bce5cbf9a73138e11b703d1551", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -19,15 +19,15 @@\n //! explicitly, by convention implementing the `Clone` trait and calling\n //! the `clone` method.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n \n /// A common trait for cloning an object.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn clone(&self) -> Self;\n \n     /// Perform copy-assignment from `source`.\n@@ -36,13 +36,14 @@ pub trait Clone : Sized {\n     /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n     /// allocations.\n     #[inline(always)]\n-    #[unstable = \"this function is rarely used\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"this function is rarely used\")]\n     fn clone_from(&mut self, source: &Self) {\n         *self = source.clone()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n@@ -51,7 +52,7 @@ impl<'a, T: ?Sized> Clone for &'a T {\n \n macro_rules! clone_impl {\n     ($t:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Clone for $t {\n             /// Return a deep copy of the value.\n             #[inline]\n@@ -81,7 +82,8 @@ clone_impl! { char }\n \n macro_rules! extern_fn_clone {\n     ($($A:ident),*) => (\n-        #[unstable = \"this may not be sufficient for fns with region parameters\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"this may not be sufficient for fns with region parameters\")]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Return a copy of a function pointer\n             #[inline]"}, {"sha": "2ecbd55fcb1d542c830ab1d351baa254b824eea3", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -39,7 +39,7 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Ordering::*;\n \n@@ -68,16 +68,16 @@ use option::Option::{self, Some, None};\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n #[lang=\"eq\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[old_orphan_check]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq(&self, other: &Rhs) -> bool;\n \n     /// This method tests for `!=`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n \n@@ -90,7 +90,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -106,16 +106,16 @@ pub trait Eq: PartialEq<Self> {\n \n /// An ordering is, e.g, a result of a comparison between two values.\n #[derive(Clone, Copy, PartialEq, Show)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Ordering {\n     /// An ordering where a compared value is less [than another].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Less = -1,\n     /// An ordering where a compared value is equal [to another].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Equal = 0,\n     /// An ordering where a compared value is greater [than another].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Greater = 1,\n }\n \n@@ -141,7 +141,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reverse(self) -> Ordering {\n         unsafe {\n             // this compiles really nicely (to a single instruction);\n@@ -164,7 +164,7 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n@@ -178,26 +178,26 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(10.cmp(&5),  Greater);  // because 10 > 5\n     /// assert_eq!( 5.cmp(&5),  Equal);    // because 5 == 5\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for Ordering {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for Ordering {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ordering {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n         (*self as int).partial_cmp(&(*other as int))\n     }\n@@ -224,16 +224,16 @@ impl PartialOrd for Ordering {\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n #[lang=\"ord\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) => true,\n@@ -243,7 +243,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn le(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) | Some(Equal) => true,\n@@ -253,7 +253,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests greater than (`>`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) => true,\n@@ -263,7 +263,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ge(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) | Some(Equal) => true,\n@@ -274,14 +274,14 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n /// Compare and return the minimum of two values.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n@@ -290,7 +290,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) | Some(Equal) => Some(v1),\n@@ -303,7 +303,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) => Some(v2),\n@@ -322,7 +322,7 @@ mod impls {\n \n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n@@ -332,7 +332,7 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n@@ -346,7 +346,7 @@ mod impls {\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl Eq for $t {}\n         )*)\n     }\n@@ -355,7 +355,7 @@ mod impls {\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n@@ -378,15 +378,15 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n@@ -398,7 +398,7 @@ mod impls {\n \n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n@@ -410,13 +410,13 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n@@ -428,14 +428,14 @@ mod impls {\n \n     // & pointers\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n@@ -450,24 +450,24 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n@@ -482,23 +482,23 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }"}, {"sha": "d79b613f589495c92ef4f360c6103386af567e65", "filename": "src/libcore/default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -81,7 +81,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n /// A trait that types which have a useful default value should implement.\n ///\n@@ -97,7 +97,7 @@\n ///     bar: f32,\n /// }\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Default {\n     /// Returns the \"default value\" for a type.\n     ///\n@@ -131,16 +131,16 @@ pub trait Default {\n     ///     fn default() -> Kind { Kind::A }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Self;\n }\n \n macro_rules! default_impl {\n     ($t:ty, $v:expr) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Default for $t {\n             #[inline]\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             fn default() -> $t { $v }\n         }\n     }"}, {"sha": "71d5e88cccff70e9cd647e3bacf66ff9476eab09", "filename": "src/libcore/error.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -79,13 +79,14 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use prelude::*;\n use fmt::Display;\n \n /// Base functionality for all errors in Rust.\n-#[unstable = \"the exact API of this trait may change\"]\n+#[unstable(feature = \"core\",\n+           reason = \"the exact API of this trait may change\")]\n pub trait Error: Display {\n     /// A short description of the error; usually a static string.\n     fn description(&self) -> &str;\n@@ -95,14 +96,15 @@ pub trait Error: Display {\n }\n \n /// A trait for types that can be converted from a given error type `E`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait FromError<E> {\n     /// Perform the conversion.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_error(err: E) -> Self;\n }\n \n // Any type is convertable from itself\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<E> FromError<E> for E {\n     fn from_error(err: E) -> E {\n         err"}, {"sha": "0f444ef186f9abe37ec960601b91a334c3cc74d0", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -30,10 +30,12 @@\n //! })\n //! ```\n \n-#![deprecated = \"It is unclear if this module is more robust than implementing \\\n-                 Drop on a custom type, and this module is being removed with no \\\n-                 replacement. Use a custom Drop implementation to regain existing \\\n-                 functionality.\"]\n+#![unstable(feature = \"core\")]\n+#![deprecated(since = \"1.0.0\",\n+              reason = \"It is unclear if this module is more robust than implementing \\\n+                        Drop on a custom type, and this module is being removed with no \\\n+                        replacement. Use a custom Drop implementation to regain existing \\\n+                        functionality.\")]\n #![allow(deprecated)]\n \n use ops::{Drop, FnMut, FnOnce};"}, {"sha": "06428ad2f39a66e23b43e53c17c431bff45e8381", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 89, "deletions": 62, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -11,7 +11,7 @@\n //! Utilities for formatting and printing strings\n \n #![allow(unused_variables)]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any;\n use cell::{Cell, RefCell, Ref, RefMut};\n@@ -39,7 +39,8 @@ mod num;\n mod float;\n pub mod rt;\n \n-#[unstable = \"core and I/O reconciliation may alter this definition\"]\n+#[unstable(feature = \"core\",\n+           reason = \"core and I/O reconciliation may alter this definition\")]\n /// The type returned by formatter methods.\n pub type Result = result::Result<(), Error>;\n \n@@ -48,7 +49,8 @@ pub type Result = result::Result<(), Error>;\n /// This type does not support transmission of an error other than that an error\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n-#[unstable = \"core and I/O reconciliation may alter this definition\"]\n+#[unstable(feature = \"core\",\n+           reason = \"core and I/O reconciliation may alter this definition\")]\n #[derive(Copy, Show)]\n pub struct Error;\n \n@@ -61,7 +63,8 @@ pub struct Error;\n /// This trait should generally not be implemented by consumers of the standard\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n-#[unstable = \"waiting for core and I/O reconciliation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"waiting for core and I/O reconciliation\")]\n pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n@@ -104,7 +107,8 @@ pub trait Writer {\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n-#[unstable = \"name may change and implemented traits are also unstable\"]\n+#[unstable(feature = \"core\",\n+           reason = \"name may change and implemented traits are also unstable\")]\n pub struct Formatter<'a> {\n     flags: uint,\n     fill: char,\n@@ -126,7 +130,8 @@ enum Void {}\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"core\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n #[derive(Copy)]\n pub struct Argument<'a> {\n     value: &'a Void,\n@@ -165,7 +170,8 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[unstable = \"implementation detail of the `format_args!` macro\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"implementation detail of the `format_args!` macro\")]\n     pub fn new(pieces: &'a [&'a str],\n                args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n@@ -182,7 +188,8 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[unstable = \"implementation detail of the `format_args!` macro\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"implementation detail of the `format_args!` macro\")]\n     pub fn with_placeholders(pieces: &'a [&'a str],\n                              fmt: &'a [rt::Argument],\n                              args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -203,7 +210,7 @@ impl<'a> Arguments<'a> {\n /// and pass it to a function or closure, passed as the first argument. The\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub struct Arguments<'a> {\n     // Format string pieces to print.\n@@ -217,14 +224,14 @@ pub struct Arguments<'a> {\n     args: &'a [Argument<'a>],\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Debug for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         Display::fmt(self, fmt)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Display for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n@@ -233,7 +240,9 @@ impl<'a> Display for Arguments<'a> {\n \n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n-#[deprecated = \"renamed to Debug\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to Debug\")]\n #[cfg(not(stage0))]\n pub trait Show {\n     /// Formats the value using the given formatter.\n@@ -242,7 +251,8 @@ pub trait Show {\n \n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is defined in your \\\n                             crate, add `#[derive(Debug)]` or manually implement it\"]\n #[lang = \"debug_trait\"]\n@@ -259,7 +269,8 @@ impl<T: Show + ?Sized> Debug for T {\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[deprecated = \"renamed to Display\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to Display\")]\n #[cfg(not(stage0))]\n pub trait String {\n     /// Formats the value using the given formatter.\n@@ -268,7 +279,8 @@ pub trait String {\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default formatter; try using \\\n                             `:?` instead if you are using a format string\"]\n pub trait Display {\n@@ -283,49 +295,56 @@ impl<T: String + ?Sized> Display for T {\n }\n \n /// Format trait for the `o` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Octal {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `b` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `x` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait LowerHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `X` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait UpperHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `p` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `e` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait LowerExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `E` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait UpperExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -339,8 +358,9 @@ pub trait UpperExp {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n-#[unstable = \"libcore and I/O have yet to be reconciled, and this is an \\\n-                  implementation detail which should not otherwise be exported\"]\n+#[unstable(feature = \"core\",\n+           reason = \"libcore and I/O have yet to be reconciled, and this is an \\\n+                     implementation detail which should not otherwise be exported\")]\n pub fn write(output: &mut Writer, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n@@ -436,7 +456,8 @@ impl<'a> Formatter<'a> {\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n-    #[unstable = \"definition may change slightly over time\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"definition may change slightly over time\")]\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n                         prefix: &str,\n@@ -512,7 +533,8 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n-    #[unstable = \"definition may change slightly over time\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"definition may change slightly over time\")]\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n@@ -589,39 +611,42 @@ impl<'a> Formatter<'a> {\n \n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n-    #[unstable = \"reconciling core and I/O may alter this definition\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"reconciling core and I/O may alter this definition\")]\n     pub fn write_str(&mut self, data: &str) -> Result {\n         self.buf.write_str(data)\n     }\n \n     /// Writes some formatted information into this instance\n-    #[unstable = \"reconciling core and I/O may alter this definition\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"reconciling core and I/O may alter this definition\")]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n \n     /// Flags for formatting (packed version of rt::Flag)\n-    #[unstable = \"return type may change and method was just created\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"return type may change and method was just created\")]\n     pub fn flags(&self) -> uint { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn fill(&self) -> char { self.fill }\n \n     /// Flag indicating what form of alignment was requested\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn align(&self) -> rt::Alignment { self.align }\n \n     /// Optionally specified integer width that the output should be\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn width(&self) -> Option<uint> { self.width }\n \n     /// Optionally specified precision for numeric types\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn precision(&self) -> Option<uint> { self.precision }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Display::fmt(\"an error occurred when formatting an argument\", f)\n@@ -631,7 +656,8 @@ impl Display for Error {\n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"core\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     Argument::new(t, f)\n@@ -640,7 +666,8 @@ pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"core\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     Argument::from_uint(s)\n }\n@@ -650,11 +677,11 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n macro_rules! fmt_refs {\n     ($($tr:ident),*) => {\n         $(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T: ?Sized + $tr> $tr for &'a T {\n             fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n         }\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T: ?Sized + $tr> $tr for &'a mut T {\n             fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n         }\n@@ -664,21 +691,21 @@ macro_rules! fmt_refs {\n \n fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Display::fmt(self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         try!(write!(f, \"\\\"\"));\n@@ -689,14 +716,14 @@ impl Debug for str {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::CharExt;\n@@ -708,7 +735,7 @@ impl Debug for char {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n@@ -718,7 +745,7 @@ impl Display for char {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n@@ -728,21 +755,21 @@ impl<T> Pointer for *const T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(&**self as *const T), f)\n@@ -751,14 +778,14 @@ impl<'a, T> Pointer for &'a mut T {\n \n macro_rules! floating { ($ty:ident) => {\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Debug for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             Display::fmt(self, fmt)\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Display for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -780,7 +807,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -802,7 +829,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -829,11 +856,11 @@ floating! { f64 }\n \n // Implementation of Display/Debug for various core types\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Debug for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Debug for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n@@ -845,7 +872,7 @@ macro_rules! peel {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($name:Debug),*> Debug for ($($name,)*) {\n             #[allow(non_snake_case, unused_assignments)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n@@ -871,12 +898,12 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Debug for &'a (any::Any+'a) {\n     fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n@@ -898,21 +925,21 @@ impl<T: Debug> Debug for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for () {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"()\")\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         write!(f, \"Cell {{ value: {:?} }}\", self.get())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.try_borrow() {\n@@ -922,14 +949,14 @@ impl<T: Debug> Debug for RefCell<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T: Debug> Debug for Ref<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Debug::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T: Debug> Debug for RefMut<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Debug::fmt(&*(self.deref()), f)"}, {"sha": "1222126b5e0cdef73c0a3bccc4ce5dff3630c90f", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -111,7 +111,8 @@ radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n \n /// A radix with in the range of `2..36`.\n #[derive(Clone, Copy, PartialEq)]\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or move to a different module\")]\n pub struct Radix {\n     base: u8,\n }\n@@ -135,7 +136,8 @@ impl GenericRadix for Radix {\n }\n \n /// A helper type for formatting radixes.\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or move to a different module\")]\n #[derive(Copy)]\n pub struct RadixFmt<T, R>(T, R);\n \n@@ -147,20 +149,21 @@ pub struct RadixFmt<T, R>(T, R);\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n /// ```\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or move to a different module\")]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n }\n \n macro_rules! radix_fmt {\n     ($T:ty as $U:ty, $fmt:ident, $S:expr) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::Debug for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 fmt::Display::fmt(self, f)\n             }\n         }\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::Display for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n@@ -170,7 +173,7 @@ macro_rules! radix_fmt {\n }\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::$Trait for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 $Radix.fmt_int(*self as $U, f)\n@@ -181,7 +184,7 @@ macro_rules! int_base {\n \n macro_rules! show {\n     ($T:ident with $S:expr) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::Debug for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 fmt::Display::fmt(self, f)"}, {"sha": "0b2c1efbc5dee1682228f5e2ea263589265c2ee0", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,8 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![unstable = \"implementation detail of the `format_args!` macro\"]\n+#![unstable(feature = \"core\",\n+            reason = \"implementation detail of the `format_args!` macro\")]\n \n pub use self::Alignment::*;\n pub use self::Count::*;"}, {"sha": "5a4d2fffade6348598849c7ac29aafabc8078aa7", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -56,7 +56,8 @@\n //! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n //! ```\n \n-#![unstable = \"module was recently redesigned\"]\n+#![unstable(feature = \"hash\",\n+            reason = \"module was recently redesigned\")]\n \n use prelude::*;\n \n@@ -95,7 +96,8 @@ pub trait Hasher {\n \n /// A common bound on the `Hasher` parameter to `Hash` implementations in order\n /// to generically hash an aggregate.\n-#[experimental = \"this trait will likely be replaced by io::Writer\"]\n+#[unstable(feature = \"hash\",\n+           reason = \"this trait will likely be replaced by io::Writer\")]\n #[allow(missing_docs)]\n pub trait Writer {\n     fn write(&mut self, bytes: &[u8]);"}, {"sha": "bef196d48246040ebef25f1d7688ae907a58eff0", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -112,7 +112,8 @@ impl SipHasher {\n     }\n \n     /// Returns the computed hash.\n-    #[deprecated = \"renamed to finish\"]\n+    #[unstable(feature = \"hash\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to finish\")]\n     pub fn result(&self) -> u64 { self.finish() }\n }\n "}, {"sha": "dd6b1e7b4e8325d4c025a455e85f79bbc19fbc35", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -39,7 +39,7 @@\n //!   guaranteed to happen in order. This is the standard mode for working\n //!   with atomic types and is equivalent to Java's `volatile`.\n \n-#![unstable]\n+#![unstable(feature = \"core\")]\n #![allow(missing_docs)]\n \n use marker::Sized;\n@@ -221,7 +221,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// `forget` is unsafe because the caller is responsible for\n     /// ensuring the argument is deallocated already.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn forget<T>(_: T) -> ();\n \n     /// Unsafely transforms a value of one type into a value of another type.\n@@ -237,7 +237,7 @@ extern \"rust-intrinsic\" {\n     /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n     /// assert!(v == [76u8]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn transmute<T,U>(e: T) -> U;\n \n     /// Gives the address for the return value of the enclosing function.\n@@ -297,7 +297,7 @@ extern \"rust-intrinsic\" {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -327,12 +327,13 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     ///\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[unstable = \"uncertain about naming and semantics\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"uncertain about naming and semantics\")]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "74d8a7ae1d6b56913cd10cf9afd36baa65d03fc7", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 196, "deletions": 172, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -54,7 +54,7 @@\n //!\n //! This `for` loop syntax can be applied to any iterator over any type.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::MinMaxResult::*;\n \n@@ -81,23 +81,23 @@ use usize;\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n #[lang=\"iterator\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling `.iter()` or a similar \\\n                             method\"]\n pub trait Iterator {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n     /// does not fit within a `usize`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n }\n \n@@ -116,7 +116,7 @@ impl<'a, T> Iterator for &'a mut (Iterator<Item=T> + 'a) {\n }\n \n /// Conversion from an `Iterator`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                           built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n@@ -125,15 +125,15 @@ pub trait FromIterator<A> {\n }\n \n /// A type growable from an `Iterator` implementation\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n /// An extension trait providing numerous methods applicable to all iterators.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IteratorExt: Iterator + Sized {\n     /// Counts the number of elements in this iterator.\n     ///\n@@ -144,7 +144,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> usize {\n         self.fold(0, |cnt, _x| cnt + 1)\n     }\n@@ -159,7 +159,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(mut self) -> Option<Self::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n@@ -178,7 +178,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.nth(2) == None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n@@ -202,7 +202,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chain<U>(self, other: U) -> Chain<Self, U> where\n         U: Iterator<Item=Self::Item>,\n     {\n@@ -224,7 +224,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<B, U>(self, other: U) -> Zip<Self, U> where\n         U: Iterator<Item=B>,\n     {\n@@ -244,7 +244,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn map<B, F>(self, f: F) -> Map<Self::Item, B, Self, F> where\n         F: FnMut(Self::Item) -> B,\n     {\n@@ -264,7 +264,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter<P>(self, predicate: P) -> Filter<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -284,7 +284,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self::Item, B, Self, F> where\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n@@ -304,7 +304,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn enumerate(self) -> Enumerate<Self> {\n         Enumerate{iter: self, count: 0}\n     }\n@@ -327,7 +327,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn peekable(self) -> Peekable<Self::Item, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n@@ -347,7 +347,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip_while<P>(self, predicate: P) -> SkipWhile<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -368,7 +368,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -388,7 +388,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip(self, n: usize) -> Skip<Self> {\n         Skip{iter: self, n: n}\n     }\n@@ -407,7 +407,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: usize) -> Take<Self> {\n         Take{iter: self, n: n}\n     }\n@@ -433,7 +433,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn scan<St, B, F>(\n         self,\n         initial_state: St,\n@@ -459,7 +459,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn flat_map<B, U, F>(self, f: F) -> FlatMap<Self::Item, B, Self, U, F> where\n         U: Iterator<Item=B>,\n         F: FnMut(Self::Item) -> U,\n@@ -495,7 +495,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fuse(self) -> Fuse<Self> {\n         Fuse{iter: self, done: false}\n     }\n@@ -519,7 +519,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn inspect<F>(self, f: F) -> Inspect<Self::Item, Self, F> where\n         F: FnMut(&Self::Item),\n     {\n@@ -540,7 +540,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(partial_sum == 10);\n     /// assert!(it.next() == Some(5));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {\n         ByRef{iter: self}\n     }\n@@ -556,7 +556,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(a, b);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n@@ -572,7 +572,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(even, vec![2, 4]);\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n-    #[unstable = \"recently added as part of collections reform\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added as part of collections reform\")]\n     fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n@@ -601,7 +602,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         F: FnMut(B, Self::Item) -> B,\n     {\n@@ -622,7 +623,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn all<F>(mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n@@ -642,7 +643,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n@@ -660,7 +661,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(it.find(|&x| *x == 3).unwrap(), &3);\n     /// assert_eq!(it.as_slice(), [4, 5]);\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -682,7 +683,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(it.position(|x| *x == 3).unwrap(), 2);\n     /// assert_eq!(it.as_slice(), [4, 5]);\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n     {\n@@ -710,7 +711,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(it.rposition(|x| *x == 2).unwrap(), 2);\n     /// assert_eq!(it.as_slice(), [1, 2]);\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n@@ -733,7 +734,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |max, x| {\n@@ -753,7 +754,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |min, x| {\n@@ -794,7 +795,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// let a = [1, 1, 1, 1];\n     /// assert!(a.iter().min_max() == MinMax(&1, &1));\n     /// ```\n-    #[unstable = \"return type may change\"]\n+    #[unstable(feature = \"core\", reason = \"return type may change\")]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self::Item: Ord\n     {\n         let (mut min, mut max) = match self.next() {\n@@ -851,7 +852,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*a.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn max_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n         F: FnMut(&Self::Item) -> B,\n     {\n@@ -880,7 +882,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*a.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn min_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n         F: FnMut(&Self::Item) -> B,\n     {\n@@ -910,7 +913,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Note: Random access with flipped indices still only applies to the first\n     /// `std::usize::MAX` elements of the original iterator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rev(self) -> Rev<Self> {\n         Rev{iter: self}\n     }\n@@ -928,7 +931,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!([1, 3], left);\n     /// assert_eq!([2, 4], right);\n     /// ```\n-    #[unstable = \"recent addition\"]\n+    #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n@@ -961,7 +964,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Creates an iterator that clones the elements it yields. Useful for converting an\n     /// Iterator<&T> to an Iterator<T>.\n-    #[unstable = \"recent addition\"]\n+    #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn cloned<T, D>(self) -> Cloned<Self> where\n         Self: Iterator<Item=D>,\n         D: Deref<Target=T>,\n@@ -981,14 +984,15 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn cycle(self) -> Cycle<Self> where Self: Clone {\n         Cycle{orig: self.clone(), iter: self}\n     }\n \n     /// Use an iterator to reverse a container in place.\n-    #[unstable = \"uncertain about placement or widespread use\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"uncertain about placement or widespread use\")]\n     fn reverse_in_place<'a, T: 'a>(&mut self) where\n         Self: Iterator<Item=&'a mut T> + DoubleEndedIterator\n     {\n@@ -1001,17 +1005,17 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> IteratorExt for I where I: Iterator {}\n \n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n }\n \n@@ -1021,7 +1025,8 @@ pub trait DoubleEndedIterator: Iterator {\n /// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n-#[unstable = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n+#[unstable(feature = \"core\",\n+           reason = \"not widely used, may be better decomposed into Index and ExactSizeIterator\")]\n pub trait RandomAccessIterator: Iterator {\n     /// Return the number of indexable elements. At most `std::usize::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n@@ -1038,7 +1043,7 @@ pub trait RandomAccessIterator: Iterator {\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `usize`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n@@ -1055,32 +1060,32 @@ pub trait ExactSizeIterator: Iterator {\n \n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n     I: ExactSizeIterator<Item=A>,\n     F: FnMut(&A),\n {}\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n     I: ExactSizeIterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rev<T> {\n     iter: T\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1090,13 +1095,13 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize { self.iter.indexable() }\n@@ -1109,12 +1114,12 @@ impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAcc\n \n /// A mutable reference to an iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ByRef<'a, I:'a> {\n     iter: &'a mut I,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1124,17 +1129,18 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I> ExactSizeIterator for ByRef<'a, I> where I: 'a + ExactSizeIterator {}\n \n /// A trait for iterators over elements which can be added together\n-#[unstable = \"needs to be re-evaluated as part of numerics reform\"]\n+#[unstable(feature = \"core\",\n+           reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n@@ -1152,7 +1158,7 @@ pub trait AdditiveIterator<A> {\n \n macro_rules! impl_additive {\n     ($A:ty, $init:expr) => {\n-        #[unstable = \"trait is experimental\"]\n+        #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n         impl<T: Iterator<Item=$A>> AdditiveIterator<$A> for T {\n             #[inline]\n             fn sum(self) -> $A {\n@@ -1175,7 +1181,8 @@ impl_additive! { f32,  0.0 }\n impl_additive! { f64,  0.0 }\n \n /// A trait for iterators over elements which can be multiplied together.\n-#[unstable = \"needs to be re-evaluated as part of numerics reform\"]\n+#[unstable(feature = \"core\",\n+           reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait MultiplicativeIterator<A> {\n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n@@ -1196,7 +1203,7 @@ pub trait MultiplicativeIterator<A> {\n \n macro_rules! impl_multiplicative {\n     ($A:ty, $init:expr) => {\n-        #[unstable = \"trait is experimental\"]\n+        #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n         impl<T: Iterator<Item=$A>> MultiplicativeIterator<$A> for T {\n             #[inline]\n             fn product(self) -> $A {\n@@ -1220,7 +1227,8 @@ impl_multiplicative! { f64,  1.0 }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n #[derive(Clone, PartialEq, Show)]\n-#[unstable = \"unclear whether such a fine-grained result is widely useful\"]\n+#[unstable(feature = \"core\",\n+           reason = \"unclear whether such a fine-grained result is widely useful\")]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -1252,7 +1260,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1, 2);\n     /// assert_eq!(r.into_option(), Some((1, 2)));\n     /// ```\n-    #[unstable = \"type is unstable\"]\n+    #[unstable(feature = \"core\", reason = \"type is unstable\")]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1263,14 +1271,14 @@ impl<T: Clone> MinMaxResult<T> {\n }\n \n /// An iterator that clones the elements of an underlying iterator\n-#[unstable = \"recent addition\"]\n+#[unstable(feature = \"core\", reason = \"recent addition\")]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[derive(Clone)]\n pub struct Cloned<I> {\n     it: I,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> Iterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1287,7 +1295,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1298,7 +1306,7 @@ impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1308,13 +1316,13 @@ impl<T, D, I> ExactSizeIterator for Cloned<I> where\n /// An iterator that repeats endlessly\n #[derive(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cycle<I> {\n     orig: I,\n     iter: I,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1337,7 +1345,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n@@ -1367,14 +1375,14 @@ impl<I> RandomAccessIterator for Cycle<I> where\n /// An iterator that strings two iterators together\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n     a: A,\n     b: B,\n     flag: bool,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1408,7 +1416,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     A: DoubleEndedIterator<Item=T>,\n     B: DoubleEndedIterator<Item=T>,\n@@ -1422,7 +1430,7 @@ impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=T>,\n@@ -1447,13 +1455,13 @@ impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n /// An iterator that iterates two other iterators simultaneously\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Zip<A, B> {\n     a: A,\n     b: B\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, U, A, B> Iterator for Zip<A, B> where\n     A: Iterator<Item = T>,\n     B: Iterator<Item = U>,\n@@ -1489,7 +1497,7 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     A: DoubleEndedIterator + ExactSizeIterator<Item=T>,\n     B: DoubleEndedIterator + ExactSizeIterator<Item=U>,\n@@ -1514,7 +1522,7 @@ impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=U>,\n@@ -1538,14 +1546,14 @@ impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n \n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Clone for Map<A, B, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> B,\n@@ -1568,7 +1576,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     type Item = B;\n \n@@ -1584,7 +1592,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1596,7 +1604,7 @@ impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1615,14 +1623,14 @@ impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n \n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for Filter<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1635,7 +1643,7 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1658,7 +1666,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n     I: DoubleEndedIterator<Item=A>,\n     P: FnMut(&A) -> bool,\n@@ -1676,14 +1684,14 @@ impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n \n /// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> Option<B>,\n@@ -1696,7 +1704,7 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1721,7 +1729,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1741,13 +1749,13 @@ impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n /// An iterator that yields the current count and the element during iteration\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Enumerate<I> {\n     iter: I,\n     count: usize\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n     type Item = (usize, <I as Iterator>::Item);\n \n@@ -1769,7 +1777,7 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Enumerate<I> where\n     I: ExactSizeIterator + DoubleEndedIterator\n {\n@@ -1785,7 +1793,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1803,14 +1811,14 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     iter: I,\n     peeked: Option<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1836,10 +1844,10 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> ExactSizeIterator for Peekable<T, I> where I: ExactSizeIterator<Item = T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n@@ -1863,15 +1871,15 @@ impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n \n /// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1885,7 +1893,7 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1909,15 +1917,15 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n \n /// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1931,7 +1939,7 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1964,13 +1972,13 @@ impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n /// An iterator that skips over `n` elements of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Skip<I> {\n     iter: I,\n     n: usize\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2014,7 +2022,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2031,19 +2039,19 @@ impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n \n /// An iterator that only iterates over the first `n` iterations of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<I> {\n     iter: I,\n     n: usize\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Take<I> where I: Iterator{\n     type Item = <I as Iterator>::Item;\n \n@@ -2072,7 +2080,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2089,13 +2097,13 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n \n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n@@ -2105,7 +2113,7 @@ pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Optio\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     I: Clone + Iterator<Item=A>,\n     St: Clone,\n@@ -2120,7 +2128,7 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n@@ -2143,7 +2151,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n /// and yields the elements of the produced iterators\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2156,7 +2164,7 @@ pub struct FlatMap<A, B, I, U, F> where\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     I: Clone + Iterator<Item=A>,\n     U: Clone + Iterator<Item=B>,\n@@ -2172,7 +2180,7 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2207,7 +2215,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n     I: DoubleEndedIterator<Item=A>,\n     U: DoubleEndedIterator<Item=B>,\n@@ -2234,13 +2242,13 @@ impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n /// yields `None` once.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Fuse<I> {\n     iter: I,\n     done: bool\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Fuse<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2269,7 +2277,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n@@ -2288,7 +2296,7 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n }\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2301,14 +2309,14 @@ impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}\n \n impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n-    #[unstable = \"seems marginal\"]\n+    #[unstable(feature = \"core\", reason = \"seems marginal\")]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2317,14 +2325,14 @@ impl<I> Fuse<I> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> Clone for Inspect<A, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(&A),\n@@ -2349,7 +2357,7 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     type Item = A;\n \n@@ -2365,7 +2373,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2377,7 +2385,7 @@ impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2426,15 +2434,15 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///     println!(\"{}\", i);\n /// }\n /// ```\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, St, F> Clone for Unfold<A, St, F> where\n     F: Clone + FnMut(&mut St) -> Option<A>,\n     St: Clone,\n@@ -2447,7 +2455,7 @@ impl<A, St, F> Clone for Unfold<A, St, F> where\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n@@ -2460,7 +2468,7 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n@@ -2479,7 +2487,8 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n #[derive(Clone, Copy)]\n-#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or replaced by range notation adapaters\")]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -2489,12 +2498,13 @@ pub struct Counter<A> {\n \n /// Creates a new counter with the specified start/step\n #[inline]\n-#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may be renamed or replaced by range notation adapaters\")]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     type Item = A;\n \n@@ -2513,7 +2523,8 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n \n /// An iterator over the range [start, stop)\n #[derive(Clone, Copy)]\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by range notation\")]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n@@ -2534,7 +2545,8 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by range notation\")]\n pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n     Range {\n         state: start,\n@@ -2544,7 +2556,8 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n }\n \n // FIXME: #10414: Unfortunate type bound\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by range notation\")]\n impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     type Item = A;\n \n@@ -2594,7 +2607,8 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by range notation\")]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2609,23 +2623,26 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n         range: range(start, stop),\n         done: false,\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n@@ -2660,7 +2677,8 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2679,7 +2697,8 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeStep<A> {\n     state: A,\n     stop: A,\n@@ -2689,13 +2708,15 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int> Iterator for RangeStep<A> {\n     type Item = A;\n \n@@ -2716,7 +2737,8 @@ impl<A: Int> Iterator for RangeStep<A> {\n \n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeStepInclusive<A> {\n     state: A,\n     stop: A,\n@@ -2727,7 +2749,8 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n     RangeStepInclusive {\n@@ -2739,7 +2762,8 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int> Iterator for RangeStepInclusive<A> {\n     type Item = A;\n \n@@ -2761,7 +2785,7 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n \n macro_rules! range_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Iterator for ::ops::Range<$t> {\n             type Item = $t;\n \n@@ -2784,14 +2808,14 @@ macro_rules! range_impl {\n             }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl ExactSizeIterator for ::ops::Range<$t> {}\n     )*)\n }\n \n macro_rules! range_impl_no_hint {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Iterator for ::ops::Range<$t> {\n             type Item = $t;\n \n@@ -2811,7 +2835,7 @@ macro_rules! range_impl_no_hint {\n \n macro_rules! range_other_impls {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl DoubleEndedIterator for ::ops::Range<$t> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$t> {\n@@ -2824,7 +2848,7 @@ macro_rules! range_other_impls {\n             }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Iterator for ::ops::RangeFrom<$t> {\n             type Item = $t;\n \n@@ -2849,12 +2873,12 @@ range_other_impls!(usize u8 u16 u32 u64 isize i8 i16 i32 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n     element: A\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n@@ -2864,13 +2888,13 @@ impl<A: Clone> Iterator for Repeat<A> {\n     fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> usize { usize::MAX }\n@@ -2882,12 +2906,12 @@ type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n     T: Clone,\n     F: FnMut(T) -> T,\n@@ -2918,7 +2942,7 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n \n /// Create a new iterator that endlessly repeats the element `elt`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n     Repeat{element: elt}\n }\n@@ -2930,7 +2954,7 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[unstable = \"needs review and revision\"]\n+#[unstable(feature = \"core\", reason = \"needs review and revision\")]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}, {"sha": "d4ca5e3f8dcb59412edf41546a970c773afdb933", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -48,7 +48,8 @@\n // separate crate, libcoretest, to avoid bizarre issues.\n \n #![crate_name = \"core\"]\n-#![unstable]\n+#![unstable(feature = \"core\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "943365d8454d4629ed65a6757aa17ef28817e961", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -52,7 +52,7 @@ macro_rules! panic {\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n@@ -79,7 +79,7 @@ macro_rules! assert {\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n@@ -123,7 +123,7 @@ macro_rules! assert_eq {\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n }\n@@ -185,7 +185,7 @@ macro_rules! write {\n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! writeln {\n     ($dst:expr, $fmt:expr) => (\n         write!($dst, concat!($fmt, \"\\n\"))\n@@ -235,7 +235,8 @@ macro_rules! writeln {\n /// }\n /// ```\n #[macro_export]\n-#[unstable = \"relationship with panic is unclear\"]\n+#[unstable(feature = \"core\",\n+           reason = \"relationship with panic is unclear\")]\n macro_rules! unreachable {\n     () => ({\n         panic!(\"internal error: entered unreachable code\")\n@@ -251,7 +252,8 @@ macro_rules! unreachable {\n /// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n #[macro_export]\n-#[unstable = \"relationship with panic is unclear\"]\n+#[unstable(feature = \"core\",\n+           reason = \"relationship with panic is unclear\")]\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }"}, {"sha": "1fc3e34af5e31dafd1dc4e9cf903be7ef603947d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -23,20 +23,21 @@\n //! implemented using unsafe code. In that case, you may want to embed\n //! some of the marker types below into your type.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n \n /// Types able to be transferred across thread boundaries.\n-#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n pub unsafe trait Send: 'static {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n pub trait Sized {\n@@ -142,7 +143,7 @@ pub trait Sized {\n /// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n /// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"copy\"]\n pub trait Copy {\n     // Empty.\n@@ -193,7 +194,8 @@ pub trait Copy {\n /// around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n-#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n pub unsafe trait Sync {\n@@ -238,7 +240,8 @@ pub unsafe trait Sync {\n /// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n /// for some lifetime `'a`, but not the other way around).\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"covariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct CovariantType<T: ?Sized>;\n@@ -287,7 +290,8 @@ impl<T: ?Sized> Clone for CovariantType<T> {\n /// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n /// function requires arguments of type `T`, it must also accept\n /// arguments of type `U`, hence such a conversion is safe.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"contravariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct ContravariantType<T: ?Sized>;\n@@ -317,14 +321,17 @@ impl<T: ?Sized> Clone for ContravariantType<T> {\n /// The type system would infer that `value` is only read here and\n /// never written, but in fact `Cell` uses unsafe code to achieve\n /// interior mutability.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"invariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantType<T: ?Sized>;\n \n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n impl<T: ?Sized> Copy for InvariantType<T> {}\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n impl<T: ?Sized> Clone for InvariantType<T> {\n     fn clone(&self) -> InvariantType<T> { *self }\n }\n@@ -345,7 +352,8 @@ impl<T: ?Sized> Clone for InvariantType<T> {\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"covariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct CovariantLifetime<'a>;\n@@ -362,7 +370,8 @@ pub struct CovariantLifetime<'a>;\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"contravariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct ContravariantLifetime<'a>;\n@@ -374,23 +383,26 @@ pub struct ContravariantLifetime<'a>;\n /// pointer that is actually a pointer into memory with lifetime `'a`,\n /// and this pointer is itself stored in an inherently mutable\n /// location (such as a `Cell`).\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"invariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantLifetime<'a>;\n \n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_copy_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n #[allow(missing_copy_implementations)]\n pub struct NoCopy;\n \n /// A type which is considered managed by the GC. This is typically\n /// embedded in other types.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"managed_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n #[allow(missing_copy_implementations)]"}, {"sha": "0d26c8e79142ae728bf071fc216143a496387841", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -13,13 +13,13 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n use intrinsics;\n use ptr;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n \n /// Moves a thing into the void.\n@@ -29,7 +29,7 @@ pub use intrinsics::transmute;\n ///\n /// This function is the unsafe version of the `drop` function because it does\n /// not run any destructors.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::forget;\n \n /// Returns the size of a type in bytes.\n@@ -42,7 +42,7 @@ pub use intrinsics::forget;\n /// assert_eq!(4, mem::size_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n@@ -57,7 +57,7 @@ pub fn size_of<T>() -> uint {\n /// assert_eq!(4, mem::size_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n@@ -74,7 +74,7 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n /// assert_eq!(4, mem::min_align_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n@@ -89,7 +89,7 @@ pub fn min_align_of<T>() -> uint {\n /// assert_eq!(4, mem::min_align_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n     min_align_of::<T>()\n }\n@@ -107,7 +107,7 @@ pub fn min_align_of_val<T>(_val: &T) -> uint {\n /// assert_eq!(4, mem::align_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn align_of<T>() -> uint {\n     // We use the preferred alignment as the default alignment for a type. This\n     // appears to be what clang migrated towards as well:\n@@ -129,7 +129,7 @@ pub fn align_of<T>() -> uint {\n /// assert_eq!(4, mem::align_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn align_of_val<T>(_val: &T) -> uint {\n     align_of::<T>()\n }\n@@ -153,7 +153,7 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n /// let x: int = unsafe { mem::zeroed() };\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n@@ -174,7 +174,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// let x: int = unsafe { mem::uninitialized() };\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n@@ -196,7 +196,7 @@ pub unsafe fn uninitialized<T>() -> T {\n /// assert_eq!(5, *y);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n@@ -261,7 +261,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src\n@@ -288,7 +288,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n /// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n@@ -311,24 +311,26 @@ pub fn drop<T>(_x: T) { }\n /// assert_eq!(1, one);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     ptr::read(src as *const T as *const U)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline]\n-#[unstable = \"this function may be removed in the future due to its \\\n-              questionable utility\"]\n+#[unstable(feature = \"core\",\n+           reason = \"this function may be removed in the future due to its \\\n+                     questionable utility\")]\n pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n                                                         ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second mutable pointer to match the first.\n #[inline]\n-#[unstable = \"this function may be removed in the future due to its \\\n-              questionable utility\"]\n+#[unstable(feature = \"core\",\n+           reason = \"this function may be removed in the future due to its \\\n+                     questionable utility\")]\n pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,\n                                                             ptr: &mut T)\n                                                             -> &'a mut T {"}, {"sha": "7c8be79d075cba1ac66aac0db038888e6af5bf9c", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -32,7 +32,7 @@ unsafe impl Zeroable for u64 {}\n /// NULL or 0 that might allow certain optimizations.\n #[lang=\"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show)]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);\n \n impl<T: Zeroable> NonZero<T> {"}, {"sha": "83d070feb8a69303f7d2791cdcb2aebb649dc999", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,54 +14,55 @@\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n use mem;\n use num::Float;\n use num::FpCategory as Fp;\n use option::Option;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const RADIX: uint = 2;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MANTISSA_DIGITS: uint = 24;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 6;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n /// Smallest finite f32 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n /// Smallest positive, normalized f32 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n /// Largest finite f32 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -125;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_EXP: int = 128;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_10_EXP: int = -37;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 38;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NAN: f32 = 0.0_f32/0.0_f32;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /// Various useful constants.\n-#[unstable = \"naming scheme needs to be revisited\"]\n+#[unstable(feature = \"core\",\n+           reason = \"naming scheme needs to be revisited\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n \n@@ -117,7 +118,7 @@ pub mod consts {\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }\n@@ -177,43 +178,53 @@ impl Float for f32 {\n     }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn digits(_: Option<f32>) -> uint { DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn epsilon() -> f32 { EPSILON }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_value() -> f32 { MIN_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_value() -> f32 { MAX_VALUE }\n \n     /// Returns the mantissa, exponent and sign as integers."}, {"sha": "ce011b3c2eeb6a40e2e33a462cad58da92dfdee6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,7 @@\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n use mem;\n@@ -26,45 +26,46 @@ use option::Option;\n // constants are implemented in favour of referencing the respective\n // members of `Bounded` and `Float`.\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const RADIX: uint = 2;\n \n pub const MANTISSA_DIGITS: uint = 53;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 15;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n /// Smallest finite f64 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n /// Smallest positive, normalized f64 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n /// Largest finite f64 value\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -1021;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_EXP: int = 1024;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_10_EXP: int = -307;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 308;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NAN: f64 = 0.0_f64/0.0_f64;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n /// Various useful constants.\n-#[unstable = \"naming scheme needs to be revisited\"]\n+#[unstable(feature = \"core\",\n+           reason = \"naming scheme needs to be revisited\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n \n@@ -124,7 +125,7 @@ pub mod consts {\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }\n@@ -184,43 +185,53 @@ impl Float for f64 {\n     }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn digits(_: Option<f64>) -> uint { DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn epsilon() -> f64 { EPSILON }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_value() -> f64 { MIN_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\")]\n     fn max_value() -> f64 { MAX_VALUE }\n \n     /// Returns the mantissa, exponent and sign as integers."}, {"sha": "5ea60d0d96d29f44943a0c751cf760d7c7deef0c", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n \n int_module! { i16, 16 }"}, {"sha": "7d9faa998c12e87769a8519d416b7085d802dcbf", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n \n int_module! { i32, 32 }"}, {"sha": "5a70911387b9b7192ab7a86fae52a90e77ddaa7b", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n \n int_module! { i64, 64 }"}, {"sha": "1d7d78ffa6c2352a20ad49cbfda99a0b3fc7ce17", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n \n int_module! { i8, 8 }"}, {"sha": "2132b9516abad0973d95c422f34e503f246c6c03", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,8 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by isize\"]\n+#![unstable(feature = \"core\")]\n+#![deprecated(since = \"1.0.0\", reason = \"replaced by isize\")]\n \n #[cfg(target_pointer_width = \"32\")] int_module! { int, 32 }\n #[cfg(target_pointer_width = \"64\")] int_module! { int, 64 }"}, {"sha": "954c8a08e64d6bafdd15a6ef6c2fe9e6ad29e8c9", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,21 +14,21 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub const BITS : uint = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub const BYTES : uint = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = (-1 as $T) << (BITS - 1);\n // FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: $T = !MIN;\n \n ) }"}, {"sha": "0fd0d90b12501ea87b257bb523b56a1c6d0f1b47", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n \n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "9e460492b64bd9789d37c666d902e111d093a6c7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 113, "deletions": 75, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,7 @@\n \n //! Numeric traits and functions for the built-in numeric types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n use char::CharExt;\n@@ -30,7 +30,7 @@ use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Int\n     : Copy + Clone\n     + NumCast\n@@ -50,22 +50,26 @@ pub trait Int\n {\n     /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"unsure about its place in the world\")]\n     fn zero() -> Self;\n \n     /// Returns the `1` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"unsure about its place in the world\")]\n     fn one() -> Self;\n \n     /// Returns the smallest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"unsure about its place in the world\")]\n     fn min_value() -> Self;\n \n     /// Returns the largest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"unsure about its place in the world\")]\n     fn max_value() -> Self;\n \n     /// Returns the number of ones in the binary representation of `self`.\n@@ -79,7 +83,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn count_ones(self) -> uint;\n \n     /// Returns the number of zeros in the binary representation of `self`.\n@@ -93,7 +98,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_zeros(), 5);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     #[inline]\n     fn count_zeros(self) -> uint {\n         (!self).count_ones()\n@@ -111,7 +117,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn leading_zeros(self) -> uint;\n \n     /// Returns the number of trailing zeros in the binary representation\n@@ -126,7 +133,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn trailing_zeros(self) -> uint;\n \n     /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n@@ -142,7 +150,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_left(12), m);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn rotate_left(self, n: uint) -> Self;\n \n     /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n@@ -158,7 +167,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_right(12), m);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     fn rotate_right(self, n: uint) -> Self;\n \n     /// Reverses the byte order of the integer.\n@@ -173,7 +183,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.swap_bytes(), m);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn swap_bytes(self) -> Self;\n \n     /// Convert an integer from big endian to the target's endianness.\n@@ -193,7 +203,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn from_be(x: Self) -> Self {\n         if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -216,7 +226,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn from_le(x: Self) -> Self {\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -239,7 +249,7 @@ pub trait Int\n     ///     assert_eq!(n.to_be(), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn to_be(self) -> Self { // or not to be?\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -262,7 +272,7 @@ pub trait Int\n     ///     assert_eq!(n.to_le(), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn to_le(self) -> Self {\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n@@ -279,7 +289,7 @@ pub trait Int\n     /// assert_eq!(5u16.checked_add(65530), Some(65535));\n     /// assert_eq!(6u16.checked_add(65530), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_add(self, other: Self) -> Option<Self>;\n \n     /// Checked integer subtraction. Computes `self - other`, returning `None`\n@@ -293,7 +303,7 @@ pub trait Int\n     /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n     /// assert_eq!((-128i8).checked_sub(1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_sub(self, other: Self) -> Option<Self>;\n \n     /// Checked integer multiplication. Computes `self * other`, returning\n@@ -307,7 +317,7 @@ pub trait Int\n     /// assert_eq!(5u8.checked_mul(51), Some(255));\n     /// assert_eq!(5u8.checked_mul(52), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_mul(self, other: Self) -> Option<Self>;\n \n     /// Checked integer division. Computes `self / other`, returning `None` if\n@@ -322,12 +332,12 @@ pub trait Int\n     /// assert_eq!((-128i8).checked_div(-1), None);\n     /// assert_eq!((1i8).checked_div(0), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_div(self, other: Self) -> Option<Self>;\n \n     /// Saturating integer addition. Computes `self + other`, saturating at\n     /// the numeric bounds instead of overflowing.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n@@ -339,7 +349,7 @@ pub trait Int\n \n     /// Saturating integer subtraction. Computes `self - other`, saturating at\n     /// the numeric bounds instead of overflowing.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n@@ -358,7 +368,8 @@ pub trait Int\n     ///\n     /// assert_eq!(2.pow(4), 16);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"pending integer conventions\")]\n     #[inline]\n     fn pow(self, mut exp: uint) -> Self {\n         let mut base = self;\n@@ -390,7 +401,7 @@ macro_rules! uint_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -521,7 +532,7 @@ macro_rules! int_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -614,38 +625,38 @@ int_impl! { int = i64, u64, 64,\n     intrinsics::i64_mul_with_overflow }\n \n /// A built-in two's complement integer.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait SignedInt\n     : Int\n     + Neg<Output=Self>\n {\n     /// Computes the absolute value of `self`. `Int::min_value()` will be\n     /// returned if the number is `Int::min_value()`.\n-    #[unstable = \"overflow in debug builds?\"]\n+    #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n     fn abs(self) -> Self;\n \n     /// Returns a number representing sign of `self`.\n     ///\n     /// - `0` if the number is zero\n     /// - `1` if the number is positive\n     /// - `-1` if the number is negative\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn signum(self) -> Self;\n \n     /// Returns `true` if `self` is positive and `false` if the number\n     /// is zero or negative.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_positive(self) -> bool;\n \n     /// Returns `true` if `self` is negative and `false` if the number\n     /// is zero or positive.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_negative(self) -> bool;\n }\n \n macro_rules! signed_int_impl {\n     ($T:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl SignedInt for $T {\n             #[inline]\n             fn abs(self) -> $T {\n@@ -677,18 +688,18 @@ signed_int_impl! { i64 }\n signed_int_impl! { int }\n \n /// A built-in unsigned integer.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UnsignedInt: Int {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn is_power_of_two(self) -> bool {\n         (self - Int::one()) & self == Int::zero() && !(self == Int::zero())\n     }\n \n     /// Returns the smallest power of two greater than or equal to `self`.\n     /// Unspecified behavior on overflow.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn next_power_of_two(self) -> Self {\n         let bits = size_of::<Self>() * 8;\n@@ -699,7 +710,7 @@ pub trait UnsignedInt: Int {\n     /// Returns the smallest power of two greater than or equal to `n`. If the\n     /// next power of two is greater than the type's maximum value, `None` is\n     /// returned, otherwise the power of two is wrapped in `Some`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_next_power_of_two(self) -> Option<Self> {\n         let npot = self.next_power_of_two();\n         if npot >= self {\n@@ -710,23 +721,23 @@ pub trait UnsignedInt: Int {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for uint {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u8 {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u16 {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u32 {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u64 {}\n \n /// A generic trait for converting a value to a number.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`.\n     #[inline]\n@@ -991,7 +1002,7 @@ impl_to_primitive_float! { f32 }\n impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait FromPrimitive : ::marker::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n@@ -1073,73 +1084,73 @@ pub trait FromPrimitive : ::marker::Sized {\n }\n \n /// A utility function that just calls `FromPrimitive::from_int`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n     FromPrimitive::from_int(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i8`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n     FromPrimitive::from_i8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i16`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n     FromPrimitive::from_i16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n     FromPrimitive::from_i32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n     FromPrimitive::from_i64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_uint`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n     FromPrimitive::from_uint(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u8`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n     FromPrimitive::from_u8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u16`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n     FromPrimitive::from_u16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n     FromPrimitive::from_u32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n     FromPrimitive::from_u64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n     FromPrimitive::from_f32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n     FromPrimitive::from_f64(n)\n }\n@@ -1190,13 +1201,13 @@ impl_from_primitive! { f64, to_f64 }\n /// ```\n ///\n #[inline]\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n     NumCast::from(n)\n }\n \n /// An interface for casting between machine scalars.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait NumCast: ToPrimitive {\n     /// Creates a number from another value that can be converted into a primitive via the\n     /// `ToPrimitive` trait.\n@@ -1231,7 +1242,7 @@ impl_num_cast! { f64,   to_f64 }\n \n /// Used for representing the classification of floating point numbers\n #[derive(Copy, PartialEq, Show)]\n-#[unstable = \"may be renamed\"]\n+#[unstable(feature = \"core\", reason = \"may be renamed\")]\n pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n     Nan,\n@@ -1251,7 +1262,8 @@ pub enum FpCategory {\n //\n // FIXME(#8888): Several of these functions have a parameter named\n //               `unused_self`. Removing it requires #8888 to be fixed.\n-#[unstable = \"distribution of methods between core/std is unclear\"]\n+#[unstable(feature = \"core\",\n+           reason = \"distribution of methods between core/std is unclear\")]\n pub trait Float\n     : Copy + Clone\n     + NumCast\n@@ -1280,34 +1292,56 @@ pub trait Float\n     // FIXME (#5527): These should be associated constants\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n-    #[deprecated = \"use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n+                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n     /// Returns the number of base-10 digits of precision that this type supports.\n-    #[deprecated = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     fn digits(unused_self: Option<Self>) -> uint;\n     /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    #[deprecated = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n     fn epsilon() -> Self;\n     /// Returns the minimum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     fn min_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     fn max_exp(unused_self: Option<Self>) -> int;\n     /// Returns the minimum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the smallest finite value that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\")]\n     fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_POS_VALUE` or `std::f64::MIN_POS_VALUE` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_POS_VALUE` or \\\n+                           `std::f64::MIN_POS_VALUE` as appropriate\")]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\"]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\")]\n     fn max_value() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n@@ -1394,20 +1428,21 @@ pub trait Float\n }\n \n /// A generic trait for converting a string with a radix (base) to a value\n-#[unstable = \"might need to return Result\"]\n+#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n pub trait FromStrRadix {\n     fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n-#[unstable = \"might need to return Result\"]\n+#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"might need to return Result\")]\n         impl FromStr for $T {\n             /// Convert a string in base 10 to a float.\n             /// Accepts an optional decimal exponent.\n@@ -1440,7 +1475,8 @@ macro_rules! from_str_radix_float_impl {\n             }\n         }\n \n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"might need to return Result\")]\n         impl FromStrRadix for $T {\n             /// Convert a string in a given base to a float.\n             ///\n@@ -1604,15 +1640,17 @@ from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"might need to return Result\")]\n         impl FromStr for $T {\n             #[inline]\n             fn from_str(src: &str) -> Option<$T> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"might need to return Result\")]\n         impl FromStrRadix for $T {\n             fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n                 assert!(radix >= 2 && radix <= 36,"}, {"sha": "21635799a77a26a458619bcd3b3431ce2ae0c7ba", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n \n uint_module! { u16, i16, 16 }"}, {"sha": "7d520770503d4b2507cb483afc8bcf04204ca443", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n \n uint_module! { u32, i32, 32 }"}, {"sha": "f10822077dc7511e3e44d12596e6e2198e0e941d", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n \n uint_module! { u64, i64, 64 }"}, {"sha": "3d6922b07b19407b325941dd14888e4fea334214", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n \n uint_module! { u8, i8, 8 }"}, {"sha": "f66a0eed971612913bf5e7e0b1fa98cfbdbfeab4", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,6 +14,7 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by usize\"]\n+#![unstable(feature = \"core\")]\n+#![deprecated(since = \"1.0.0\", reason = \"replaced by usize\")]\n \n uint_module! { uint, int, ::int::BITS }"}, {"sha": "06502be54aaccded31e2541928248cde27f77407", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,14 +12,14 @@\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub const BITS : uint = $bits;\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub const BYTES : uint = ($bits / 8);\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = 0 as $T;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: $T = 0 as $T - 1 as $T;\n \n ) }"}, {"sha": "602ef4fe45e734e0f1a931a2a50c98ce98e0511a", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n \n uint_module! { usize, isize, ::isize::BITS }"}, {"sha": "d482888e3bc8ca9608e526a566cfc6b50eb20f23", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 88, "deletions": 81, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -65,7 +65,7 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n use fmt;\n@@ -92,18 +92,19 @@ use fmt;\n /// }\n /// ```\n #[lang=\"drop\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn drop(&mut self);\n }\n \n // implements the unary operator \"op &T\"\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n     (impl $imp:ident, $method:ident for $t:ty) => {\n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp for &'a $t {\n             type Output = <$t as $imp>::Output;\n \n@@ -119,7 +120,8 @@ macro_rules! forward_ref_unop {\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp<$u> for &'a $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -129,7 +131,8 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp<&'a $u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -139,7 +142,8 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"core\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a, 'b> $imp<&'a $u> for &'b $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -178,19 +182,19 @@ macro_rules! forward_ref_binop {\n /// }\n /// ```\n #[lang=\"add\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Add<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `+` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Add for $t {\n             type Output = $t;\n \n@@ -231,19 +235,19 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"sub\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Sub<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `-` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Sub for $t {\n             type Output = $t;\n \n@@ -284,19 +288,19 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"mul\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Mul<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `*` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Mul for $t {\n             type Output = $t;\n \n@@ -337,19 +341,19 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"div\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Div<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `/` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Div for $t {\n             type Output = $t;\n \n@@ -390,19 +394,19 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"rem\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Rem<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output = Self;\n \n     /// The method for the `%` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -416,7 +420,7 @@ macro_rules! rem_impl {\n \n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -463,25 +467,25 @@ rem_float_impl! { f64, fmod }\n /// }\n /// ```\n #[lang=\"neg\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the unary `-` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }\n \n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Neg for $t {\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             type Output = $t;\n \n             #[inline]\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             fn neg(self) -> $t { -self }\n         }\n \n@@ -491,7 +495,7 @@ macro_rules! neg_impl {\n \n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Neg for $t {\n             type Output = $t;\n \n@@ -540,19 +544,19 @@ neg_uint_impl! { u64, i64 }\n /// }\n /// ```\n #[lang=\"not\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the unary `!` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n }\n \n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Not for $t {\n             type Output = $t;\n \n@@ -593,19 +597,19 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitand\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitAnd<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `&` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitAnd for $t {\n             type Output = $t;\n \n@@ -646,19 +650,19 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitor\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitOr<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `|` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitOr for $t {\n             type Output = $t;\n \n@@ -699,19 +703,19 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitxor\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitXor<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `^` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitXor for $t {\n             type Output = $t;\n \n@@ -752,19 +756,19 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shl\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shl<RHS> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `<<` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shl_impl {\n     ($t:ty, $f:ty) => (\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for $t {\n             type Output = $t;\n \n@@ -823,13 +827,13 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"shr\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shr<RHS> {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `>>` operator\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n \n@@ -895,12 +899,12 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"index\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n }\n \n@@ -933,22 +937,22 @@ pub trait Index<Index: ?Sized> {\n /// }\n /// ```\n #[lang=\"index_mut\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"full_range\"]\n-#[unstable = \"may be renamed to RangeFull\"]\n+#[unstable(feature = \"core\", reason  = \"may be renamed to RangeFull\")]\n pub struct FullRange;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for FullRange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(\"..\", fmt)\n@@ -958,15 +962,15 @@ impl fmt::Debug for FullRange {\n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n@@ -976,15 +980,15 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n /// A range which is only bounded below.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_from\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..\", self.start)\n@@ -994,13 +998,13 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_to\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..{:?}\", self.end)\n@@ -1037,24 +1041,24 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n     /// The method called to dereference a value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Deref for &'a mut T {\n     type Target = T;\n \n@@ -1097,37 +1101,40 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Self::Target;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait Fn<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait FnMut<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Result;"}, {"sha": "c7266aa4f1a8b1d98f1548160475854501b1e378", "filename": "src/libcore/option.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -141,7 +141,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Option::*;\n \n@@ -164,13 +164,13 @@ use slice;\n \n /// The `Option` type.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     None,\n     /// Some value `T`\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Some(T)\n }\n \n@@ -195,7 +195,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.is_some(), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_some(&self) -> bool {\n         match *self {\n             Some(_) => true,\n@@ -215,7 +215,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.is_none(), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_none(&self) -> bool {\n         !self.is_some()\n     }\n@@ -241,7 +241,7 @@ impl<T> Option<T> {\n     /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n         match *self {\n             Some(ref x) => Some(x),\n@@ -262,7 +262,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(42));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self {\n             Some(ref mut x) => Some(x),\n@@ -285,7 +285,8 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(\"Dirt\"));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n             Some(ref mut x) => {\n@@ -322,7 +323,7 @@ impl<T> Option<T> {\n     /// x.expect(\"the world is ending\"); // panics with `world is ending`\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n@@ -354,7 +355,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.unwrap(), \"air\"); // fails\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n@@ -371,7 +372,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n@@ -389,7 +390,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n         match self {\n             Some(x) => x,\n@@ -413,7 +414,7 @@ impl<T> Option<T> {\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => Some(f(x)),\n@@ -433,7 +434,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_or<U, F: FnOnce(T) -> U>(self, def: U, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -455,7 +456,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, def: D, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -476,7 +477,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or(0), Err(0));\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -497,7 +498,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -521,7 +522,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { inner: Item { opt: self.as_ref() } }\n     }\n@@ -542,7 +543,8 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"waiting for iterator conventions\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: Item { opt: self.as_mut() } }\n     }\n@@ -561,7 +563,7 @@ impl<T> Option<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: Item { opt: self } }\n     }\n@@ -592,7 +594,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.and(y), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n         match self {\n             Some(_) => optb,\n@@ -615,7 +617,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.and_then(sq).and_then(sq), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n@@ -645,7 +647,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.or(y), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -667,7 +669,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.or_else(nobody), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -693,7 +695,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n@@ -702,7 +704,8 @@ impl<T> Option<T> {\n impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n     /// Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\n     /// Useful for converting an Option<&T> to an Option<T>.\n-    #[unstable = \"recently added as part of collections reform\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added as part of collections reform\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.deref().clone())\n     }\n@@ -732,7 +735,7 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0, bad_year);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -745,7 +748,8 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"waiting on the stability of the trait itself\"]\n+#[unstable(feature = \"core\",\n+           reason = \"waiting on the stability of the trait itself\")]\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n@@ -760,10 +764,10 @@ impl<T> AsSlice<T> for Option<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Option<T> { None }\n }\n \n@@ -803,10 +807,10 @@ impl<A> DoubleEndedIterator for Item<A> {\n impl<A> ExactSizeIterator for Item<A> {}\n \n /// An iterator over a reference of the contained item in an Option.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -816,27 +820,27 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Clone for Iter<'a, A> {\n     fn clone(&self) -> Iter<'a, A> {\n         Iter { inner: self.inner.clone() }\n     }\n }\n \n /// An iterator over a mutable reference of the contained item in an Option.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n@@ -846,20 +850,20 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -869,20 +873,20 @@ impl<A> Iterator for IntoIter<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a\n@@ -902,7 +906,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// assert!(res == Some(vec!(2, 3)));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed."}, {"sha": "9c18cd0f6d9af0cc9d3dac1c4313ba2492aaf973", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -86,7 +86,7 @@\n //! but C APIs hand out a lot of pointers generally, so are a common source\n //! of unsafe pointers in Rust.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use mem;\n use clone::Clone;\n@@ -99,13 +99,14 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n \n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub use intrinsics::copy_nonoverlapping_memory;\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub use intrinsics::copy_memory;\n \n-#[unstable = \"uncertain about naming and semantics\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about naming and semantics\")]\n pub use intrinsics::set_memory;\n \n \n@@ -120,7 +121,7 @@ pub use intrinsics::set_memory;\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n /// Creates a null mutable raw pointer.\n@@ -134,7 +135,7 @@ pub fn null<T>() -> *const T { 0 as *const T }\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be\n@@ -145,7 +146,8 @@ pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Beyond accepting a raw pointer, this is unsafe because it will not drop the\n /// contents of `dst`, and may be used to create invalid instances of `T`.\n #[inline]\n-#[unstable = \"may play a larger role in std::ptr future extensions\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n@@ -158,7 +160,7 @@ pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n ///\n /// This is only unsafe because it accepts a raw pointer.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninitialized();\n@@ -182,7 +184,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// This is only unsafe because it accepts a raw pointer.\n /// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n@@ -200,7 +202,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n #[inline(always)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n@@ -213,7 +215,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n-#[unstable = \"may play a larger role in std::ptr future extensions\"]\n+#[unstable(feature = \"core\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n     let tmp = read(&*dest);\n@@ -236,18 +239,18 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n #[inline]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n /// Methods on raw pointers\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PtrExt: Sized {\n     type Target;\n \n     /// Returns true if the pointer is null.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool;\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -259,8 +262,9 @@ pub trait PtrExt: Sized {\n     /// null-safety, it is important to note that this is still an unsafe\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n-    #[unstable = \"Option is not clearly the right return type, and we may want \\\n-                  to tie the return lifetime to a borrow of the raw pointer\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"Option is not clearly the right return type, and we may want \\\n+                         to tie the return lifetime to a borrow of the raw pointer\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;\n \n     /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n@@ -271,12 +275,12 @@ pub trait PtrExt: Sized {\n     /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n     /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n     /// the pointer is used.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n /// Methods on mutable raw pointers\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait MutPtrExt {\n     type Target;\n \n@@ -287,28 +291,30 @@ pub trait MutPtrExt {\n     ///\n     /// As with `as_ref`, this is unsafe because it cannot verify the validity\n     /// of the returned pointer.\n-    #[unstable = \"Option is not clearly the right return type, and we may want \\\n-                  to tie the return lifetime to a borrow of the raw pointer\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"Option is not clearly the right return type, and we may want \\\n+                         to tie the return lifetime to a borrow of the raw pointer\")]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PtrExt for *const T {\n     type Target = T;\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> *const T {\n         intrinsics::offset(self, count)\n     }\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n@@ -318,23 +324,24 @@ impl<T> PtrExt for *const T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> *mut T {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n@@ -344,13 +351,14 @@ impl<T> PtrExt for *mut T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> MutPtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> {\n         if self.is_null() {\n             None\n@@ -361,7 +369,7 @@ impl<T> MutPtrExt for *mut T {\n }\n \n // Equality for pointers\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialEq for *const T {\n     #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n@@ -371,10 +379,10 @@ impl<T> PartialEq for *const T {\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Eq for *const T {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -384,18 +392,18 @@ impl<T> PartialEq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Eq for *mut T {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n         *self\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n@@ -408,7 +416,7 @@ mod externfnpointers {\n     use mem;\n     use cmp::PartialEq;\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n@@ -419,7 +427,7 @@ mod externfnpointers {\n     }\n     macro_rules! fnptreq {\n         ($($p:ident),*) => {\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n@@ -439,7 +447,7 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Ord for *const T {\n     #[inline]\n     fn cmp(&self, other: &*const T) -> Ordering {\n@@ -453,7 +461,7 @@ impl<T> Ord for *const T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialOrd for *const T {\n     #[inline]\n     fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n@@ -473,7 +481,7 @@ impl<T> PartialOrd for *const T {\n     fn ge(&self, other: &*const T) -> bool { *self >= *other }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Ord for *mut T {\n     #[inline]\n     fn cmp(&self, other: &*mut T) -> Ordering {\n@@ -487,7 +495,7 @@ impl<T> Ord for *mut T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n@@ -513,32 +521,34 @@ impl<T> PartialOrd for *mut T {\n /// raw `*mut T` (which conveys no particular ownership semantics).\n /// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n pub struct Unique<T>(pub *mut T);\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n unsafe impl<T:Send> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n unsafe impl<T:Sync> Sync for Unique<T> { }\n \n impl<T> Unique<T> {\n     /// Returns a null Unique.\n-    #[unstable = \"recently added to this module\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added to this module\")]\n     pub fn null() -> Unique<T> {\n         Unique(null_mut())\n     }\n \n     /// Return an (unsafe) pointer into the memory owned by `self`.\n-    #[unstable = \"recently added to this module\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added to this module\")]\n     pub unsafe fn offset(self, offset: int) -> *mut T {\n         self.0.offset(offset)\n     }"}, {"sha": "3fd244b46e30f4d27d897c29accbb7c7ddc53a77", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![unstable]\n+#![unstable(feature = \"core\")]\n \n //! Contains struct definitions for the layout of compiler built-in types.\n //!"}, {"sha": "ade257165c6ad0f24e1bdde4e62a18f9247ea8e0", "filename": "src/libcore/result.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -224,7 +224,7 @@\n //!\n //! `try!` is imported by the prelude, and is available everywhere.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Result::{Ok, Err};\n \n@@ -241,22 +241,22 @@ use slice;\n /// See the [`std::result`](index.html) module documentation for details.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n #[must_use]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Result<T, E> {\n     /// Contains the success value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Ok(T),\n \n     /// Contains the error value\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Err(E)\n }\n \n /////////////////////////////////////////////////////////////////////////////\n // Type implementation\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n     // Querying the contained values\n@@ -274,7 +274,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_ok(), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_ok(&self) -> bool {\n         match *self {\n             Ok(_) => true,\n@@ -294,7 +294,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_err(), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_err(&self) -> bool {\n         !self.is_ok()\n     }\n@@ -318,7 +318,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.ok(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ok(self) -> Option<T> {\n         match self {\n             Ok(x)  => Some(x),\n@@ -341,7 +341,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.err(), Some(\"Nothing here\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn err(self) -> Option<E> {\n         match self {\n             Ok(_)  => None,\n@@ -366,7 +366,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ref(&self) -> Result<&T, &E> {\n         match *self {\n             Ok(ref x) => Ok(x),\n@@ -393,7 +393,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), 0);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut(&mut self) -> Result<&mut T, &mut E> {\n         match *self {\n             Ok(ref mut x) => Ok(x),\n@@ -417,7 +417,8 @@ impl<T, E> Result<T, E> {\n     /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n+    #[unstable(feature = \"core\",\n+               reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         match *self {\n             Ok(ref mut x) => slice::mut_ref_slice(x),\n@@ -463,7 +464,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(sum == 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n         match self {\n             Ok(t) => Ok(op(t)),\n@@ -489,7 +490,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -513,7 +514,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { inner: self.as_ref().ok() }\n     }\n@@ -534,7 +535,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: self.as_mut().ok() }\n     }\n@@ -553,7 +554,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(v, vec![]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: self.ok() }\n     }\n@@ -584,7 +585,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(_) => res,\n@@ -608,7 +609,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n@@ -638,7 +639,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n         match self {\n             Ok(_) => self,\n@@ -662,7 +663,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -684,7 +685,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_or(optb), optb);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or(self, optb: T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -704,7 +705,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n             Ok(t) => t,\n@@ -713,7 +714,7 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E: Debug> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n@@ -734,7 +735,7 @@ impl<T, E: Debug> Result<T, E> {\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n@@ -744,7 +745,7 @@ impl<T, E: Debug> Result<T, E> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n@@ -765,7 +766,7 @@ impl<T: Debug, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n@@ -782,7 +783,7 @@ impl<T: Debug, E> Result<T, E> {\n impl<T, E> AsSlice<T> for Result<T, E> {\n     /// Convert from `Result<T, E>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Ok(ref x) => slice::ref_slice(x),\n@@ -800,10 +801,10 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n /////////////////////////////////////////////////////////////////////////////\n \n /// An iterator over a reference to the `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -816,24 +817,24 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n }\n \n /// An iterator over a mutable reference to the `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -846,20 +847,20 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> { inner: Option<T> }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -872,20 +873,20 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n@@ -949,7 +950,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn fold<T,\n             V,\n             E,"}, {"sha": "4a1c123668f27171b9907711bd3469cd8c75949c", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -19,7 +19,6 @@\n //! provided beyond this module.\n //!\n //! ```rust\n-//! #[allow(unstable)];\n //!\n //! fn main() {\n //!     use std::simd::f32x4;\n@@ -37,7 +36,7 @@\n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -46,26 +45,26 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -74,32 +73,32 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]"}, {"sha": "a113a34ef3569b1c814d25b48eb8d06db9253cf2", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 81, "deletions": 79, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,7 @@\n //!\n //! For more details `std::slice`.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"slice\")]\n \n // How this module is organized.\n@@ -125,7 +125,7 @@ pub trait SliceExt {\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -230,7 +230,7 @@ impl<T> SliceExt for [T] {\n         self.repr().data\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n         F: FnMut(&T) -> Ordering\n     {\n@@ -410,12 +410,12 @@ impl<T> SliceExt for [T] {\n         m >= n && needle == &self[m-n..]\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -446,7 +446,7 @@ impl<T> SliceExt for [T] {\n         true\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -489,7 +489,7 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<uint> for [T] {\n     type Output = T;\n \n@@ -500,7 +500,7 @@ impl<T> ops::Index<uint> for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<uint> for [T] {\n     type Output = T;\n \n@@ -511,7 +511,7 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -526,23 +526,23 @@ impl<T> ops::Index<ops::Range<uint>> for [T] {\n         }\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -551,7 +551,7 @@ impl<T> ops::Index<ops::FullRange> for [T] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -566,15 +566,15 @@ impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n         }\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -583,7 +583,7 @@ impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -598,33 +598,34 @@ impl<T> ops::IndexMut<ops::FullRange> for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Data that is viewable as a slice.\n-#[unstable = \"will be replaced by slice syntax\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will be replaced by slice syntax\")]\n pub trait AsSlice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Default for &'a [T] {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> &'a [T] { &[] }\n }\n \n@@ -635,7 +636,7 @@ impl<'a, T> Default for &'a [T] {\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n \n@@ -673,7 +674,7 @@ macro_rules! iterator {\n             }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -715,14 +716,14 @@ macro_rules! make_slice {\n }\n \n /// Immutable slice iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n     marker: marker::ContravariantLifetime<'a>\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -731,7 +732,7 @@ impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -740,7 +741,7 @@ impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -749,7 +750,7 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -763,7 +764,7 @@ impl<'a, T> Iter<'a, T> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n@@ -773,15 +774,15 @@ impl<'a,T> Copy for Iter<'a,T> {}\n \n iterator!{struct Iter -> *const T, &'a T}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -807,39 +808,39 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n }\n \n /// Mutable slice iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -848,31 +849,31 @@ impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -889,15 +890,15 @@ impl<'a, T> IterMut<'a, T> {\n     /// to consume the iterator. Consider using the `Slice` and\n     /// `SliceMut` implementations for obtaining slices with more\n     /// restricted lifetimes that do not consume the iterator.\n-    #[unstable]\n+    #[unstable(feature = \"core\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n }\n \n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n@@ -910,15 +911,15 @@ trait SplitIter: DoubleEndedIterator {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n     pred: P,\n     finished: bool\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     fn clone(&self) -> Split<'a, T, P> {\n         Split {\n@@ -929,7 +930,7 @@ impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a [T];\n \n@@ -957,7 +958,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -983,7 +984,7 @@ impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n     pred: P,\n@@ -1002,7 +1003,7 @@ impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a mut [T];\n \n@@ -1037,7 +1038,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n@@ -1092,37 +1093,37 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n             P: FnMut(&T) -> bool\n         {\n@@ -1148,13 +1149,13 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n \n /// An iterator over overlapping subslices of length `size`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Windows<'a, T> {\n     type Item = &'a [T];\n \n@@ -1186,13 +1187,13 @@ impl<'a, T> Iterator for Windows<'a, T> {\n /// When the slice len is not evenly divided by the chunk size, the last slice\n /// of the iteration will be the remainder.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Chunks<'a, T> {\n     type Item = &'a [T];\n \n@@ -1221,7 +1222,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1237,10 +1238,10 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1264,13 +1265,13 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n /// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for ChunksMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -1300,7 +1301,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1318,23 +1319,23 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n \n //\n // Free functions\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n@@ -1368,7 +1369,8 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"should be renamed to from_raw_parts\"]\n+#[unstable(feature = \"core\",\n+           reason = \"should be renamed to from_raw_parts\")]\n pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1380,7 +1382,8 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable = \"should be renamed to from_raw_parts_mut\"]\n+#[unstable(feature = \"core\",\n+           reason = \"should be renamed to from_raw_parts_mut\")]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1390,7 +1393,7 @@ pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n //\n \n /// Operations on `[u8]`.\n-#[unstable = \"needs review\"]\n+#[unstable(feature = \"core\", reason = \"needs review\")]\n pub mod bytes {\n     use ptr;\n     use slice::SliceExt;\n@@ -1403,7 +1406,6 @@ pub mod bytes {\n \n     impl MutableByteVector for [u8] {\n         #[inline]\n-        #[allow(unstable)]\n         fn set_memory(&mut self, value: u8) {\n             unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n         }\n@@ -1432,7 +1434,7 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n@@ -1444,17 +1446,17 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for [T] {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n@@ -1479,7 +1481,7 @@ impl<T: PartialOrd> PartialOrd for [T] {\n }\n \n /// Extension methods for slices containing integers.\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub trait IntSliceExt<U, S> {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n@@ -1494,7 +1496,7 @@ pub trait IntSliceExt<U, S> {\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n-        #[unstable]\n+        #[unstable(feature = \"core\")]\n         impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }"}, {"sha": "5b94733ea6fd6d3ca5f4e31396c40380b9c2c27c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -47,7 +47,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     ($te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n \n@@ -60,7 +60,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -69,7 +69,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern $te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -82,7 +82,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -91,7 +91,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern forward $te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -110,7 +110,8 @@ macro_rules! delegate_iter {\n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n // FIXME(#17307): there should be an `E` associated type for a `Result` return\n-#[unstable = \"will return a Result once associated types are working\"]\n+#[unstable(feature = \"core\",\n+           reason = \"will return a Result once associated types are working\")]\n pub trait FromStr {\n     /// Parses a string `s` to return an optional value of this type. If the\n     /// string is ill-formatted, the None is returned.\n@@ -145,7 +146,8 @@ Section: Creating a string\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n #[derive(Copy, Eq, PartialEq, Clone, Show)]\n-#[unstable = \"error enumeration recently added and definitions may be refined\"]\n+#[unstable(feature = \"core\",\n+           reason = \"error enumeration recently added and definitions may be refined\")]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given.\n     ///\n@@ -169,15 +171,15 @@ pub enum Utf8Error {\n ///\n /// Returns `Err` if the slice is not utf-8 with a description as to why the\n /// provided slice is not utf-8.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n@@ -195,7 +197,9 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n /// # Panics\n ///\n /// This function will panic if the string pointed to by `s` is not valid UTF-8.\n-#[deprecated = \"use std::ffi::c_str_to_bytes + str::from_utf8\"]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use std::ffi::c_str_to_bytes + str::from_utf8\")]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0;\n@@ -207,7 +211,8 @@ pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n }\n \n /// Something that can be used to compare against a character\n-#[unstable = \"definition may change as pattern-related methods are stabilized\"]\n+#[unstable(feature = \"core\",\n+           reason = \"definition may change as pattern-related methods are stabilized\")]\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n     fn matches(&mut self, char) -> bool;\n@@ -244,7 +249,7 @@ impl<'a> CharEq for &'a [char] {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for Utf8Error {\n     fn description(&self) -> &str {\n         match *self {\n@@ -254,7 +259,7 @@ impl Error for Utf8Error {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Utf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -276,7 +281,7 @@ Section: Iterators\n ///\n /// Created with the method `.chars()`.\n #[derive(Clone, Copy)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n@@ -307,7 +312,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n \n /// Reads the next code point out of a byte iterator (assuming a\n /// UTF-8-like encoding).\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode UTF-8\n     let x = match bytes.next() {\n@@ -339,7 +344,7 @@ pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     Some(ch)\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n \n@@ -360,7 +365,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n@@ -397,13 +402,13 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n     front_offset: uint,\n     iter: Chars<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n     type Item = (uint, char);\n \n@@ -427,7 +432,7 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n@@ -446,7 +451,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n /// Use with the `std::iter` module.\n ///\n /// Created with `StrExt::bytes`\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n delegate_iter!{exact u8 : Bytes<'a>}\n@@ -486,13 +491,13 @@ struct CharSplitsN<'a, Sep> {\n }\n \n /// An iterator over the lines of a string, separated by `\\n`.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Lines<'a> {\n     inner: CharSplits<'a, char>,\n }\n \n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinesAny<'a> {\n     inner: Map<&'a str, &'a str, Lines<'a>, fn(&str) -> &str>,\n }\n@@ -509,7 +514,7 @@ impl<'a, Sep> CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     type Item = &'a str;\n \n@@ -544,7 +549,7 @@ impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n@@ -586,7 +591,7 @@ impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n     type Item = &'a str;\n \n@@ -892,7 +897,7 @@ impl Searcher {\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[derive(Clone)]\n-#[unstable = \"type may be removed\"]\n+#[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct MatchIndices<'a> {\n     // constants\n     haystack: &'a str,\n@@ -903,14 +908,14 @@ pub struct MatchIndices<'a> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[derive(Clone)]\n-#[unstable = \"type may be removed\"]\n+#[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n     last_end: uint,\n     finished: bool\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for MatchIndices<'a> {\n     type Item = (uint, uint);\n \n@@ -927,7 +932,7 @@ impl<'a> Iterator for MatchIndices<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SplitStr<'a> {\n     type Item = &'a str;\n \n@@ -1087,7 +1092,8 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n #[derive(Copy)]\n-#[unstable = \"naming is uncertain with container conventions\"]\n+#[unstable(feature = \"core\",\n+           reason = \"naming is uncertain with container conventions\")]\n pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n@@ -1113,7 +1119,7 @@ mod traits {\n     use ops;\n     use str::{StrExt, eq_slice};\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n@@ -1129,7 +1135,7 @@ mod traits {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n@@ -1139,10 +1145,10 @@ mod traits {\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Eq for str {}\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for str {\n         #[inline]\n         fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n@@ -1176,7 +1182,7 @@ mod traits {\n     /// // byte 100 is outside the string\n     /// // &s[3 .. 100];\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::Range<uint>> for str {\n         type Output = str;\n         #[inline]\n@@ -1199,7 +1205,7 @@ mod traits {\n     ///\n     /// Panics when `end` does not point to a valid character, or is\n     /// out of bounds.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeTo<uint>> for str {\n         type Output = str;\n         #[inline]\n@@ -1219,7 +1225,7 @@ mod traits {\n     ///\n     /// Panics when `begin` does not point to a valid character, or is\n     /// out of bounds.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFrom<uint>> for str {\n         type Output = str;\n         #[inline]\n@@ -1233,7 +1239,7 @@ mod traits {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::FullRange> for str {\n         type Output = str;\n         #[inline]\n@@ -1244,9 +1250,10 @@ mod traits {\n }\n \n /// Any string that can be represented as a slice\n-#[unstable = \"Instead of taking this bound generically, this trait will be \\\n-              replaced with one of slicing syntax (&foo[]), deref coercions, or \\\n-              a more generic conversion trait\"]\n+#[unstable(feature = \"core\",\n+           reason = \"Instead of taking this bound generically, this trait will be \\\n+                     replaced with one of slicing syntax (&foo[]), deref coercions, or \\\n+                     a more generic conversion trait\")]\n pub trait Str {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n@@ -1264,25 +1271,26 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n \n /// Return type of `StrExt::split`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, P>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[derive(Clone)]\n-#[unstable = \"might get removed in favour of a constructor method on Split\"]\n+#[unstable(feature = \"core\",\n+           reason = \"might get removed in favour of a constructor method on Split\")]\n pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n@@ -1648,7 +1656,7 @@ impl StrExt for str {\n /// Pluck a code point out of a UTF-8-like byte slice and return the\n /// index of the next code point.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"core\")]\n pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n     if bytes[i] < 128u8 {\n         return (bytes[i] as u32, i + 1);\n@@ -1671,13 +1679,13 @@ pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n     multibyte_char_range_at(bytes, i)\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Default for &'a str {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> &'a str { \"\" }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Lines<'a> {\n     type Item = &'a str;\n \n@@ -1687,13 +1695,13 @@ impl<'a> Iterator for Lines<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Lines<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for LinesAny<'a> {\n     type Item = &'a str;\n \n@@ -1703,7 +1711,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }"}, {"sha": "64c2964eb7c6986fc36d3c2d89fc786e39ceeae8", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -33,7 +33,7 @@\n //! * `Ord`\n //! * `Default`\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n use cmp::*;\n@@ -55,14 +55,14 @@ macro_rules! tuple_impls {\n         }\n     )+) => {\n         $(\n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(e!(self.$idx.clone()),)+)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -74,10 +74,10 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n@@ -101,17 +101,17 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                     lexical_cmp!($(self.$idx, other.$idx),+)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Default),+> Default for ($($T,)+) {\n-                #[stable]\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n                     ($({ let x: $T = Default::default(); x},)+)"}, {"sha": "8bd2ed95ed5689071dc743aaed8f191f75fea9d5", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -114,7 +114,6 @@ fn discard_doesnt_unborrow() {\n }\n \n #[test]\n-#[allow(unstable)]\n fn clone_ref_updates_flag() {\n     let x = RefCell::new(0i);\n     {"}, {"sha": "0d371dbe15375bd1c0d14c210939ee160f2d920c", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,6 @@\n #![feature(unboxed_closures)]\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n \n extern crate core;\n extern crate test;"}, {"sha": "5f3a68a9e344db215cf23204d157238f310eea1a", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -15,15 +15,18 @@\n //! [mz]: https://code.google.com/p/miniz/\n \n #![crate_name = \"flate\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+#![feature(hash)]\n+#![feature(core)]\n+#![feature(libc)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "d76e4b2ed956aa232afd6f296a61578686c602db", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -15,7 +15,8 @@\n //! generated instead.\n \n #![crate_name = \"fmt_macros\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -26,7 +27,9 @@\n \n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(unicode)]\n \n pub use self::Piece::*;\n pub use self::Position::*;"}, {"sha": "4774262246a338de906dbcaebde80afb29e001e5", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -78,7 +78,9 @@\n //! ```\n \n #![crate_name = \"getopts\"]\n-#![unstable = \"use the crates.io `getopts` library instead\"]\n+#![unstable(feature = \"rustc_private\",\n+            reason = \"use the crates.io `getopts` library instead\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -88,8 +90,10 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![deny(missing_docs)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![cfg_attr(test, feature(rustc_private))]\n \n #[cfg(test)] #[macro_use] extern crate log;\n \n@@ -538,7 +542,9 @@ pub fn opt(short_name: &str,\n \n impl Fail {\n     /// Convert a `Fail` enum into an error string.\n-    #[deprecated=\"use `fmt::String` (`{}` format specifier)\"]\n+    #[unstable(feature = \"rustc_private\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `fmt::String` (`{}` format specifier)\")]\n     pub fn to_err_msg(self) -> String {\n         self.to_string()\n     }"}, {"sha": "171b4ec2097b090d0d273deaa2d9957363b95d25", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -265,7 +265,8 @@\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n #![crate_name = \"graphviz\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -274,7 +275,10 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(path)]\n \n use self::LabelText::*;\n "}, {"sha": "71f117835935d63c8aa4fadab9005537f191b11e", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deprecated = \"use std::vec::CowVec\"]\n+#![unstable(feature = \"rustc_private\")]\n+#![deprecated(since = \"1.0.0\", reason = \"use std::vec::CowVec\")]\n \n pub use self::MaybeOwnedVector::*;\n "}, {"sha": "548782216bbe5f5d8ea936c0c01e38c89e2ae360", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,15 +10,18 @@\n \n #![crate_name = \"libc\"]\n #![crate_type = \"rlib\"]\n-#![cfg_attr(not(feature = \"cargo-build\"), unstable)]\n+#![cfg_attr(not(feature = \"cargo-build\"),\n+            unstable(feature = \"libc\"))]\n+#![cfg_attr(not(feature = \"cargo-build\"), feature(staged_api))]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n+#![cfg_attr(not(feature = \"cargo-build\"), feature(core))]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![no_std]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+#![cfg_attr(test, feature(test))]\n \n //! Bindings for the C standard library and other platform libraries\n //!\n@@ -73,7 +76,6 @@\n //! one from Berkeley after the lawsuits died down and the CSRG dissolved.\n \n #![allow(bad_style, raw_pointer_derive)]\n-\n #[cfg(feature = \"cargo-build\")] extern crate \"std\" as core;\n #[cfg(not(feature = \"cargo-build\"))] extern crate core;\n "}, {"sha": "dfec2c18816e407ce7bf4a8fd34b6a1c0f888806", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -156,7 +156,9 @@\n //! if logging is disabled, none of the components of the log will be executed.\n \n #![crate_name = \"log\"]\n-#![unstable = \"use the crates.io `log` library instead\"]\n+#![unstable(feature = \"rustc_private\",\n+            reason = \"use the crates.io `log` library instead\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -169,8 +171,13 @@\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![deny(missing_docs)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n \n use std::cell::RefCell;\n use std::fmt;"}, {"sha": "25c205b2bf2a8d1a02614e400b32ab1f488bbe0c", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -17,7 +17,7 @@\n //! internally. The `IndependentSample` trait is for generating values\n //! that do not need to record state.\n \n-#![unstable]\n+#![unstable(feature = \"rand\")]\n \n use core::prelude::*;\n use core::num::{Float, Int};"}, {"sha": "762581518505f675b349e5b2696773fa12890438", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -23,10 +23,11 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n #![no_std]\n-#![unstable]\n+#![unstable(feature = \"rand\")]\n+#![feature(staged_api)]\n #![staged_api]\n+#![feature(core)]\n \n #[macro_use]\n extern crate core;"}, {"sha": "10c71cff5be80775a21557fb41664be5766e14a5", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -141,9 +141,9 @@ impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n         *rng = Default::default();\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for ReseedWithDefault {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> ReseedWithDefault { ReseedWithDefault }\n }\n "}, {"sha": "2500cb864632e27a24fa8c1c5dd628123ade3a89", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -16,7 +16,8 @@\n //!     http://www.matroska.org/technical/specs/rfc/index.html\n \n #![crate_name = \"rbml\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -27,7 +28,10 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(rustc_private)]\n \n extern crate serialize;\n #[macro_use] extern crate log;\n@@ -853,7 +857,10 @@ pub mod writer {\n \n     // Set to true to generate more debugging in EBML code.\n     // Totally lame approach.\n+    #[cfg(not(ndebug))]\n     static DEBUG: bool = true;\n+    #[cfg(ndebug)]\n+    static DEBUG: bool = false;\n \n     impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         // used internally to emit things like the vector length and so on"}, {"sha": "580e55f78a9e5385504780e42af0a663df5fc7e2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -15,7 +15,8 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -29,7 +30,17 @@\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n+#![feature(hash)]\n+#![cfg_attr(test, feature(test))]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "f13814527cdfd3a6ddb58b691839c85753a34814", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 131, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -46,7 +46,7 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::{abi, ast, ast_map};\n use syntax::ast_util::is_shift_binop;\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::{self, Span, DUMMY_SP};\n+use syntax::codemap::{self, Span};\n use syntax::parse::token;\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ast_util;\n@@ -662,9 +662,6 @@ impl LintPass for UnusedAttributes {\n             // FIXME: #14407 these are only looked at on-demand so we can't\n             // guarantee they'll have already been checked\n             \"deprecated\",\n-            \"experimental\",\n-            \"frozen\",\n-            \"locked\",\n             \"must_use\",\n             \"stable\",\n             \"unstable\",\n@@ -1696,37 +1693,16 @@ declare_lint! {\n     \"detects use of #[deprecated] items\"\n }\n \n-declare_lint! {\n-    UNSTABLE,\n-    Warn,\n-    \"detects use of #[unstable] items (incl. items with no stability attribute)\"\n-}\n-\n-/// Checks for use of items with `#[deprecated]`, `#[unstable]` and\n-/// `#[unstable]` attributes, or no stability attribute.\n+/// Checks for use of items with `#[deprecated]` attributes\n #[derive(Copy)]\n-pub struct Stability { this_crate_staged: bool }\n+pub struct Stability;\n \n impl Stability {\n-    pub fn new() -> Stability { Stability { this_crate_staged: false } }\n-\n-    fn lint(&self, cx: &Context, id: ast::DefId, span: Span) {\n-\n-        let ref stability = stability::lookup(cx.tcx, id);\n-        let cross_crate = !ast_util::is_local(id);\n-        let staged = (!cross_crate && self.this_crate_staged)\n-            || (cross_crate && stability::is_staged_api(cx.tcx, id));\n+    fn lint(&self, cx: &Context, _id: ast::DefId, span: Span, stability: &Option<attr::Stability>) {\n \n-        if !staged { return }\n-\n-        // stability attributes are promises made across crates; only\n-        // check DEPRECATED for crate-local usage.\n+        // deprecated attributes apply in-crate and cross-crate\n         let (lint, label) = match *stability {\n-            // no stability attributes == Unstable\n-            None if cross_crate => (UNSTABLE, \"unmarked\"),\n-            Some(attr::Stability { level: attr::Unstable, .. }) if cross_crate =>\n-                (UNSTABLE, \"unstable\"),\n-            Some(attr::Stability { level: attr::Deprecated, .. }) =>\n+            Some(attr::Stability { deprecated_since: Some(_), .. }) =>\n                 (DEPRECATED, \"deprecated\"),\n             _ => return\n         };\n@@ -1736,7 +1712,7 @@ impl Stability {\n         fn output(cx: &Context, span: Span, stability: &Option<attr::Stability>,\n                   lint: &'static Lint, label: &'static str) {\n             let msg = match *stability {\n-                Some(attr::Stability { text: Some(ref s), .. }) => {\n+                Some(attr::Stability { reason: Some(ref s), .. }) => {\n                     format!(\"use of {} item: {}\", label, *s)\n                 }\n                 _ => format!(\"use of {} item\", label)\n@@ -1745,111 +1721,21 @@ impl Stability {\n             cx.span_lint(lint, span, &msg[]);\n         }\n     }\n-\n-\n-    fn is_internal(&self, cx: &Context, span: Span) -> bool {\n-        cx.tcx.sess.codemap().span_is_internal(span)\n-    }\n-\n }\n \n impl LintPass for Stability {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(DEPRECATED, UNSTABLE)\n-    }\n-\n-    fn check_crate(&mut self, _: &Context, c: &ast::Crate) {\n-        // Just mark the #[staged_api] attribute used, though nothing else is done\n-        // with it during this pass over the source.\n-        for attr in c.attrs.iter() {\n-            if attr.name().get() == \"staged_api\" {\n-                match attr.node.value.node {\n-                    ast::MetaWord(_) => {\n-                        attr::mark_used(attr);\n-                        self.this_crate_staged = true;\n-                    }\n-                    _ => (/*pass*/)\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if self.is_internal(cx, e.span) { return; }\n-\n-        let mut span = e.span;\n-\n-        let id = match e.node {\n-            ast::ExprPath(..) | ast::ExprQPath(..) | ast::ExprStruct(..) => {\n-                match cx.tcx.def_map.borrow().get(&e.id) {\n-                    Some(&def) => def.def_id(),\n-                    None => return\n-                }\n-            }\n-            ast::ExprMethodCall(i, _, _) => {\n-                span = i.span;\n-                let method_call = ty::MethodCall::expr(e.id);\n-                match cx.tcx.method_map.borrow().get(&method_call) {\n-                    Some(method) => {\n-                        match method.origin {\n-                            ty::MethodStatic(def_id) => {\n-                                def_id\n-                            }\n-                            ty::MethodStaticClosure(def_id) => {\n-                                def_id\n-                            }\n-                            ty::MethodTypeParam(ty::MethodParam {\n-                                ref trait_ref,\n-                                method_num: index,\n-                                ..\n-                            }) |\n-                            ty::MethodTraitObject(ty::MethodObject {\n-                                ref trait_ref,\n-                                method_num: index,\n-                                ..\n-                            }) => {\n-                                ty::trait_item(cx.tcx, trait_ref.def_id, index).def_id()\n-                            }\n-                        }\n-                    }\n-                    None => return\n-                }\n-            }\n-            _ => return\n-        };\n-\n-        self.lint(cx, id, span);\n+        lint_array!(DEPRECATED)\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if self.is_internal(cx, item.span) { return }\n-\n-        match item.node {\n-            ast::ItemExternCrate(_) => {\n-                // compiler-generated `extern crate` items have a dummy span.\n-                if item.span == DUMMY_SP { return }\n+        stability::check_item(cx.tcx, item,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+    }\n \n-                let cnum = match cx.tcx.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n-                    Some(cnum) => cnum,\n-                    None => return,\n-                };\n-                let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n-                self.lint(cx, id, item.span);\n-            }\n-            ast::ItemTrait(_, _, ref supertraits, _) => {\n-                for t in supertraits.iter() {\n-                    if let ast::TraitTyParamBound(ref t, _) = *t {\n-                        let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n-                        self.lint(cx, id, t.trait_ref.path.span);\n-                    }\n-                }\n-            }\n-            ast::ItemImpl(_, _, _, Some(ref t), _, _) => {\n-                let id = ty::trait_ref_to_def_id(cx.tcx, t);\n-                self.lint(cx, id, t.path.span);\n-            }\n-            _ => (/* pass */)\n-        }\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        stability::check_expr(cx.tcx, e,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n     }\n }\n \n@@ -2096,9 +1982,9 @@ declare_lint! {\n }\n \n declare_lint! {\n-    pub UNKNOWN_FEATURES,\n+    pub UNUSED_FEATURES,\n     Deny,\n-    \"unknown features found in crate-level #[feature] directives\"\n+    \"unused or unknown features found in crate-level #[feature] directives\"\n }\n \n declare_lint! {\n@@ -2142,7 +2028,7 @@ impl LintPass for HardwiredLints {\n             DEAD_CODE,\n             UNREACHABLE_CODE,\n             WARNINGS,\n-            UNKNOWN_FEATURES,\n+            UNUSED_FEATURES,\n             UNKNOWN_CRATE_TYPES,\n             VARIANT_SIZE_DIFFERENCES,\n             FAT_PTR_TRANSMUTES"}, {"sha": "3a103e421016f398cbbe4f20e766b5476e9b27d5", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -211,14 +211,14 @@ impl LintStore {\n                      UnusedAllocation,\n                      MissingCopyImplementations,\n                      UnstableFeatures,\n+                     Stability,\n                      UnconditionalRecursion,\n         );\n \n         add_builtin_with_new!(sess,\n                               TypeLimits,\n                               RawPointerDerive,\n                               MissingDoc,\n-                              Stability,\n                               MissingDebugImplementations,\n         );\n \n@@ -236,6 +236,7 @@ impl LintStore {\n         // Insert temporary renamings for a one-time deprecation\n         self.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");\n \n+        self.register_renamed(\"unknown_features\", \"unused_features\");\n     }\n \n     #[allow(unused_variables)]\n@@ -295,15 +296,6 @@ impl LintStore {\n             },\n             None => unreachable!()\n         }\n-        match self.by_name.get(\"unstable\") {\n-            Some(&Id(lint_id)) => if self.get_level_source(lint_id).0 != Forbid {\n-                self.set_level(lint_id, (lvl, ReleaseChannel))\n-            },\n-            Some(&Renamed(_, lint_id)) => if self.get_level_source(lint_id).0 != Forbid {\n-                self.set_level(lint_id, (lvl, ReleaseChannel))\n-            },\n-            None => unreachable!()\n-        }\n     }\n }\n \n@@ -809,6 +801,5 @@ pub fn check_crate(tcx: &ty::ctxt,\n         }\n     }\n \n-    tcx.sess.abort_if_errors();\n     *tcx.node_lint_levels.borrow_mut() = cx.node_levels.into_inner();\n }"}, {"sha": "7b5af0ab1aa2ff2cc848ac7da12d25645b2cd961", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 256, "deletions": 40, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -11,48 +11,55 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n+use session::Session;\n+use lint;\n use middle::ty;\n use metadata::csearch;\n-use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+use syntax::codemap::{Span, DUMMY_SP};\n use syntax::{attr, visit};\n use syntax::ast;\n use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n use syntax::ast::{Item, RequiredMethod, ProvidedMethod, TraitItem};\n use syntax::ast::{TypeMethod, Method, Generics, StructField, TypeTraitItem};\n use syntax::ast_util::is_local;\n-use syntax::attr::Stability;\n+use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, FkMethod, Visitor};\n-use util::nodemap::{NodeMap, DefIdMap};\n+use syntax::feature_gate::emit_feature_warn;\n+use util::nodemap::{NodeMap, DefIdMap, FnvHashSet, FnvHashMap};\n use util::ppaux::Repr;\n \n use std::mem::replace;\n \n /// A stability index, giving the stability level for items and methods.\n pub struct Index {\n+    // Indicates whether this crate has #![feature(staged_api)]\n+    staged_api: bool,\n     // stability for crate-local items; unmarked stability == no entry\n     local: NodeMap<Stability>,\n     // cache for extern-crate items; unmarked stability == entry with None\n     extern_cache: DefIdMap<Option<Stability>>\n }\n \n // A private tree-walker for producing an Index.\n-struct Annotator {\n+struct Annotator<'a> {\n+    sess: &'a Session,\n     index: Index,\n     parent: Option<Stability>\n }\n \n-impl Annotator {\n+impl<'a> Annotator<'a> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, id: NodeId, use_parent: bool,\n-                   attrs: &Vec<Attribute>, f: F) where\n+                   attrs: &Vec<Attribute>, item_sp: Span, f: F) where\n         F: FnOnce(&mut Annotator),\n     {\n-        match attr::find_stability(attrs.as_slice()) {\n+        match attr::find_stability(self.sess.diagnostic(), attrs.as_slice(), item_sp) {\n             Some(stab) => {\n                 self.index.local.insert(id, stab.clone());\n \n-                // Don't inherit #[stable]\n+                // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                 if stab.level != attr::Stable {\n                     let parent = replace(&mut self.parent, Some(stab));\n                     f(self);\n@@ -71,7 +78,7 @@ impl Annotator {\n     }\n }\n \n-impl<'v> Visitor<'v> for Annotator {\n+impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n     fn visit_item(&mut self, i: &Item) {\n         // FIXME (#18969): the following is a hack around the fact\n         // that we cannot currently annotate the stability of\n@@ -86,72 +93,276 @@ impl<'v> Visitor<'v> for Annotator {\n             _ => true,\n         };\n \n-        self.annotate(i.id, use_parent, &i.attrs, |v| visit::walk_item(v, i));\n+        self.annotate(i.id, use_parent, &i.attrs, i.span, |v| visit::walk_item(v, i));\n \n         if let ast::ItemStruct(ref sd, _) = i.node {\n             sd.ctor_id.map(|id| {\n-                self.annotate(id, true, &i.attrs, |_| {})\n+                self.annotate(id, true, &i.attrs, i.span, |_| {})\n             });\n         }\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, _: &'v FnDecl,\n-                _: &'v Block, _: Span, _: NodeId) {\n+                _: &'v Block, sp: Span, _: NodeId) {\n         if let FkMethod(_, _, meth) = fk {\n             // Methods are not already annotated, so we annotate it\n-            self.annotate(meth.id, true, &meth.attrs, |_| {});\n+            self.annotate(meth.id, true, &meth.attrs, sp, |_| {});\n         }\n         // Items defined in a function body have no reason to have\n         // a stability attribute, so we don't recurse.\n     }\n \n     fn visit_trait_item(&mut self, t: &TraitItem) {\n-        let (id, attrs) = match *t {\n-            RequiredMethod(TypeMethod {id, ref attrs, ..}) => (id, attrs),\n+        let (id, attrs, sp) = match *t {\n+            RequiredMethod(TypeMethod {id, ref attrs, span, ..}) => (id, attrs, span),\n \n             // work around lack of pattern matching for @ types\n             ProvidedMethod(ref method) => {\n                 match **method {\n-                    Method {ref attrs, id, ..} => (id, attrs),\n+                    Method {ref attrs, id, span, ..} => (id, attrs, span),\n                 }\n             }\n \n-            TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs),\n+            TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs,\n+                                           typedef.ty_param.span),\n         };\n-        self.annotate(id, true, attrs, |v| visit::walk_trait_item(v, t));\n+        self.annotate(id, true, attrs, sp, |v| visit::walk_trait_item(v, t));\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics) {\n-        self.annotate(var.node.id, true, &var.node.attrs,\n+        self.annotate(var.node.id, true, &var.node.attrs, var.span,\n                       |v| visit::walk_variant(v, var, g))\n     }\n \n     fn visit_struct_field(&mut self, s: &StructField) {\n-        self.annotate(s.node.id, true, &s.node.attrs,\n+        self.annotate(s.node.id, true, &s.node.attrs, s.span,\n                       |v| visit::walk_struct_field(v, s));\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        self.annotate(i.id, true, &i.attrs, |_| {});\n+        self.annotate(i.id, true, &i.attrs, i.span, |_| {});\n     }\n }\n \n impl Index {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(krate: &Crate) -> Index {\n+    pub fn build(sess: &Session, krate: &Crate) -> Index {\n+        let mut staged_api = false;\n+        for attr in krate.attrs.iter() {\n+            if attr.name().get() == \"staged_api\" {\n+                match attr.node.value.node {\n+                    ast::MetaWord(_) => {\n+                        attr::mark_used(attr);\n+                        staged_api = true;\n+                    }\n+                    _ => (/*pass*/)\n+                }\n+            }\n+        }\n+        let index = Index {\n+            staged_api: staged_api,\n+            local: NodeMap(),\n+            extern_cache: DefIdMap()\n+        };\n+        if !staged_api {\n+            return index;\n+        }\n         let mut annotator = Annotator {\n-            index: Index {\n-                local: NodeMap(),\n-                extern_cache: DefIdMap()\n-            },\n+            sess: sess,\n+            index: index,\n             parent: None\n         };\n-        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs,\n+        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs, krate.span,\n                            |v| visit::walk_crate(v, krate));\n         annotator.index\n     }\n }\n \n+/// Cross-references the feature names of unstable APIs with enabled\n+/// features and possibly prints errors. Returns a list of all\n+/// features used.\n+pub fn check_unstable_api_usage(tcx: &ty::ctxt) -> FnvHashSet<InternedString> {\n+    let ref active_lib_features = tcx.sess.features.borrow().lib_features;\n+\n+    // Put the active features into a map for quick lookup\n+    let active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+\n+    let mut checker = Checker {\n+        tcx: tcx,\n+        active_features: active_features,\n+        used_features: FnvHashSet()\n+    };\n+\n+    let krate = tcx.map.krate();\n+    visit::walk_crate(&mut checker, krate);\n+\n+    let used_features = checker.used_features;\n+    return used_features;\n+}\n+\n+struct Checker<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    active_features: FnvHashSet<InternedString>,\n+    used_features: FnvHashSet<InternedString>\n+}\n+\n+impl<'a, 'tcx> Checker<'a, 'tcx> {\n+    fn check(&mut self, id: ast::DefId, span: Span, stab: &Option<Stability>) {\n+        // Only the cross-crate scenario matters when checking unstable APIs\n+        let cross_crate = !is_local(id);\n+        if !cross_crate { return }\n+\n+        match *stab {\n+            Some(Stability { level: attr::Unstable, ref feature, ref reason, .. }) => {\n+                self.used_features.insert(feature.clone());\n+\n+                if !self.active_features.contains(feature) {\n+                    let msg = match *reason {\n+                        Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n+                                               feature.get(), r.get()),\n+                        None => format!(\"use of unstable library feature '{}'\", feature.get())\n+                    };\n+\n+                    emit_feature_warn(&self.tcx.sess.parse_sess.span_diagnostic,\n+                                      feature.get(), span, &msg[]);\n+                }\n+            }\n+            Some(..) => {\n+                // Stable APIs are always ok to call and deprecated APIs are\n+                // handled by a lint.\n+            }\n+            None => {\n+                // This is an 'unmarked' API, which should not exist\n+                // in the standard library.\n+                self.tcx.sess.span_err(span, \"use of unmarked library feature\");\n+                self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n+                                               using or a bug in the compiler - there is \\\n+                                               no way to use this feature\");\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        check_item(self.tcx, item,\n+                   &mut |id, sp, stab| self.check(id, sp, stab));\n+        visit::walk_item(self, item);\n+    }\n+\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n+        check_expr(self.tcx, ex,\n+                   &mut |id, sp, stab| self.check(id, sp, stab));\n+        visit::walk_expr(self, ex);\n+    }\n+}\n+\n+/// Helper for discovering nodes to check for stability\n+pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    match item.node {\n+        ast::ItemExternCrate(_) => {\n+            // compiler-generated `extern crate` items have a dummy span.\n+            if item.span == DUMMY_SP { return }\n+\n+            let cnum = match tcx.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                Some(cnum) => cnum,\n+                None => return,\n+            };\n+            let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+            maybe_do_stability_check(tcx, id, item.span, cb);\n+        }\n+        ast::ItemTrait(_, _, ref supertraits, _) => {\n+            for t in supertraits.iter() {\n+                if let ast::TraitTyParamBound(ref t, _) = *t {\n+                    let id = ty::trait_ref_to_def_id(tcx, &t.trait_ref);\n+                    maybe_do_stability_check(tcx, id, t.trait_ref.path.span, cb);\n+                }\n+            }\n+        }\n+        ast::ItemImpl(_, _, _, Some(ref t), _, _) => {\n+            let id = ty::trait_ref_to_def_id(tcx, t);\n+            maybe_do_stability_check(tcx, id, t.path.span, cb);\n+        }\n+        _ => (/* pass */)\n+    }\n+}\n+\n+/// Helper for discovering nodes to check for stability\n+pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    if is_internal(tcx, e.span) { return; }\n+\n+    let mut span = e.span;\n+\n+    let id = match e.node {\n+        ast::ExprPath(..) | ast::ExprQPath(..) | ast::ExprStruct(..) => {\n+            match tcx.def_map.borrow().get(&e.id) {\n+                Some(&def) => def.def_id(),\n+                None => return\n+            }\n+        }\n+        ast::ExprMethodCall(i, _, _) => {\n+            span = i.span;\n+            let method_call = ty::MethodCall::expr(e.id);\n+            match tcx.method_map.borrow().get(&method_call) {\n+                Some(method) => {\n+                    match method.origin {\n+                        ty::MethodStatic(def_id) => {\n+                            def_id\n+                        }\n+                        ty::MethodStaticClosure(def_id) => {\n+                            def_id\n+                        }\n+                        ty::MethodTypeParam(ty::MethodParam {\n+                            ref trait_ref,\n+                            method_num: index,\n+                            ..\n+                        }) |\n+                        ty::MethodTraitObject(ty::MethodObject {\n+                            ref trait_ref,\n+                            method_num: index,\n+                            ..\n+                        }) => {\n+                            ty::trait_item(tcx, trait_ref.def_id, index).def_id()\n+                        }\n+                    }\n+                }\n+                None => return\n+            }\n+        }\n+        _ => return\n+    };\n+\n+    maybe_do_stability_check(tcx, id, span, cb);\n+}\n+\n+fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n+                            cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    if !is_staged_api(tcx, id) { return  }\n+    let ref stability = lookup(tcx, id);\n+    cb(id, span, stability);\n+}\n+\n+fn is_internal(tcx: &ty::ctxt, span: Span) -> bool {\n+    tcx.sess.codemap().span_is_internal(span)\n+}\n+\n+fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n+    match ty::trait_item_of_item(tcx, id) {\n+        Some(ty::MethodTraitItemId(trait_method_id))\n+            if trait_method_id != id => {\n+                is_staged_api(tcx, trait_method_id)\n+            }\n+        _ if is_local(id) => {\n+            tcx.stability.borrow().staged_api\n+        }\n+        _ => {\n+            csearch::is_staged_api(&tcx.sess.cstore, id)\n+        }\n+    }\n+}\n+\n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n@@ -190,18 +401,23 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n     })\n }\n \n-pub fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n-    match ty::trait_item_of_item(tcx, id) {\n-        Some(ty::MethodTraitItemId(trait_method_id))\n-            if trait_method_id != id => {\n-                is_staged_api(tcx, trait_method_id)\n-            }\n-        _ if is_local(id) => {\n-            // Unused case\n-            unreachable!()\n-        }\n-        _ => {\n-            csearch::is_staged_api(&tcx.sess.cstore, id)\n-        }\n+/// Given the list of enabled features that were not language features (i.e. that\n+/// were expected to be library features), and the list of features used from\n+/// libraries, identify activated features that don't exist and error about them.\n+pub fn check_unused_features(sess: &Session,\n+                             used_lib_features: &FnvHashSet<InternedString>) {\n+    let ref lib_features = sess.features.borrow().lib_features;\n+    let mut active_lib_features: FnvHashMap<InternedString, Span>\n+        = lib_features.clone().into_iter().collect();\n+\n+    for used_feature in used_lib_features.iter() {\n+        active_lib_features.remove(used_feature);\n+    }\n+\n+    for (_, &span) in active_lib_features.iter() {\n+        sess.add_lint(lint::builtin::UNUSED_FEATURES,\n+                      ast::CRATE_NODE_ID,\n+                      span,\n+                      \"unused or unknown feature\".to_string());\n     }\n }"}, {"sha": "e62f3145e5a2e5e894a5ac06bdbfaf7fc9533ce0", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -305,9 +305,19 @@ pub fn build_session(sopts: config::Options,\n                      local_crate_source_file: Option<Path>,\n                      registry: diagnostics::registry::Registry)\n                      -> Session {\n+    // FIXME: This is not general enough to make the warning lint completely override\n+    // normal diagnostic warnings, since the warning lint can also be denied and changed\n+    // later via the source code.\n+    let can_print_warnings = sopts.lint_opts\n+        .iter()\n+        .filter(|&&(ref key, _)| *key == \"warnings\")\n+        .map(|&(_, ref level)| *level != lint::Allow)\n+        .last()\n+        .unwrap_or(true);\n+\n     let codemap = codemap::CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::default_handler(sopts.color, Some(registry));\n+        diagnostic::default_handler(sopts.color, Some(registry), can_print_warnings);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "13dec65d13ea70c6f7e9e949acf0712e11c19707", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -22,7 +22,8 @@\n //! build speedups.\n \n #![crate_name = \"rustc_back\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -32,7 +33,13 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax, box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(hash)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "a63e8237b4bef01780b68125debe00955e18a111", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -223,7 +223,7 @@ impl Target {\n         // this is 1. ugly, 2. error prone.\n \n \n-        let handler = diagnostic::default_handler(diagnostic::Auto, None);\n+        let handler = diagnostic::default_handler(diagnostic::Auto, None, true);\n \n         let get_req_field = |&: name: &str| {\n             match obj.find(name)"}, {"sha": "e0f5b5c387f9ab11829a2fbf7ef4c86561b20396", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_bitflags\"]\n-#![unstable]\n+#![allow(unknown_features)]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![no_std]\n+#![unstable(feature = \"rustc_private\")]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "d525c22f0ab6f22de8bfc8603bc87c3493fb4bd3", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_borrowck\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -23,7 +24,10 @@\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n+#![feature(hash)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "6e76519ce23607fdbaf1b6567febd5f45b2e44c0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -390,16 +390,10 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // baz! should not use this definition unless foo is enabled.\n \n     time(time_passes, \"gated macro checking\", (), |_| {\n-        let (features, unknown_features) =\n+        let features =\n             syntax::feature_gate::check_crate_macros(sess.codemap(),\n                                                      &sess.parse_sess.span_diagnostic,\n                                                      &krate);\n-        for uf in unknown_features.iter() {\n-            sess.add_lint(lint::builtin::UNKNOWN_FEATURES,\n-                          ast::CRATE_NODE_ID,\n-                          *uf,\n-                          \"unknown feature\".to_string());\n-        }\n \n         // these need to be set \"early\" so that expansion sees `quote` if enabled.\n         *sess.features.borrow_mut() = features;\n@@ -492,9 +486,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     time(time_passes, \"complete gated feature checking\", (), |_| {\n-        syntax::feature_gate::check_crate(sess.codemap(),\n+        let features =\n+            syntax::feature_gate::check_crate(sess.codemap(),\n                                           &sess.parse_sess.span_diagnostic,\n                                           &krate);\n+        *sess.features.borrow_mut() = features;\n         sess.abort_if_errors();\n     });\n \n@@ -599,7 +595,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n          middle::check_loop::check_crate(&sess, krate));\n \n     let stability_index = time(time_passes, \"stability index\", (), |_|\n-                               stability::Index::build(krate));\n+                               stability::Index::build(&sess, krate));\n \n     time(time_passes, \"static item recursion checking\", (), |_|\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n@@ -668,9 +664,20 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                   &reachable_map)\n     });\n \n+    let ref lib_features_used =\n+        time(time_passes, \"stability checking\", (), |_|\n+             stability::check_unstable_api_usage(&ty_cx));\n+\n+    time(time_passes, \"unused feature checking\", (), |_|\n+         stability::check_unused_features(\n+             &ty_cx.sess, lib_features_used));\n+\n     time(time_passes, \"lint checking\", (), |_|\n          lint::check_crate(&ty_cx, &exported_items));\n \n+    // The above three passes generate errors w/o aborting\n+    ty_cx.sess.abort_if_errors();\n+\n     ty::CrateAnalysis {\n         export_map: export_map,\n         ty_cx: ty_cx,"}, {"sha": "727638c29c35fb196c4ee9c154031a5971baa319", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -15,7 +15,8 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_driver\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -29,7 +30,15 @@\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "52d7415a523df3467ea215b1a13f7a88327325b0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -103,7 +103,7 @@ fn test_env<F>(source_string: &str,\n     let codemap =\n         CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::mk_handler(emitter);\n+        diagnostic::mk_handler(true, emitter);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n@@ -125,7 +125,7 @@ fn test_env<F>(source_string: &str,\n         resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    let stability_index = stability::Index::build(krate);\n+    let stability_index = stability::Index::build(&sess, krate);\n     let tcx = ty::mk_ctxt(sess,\n                           &arenas,\n                           def_map,"}, {"sha": "17191356d3fb063a3dd656c7e20b7dd11e73c3d8", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,8 @@\n #![allow(dead_code)]\n \n #![crate_name = \"rustc_llvm\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -26,7 +27,12 @@\n #![feature(link_args)]\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(libc)]\n+#![feature(path)]\n+#![feature(std_misc)]\n+#![feature(hash)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "dbac2358047dfb561cad273bbc7db595961d73eb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_privacy\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -19,7 +20,9 @@\n \n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "1d9c701a16c417aa36d195f230984b3307d7be6e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_resolve\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -20,7 +21,12 @@\n #![feature(slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(alloc)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(hash)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "15b9d6237ed4ce2db0041f39719d17c0269b82c1", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -911,7 +911,7 @@ fn run_work_multithreaded(sess: &Session,\n         futures.push(rx);\n \n         thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move |:| {\n-            let diag_handler = mk_handler(box diag_emitter);\n+            let diag_handler = mk_handler(true, box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n             // fields."}, {"sha": "bb026e237df82051b917b20a5b25ba9b1e596c1a", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -15,7 +15,8 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_trans\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -29,7 +30,17 @@\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(alloc)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n+#![feature(hash)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "31c9f9961260a116552ed2fa1b70cb97d05d1f7e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -64,7 +64,8 @@ This API is completely unstable and subject to change.\n */\n \n #![crate_name = \"rustc_typeck\"]\n-#![unstable]\n+#![unstable(feature = \"rustc_private\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -79,7 +80,10 @@ This API is completely unstable and subject to change.\n #![feature(rustc_diagnostic_macros)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "c12726c8868cad9c4cdd7a984b161547756d2857", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -32,6 +32,7 @@ use syntax::ast_util;\n use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n+use syntax::codemap;\n use syntax::codemap::{DUMMY_SP, Pos, Spanned};\n use syntax::parse::token::{self, InternedString, special_idents};\n use syntax::ptr::P;\n@@ -446,11 +447,13 @@ impl attr::AttrMetaMethods for Attribute {\n         }\n     }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n+    fn span(&self) -> codemap::Span { unimplemented!() }\n }\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n     fn meta_item_list(&self) -> Option<&[P<ast::MetaItem>]> { None }\n+    fn span(&self) -> codemap::Span { unimplemented!() }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n@@ -2473,15 +2476,20 @@ impl Clean<Item> for doctree::Macro {\n #[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Stability {\n     pub level: attr::StabilityLevel,\n-    pub text: String\n+    pub feature: String,\n+    pub since: String,\n+    pub reason: String\n }\n \n impl Clean<Stability> for attr::Stability {\n     fn clean(&self, _: &DocContext) -> Stability {\n         Stability {\n             level: self.level,\n-            text: self.text.as_ref().map_or(\"\".to_string(),\n-                                            |interned| interned.get().to_string()),\n+            feature: self.feature.get().to_string(),\n+            since: self.since.as_ref().map_or(\"\".to_string(),\n+                                              |interned| interned.get().to_string()),\n+            reason: self.reason.as_ref().map_or(\"\".to_string(),\n+                                                |interned| interned.get().to_string()),\n         }\n     }\n }"}, {"sha": "fc3d6f5912ffb566c1a88f73001fc21551192c87", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -108,7 +108,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     };\n \n     let codemap = codemap::CodeMap::new();\n-    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n+    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None, true);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "b6db3222f3053b3c3fe0cb5eaa3207ecddab7080", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -714,7 +714,7 @@ impl<'a> fmt::Display for Stability<'a> {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level,\n-                       reason = stability.text)\n+                       reason = stability.reason)\n             }\n             None => Ok(())\n         }\n@@ -728,8 +728,8 @@ impl<'a> fmt::Display for ConciseStability<'a> {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n                        lvl = stability.level,\n-                       colon = if stability.text.len() > 0 { \": \" } else { \"\" },\n-                       reason = stability.text)\n+                       colon = if stability.reason.len() > 0 { \": \" } else { \"\" },\n+                       reason = stability.reason)\n             }\n             None => {\n                 write!(f, \"<a class='stability Unmarked' title='No stability level'></a>\")\n@@ -765,12 +765,6 @@ impl fmt::Display for ModuleSummary {\n             try!(write!(f, \"<span class='summary Unstable' \\\n                             style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n                         (100 * cnt.unstable) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Experimental' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.experimental) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Deprecated' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.deprecated) as f64/tot as f64));\n             try!(write!(f, \"<span class='summary Unmarked' \\\n                             style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n                         (100 * cnt.unmarked) as f64/tot as f64));\n@@ -786,13 +780,11 @@ impl fmt::Display for ModuleSummary {\n         let mut context = Vec::new();\n \n         let tot = self.counts.total();\n-        let (stable, unstable, experimental, deprecated, unmarked) = if tot == 0 {\n-            (0, 0, 0, 0, 0)\n+        let (stable, unstable, unmarked) = if tot == 0 {\n+            (0, 0, 0)\n         } else {\n             ((100 * self.counts.stable)/tot,\n              (100 * self.counts.unstable)/tot,\n-             (100 * self.counts.experimental)/tot,\n-             (100 * self.counts.deprecated)/tot,\n              (100 * self.counts.unmarked)/tot)\n         };\n \n@@ -804,13 +796,11 @@ its children (percentages total for {name}):\n <blockquote>\n <a class='stability Stable'></a> stable ({}%),<br/>\n <a class='stability Unstable'></a> unstable ({}%),<br/>\n-<a class='stability Experimental'></a> experimental ({}%),<br/>\n-<a class='stability Deprecated'></a> deprecated ({}%),<br/>\n <a class='stability Unmarked'></a> unmarked ({}%)\n </blockquote>\n The counts do not include methods or trait\n implementations that are visible only through a re-exported type.\",\n-stable, unstable, experimental, deprecated, unmarked,\n+stable, unstable, unmarked,\n name=self.name));\n         try!(write!(f, \"<table>\"));\n         try!(fmt_inner(f, &mut context, self));"}, {"sha": "75812a2803c07fad4598fe01189a4b7de607aa51", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![crate_name = \"rustdoc\"]\n-#![unstable]\n+#![unstable(feature = \"rustdoc\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -20,7 +21,17 @@\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(test)]\n+#![feature(unicode)]\n+#![feature(hash)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "f1d9aef7f7ce8c10b71526cacbb7248c42728fef", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -16,7 +16,7 @@\n use std::cmp::Ordering;\n use std::ops::Add;\n \n-use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n+use syntax::attr::{Unstable, Stable};\n use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n@@ -29,12 +29,8 @@ use html::render::cache;\n /// The counts for each stability level.\n #[derive(Copy)]\n pub struct Counts {\n-    pub deprecated: uint,\n-    pub experimental: uint,\n     pub unstable: uint,\n     pub stable: uint,\n-    pub frozen: uint,\n-    pub locked: uint,\n \n     /// No stability level, inherited or otherwise.\n     pub unmarked: uint,\n@@ -45,12 +41,8 @@ impl Add for Counts {\n \n     fn add(self, other: Counts) -> Counts {\n         Counts {\n-            deprecated:   self.deprecated   + other.deprecated,\n-            experimental: self.experimental + other.experimental,\n             unstable:     self.unstable     + other.unstable,\n             stable:       self.stable       + other.stable,\n-            frozen:       self.frozen       + other.frozen,\n-            locked:       self.locked       + other.locked,\n             unmarked:     self.unmarked     + other.unmarked,\n         }\n     }\n@@ -59,19 +51,14 @@ impl Add for Counts {\n impl Counts {\n     fn zero() -> Counts {\n         Counts {\n-            deprecated:   0,\n-            experimental: 0,\n             unstable:     0,\n             stable:       0,\n-            frozen:       0,\n-            locked:       0,\n             unmarked:     0,\n         }\n     }\n \n     pub fn total(&self) -> uint {\n-        self.deprecated + self.experimental + self.unstable + self.stable +\n-            self.frozen + self.locked + self.unmarked\n+        self.unstable + self.stable + self.unmarked\n     }\n }\n \n@@ -106,14 +93,10 @@ fn visible(item: &Item) -> bool {\n \n fn count_stability(stab: Option<&Stability>) -> Counts {\n     match stab {\n-        None             => Counts { unmarked: 1,     .. Counts::zero() },\n+        None            => Counts { unmarked: 1,     .. Counts::zero() },\n         Some(ref stab) => match stab.level {\n-            Deprecated   => Counts { deprecated: 1,   .. Counts::zero() },\n-            Experimental => Counts { experimental: 1, .. Counts::zero() },\n-            Unstable     => Counts { unstable: 1,     .. Counts::zero() },\n-            Stable       => Counts { stable: 1,       .. Counts::zero() },\n-            Frozen       => Counts { frozen: 1,       .. Counts::zero() },\n-            Locked       => Counts { locked: 1,       .. Counts::zero() },\n+            Unstable    => Counts { unstable: 1,     .. Counts::zero() },\n+            Stable      => Counts { stable: 1,       .. Counts::zero() },\n         }\n     }\n }"}, {"sha": "2f692fe99cda7f61275a4f204a1fd1946bbf512b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -58,7 +58,7 @@ pub fn run(input: &str,\n     };\n \n     let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n+    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None, true);\n     let span_diagnostic_handler =\n     diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n@@ -164,7 +164,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n \n     // Compile the code\n     let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::mk_handler(box emitter);\n+    let diagnostic_handler = diagnostic::mk_handler(true, box emitter);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "d51bb3af62728a98f929c1a37a6d6844bcf15503", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -15,7 +15,9 @@ Core encoding and decoding interfaces.\n */\n \n #![crate_name = \"serialize\"]\n-#![unstable = \"deprecated in favor of rustc-serialize on crates.io\"]\n+#![unstable(feature = \"rustc_private\",\n+            reason = \"deprecated in favor of rustc-serialize on crates.io\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -28,7 +30,14 @@ Core encoding and decoding interfaces.\n #![feature(old_impl_check)]\n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n+#![cfg_attr(test, feature(test))]\n \n // test harness access\n #[cfg(test)] extern crate test;"}, {"sha": "9aa38e711e70f3501b1ccd49d5e736a20e46c13e", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,8 @@\n \n //! Operations on ASCII strings and characters\n \n-#![unstable = \"unsure about placement and naming\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"unsure about placement and naming\")]\n \n use iter::IteratorExt;\n use ops::FnMut;\n@@ -22,7 +23,8 @@ use string::String;\n use vec::Vec;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n pub trait OwnedAsciiExt {\n     /// Convert the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n@@ -36,7 +38,8 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n pub trait AsciiExt<T = Self> {\n     /// Check if within the ASCII range.\n     fn is_ascii(&self) -> bool;\n@@ -57,7 +60,8 @@ pub trait AsciiExt<T = Self> {\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt<String> for str {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -82,7 +86,8 @@ impl AsciiExt<String> for str {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_uppercase(self) -> String {\n@@ -97,7 +102,8 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -123,7 +129,8 @@ impl AsciiExt<Vec<u8>> for [u8] {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {\n@@ -142,7 +149,8 @@ impl OwnedAsciiExt for Vec<u8> {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt for u8 {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -165,7 +173,8 @@ impl AsciiExt for u8 {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt for char {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -207,7 +216,8 @@ impl AsciiExt for char {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex escapes.\n /// - Unicode escapes are never generated by this function.\n-#[unstable = \"needs to be updated to use an iterator\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"needs to be updated to use an iterator\")]\n pub fn escape_default<F>(c: u8, mut f: F) where\n     F: FnMut(u8),\n {"}, {"sha": "0d8b233a1697d72f264a09526e50c18f62384888", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -11,5 +11,5 @@\n //! The boolean type\n \n #![doc(primitive = \"bool\")]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "ae295c3e8e44239db67514754b788bf96e2a2790", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 71, "deletions": 58, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -296,7 +296,7 @@ fn test_resize_policy() {\n /// }\n /// ```\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashMap<K, V, S = RandomState> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n     hash_state: S,\n@@ -499,7 +499,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n@@ -513,7 +513,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomState> {\n         HashMap::with_capacity_and_hash_state(capacity, Default::default())\n     }\n@@ -539,7 +539,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n         HashMap {\n             hash_state:    hash_state,\n@@ -567,7 +567,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n                                         -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n@@ -591,7 +591,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(map.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.resize_policy.usable_capacity(self.table.capacity())\n     }\n@@ -611,7 +611,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let min_cap = self.resize_policy.min_capacity(new_size);\n@@ -723,7 +723,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.shrink_to_fit();\n     /// assert!(map.capacity() >= 2);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         let min_capacity = self.resize_policy.min_capacity(self.len());\n         let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n@@ -817,7 +817,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n@@ -842,7 +842,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"{}\", val);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n@@ -867,7 +867,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter { inner: self.table.iter() }\n     }\n@@ -895,7 +895,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         IterMut { inner: self.table.iter_mut() }\n     }\n@@ -917,7 +917,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n@@ -928,7 +928,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    #[unstable = \"precise API still being fleshed out\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"precise API still being fleshed out\")]\n     pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>\n     {\n         // Gotta resize now.\n@@ -950,7 +951,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.table.size() }\n \n     /// Returns true if the map contains no elements.\n@@ -966,7 +967,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n@@ -989,7 +990,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(a.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two; // coerce to fn pointer\n@@ -1012,7 +1014,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -1034,7 +1036,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1057,7 +1059,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1083,7 +1085,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1106,7 +1108,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         self.reserve(1);\n@@ -1135,7 +1137,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1208,14 +1210,14 @@ impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Eq for HashMap<K, V, S>\n     where K: Eq + Hash<H>, V: Eq,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Debug for HashMap<K, V, S>\n     where K: Eq + Hash<H> + Debug, V: Debug,\n           S: HashState<Hasher=H>,\n@@ -1233,7 +1235,7 @@ impl<K, V, S, H> Debug for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Default for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -1244,7 +1246,7 @@ impl<K, V, S, H> Default for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           Q: Eq + Hash<H> + BorrowFrom<K>,\n@@ -1259,7 +1261,7 @@ impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           Q: Eq + Hash<H> + BorrowFrom<K>,\n@@ -1275,7 +1277,7 @@ impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n }\n \n /// HashMap iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: table::Iter<'a, K, V>\n }\n@@ -1290,13 +1292,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n }\n \n /// HashMap mutable values iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: table::IterMut<'a, K, V>\n }\n \n /// HashMap move iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1307,7 +1309,7 @@ pub struct IntoIter<K, V> {\n }\n \n /// HashMap keys iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n@@ -1322,7 +1324,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n }\n \n /// HashMap values iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -1337,7 +1339,8 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n }\n \n /// HashMap drain iterator.\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1348,21 +1351,24 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single occupied location in a HashMap.\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single empty location in a HashMap.\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single location in a map, which may be vacant or occupied.\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry.\n     Occupied(OccupiedEntry<'a, K, V>),\n@@ -1379,79 +1385,80 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n \n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> Entry<'a, K, V> {\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant.\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n@@ -1462,7 +1469,8 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry.\n     pub fn get(&self) -> &V {\n@@ -1493,7 +1501,8 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n@@ -1509,7 +1518,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -1524,7 +1533,7 @@ impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -1545,13 +1554,15 @@ impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n /// instances are unlikely to produce the same result for the same values.\n #[derive(Clone)]\n #[allow(missing_copy_implementations)]\n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n pub struct RandomState {\n     k0: u64,\n     k1: u64,\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl RandomState {\n     /// Construct a new `RandomState` that is initialized with random keys.\n     #[inline]\n@@ -1561,15 +1572,17 @@ impl RandomState {\n     }\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl HashState for RandomState {\n     type Hasher = Hasher;\n     fn hasher(&self) -> Hasher {\n         Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n     }\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl Default for RandomState {\n     #[inline]\n     fn default() -> RandomState {"}, {"sha": "84f01f70c3e885b722b5af6252e058b172dc7d1b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -90,7 +90,7 @@ use super::state::HashState;\n /// }\n /// ```\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n     map: HashMap<T, (), S>\n }\n@@ -105,7 +105,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashSet<T, RandomState> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n@@ -120,7 +120,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomState> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n@@ -147,7 +147,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n         HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n     }\n@@ -171,7 +171,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(1i);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n                                         -> HashSet<T, S> {\n         HashSet {\n@@ -189,7 +189,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert!(set.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.map.capacity()\n     }\n@@ -209,7 +209,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// set.reserve(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.map.reserve(additional)\n     }\n@@ -230,7 +230,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.shrink_to_fit();\n     /// assert!(set.capacity() >= 2);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.map.shrink_to_fit()\n     }\n@@ -251,7 +251,7 @@ impl<T, S, H> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n@@ -276,7 +276,7 @@ impl<T, S, H> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first;\n@@ -306,7 +306,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n         Difference {\n             iter: self.iter(),\n@@ -334,7 +334,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n         -> SymmetricDifference<'a, T, S> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n@@ -357,7 +357,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n         Intersection {\n             iter: self.iter(),\n@@ -382,7 +382,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n         Union { iter: self.iter().chain(other.difference(self)) }\n     }\n@@ -399,7 +399,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.insert(1u);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -414,12 +414,13 @@ impl<T, S, H> HashSet<T, S>\n     /// v.insert(1u);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n@@ -439,7 +440,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -457,7 +458,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n@@ -481,7 +482,7 @@ impl<T, S, H> HashSet<T, S>\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n@@ -502,7 +503,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n@@ -527,7 +528,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n         other.is_subset(self)\n     }\n@@ -546,7 +547,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -567,15 +568,15 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> PartialEq for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -588,14 +589,14 @@ impl<T, S, H> PartialEq for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Eq for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {}\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> fmt::Debug for HashSet<T, S>\n     where T: Eq + Hash<H> + fmt::Debug,\n           S: HashState<Hasher=H>,\n@@ -613,7 +614,7 @@ impl<T, S, H> fmt::Debug for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> FromIterator<T> for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -627,7 +628,7 @@ impl<T, S, H> FromIterator<T> for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Extend<T> for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -640,19 +641,19 @@ impl<T, S, H> Extend<T> for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Default for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n           H: hash::Hasher<Output=u64>\n {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> HashSet<T, S> {\n         HashSet::with_hash_state(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -685,7 +686,7 @@ impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -718,7 +719,7 @@ impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -751,7 +752,7 @@ impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -785,25 +786,25 @@ impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n /// HashSet iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n     iter: Keys<'a, K, ()>\n }\n \n /// HashSet move iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n     iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n     iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n }\n \n /// Intersection iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -812,7 +813,7 @@ pub struct Intersection<'a, T: 'a, S: 'a> {\n }\n \n /// Difference iterator\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -821,54 +822,54 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n }\n \n /// Symmetric difference iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n     iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n }\n \n /// Set union iterator.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> Iterator for IntoIter<K> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Drain<'a, K> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -893,7 +894,7 @@ impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -918,7 +919,7 @@ impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -930,7 +931,7 @@ impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Union<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,"}, {"sha": "9e6a45d8bf0b5877fa3ae8159d83d61e8b120cb8", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -629,7 +629,6 @@ impl<K, V> RawTable<K, V> {\n \n     /// Creates a new raw table from a given capacity. All buckets are\n     /// initially empty.\n-    #[allow(unstable)]\n     pub fn new(capacity: uint) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);"}, {"sha": "0c55850b32a2dd5d689bd21914e173fb36728059", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -359,7 +359,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core_collections::Bound;\n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n@@ -373,21 +373,21 @@ pub use self::hash_set::HashSet;\n \n mod hash;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod hash_map {\n     //! A hashmap\n     pub use super::hash::map::*;\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;\n }\n \n /// Experimental support for providing custom hash algorithms to a HashMap and\n /// HashSet.\n-#[unstable = \"module was recently added\"]\n+#[unstable(feature = \"std_misc\", reason = \"module was recently added\")]\n pub mod hash_state {\n     pub use super::hash::state::*;\n }"}, {"sha": "f35f63143ef8275cdeab063398d4da89c16e0adf", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,7 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n #![allow(missing_docs)]\n \n use prelude::v1::*;"}, {"sha": "c184d3f4661f16e519ae356771f5d7b824e14b4a", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n use prelude::v1::*;\n "}, {"sha": "fdd7aa216d3c0edc9c84711a0de71353856ee5ca", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -119,7 +119,7 @@ impl Deref for CString {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for CString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         String::from_utf8_lossy(self.as_bytes()).fmt(f)"}, {"sha": "69ada28a4b4a456ba05b452591d163d1e7c53fa4", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,8 +10,9 @@\n \n //! Utilities related to FFI bindings.\n \n-#![unstable = \"module just underwent fairly large reorganization and the dust \\\n-               still needs to settle\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"module just underwent fairly large reorganization and the dust \\\n+                      still needs to settle\")]\n \n pub use self::c_str::CString;\n pub use self::c_str::c_str_to_bytes;"}, {"sha": "8fdc5547e46b106994600555fab427c74b8f8eaa", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -29,7 +29,8 @@\n //! for conversion to/from various other string types. Eventually these types\n //! will offer a full-fledged string API.\n \n-#![unstable = \"recently added as part of path/io reform\"]\n+#![unstable(feature = \"os\",\n+            reason = \"recently added as part of path/io reform\")]\n \n use core::prelude::*;\n "}, {"sha": "4ab43e875cdffad9d8033bbf50e7c95e43b4f719", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -401,7 +401,7 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n use string;\n \n@@ -431,8 +431,9 @@ pub use core::fmt::{argument, argumentuint};\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n-#[unstable = \"this is an implementation detail of format! and should not \\\n-                  be called directly\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"this is an implementation detail of format! and should not \\\n+                     be called directly\")]\n pub fn format(args: Arguments) -> string::String {\n     let mut output = string::String::new();\n     let _ = write!(&mut output, \"{}\", args);"}, {"sha": "3a745389e1e719f83d8d7159c864efe4275b5c1e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -96,7 +96,8 @@\n //! and `format!`, also available to all Rust code.\n \n #![crate_name = \"std\"]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -114,7 +115,14 @@\n #![feature(optin_builtin_traits)]\n #![feature(int_uint)]\n #![feature(int_uint)]\n-#![allow(unstable)]\n+#![feature(core)]\n+#![feature(libc)]\n+#![feature(alloc)]\n+#![feature(unicode)]\n+#![feature(collections)]\n+#![feature(rand)]\n+#![feature(hash)]\n+#![cfg_attr(test, feature(test))]\n \n // Don't link to std. We are std.\n #![no_std]\n@@ -177,7 +185,7 @@ pub use alloc::rc;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core_collections::vec;\n \n pub use unicode::char;"}, {"sha": "9c3285a9d0890b701300603b0599a45100b8035c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n /// The entry point for panic of Rust tasks.\n ///\n@@ -36,7 +36,7 @@\n /// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! panic {\n     () => ({\n         panic!(\"explicit panic\")\n@@ -71,15 +71,15 @@ macro_rules! panic {\n /// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n     ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n }\n \n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! print {\n     ($($arg:tt)*) => ($crate::old_io::stdio::print_args(format_args!($($arg)*)))\n }\n@@ -97,7 +97,7 @@ macro_rules! print {\n /// println!(\"format {} arguments\", \"some\");\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! println {\n     ($($arg:tt)*) => ($crate::old_io::stdio::println_args(format_args!($($arg)*)))\n }\n@@ -106,7 +106,7 @@ macro_rules! println {\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! try {\n     ($expr:expr) => (match $expr {\n         $crate::result::Result::Ok(val) => val,\n@@ -148,7 +148,7 @@ macro_rules! try {\n ///\n /// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n-#[unstable]\n+#[unstable(feature = \"std_misc\")]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+"}, {"sha": "9b5b0e62a3c1a7a141e4f965b867371ce36da187", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for 32-bits floats (`f32` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n #![allow(unsigned_negation)]\n #![doc(primitive = \"f32\")]\n@@ -73,7 +73,7 @@ mod cmath {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { num::Float::nan() }\n@@ -366,7 +366,7 @@ impl Float for f32 {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -379,7 +379,7 @@ pub fn to_string(num: f32) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -394,7 +394,7 @@ pub fn to_str_hex(num: f32) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -407,7 +407,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -422,7 +422,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -438,7 +438,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -454,7 +454,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "1c9558325292b207fb98bda6639c113dcb99b52f", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for 64-bits floats (`f64` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n #![doc(primitive = \"f64\")]\n \n@@ -81,7 +81,7 @@ mod cmath {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Float for f64 {\n     // inlined methods from `num::Float`\n     #[inline]\n@@ -375,7 +375,7 @@ impl Float for f64 {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -388,7 +388,7 @@ pub fn to_string(num: f64) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -403,7 +403,7 @@ pub fn to_str_hex(num: f64) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -416,7 +416,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -431,7 +431,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -447,7 +447,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -463,7 +463,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "2b730cd6f9ad81e8755db53e25b420bbef9b1643", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "498f19b9b8307f3d45a68c90ff3d4a5d216276b2", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "aea1e92117bb0f315e0f414b1ccf000584135543", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "43794345fe7a4ebcd9b2b88ed2263ae2efa3f2b3", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "1b03bf6f4f0097c7b8cb9e20c9ee1a1b74051355", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "669952eee3924a8bb81e94cd953a16ca965cdc77", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,8 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by isize\"]\n+#![unstable(feature = \"std_misc\")]\n+#![deprecated(since = \"1.0.0\", reason = \"replaced by isize\")]\n \n pub use core::int::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "af1976d5750932db4eb3d5187a2db2f778dfecc7", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty) => ("}, {"sha": "7fb2cd81ababf2dbfc44f0722f3f31e781446df2", "filename": "src/libstd/num/isize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fisize.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n \n pub use core::isize::{BITS, BYTES, MIN, MAX};"}, {"sha": "dad8b70ceacdf7fce72daca57d971dc72fea7b73", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 103, "deletions": 72, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -13,7 +13,7 @@\n //! These are implemented for the primitive numeric types in `std::{u8, u16,\n //! u32, u64, uint, i8, i16, i32, i64, int, f32, f64}`.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n #[cfg(test)] use fmt::Debug;\n@@ -33,11 +33,11 @@ pub use core::num::{FpCategory};\n \n use option::Option;\n \n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub mod strconv;\n \n /// Mathematical operations on primitive floating point numbers.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Float\n     : Copy + Clone\n     + NumCast\n@@ -52,267 +52,298 @@ pub trait Float\n {\n     // inlined methods from `num::Float`\n     /// Returns the NaN value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn nan() -> Self;\n     /// Returns the infinite value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn neg_infinity() -> Self;\n     /// Returns the `0` value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn zero() -> Self;\n     /// Returns -0.0.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn neg_zero() -> Self;\n     /// Returns the `1` value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn one() -> Self;\n \n     // FIXME (#5527): These should be associated constants\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n-    #[deprecated = \"use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS` as appropriate\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n+                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n     /// Returns the number of base-10 digits of precision that this type supports.\n-    #[deprecated = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     fn digits(unused_self: Option<Self>) -> uint;\n     /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    #[deprecated = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n     fn epsilon() -> Self;\n     /// Returns the minimum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     fn min_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     fn max_exp(unused_self: Option<Self>) -> int;\n     /// Returns the minimum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n \n     /// Returns the smallest finite value that this type can represent.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn max_value() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n-    #[unstable = \"position is undecided\"]\n+    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_nan(self) -> bool;\n     /// Returns true if this value is positive infinity or negative infinity and\n     /// false otherwise.\n-    #[unstable = \"position is undecided\"]\n+    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_infinite(self) -> bool;\n     /// Returns true if this number is neither infinite nor NaN.\n-    #[unstable = \"position is undecided\"]\n+    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_finite(self) -> bool;\n     /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n-    #[unstable = \"position is undecided\"]\n+    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_normal(self) -> bool;\n     /// Returns the category that this number falls into.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn classify(self) -> FpCategory;\n \n     /// Returns the mantissa, exponent and sign as integers, respectively.\n-    #[unstable = \"signature is undecided\"]\n+    #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n     fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Return the largest integer less than or equal to a number.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn floor(self) -> Self;\n     /// Return the smallest integer greater than or equal to a number.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ceil(self) -> Self;\n     /// Return the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn round(self) -> Self;\n     /// Return the integer part of a number.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trunc(self) -> Self;\n     /// Return the fractional part of a number.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fract(self) -> Self;\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn abs(self) -> Self;\n     /// Returns a number that represents the sign of `self`.\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n     /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n     /// - `Float::nan()` if the number is `Float::nan()`\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn signum(self) -> Self;\n     /// Returns `true` if `self` is positive, including `+0.0` and\n     /// `Float::infinity()`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_positive(self) -> bool;\n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_negative(self) -> bool;\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn mul_add(self, a: Self, b: Self) -> Self;\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn recip(self) -> Self;\n \n     /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn powi(self, n: i32) -> Self;\n     /// Raise a number to a floating point power.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn powf(self, n: Self) -> Self;\n \n     /// Take the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sqrt(self) -> Self;\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn rsqrt(self) -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn exp(self) -> Self;\n     /// Returns 2 raised to the power of the number, `2^(self)`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn exp2(self) -> Self;\n     /// Returns the natural logarithm of the number.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ln(self) -> Self;\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log(self, base: Self) -> Self;\n     /// Returns the base 2 logarithm of the number.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log2(self) -> Self;\n     /// Returns the base 10 logarithm of the number.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log10(self) -> Self;\n \n     /// Convert radians to degrees.\n-    #[unstable = \"desirability is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     fn to_degrees(self) -> Self;\n     /// Convert degrees to radians.\n-    #[unstable = \"desirability is unclear\"]\n+    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     fn to_radians(self) -> Self;\n \n     /// Constructs a floating point number created by multiplying `x` by 2\n     /// raised to the power of `exp`.\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"pending integer conventions\")]\n     fn ldexp(x: Self, exp: int) -> Self;\n     /// Breaks the number into a normalized fraction and a base-2 exponent,\n     /// satisfying:\n     ///\n     ///  * `self = x * pow(2, exp)`\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"pending integer conventions\")]\n     fn frexp(self) -> (Self, int);\n \n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn next_after(self, other: Self) -> Self;\n \n     /// Returns the maximum of the two numbers.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self, other: Self) -> Self;\n     /// Returns the minimum of the two numbers.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self, other: Self) -> Self;\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is\n     /// less than or equal to `other`, otherwise the difference between`self`\n     /// and `other` is returned.\n-    #[unstable = \"may be renamed\"]\n+    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn abs_sub(self, other: Self) -> Self;\n \n     /// Take the cubic root of a number.\n-    #[unstable = \"may be renamed\"]\n+    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure about its place in the world\")]\n     fn hypot(self, other: Self) -> Self;\n \n     /// Computes the sine of a number (in radians).\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cos(self) -> Self;\n     /// Computes the tangent of a number (in radians).\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn tan(self) -> Self;\n \n     /// Computes the arcsine of a number. Return value is in radians in\n     /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n     /// [-1, 1].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn asin(self) -> Self;\n     /// Computes the arccosine of a number. Return value is in radians in\n     /// the range [0, pi] or NaN if the number is outside the range\n     /// [-1, 1].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn acos(self) -> Self;\n     /// Computes the arctangent of a number. Return value is in radians in the\n     /// range [-pi/2, pi/2];\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atan(self) -> Self;\n     /// Computes the four quadrant arctangent of a number, `y`, and another\n     /// number `x`. Return value is in radians in the range [-pi, pi].\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atan2(self, other: Self) -> Self;\n     /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n     /// `(sin(x), cos(x))`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sin_cos(self) -> (Self, Self);\n \n     /// Returns the exponential of the number, minus 1, in a way that is\n     /// accurate even if the number is close to zero.\n-    #[unstable = \"may be renamed\"]\n+    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn exp_m1(self) -> Self;\n     /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately.\n-    #[unstable = \"may be renamed\"]\n+    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn ln_1p(self) -> Self;\n \n     /// Hyperbolic sine function.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sinh(self) -> Self;\n     /// Hyperbolic cosine function.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cosh(self) -> Self;\n     /// Hyperbolic tangent function.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn tanh(self) -> Self;\n     /// Inverse hyperbolic sine function.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn asinh(self) -> Self;\n     /// Inverse hyperbolic cosine function.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atanh(self) -> Self;\n }\n "}, {"sha": "3fda77fb69c402ecd739b28811687f1517006bbc", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "8610f0c01473f8887d0938ed68d39243991b310b", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "3587b06965624930b38cf0976a19b3e5e2c481e0", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "6a285e8299c1eccbb437558866da2881c2a5b7b2", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "c7b491381f337abca0b65054bfdaa8b620469cd9", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,8 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by usize\"]\n+#![unstable(feature = \"std_misc\")]\n+#![deprecated(since = \"1.0.0\", reason = \"replaced by usize\")]\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "82c55d7b5b83c43df529cdea4fa88a9fe078fc81", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n "}, {"sha": "19964c306a79bbcc08bdf8047ae23e96be9e8a89", "filename": "src/libstd/num/usize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fusize.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n \n pub use core::usize::{BITS, BYTES, MIN, MAX};"}, {"sha": "1590598c0b8a76a5d7993c4bc1168cf896c078a1", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -52,7 +52,7 @@ pub struct BufferedReader<R> {\n     cap: uint,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R> fmt::Debug for BufferedReader<R> where R: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"BufferedReader {{ reader: {:?}, buffer: {}/{} }}\",\n@@ -151,7 +151,7 @@ pub struct BufferedWriter<W> {\n     pos: uint\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"BufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n@@ -251,7 +251,7 @@ pub struct LineBufferedWriter<W> {\n     inner: BufferedWriter<W>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"LineBufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n@@ -342,7 +342,7 @@ pub struct BufferedStream<S> {\n     inner: BufferedReader<InternalBufferedWriter<S>>\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;"}, {"sha": "feb2ef6f4f3ca1d94bba0ad555e7d47b27032f93", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -134,7 +134,7 @@ impl ChanWriter {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for ChanWriter {\n     fn clone(&self) -> ChanWriter {\n         ChanWriter { tx: self.tx.clone() }"}, {"sha": "254daf3202a9e2cb1ff3b10157574192a65d41fc", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -62,7 +62,9 @@ impl Writer for Vec<u8> {\n ///\n /// assert_eq!(w.into_inner(), vec!(0, 1, 2));\n /// ```\n-#[deprecated = \"use the Vec<u8> Writer implementation directly\"]\n+#[unstable(feature = \"io\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use the Vec<u8> Writer implementation directly\")]\n #[derive(Clone)]\n pub struct MemWriter {\n     buf: Vec<u8>,"}, {"sha": "6c5ce129a33cf9fab28e193c78429a39da236646", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -237,7 +237,7 @@\n //! concerned with error handling; instead its caller is responsible for\n //! responding to errors that may occur while attempting to read the numbers.\n \n-#![unstable]\n+#![unstable(feature = \"io\")]\n #![deny(unused_must_use)]\n \n pub use self::SeekStyle::*;\n@@ -357,7 +357,7 @@ impl IoError {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -1000,7 +1000,8 @@ pub trait Writer {\n     fn write_all(&mut self, buf: &[u8]) -> IoResult<()>;\n \n     /// Deprecated, this method was renamed to `write_all`\n-    #[deprecated = \"renamed to `write_all`\"]\n+    #[unstable(feature = \"io\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `write_all`\")]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write_all(buf) }\n \n     /// Flush this output stream, ensuring that all intermediately buffered\n@@ -1711,7 +1712,6 @@ pub enum FileType {\n /// # Examples\n ///\n /// ```no_run\n-/// # #![allow(unstable)]\n ///\n /// use std::old_io::fs::PathExtensions;\n ///\n@@ -1752,15 +1752,15 @@ pub struct FileStat {\n     ///\n     /// Usage of this field is discouraged, but if access is desired then the\n     /// fields are located here.\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub unstable: UnstableFileStat,\n }\n \n /// This structure represents all of the possible information which can be\n /// returned from a `stat` syscall which is not contained in the `FileStat`\n /// structure. This information is not necessarily platform independent, and may\n /// have different meanings or no meaning at all on some platforms.\n-#[unstable]\n+#[unstable(feature = \"io\")]\n #[derive(Copy, Hash)]\n pub struct UnstableFileStat {\n     /// The ID of the device containing the file.\n@@ -1824,14 +1824,14 @@ bitflags! {\n }\n \n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for FilePermission {\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn default() -> FilePermission { FilePermission::empty() }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for FilePermission {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:04o}\", self.bits)"}, {"sha": "e60b455aecda6cce7b763942bfc10342aa5e08d1", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -38,7 +38,7 @@ pub enum IpAddr {\n     Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for IpAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -70,7 +70,7 @@ pub struct SocketAddr {\n     pub port: Port,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for SocketAddr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.ip {"}, {"sha": "71b77adcd964de8b7ce2af065dcb68dd8c2ece2b", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -68,7 +68,8 @@ impl UnixStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable = \"the timeout argument is likely to change types\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument is likely to change types\")]\n     pub fn connect_timeout<P>(path: P, timeout: Duration)\n                               -> IoResult<UnixStream>\n                               where P: BytesContainer {\n@@ -107,23 +108,26 @@ impl UnixStream {\n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }\n@@ -217,8 +221,9 @@ impl UnixAcceptor {\n     /// When using this method, it is likely necessary to reset the timeout as\n     /// appropriate, the timeout specified is specific to this object, not\n     /// specific to the next request.\n-    #[unstable = \"the name and arguments to this function are likely \\\n-                      to change\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the name and arguments to this function are likely \\\n+                         to change\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n@@ -227,7 +232,7 @@ impl UnixAcceptor {\n     ///\n     /// This function has the same semantics as `TcpAcceptor::close_accept`, and\n     /// more information can be found in that documentation.\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.close_accept()\n     }"}, {"sha": "1e76bb3ab0dffa4f60a7a441bb924b6d8afae5a0", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -85,7 +85,8 @@ impl TcpStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable = \"the timeout argument may eventually change types\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may eventually change types\")]\n     pub fn connect_timeout<A: ToSocketAddr>(addr: A,\n                                             timeout: Duration) -> IoResult<TcpStream> {\n         if timeout <= Duration::milliseconds(0) {\n@@ -109,7 +110,7 @@ impl TcpStream {\n     }\n \n     /// Sets the nodelay flag on this connection to the boolean specified\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n         self.inner.set_nodelay(nodelay)\n     }\n@@ -119,7 +120,7 @@ impl TcpStream {\n     /// If the value specified is `None`, then the keepalive flag is cleared on\n     /// this connection. Otherwise, the keepalive timeout will be set to the\n     /// specified time, in seconds.\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n         self.inner.set_keepalive(delay_in_seconds)\n     }\n@@ -187,7 +188,8 @@ impl TcpStream {\n     ///\n     /// For clarification on the semantics of interrupting a read and a write,\n     /// take a look at `set_read_timeout` and `set_write_timeout`.\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n@@ -204,7 +206,8 @@ impl TcpStream {\n     /// action is taken. Otherwise, the read operation will be scheduled to\n     /// promptly return. If a timeout error is returned, then no data was read\n     /// during the timeout period.\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n@@ -231,7 +234,8 @@ impl TcpStream {\n     /// does not know how many bytes were written as part of the timeout\n     /// operation. It may be the case that bytes continue to be written in an\n     /// asynchronous fashion after the call to write returns.\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }\n@@ -372,7 +376,6 @@ impl TcpAcceptor {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// # #![allow(unstable)]\n     /// use std::old_io::TcpListener;\n     /// use std::old_io::{Listener, Acceptor, TimedOut};\n     ///\n@@ -395,8 +398,9 @@ impl TcpAcceptor {\n     /// a.set_timeout(None);\n     /// let socket = a.accept();\n     /// ```\n-    #[unstable = \"the type of the argument and name of this function are \\\n-                      subject to change\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the type of the argument and name of this function are \\\n+                         subject to change\")]\n     pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }\n \n     /// Closes the accepting capabilities of this acceptor.\n@@ -416,7 +420,6 @@ impl TcpAcceptor {\n     /// # Example\n     ///\n     /// ```\n-    /// # #![allow(unstable)]\n     /// use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile};\n     /// use std::thread::Thread;\n     ///\n@@ -442,7 +445,7 @@ impl TcpAcceptor {\n     /// // Signal our accept loop to exit\n     /// assert!(a.close_accept().is_ok());\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.close_accept()\n     }\n@@ -480,7 +483,6 @@ impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor {\n }\n \n #[cfg(test)]\n-#[allow(unstable)]\n mod test {\n     use prelude::v1::*;\n "}, {"sha": "9055a089eec7f3fde3e672338172dfcfd7b17db4", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -92,63 +92,66 @@ impl UdpSocket {\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         self.inner.join_multicast(multi)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         self.inner.leave_multicast(multi)\n     }\n \n     /// Set the multicast loop flag to the specified value\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n         self.inner.set_multicast_loop(on)\n     }\n \n     /// Sets the multicast TTL\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n         self.inner.multicast_time_to_live(ttl)\n     }\n \n     /// Sets this socket's TTL\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n         self.inner.time_to_live(ttl)\n     }\n \n     /// Sets the broadcast flag on or off\n-    #[unstable]\n+    #[unstable(feature = \"io\")]\n     pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n         self.inner.set_broadcast(broadcast)\n     }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }\n@@ -176,7 +179,6 @@ impl sys_common::AsInner<UdpSocketImp> for UdpSocket {\n }\n \n #[cfg(test)]\n-#[allow(unstable)]\n mod test {\n     use prelude::v1::*;\n "}, {"sha": "78910882467290789c5c3bb7b6702ad0032f60bc", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,6 @@\n \n //! Bindings for executing child processes\n \n-#![allow(unstable)]\n #![allow(non_upper_case_globals)]\n \n pub use self::StdioContainer::*;\n@@ -502,7 +501,7 @@ pub enum ProcessExit {\n     ExitSignal(int),\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -653,7 +652,6 @@ impl Process {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// # #![allow(unstable)]\n     /// use std::old_io::{Command, IoResult};\n     /// use std::old_io::process::ProcessExit;\n     ///\n@@ -681,7 +679,8 @@ impl Process {\n     ///     p.wait()\n     /// }\n     /// ```\n-    #[unstable = \"the type of the timeout is likely to change\"]\n+    #[unstable(feature = \"io\",\n+               reason = \"the type of the timeout is likely to change\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.deadline = timeout_ms.map(|i| i + sys::timer::now()).unwrap_or(0);\n     }"}, {"sha": "cd37a355e1db4722b427a1cec832c1927cab8cf5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -24,7 +24,7 @@\n //! which OS the user is on -- they should be given the opportunity to write\n //! OS-ignorant code by default.\n \n-#![unstable]\n+#![unstable(feature = \"os\")]\n \n #![allow(missing_docs)]\n #![allow(non_snake_case)]\n@@ -902,7 +902,7 @@ pub enum MapError {\n     ErrMapViewOfFile(uint)\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for MapError {\n     fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result {\n         let str = match *self {"}, {"sha": "b42353e964c511993cd2d89612ca502632ca6a61", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -59,7 +59,7 @@\n //! println!(\"path exists: {}\", path.exists());\n //! ```\n \n-#![unstable]\n+#![unstable(feature = \"path\")]\n \n use core::marker::Sized;\n use ffi::CString;\n@@ -823,14 +823,14 @@ pub struct Display<'a, P:'a> {\n     filename: bool\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, P: GenericPath> fmt::Debug for Display<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&self.as_cow(), f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, P: GenericPath> fmt::Display for Display<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_cow().fmt(f)"}, {"sha": "39138e148032b96f5527e78fcb81a73ea8b63a9b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -57,7 +57,7 @@ pub fn is_sep(c: char) -> bool {\n     c == SEP\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&self.display(), f)"}, {"sha": "34faa65af75a199851c3f1f2a5b2b5672fa4dc3c", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -85,7 +85,7 @@ pub struct Path {\n     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&self.display(), f)"}, {"sha": "09fa10dacf98c2807a7186165d6692415dbc2074", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -35,7 +35,6 @@\n //! pervasive that it would be obnoxious to import for every use, particularly\n //! those that define methods on primitive types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[stable]\n pub mod v1;"}, {"sha": "51c9f9de83cc88e7fc210550665c7629186c7342", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,35 +10,54 @@\n \n //! The first version of the prelude of the standard library.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Reexported core operators\n-#[stable] #[doc(no_inline)] pub use marker::{Copy, Send, Sized, Sync};\n-#[stable] #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use marker::{Copy, Send, Sized, Sync};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // TEMPORARY\n-#[unstable] #[doc(no_inline)] pub use ops::FullRange;\n+#[unstable(feature = \"std_misc\")]\n+#[doc(no_inline)] pub use ops::FullRange;\n \n // Reexported functions\n-#[stable] #[doc(no_inline)] pub use mem::drop;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use mem::drop;\n \n // Reexported types and traits\n \n-#[stable] #[doc(no_inline)] pub use boxed::Box;\n-#[stable] #[doc(no_inline)] pub use char::CharExt;\n-#[stable] #[doc(no_inline)] pub use clone::Clone;\n-#[stable] #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n-#[stable] #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n-#[stable] #[doc(no_inline)] pub use iter::ExactSizeIterator;\n-#[stable] #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n-#[stable] #[doc(no_inline)] pub use option::Option::{self, Some, None};\n-#[stable] #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n-#[stable] #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n-#[stable] #[doc(no_inline)] pub use slice::AsSlice;\n-#[stable] #[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt};\n-#[stable] #[doc(no_inline)] pub use str::{Str, StrExt};\n-#[stable] #[doc(no_inline)] pub use string::{String, ToString};\n-#[stable] #[doc(no_inline)] pub use vec::Vec;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use boxed::Box;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use char::CharExt;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use clone::Clone;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use iter::DoubleEndedIterator;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use iter::ExactSizeIterator;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use option::Option::{self, Some, None};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use slice::AsSlice;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use str::{Str, StrExt};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use string::{String, ToString};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use vec::Vec;\n \n // NB: remove when path reform lands\n #[doc(no_inline)] pub use path::{Path, GenericPath};"}, {"sha": "8f5d0e22c888632085af47a3ccb1cc8b95b687c7", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -219,7 +219,7 @@\n //! }\n //! ```\n \n-#![unstable]\n+#![unstable(feature = \"rand\")]\n \n use cell::RefCell;\n use clone::Clone;"}, {"sha": "7e19f1cac2c5bf5a0c74c7d25e3f0823061ba086", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -16,7 +16,7 @@\n //! and should be considered as private implementation details for the\n //! time being.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n // FIXME: this should not be here.\n #![allow(missing_docs)]"}, {"sha": "18298f1c7f4f5ac3c5dd8e0d1d6e6ffceddd34dd", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -582,7 +582,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n /// Only a limited number of callbacks can be registered, and this function\n /// returns whether the callback was successfully registered or not. It is not\n /// currently possible to unregister a callback once it has been registered.\n-#[unstable]\n+#[unstable(feature = \"std_misc\")]\n pub unsafe fn register(f: Callback) -> bool {\n     match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n         // The invocation code has knowledge of this window where the count has"}, {"sha": "06b6816248709abc66379bda43b11f596e103767", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -12,7 +12,7 @@\n //! the standard library This varies per-platform, but these libraries are\n //! necessary for running libstd.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n // All platforms need to link to rustrt\n #[cfg(not(test))]"}, {"sha": "40710d627c0ec3df6f4562d7d1b29a1f591f5a17", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -29,7 +29,7 @@ use sync::{Mutex, Condvar};\n ///     });\n /// }\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n@@ -54,7 +54,7 @@ impl Barrier {\n     ///\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(n: uint) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n@@ -75,7 +75,7 @@ impl Barrier {\n     /// returns `true` from `is_leader` when returning from this function, and\n     /// all other threads will receive a result that will return `false` from\n     /// `is_leader`\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn wait(&self) -> BarrierWaitResult {\n         let mut lock = self.lock.lock().unwrap();\n         let local_gen = lock.generation_id;\n@@ -102,7 +102,7 @@ impl BarrierWaitResult {\n     ///\n     /// Only one thread will have `true` returned from their result, all other\n     /// threads will have `false` returned.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_leader(&self) -> bool { self.0 }\n }\n "}, {"sha": "a7a5b084582caafa6df03953be83e079dbdf0051", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -58,7 +58,7 @@ use sync::{mutex, MutexGuard};\n ///     started = cvar.wait(started).unwrap();\n /// }\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Condvar { inner: Box<StaticCondvar> }\n \n unsafe impl Send for Condvar {}\n@@ -76,7 +76,8 @@ unsafe impl Sync for Condvar {}\n ///\n /// static CVAR: StaticCondvar = CONDVAR_INIT;\n /// ```\n-#[unstable = \"may be merged with Condvar in the future\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"may be merged with Condvar in the future\")]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n     mutex: AtomicUsize,\n@@ -86,7 +87,8 @@ unsafe impl Send for StaticCondvar {}\n unsafe impl Sync for StaticCondvar {}\n \n /// Constant initializer for a statically allocated condition variable.\n-#[unstable = \"may be merged with Condvar in the future\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"may be merged with Condvar in the future\")]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n     mutex: ATOMIC_USIZE_INIT,\n@@ -95,7 +97,7 @@ pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Condvar {\n         Condvar {\n             inner: box StaticCondvar {\n@@ -131,7 +133,7 @@ impl Condvar {\n     /// over time. Each condition variable is dynamically bound to exactly one\n     /// mutex to ensure defined behavior across platforms. If this functionality\n     /// is not desired, then unsafe primitives in `sys` are provided.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n         unsafe {\n@@ -154,7 +156,7 @@ impl Condvar {\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n-    #[unstable]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n                            -> LockResult<(MutexGuard<'a, T>, bool)> {\n         unsafe {\n@@ -169,7 +171,7 @@ impl Condvar {\n     /// The semantics of this function are equivalent to `wait_timeout` except\n     /// that the implementation will repeatedly wait while the duration has not\n     /// passed and the provided function returns `false`.\n-    #[unstable]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn wait_timeout_with<'a, T, F>(&self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n@@ -189,7 +191,7 @@ impl Condvar {\n     /// `notify_one` are not buffered in any way.\n     ///\n     /// To wake up all threads, see `notify_all()`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n@@ -199,11 +201,11 @@ impl Condvar {\n     /// way.\n     ///\n     /// To wake up only one thread, see `notify_one()`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Drop for Condvar {\n     fn drop(&mut self) {\n         unsafe { self.inner.inner.destroy() }\n@@ -215,7 +217,8 @@ impl StaticCondvar {\n     /// notification.\n     ///\n     /// See `Condvar::wait`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n         let poisoned = unsafe {\n@@ -235,7 +238,8 @@ impl StaticCondvar {\n     /// specified duration.\n     ///\n     /// See `Condvar::wait_timeout`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n                                -> LockResult<(MutexGuard<'a, T>, bool)> {\n         let (poisoned, success) = unsafe {\n@@ -258,7 +262,8 @@ impl StaticCondvar {\n     /// passed and the function returns `false`.\n     ///\n     /// See `Condvar::wait_timeout_with`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout_with<'a, T, F>(&'static self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n@@ -298,13 +303,15 @@ impl StaticCondvar {\n     /// Wake up one blocked thread on this condvar.\n     ///\n     /// See `Condvar::notify_one`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n     ///\n     /// See `Condvar::notify_all`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n \n     /// Deallocate all resources associated with this static condvar.\n@@ -313,7 +320,8 @@ impl StaticCondvar {\n     /// active users of the condvar, and this also doesn't prevent any future\n     /// users of the condvar. This method is required to be called to not leak\n     /// memory on all platforms.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.inner.destroy()\n     }"}, {"sha": "a79fb684f477036b861258463ed78ce0e5c0a845", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -27,9 +27,10 @@\n //! ```\n \n #![allow(missing_docs)]\n-#![unstable = \"futures as-is have yet to be deeply reevaluated with recent \\\n-               core changes to Rust's synchronization story, and will likely \\\n-               become stable in the future but are unstable until that time\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"futures as-is have yet to be deeply reevaluated with recent \\\n+                      core changes to Rust's synchronization story, and will likely \\\n+                      become stable in the future but are unstable until that time\")]\n \n use core::prelude::*;\n use core::mem::replace;"}, {"sha": "f3b721438d807a2872f2fa706e441ebc2df3a3f2", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -15,7 +15,7 @@\n //! and/or blocking at all, but rather provide the necessary tools to build\n //! other types of concurrent primitives.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;"}, {"sha": "322c6137984abf27762cee60c2bff0bec0cc83da", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -163,7 +163,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // A description of how Rust's channel implementation works\n //\n@@ -338,7 +338,7 @@ mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -350,14 +350,14 @@ unsafe impl<T:Send> Send for Receiver<T> { }\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -368,7 +368,7 @@ unsafe impl<T:Send> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<UnsafeCell<sync::Packet<T>>>,\n }\n@@ -383,50 +383,50 @@ impl<T> !Sync for SyncSender<T> {}\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n #[derive(PartialEq, Eq)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SendError<T>(pub T);\n \n /// An error returned from the `recv` function on a `Receiver`.\n ///\n /// The `recv` operation can only fail if the sending half of a channel is\n /// disconnected, implying that no further messages will ever be received.\n #[derive(PartialEq, Eq, Clone, Copy, Show)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n #[derive(PartialEq, Clone, Copy, Show)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Empty,\n \n     /// This channel's sending half has become disconnected, and there will\n     /// never be any more data received on this channel\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Disconnected,\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n #[derive(PartialEq, Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n     ///\n     /// If this is a buffered channel, then the buffer is full at this time. If\n     /// this is not a buffered channel, then there is no receiver available to\n     /// acquire the data.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Full(T),\n \n     /// This channel's receiving half has disconnected, so the data could not be\n     /// sent. The data is returned back to the callee in this case.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Disconnected(T),\n }\n \n@@ -484,7 +484,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// // Let's see what that answer was\n /// println!(\"{:?}\", rx.recv().unwrap());\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n@@ -524,7 +524,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv().unwrap(), 1i);\n /// assert_eq!(rx.recv().unwrap(), 2i);\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n@@ -568,7 +568,7 @@ impl<T: Send> Sender<T> {\n     /// drop(rx);\n     /// assert_eq!(tx.send(1i).err().unwrap().0, 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n@@ -615,7 +615,7 @@ impl<T: Send> Sender<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n@@ -661,7 +661,7 @@ impl<T: Send> Clone for Sender<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n@@ -696,7 +696,7 @@ impl<T: Send> SyncSender<T> {\n     /// This function will never panic, but it may return `Err` if the\n     /// `Receiver` has disconnected and is no longer able to receive\n     /// information.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         unsafe { (*self.inner.get()).send(t).map_err(SendError) }\n     }\n@@ -710,13 +710,13 @@ impl<T: Send> SyncSender<T> {\n     ///\n     /// See `SyncSender::send` for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         unsafe { (*self.inner.get()).try_send(t) }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n         unsafe { (*self.inner.get()).clone_chan(); }\n@@ -725,7 +725,7 @@ impl<T: Send> Clone for SyncSender<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n         unsafe { (*self.inner.get()).drop_chan(); }\n@@ -749,7 +749,7 @@ impl<T: Send> Receiver<T> {\n     ///\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n     /// block on a receiver.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -810,7 +810,7 @@ impl<T: Send> Receiver<T> {\n     /// If the corresponding `Sender` has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return `Err` to\n     /// indicate that no more messages can ever be received on this channel.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv(&self) -> Result<T, RecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -849,7 +849,7 @@ impl<T: Send> Receiver<T> {\n \n     /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { rx: self }\n     }\n@@ -941,15 +941,15 @@ impl<T: Send> select::Packet for Receiver<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send> Iterator for Iter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n@@ -961,21 +961,21 @@ impl<T: Send> Drop for Receiver<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Debug for SendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"SendError(..)\".fmt(f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for SendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"sending on a closed channel\".fmt(f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Debug for TrySendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -985,7 +985,7 @@ impl<T> fmt::Debug for TrySendError<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for TrySendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -999,14 +999,14 @@ impl<T> fmt::Display for TrySendError<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for RecvError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"receiving on a closed channel\".fmt(f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for TryRecvError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "c222c313ba6864748a50882d5d91a011e458c83e", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -35,7 +35,7 @@\n //! method, and see the method for more information about it. Due to this\n //! caveat, this queue may not be appropriate for all use-cases.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/non-intrusive-mpsc-node-based-queue\n@@ -139,7 +139,7 @@ impl<T: Send> Queue<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "e97c82a5b1b027122a8d36416bea597b9e566e35", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -46,12 +46,13 @@\n //! ```\n \n #![allow(dead_code)]\n-#![unstable = \"This implementation, while likely sufficient, is unsafe and \\\n-                   likely to be error prone. At some point in the future this \\\n-                   module will likely be replaced, and it is currently \\\n-                   unknown how much API breakage that will cause. The ability \\\n-                   to select over a number of channels will remain forever, \\\n-                   but no guarantees beyond this are being made\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"This implementation, while likely sufficient, is unsafe and \\\n+                      likely to be error prone. At some point in the future this \\\n+                      module will likely be replaced, and it is currently \\\n+                      unknown how much API breakage that will cause. The ability \\\n+                      to select over a number of channels will remain forever, \\\n+                      but no guarantees beyond this are being made\")]\n \n \n use core::prelude::*;"}, {"sha": "c1983fcab194de1a614641e3834ca1eed5411608", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -33,7 +33,7 @@\n //! concurrently between two tasks. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n use core::prelude::*;\n "}, {"sha": "f7fdd60eb8cb7e117731f39efc6620f626d9f245", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -109,7 +109,7 @@ use sys_common::mutex as sys;\n ///\n /// *guard += 1;\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Mutex<T> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n@@ -145,7 +145,8 @@ unsafe impl<T:Send> Sync for Mutex<T> { }\n /// }\n /// // lock is unlocked here.\n /// ```\n-#[unstable = \"may be merged with Mutex in the future\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"may be merged with Mutex in the future\")]\n pub struct StaticMutex {\n     lock: sys::Mutex,\n     poison: poison::Flag,\n@@ -159,7 +160,7 @@ unsafe impl Sync for StaticMutex {}\n /// The data protected by the mutex can be access through this guard via its\n /// Deref and DerefMut implementations\n #[must_use]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n@@ -172,15 +173,16 @@ impl<'a, T> !marker::Send for MutexGuard<'a, T> {}\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n-#[unstable = \"may be merged with Mutex in the future\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"may be merged with Mutex in the future\")]\n pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: sys::MUTEX_INIT,\n     poison: poison::FLAG_INIT,\n };\n \n impl<T: Send> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         Mutex {\n             inner: box MUTEX_INIT,\n@@ -199,7 +201,7 @@ impl<T: Send> Mutex<T> {\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return an error once the mutex is acquired.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe { self.inner.lock.lock() }\n         MutexGuard::new(&*self.inner, &self.data)\n@@ -218,7 +220,7 @@ impl<T: Send> Mutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         if unsafe { self.inner.lock.try_lock() } {\n             Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n@@ -229,7 +231,7 @@ impl<T: Send> Mutex<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n@@ -246,15 +248,17 @@ static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n-    #[unstable = \"may be merged with Mutex in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Mutex in the future\")]\n     pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n         unsafe { self.lock.lock() }\n         MutexGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n     #[inline]\n-    #[unstable = \"may be merged with Mutex in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Mutex in the future\")]\n     pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n         if unsafe { self.lock.try_lock() } {\n             Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n@@ -273,7 +277,8 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n-    #[unstable = \"may be merged with Mutex in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Mutex in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n@@ -293,23 +298,23 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {"}, {"sha": "1c489540581824aeb4ce66dd1c3d7845d2de4830", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -36,7 +36,7 @@ use sync::{StaticMutex, MUTEX_INIT};\n ///     // run initialization here\n /// });\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Once {\n     mutex: StaticMutex,\n     cnt: AtomicIsize,\n@@ -46,7 +46,7 @@ pub struct Once {\n unsafe impl Sync for Once {}\n \n /// Initialization value for static `Once` values.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n     cnt: ATOMIC_ISIZE_INIT,\n@@ -63,7 +63,7 @@ impl Once {\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n         if self.cnt.load(Ordering::SeqCst) < 0 {"}, {"sha": "18680b96592ce3b9589de4b0a5f7b863bb36def5", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -53,22 +53,22 @@ pub struct Guard {\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PoisonError<T> {\n     guard: T,\n }\n \n /// An enumeration of possible errors which can occur while calling the\n /// `try_lock` method.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another task failed while holding\n     /// the lock.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Poisoned(PoisonError<T>),\n     /// The lock could not be acquired at this time because the operation would\n     /// otherwise block.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     WouldBlock,\n }\n \n@@ -79,25 +79,25 @@ pub enum TryLockError<T> {\n /// that the primitive was poisoned. Note that the `Err` variant *also* carries\n /// the associated guard, and it can be acquired through the `into_inner`\n /// method.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n \n /// A type alias for the result of a nonblocking locking method.\n ///\n /// For more information, see `LockResult`. A `TryLockResult` doesn't\n /// necessarily hold the associated guard in the `Err` type as the lock may not\n /// have been acquired for other reasons.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Debug for PoisonError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"PoisonError { inner: .. }\".fmt(f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for PoisonError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.description().fmt(f)\n@@ -113,22 +113,23 @@ impl<T> Error for PoisonError<T> {\n impl<T> PoisonError<T> {\n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n-    #[deprecated=\"renamed to into_inner\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to into_inner\")]\n     pub fn into_guard(self) -> T { self.guard }\n \n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n-    #[unstable]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn into_inner(self) -> T { self.guard }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// reference to the underlying guard to allow access regardless.\n-    #[unstable]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn get_ref(&self) -> &T { &self.guard }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// mutable reference to the underlying guard to allow access regardless.\n-    #[unstable]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn get_mut(&mut self) -> &mut T { &mut self.guard }\n }\n \n@@ -138,7 +139,7 @@ impl<T> FromError<PoisonError<T>> for TryLockError<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Debug for TryLockError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -148,7 +149,7 @@ impl<T> fmt::Debug for TryLockError<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for TryLockError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.description().fmt(f)"}, {"sha": "12befbf72e37e4d3f377f308ba91a9a64612ebc4", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -58,7 +58,7 @@ use sys_common::rwlock as sys;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLock<T> {\n     inner: Box<StaticRwLock>,\n     data: UnsafeCell<T>,\n@@ -90,7 +90,8 @@ unsafe impl<T> Sync for RwLock<T> {}\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n-#[unstable = \"may be merged with RwLock in the future\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"may be merged with RwLock in the future\")]\n pub struct StaticRwLock {\n     lock: sys::RWLock,\n     poison: poison::Flag,\n@@ -100,7 +101,8 @@ unsafe impl Send for StaticRwLock {}\n unsafe impl Sync for StaticRwLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n-#[unstable = \"may be merged with RwLock in the future\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"may be merged with RwLock in the future\")]\n pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n     lock: sys::RWLOCK_INIT,\n     poison: poison::FLAG_INIT,\n@@ -109,7 +111,7 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockReadGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n@@ -120,7 +122,7 @@ impl<'a, T> !marker::Send for RwLockReadGuard<'a, T> {}\n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockWriteGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n@@ -139,7 +141,7 @@ impl<T: Send + Sync> RwLock<T> {\n     ///\n     /// let lock = RwLock::new(5);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> RwLock<T> {\n         RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n     }\n@@ -162,7 +164,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n         unsafe { self.inner.lock.read() }\n         RwLockReadGuard::new(&*self.inner, &self.data)\n@@ -184,7 +186,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n             Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n@@ -208,7 +210,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// An error will be returned when the lock is acquired.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n         unsafe { self.inner.lock.write() }\n         RwLockWriteGuard::new(&*self.inner, &self.data)\n@@ -227,7 +229,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n             Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n@@ -238,7 +240,7 @@ impl<T: Send + Sync> RwLock<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         unsafe { self.inner.lock.destroy() }\n@@ -255,7 +257,8 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::read`.\n     #[inline]\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n         RwLockReadGuard::new(self, &DUMMY.0)\n@@ -265,7 +268,8 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::try_read`.\n     #[inline]\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub fn try_read(&'static self)\n                     -> TryLockResult<RwLockReadGuard<'static, ()>> {\n         if unsafe { self.lock.try_read() } {\n@@ -280,7 +284,8 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::write`.\n     #[inline]\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n         RwLockWriteGuard::new(self, &DUMMY.0)\n@@ -290,7 +295,8 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::try_write`.\n     #[inline]\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub fn try_write(&'static self)\n                      -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n         if unsafe { self.lock.try_write() } {\n@@ -306,7 +312,8 @@ impl StaticRwLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n@@ -338,35 +345,35 @@ impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);"}, {"sha": "0304b898884ccb2e47cfa0d11faf0484dac82c25", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable = \"the interaction between semaphores and the acquisition/release \\\n-               of resources is currently unclear\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"the interaction between semaphores and the acquisition/release \\\n+                      of resources is currently unclear\")]\n \n use ops::Drop;\n use sync::{Mutex, Condvar};\n@@ -99,7 +100,7 @@ impl Semaphore {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Drop for SemaphoreGuard<'a> {\n     fn drop(&mut self) {\n         self.sem.release();"}, {"sha": "3fac998d3e72d0e52452e45e9845da74687bbd55", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,10 +10,11 @@\n \n //! Abstraction of a thread pool for basic parallelism.\n \n-#![unstable = \"the semantics of a failing task and whether a thread is \\\n-               re-attached to a thread pool are somewhat unclear, and the \\\n-               utility of this type in `std::sync` is questionable with \\\n-               respect to the jobs of other primitives\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"the semantics of a failing task and whether a thread is \\\n+                      re-attached to a thread pool are somewhat unclear, and the \\\n+                      utility of this type in `std::sync` is questionable with \\\n+                      respect to the jobs of other primitives\")]\n \n use core::prelude::*;\n "}, {"sha": "4a82b2807e7a3c914ab58c220fb694b1c04dc33c", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -29,7 +29,7 @@\n //! }\n //! ```\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n use vec::Vec;\n use sys::os_str::Buf;"}, {"sha": "a3bbf5c5fe795d5c3c3c42abef13178884d90369", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -14,7 +14,7 @@\n //! descriptors, and sockets, but its functionality will grow over\n //! time.\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n pub use sys_common::wtf8::{Wtf8Buf, EncodeWide};\n "}, {"sha": "c19ec8ea25c641db80f09634b9a799b7a5ec2000", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -144,7 +144,7 @@\n //!\n //! * It can be implemented highly efficiently on many platforms.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any::Any;\n use boxed::Box;\n@@ -166,7 +166,7 @@ use sys_common::{stack, thread_info};\n \n /// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Builder {\n     // A name for the thread-to-be, for identification in panic messages\n     name: Option<String>,\n@@ -181,7 +181,7 @@ pub struct Builder {\n impl Builder {\n     /// Generate the base configuration for spawning a thread, from which\n     /// configuration methods can be chained.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Builder {\n         Builder {\n             name: None,\n@@ -193,28 +193,30 @@ impl Builder {\n \n     /// Name the thread-to-be. Currently the name is used for identification\n     /// only in panic messages.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn name(mut self, name: String) -> Builder {\n         self.name = Some(name);\n         self\n     }\n \n     /// Set the size of the stack for the new thread.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stack_size(mut self, size: uint) -> Builder {\n         self.stack_size = Some(size);\n         self\n     }\n \n     /// Redirect thread-local stdout.\n-    #[unstable = \"Will likely go away after proc removal\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"Will likely go away after proc removal\")]\n     pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Builder {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect thread-local stderr.\n-    #[unstable = \"Will likely go away after proc removal\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"Will likely go away after proc removal\")]\n     pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Builder {\n         self.stderr = Some(stderr);\n         self\n@@ -223,7 +225,8 @@ impl Builder {\n     /// Spawn a new detached thread, and return a handle to it.\n     ///\n     /// See `Thead::spawn` and the module doc for more details.\n-    #[unstable = \"may change with specifics of new Send semantics\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(self, f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n         let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(|_| {}));\n         unsafe { imp::detach(native) };\n@@ -234,7 +237,8 @@ impl Builder {\n     /// scope, and return a `JoinGuard`.\n     ///\n     /// See `Thead::scoped` and the module doc for more details.\n-    #[unstable = \"may change with specifics of new Send semantics\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n@@ -326,7 +330,7 @@ struct Inner {\n unsafe impl Sync for Inner {}\n \n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n /// A handle to a thread.\n pub struct Thread {\n     inner: Arc<Inner>,\n@@ -350,7 +354,8 @@ impl Thread {\n     /// main thread; the whole process is terminated when the main thread\n     /// finishes.) The thread handle can be used for low-level\n     /// synchronization. See the module documentation for additional details.\n-    #[unstable = \"may change with specifics of new Send semantics\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n         Builder::new().spawn(f)\n     }\n@@ -363,28 +368,29 @@ impl Thread {\n     /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n     /// it *must* be joined before the relevant stack frame is popped. See the\n     /// module documentation for additional details.\n-    #[unstable = \"may change with specifics of new Send semantics\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n         Builder::new().scoped(f)\n     }\n \n     /// Gets a handle to the thread that invokes it.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn current() -> Thread {\n         thread_info::current_thread()\n     }\n \n     /// Cooperatively give up a timeslice to the OS scheduler.\n-    #[unstable = \"name may change\"]\n+    #[unstable(feature = \"std_misc\", reason = \"name may change\")]\n     pub fn yield_now() {\n         unsafe { imp::yield_now() }\n     }\n \n     /// Determines whether the current thread is unwinding because of panic.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n@@ -398,7 +404,7 @@ impl Thread {\n     // future, this will be implemented in a more efficient way, perhaps along the lines of\n     //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n     // or futuxes, and in either case may allow spurious wakeups.\n-    #[unstable = \"recently introduced\"]\n+    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park() {\n         let thread = Thread::current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n@@ -411,7 +417,7 @@ impl Thread {\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n-    #[unstable = \"recently introduced\"]\n+    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n@@ -421,7 +427,7 @@ impl Thread {\n     }\n \n     /// Get the thread's name.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn name(&self) -> Option<&str> {\n         self.inner.name.as_ref().map(|s| s.as_slice())\n     }\n@@ -435,7 +441,7 @@ impl thread_info::NewThread for Thread {\n /// Indicates the manner in which a thread exited.\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n \n struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n@@ -447,20 +453,21 @@ unsafe impl<T> Sync for Packet<T> {}\n ///\n /// The type `T` is the return type for the thread's main function.\n #[must_use]\n-#[unstable = \"may change with specifics of new Send semantics\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"may change with specifics of new Send semantics\")]\n pub struct JoinGuard<'a, T: 'a> {\n     native: imp::rust_thread,\n     thread: Thread,\n     joined: bool,\n     packet: Packet<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<'a, T: Send + 'a> Sync for JoinGuard<'a, T> {}\n \n impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     /// Extract a handle to the thread this guard will join on.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n         &self.thread\n     }\n@@ -470,7 +477,7 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     ///\n     /// If the child thread panics, `Err` is returned with the parameter given\n     /// to `panic`.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn join(mut self) -> Result<T> {\n         assert!(!self.joined);\n         unsafe { imp::join(self.native) };\n@@ -483,15 +490,16 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n \n impl<T: Send> JoinGuard<'static, T> {\n     /// Detaches the child thread, allowing it to outlive its parent.\n-    #[unstable = \"unsure whether this API imposes limitations elsewhere\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"unsure whether this API imposes limitations elsewhere\")]\n     pub fn detach(mut self) {\n         unsafe { imp::detach(self.native) };\n         self.joined = true; // avoid joining in the destructor\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n         if !self.joined {"}, {"sha": "2a9bf452329cd636cf438340d0bb361b494ec849", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -34,7 +34,7 @@\n //! will want to make use of some form of **interior mutability** through the\n //! `Cell` or `RefCell` types.\n \n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use prelude::v1::*;\n \n@@ -93,7 +93,7 @@ pub mod __impl {\n ///     assert_eq!(*f.borrow(), 2);\n /// });\n /// ```\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Key<T> {\n     // The key itself may be tagged with #[thread_local], and this `Key` is\n     // stored as a `static`, and it's not valid for a static to reference the\n@@ -113,7 +113,7 @@ pub struct Key<T> {\n \n /// Declare a new thread local storage key of type `std::thread_local::Key`.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n         static $name: ::std::thread_local::Key<$t> = {\n@@ -218,7 +218,8 @@ macro_rules! __thread_local_inner {\n }\n \n /// Indicator of the state of a thread local storage key.\n-#[unstable = \"state querying was recently added\"]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"state querying was recently added\")]\n #[derive(Eq, PartialEq, Copy)]\n pub enum State {\n     /// All keys are in this state whenever a thread starts. Keys will\n@@ -258,7 +259,7 @@ impl<T: 'static> Key<T> {\n     /// This function will `panic!()` if the key currently has its\n     /// destructor running, and it **may** panic if the destructor has\n     /// previously been run for this thread.\n-    #[stable]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with<F, R>(&'static self, f: F) -> R\n                       where F: FnOnce(&T) -> R {\n         let slot = (self.inner)();\n@@ -301,7 +302,8 @@ impl<T: 'static> Key<T> {\n     /// initialization does not panic. Keys in the `Valid` state are guaranteed\n     /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n     /// any call to `with`.\n-    #[unstable = \"state querying was recently added\"]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"state querying was recently added\")]\n     pub fn state(&'static self) -> State {\n         unsafe {\n             match (self.inner)().get() {\n@@ -317,7 +319,9 @@ impl<T: 'static> Key<T> {\n     }\n \n     /// Deprecated\n-    #[deprecated = \"function renamed to state() and returns more info\"]\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"function renamed to state() and returns more info\")]\n     pub fn destroyed(&'static self) -> bool { self.state() == State::Destroyed }\n }\n "}, {"sha": "1a20612d60a8475b2072de79a0856719d4899cf5", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -38,8 +38,9 @@\n //! });\n //! ```\n \n-#![unstable = \"scoped TLS has yet to have wide enough use to fully consider \\\n-               stabilizing its interface\"]\n+#![unstable(feature = \"std_misc\",\n+            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n+                      stabilizing its interface\")]\n \n use prelude::v1::*;\n "}, {"sha": "2e53d0ceecbdfc0b00b1602d34d9b06ca43afd37", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,6 +10,7 @@\n \n // Because this module is temporary...\n #![allow(missing_docs)]\n+#![unstable(feature = \"std_misc\")]\n \n use alloc::boxed::Box;\n use core::marker::Send;"}, {"sha": "fdd9cbdccf515e175aab6ba43417f6998ba26d5c", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -10,7 +10,7 @@\n \n //! Temporal quantification\n \n-#![unstable]\n+#![unstable(feature = \"std_misc\")]\n \n use {fmt, i64};\n use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n@@ -334,7 +334,7 @@ impl Div<i32> for Duration {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // technically speaking, negative duration is not valid ISO 8601,"}, {"sha": "2a911557765b5b9949f0bda1831e4fd98882af17", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -57,4 +57,4 @@\n //! ```\n \n #![doc(primitive = \"tuple\")]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "2c3ddcd9d4947188f937401a07ff3a01801fc8e0", "filename": "src/libstd/unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![doc(primitive = \"unit\")]\n-#![stable]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n //! The `()` type, sometimes called \"unit\" or \"nil\".\n //!"}, {"sha": "061600d9420f5c3c89cf7b6361ed0494a6ae866a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "f3e6689731656c5b46b800896bc8f074b1d585ef", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "dd89153d497100ab190c34d349a6bc6182dddf5a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "6e797844c18c0b3cb3008ab32564553b74a64edc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 106, "deletions": 77, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "ff4c7b565cbbe469375cac7706eb8b0bf8882c4a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "99be1b11b11cbc6ee2137a7b21e1b00c3dfa3fc3", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "4bd476885a04cecd1b7f06ce05e4e79bf0e7c046", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "a7679adca2e178eeca05d954605132af0d2fdb50", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "21a7d6808475142edeab13ee9684c01c520e30df", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "aa3af76d46c1b7397b3842cc216b8101936af65c", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "43a1bbd6c02ce2937d0efb8fec1090625263000e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "e19c1dc7ed626688f26ccba638bceb7034f15e5f", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "467fed5d246706ede73c6b98a6e0398311bb2c6d", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "adcb52537094a6cb7cb410beb7a2b5741e990ef6", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "3e571bad09ca43dd62c42f560ae5f37809b18d44", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "77eb82f80228649965299a2e1be76ffe26a84a03", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "1977e2aad285e902350eb498f1c632fdd8748cf2", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "3679557d06bb761b7f69424b0dc9e5c715163197", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 74, "deletions": 79, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "3a92cf59611cf95f105382c64b05e0445e14954d", "filename": "src/test/auxiliary/stability_cfg1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "d9ed76e5c58e766ba8fbe7a4ad3ac718e5bd95ef", "filename": "src/test/auxiliary/stability_cfg2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "0bd69b73214c9b6f2209b5c141a49a26e439c6a4", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "c65b2366bf10f7360f69e167aa453f57e18bb4d9", "filename": "src/test/compile-fail/enable-unstable-lib-feature.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "9923db3c56636ad25accf1e3032652cace5b9faa", "filename": "src/test/compile-fail/fail-no-dead-code-core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "ff640793afe01f314662a9a26310baad8505fdc4", "filename": "src/test/compile-fail/issue-17337.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "a8804a6df061a5297900bbb11d970b7c2a8296cd", "filename": "src/test/compile-fail/issue-17999.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "9f0e81a662f55c38a0190140a8a623ceb498c89b", "filename": "src/test/compile-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "5f0f0fc05a929372e32b797533f81630d35a64ef", "filename": "src/test/compile-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "3f25e9c7b76aac34ea92298574f4584b3faf16c2", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "dc59194373124a9c70b0b99af684b384d0956a5d", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "be135978d2dad3b1aba763429954e0db391b4546", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "22570bad616963c3cfca4da05c7510c2bfc5d86d", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "98853a2e9a119948669b9bf9bf985d4d82dcabe4", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "fcc8fb6f933bda47e52bf96a7e30f48a7bc7f5ae", "filename": "src/test/compile-fail/lint-forbid-attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-forbid-attr.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "be927297be7b2a800ee0a949cf552e929c9134a8", "filename": "src/test/compile-fail/lint-forbid-cmdline.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-forbid-cmdline.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "ec4e3c774dbf02d9e9aae57ef8b42788513cfdba", "filename": "src/test/compile-fail/lint-output-format.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "5b093a8556cdd112f16300bf7dd4d099ca11440f", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 114, "deletions": 221, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "d5e9cc630c359eb1a7a6e6525d371fb53ce93d92", "filename": "src/test/compile-fail/lint-unknown-feature-default.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "ac1720b339e8412087645dfdbf03ab47ee968200", "filename": "src/test/compile-fail/lint-unknown-feature.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "03bb7cc1f15e049091b6916e637260703e3ccf6f", "filename": "src/test/compile-fail/lint-unused-extern-crate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "057b8e3acc6e37224fbdab11cd4211cbc59a8d7a", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "4a3f7e9cad972b9f8b564ce87b04849e42f9e172", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "5b781a40fe5482258c20e3abf3b689b9ba8ce3f4", "filename": "src/test/compile-fail/missing_debug_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "f028c9af46235647a0fbe65c47fdbf8dd169fe63", "filename": "src/test/compile-fail/simd-binop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "dcbb1880b1089da7de0a85b896226e9cb8963962", "filename": "src/test/compile-fail/stability-attribute-sanity.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "53d687b5cfefe16f6649abb6bfb3f42ddb2c60c1", "filename": "src/test/compile-fail/staged_api.rs", "status": "renamed", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fstaged_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Fstaged_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstaged_api.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08", "previous_filename": "src/test/compile-fail/simd-experimental.rs"}, {"sha": "50217ff9e5dc6c37826c05e35b4f11c58778a8bf", "filename": "src/test/compile-fail/unused-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-attr.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "578ea4479ecab5b3fb3e6751b46e6a707a3bf07d", "filename": "src/test/debuginfo/simd.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimd.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/run-make/allow-non-lint-warnings-cmdline/1", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2F1", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2F1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2F1?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "961342591aa51efbb0bf060687b1c0b569ffc988", "filename": "src/test/run-make/allow-non-lint-warnings-cmdline/Makefile", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2FMakefile?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "19ce5d0a7ca40a60a787f82b8a6fd0fed6b1e783", "filename": "src/test/run-make/allow-non-lint-warnings-cmdline/foo.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fallow-non-lint-warnings-cmdline%2Ffoo.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/run-make/allow-warnings-cmdline-stability/1", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2F1", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2F1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2F1?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "64b7f58caeaf3e7e7be37dda3b90f25c82d65406", "filename": "src/test/run-make/allow-warnings-cmdline-stability/Makefile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2FMakefile?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "6a683d96b03a046e57659af6ea976f4c12bb821a", "filename": "src/test/run-make/allow-warnings-cmdline-stability/bar.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2Fbar.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "fb23a214016a7ec41df3389036b118300d6d2410", "filename": "src/test/run-make/allow-warnings-cmdline-stability/foo.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fallow-warnings-cmdline-stability%2Ffoo.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "5aafe93067c138a058072ee94f3947e8c793826c", "filename": "src/test/run-pass/associated-types-normalize-unifield-struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "56de6726bfb2536e03c3776d049843f6192c0a42", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "13177880c5ab7da2d6c18498406ae2025351d2d1", "filename": "src/test/run-pass/issue-11958.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fissue-11958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fissue-11958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11958.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "124b0205faeb5d39a7d6b1e4c3b20a4060ed23c1", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "044d43a57fabad14eea27687b54fa27998dc6981", "filename": "src/test/run-pass/issue-21058.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21058.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "482eea19823f17a4603309de91c3e243c4fedd01", "filename": "src/test/run-pass/simd-binop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-binop.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "7f1be4b7d7060f0b8ac5ca485ffddc11ded05a64", "filename": "src/test/run-pass/simd-issue-10604.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}, {"sha": "23c5501b4a40759cd3ec424444409e4e421d6e60", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a530cc9706324ad44dba464d541a807eb5afdb08/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=a530cc9706324ad44dba464d541a807eb5afdb08"}]}