{"sha": "44bef5f2cb175769155d92ec65bd6b16e6708a1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0YmVmNWYyY2IxNzU3NjkxNTVkOTJlYzY1YmQ2YjE2ZTY3MDhhMWU=", "commit": {"author": {"name": "unknown", "email": "Eric@.(none)", "date": "2011-08-08T20:38:20Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-08T23:55:38Z"}, "message": "Introduced task handles.\n\nThis is the new way to refer to tasks in rust-land. Currently all they\ndo is serve as a key to look up the old rust_task structure. Ideally\nthey won't be ref counted, but baby steps.", "tree": {"sha": "d7524b51e2af0cb191cd93cda3f282ac4ac8f4c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7524b51e2af0cb191cd93cda3f282ac4ac8f4c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44bef5f2cb175769155d92ec65bd6b16e6708a1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44bef5f2cb175769155d92ec65bd6b16e6708a1e", "html_url": "https://github.com/rust-lang/rust/commit/44bef5f2cb175769155d92ec65bd6b16e6708a1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44bef5f2cb175769155d92ec65bd6b16e6708a1e/comments", "author": null, "committer": null, "parents": [{"sha": "f4f057ced1f4152575571a6e5116e1ad5bb38beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4f057ced1f4152575571a6e5116e1ad5bb38beb", "html_url": "https://github.com/rust-lang/rust/commit/f4f057ced1f4152575571a6e5116e1ad5bb38beb"}], "stats": {"total": 113, "additions": 75, "deletions": 38}, "files": [{"sha": "4ef3eb05ce11e69f89948e612b3e24722d080f85", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -4,7 +4,7 @@\n // NB: please do not commit code with this uncommented. It's\n // hugely expensive and should only be used as a last resort.\n //\n-// #define TRACK_ALLOCATIONS\n+#define TRACK_ALLOCATIONS\n \n #define MAGIC 0xbadc0ffe\n "}, {"sha": "a94eb6c1a242965496644e3f2d2d14136d3616a3", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -93,7 +93,9 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n     rust_srv *srv = new rust_srv(env);\n     rust_kernel *kernel = new rust_kernel(srv, env->num_sched_threads);\n-    rust_task *root_task = kernel->create_task(NULL, \"main\");\n+    rust_task_id root_id = kernel->create_task(NULL, \"main\");\n+    rust_task *root_task = kernel->get_task_by_id(root_id);\n+    I(kernel, root_task != NULL);\n     rust_scheduler *sched = root_task->sched;\n     command_line_args *args\n         = new (kernel, \"main command line args\")"}, {"sha": "7653bc35ee254b0ddbb26181dafb11c62647f908", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -408,8 +408,11 @@ task_yield(rust_task *task) {\n }\n \n extern \"C\" CDECL intptr_t\n-task_join(rust_task *task, rust_task *join_task) {\n+task_join(rust_task *task, rust_task_id tid) {\n     // If the other task is already dying, we don't have to wait for it.\n+    rust_task *join_task = task->kernel->get_task_by_id(tid);\n+    // FIXME: find task exit status and return that.\n+    if(!join_task) return 0;\n     join_task->lock.lock();\n     if (join_task->dead() == false) {\n         join_task->tasks_waiting_to_join.push(task);"}, {"sha": "12a199f685d13a08d195a25765399665db2b6c6f", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -73,16 +73,17 @@ void rust_chan::disassociate() {\n  * Attempt to send data to the associated port.\n  */\n void rust_chan::send(void *sptr) {\n-    scoped_lock with(port->lock);\n-\n-    buffer.enqueue(sptr);\n-\n     if (!is_associated()) {\n         W(kernel, is_associated(),\n           \"rust_chan::transmit with no associated port.\");\n         return;\n     }\n \n+    I(kernel, port != NULL);\n+    scoped_lock with(port->lock);\n+\n+    buffer.enqueue(sptr);\n+\n     A(kernel, !buffer.is_empty(),\n       \"rust_chan::transmit with nothing to send.\");\n "}, {"sha": "798087a9d5467277a2842c4b8a009e5097bd2545", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -64,6 +64,8 @@ struct stk_seg;\n struct type_desc;\n struct frame_glue_fns;\n \n+typedef intptr_t rust_task_id;\n+\n #ifndef __i386__\n #error \"Target CPU not supported.\"\n #endif"}, {"sha": "4197f5dea890d55bc4a7178e2f957b0f68a68bdf", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -9,6 +9,7 @@ rust_kernel::rust_kernel(rust_srv *srv, size_t num_threads) :\n     _region(srv, true),\n     _log(srv, NULL),\n     srv(srv),\n+    max_id(0),\n     num_threads(num_threads),\n     rval(0),\n     live_tasks(0),\n@@ -133,10 +134,31 @@ int rust_kernel::start_task_threads()\n     return rval;\n }\n \n-rust_task *\n+rust_task_id\n rust_kernel::create_task(rust_task *spawner, const char *name) {\n     rust_scheduler *thread = threads[rand(&rctx) % num_threads];\n-    return thread->create_task(spawner, name);\n+    rust_task *t = thread->create_task(spawner, name);\n+    {\n+        scoped_lock with(_kernel_lock);\n+        t->id = max_id++;\n+        task_table.put(t->id, t);\n+    }\n+    return t->id;\n+}\n+\n+rust_task *\n+rust_kernel::get_task_by_id(rust_task_id id) {\n+    scoped_lock with(_kernel_lock);\n+    rust_task *task = NULL;\n+    // get leaves task unchanged if not found.\n+    task_table.get(id, &task);\n+    return task;\n+}\n+\n+void\n+rust_kernel::release_task_id(rust_task_id id) {\n+    scoped_lock with(_kernel_lock);\n+    task_table.remove(id);\n }\n \n void rust_kernel::wakeup_schedulers() {"}, {"sha": "ff5b100445e30532238d562b4dec54b788572105", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -26,8 +26,10 @@ class rust_kernel {\n     void create_schedulers();\n     void destroy_schedulers();\n \n-public:\n+    rust_task_id max_id;\n+    hash_map<rust_task_id, rust_task *> task_table;\n \n+public:\n     const size_t num_threads;\n     int rval;\n \n@@ -56,7 +58,9 @@ class rust_kernel {\n     void win32_require(LPCTSTR fn, BOOL ok);\n #endif\n \n-    rust_task *create_task(rust_task *spawner, const char *name);\n+    rust_task_id create_task(rust_task *spawner, const char *name);\n+    rust_task *get_task_by_id(rust_task_id id);\n+    void release_task_id(rust_task_id tid);\n };\n \n #endif /* RUST_KERNEL_H */"}, {"sha": "286691695121c4ad39f3288145ff887ca1b0ec40", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -51,9 +51,6 @@ struct rust_scheduler : public kernel_owned<rust_scheduler>,\n     rust_kernel *kernel;\n     int32_t list_index;\n \n-    hash_map<rust_task *, rust_task *> _task_proxies;\n-    hash_map<rust_port *, rust_port *> _port_proxies;\n-\n     const int id;\n \n     lock_and_signal lock;"}, {"sha": "fbee8896590b062d3363bf378ba594769c44ae41", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -95,6 +95,8 @@ rust_task::~rust_task()\n     DLOG(sched, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n+    kernel->release_task_id(id);\n+\n     /* FIXME: tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n     I(sched, ref_count == 0); // ||"}, {"sha": "be7a774db9226047bda1d77ed23acb4a9591da3b", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -34,7 +34,6 @@ struct gc_alloc {\n     }\n };\n \n-\n struct\n rust_task : public kernel_owned<rust_task>, rust_cond\n {\n@@ -59,6 +58,8 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     size_t gc_alloc_thresh;\n     size_t gc_alloc_accum;\n \n+    rust_task_id id;\n+\n     // Keeps track of the last time this task yielded.\n     timer yield_timer;\n "}, {"sha": "5feffe600c3fc1a695365a0d2a382cf2c66f1c50", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -140,9 +140,11 @@ void upcall_del_chan(rust_task *task, rust_chan *chan) {\n  * has its own copy of the channel.\n  */\n extern \"C\" CDECL rust_chan *\n-upcall_clone_chan(rust_task *task, rust_task *target,\n+upcall_clone_chan(rust_task *task, rust_task_id tid,\n                   rust_chan *chan) {\n+    // FIXME: This should be removed.\n     LOG_UPCALL_ENTRY(task);\n+    rust_task *target = task->kernel->get_task_by_id(tid);\n     return chan->clone(target);\n }\n \n@@ -203,9 +205,9 @@ upcall_fail(rust_task *task,\n  * Called whenever a task's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_kill(rust_task *task, rust_task *target) {\n+upcall_kill(rust_task *task, rust_task_id tid) {\n     LOG_UPCALL_ENTRY(task);\n-\n+    rust_task *target = task->kernel->get_task_by_id(tid);\n     target->kill();\n }\n \n@@ -322,9 +324,9 @@ upcall_new_str(rust_task *task, char const *s, size_t fill) {\n }\n \n extern \"C\" CDECL rust_str *\n-upcall_dup_str(rust_task *task, rust_task *target, rust_str *str) {\n+upcall_dup_str(rust_task *task, rust_task_id tid, rust_str *str) {\n     LOG_UPCALL_ENTRY(task);\n-\n+    rust_task *target = task->kernel->get_task_by_id(tid);\n     return make_str(target, (char const *)str->data, str->fill);\n }\n \n@@ -482,27 +484,30 @@ upcall_get_type_desc(rust_task *task,\n     return td;\n }\n \n-extern \"C\" CDECL rust_task *\n+extern \"C\" CDECL rust_task_id\n upcall_new_task(rust_task *spawner, rust_vec *name) {\n     // name is a rust string structure.\n     LOG_UPCALL_ENTRY(spawner);\n-    rust_task *task =\n+    rust_task_id tid =\n         spawner->kernel->create_task(spawner, (const char *)name->data);\n+    rust_task *task = spawner->kernel->get_task_by_id(tid);\n     task->ref();\n-    return task;\n+    return tid;\n }\n \n extern \"C\" CDECL void\n-upcall_take_task(rust_task *task, rust_task *target) {\n+upcall_take_task(rust_task *task, rust_task_id tid) {\n     LOG_UPCALL_ENTRY(task);\n+    rust_task *target = task->kernel->get_task_by_id(tid);\n     if(target) {\n         target->ref();\n     }\n }\n \n extern \"C\" CDECL void\n-upcall_drop_task(rust_task *task, rust_task *target) {\n+upcall_drop_task(rust_task *task, rust_task_id tid) {\n     LOG_UPCALL_ENTRY(task);\n+    rust_task *target = task->kernel->get_task_by_id(tid);\n     if(target) {\n         target->deref();\n     }\n@@ -526,13 +531,14 @@ upcall_drop_chan(rust_task *task, rust_chan *target) {\n \n extern \"C\" CDECL rust_task *\n upcall_start_task(rust_task *spawner,\n-                  rust_task *task,\n+                  rust_task_id tid,\n                   uintptr_t spawnee_fn,\n                   uintptr_t args,\n                   size_t args_sz) {\n     LOG_UPCALL_ENTRY(spawner);\n \n     rust_scheduler *sched = spawner->sched;\n+    rust_task *task = spawner->kernel->get_task_by_id(tid);\n     DLOG(sched, task,\n          \"upcall start_task(task %s @0x%\" PRIxPTR\n          \", spawnee 0x%\" PRIxPTR \")\","}, {"sha": "520426eb256c169f2ec6e2ef97d80fd336db498c", "filename": "src/rt/test/rust_test_runtime.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Ftest%2Frust_test_runtime.cpp?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -45,7 +45,8 @@ void task_entry() {\n \n void\n rust_task_test::worker::run() {\n-    rust_task *root_task = kernel->create_task(NULL, \"main\");\n+    rust_task_id root_id = kernel->create_task(NULL, \"main\");\n+    rust_task *root_task = kernel->get_task_by_id(root_id);\n     root_task->start((uintptr_t)&task_entry, (uintptr_t)NULL);\n     root_task->sched->start_main_loop();\n }"}, {"sha": "0ff6ed190d3fc4c06db86e240fb920d1cd06db64", "filename": "src/rt/util/hash_map.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Futil%2Fhash_map.h", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Frt%2Futil%2Fhash_map.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Fhash_map.h?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -1,3 +1,4 @@\n+// -*- c++ -*-\n /**\n  * A C++ wrapper around uthash.\n  */"}, {"sha": "b1f825aa372544a3a575d5fac7050eb94f2b9e64", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44bef5f2cb175769155d92ec65bd6b16e6708a1e/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=44bef5f2cb175769155d92ec65bd6b16e6708a1e", "patch": "@@ -4,28 +4,23 @@ import std::comm;\n \n fn start(pcc: *u8) {\n     let c = comm::chan_from_unsafe_ptr(pcc);\n-    let p;\n+    let p = comm::mk_port[str]();\n+    c.send(p.mk_chan().unsafe_ptr());\n \n     let a;\n     let b;\n-    p = comm::mk_port[str]();\n-    c.send(p.mk_chan().unsafe_ptr());\n     a = p.recv();\n     log_err a;\n     b = p.recv();\n     log_err b;\n }\n \n fn main() {\n-    let p : comm::_port[*u8];\n-    let child;\n-\n-    p = comm::mk_port();\n-    child = spawn start(p.mk_chan().unsafe_ptr());\n-    let pc; let c;\n+    let p = comm::mk_port[*u8]();\n+    let child = spawn start(p.mk_chan().unsafe_ptr());\n \n-    pc = p.recv();\n-    c = comm::chan_from_unsafe_ptr(pc);\n+    let pc = p.recv();\n+    let c = comm::chan_from_unsafe_ptr(pc);\n     c.send(\"A\");\n     c.send(\"B\");\n     task::yield();"}]}