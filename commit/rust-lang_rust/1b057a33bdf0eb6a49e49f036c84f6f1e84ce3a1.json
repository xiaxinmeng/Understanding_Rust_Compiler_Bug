{"sha": "1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "node_id": "C_kwDOAAsO6NoAKDFiMDU3YTMzYmRmMGViNmE0OWU0OWYwMzZjODRmNmYxZTg0Y2UzYTE", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-11-18T21:44:45Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-07T21:23:35Z"}, "message": "Move associated_item* providers to their own module", "tree": {"sha": "c62eb1263abb4c76d3bd733de032938487854b49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c62eb1263abb4c76d3bd733de032938487854b49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "html_url": "https://github.com/rust-lang/rust/commit/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7595853a2ef0ff2884db8d627023687256c3845", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7595853a2ef0ff2884db8d627023687256c3845", "html_url": "https://github.com/rust-lang/rust/commit/d7595853a2ef0ff2884db8d627023687256c3845"}], "stats": {"total": 459, "additions": 234, "deletions": 225}, "files": [{"sha": "37c2f987b77743efecd56eca3d9f1c5ea4258264", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "patch": "@@ -0,0 +1,230 @@\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers {\n+        associated_item,\n+        associated_item_def_ids,\n+        associated_items,\n+        trait_of_item,\n+        ..*providers\n+    };\n+}\n+\n+fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n+    let item = tcx.hir().expect_item(def_id.expect_local());\n+    match item.kind {\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n+            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.def_id.to_def_id()),\n+        ),\n+        hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n+            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.def_id.to_def_id()),\n+        ),\n+        hir::ItemKind::TraitAlias(..) => &[],\n+        _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n+    }\n+}\n+\n+fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n+    let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n+    ty::AssocItems::new(items)\n+}\n+\n+/// If the given `DefId` describes an item belonging to a trait,\n+/// returns the `DefId` of the trait that the trait item belongs to;\n+/// otherwise, returns `None`.\n+fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    tcx.opt_associated_item(def_id).and_then(|associated_item| match associated_item.container {\n+        ty::TraitContainer(def_id) => Some(def_id),\n+        ty::ImplContainer(_) => None,\n+    })\n+}\n+\n+fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    let parent_id = tcx.hir().get_parent_item(id);\n+    let parent_def_id = tcx.hir().local_def_id(parent_id);\n+    let parent_item = tcx.hir().expect_item(parent_def_id);\n+    match parent_item.kind {\n+        hir::ItemKind::Impl(ref impl_) => {\n+            if let Some(impl_item_ref) =\n+                impl_.items.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+            {\n+                let assoc_item =\n+                    associated_item_from_impl_item_ref(tcx, parent_def_id, impl_item_ref);\n+                debug_assert_eq!(assoc_item.def_id, def_id);\n+                return assoc_item;\n+            }\n+        }\n+\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            if let Some(trait_item_ref) =\n+                trait_item_refs.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+            {\n+                let assoc_item =\n+                    associated_item_from_trait_item_ref(tcx, parent_def_id, trait_item_ref);\n+                debug_assert_eq!(assoc_item.def_id, def_id);\n+                return assoc_item;\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    span_bug!(\n+        parent_item.span,\n+        \"unexpected parent of trait or impl item or item not found: {:?}\",\n+        parent_item.kind\n+    )\n+}\n+\n+fn associated_item_from_trait_item_ref(\n+    tcx: TyCtxt<'_>,\n+    parent_def_id: LocalDefId,\n+    trait_item_ref: &hir::TraitItemRef,\n+) -> ty::AssocItem {\n+    let def_id = trait_item_ref.id.def_id;\n+    let (kind, has_self) = match trait_item_ref.kind {\n+        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n+        hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n+        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n+    };\n+\n+    ty::AssocItem {\n+        ident: trait_item_ref.ident,\n+        kind,\n+        vis: tcx.visibility(def_id),\n+        defaultness: trait_item_ref.defaultness,\n+        def_id: def_id.to_def_id(),\n+        trait_item_def_id: Some(def_id.to_def_id()),\n+        container: ty::TraitContainer(parent_def_id.to_def_id()),\n+        fn_has_self_parameter: has_self,\n+    }\n+}\n+\n+fn associated_item_from_impl_item_ref(\n+    tcx: TyCtxt<'_>,\n+    parent_def_id: LocalDefId,\n+    impl_item_ref: &hir::ImplItemRef,\n+) -> ty::AssocItem {\n+    let def_id = impl_item_ref.id.def_id;\n+    let (kind, has_self) = match impl_item_ref.kind {\n+        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n+        hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n+        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n+    };\n+\n+    let trait_item_def_id = impl_item_base_id(tcx, parent_def_id, impl_item_ref);\n+\n+    ty::AssocItem {\n+        ident: impl_item_ref.ident,\n+        kind,\n+        vis: tcx.visibility(def_id),\n+        defaultness: impl_item_ref.defaultness,\n+        def_id: def_id.to_def_id(),\n+        trait_item_def_id,\n+        container: ty::ImplContainer(parent_def_id.to_def_id()),\n+        fn_has_self_parameter: has_self,\n+    }\n+}\n+\n+fn impl_item_base_id<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    parent_def_id: LocalDefId,\n+    impl_item: &hir::ImplItemRef,\n+) -> Option<DefId> {\n+    let impl_trait_ref = tcx.impl_trait_ref(parent_def_id)?;\n+\n+    // If the trait reference itself is erroneous (so the compilation is going\n+    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n+    // isn't populated for such impls.\n+    if impl_trait_ref.references_error() {\n+        return None;\n+    }\n+\n+    // Locate trait items\n+    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n+\n+    // Match item against trait\n+    let mut items = associated_items.filter_by_name(tcx, impl_item.ident, impl_trait_ref.def_id);\n+\n+    let mut trait_item = items.next()?;\n+\n+    let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n+        (ty::AssocKind::Const, hir::AssocItemKind::Const) => true,\n+        (ty::AssocKind::Fn, hir::AssocItemKind::Fn { .. }) => true,\n+        (ty::AssocKind::Type, hir::AssocItemKind::Type) => true,\n+        _ => false,\n+    };\n+\n+    // If we don't have a compatible item, we'll use the first one whose name matches\n+    // to report an error.\n+    let mut compatible_kind = is_compatible(&trait_item);\n+\n+    if !compatible_kind {\n+        if let Some(ty_trait_item) = items.find(is_compatible) {\n+            compatible_kind = true;\n+            trait_item = ty_trait_item;\n+        }\n+    }\n+\n+    if compatible_kind {\n+        Some(trait_item.def_id)\n+    } else {\n+        report_mismatch_error(tcx, trait_item.def_id, impl_trait_ref, impl_item);\n+        None\n+    }\n+}\n+\n+#[inline(never)]\n+#[cold]\n+fn report_mismatch_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_item_def_id: DefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item: &hir::ImplItemRef,\n+) {\n+    let mut err = match impl_item.kind {\n+        hir::AssocItemKind::Const => {\n+            // Find associated const definition.\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0323,\n+                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::AssocItemKind::Fn { .. } => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0324,\n+                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::AssocItemKind::Type => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0325,\n+                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+    };\n+\n+    err.span_label(impl_item.span, \"does not match trait\");\n+    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n+        err.span_label(trait_span, \"item in trait\");\n+    }\n+    err.emit();\n+}"}, {"sha": "55e199907617cb72af846b85a8c6c357cb6492f6", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "patch": "@@ -16,13 +16,15 @@ extern crate tracing;\n \n use rustc_middle::ty::query::Providers;\n \n+mod assoc;\n mod common_traits;\n pub mod instance;\n mod needs_drop;\n pub mod representability;\n mod ty;\n \n pub fn provide(providers: &mut Providers) {\n+    assoc::provide(providers);\n     common_traits::provide(providers);\n     needs_drop::provide(providers);\n     ty::provide(providers);"}, {"sha": "8f50e3e0fe1ca984883046c497e0687460d0439e", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 225, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "patch": "@@ -1,11 +1,8 @@\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{\n-    self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt, TypeFoldable,\n-};\n+use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits;\n \n@@ -74,193 +71,6 @@ fn sized_constraint_for_ty<'tcx>(\n     result\n }\n \n-fn associated_item_from_trait_item_ref(\n-    tcx: TyCtxt<'_>,\n-    parent_def_id: LocalDefId,\n-    trait_item_ref: &hir::TraitItemRef,\n-) -> ty::AssocItem {\n-    let def_id = trait_item_ref.id.def_id;\n-    let (kind, has_self) = match trait_item_ref.kind {\n-        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n-        hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n-        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-    };\n-\n-    ty::AssocItem {\n-        ident: trait_item_ref.ident,\n-        kind,\n-        vis: tcx.visibility(def_id),\n-        defaultness: trait_item_ref.defaultness,\n-        def_id: def_id.to_def_id(),\n-        trait_item_def_id: Some(def_id.to_def_id()),\n-        container: ty::TraitContainer(parent_def_id.to_def_id()),\n-        fn_has_self_parameter: has_self,\n-    }\n-}\n-\n-fn associated_item_from_impl_item_ref(\n-    tcx: TyCtxt<'_>,\n-    parent_def_id: LocalDefId,\n-    impl_item_ref: &hir::ImplItemRef,\n-) -> ty::AssocItem {\n-    let def_id = impl_item_ref.id.def_id;\n-    let (kind, has_self) = match impl_item_ref.kind {\n-        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n-        hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n-        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-    };\n-\n-    let trait_item_def_id = impl_item_base_id(tcx, parent_def_id, impl_item_ref);\n-\n-    ty::AssocItem {\n-        ident: impl_item_ref.ident,\n-        kind,\n-        vis: tcx.visibility(def_id),\n-        defaultness: impl_item_ref.defaultness,\n-        def_id: def_id.to_def_id(),\n-        trait_item_def_id,\n-        container: ty::ImplContainer(parent_def_id.to_def_id()),\n-        fn_has_self_parameter: has_self,\n-    }\n-}\n-\n-fn impl_item_base_id<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    parent_def_id: LocalDefId,\n-    impl_item: &hir::ImplItemRef,\n-) -> Option<DefId> {\n-    let impl_trait_ref = tcx.impl_trait_ref(parent_def_id)?;\n-\n-    // If the trait reference itself is erroneous (so the compilation is going\n-    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n-    // isn't populated for such impls.\n-    if impl_trait_ref.references_error() {\n-        return None;\n-    }\n-\n-    // Locate trait items\n-    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n-\n-    // Match item against trait\n-    let mut items = associated_items.filter_by_name(tcx, impl_item.ident, impl_trait_ref.def_id);\n-\n-    let mut trait_item = items.next()?;\n-\n-    let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n-        (ty::AssocKind::Const, hir::AssocItemKind::Const) => true,\n-        (ty::AssocKind::Fn, hir::AssocItemKind::Fn { .. }) => true,\n-        (ty::AssocKind::Type, hir::AssocItemKind::Type) => true,\n-        _ => false,\n-    };\n-\n-    // If we don't have a compatible item, we'll use the first one whose name matches\n-    // to report an error.\n-    let mut compatible_kind = is_compatible(&trait_item);\n-\n-    if !compatible_kind {\n-        if let Some(ty_trait_item) = items.find(is_compatible) {\n-            compatible_kind = true;\n-            trait_item = ty_trait_item;\n-        }\n-    }\n-\n-    if compatible_kind {\n-        Some(trait_item.def_id)\n-    } else {\n-        report_mismatch_error(tcx, trait_item.def_id, impl_trait_ref, impl_item);\n-        None\n-    }\n-}\n-\n-#[inline(never)]\n-#[cold]\n-fn report_mismatch_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_item_def_id: DefId,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item: &hir::ImplItemRef,\n-) {\n-    let mut err = match impl_item.kind {\n-        hir::AssocItemKind::Const => {\n-            // Find associated const definition.\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0323,\n-                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n-                impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-\n-        hir::AssocItemKind::Fn { .. } => {\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0324,\n-                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n-                impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-\n-        hir::AssocItemKind::Type => {\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0325,\n-                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n-                impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-    };\n-\n-    err.span_label(impl_item.span, \"does not match trait\");\n-    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n-        err.span_label(trait_span, \"item in trait\");\n-    }\n-    err.emit();\n-}\n-\n-fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n-    let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let parent_id = tcx.hir().get_parent_item(id);\n-    let parent_def_id = tcx.hir().local_def_id(parent_id);\n-    let parent_item = tcx.hir().expect_item(parent_def_id);\n-    match parent_item.kind {\n-        hir::ItemKind::Impl(ref impl_) => {\n-            if let Some(impl_item_ref) =\n-                impl_.items.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n-            {\n-                let assoc_item =\n-                    associated_item_from_impl_item_ref(tcx, parent_def_id, impl_item_ref);\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n-                return assoc_item;\n-            }\n-        }\n-\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            if let Some(trait_item_ref) =\n-                trait_item_refs.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n-            {\n-                let assoc_item =\n-                    associated_item_from_trait_item_ref(tcx, parent_def_id, trait_item_ref);\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n-                return assoc_item;\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    span_bug!(\n-        parent_item.span,\n-        \"unexpected parent of trait or impl item or item not found: {:?}\",\n-        parent_item.kind\n-    )\n-}\n-\n fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n     let item = tcx.hir().expect_item(def_id.expect_local());\n     if let hir::ItemKind::Impl(impl_) = &item.kind {\n@@ -303,25 +113,6 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n     ty::AdtSizedConstraint(result)\n }\n \n-fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n-    match item.kind {\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n-            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.def_id.to_def_id()),\n-        ),\n-        hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n-            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.def_id.to_def_id()),\n-        ),\n-        hir::ItemKind::TraitAlias(..) => &[],\n-        _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n-    }\n-}\n-\n-fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n-    let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n-    ty::AssocItems::new(items)\n-}\n-\n fn def_ident_span(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Span> {\n     tcx.hir()\n         .get_if_local(def_id)\n@@ -337,16 +128,6 @@ fn def_ident_span(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Span> {\n         .map(|ident| ident.span)\n }\n \n-/// If the given `DefId` describes an item belonging to a trait,\n-/// returns the `DefId` of the trait that the trait item belongs to;\n-/// otherwise, returns `None`.\n-fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    tcx.opt_associated_item(def_id).and_then(|associated_item| match associated_item.container {\n-        ty::TraitContainer(def_id) => Some(def_id),\n-        ty::ImplContainer(_) => None,\n-    })\n-}\n-\n /// See `ParamEnv` struct definition for details.\n #[instrument(level = \"debug\", skip(tcx))]\n fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n@@ -726,14 +507,10 @@ pub fn conservative_is_privately_uninhabited_raw<'tcx>(\n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n         asyncness,\n-        associated_item,\n-        associated_item_def_ids,\n-        associated_items,\n         adt_sized_constraint,\n         def_ident_span,\n         param_env,\n         param_env_reveal_all_normalized,\n-        trait_of_item,\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,"}]}