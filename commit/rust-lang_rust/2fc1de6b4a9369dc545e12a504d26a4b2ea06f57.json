{"sha": "2fc1de6b4a9369dc545e12a504d26a4b2ea06f57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYzFkZTZiNGE5MzY5ZGM1NDVlMTJhNTA0ZDI2YTRiMmVhMDZmNTc=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-04T09:40:47Z"}, "committer": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-08T12:48:13Z"}, "message": "rewrite_string: do not overflow the next line when the line_start is not a whitespace", "tree": {"sha": "1b06ccfd00705a56141325525489e711b2f76a08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b06ccfd00705a56141325525489e711b2f76a08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fc1de6b4a9369dc545e12a504d26a4b2ea06f57", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEipi5pnt+pUplKNfibVYg2QghATMFAlu7Ug0ACgkQbVYg2Qgh\nATN20AgAi0IPHgaezINiJL+s3gjmq0qf7qjuxtnE/0LpDoRQpOisWLeshr1OWki5\naQspOeYswN730q2A8UtUSyhN5bILg9UcoY+Yt2FEi5z96deC18p5GACJURUt4tVH\nXbz4yrF4KVa78NHnMon8VqWEM/iZZbo1ncUmbVcMgmfFoV74hmJMuz1NXPlxkZuD\nXXp9HN7QMc+lWDxQ9aDozQAT4+CJYKTfrXvc8NvW8ryx5G2rqY0lFrBTt1qDZrMm\n6zPexTRMdeAvOnaoja6W/2uw+W25ygHUcu7UoEphrklMImU1BhwaGHaugTEjxyfH\nOR9napiHI4k9w6TpjLuRhaURPL/3bw==\n=QIE4\n-----END PGP SIGNATURE-----", "payload": "tree 1b06ccfd00705a56141325525489e711b2f76a08\nparent f46082fbd8e5c347d018dd1889181fef2015c4bd\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1538646047 +0200\ncommitter St\u00e9phane Campinas <stephane.campinas@gmail.com> 1539002893 +0200\n\nrewrite_string: do not overflow the next line when the line_start is not a whitespace\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc1de6b4a9369dc545e12a504d26a4b2ea06f57", "html_url": "https://github.com/rust-lang/rust/commit/2fc1de6b4a9369dc545e12a504d26a4b2ea06f57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fc1de6b4a9369dc545e12a504d26a4b2ea06f57/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f46082fbd8e5c347d018dd1889181fef2015c4bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f46082fbd8e5c347d018dd1889181fef2015c4bd", "html_url": "https://github.com/rust-lang/rust/commit/f46082fbd8e5c347d018dd1889181fef2015c4bd"}], "stats": {"total": 90, "additions": 75, "deletions": 15}, "files": [{"sha": "7589dca1bf9540e463893c4afe202f9b6a8f70aa", "filename": "src/string.rs", "status": "modified", "additions": 75, "deletions": 15, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2fc1de6b4a9369dc545e12a504d26a4b2ea06f57/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc1de6b4a9369dc545e12a504d26a4b2ea06f57/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=2fc1de6b4a9369dc545e12a504d26a4b2ea06f57", "patch": "@@ -64,7 +64,7 @@ impl<'a> StringFormat<'a> {\n \n     /// Like max_chars_with_indent but the indentation is not substracted.\n     /// This allows to fit more graphemes from the string on a line when\n-    /// SnippetState::Overflow.\n+    /// SnippetState::EndWithLineFeed.\n     fn max_chars_without_indent(&self) -> Option<usize> {\n         Some(self.config.max_width().checked_sub(self.line_end.len())?)\n     }\n@@ -73,7 +73,8 @@ impl<'a> StringFormat<'a> {\n pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String> {\n     let max_chars_with_indent = fmt.max_chars_with_indent()?;\n     let max_chars_without_indent = fmt.max_chars_without_indent()?;\n-    let indent = fmt.shape.indent.to_string_with_newline(fmt.config);\n+    let indent_with_newline = fmt.shape.indent.to_string_with_newline(fmt.config);\n+    let indent_without_newline = fmt.shape.indent.to_string(fmt.config);\n \n     // Strip line breaks.\n     // With this regex applied, all remaining whitespaces are significant\n@@ -95,6 +96,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     // Snip a line at a time from `stripped_str` until it is used up. Push the snippet\n     // onto result.\n     let mut cur_max_chars = max_chars_with_indent;\n+    let is_overflow_allowed = is_whitespace(fmt.line_start);\n     loop {\n         // All the input starting at cur_start fits on the current line\n         if graphemes.len() - cur_start <= cur_max_chars {\n@@ -112,14 +114,21 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n             SnippetState::LineEnd(line, len) => {\n                 result.push_str(&line);\n                 result.push_str(fmt.line_end);\n-                result.push_str(&indent);\n+                result.push_str(&indent_with_newline);\n                 result.push_str(fmt.line_start);\n                 cur_max_chars = max_chars_with_indent;\n                 cur_start += len;\n             }\n-            SnippetState::Overflow(line, len) => {\n+            SnippetState::EndWithLineFeed(line, len) => {\n                 result.push_str(&line);\n-                cur_max_chars = max_chars_without_indent;\n+                if is_overflow_allowed {\n+                    // the next line can benefit from the full width\n+                    cur_max_chars = max_chars_without_indent;\n+                } else {\n+                    result.push_str(&indent_without_newline);\n+                    result.push_str(fmt.line_start);\n+                    cur_max_chars = max_chars_with_indent;\n+                }\n                 cur_start += len;\n             }\n             SnippetState::EndOfInput(line) => {\n@@ -141,14 +150,19 @@ enum SnippetState {\n     EndOfInput(String),\n     /// The input could be broken and the returned snippet should be ended with a\n     /// `[StringFormat::line_end]`. The next snippet needs to be indented.\n+    ///\n     /// The returned string is the line to print out and the number is the length that got read in\n     /// the text being rewritten. That length may be greater than the returned string if trailing\n     /// whitespaces got trimmed.\n     LineEnd(String, usize),\n-    /// The input could be broken but the returned snippet should not be ended with a\n-    /// `[StringFormat::line_end]` because the whitespace is significant. Therefore, the next\n-    /// snippet should not be indented.\n-    Overflow(String, usize),\n+    /// The input could be broken but a newline is present that cannot be trimmed. The next snippet\n+    /// to be rewritten *could* use more width than what is specified by the given shape. For\n+    /// example with a multiline string, the next snippet does not need to be indented, allowing\n+    /// more characters to be fit within a line.\n+    ///\n+    /// The returned string is the line to print out and the number is the length that got read in\n+    /// the text being rewritten.\n+    EndWithLineFeed(String, usize),\n }\n \n /// Break the input string at a boundary character around the offset `max_chars`. A boundary\n@@ -170,7 +184,7 @@ fn break_string(max_chars: usize, trim_end: bool, input: &[&str]) -> SnippetStat\n         for (i, grapheme) in input[0..=index].iter().enumerate() {\n             if is_line_feed(grapheme) {\n                 if i < index_minus_ws || !trim_end {\n-                    return SnippetState::Overflow(input[0..=i].join(\"\").to_string(), i + 1);\n+                    return SnippetState::EndWithLineFeed(input[0..=i].join(\"\").to_string(), i + 1);\n                 }\n                 break;\n             }\n@@ -179,7 +193,7 @@ fn break_string(max_chars: usize, trim_end: bool, input: &[&str]) -> SnippetStat\n         let mut index_plus_ws = index;\n         for (i, grapheme) in input[index + 1..].iter().enumerate() {\n             if !trim_end && is_line_feed(grapheme) {\n-                return SnippetState::Overflow(\n+                return SnippetState::EndWithLineFeed(\n                     input[0..=index + 1 + i].join(\"\").to_string(),\n                     index + 2 + i,\n                 );\n@@ -314,11 +328,11 @@ mod test {\n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n             break_string(15, false, &graphemes[..]),\n-            SnippetState::Overflow(\"Neque in sem.      \\n\".to_string(), 20)\n+            SnippetState::EndWithLineFeed(\"Neque in sem.      \\n\".to_string(), 20)\n         );\n         assert_eq!(\n             break_string(25, false, &graphemes[..]),\n-            SnippetState::Overflow(\"Neque in sem.      \\n\".to_string(), 20)\n+            SnippetState::EndWithLineFeed(\"Neque in sem.      \\n\".to_string(), 20)\n         );\n         // if `StringFormat::line_end` is true, then the line feed does not matter anymore\n         assert_eq!(\n@@ -352,11 +366,11 @@ mod test {\n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n             break_string(25, false, &graphemes[..]),\n-            SnippetState::Overflow(\"Nulla\\n\".to_string(), 6)\n+            SnippetState::EndWithLineFeed(\"Nulla\\n\".to_string(), 6)\n         );\n         assert_eq!(\n             break_string(25, true, &graphemes[..]),\n-            SnippetState::Overflow(\"Nulla\\n\".to_string(), 6)\n+            SnippetState::EndWithLineFeed(\"Nulla\\n\".to_string(), 6)\n         );\n \n         let mut config: Config = Default::default();\n@@ -383,4 +397,50 @@ mod test {\n         let rewritten_string = rewrite_string(string, &fmt);\n         assert_eq!(rewritten_string, Some(\"\\\"Vivamus id mi.  \\\"\".to_string()));\n     }\n+\n+    #[test]\n+    fn overflow_in_non_string_content() {\n+        let comment = \"Aenean metus.\\nVestibulum ac lacus. Vivamus porttitor\";\n+        let config: Config = Default::default();\n+        let fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"\",\n+            shape: Shape::legacy(30, Indent::from_width(&config, 8)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\n+                \"Aenean metus.\\n        // Vestibulum ac lacus. Vivamus\\n        // porttitor\"\n+                    .to_string()\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn overflow_in_non_string_content_with_line_end() {\n+        let comment = \"Aenean metus.\\nVestibulum ac lacus. Vivamus porttitor\";\n+        let config: Config = Default::default();\n+        let fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"@\",\n+            shape: Shape::legacy(30, Indent::from_width(&config, 8)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\n+                \"Aenean metus.\\n        // Vestibulum ac lacus. Vivamus@\\n        // porttitor\"\n+                    .to_string()\n+            )\n+        );\n+    }\n }"}]}