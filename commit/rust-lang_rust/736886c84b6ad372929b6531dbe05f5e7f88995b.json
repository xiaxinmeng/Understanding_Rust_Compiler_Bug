{"sha": "736886c84b6ad372929b6531dbe05f5e7f88995b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNjg4NmM4NGI2YWQzNzI5MjliNjUzMWRiZTA1ZjVlN2Y4ODk5NWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-10T00:47:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-10T00:47:35Z"}, "message": "Auto merge of #26907 - nrc:save-fns, r=brson\n\nr? @huonw", "tree": {"sha": "0fa1a4e16b2b94996f0a5f7c7e241988da4f503a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fa1a4e16b2b94996f0a5f7c7e241988da4f503a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/736886c84b6ad372929b6531dbe05f5e7f88995b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/736886c84b6ad372929b6531dbe05f5e7f88995b", "html_url": "https://github.com/rust-lang/rust/commit/736886c84b6ad372929b6531dbe05f5e7f88995b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/736886c84b6ad372929b6531dbe05f5e7f88995b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67256dff6dd7526f0be9da5092a6b3e390654c8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/67256dff6dd7526f0be9da5092a6b3e390654c8c", "html_url": "https://github.com/rust-lang/rust/commit/67256dff6dd7526f0be9da5092a6b3e390654c8c"}, {"sha": "0c766cb8bc62fcd016165db2313188e7f6de71dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c766cb8bc62fcd016165db2313188e7f6de71dd", "html_url": "https://github.com/rust-lang/rust/commit/0c766cb8bc62fcd016165db2313188e7f6de71dd"}], "stats": {"total": 541, "additions": 331, "deletions": 210}, "files": [{"sha": "c5196d09e00a14f48ad97dc7c3d2afd28e872ea7", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 81, "deletions": 185, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=736886c84b6ad372929b6531dbe05f5e7f88995b", "patch": "@@ -28,19 +28,17 @@\n //! DumpCsvVisitor walks the AST and processes it.\n \n \n-use super::{escape, generated_code, recorder, SaveContext, PathCollector};\n+use super::{escape, generated_code, recorder, SaveContext, PathCollector, Data};\n \n use session::Session;\n \n use middle::def;\n use middle::ty::{self, Ty};\n-use rustc::ast_map::NodeItem;\n \n use std::cell::Cell;\n use std::fs::File;\n use std::path::Path;\n \n-use syntax::ast_util;\n use syntax::ast::{self, NodeId, DefId};\n use syntax::codemap::*;\n use syntax::parse::token::{self, get_ident, keywords};\n@@ -298,101 +296,34 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_method(&mut self, sig: &ast::MethodSig,\n+    fn process_method(&mut self,\n+                      sig: &ast::MethodSig,\n                       body: Option<&ast::Block>,\n-                      id: ast::NodeId, name: ast::Name,\n+                      id: ast::NodeId,\n+                      name: ast::Name,\n                       span: Span) {\n         if generated_code(span) {\n             return;\n         }\n \n         debug!(\"process_method: {}:{}\", id, token::get_name(name));\n \n-        let scope_id;\n-        // The qualname for a method is the trait name or name of the struct in an impl in\n-        // which the method is declared in, followed by the method's name.\n-        let qualname = match self.tcx.impl_of_method(ast_util::local_def(id)) {\n-            Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n-                NodeItem(item) => {\n-                    scope_id = item.id;\n-                    match item.node {\n-                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n-                            let mut result = String::from(\"<\");\n-                            result.push_str(&ty_to_string(&**ty));\n-\n-                            match self.tcx.trait_of_item(ast_util::local_def(id)) {\n-                                Some(def_id) => {\n-                                    result.push_str(\" as \");\n-                                    result.push_str(\n-                                        &self.tcx.item_path_str(def_id));\n-                                },\n-                                None => {}\n-                            }\n-                            result.push_str(\">\");\n-                            result\n-                        }\n-                        _ => {\n-                            self.sess.span_bug(span,\n-                                &format!(\"Container {} for method {} not an impl?\",\n-                                         impl_id.node, id));\n-                        },\n-                    }\n-                },\n-                _ => {\n-                    self.sess.span_bug(span,\n-                        &format!(\"Container {} for method {} is not a node item {:?}\",\n-                                 impl_id.node, id, self.tcx.map.get(impl_id.node)));\n-                },\n-            },\n-            None => match self.tcx.trait_of_item(ast_util::local_def(id)) {\n-                Some(def_id) => {\n-                    scope_id = def_id.node;\n-                    match self.tcx.map.get(def_id.node) {\n-                        NodeItem(_) => {\n-                            format!(\"::{}\", self.tcx.item_path_str(def_id))\n-                        }\n-                        _ => {\n-                            self.sess.span_bug(span,\n-                                &format!(\"Could not find container {} for method {}\",\n-                                         def_id.node, id));\n-                        }\n-                    }\n-                },\n-                None => {\n-                    self.sess.span_bug(span,\n-                        &format!(\"Could not find container for method {}\", id));\n-                },\n-            },\n-        };\n-\n-        let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n-\n-        // record the decl for this def (if it has one)\n-        let decl_id = self.tcx.trait_item_of_item(ast_util::local_def(id))\n-            .and_then(|new_id| {\n-                let def_id = new_id.def_id();\n-                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n-                    Some(def_id)\n-                } else {\n-                    None\n-                }\n-            });\n+        let method_data = self.save_ctxt.get_method_data(id, name, span);\n \n-        let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n         if body.is_some() {\n             self.fmt.method_str(span,\n-                                sub_span,\n-                                id,\n-                                qualname,\n-                                decl_id,\n-                                scope_id);\n-            self.process_formals(&sig.decl.inputs, qualname);\n+                                Some(method_data.span),\n+                                method_data.id,\n+                                &method_data.qualname,\n+                                method_data.declaration,\n+                                method_data.scope);\n+            self.process_formals(&sig.decl.inputs, &method_data.qualname);\n         } else {\n             self.fmt.method_decl_str(span,\n-                                     sub_span,\n-                                     id,\n-                                     qualname,\n-                                     scope_id);\n+                                     Some(method_data.span),\n+                                     method_data.id,\n+                                     &method_data.qualname,\n+                                     method_data.scope);\n         }\n \n         // walk arg and return types\n@@ -411,7 +342,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         self.process_generic_params(&sig.generics,\n                                     span,\n-                                    qualname,\n+                                    &method_data.qualname,\n                                     id);\n     }\n \n@@ -432,7 +363,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                 parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            down_cast_data!(field_data, VariableData, self, field.span);\n             self.fmt.field_str(field.span,\n                                Some(field_data.span),\n                                field_data.id,\n@@ -738,90 +668,51 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     fn process_path(&mut self,\n                     id: NodeId,\n-                    span: Span,\n                     path: &ast::Path,\n                     ref_kind: Option<recorder::Row>) {\n-        if generated_code(span) {\n-            return\n+        if generated_code(path.span) {\n+            return;\n         }\n \n-        let def_map = self.tcx.def_map.borrow();\n-        if !def_map.contains_key(&id) {\n-            self.sess.span_bug(span,\n-                               &format!(\"def_map has no key for {} in visit_expr\", id));\n-        }\n-        let def = def_map.get(&id).unwrap().full_def();\n-        let sub_span = self.span.span_for_last_ident(span);\n-        match def {\n-            def::DefUpvar(..) |\n-            def::DefLocal(..) |\n-            def::DefStatic(..) |\n-            def::DefConst(..) |\n-            def::DefAssociatedConst(..) |\n-            def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n-                                                    span,\n-                                                    sub_span,\n-                                                    def.def_id(),\n-                                                    self.cur_scope),\n-            def::DefStruct(def_id) => self.fmt.ref_str(recorder::TypeRef,\n-                                                       span,\n-                                                       sub_span,\n-                                                       def_id,\n-                                                       self.cur_scope),\n-            def::DefTy(def_id, _) => self.fmt.ref_str(recorder::TypeRef,\n-                                                      span,\n-                                                      sub_span,\n-                                                      def_id,\n-                                                      self.cur_scope),\n-            def::DefMethod(declid, provenence) => {\n-                let sub_span = self.span.sub_span_for_meth_name(span);\n-                let defid = if declid.krate == ast::LOCAL_CRATE {\n-                    let ti = self.tcx.impl_or_trait_item(declid);\n-                    match provenence {\n-                        def::FromTrait(def_id) => {\n-                            Some(self.tcx.trait_items(def_id)\n-                                    .iter()\n-                                    .find(|mr| {\n-                                        mr.name() == ti.name()\n-                                    })\n-                                    .unwrap()\n-                                    .def_id())\n-                        }\n-                        def::FromImpl(def_id) => {\n-                            let impl_items = self.tcx.impl_items.borrow();\n-                            Some(impl_items.get(&def_id)\n-                                           .unwrap()\n-                                           .iter()\n-                                           .find(|mr| {\n-                                                self.tcx.impl_or_trait_item(mr.def_id()).name()\n-                                                    == ti.name()\n-                                            })\n-                                           .unwrap()\n-                                           .def_id())\n-                        }\n-                    }\n-                } else {\n-                    None\n-                };\n-                self.fmt.meth_call_str(span,\n-                                       sub_span,\n-                                       defid,\n-                                       Some(declid),\n-                                       self.cur_scope);\n-            },\n-            def::DefFn(def_id, _) => {\n-                self.fmt.fn_call_str(span,\n-                                     sub_span,\n-                                     def_id,\n-                                     self.cur_scope)\n+        let path_data = self.save_ctxt.get_path_data(id, path);\n+        match path_data {\n+            Data::VariableRefData(ref vrd) => {\n+                self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n+                                                    path.span,\n+                                                    Some(vrd.span),\n+                                                    vrd.ref_id,\n+                                                    vrd.scope);\n+\n+            }\n+            Data::TypeRefData(ref trd) => {\n+                self.fmt.ref_str(recorder::TypeRef,\n+                                 path.span,\n+                                 Some(trd.span),\n+                                 trd.ref_id,\n+                                 trd.scope);\n+            }\n+            Data::MethodCallData(ref mcd) => {\n+                self.fmt.meth_call_str(path.span,\n+                                       Some(mcd.span),\n+                                       mcd.ref_id,\n+                                       mcd.decl_id,\n+                                       mcd.scope);\n+            }\n+            Data::FunctionCallData(fcd) => {\n+                self.fmt.fn_call_str(path.span,\n+                                     Some(fcd.span),\n+                                     fcd.ref_id,\n+                                     fcd.scope);\n+            }\n+            _ => {\n+                self.sess.span_bug(path.span,\n+                                   &format!(\"Unexpected data: {:?}\", path_data));\n             }\n-            _ => self.sess.span_bug(span,\n-                                    &format!(\"Unexpected def kind while looking \\\n-                                              up path in `{}`: `{:?}`\",\n-                                             self.span.snippet(span),\n-                                             def)),\n         }\n-        // modules or types in the path prefix\n+\n+        // Modules or types in the path prefix.\n+        let def_map = self.tcx.def_map.borrow();\n+        let def = def_map.get(&id).unwrap().full_def();\n         match def {\n             def::DefMethod(did, _) => {\n                 let ti = self.tcx.impl_or_trait_item(did);\n@@ -861,6 +752,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                              struct_lit_data.ref_id,\n                              struct_lit_data.scope);\n             let struct_def = struct_lit_data.ref_id;\n+            let scope = self.save_ctxt.enclosing_scope(ex.id);\n \n             for field in fields {\n                 if generated_code(field.ident.span) {\n@@ -869,7 +761,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n                 let field_data = self.save_ctxt.get_field_ref_data(field,\n                                                                    struct_def,\n-                                                                   self.cur_scope);\n+                                                                   scope);\n                 self.fmt.ref_str(recorder::VarRef,\n                                  field.ident.span,\n                                  Some(field_data.span),\n@@ -886,18 +778,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n-        let method_call = ty::MethodCall::expr(ex.id);\n-        let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n-        let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n-            ty::ImplContainer(_) => (Some(method_id), None),\n-            ty::TraitContainer(_) => (None, Some(method_id))\n-        };\n-        let sub_span = self.span.sub_span_for_meth_name(ex.span);\n-        self.fmt.meth_call_str(ex.span,\n-                               sub_span,\n-                               def_id,\n-                               decl_id,\n-                               self.cur_scope);\n+        if let Some(call_data) = self.save_ctxt.get_expr_data(ex) {\n+            down_cast_data!(call_data, MethodCallData, self, ex.span);\n+            self.fmt.meth_call_str(ex.span,\n+                                   Some(call_data.span),\n+                                   call_data.ref_id,\n+                                   call_data.decl_id,\n+                                   call_data.scope);\n+        }\n \n         // walk receiver and args\n         visit::walk_exprs(self, &args);\n@@ -1129,8 +1017,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                    trait_item.span, &*ty, &*expr);\n             }\n             ast::MethodTraitItem(ref sig, ref body) => {\n-                self.process_method(sig, body.as_ref().map(|x| &**x),\n-                                    trait_item.id, trait_item.ident.name, trait_item.span);\n+                self.process_method(sig,\n+                                    body.as_ref().map(|x| &**x),\n+                                    trait_item.id,\n+                                    trait_item.ident.name,\n+                                    trait_item.span);\n             }\n             ast::ConstTraitItem(_, None) |\n             ast::TypeTraitItem(..) => {}\n@@ -1144,8 +1035,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                    impl_item.span, &ty, &expr);\n             }\n             ast::MethodImplItem(ref sig, ref body) => {\n-                self.process_method(sig, Some(body), impl_item.id,\n-                                    impl_item.ident.name, impl_item.span);\n+                self.process_method(sig,\n+                                    Some(body),\n+                                    impl_item.id,\n+                                    impl_item.ident.name,\n+                                    impl_item.span);\n             }\n             ast::TypeImplItem(_) |\n             ast::MacImplItem(_) => {}\n@@ -1191,7 +1085,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 visit::walk_expr(self, ex);\n             }\n             ast::ExprPath(_, ref path) => {\n-                self.process_path(ex.id, path.span, path, None);\n+                self.process_path(ex.id, path, None);\n                 visit::walk_expr(self, ex);\n             }\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n@@ -1287,6 +1181,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n         // This is to get around borrow checking, because we need mut self to call process_path.\n         let mut paths_to_process = vec![];\n+\n         // process collected paths\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n             let def_map = self.tcx.def_map.borrow();\n@@ -1323,11 +1218,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                             def)\n             }\n         }\n+\n         for &(id, ref path, ref_kind) in &paths_to_process {\n-            self.process_path(id, path.span, path, ref_kind);\n+            self.process_path(id, path, ref_kind);\n         }\n         visit::walk_expr_opt(self, &arm.guard);\n-        self.visit_expr(&*arm.body);\n+        self.visit_expr(&arm.body);\n     }\n \n     fn visit_stmt(&mut self, s: &ast::Stmt) {"}, {"sha": "4e0b34b7ef8ac3efe2d06c3800bfb5b39a0a66be", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 229, "deletions": 18, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=736886c84b6ad372929b6531dbe05f5e7f88995b", "patch": "@@ -15,6 +15,8 @@ use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n+use rustc::ast_map::NodeItem;\n+\n use syntax::{attr};\n use syntax::ast::{self, NodeId, DefId};\n use syntax::ast_util;\n@@ -61,6 +63,10 @@ pub enum Data {\n     VariableRefData(VariableRefData),\n     /// Data for a reference to a type or trait.\n     TypeRefData(TypeRefData),\n+    /// Data about a function call.\n+    FunctionCallData(FunctionCallData),\n+    /// Data about a method call.\n+    MethodCallData(MethodCallData),\n }\n \n /// Data for all kinds of functions and methods.\n@@ -120,7 +126,7 @@ pub struct ImplData {\n }\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n-/// will refere to that variables declaration (by ref_id)).\n+/// will refer to that variables declaration (by ref_id)).\n #[derive(Debug)]\n pub struct VariableRefData {\n     pub name: String,\n@@ -137,6 +143,24 @@ pub struct TypeRefData {\n     pub ref_id: DefId,\n }\n \n+/// Data about a function call.\n+#[derive(Debug)]\n+pub struct FunctionCallData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: DefId,\n+}\n+\n+/// Data about a method call.\n+#[derive(Debug)]\n+pub struct MethodCallData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: Option<DefId>,\n+    pub decl_id: Option<DefId>,\n+}\n+\n+\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn new(tcx: &'l ty::ctxt<'tcx>,\n@@ -172,7 +196,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: qualname,\n                     declaration: None,\n                     span: sub_span.unwrap(),\n-                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n+                    scope: self.enclosing_scope(item.id),\n                 })\n             }\n             ast::ItemStatic(ref typ, mt, ref expr) => {\n@@ -191,7 +215,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n+                    scope: self.enclosing_scope(item.id),\n                     value: value,\n                     type_value: ty_to_string(&typ),\n                 })\n@@ -205,7 +229,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n+                    scope: self.enclosing_scope(item.id),\n                     value: self.span_utils.snippet(expr.span),\n                     type_value: ty_to_string(&typ),\n                 })\n@@ -223,7 +247,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n+                    scope: self.enclosing_scope(item.id),\n                     filename: filename,\n                 })\n             },\n@@ -237,14 +261,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     value: val,\n                     span: sub_span.unwrap(),\n                     qualname: enum_name,\n-                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n+                    scope: self.enclosing_scope(item.id),\n                 })\n             },\n             ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n                 let mut type_data = None;\n                 let sub_span;\n \n-                let parent = self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0);\n+                let parent = self.enclosing_scope(item.id);\n \n                 match typ.node {\n                     // Common case impl for a struct or something basic.\n@@ -281,34 +305,114 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    // FIXME: we ought to be able to get the parent id ourselves, but we can't\n-    // for now.\n-    pub fn get_field_data(&self, field: &ast::StructField, parent: NodeId) -> Option<Data> {\n+    pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<VariableData> {\n         match field.node.kind {\n             ast::NamedField(ident, _) => {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"::{}::{}\",\n-                                       self.tcx.map.path_to_string(parent),\n+                                       self.tcx.map.path_to_string(scope),\n                                        name);\n                 let typ = self.tcx.node_types().get(&field.node.id).unwrap()\n                                                .to_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n-                Some(Data::VariableData(VariableData {\n+                Some(VariableData {\n                     id: field.node.id,\n                     name: get_ident(ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: parent,\n+                    scope: scope,\n                     value: \"\".to_owned(),\n                     type_value: typ,\n-                }))\n+                })\n             },\n             _ => None,\n         }\n     }\n \n-    // FIXME: we ought to be able to get the parent id ourselves, but we can't\n-    // for now.\n+    // FIXME would be nice to take a MethodItem here, but the ast provides both\n+    // trait and impl flavours, so the caller must do the disassembly.\n+    pub fn get_method_data(&self,\n+                           id: ast::NodeId,\n+                           name: ast::Name,\n+                           span: Span) -> FunctionData {\n+        // The qualname for a method is the trait name or name of the struct in an impl in\n+        // which the method is declared in, followed by the method's name.\n+        let qualname = match self.tcx.impl_of_method(ast_util::local_def(id)) {\n+            Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n+                NodeItem(item) => {\n+                    match item.node {\n+                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n+                            let mut result = String::from(\"<\");\n+                            result.push_str(&ty_to_string(&**ty));\n+\n+                            match self.tcx.trait_of_item(ast_util::local_def(id)) {\n+                                Some(def_id) => {\n+                                    result.push_str(\" as \");\n+                                    result.push_str(\n+                                        &self.tcx.item_path_str(def_id));\n+                                },\n+                                None => {}\n+                            }\n+                            result.push_str(\">\");\n+                            result\n+                        }\n+                        _ => {\n+                            self.tcx.sess.span_bug(span,\n+                                &format!(\"Container {} for method {} not an impl?\",\n+                                         impl_id.node, id));\n+                        },\n+                    }\n+                },\n+                _ => {\n+                    self.tcx.sess.span_bug(span,\n+                        &format!(\"Container {} for method {} is not a node item {:?}\",\n+                                 impl_id.node, id, self.tcx.map.get(impl_id.node)));\n+                },\n+            },\n+            None => match self.tcx.trait_of_item(ast_util::local_def(id)) {\n+                Some(def_id) => {\n+                    match self.tcx.map.get(def_id.node) {\n+                        NodeItem(_) => {\n+                            format!(\"::{}\", self.tcx.item_path_str(def_id))\n+                        }\n+                        _ => {\n+                            self.tcx.sess.span_bug(span,\n+                                &format!(\"Could not find container {} for method {}\",\n+                                         def_id.node, id));\n+                        }\n+                    }\n+                },\n+                None => {\n+                    self.tcx.sess.span_bug(span,\n+                        &format!(\"Could not find container for method {}\", id));\n+                },\n+            },\n+        };\n+\n+        let qualname = format!(\"{}::{}\", qualname, &token::get_name(name));\n+\n+        let decl_id = self.tcx.trait_item_of_item(ast_util::local_def(id))\n+            .and_then(|new_id| {\n+                let def_id = new_id.def_id();\n+                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n+                    Some(def_id)\n+                } else {\n+                    None\n+                }\n+            });\n+\n+        let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n+\n+        FunctionData {\n+            id: id,\n+            name: token::get_name(name).to_string(),\n+            qualname: qualname,\n+            declaration: decl_id,\n+            span: sub_span.unwrap(),\n+            scope: self.enclosing_scope(id),\n+        }\n+    }\n+\n     pub fn get_trait_ref_data(&self,\n                               trait_ref: &ast::TraitRef,\n                               parent: NodeId)\n@@ -337,7 +441,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 return Some(Data::VariableRefData(VariableRefData {\n                                     name: get_ident(ident.node).to_string(),\n                                     span: sub_span.unwrap(),\n-                                    scope: self.tcx.map.get_enclosing_scope(expr.id).unwrap_or(0),\n+                                    scope: self.enclosing_scope(expr.id),\n                                     ref_id: f.id,\n                                 }));\n                             }\n@@ -360,7 +464,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         Some(Data::TypeRefData(TypeRefData {\n                             span: sub_span.unwrap(),\n-                            scope: self.tcx.map.get_enclosing_scope(expr.id).unwrap_or(0),\n+                            scope: self.enclosing_scope(expr.id),\n                             ref_id: def_id,\n                         }))\n                     }\n@@ -372,13 +476,116 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n+            ast::ExprMethodCall(..) => {\n+                let method_call = ty::MethodCall::expr(expr.id);\n+                let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n+                    ty::ImplContainer(_) => (Some(method_id), None),\n+                    ty::TraitContainer(_) => (None, Some(method_id))\n+                };\n+                let sub_span = self.span_utils.sub_span_for_meth_name(expr.span);\n+                let parent = self.enclosing_scope(expr.id);\n+                Some(Data::MethodCallData(MethodCallData {\n+                    span: sub_span.unwrap(),\n+                    scope: parent,\n+                    ref_id: def_id,\n+                    decl_id: decl_id,\n+                }))\n+            }\n+            ast::ExprPath(_, ref path) => {\n+                Some(self.get_path_data(expr.id, path))\n+            }\n             _ => {\n                 // FIXME\n                 unimplemented!();\n             }\n         }\n     }\n \n+    pub fn get_path_data(&self,\n+                         id: NodeId,\n+                         path: &ast::Path)\n+                         -> Data {\n+        let def_map = self.tcx.def_map.borrow();\n+        if !def_map.contains_key(&id) {\n+            self.tcx.sess.span_bug(path.span,\n+                                   &format!(\"def_map has no key for {} in visit_expr\", id));\n+        }\n+        let def = def_map.get(&id).unwrap().full_def();\n+        let sub_span = self.span_utils.span_for_last_ident(path.span);\n+        match def {\n+            def::DefUpvar(..) |\n+            def::DefLocal(..) |\n+            def::DefStatic(..) |\n+            def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n+            def::DefVariant(..) => {\n+                Data::VariableRefData(VariableRefData {\n+                    name: self.span_utils.snippet(sub_span.unwrap()),\n+                    span: sub_span.unwrap(),\n+                    scope: self.enclosing_scope(id),\n+                    ref_id: def.def_id(),\n+                })\n+            }\n+            def::DefStruct(def_id) | def::DefTy(def_id, _) => {\n+                Data::TypeRefData(TypeRefData {\n+                    span: sub_span.unwrap(),\n+                    ref_id: def_id,\n+                    scope: self.enclosing_scope(id),\n+                })\n+            }\n+            def::DefMethod(decl_id, provenence) => {\n+                let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n+                let def_id = if decl_id.krate == ast::LOCAL_CRATE {\n+                    let ti = self.tcx.impl_or_trait_item(decl_id);\n+                    match provenence {\n+                        def::FromTrait(def_id) => {\n+                            Some(self.tcx.trait_items(def_id)\n+                                    .iter()\n+                                    .find(|mr| {\n+                                        mr.name() == ti.name()\n+                                    })\n+                                    .unwrap()\n+                                    .def_id())\n+                        }\n+                        def::FromImpl(def_id) => {\n+                            let impl_items = self.tcx.impl_items.borrow();\n+                            Some(impl_items.get(&def_id)\n+                                           .unwrap()\n+                                           .iter()\n+                                           .find(|mr| {\n+                                                self.tcx.impl_or_trait_item(mr.def_id()).name()\n+                                                    == ti.name()\n+                                            })\n+                                           .unwrap()\n+                                           .def_id())\n+                        }\n+                    }\n+                } else {\n+                    None\n+                };\n+                Data::MethodCallData(MethodCallData {\n+                    span: sub_span.unwrap(),\n+                    scope: self.enclosing_scope(id),\n+                    ref_id: def_id,\n+                    decl_id: Some(decl_id),\n+                })\n+            },\n+            def::DefFn(def_id, _) => {\n+                Data::FunctionCallData(FunctionCallData {\n+                    ref_id: def_id,\n+                    span: sub_span.unwrap(),\n+                    scope: self.enclosing_scope(id),\n+                })\n+            }\n+            _ => self.tcx.sess.span_bug(path.span,\n+                                        &format!(\"Unexpected def kind while looking \\\n+                                                  up path in `{}`: `{:?}`\",\n+                                                 self.span_utils.snippet(path.span),\n+                                                 def)),\n+        }\n+    }\n+\n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n                               struct_id: DefId,\n@@ -420,6 +627,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n+    #[inline]\n+    fn enclosing_scope(&self, id: NodeId) -> NodeId {\n+        self.tcx.map.get_enclosing_scope(id).unwrap_or(0)\n+    }\n }\n \n // An AST visitor for collecting paths from patterns."}, {"sha": "53befc092da88f363d9e10b91fa8a4d1a48f36d7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=736886c84b6ad372929b6531dbe05f5e7f88995b", "patch": "@@ -60,14 +60,14 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             };\n \n             // Keep going, outside-in.\n-            //\n             let fully_expanded = fld.fold_expr(expanded_expr);\n+            let span = fld.new_span(span);\n             fld.cx.bt_pop();\n \n             fully_expanded.map(|e| ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n                 node: e.node,\n-                span: fld.new_span(span),\n+                span: span,\n             })\n         }\n \n@@ -367,7 +367,8 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n /// of expansion and the mark which must be applied to the result.\n /// Our current interface doesn't allow us to apply the mark to the\n /// result until after calling make_expr, make_items, etc.\n-fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n+fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n+                             span: codemap::Span,\n                              parse_thunk: F,\n                              mark_thunk: G,\n                              fld: &mut MacroExpander)"}, {"sha": "81ae607fea250cbe09f9b4b17bce90d552b4f057", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=736886c84b6ad372929b6531dbe05f5e7f88995b", "patch": "@@ -1566,12 +1566,13 @@ impl<'a> Parser<'a> {\n     // Assumes that the leading `<` has been parsed already.\n     pub fn parse_qualified_path(&mut self, mode: PathParsingMode)\n                                 -> PResult<(QSelf, ast::Path)> {\n+        let span = self.last_span;\n         let self_type = try!(self.parse_ty_sum());\n         let mut path = if try!(self.eat_keyword(keywords::As)) {\n             try!(self.parse_path(LifetimeAndTypesWithoutColons))\n         } else {\n             ast::Path {\n-                span: self.span,\n+                span: span,\n                 global: false,\n                 segments: vec![]\n             }\n@@ -1598,9 +1599,6 @@ impl<'a> Parser<'a> {\n         };\n         path.segments.extend(segments);\n \n-        if path.segments.len() == 1 {\n-            path.span.lo = self.last_span.lo;\n-        }\n         path.span.hi = self.last_span.hi;\n \n         Ok((qself, path))"}, {"sha": "4981ea475d3a8a595709b2902f7df19e0da1a8d8", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736886c84b6ad372929b6531dbe05f5e7f88995b/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=736886c84b6ad372929b6531dbe05f5e7f88995b", "patch": "@@ -364,3 +364,18 @@ impl<'a> Pattern<'a> for CharEqPattern {\n }\n \n struct CharSearcher<'a>(<CharEqPattern as Pattern<'a>>::Searcher);\n+\n+pub trait Error {\n+}\n+\n+impl Error + 'static {\n+    pub fn is<T: Error + 'static>(&self) -> bool {\n+        panic!()\n+    }\n+}\n+\n+impl Error + 'static + Send {\n+    pub fn is<T: Error + 'static>(&self) -> bool {\n+        <Error + 'static>::is::<T>(self)\n+    }\n+}"}]}