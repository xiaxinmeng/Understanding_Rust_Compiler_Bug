{"sha": "2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNTQxNmQ2NjI3MjRiOGU4YmE2OGFlYjQwNjlhYTM3ZTdhNDA2ZDU=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-19T21:14:34Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-23T14:11:19Z"}, "message": "Rustup to *1.10.0-nightly (9c6904ca1 2016-05-18)*", "tree": {"sha": "4fe5e580b49f4e698657db0808282d90fb158e86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fe5e580b49f4e698657db0808282d90fb158e86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXQw+IAAoJEF5CfHlMukXoJsUQAIbJgOMCSJMakTJVPTonP11V\n7leKzElLXKoBGTcsKXNdl0/5/bK5iI2KhWVi6gCI5AqvQdc71AvqjXlWEexkEUvB\n/r17/jJf3+eNddB2zpTX5OxshlTqxmedwbKMMTOGz5viAtSUIjpkTbbTj/6roHAu\nh9Rt66+Mp4tX6vEdcyV+MtQKn0CELGpQFe9mvcWP3B3EIn5oJNXp6nZYq8jOisPV\nnD0sV9pK4yYFe3pHTLLJOzND7L/LumEYbC62qkKe1JH5cCM3w62Wa5nYYpY9QrbM\nIlSgEwPWGQt822Z+xJcJHu7zq+IdLbOl/1zcLLlyAfqvV2F/J6XQF1Zk/nkc9nnY\nSuQOlBaksgUApkzeW1SUGgYzYhKEZyVapkvhMcKCi/UsfUVegHsqmUdjADIPigC5\nxl/TSzNWFOkLAP0J7Cqa6th6CpzApik2AuCLfqnaACnTe7R4CGA06GAo3G09o3pK\nEl/vf/aTa8vEz2FCsuybEJPYsLCWQmr/ymJnX7O1r7yUBboCQiO0VG6PNzsNGfW+\nFAigawAmQDMbpt9NiZbv3H2+RJ+h1XbVSnwJJqAP5k6R2A+MHAIVzq7zYujxeBpR\nBrGWF7jf+hmF0KxYKgSCdqnf17/DmcsY3cXgDojUZv0FBQm+CcOFNGM+iHf57PEG\nPK94iryDF+ZN/Y05wNZI\n=9Avg\n-----END PGP SIGNATURE-----", "payload": "tree 4fe5e580b49f4e698657db0808282d90fb158e86\nparent 973ae82d72368401c237b0e8f62012c8ac28df70\nauthor mcarton <cartonmartin+git@gmail.com> 1463692474 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1464012679 +0200\n\nRustup to *1.10.0-nightly (9c6904ca1 2016-05-18)*\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "html_url": "https://github.com/rust-lang/rust/commit/2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "973ae82d72368401c237b0e8f62012c8ac28df70", "url": "https://api.github.com/repos/rust-lang/rust/commits/973ae82d72368401c237b0e8f62012c8ac28df70", "html_url": "https://github.com/rust-lang/rust/commit/973ae82d72368401c237b0e8f62012c8ac28df70"}], "stats": {"total": 172, "additions": 93, "deletions": 79}, "files": [{"sha": "6843afb4ede6ed99bf13907c89a83a8bba3187e8", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -161,7 +161,7 @@ name\n [unused_label](https://github.com/Manishearth/rust-clippy/wiki#unused_label)                                         | warn    | unused label\n [unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                                 | warn    | unused lifetimes in function definitions\n [use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                               | allow   | use `Debug`-based formatting\n-[used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)                   | warn    | using a binding which is prefixed with an underscore\n+[used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)                   | allow   | using a binding which is prefixed with an underscore\n [useless_format](https://github.com/Manishearth/rust-clippy/wiki#useless_format)                                     | warn    | useless use of `format!`\n [useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                               | warn    | transmutes that have the same to and from types\n [useless_vec](https://github.com/Manishearth/rust-clippy/wiki#useless_vec)                                           | warn    | useless `vec!`"}, {"sha": "5cb84f62651b29d042e6a306268fc5259a97a80e", "filename": "src/blacklisted_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblacklisted_name.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -35,11 +35,11 @@ impl LintPass for BlackListedName {\n impl LateLintPass for BlackListedName {\n     fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n         if let PatKind::Ident(_, ref ident, _) = pat.node {\n-            if self.blacklist.iter().any(|s| s == &*ident.node.name.as_str()) {\n+            if self.blacklist.iter().any(|s| s == &*ident.node.as_str()) {\n                 span_lint(cx,\n                           BLACKLISTED_NAME,\n                           pat.span,\n-                          &format!(\"use of a blacklisted/placeholder name `{}`\", ident.node.name));\n+                          &format!(\"use of a blacklisted/placeholder name `{}`\", ident.node));\n             }\n         }\n     }"}, {"sha": "4344ba461dd3bcc9f5ee361daa861f0ed9c67d1d", "filename": "src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -193,7 +193,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                 }\n             }\n             PatKind::Ident(_, ref ident, ref as_pat) => {\n-                if let Entry::Vacant(v) = map.entry(ident.node.name.as_str()) {\n+                if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n                     v.insert(cx.tcx.pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {"}, {"sha": "f73b6cfed2d747b07fa53c143c86800714d01c19", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -77,7 +77,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                                 // If it's a proper path, it can't be a local variable\n                                 return;\n                             }\n-                            if p.segments[0].identifier != ident.node {\n+                            if p.segments[0].name != ident.node {\n                                 // The two idents should be the same\n                                 return;\n                             }"}, {"sha": "888abbc92c5e87b3b05b5e4fcf90a77fc6454928", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -411,6 +411,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::WRONG_PUB_SELF_CONVENTION,\n+        misc::USED_UNDERSCORE_BINDING,\n         mut_mut::MUT_MUT,\n         mutex_atomic::MUTEX_INTEGER,\n         non_expressive_names::SIMILAR_NAMES,\n@@ -505,7 +506,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::MODULO_ONE,\n         misc::REDUNDANT_PATTERN,\n         misc::TOPLEVEL_REF_ARG,\n-        misc::USED_UNDERSCORE_BINDING,\n         misc_early::DUPLICATE_UNDERSCORE_ARGUMENT,\n         misc_early::REDUNDANT_CLOSURE_CALL,\n         misc_early::UNNEEDED_FIELD_PATTERN,"}, {"sha": "061b8efaa64d5b11c2e50fcb7b6c1487740dfefa", "filename": "src/loops.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -286,7 +286,7 @@ impl LateLintPass for LoopsPass {\n                 if let Some(lhs_constructor) = path.segments.last() {\n                     if method_name.node.as_str() == \"next\" &&\n                        match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                       lhs_constructor.identifier.name.as_str() == \"Some\" &&\n+                       lhs_constructor.name.as_str() == \"Some\" &&\n                        !is_iterator_used_after_while_let(cx, iter_expr) {\n                         let iterator = snippet(cx, method_args[0].span, \"_\");\n                         let loop_var = snippet(cx, pat_args[0].span, \"_\");\n@@ -333,7 +333,7 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n         if let PatKind::Ident(_, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx: cx,\n-                var: ident.node.name,\n+                var: ident.node,\n                 indexed: HashMap::new(),\n                 nonindex: false,\n             };\n@@ -378,9 +378,9 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                               expr.span,\n                               &format!(\"the loop variable `{}` is used to index `{}`. Consider using `for ({}, \\\n                                         item) in {}.iter().enumerate(){}{}` or similar iterators\",\n-                                       ident.node.name,\n+                                       ident.node,\n                                        indexed,\n-                                       ident.node.name,\n+                                       ident.node,\n                                        indexed,\n                                        take,\n                                        skip));\n@@ -396,7 +396,7 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                               expr.span,\n                               &format!(\"the loop variable `{}` is only used to index `{}`. \\\n                                         Consider using `for item in {}` or similar iterators\",\n-                                       ident.node.name,\n+                                       ident.node,\n                                        indexed,\n                                        repl));\n                 }\n@@ -412,7 +412,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n         method.node.as_str() == \"len\",\n         let ExprPath(_, ref path) = len_args[0].node,\n         path.segments.len() == 1,\n-        &path.segments[0].identifier.name == var\n+        &path.segments[0].name == var\n     ], {\n         return true;\n     }}\n@@ -613,7 +613,7 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Ident(_, ident, None) if ident.node.name.as_str().starts_with('_') => {\n+        PatKind::Ident(_, ident, None) if ident.node.as_str().starts_with('_') => {\n             let mut visitor = UsedVisitor {\n                 var: ident.node,\n                 used: false,\n@@ -626,14 +626,14 @@ fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n }\n \n struct UsedVisitor {\n-    var: Ident, // var to look for\n+    var: ast::Name, // var to look for\n     used: bool, // has the var been used otherwise?\n }\n \n impl<'a> Visitor<'a> for UsedVisitor {\n     fn visit_expr(&mut self, expr: &Expr) {\n         if let ExprPath(None, ref path) = expr.node {\n-            if path.segments.len() == 1 && path.segments[0].identifier == self.var {\n+            if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 self.used = true;\n                 return;\n             }\n@@ -653,7 +653,7 @@ struct VarVisitor<'v, 't: 'v> {\n impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n     fn visit_expr(&mut self, expr: &'v Expr) {\n         if let ExprPath(None, ref path) = expr.node {\n-            if path.segments.len() == 1 && path.segments[0].identifier.name == self.var {\n+            if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 // we are referencing our variable! now check if it's as an index\n                 if_let_chain! {\n                     [\n@@ -667,11 +667,11 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n                             match def.base_def {\n                                 Def::Local(..) | Def::Upvar(..) => {\n                                     let extent = self.cx.tcx.region_maps.var_scope(def.base_def.var_id());\n-                                    self.indexed.insert(seqvar.segments[0].identifier.name, Some(extent));\n+                                    self.indexed.insert(seqvar.segments[0].name, Some(extent));\n                                     return;  // no need to walk further\n                                 }\n                                 Def::Static(..) | Def::Const(..) => {\n-                                    self.indexed.insert(seqvar.segments[0].identifier.name, None);\n+                                    self.indexed.insert(seqvar.segments[0].name, None);\n                                     return;  // no need to walk further\n                                 }\n                                 _ => (),\n@@ -885,7 +885,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         if let DeclLocal(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n                 if let PatKind::Ident(_, ref ident, _) = local.pat.node {\n-                    self.name = Some(ident.node.name);\n+                    self.name = Some(ident.node);\n \n                     self.state = if let Some(ref init) = local.init {\n                         if is_integer_literal(init, 0) {"}, {"sha": "4ad232759cfac5f3b6a3fa73be084a4c1b16e4bd", "filename": "src/map_clone.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n+use syntax::ast;\n use utils::{is_adjusted, match_path, match_trait_method, match_type, paths, snippet,\n             span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n \n@@ -52,7 +53,7 @@ impl LateLintPass for MapClonePass {\n                                     if clone_call.node.as_str() == \"clone\" &&\n                                         clone_args.len() == 1 &&\n                                         match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_ident(&clone_args[0], arg_ident)\n+                                        expr_eq_name(&clone_args[0], arg_ident)\n                                     {\n                                         span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                             \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -82,11 +83,11 @@ impl LateLintPass for MapClonePass {\n     }\n }\n \n-fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n+fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n         ExprPath(None, ref path) => {\n             let arg_segment = [PathSegment {\n-                                   identifier: id,\n+                                   name: id,\n                                    parameters: PathParameters::none(),\n                                }];\n             !path.global && path.segments[..] == arg_segment\n@@ -105,18 +106,18 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n     }\n }\n \n-fn get_arg_name(pat: &Pat) -> Option<Ident> {\n+fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n     match pat.node {\n-        PatKind::Ident(_, ident, None) => Some(ident.node),\n+        PatKind::Ident(_, name, None) => Some(name.node),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n         _ => None,\n     }\n }\n \n-fn only_derefs(cx: &LateContext, expr: &Expr, id: Ident) -> bool {\n+fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n         ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n-        _ => expr_eq_ident(expr, id),\n+        _ => expr_eq_name(expr, id),\n     }\n }\n "}, {"sha": "14bc74d467f05d3b0e83d9b63a93a617c7b4980f", "filename": "src/methods.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -473,7 +473,6 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[P<hi\n                 let path: &str = &path.segments\n                                       .last()\n                                       .expect(\"A path must have at least one segment\")\n-                                      .identifier\n                                       .name\n                                       .as_str();\n \n@@ -811,7 +810,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let hir::ExprCall(ref fun, ref arg_char) = other.node,\n         arg_char.len() == 1,\n         let hir::ExprPath(None, ref path) = fun.node,\n-        path.segments.len() == 1 && path.segments[0].identifier.name.as_str() == \"Some\"\n+        path.segments.len() == 1 && path.segments[0].name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tcx.expr_ty_adjusted(&args[0][0]));\n "}, {"sha": "3ab7823e50d2c6568eed9daa9c250f304f90cbf9", "filename": "src/misc.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -8,8 +8,10 @@ use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use syntax::ptr::P;\n-use utils::{get_item_name, match_path, snippet, get_parent_expr, span_lint};\n-use utils::{span_lint_and_then, walk_ptrs_ty, is_integer_literal, implements_trait};\n+use utils::{\n+    get_item_name, get_parent_expr, implements_trait, is_integer_literal, match_path, snippet,\n+    span_lint, span_lint_and_then, walk_ptrs_ty\n+};\n \n /// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`.\n ///\n@@ -118,7 +120,7 @@ impl LateLintPass for CmpNan {\n \n fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n     path.segments.last().map(|seg| {\n-        if seg.identifier.name.as_str() == \"NAN\" {\n+        if seg.name.as_str() == \"NAN\" {\n             span_lint(cx,\n                       CMP_NAN,\n                       span,\n@@ -350,8 +352,8 @@ impl LateLintPass for PatternPass {\n                           REDUNDANT_PATTERN,\n                           pat.span,\n                           &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n-                                   ident.node.name,\n-                                   ident.node.name));\n+                                   ident.node,\n+                                   ident.node));\n             }\n         }\n     }\n@@ -363,15 +365,16 @@ impl LateLintPass for PatternPass {\n /// **Why is this bad?** A single leading underscore is usually used to indicate that a binding\n /// will not be used. Using such a binding breaks this expectation.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** The lint does not work properly with desugaring and macro, it has been\n+/// allowed in the mean time.\n ///\n /// **Example**:\n /// ```\n /// let _x = 0;\n /// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n ///                 // We should rename `_x` to `x`\n /// ```\n-declare_lint!(pub USED_UNDERSCORE_BINDING, Warn,\n+declare_lint!(pub USED_UNDERSCORE_BINDING, Allow,\n               \"using a binding which is prefixed with an underscore\");\n \n #[derive(Copy, Clone)]\n@@ -387,32 +390,42 @@ impl LateLintPass for UsedUnderscoreBinding {\n     #[cfg_attr(rustfmt, rustfmt_skip)]\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if in_attributes_expansion(cx, expr) {\n-    // Don't lint things expanded by #[derive(...)], etc\n+            // Don't lint things expanded by #[derive(...)], etc\n             return;\n         }\n-        let needs_lint = match expr.node {\n+        let binding = match expr.node {\n             ExprPath(_, ref path) => {\n-                let ident = path.segments\n+                let segment = path.segments\n                                 .last()\n                                 .expect(\"path should always have at least one segment\")\n-                                .identifier;\n-                ident.name.as_str().starts_with('_') &&\n-                !ident.name.as_str().starts_with(\"__\") &&\n-                ident.name != ident.unhygienic_name &&\n-                is_used(cx, expr) // not in bang macro\n+                                .name;\n+                if segment.as_str().starts_with('_') &&\n+                   !segment.as_str().starts_with(\"__\") &&\n+                   segment != segment.unhygienize() && // not in bang macro\n+                   is_used(cx, expr) {\n+                    Some(segment.as_str())\n+                } else {\n+                    None\n+                }\n             }\n             ExprField(_, spanned) => {\n                 let name = spanned.node.as_str();\n-                name.starts_with('_') && !name.starts_with(\"__\")\n+                if name.starts_with('_') && !name.starts_with(\"__\") {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n             }\n-            _ => false,\n+            _ => None,\n         };\n-        if needs_lint {\n-            span_lint(cx,\n-                      USED_UNDERSCORE_BINDING,\n-                      expr.span,\n-                      \"used binding which is prefixed with an underscore. A leading underscore signals that a \\\n-                       binding will not be used.\");\n+        if let Some(binding) = binding {\n+            if binding != \"_result\" { // FIXME: #944\n+                span_lint(cx,\n+                          USED_UNDERSCORE_BINDING,\n+                          expr.span,\n+                          &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n+                                    underscore signals that a binding will not be used.\", binding));\n+            }\n         }\n     }\n }\n@@ -431,8 +444,8 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     }\n }\n \n-/// Test whether an expression is in a macro expansion (e.g. something generated by #[derive(...)]\n-/// or the like)\n+/// Test whether an expression is in a macro expansion (e.g. something generated by\n+/// `#[derive(...)`] or the like).\n fn in_attributes_expansion(cx: &LateContext, expr: &Expr) -> bool {\n     cx.sess().codemap().with_expn_info(expr.span.expn_id, |info_opt| {\n         info_opt.map_or(false, |info| {"}, {"sha": "34921bc2c041d5974cade51e7908a1562286ef23", "filename": "src/overflow_check_conditional.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow_check_conditional.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -31,7 +31,7 @@ impl LateLintPass for OverflowCheckConditional {\n         let Expr_::ExprPath(_,ref path1) = ident1.node,\n         let Expr_::ExprPath(_, ref path2) = ident2.node,\n         let Expr_::ExprPath(_, ref path3) = second.node,\n-        (&path1.segments[0]).identifier == (&path3.segments[0]).identifier || (&path2.segments[0]).identifier == (&path3.segments[0]).identifier,\n+        &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n         cx.tcx.expr_ty(ident1).is_integral(),\n         cx.tcx.expr_ty(ident2).is_integral()\n         ], {\n@@ -53,7 +53,7 @@ impl LateLintPass for OverflowCheckConditional {\n         let Expr_::ExprPath(_,ref path1) = ident1.node,\n         let Expr_::ExprPath(_, ref path2) = ident2.node,\n         let Expr_::ExprPath(_, ref path3) = first.node,\n-        (&path1.segments[0]).identifier == (&path3.segments[0]).identifier || (&path2.segments[0]).identifier == (&path3.segments[0]).identifier,\n+        &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n         cx.tcx.expr_ty(ident1).is_integral(),\n         cx.tcx.expr_ty(ident2).is_integral()\n         ], {"}, {"sha": "cf7de04cb6fc07b9cf08acde9ec6d77a163a3b5e", "filename": "src/shadow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -66,7 +66,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, block: &Block) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n         if let PatKind::Ident(_, ident, _) = arg.pat.node {\n-            bindings.push((ident.node.unhygienic_name, ident.span))\n+            bindings.push((ident.node.unhygienize(), ident.span))\n         }\n     }\n     check_block(cx, block, &mut bindings);\n@@ -120,7 +120,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n     // TODO: match more stuff / destructuring\n     match pat.node {\n         PatKind::Ident(_, ref ident, ref inner) => {\n-            let name = ident.node.unhygienic_name;\n+            let name = ident.node.unhygienize();\n             if is_binding(cx, pat) {\n                 let mut new_binding = true;\n                 for tup in bindings.iter_mut() {\n@@ -326,7 +326,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.global && path.segments.len() == 1 && path.segments[0].identifier.unhygienic_name == name\n+    !path.global && path.segments.len() == 1 && path.segments[0].name.unhygienize() == name\n }\n \n struct ContainsSelf {\n@@ -335,8 +335,8 @@ struct ContainsSelf {\n }\n \n impl<'v> Visitor<'v> for ContainsSelf {\n-    fn visit_ident(&mut self, _: Span, ident: Ident) {\n-        if self.name == ident.unhygienic_name {\n+    fn visit_name(&mut self, _: Span, name: Name) {\n+        if self.name == name.unhygienize() {\n             self.result = true;\n         }\n     }"}, {"sha": "c5572181395a44bd7aaf19b808497975d8f24af1", "filename": "src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fswap.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -75,7 +75,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             let ExprPath(None, ref rhs2) = rhs2.node,\n             rhs2.segments.len() == 1,\n \n-            tmp_name.node.name.as_str() == rhs2.segments[0].identifier.name.as_str(),\n+            tmp_name.node.as_str() == rhs2.segments[0].name.as_str(),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2)\n         ], {"}, {"sha": "3de6719c546ac44263bdf76d33c120e110ecd896", "filename": "src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsafe_removed_from_name.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -41,7 +41,7 @@ impl LateLintPass for UnsafeNameRemoval {\n                         path.segments\n                             .last()\n                             .expect(\"use paths cannot be empty\")\n-                            .identifier.name,\n+                            .name,\n                         *name,\n                         cx, &item.span\n                         );"}, {"sha": "d408f16a3711e6e41778dde593c95c48e9bdfafd", "filename": "src/unused_label.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funused_label.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -65,10 +65,10 @@ impl<'v> Visitor<'v> for UnusedLabelVisitor {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprBreak(Some(label)) | hir::ExprAgain(Some(label)) => {\n-                self.labels.remove(&label.node.name.as_str());\n+                self.labels.remove(&label.node.as_str());\n             }\n             hir::ExprLoop(_, Some(label)) | hir::ExprWhile(_, _, Some(label)) => {\n-                self.labels.insert(label.name.as_str(), expr.span);\n+                self.labels.insert(label.as_str(), expr.span);\n             }\n             _ => (),\n         }"}, {"sha": "0f0a7312ee4a7a101058274a8479208ad9542ea4", "filename": "src/utils/hir.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n         match (&left.node, &right.node) {\n             (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n+            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str()),\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n@@ -80,7 +80,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                     l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                 })\n             }\n-            (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n+            (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str()),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n@@ -95,7 +95,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             }\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll), &ExprLoop(ref rb, ref rl)) => {\n-                self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+                self.eq_block(lb, rb) && both(ll, rl, |l, r| l.as_str() == r.as_str())\n             }\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) &&\n@@ -124,7 +124,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprVec(ref l), &ExprVec(ref r)) => self.eq_exprs(l, r),\n             (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n-                self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+                self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.as_str() == r.as_str())\n             }\n             _ => false,\n         }\n@@ -146,7 +146,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 self.eq_path(lp, rp) && both(la, ra, |l, r| over(l, r, |l, r| self.eq_pat(l, r)))\n             }\n             (&PatKind::Ident(ref lb, ref li, ref lp), &PatKind::Ident(ref rb, ref ri, ref rp)) => {\n-                lb == rb && li.node.name.as_str() == ri.node.name.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+                lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::QPath(ref ls, ref lp), &PatKind::QPath(ref rs, ref rp)) => {\n@@ -172,7 +172,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         left.global == right.global &&\n         over(&left.segments,\n              &right.segments,\n-             |l, r| l.identifier.name.as_str() == r.identifier.name.as_str() && l.parameters == r.parameters)\n+             |l, r| l.name.as_str() == r.name.as_str() && l.parameters == r.parameters)\n     }\n \n     fn eq_qself(&self, left: &QSelf, right: &QSelf) -> bool {\n@@ -281,7 +281,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprAgain;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node.name);\n+                    self.hash_name(&i.node);\n                 }\n             }\n             ExprAssign(ref l, ref r) => {\n@@ -313,7 +313,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node.name);\n+                    self.hash_name(&i.node);\n                 }\n             }\n             ExprBox(ref e) => {\n@@ -374,7 +374,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n-                    self.hash_name(&i.name);\n+                    self.hash_name(&i);\n                 }\n             }\n             ExprMatch(ref e, ref arms, ref s) => {\n@@ -468,7 +468,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(cond);\n                 self.hash_block(b);\n                 if let Some(l) = l {\n-                    self.hash_name(&l.name);\n+                    self.hash_name(&l);\n                 }\n             }\n         }\n@@ -487,7 +487,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn hash_path(&mut self, p: &Path) {\n         p.global.hash(&mut self.s);\n         for p in &p.segments {\n-            self.hash_name(&p.identifier.name);\n+            self.hash_name(&p.name);\n         }\n     }\n "}, {"sha": "3ff6167620afa22b927e3892303314dd435a2396", "filename": "src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -200,7 +200,7 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.name.as_str() == *b)\n }\n \n /// Match a `Path` against a slice of segment string literals, e.g."}, {"sha": "c571906c53b8ceaaaf5cc8ad2afbda1030dcd187", "filename": "tests/compile-fail/used_underscore_binding.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5416d662724b8e8ba68aeb4069aa37e7a406d5/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fused_underscore_binding.rs?ref=2a5416d662724b8e8ba68aeb4069aa37e7a406d5", "patch": "@@ -3,15 +3,16 @@\n #![deny(clippy)]\n \n #![allow(blacklisted_name)]\n+#![deny(used_underscore_binding)]\n \n /// Test that we lint if we use a binding with a single leading underscore\n fn prefix_underscore(_foo: u32) -> u32 {\n-    _foo + 1 //~ ERROR used binding which is prefixed with an underscore\n+    _foo + 1 //~ ERROR used binding `_foo` which is prefixed with an underscore\n }\n \n /// Test that we lint even if the use is within a macro expansion\n fn in_macro(_foo: u32) {\n-    println!(\"{}\", _foo); //~ ERROR used binding which is prefixed with an underscore\n+    println!(\"{}\", _foo); //~ ERROR used binding `_foo` which is prefixed with an underscore\n }\n \n // Struct for testing use of fields prefixed with an underscore\n@@ -22,7 +23,7 @@ struct StructFieldTest {\n /// Test that we lint the use of a struct field which is prefixed with an underscore\n fn in_struct_field() {\n     let mut s = StructFieldTest { _underscore_field: 0 };\n-    s._underscore_field += 1; //~ Error used binding which is prefixed with an underscore\n+    s._underscore_field += 1; //~ Error used binding `_underscore_field` which is prefixed with an underscore\n }\n \n /// Test that we do not lint if the underscore is not a prefix"}]}