{"sha": "18cacbabb43f2fd87e20706be852e62aea282257", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Y2FjYmFiYjQzZjJmZDg3ZTIwNzA2YmU4NTJlNjJhZWEyODIyNTc=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-01-26T09:55:54Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-01-26T09:55:54Z"}, "message": "Incorporate review suggestions", "tree": {"sha": "dffc359266c8a2808b762faa7f7f70c43764ae90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dffc359266c8a2808b762faa7f7f70c43764ae90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18cacbabb43f2fd87e20706be852e62aea282257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18cacbabb43f2fd87e20706be852e62aea282257", "html_url": "https://github.com/rust-lang/rust/commit/18cacbabb43f2fd87e20706be852e62aea282257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18cacbabb43f2fd87e20706be852e62aea282257/comments", "author": null, "committer": null, "parents": [{"sha": "5284b95a064280d2ed70e6fabf6eb863689d3848", "url": "https://api.github.com/repos/rust-lang/rust/commits/5284b95a064280d2ed70e6fabf6eb863689d3848", "html_url": "https://github.com/rust-lang/rust/commit/5284b95a064280d2ed70e6fabf6eb863689d3848"}], "stats": {"total": 79, "additions": 44, "deletions": 35}, "files": [{"sha": "4126b78e676b619a839e7987142fb3f9d61b4987", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/18cacbabb43f2fd87e20706be852e62aea282257/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cacbabb43f2fd87e20706be852e62aea282257/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=18cacbabb43f2fd87e20706be852e62aea282257", "patch": "@@ -1148,6 +1148,48 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+    // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n+    // `&str`\n+    fn get_arg_root<'a>(cx: &LateContext<'_, '_>, arg: &'a hir::Expr) -> &'a hir::Expr {\n+        let mut arg_root = arg;\n+        loop {\n+            arg_root = match &arg_root.node {\n+                hir::ExprKind::AddrOf(_, expr) => expr,\n+                hir::ExprKind::MethodCall(method_name, _, call_args) => {\n+                    if call_args.len() == 1\n+                        && (method_name.ident.name == \"as_str\" || method_name.ident.name == \"as_ref\")\n+                        && {\n+                            let arg_type = cx.tables.expr_ty(&call_args[0]);\n+                            let base_type = walk_ptrs_ty(arg_type);\n+                            base_type.sty == ty::Str || match_type(cx, base_type, &paths::STRING)\n+                        }\n+                    {\n+                        &call_args[0]\n+                    } else {\n+                        break;\n+                    }\n+                },\n+                _ => break,\n+            };\n+        }\n+        arg_root\n+    }\n+\n+    // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n+    // converted to string.\n+    fn requires_to_string(cx: &LateContext<'_, '_>, arg: &hir::Expr) -> bool {\n+        let arg_ty = cx.tables.expr_ty(arg);\n+        if match_type(cx, arg_ty, &paths::STRING) {\n+            return false;\n+        }\n+        if let ty::Ref(ty::ReStatic, ty, ..) = arg_ty.sty {\n+            if ty.sty == ty::Str {\n+                return false;\n+            }\n+        };\n+        true\n+    }\n+\n     fn generate_format_arg_snippet(\n         cx: &LateContext<'_, '_>,\n         a: &hir::Expr,\n@@ -1195,29 +1237,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         return;\n     };\n \n-    // Strip off `&`, `as_ref()` and `as_str()` until we're left with either a `String` or `&str`\n-    // which we call `arg_root`.\n-    let mut arg_root = &args[1];\n-    loop {\n-        arg_root = match &arg_root.node {\n-            hir::ExprKind::AddrOf(_, expr) => expr,\n-            hir::ExprKind::MethodCall(method_name, _, call_args) => {\n-                if call_args.len() == 1\n-                    && (method_name.ident.name == \"as_str\" || method_name.ident.name == \"as_ref\")\n-                    && {\n-                        let arg_type = cx.tables.expr_ty(&call_args[0]);\n-                        let base_type = walk_ptrs_ty(arg_type);\n-                        base_type.sty == ty::Str || match_type(cx, base_type, &paths::STRING)\n-                    }\n-                {\n-                    &call_args[0]\n-                } else {\n-                    break;\n-                }\n-            },\n-            _ => break,\n-        };\n-    }\n+    let arg_root = get_arg_root(cx, &args[1]);\n \n     let span_replace_word = method_span.with_hi(expr.span.hi());\n \n@@ -1230,7 +1250,6 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n                 let fmt_spec = &format_args[0];\n                 let fmt_args = &format_args[1];\n \n-                let mut applicability = Applicability::MachineApplicable;\n                 let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n \n                 args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n@@ -1252,18 +1271,8 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         }\n     }\n \n-    // If root_arg is `&'static str` or `String` we can use it directly in the `panic!` call otherwise\n-    // we must use `to_string` to convert it.\n     let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);\n-    let arg_root_ty = cx.tables.expr_ty(arg_root);\n-    let mut requires_conv = !match_type(cx, arg_root_ty, &paths::STRING);\n-    if let ty::Ref(ty::ReStatic, ty, ..) = arg_root_ty.sty {\n-        if ty.sty == ty::Str {\n-            requires_conv = false;\n-        }\n-    };\n-\n-    if requires_conv {\n+    if requires_to_string(cx, arg_root) {\n         arg_root_snippet.to_mut().push_str(\".to_string()\");\n     }\n "}]}