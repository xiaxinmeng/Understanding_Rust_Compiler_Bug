{"sha": "20ca02569ae3e1dc29962e92739fbab632abf241", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwY2EwMjU2OWFlM2UxZGMyOTk2MmU5MjczOWZiYWI2MzJhYmYyNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-06T06:42:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-06T06:42:19Z"}, "message": "Auto merge of #53721 - arielb1:exhaustively-unpun, r=nikomatsakis\n\nfix `is_non_exhaustive` confusion between structs and enums\n\nStructs and enums can both be non-exhaustive, with a very different\nmeaning. This PR splits `is_non_exhaustive` to 2 separate functions - 1\nfor structs, and another for enums, and fixes the places that got the\nusage confused.\n\nFixes #53549.\n\nr? @eddyb", "tree": {"sha": "00d5155617647e0d559f3180c23b5a4e16310011", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00d5155617647e0d559f3180c23b5a4e16310011"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20ca02569ae3e1dc29962e92739fbab632abf241", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20ca02569ae3e1dc29962e92739fbab632abf241", "html_url": "https://github.com/rust-lang/rust/commit/20ca02569ae3e1dc29962e92739fbab632abf241", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20ca02569ae3e1dc29962e92739fbab632abf241/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e5457f3fa6c6e322e05352f0109f2cd511396c", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e5457f3fa6c6e322e05352f0109f2cd511396c", "html_url": "https://github.com/rust-lang/rust/commit/27e5457f3fa6c6e322e05352f0109f2cd511396c"}, {"sha": "ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "html_url": "https://github.com/rust-lang/rust/commit/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593"}], "stats": {"total": 214, "additions": 156, "deletions": 58}, "files": [{"sha": "bb8498cb94d67d7177814bc4b055a941047f1548", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -344,13 +344,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n     }\n }\n \n-impl_stable_hash_for!(struct ty::VariantDef {\n-    did,\n-    name,\n-    discr,\n-    fields,\n-    ctor_kind\n-});\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::VariantFlags {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        std_hash::Hash::hash(self, hasher);\n+    }\n+}\n \n impl_stable_hash_for!(enum ty::VariantDiscr {\n     Explicit(def_id),"}, {"sha": "5e2093d03566af5a4900b191f1de312719195984", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 66, "deletions": 11, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -1692,12 +1692,17 @@ bitflags! {\n         const IS_FUNDAMENTAL      = 1 << 2;\n         const IS_UNION            = 1 << 3;\n         const IS_BOX              = 1 << 4;\n-        /// Indicates whether this abstract data type will be expanded on in future (new\n-        /// fields/variants) and as such, whether downstream crates must match exhaustively on the\n-        /// fields/variants of this data type.\n-        ///\n-        /// See RFC 2008 (<https://github.com/rust-lang/rfcs/pull/2008>).\n-        const IS_NON_EXHAUSTIVE   = 1 << 5;\n+        /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n+        /// (i.e., this flag is never set unless this ADT is an enum).\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE   = 1 << 5;\n+    }\n+}\n+\n+bitflags! {\n+    pub struct VariantFlags: u32 {\n+        const NO_VARIANT_FLAGS        = 0;\n+        /// Indicates whether the field list of this variant is `#[non_exhaustive]`.\n+        const IS_FIELD_LIST_NON_EXHAUSTIVE = 1 << 0;\n     }\n }\n \n@@ -1710,8 +1715,56 @@ pub struct VariantDef {\n     pub discr: VariantDiscr,\n     pub fields: Vec<FieldDef>,\n     pub ctor_kind: CtorKind,\n+    flags: VariantFlags,\n }\n \n+impl<'a, 'gcx, 'tcx> VariantDef {\n+    /// Create a new `VariantDef`.\n+    ///\n+    /// - `did` is the DefId used for the variant - for tuple-structs, it is the constructor DefId,\n+    /// and for everything else, it is the variant DefId.\n+    /// - `attribute_def_id` is the DefId that has the variant's attributes.\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               did: DefId,\n+               name: Name,\n+               discr: VariantDiscr,\n+               fields: Vec<FieldDef>,\n+               adt_kind: AdtKind,\n+               ctor_kind: CtorKind)\n+               -> Self\n+    {\n+        debug!(\"VariantDef::new({:?}, {:?}, {:?}, {:?}, {:?}, {:?})\", did, name, discr, fields,\n+               adt_kind, ctor_kind);\n+        let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n+        if adt_kind == AdtKind::Struct && tcx.has_attr(did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive field list for {:?}\", did);\n+            flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n+        }\n+        VariantDef {\n+            did,\n+            name,\n+            discr,\n+            fields,\n+            ctor_kind,\n+            flags\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn is_field_list_non_exhaustive(&self) -> bool {\n+        self.flags.intersects(VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE)\n+    }\n+}\n+\n+impl_stable_hash_for!(struct VariantDef {\n+    did,\n+    name,\n+    discr,\n+    fields,\n+    ctor_kind,\n+    flags\n+});\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum VariantDiscr {\n     /// Explicit value for this variant, i.e. `X = 123`.\n@@ -1850,7 +1903,7 @@ impl_stable_hash_for!(struct ReprFlags {\n \n \n /// Represents the repr options provided by the user,\n-#[derive(Copy, Clone, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n     pub align: u32,\n@@ -1939,6 +1992,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n            kind: AdtKind,\n            variants: Vec<VariantDef>,\n            repr: ReprOptions) -> Self {\n+        debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1950,8 +2004,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         if Some(did) == tcx.lang_items().owned_box() {\n             flags = flags | AdtFlags::IS_BOX;\n         }\n-        if tcx.has_attr(did, \"non_exhaustive\") {\n-            flags = flags | AdtFlags::IS_NON_EXHAUSTIVE;\n+        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive variant list for {:?}\", did);\n+            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n         }\n         match kind {\n             AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n@@ -1982,8 +2037,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn is_non_exhaustive(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_NON_EXHAUSTIVE)\n+    pub fn is_variant_list_non_exhaustive(&self) -> bool {\n+        self.flags.intersects(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n     }\n \n     /// Returns the kind of the ADT - Struct or Enum."}, {"sha": "9907df7ed02400094a1de14a4e2691184ced1f46", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -542,28 +542,36 @@ impl<'a, 'tcx> CrateMetadata {\n                           self.def_path_table.def_path_hash(item_id))\n     }\n \n-    fn get_variant(&self, item: &Entry, index: DefIndex) -> ty::VariantDef {\n+    fn get_variant(&self,\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   item: &Entry,\n+                   index: DefIndex,\n+                   adt_kind: ty::AdtKind)\n+                   -> ty::VariantDef\n+    {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        ty::VariantDef {\n-            did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(index).as_symbol(),\n-            fields: item.children.decode(self).map(|index| {\n+        ty::VariantDef::new(\n+            tcx,\n+            self.local_def_id(data.struct_ctor.unwrap_or(index)),\n+            self.item_name(index).as_symbol(),\n+            data.discr,\n+            item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n                     ident: Ident::from_interned_str(self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n-            discr: data.discr,\n-            ctor_kind: data.ctor_kind,\n-        }\n+            adt_kind,\n+            data.ctor_kind\n+        )\n     }\n \n     pub fn get_adt_def(&self,\n@@ -584,11 +592,11 @@ impl<'a, 'tcx> CrateMetadata {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n-                    self.get_variant(&self.entry(index), index)\n+                    self.get_variant(tcx, &self.entry(index), index, kind)\n                 })\n                 .collect()\n         } else {\n-            vec![self.get_variant(&item, item_id)]\n+            vec![self.get_variant(tcx, &item, item_id, kind)]\n         };\n \n         tcx.alloc_adt_def(did, kind, variants, repr)"}, {"sha": "0fd43c592c8535dd3bfeae79456e6f7242a63cc9", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -740,7 +740,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         // If the structure is marked as non_exhaustive then lower the visibility\n         // to within the crate.\n-        if adt_def.is_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n+        if adt_def.non_enum_variant().is_field_list_non_exhaustive() &&\n+            ctor_vis == ty::Visibility::Public\n+        {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n "}, {"sha": "d7fbbc88cc16d63e864e93c11e174b5163d852c9", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -381,7 +381,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::Adt(adt_def, ..) => adt_def.is_enum() && adt_def.is_non_exhaustive(),\n+            ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n             _ => false,\n         }\n     }"}, {"sha": "4245136ef213174cf3e16ffb8a8358636fa2d4f4", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -686,7 +686,9 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n                         // visibility to within the crate.\n                         let struct_def_id = self.tcx.hir.get_parent_did(node_id);\n                         let adt_def = self.tcx.adt_def(struct_def_id);\n-                        if adt_def.is_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n+                        if adt_def.non_enum_variant().is_field_list_non_exhaustive()\n+                            && ctor_vis == ty::Visibility::Public\n+                        {\n                             ctor_vis = ty::Visibility::Restricted(\n                                 DefId::local(CRATE_DEF_INDEX));\n                         }"}, {"sha": "2a8ee4bd8df0eeeb9feb5e19bbecb337641271c0", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -950,7 +950,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n \n         // Require `..` if struct has non_exhaustive attribute.\n-        if adt.is_struct() && adt.is_non_exhaustive() && !adt.did.is_local() && !etc {\n+        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n             span_err!(tcx.sess, span, E0638,\n                       \"`..` required with {} marked as non-exhaustive\",\n                       kind_name);"}, {"sha": "a45e5c8ec2a4511da865c1f128e0729ab0899ca3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -3471,7 +3471,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // re-link the regions that EIfEO can erase.\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n-        let (substs, adt_kind, kind_name) = match &adt_ty.sty{\n+        let (substs, adt_kind, kind_name) = match &adt_ty.sty {\n             &ty::Adt(adt, substs) => {\n                 (substs, adt.adt_kind(), adt.variant_descr())\n             }\n@@ -3645,37 +3645,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n-        let (variant, struct_ty) =\n-        if let Some(variant_ty) = self.check_struct_path(qpath, expr.id) {\n-            variant_ty\n-        } else {\n-            self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx.types.err;\n-        };\n+        let (variant, adt_ty) =\n+            if let Some(variant_ty) = self.check_struct_path(qpath, expr.id) {\n+                variant_ty\n+            } else {\n+                self.check_struct_fields_on_error(fields, base_expr);\n+                return self.tcx.types.err;\n+            };\n \n         let path_span = match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.span,\n             hir::QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n         // Prohibit struct expressions when non exhaustive flag is set.\n-        if let ty::Adt(adt, _) = struct_ty.sty {\n-            if !adt.did.is_local() && adt.is_non_exhaustive() {\n-                span_err!(self.tcx.sess, expr.span, E0639,\n-                          \"cannot create non-exhaustive {} using struct expression\",\n-                          adt.variant_descr());\n-            }\n+        let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n+        if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n+            span_err!(self.tcx.sess, expr.span, E0639,\n+                      \"cannot create non-exhaustive {} using struct expression\",\n+                      adt.variant_descr());\n         }\n \n-        let error_happened = self.check_expr_struct_fields(struct_ty, expected, expr.id, path_span,\n+        let error_happened = self.check_expr_struct_fields(adt_ty, expected, expr.id, path_span,\n                                                            variant, fields, base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             // If check_expr_struct_fields hit an error, do not attempt to populate\n             // the fields with the base_expr. This could cause us to hit errors later\n             // when certain fields are assumed to exist that in fact do not.\n             if !error_happened {\n-                self.check_expr_has_type_or_error(base_expr, struct_ty);\n-                match struct_ty.sty {\n+                self.check_expr_has_type_or_error(base_expr, adt_ty);\n+                match adt_ty.sty {\n                     ty::Adt(adt, substs) if adt.is_struct() => {\n                         let fru_field_types = adt.non_enum_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n@@ -3693,8 +3692,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n-        self.require_type_is_sized(struct_ty, expr.span, traits::StructInitializerSized);\n-        struct_ty\n+        self.require_type_is_sized(adt_ty, expr.span, traits::StructInitializerSized);\n+        adt_ty\n     }\n \n "}, {"sha": "decd24e87f365d61415f70410ebb5d05da384163", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -549,12 +549,13 @@ fn convert_enum_variant_types<'a, 'tcx>(\n     }\n }\n \n-fn convert_struct_variant<'a, 'tcx>(\n+fn convert_variant<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     did: DefId,\n     name: ast::Name,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData,\n+    adt_kind: ty::AdtKind\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = FxHashMap();\n     let node_id = tcx.hir.as_local_node_id(did).unwrap();\n@@ -585,13 +586,13 @@ fn convert_struct_variant<'a, 'tcx>(\n             }\n         })\n         .collect();\n-    ty::VariantDef {\n+    ty::VariantDef::new(tcx,\n         did,\n         name,\n         discr,\n         fields,\n-        ctor_kind: CtorKind::from_hir(def),\n-    }\n+        adt_kind,\n+        CtorKind::from_hir(def))\n }\n \n fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n@@ -621,7 +622,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n                         };\n                         distance_from_explicit += 1;\n \n-                        convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n+                        convert_variant(tcx, did, v.node.name, discr, &v.node.data, AdtKind::Enum)\n                     })\n                     .collect(),\n             )\n@@ -635,23 +636,25 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n             };\n             (\n                 AdtKind::Struct,\n-                vec![convert_struct_variant(\n+                vec![convert_variant(\n                     tcx,\n                     ctor_id.unwrap_or(def_id),\n                     item.name,\n                     ty::VariantDiscr::Relative(0),\n                     def,\n+                    AdtKind::Struct\n                 )],\n             )\n         }\n         ItemKind::Union(ref def, _) => (\n             AdtKind::Union,\n-            vec![convert_struct_variant(\n+            vec![convert_variant(\n                 tcx,\n                 def_id,\n                 item.name,\n                 ty::VariantDiscr::Relative(0),\n                 def,\n+                AdtKind::Union\n             )],\n         ),\n         _ => bug!(),"}, {"sha": "83fb24cda088cd1bdb7b600a6bcdfde6c9d67391", "filename": "src/test/run-pass/rfc-2008-non-exhaustive/enums.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Ftest%2Frun-pass%2Frfc-2008-non-exhaustive%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ca02569ae3e1dc29962e92739fbab632abf241/src%2Ftest%2Frun-pass%2Frfc-2008-non-exhaustive%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2008-non-exhaustive%2Fenums.rs?ref=20ca02569ae3e1dc29962e92739fbab632abf241", "patch": "@@ -30,4 +30,33 @@ fn main() {\n     match enum_unit {\n         _ => \"no error with only wildcard\"\n     };\n+\n+\n+    // issue #53549 - check that variant constructors can still be called normally.\n+\n+    match NonExhaustiveEnum::Unit {\n+        NonExhaustiveEnum::Unit => {},\n+        _ => {}\n+    };\n+\n+    match NonExhaustiveEnum::Tuple(2) {\n+        NonExhaustiveEnum::Tuple(2) => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Unit {}) {\n+        NonExhaustiveEnum::Unit {} => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Tuple { 0: 2 }) {\n+        NonExhaustiveEnum::Tuple { 0: 2 } => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Struct { field: 2 }) {\n+        NonExhaustiveEnum::Struct { field: 2 } => {},\n+        _ => {}\n+    };\n+\n }"}]}