{"sha": "8ae5eadb22f378b6b1d277c4e7e978639b47838c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZTVlYWRiMjJmMzc4YjZiMWQyNzdjNGU3ZTk3ODYzOWI0NzgzOGM=", "commit": {"author": {"name": "Dylan McKay", "email": "me@dylanmckay.io", "date": "2020-06-11T05:52:09Z"}, "committer": {"name": "Dylan McKay", "email": "me@dylanmckay.io", "date": "2020-07-21T17:16:22Z"}, "message": "[AVR] Correctly set the pointer address space when constructing pointers to functions\n\nThis patch extends the existing `type_i8p` method so that it requires an\nexplicit address space to be specified. Before this patch, the\n`type_i8p` method implcitily assumed the default address space, which is\nnot a safe transformation on all targets, namely AVR.\n\nThe Rust compiler already has support for tracking the \"instruction\naddress space\" on a per-target basis. This patch extends the code\ngeneration routines so that an address space must always be specified.\n\nIn my estimation, around 15% of the callers of `type_i8p` produced\ninvalid code on AVR due to the loss of address space prior to LLVM final\ncode generation. This would lead to unavoidable assertion errors\nrelating to invalid bitcasts.\n\nWith this patch, the address space is always either 1) explicitly set to\nthe instruction address space because the logic is dealing with functions\nwhich must be placed there, or 2) explicitly set to the default address\nspace 0 because the logic can only operate on data space pointers and thus\nwe keep the existing semantics of assuming the default, \"data\" address space.", "tree": {"sha": "da12436d59779f31363a183d9ddfb2d341a7de37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da12436d59779f31363a183d9ddfb2d341a7de37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ae5eadb22f378b6b1d277c4e7e978639b47838c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae5eadb22f378b6b1d277c4e7e978639b47838c", "html_url": "https://github.com/rust-lang/rust/commit/8ae5eadb22f378b6b1d277c4e7e978639b47838c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ae5eadb22f378b6b1d277c4e7e978639b47838c/comments", "author": {"login": "dylanmckay", "id": 7722159, "node_id": "MDQ6VXNlcjc3MjIxNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/7722159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylanmckay", "html_url": "https://github.com/dylanmckay", "followers_url": "https://api.github.com/users/dylanmckay/followers", "following_url": "https://api.github.com/users/dylanmckay/following{/other_user}", "gists_url": "https://api.github.com/users/dylanmckay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylanmckay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylanmckay/subscriptions", "organizations_url": "https://api.github.com/users/dylanmckay/orgs", "repos_url": "https://api.github.com/users/dylanmckay/repos", "events_url": "https://api.github.com/users/dylanmckay/events{/privacy}", "received_events_url": "https://api.github.com/users/dylanmckay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylanmckay", "id": 7722159, "node_id": "MDQ6VXNlcjc3MjIxNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/7722159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylanmckay", "html_url": "https://github.com/dylanmckay", "followers_url": "https://api.github.com/users/dylanmckay/followers", "following_url": "https://api.github.com/users/dylanmckay/following{/other_user}", "gists_url": "https://api.github.com/users/dylanmckay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylanmckay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylanmckay/subscriptions", "organizations_url": "https://api.github.com/users/dylanmckay/orgs", "repos_url": "https://api.github.com/users/dylanmckay/repos", "events_url": "https://api.github.com/users/dylanmckay/events{/privacy}", "received_events_url": "https://api.github.com/users/dylanmckay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b52522ade1f6979a35b24087dadcf5ba5c981cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/b52522ade1f6979a35b24087dadcf5ba5c981cbe", "html_url": "https://github.com/rust-lang/rust/commit/b52522ade1f6979a35b24087dadcf5ba5c981cbe"}], "stats": {"total": 171, "additions": 148, "deletions": 23}, "files": [{"sha": "7857ccb613bf8abd7fe212b11576986f80e49c7d", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -366,7 +366,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         unsafe {\n             llvm::LLVMPointerType(\n                 self.llvm_type(cx),\n-                cx.data_layout().instruction_address_space as c_uint,\n+                cx.data_layout().instruction_address_space.0 as c_uint,\n             )\n         }\n     }"}, {"sha": "0e1cd8e493d9a8dcde2769fab461bff3adecbd26", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::bug;\n use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::symbol::Symbol;\n-use rustc_target::abi::{self, HasDataLayout, LayoutOf, Pointer, Size};\n+use rustc_target::abi::{self, AddressSpace, HasDataLayout, LayoutOf, Pointer, Size};\n \n use libc::{c_char, c_uint};\n use log::debug;\n@@ -244,7 +244,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 }\n             }\n             Scalar::Ptr(ptr) => {\n-                let base_addr = match self.tcx.global_alloc(ptr.alloc_id) {\n+                let (base_addr, base_addr_space) = match self.tcx.global_alloc(ptr.alloc_id) {\n                     GlobalAlloc::Memory(alloc) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         let value = match alloc.mutability {\n@@ -254,18 +254,21 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         if !self.sess().fewer_names() {\n                             llvm::set_value_name(value, format!(\"{:?}\", ptr.alloc_id).as_bytes());\n                         }\n-                        value\n+                        (value, AddressSpace::DATA)\n                     }\n-                    GlobalAlloc::Function(fn_instance) => self.get_fn_addr(fn_instance),\n+                    GlobalAlloc::Function(fn_instance) => (\n+                        self.get_fn_addr(fn_instance),\n+                        self.data_layout().instruction_address_space,\n+                    ),\n                     GlobalAlloc::Static(def_id) => {\n                         assert!(self.tcx.is_static(def_id));\n                         assert!(!self.tcx.is_thread_local_static(def_id));\n-                        self.get_static(def_id)\n+                        (self.get_static(def_id), AddressSpace::DATA)\n                     }\n                 };\n                 let llval = unsafe {\n                     llvm::LLVMConstInBoundsGEP(\n-                        self.const_bitcast(base_addr, self.type_i8p()),\n+                        self.const_bitcast(base_addr, self.type_i8p_ext(base_addr_space)),\n                         &self.const_usize(ptr.offset.bytes()),\n                         1,\n                     )"}, {"sha": "3e9e5d9c8c1f44e059030d9397441ca8b31feb44", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -13,14 +13,14 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ConstValue, ErrorHandled, Pointer,\n+    read_target_uint, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n+use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n \n use std::ffi::CStr;\n \n@@ -53,10 +53,16 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         )\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n+\n+        let address_space = match cx.tcx.global_alloc(alloc_id) {\n+            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n+            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) => AddressSpace::DATA,\n+        };\n+\n         llvals.push(cx.scalar_to_backend(\n             Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n             &Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n-            cx.type_i8p(),\n+            cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;\n     }"}, {"sha": "05e364884f66dcd66fac3e1b2d5e3fa8d7e89ce6", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::Ty;\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n-use rustc_target::abi::{Align, Integer, Size};\n+use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n \n use std::fmt;\n use std::ptr;\n@@ -198,9 +198,13 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         assert_ne!(\n             self.type_kind(ty),\n             TypeKind::Function,\n-            \"don't call ptr_to on function types, use ptr_to_llvm_type on FnAbi instead\"\n+            \"don't call ptr_to on function types, use ptr_to_llvm_type on FnAbi instead or explicitly specify an address space if it makes sense\"\n         );\n-        ty.ptr_to()\n+        ty.ptr_to(AddressSpace::DATA)\n+    }\n+\n+    fn type_ptr_to_ext(&self, ty: &'ll Type, address_space: AddressSpace) -> &'ll Type {\n+        ty.ptr_to(address_space)\n     }\n \n     fn element_type(&self, ty: &'ll Type) -> &'ll Type {\n@@ -241,11 +245,11 @@ impl Type {\n     }\n \n     pub fn i8p_llcx(llcx: &llvm::Context) -> &Type {\n-        Type::i8_llcx(llcx).ptr_to()\n+        Type::i8_llcx(llcx).ptr_to(AddressSpace::DATA)\n     }\n \n-    fn ptr_to(&self) -> &Type {\n-        unsafe { llvm::LLVMPointerType(&self, 0) }\n+    fn ptr_to(&self, address_space: AddressSpace) -> &Type {\n+        unsafe { llvm::LLVMPointerType(&self, address_space.0) }\n     }\n }\n "}, {"sha": "bcc19c6a44bd829ffff227b9c606938cb26da6b5", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -75,7 +75,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     }\n \n     // Not in the cache; build it.\n-    let nullptr = cx.const_null(cx.type_i8p());\n+    let nullptr = cx.const_null(cx.type_i8p_ext(cx.data_layout().instruction_address_space));\n \n     let methods_root;\n     let methods = if let Some(trait_ref) = trait_ref {"}, {"sha": "f4d83e87710822836ccab73f7674d4bc417aef08", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_target::abi::call::{FnAbi, PassMode};\n+use rustc_target::abi::HasDataLayout;\n \n use std::iter;\n \n@@ -323,7 +324,9 @@ fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n-                    let null = bx.const_null(bx.type_i8p());\n+                    let null = bx.const_null(\n+                        bx.type_i8p_ext(bx.cx().data_layout().instruction_address_space),\n+                    );\n                     let sixty_four = bx.const_i32(64);\n                     funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                     cp_bx.br(llbb);"}, {"sha": "726d948cfd40cf483be1e705af99a8412f59abd4", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n-use rustc_target::abi::Integer;\n+use rustc_target::abi::{AddressSpace, Integer};\n \n // This depends on `Backend` and not `BackendTypes`, because consumers will probably want to use\n // `LayoutOf` or `HasTyCtxt`. This way, they don't have to add a constraint on it themselves.\n@@ -27,6 +27,7 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn type_struct(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n     fn type_kind(&self, ty: Self::Type) -> TypeKind;\n     fn type_ptr_to(&self, ty: Self::Type) -> Self::Type;\n+    fn type_ptr_to_ext(&self, ty: Self::Type, address_space: AddressSpace) -> Self::Type;\n     fn element_type(&self, ty: Self::Type) -> Self::Type;\n \n     /// Returns the number of elements in `self` if it is a LLVM vector type.\n@@ -42,7 +43,11 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n \n pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     fn type_i8p(&self) -> Self::Type {\n-        self.type_ptr_to(self.type_i8())\n+        self.type_i8p_ext(AddressSpace::DATA)\n+    }\n+\n+    fn type_i8p_ext(&self, address_space: AddressSpace) -> Self::Type {\n+        self.type_ptr_to_ext(self.type_i8(), address_space)\n     }\n \n     fn type_int(&self) -> Self::Type {"}, {"sha": "a570bd914ae68100fa85eb102c514c75f55bb8f3", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -32,7 +32,7 @@ pub struct TargetDataLayout {\n     /// Alignments for vector types.\n     pub vector_align: Vec<(Size, AbiAndPrefAlign)>,\n \n-    pub instruction_address_space: u32,\n+    pub instruction_address_space: AddressSpace,\n }\n \n impl Default for TargetDataLayout {\n@@ -56,7 +56,7 @@ impl Default for TargetDataLayout {\n                 (Size::from_bits(64), AbiAndPrefAlign::new(align(64))),\n                 (Size::from_bits(128), AbiAndPrefAlign::new(align(128))),\n             ],\n-            instruction_address_space: 0,\n+            instruction_address_space: AddressSpace::DATA,\n         }\n     }\n }\n@@ -65,7 +65,7 @@ impl TargetDataLayout {\n     pub fn parse(target: &Target) -> Result<TargetDataLayout, String> {\n         // Parse an address space index from a string.\n         let parse_address_space = |s: &str, cause: &str| {\n-            s.parse::<u32>().map_err(|err| {\n+            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n                 format!(\"invalid address space `{}` for `{}` in \\\"data-layout\\\": {}\", s, cause, err)\n             })\n         };\n@@ -744,6 +744,17 @@ impl FieldsShape {\n     }\n }\n \n+/// An identifier that specifies the address space that some operation\n+/// should operate on. Special address spaces have an effect on code generation,\n+/// depending on the target and the address spaces it implements.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct AddressSpace(pub u32);\n+\n+impl AddressSpace {\n+    /// The default address space, corresponding to data space.\n+    pub const DATA: Self = AddressSpace(0);\n+}\n+\n /// Describes how values of the type are passed by target ABIs,\n /// in terms of categories of C types there are ABI rules for.\n #[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]"}, {"sha": "7759d9603a5a47a73104f01740180b1ae24a6d1b", "filename": "src/test/codegen/avr/avr-func-addrspace.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae5eadb22f378b6b1d277c4e7e978639b47838c/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs?ref=8ae5eadb22f378b6b1d277c4e7e978639b47838c", "patch": "@@ -0,0 +1,93 @@\n+// compile-flags: -O --target=avr-unknown-unknown --crate-type=rlib\n+\n+// This test validates that function pointers can be stored in global variables\n+// and called upon. It ensures that Rust emits function pointers in the correct\n+// address space to LLVM so that an assertion error relating to casting is\n+// not triggered.\n+//\n+// It also validates that functions can be called through function pointers\n+// through traits.\n+\n+#![feature(no_core, lang_items, unboxed_closures, arbitrary_self_types)]\n+#![crate_type = \"lib\"]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+pub trait Sized { }\n+#[lang = \"copy\"]\n+pub trait Copy { }\n+#[lang = \"receiver\"]\n+pub trait Receiver { }\n+\n+pub struct Result<T, E> { _a: T, _b: E }\n+\n+impl Copy for usize {}\n+\n+#[lang = \"drop_in_place\"]\n+pub unsafe fn drop_in_place<T: ?Sized>(_: *mut T) {}\n+\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"fn_mut\"]\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"fn\"]\n+pub trait Fn<Args>: FnOnce<Args> {\n+    /// Performs the call operation.\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n+impl<'a, A, R> FnOnce<A> for &'a fn(A) -> R {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> R {\n+        (*self)(args)\n+    }\n+}\n+\n+pub static mut STORAGE_FOO: fn(&usize, &mut u32) -> Result<(), ()> = arbitrary_black_box;\n+pub static mut STORAGE_BAR: u32 = 12;\n+\n+fn arbitrary_black_box(ptr: &usize, _: &mut u32) -> Result<(), ()> {\n+    let raw_ptr = ptr as *const usize;\n+    let _v: usize = unsafe { *raw_ptr };\n+    loop {}\n+}\n+\n+#[inline(never)]\n+#[no_mangle]\n+fn call_through_fn_trait(a: &mut impl Fn<(), Output=()>) {\n+    (*a)()\n+}\n+\n+#[inline(never)]\n+fn update_bar_value() {\n+    unsafe {\n+        STORAGE_BAR = 88;\n+    }\n+}\n+\n+// CHECK: define void @test(){{.+}}addrspace(1)\n+#[no_mangle]\n+pub extern \"C\" fn test() {\n+    let mut buf = 7;\n+\n+    // A call through the Fn trait must use address space 1.\n+    //\n+    // CHECK: call{{.+}}addrspace(1) void @call_through_fn_trait()\n+    call_through_fn_trait(&mut update_bar_value);\n+\n+    // A call through a global variable must use address space 1.\n+    // CHECK: load {{.*}}addrspace(1){{.+}}FOO\n+    unsafe {\n+        STORAGE_FOO(&1, &mut buf);\n+    }\n+}"}]}