{"sha": "2d99ffd11b28357ed989a9641ed94ea384659d51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkOTlmZmQxMWIyODM1N2VkOTg5YTk2NDFlZDk0ZWEzODQ2NTlkNTE=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-06-20T13:42:11Z"}, "committer": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-06-29T13:37:18Z"}, "message": "track anonymous regions in return types, fix tidy errors", "tree": {"sha": "ea4bb4d831ee595544e7720c08559100d23e4067", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea4bb4d831ee595544e7720c08559100d23e4067"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d99ffd11b28357ed989a9641ed94ea384659d51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d99ffd11b28357ed989a9641ed94ea384659d51", "html_url": "https://github.com/rust-lang/rust/commit/2d99ffd11b28357ed989a9641ed94ea384659d51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d99ffd11b28357ed989a9641ed94ea384659d51/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fb6f74e57f6c75113074b56f48b16992c5ce1e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fb6f74e57f6c75113074b56f48b16992c5ce1e1", "html_url": "https://github.com/rust-lang/rust/commit/8fb6f74e57f6c75113074b56f48b16992c5ce1e1"}], "stats": {"total": 108, "additions": 91, "deletions": 17}, "files": [{"sha": "9e2d922b932d1624f5db2e4a1143dbaa84928c37", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2d99ffd11b28357ed989a9641ed94ea384659d51", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         for error in errors {\n \n             debug!(\"report_region_errors: error = {:?}\", error);\n-            \n+\n             if !self.try_report_named_anon_conflict(&error){\n \n                match error.clone() {"}, {"sha": "edb7887b504b1e1e3bcd584a5db353d83fb422ae", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=2d99ffd11b28357ed989a9641ed94ea384659d51", "patch": "@@ -15,6 +15,7 @@ use ty::{self, Region};\n use infer::region_inference::RegionResolutionError::*;\n use infer::region_inference::RegionResolutionError;\n use hir::map as hir_map;\n+use hir::def_id::DefId;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method walks the Type of the function body arguments using\n@@ -24,13 +25,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // Currently only the case where the function declaration consists of\n     // one named region and one anonymous region is handled.\n     // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n-    // Here, we would return the hir::Arg for y, and we return the type &'a\n+    // Here, we would return the hir::Arg for y, we return the type &'a\n     // i32, which is the type of y but with the anonymous region replaced\n-    // with 'a.\n+    // with 'a and also the corresponding bound region.\n     fn find_arg_with_anonymous_region(&self,\n                                       anon_region: Region<'tcx>,\n                                       named_region: Region<'tcx>)\n-                                      -> Option<(&hir::Arg, ty::Ty<'tcx>)> {\n+                                      -> Option<(&hir::Arg, ty::Ty<'tcx>, ty::BoundRegion)> {\n \n         match *anon_region {\n             ty::ReFree(ref free_region) => {\n@@ -55,7 +56,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                           r\n                                                       });\n                                     if found_anon_region {\n-                                        return Some((arg, new_arg_ty));\n+                                        return Some((arg, new_arg_ty, free_region.bound_region));\n                                     } else {\n                                         None\n                                     }\n@@ -85,15 +86,36 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.\n-        let (named, (arg, new_ty)) =\n-            if self.is_named_region(sub) && self.is_suitable_anonymous_region(sup) {\n-                (sub, self.find_arg_with_anonymous_region(sup, sub).unwrap())\n-            } else if self.is_named_region(sup) && self.is_suitable_anonymous_region(sub) {\n-                (sup, self.find_arg_with_anonymous_region(sub, sup).unwrap())\n+        let (named, (arg, new_ty, br), scope_def_id) =\n+            if self.is_named_region(sub) && self.is_suitable_anonymous_region(sup).is_some() {\n+                (sub,\n+                 self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n+                 self.is_suitable_anonymous_region(sup).unwrap())\n+            } else if self.is_named_region(sup) &&\n+                      self.is_suitable_anonymous_region(sub).is_some() {\n+                (sup,\n+                 self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n+                 self.is_suitable_anonymous_region(sub).unwrap())\n             } else {\n                 return false; // inapplicable\n             };\n \n+        // Here, we check for the case where the anonymous region\n+        // is in the return type.\n+        // FIXME(#42703) - Need to handle certain cases here.\n+        let ret_ty = self.tcx.type_of(scope_def_id);\n+        match ret_ty.sty {\n+            ty::TyFnDef(_, _, sig) => {\n+                let late_bound_regions = self.tcx\n+                    .collect_referenced_late_bound_regions(&sig.output());\n+                if late_bound_regions.iter().any(|r| *r == br) {\n+                    return false;\n+                } else {\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         if let Some(simple_name) = arg.pat.simple_name() {\n             struct_span_err!(self.tcx.sess,\n                              span,\n@@ -122,7 +144,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // This method returns whether the given Region is Anonymous\n-    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> bool {\n+    // and returns the DefId corresponding to the region.\n+    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<DefId> {\n \n         match *region {\n             ty::ReFree(ref free_region) => {\n@@ -147,20 +170,20 @@ associated_item(anonymous_region_binding_scope).container.id()).is_some() {\n                                     // since the signature must match the trait.\n                                     //\n                                     // FIXME(#42706) -- in some cases, we could do better here.\n-                                    return false;//None;\n+                                    return None;\n                                 }\n                               else{  }\n \n                             }\n-                            _ => return false, // inapplicable\n+                            _ => return None, // inapplicable\n                             // we target only top-level functions\n                         }\n-                        return true;\n+                        return Some(anonymous_region_binding_scope);\n                     }\n-                    _ => false,\n+                    _ => None,\n                 }\n             }\n-            _ => false,\n+            _ => None,\n         }\n     }\n }"}, {"sha": "362290ff3fa7d9cd5f7e52229e3648ca0939d67c", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.rs?ref=2d99ffd11b28357ed989a9641ed94ea384659d51", "patch": "@@ -14,7 +14,7 @@ struct Foo {\n \n impl Foo {\n   fn foo<'a>(&'a self, x: &i32) -> &i32 {\n-   \n+\n     if true { &self.field } else { x }\n \n   }"}, {"sha": "96b733be9b4eb5c4adf22a89f4cf6846ad561f04", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-return-type-is-anon.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.rs?ref=2d99ffd11b28357ed989a9641ed94ea384659d51", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+  field: i32\n+}\n+\n+impl Foo {\n+  fn foo<'a>(&self, x: &'a i32) -> &i32 {\n+\n+    x\n+\n+  }\n+\n+}\n+\n+fn main() { }"}, {"sha": "e32de589d2870914e53fc81f50fec5dae1bb993f", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-return-type-is-anon.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d99ffd11b28357ed989a9641ed94ea384659d51/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr?ref=2d99ffd11b28357ed989a9641ed94ea384659d51", "patch": "@@ -0,0 +1,27 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:18:5\n+   |\n+18 |     x\n+   |     ^\n+   |\n+note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:3...\n+  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n+   |\n+16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n+17 | |    \n+18 | |     x\n+19 | |\n+20 | |   }\n+   | |___^\n+note: ...but the borrowed content is only valid for the lifetime 'a as defined on the method body at 16:3\n+  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n+   |\n+16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n+17 | |    \n+18 | |     x\n+19 | |\n+20 | |   }\n+   | |___^\n+\n+error: aborting due to previous error(s)\n+"}]}