{"sha": "ac32359f085875837007b575a7b52339df017a7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMzIzNTlmMDg1ODc1ODM3MDA3YjU3NWE3YjUyMzM5ZGYwMTdhN2I=", "commit": {"author": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2019-02-11T10:58:56Z"}, "committer": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2019-02-13T11:35:23Z"}, "message": "Relax some Ord bounds on BinaryHeap<T>\n\nNotably, iterators don't require any trait bounds to be iterated.", "tree": {"sha": "c30a24b4965e4df99e77a25098537b4138ccc9d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c30a24b4965e4df99e77a25098537b4138ccc9d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac32359f085875837007b575a7b52339df017a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac32359f085875837007b575a7b52339df017a7b", "html_url": "https://github.com/rust-lang/rust/commit/ac32359f085875837007b575a7b52339df017a7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac32359f085875837007b575a7b52339df017a7b/comments", "author": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd23b95e5077a89a2ce35d09cbd4141ccc94f58", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd23b95e5077a89a2ce35d09cbd4141ccc94f58", "html_url": "https://github.com/rust-lang/rust/commit/ccd23b95e5077a89a2ce35d09cbd4141ccc94f58"}], "stats": {"total": 488, "additions": 244, "deletions": 244}, "files": [{"sha": "5074d5f5a1e30429e45d848d1bdf7359b3cc0479", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 244, "deletions": 244, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/ac32359f085875837007b575a7b52339df017a7b/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac32359f085875837007b575a7b52339df017a7b/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=ac32359f085875837007b575a7b52339df017a7b", "patch": "@@ -294,7 +294,7 @@ impl<T: Ord> Default for BinaryHeap<T> {\n }\n \n #[stable(feature = \"binaryheap_debug\", since = \"1.4.0\")]\n-impl<T: fmt::Debug + Ord> fmt::Debug for BinaryHeap<T> {\n+impl<T: fmt::Debug> fmt::Debug for BinaryHeap<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.iter()).finish()\n     }\n@@ -336,49 +336,6 @@ impl<T: Ord> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n \n-    /// Returns an iterator visiting all values in the underlying vector, in\n-    /// arbitrary order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n-    ///\n-    /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in heap.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<'_, T> {\n-        Iter { iter: self.data.iter() }\n-    }\n-\n-    /// Returns the greatest item in the binary heap, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// assert_eq!(heap.peek(), None);\n-    ///\n-    /// heap.push(1);\n-    /// heap.push(5);\n-    /// heap.push(2);\n-    /// assert_eq!(heap.peek(), Some(&5));\n-    ///\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn peek(&self) -> Option<&T> {\n-        self.data.get(0)\n-    }\n-\n     /// Returns a mutable reference to the greatest item in the binary heap, or\n     /// `None` if it is empty.\n     ///\n@@ -415,119 +372,6 @@ impl<T: Ord> BinaryHeap<T> {\n         }\n     }\n \n-    /// Returns the number of elements the binary heap can hold without reallocating.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::with_capacity(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.data.capacity()\n-    }\n-\n-    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n-    ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n-    /// insertions are expected.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// heap.reserve_exact(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    ///\n-    /// [`reserve`]: #method.reserve\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: usize) {\n-        self.data.reserve_exact(additional);\n-    }\n-\n-    /// Reserves capacity for at least `additional` more elements to be inserted in the\n-    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// heap.reserve(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: usize) {\n-        self.data.reserve(additional);\n-    }\n-\n-    /// Discards as much additional capacity as possible.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n-    ///\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.shrink_to_fit();\n-    /// assert!(heap.capacity() == 0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn shrink_to_fit(&mut self) {\n-        self.data.shrink_to_fit();\n-    }\n-\n-    /// Discards capacity with a lower bound.\n-    ///\n-    /// The capacity will remain at least as large as both the length\n-    /// and the supplied value.\n-    ///\n-    /// Panics if the current capacity is smaller than the supplied\n-    /// minimum capacity.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(shrink_to)]\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n-    ///\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.shrink_to(10);\n-    /// assert!(heap.capacity() >= 10);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n-    pub fn shrink_to(&mut self, min_capacity: usize) {\n-        self.data.shrink_to(min_capacity)\n-    }\n-\n     /// Removes the greatest item from the binary heap and returns it, or `None` if it\n     /// is empty.\n     ///\n@@ -577,28 +421,6 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_up(0, old_len);\n     }\n \n-    /// Consumes the `BinaryHeap` and returns the underlying vector\n-    /// in arbitrary order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n-    /// let vec = heap.into_vec();\n-    ///\n-    /// // Will print in some order\n-    /// for x in vec {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n-    pub fn into_vec(self) -> Vec<T> {\n-        self.into()\n-    }\n-\n     /// Consumes the `BinaryHeap` and returns a vector in sorted\n     /// (ascending) order.\n     ///\n@@ -703,6 +525,247 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_up(start, pos);\n     }\n \n+    fn rebuild(&mut self) {\n+        let mut n = self.len() / 2;\n+        while n > 0 {\n+            n -= 1;\n+            self.sift_down(n);\n+        }\n+    }\n+\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let v = vec![-10, 1, 2, 3, 3];\n+    /// let mut a = BinaryHeap::from(v);\n+    ///\n+    /// let v = vec![-20, 5, 43];\n+    /// let mut b = BinaryHeap::from(v);\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n+    /// assert!(b.is_empty());\n+    /// ```\n+    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        if self.len() < other.len() {\n+            swap(self, other);\n+        }\n+\n+        if other.is_empty() {\n+            return;\n+        }\n+\n+        #[inline(always)]\n+        fn log2_fast(x: usize) -> usize {\n+            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n+        }\n+\n+        // `rebuild` takes O(len1 + len2) operations\n+        // and about 2 * (len1 + len2) comparisons in the worst case\n+        // while `extend` takes O(len2 * log_2(len1)) operations\n+        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n+        // assuming len1 >= len2.\n+        #[inline]\n+        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n+            2 * (len1 + len2) < len2 * log2_fast(len1)\n+        }\n+\n+        if better_to_rebuild(self.len(), other.len()) {\n+            self.data.append(&mut other.data);\n+            self.rebuild();\n+        } else {\n+            self.extend(other.drain());\n+        }\n+    }\n+}\n+\n+impl<T> BinaryHeap<T> {\n+    /// Returns an iterator visiting all values in the underlying vector, in\n+    /// arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order\n+    /// for x in heap.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<'_, T> {\n+        Iter { iter: self.data.iter() }\n+    }\n+\n+    /// Returns the greatest item in the binary heap, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// assert_eq!(heap.peek(), None);\n+    ///\n+    /// heap.push(1);\n+    /// heap.push(5);\n+    /// heap.push(2);\n+    /// assert_eq!(heap.peek(), Some(&5));\n+    ///\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&self) -> Option<&T> {\n+        self.data.get(0)\n+    }\n+\n+    /// Returns the number of elements the binary heap can hold without reallocating.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::with_capacity(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.data.capacity()\n+    }\n+\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `usize`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.reserve_exact(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    ///\n+    /// [`reserve`]: #method.reserve\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.data.reserve_exact(additional);\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the\n+    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `usize`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.reserve(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.data.reserve(additional);\n+    }\n+\n+    /// Discards as much additional capacity as possible.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to_fit();\n+    /// assert!(heap.capacity() == 0);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.data.shrink_to_fit();\n+    }\n+\n+    /// Discards capacity with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to(10);\n+    /// assert!(heap.capacity() >= 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.data.shrink_to(min_capacity)\n+    }\n+\n+    /// Consumes the `BinaryHeap` and returns the underlying vector\n+    /// in arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = heap.into_vec();\n+    ///\n+    /// // Will print in some order\n+    /// for x in vec {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n+    pub fn into_vec(self) -> Vec<T> {\n+        self.into()\n+    }\n+\n     /// Returns the length of the binary heap.\n     ///\n     /// # Examples\n@@ -789,67 +852,6 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn clear(&mut self) {\n         self.drain();\n     }\n-\n-    fn rebuild(&mut self) {\n-        let mut n = self.len() / 2;\n-        while n > 0 {\n-            n -= 1;\n-            self.sift_down(n);\n-        }\n-    }\n-\n-    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    ///\n-    /// let v = vec![-10, 1, 2, 3, 3];\n-    /// let mut a = BinaryHeap::from(v);\n-    ///\n-    /// let v = vec![-20, 5, 43];\n-    /// let mut b = BinaryHeap::from(v);\n-    ///\n-    /// a.append(&mut b);\n-    ///\n-    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n-    /// assert!(b.is_empty());\n-    /// ```\n-    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n-        if self.len() < other.len() {\n-            swap(self, other);\n-        }\n-\n-        if other.is_empty() {\n-            return;\n-        }\n-\n-        #[inline(always)]\n-        fn log2_fast(x: usize) -> usize {\n-            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n-        }\n-\n-        // `rebuild` takes O(len1 + len2) operations\n-        // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log_2(len1)) operations\n-        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n-        // assuming len1 >= len2.\n-        #[inline]\n-        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n-            2 * (len1 + len2) < len2 * log2_fast(len1)\n-        }\n-\n-        if better_to_rebuild(self.len(), other.len()) {\n-            self.data.append(&mut other.data);\n-            self.rebuild();\n-        } else {\n-            self.extend(other.drain());\n-        }\n-    }\n }\n \n /// Hole represents a hole in a slice i.e., an index without valid value\n@@ -1111,7 +1113,7 @@ impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> IntoIterator for BinaryHeap<T> {\n+impl<T> IntoIterator for BinaryHeap<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -1139,9 +1141,7 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a BinaryHeap<T>\n-    where T: Ord\n-{\n+impl<'a, T> IntoIterator for &'a BinaryHeap<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n "}]}