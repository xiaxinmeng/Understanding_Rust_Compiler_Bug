{"sha": "fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlODlmMzIzNmMwOGFiZDhmZDJjODFjZGQyZjQxZmYyMDY2ZjEzYWM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-18T18:26:08Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-30T16:10:08Z"}, "message": "Address review.", "tree": {"sha": "aaebc3cc172078108ceba2c303e54adcb2f8959a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaebc3cc172078108ceba2c303e54adcb2f8959a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "html_url": "https://github.com/rust-lang/rust/commit/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65a8681a1701fa01e62a9fc9698e682df465f2ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/65a8681a1701fa01e62a9fc9698e682df465f2ec", "html_url": "https://github.com/rust-lang/rust/commit/65a8681a1701fa01e62a9fc9698e682df465f2ec"}], "stats": {"total": 100, "additions": 45, "deletions": 55}, "files": [{"sha": "e7bd488af8ebf69cbd654ce5c4a0baa78b488099", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "patch": "@@ -391,8 +391,6 @@ impl DirtyCleanVisitor<'tcx> {\n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        // if the node wasn't previously evaluated and now is (or vice versa),\n-        // then the node isn't actually clean or dirty.\n         if self.tcx.dep_graph.is_red(&dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx"}, {"sha": "23bd63a37d63753f71c34786dbd31959f8762e31", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "patch": "@@ -34,10 +34,8 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n         let dep_graph_path = dep_graph_path(sess);\n         let staging_dep_graph_path = staging_dep_graph_path(sess);\n \n-        join(\n-            || sess.time(\"assert_dep_graph\", || crate::assert_dep_graph(tcx)),\n-            || sess.time(\"check_dirty_clean\", || dirty_clean::check_dirty_clean_annotations(tcx)),\n-        );\n+        sess.time(\"assert_dep_graph\", || crate::assert_dep_graph(tcx));\n+        sess.time(\"check_dirty_clean\", || dirty_clean::check_dirty_clean_annotations(tcx));\n \n         if sess.opts.debugging_opts.incremental_info {\n             tcx.dep_graph.print_incremental_info()"}, {"sha": "04def9091318599461c5429d8a810500f46abfac", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "patch": "@@ -626,11 +626,10 @@ impl<K: DepKind> DepGraph<K> {\n \n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n-        let dep_node_index = {\n-            // We allocating an entry for the node in the current dependency graph and\n-            // adding all the appropriate edges imported from the previous graph\n-            data.current.intern_dark_green_node(&data.previous, prev_dep_node_index)\n-        };\n+        // We allocating an entry for the node in the current dependency graph and\n+        // adding all the appropriate edges imported from the previous graph\n+        let dep_node_index =\n+            data.current.promote_node_and_deps_to_current(&data.previous, prev_dep_node_index);\n \n         // ... emitting any stored diagnostic ...\n \n@@ -713,7 +712,7 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    // Returns true if the given node has been marked as green during the\n+    // Returns true if the given node has been marked as red during the\n     // current compilation session. Used in various assertions\n     pub fn is_red(&self, dep_node: &DepNode<K>) -> bool {\n         self.node_color(dep_node) == Some(DepNodeColor::Red)\n@@ -833,17 +832,11 @@ rustc_index::newtype_index! {\n /// will be populated as we run queries or tasks. We never remove nodes from the\n /// graph: they are only added.\n ///\n-/// The nodes in it are identified by a `DepNodeIndex`. Internally, this maps to\n-/// a `HybridIndex`, which identifies which collection in the `data` field\n-/// contains a node's data. Which collection is used for a node depends on\n-/// whether the node was present in the `PreviousDepGraph`, and if so, the color\n-/// of the node. Each type of node can share more or less data with the previous\n-/// graph. When possible, we can store just the index of the node in the\n-/// previous graph, rather than duplicating its data in our own collections.\n-/// This is important, because these graph structures are some of the largest in\n-/// the compiler.\n+/// The nodes in it are identified by a `DepNodeIndex`. We avoid keeping the nodes\n+/// in memory.  This is important, because these graph structures are some of the\n+/// largest in the compiler.\n ///\n-/// For the same reason, we also avoid storing `DepNode`s more than once as map\n+/// For this reason, we avoid storing `DepNode`s more than once as map\n /// keys. The `new_node_to_index` map only contains nodes not in the previous\n /// graph, and we map nodes in the previous graph to indices via a two-step\n /// mapping. `PreviousDepGraph` maps from `DepNode` to `SerializedDepNodeIndex`,\n@@ -939,6 +932,15 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         }\n     }\n \n+    #[cfg(debug_assertions)]\n+    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>) {\n+        if let Some(forbidden_edge) = &self.forbidden_edge {\n+            forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n+        }\n+    }\n+\n+    /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it.\n+    /// Assumes that this is a node that has no equivalent in the previous dep-graph.\n     fn intern_new_node(\n         &self,\n         key: DepNode<K>,\n@@ -951,9 +953,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                 let dep_node_index = self.encoder.borrow().send(key, current_fingerprint, edges);\n                 entry.insert(dep_node_index);\n                 #[cfg(debug_assertions)]\n-                if let Some(forbidden_edge) = &self.forbidden_edge {\n-                    forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n-                }\n+                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n         }\n@@ -964,37 +964,35 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         prev_graph: &PreviousDepGraph<K>,\n         key: DepNode<K>,\n         edges: EdgesVec,\n-        current_fingerprint: Option<Fingerprint>,\n+        fingerprint: Option<Fingerprint>,\n         print_status: bool,\n     ) -> (DepNodeIndex, Option<(SerializedDepNodeIndex, DepNodeColor)>) {\n         let print_status = cfg!(debug_assertions) && print_status;\n \n         if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n             // Determine the color and index of the new `DepNode`.\n-            if let Some(current_fingerprint) = current_fingerprint {\n-                if current_fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n+            if let Some(fingerprint) = fingerprint {\n+                if fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n                     if print_status {\n                         eprintln!(\"[task::green] {:?}\", key);\n                     }\n \n-                    // This is a light green node: it existed in the previous compilation,\n+                    // This is a green node: it existed in the previous compilation,\n                     // its query was re-executed, and it has the same result as before.\n                     let mut prev_index_to_index = self.prev_index_to_index.lock();\n \n                     let dep_node_index = match prev_index_to_index[prev_index] {\n                         Some(dep_node_index) => dep_node_index,\n                         None => {\n                             let dep_node_index =\n-                                self.encoder.borrow().send(key, current_fingerprint, edges);\n+                                self.encoder.borrow().send(key, fingerprint, edges);\n                             prev_index_to_index[prev_index] = Some(dep_node_index);\n                             dep_node_index\n                         }\n                     };\n \n                     #[cfg(debug_assertions)]\n-                    if let Some(forbidden_edge) = &self.forbidden_edge {\n-                        forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n-                    }\n+                    self.record_edge(dep_node_index, key);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n                 } else {\n                     if print_status {\n@@ -1009,16 +1007,14 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                         Some(dep_node_index) => dep_node_index,\n                         None => {\n                             let dep_node_index =\n-                                self.encoder.borrow().send(key, current_fingerprint, edges);\n+                                self.encoder.borrow().send(key, fingerprint, edges);\n                             prev_index_to_index[prev_index] = Some(dep_node_index);\n                             dep_node_index\n                         }\n                     };\n \n                     #[cfg(debug_assertions)]\n-                    if let Some(forbidden_edge) = &self.forbidden_edge {\n-                        forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n-                    }\n+                    self.record_edge(dep_node_index, key);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n                 }\n             } else {\n@@ -1043,26 +1039,24 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                 };\n \n                 #[cfg(debug_assertions)]\n-                if let Some(forbidden_edge) = &self.forbidden_edge {\n-                    forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n-                }\n+                self.record_edge(dep_node_index, key);\n                 (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n             }\n         } else {\n             if print_status {\n                 eprintln!(\"[task::new] {:?}\", key);\n             }\n \n-            let current_fingerprint = current_fingerprint.unwrap_or(Fingerprint::ZERO);\n+            let fingerprint = fingerprint.unwrap_or(Fingerprint::ZERO);\n \n             // This is a new node: it didn't exist in the previous compilation session.\n-            let dep_node_index = self.intern_new_node(key, edges, current_fingerprint);\n+            let dep_node_index = self.intern_new_node(key, edges, fingerprint);\n \n             (dep_node_index, None)\n         }\n     }\n \n-    fn intern_dark_green_node(\n+    fn promote_node_and_deps_to_current(\n         &self,\n         prev_graph: &PreviousDepGraph<K>,\n         prev_index: SerializedDepNodeIndex,\n@@ -1086,9 +1080,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                 );\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n                 #[cfg(debug_assertions)]\n-                if let Some(forbidden_edge) = &self.forbidden_edge {\n-                    forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n-                }\n+                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n         }"}, {"sha": "27b3b5e13667e44bd47b52e2f93fab83538373f1", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "patch": "@@ -32,7 +32,8 @@ impl<K: DepKind> DepGraphQuery<K> {\n \n         for &target in edges.iter() {\n             let target = self.dep_index_to_index[target];\n-            // Skip missing edges.\n+            // We may miss the edges that are pushed while the `DepGraphQuery` is being accessed.\n+            // Skip them to issues.\n             if let Some(target) = target {\n                 self.graph.add_edge(source, target, ());\n             }"}, {"sha": "aeb0e2b0da1a6f30df37e1acae92a3d7964387e8", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=fe89f3236c08abd8fd2c81cdd2f41ff2066f13ac", "patch": "@@ -73,7 +73,7 @@ impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<\n {\n     #[instrument(skip(d))]\n     fn decode(d: &mut opaque::Decoder<'a>) -> Result<SerializedDepGraph<K>, String> {\n-        let position = d.position();\n+        let start_position = d.position();\n \n         // The last 16 bytes are the node count and edge count.\n         debug!(\"position: {:?}\", d.position());\n@@ -85,7 +85,7 @@ impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<\n         debug!(?node_count, ?edge_count);\n \n         debug!(\"position: {:?}\", d.position());\n-        d.set_position(position);\n+        d.set_position(start_position);\n         debug!(\"position: {:?}\", d.position());\n \n         let mut nodes = IndexVec::with_capacity(node_count);\n@@ -137,15 +137,15 @@ struct Stat<K: DepKind> {\n     edge_counter: u64,\n }\n \n-struct EncodingStatus<K: DepKind> {\n+struct EncoderState<K: DepKind> {\n     encoder: FileEncoder,\n     total_node_count: usize,\n     total_edge_count: usize,\n     result: FileEncodeResult,\n     stats: Option<FxHashMap<K, Stat<K>>>,\n }\n \n-impl<K: DepKind> EncodingStatus<K> {\n+impl<K: DepKind> EncoderState<K> {\n     fn new(encoder: FileEncoder, record_stats: bool) -> Self {\n         Self {\n             encoder,\n@@ -186,8 +186,9 @@ impl<K: DepKind> EncodingStatus<K> {\n \n         debug!(?index, ?node);\n         let encoder = &mut self.encoder;\n-        self.result =\n-            std::mem::replace(&mut self.result, Ok(())).and_then(|()| node.encode(encoder));\n+        if self.result.is_ok() {\n+            self.result = node.encode(encoder);\n+        }\n         index\n     }\n \n@@ -209,7 +210,7 @@ impl<K: DepKind> EncodingStatus<K> {\n }\n \n pub struct GraphEncoder<K: DepKind> {\n-    status: Lock<EncodingStatus<K>>,\n+    status: Lock<EncoderState<K>>,\n     record_graph: Option<Lock<DepGraphQuery<K>>>,\n }\n \n@@ -225,7 +226,7 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n         } else {\n             None\n         };\n-        let status = Lock::new(EncodingStatus::new(encoder, record_stats));\n+        let status = Lock::new(EncoderState::new(encoder, record_stats));\n         GraphEncoder { status, record_graph }\n     }\n "}]}