{"sha": "616645255af92932937a0e3eb9455308ad92d42f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNjY0NTI1NWFmOTI5MzI5MzdhMGUzZWI5NDU1MzA4YWQ5MmQ0MmY=", "commit": {"author": {"name": "Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-10-11T07:15:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-11T07:15:35Z"}, "message": "Merge pull request #468 from RalfJung/pointer-provenance\n\nupdate for ptr provenance", "tree": {"sha": "c4f3dd2c5b80a9059f1f205ce04bf717b9716100", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4f3dd2c5b80a9059f1f205ce04bf717b9716100"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/616645255af92932937a0e3eb9455308ad92d42f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbvviXCRBK7hj4Ov3rIwAAdHIIAGyRTWi1qyFE5quAlQdJOEE/\n7dsC8enzpZZSkZA2RS5tBzZK0dsEp3vd2R/uo2wrMWZggb8aZDag2UfcDrBca5qb\nai9Cv96hdZLp43aCe20i2Kaf0zdo6T2E7MQairiucegQmkK1K0SegkLXWzqGEs8A\n7kxWKLxG4pYQ2MWmmW7f7+EuznloEMhZu4MtHnl6p9UsHt4o2cWKwzvwjtx8hQ+8\nrw7zCXT9gQveauKKrG15gMv1YmLi2Y70SBvWZHrXsh+6dD405N6T59soNsvtjbhx\nkALI7oap29OAglFoUi5shipVNI3lYfCizMQGEH9f9+HHSqFculZzpRq/VilAoOY=\n=jabs\n-----END PGP SIGNATURE-----\n", "payload": "tree c4f3dd2c5b80a9059f1f205ce04bf717b9716100\nparent 15a00043ba9741878a75c998e9daa7d64fca4edc\nparent cde707d28b1e3489c5bb34c0f86d650537436790\nauthor Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer <github35764891676564198441@oli-obk.de> 1539242135 +0200\ncommitter GitHub <noreply@github.com> 1539242135 +0200\n\nMerge pull request #468 from RalfJung/pointer-provenance\n\nupdate for ptr provenance"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/616645255af92932937a0e3eb9455308ad92d42f", "html_url": "https://github.com/rust-lang/rust/commit/616645255af92932937a0e3eb9455308ad92d42f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/616645255af92932937a0e3eb9455308ad92d42f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a00043ba9741878a75c998e9daa7d64fca4edc", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a00043ba9741878a75c998e9daa7d64fca4edc", "html_url": "https://github.com/rust-lang/rust/commit/15a00043ba9741878a75c998e9daa7d64fca4edc"}, {"sha": "cde707d28b1e3489c5bb34c0f86d650537436790", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde707d28b1e3489c5bb34c0f86d650537436790", "html_url": "https://github.com/rust-lang/rust/commit/cde707d28b1e3489c5bb34c0f86d650537436790"}], "stats": {"total": 124, "additions": 114, "deletions": 10}, "files": [{"sha": "721790eb1a83dbbc84166be6d2e06310114daeca", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/616645255af92932937a0e3eb9455308ad92d42f/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/616645255af92932937a0e3eb9455308ad92d42f/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=616645255af92932937a0e3eb9455308ad92d42f", "patch": "@@ -1 +1 @@\n-nightly-2018-10-10\n+nightly-2018-10-11"}, {"sha": "b7338d4d52143380ff8010cab67f3c774cc294ab", "filename": "src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/616645255af92932937a0e3eb9455308ad92d42f/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616645255af92932937a0e3eb9455308ad92d42f/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=616645255af92932937a0e3eb9455308ad92d42f", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         _ => {\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n-                            assert!(mplace.extra.is_none());\n+                            assert!(mplace.meta.is_none());\n                             self.memory.write_repeat(mplace.ptr, 0, dest.layout.size)?;\n                         }\n                     }\n@@ -410,7 +410,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         _ => {\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n-                            assert!(mplace.extra.is_none());\n+                            assert!(mplace.meta.is_none());\n                             self.memory.mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n                         }\n                     }"}, {"sha": "81a2ceead0a623b191cf45d47586eb5a90e95306", "filename": "src/lib.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/616645255af92932937a0e3eb9455308ad92d42f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616645255af92932937a0e3eb9455308ad92d42f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=616645255af92932937a0e3eb9455308ad92d42f", "patch": "@@ -13,6 +13,9 @@ extern crate rustc_mir;\n extern crate rustc_target;\n extern crate syntax;\n \n+use std::collections::HashMap;\n+use std::borrow::Cow;\n+\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n@@ -21,11 +24,10 @@ use rustc::mir;\n use syntax::ast::Mutability;\n use syntax::attr;\n \n-use std::collections::HashMap;\n \n pub use rustc::mir::interpret::*;\n pub use rustc_mir::interpret::*;\n-pub use rustc_mir::interpret;\n+pub use rustc_mir::interpret::{self, AllocMap}; // resolve ambiguity\n \n mod fn_call;\n mod operator;\n@@ -34,13 +36,15 @@ mod helpers;\n mod tls;\n mod locks;\n mod range_map;\n+mod mono_hash_map;\n \n use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n use tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n use range_map::RangeMap;\n use helpers::FalibleScalarExt;\n+use mono_hash_map::MonoHashMap;\n \n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -231,8 +235,11 @@ pub struct Evaluator<'tcx> {\n impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryData = ();\n     type MemoryKinds = MiriMemoryKind;\n+    type PointerTag = (); // still WIP\n \n-    const MUT_STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n+    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<()>)>;\n+\n+    const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n     const ENFORCE_VALIDITY: bool = false; // this is still WIP\n \n     /// Returns Ok() when the function was handled, fail otherwise\n@@ -308,7 +315,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-    ) -> EvalResult<'tcx, &'tcx Allocation> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n             Some(name) => name.as_str(),\n@@ -319,14 +326,13 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             \"__cxa_thread_atexit_impl\" => {\n                 // This should be all-zero, pointer-sized\n                 let data = vec![0; tcx.data_layout.pointer_size.bytes() as usize];\n-                let alloc = Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align);\n-                tcx.intern_const_alloc(alloc)\n+                Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align)\n             }\n             _ => return err!(Unimplemented(\n                     format!(\"can't access foreign static: {}\", link_name),\n                 )),\n         };\n-        Ok(alloc)\n+        Ok(Cow::Owned(alloc))\n     }\n \n     fn validation_op(\n@@ -344,4 +350,11 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         // We are not interested in detecting loops\n         Ok(())\n     }\n+\n+    fn static_with_default_tag(\n+        alloc: &'_ Allocation\n+    ) -> Cow<'_, Allocation<Self::PointerTag>> {\n+        let alloc = alloc.clone();\n+        Cow::Owned(alloc)\n+    }\n }"}, {"sha": "76ca7ac6a133af839382a16598ef70f1e904f999", "filename": "src/mono_hash_map.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/616645255af92932937a0e3eb9455308ad92d42f/src%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616645255af92932937a0e3eb9455308ad92d42f/src%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_hash_map.rs?ref=616645255af92932937a0e3eb9455308ad92d42f", "patch": "@@ -0,0 +1,91 @@\n+//! This is a \"monotonic HashMap\": A HashMap that, when shared, can be pushed to but not\n+//! otherwise mutated.  We also Box items in the map. This means we can safely provide\n+//! shared references into existing items in the HashMap, because they will not be dropped\n+//! (from being removed) or moved (because they are boxed).\n+//! The API is is completely tailored to what `memory.rs` needs. It is still in\n+//! a separate file to minimize the amount of code that has to care about the unsafety.\n+\n+use std::collections::hash_map::Entry;\n+use std::cell::RefCell;\n+use std::hash::Hash;\n+use std::borrow::Borrow;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use super::AllocMap;\n+\n+#[derive(Debug, Clone)]\n+pub struct MonoHashMap<K: Hash + Eq, V>(RefCell<FxHashMap<K, Box<V>>>);\n+\n+impl<K: Hash + Eq, V> Default for MonoHashMap<K, V> {\n+    fn default() -> Self {\n+        MonoHashMap(RefCell::new(Default::default()))\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> AllocMap<K, V> for MonoHashMap<K, V> {\n+    #[inline(always)]\n+    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n+        where K: Borrow<Q>\n+    {\n+        self.0.get_mut().contains_key(k)\n+    }\n+\n+    #[inline(always)]\n+    fn insert(&mut self, k: K, v: V) -> Option<V>\n+    {\n+        self.0.get_mut().insert(k, Box::new(v)).map(|x| *x)\n+    }\n+\n+    #[inline(always)]\n+    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n+        where K: Borrow<Q>\n+    {\n+        self.0.get_mut().remove(k).map(|x| *x)\n+    }\n+\n+    #[inline(always)]\n+    fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n+        self.0.borrow()\n+            .iter()\n+            .filter_map(move |(k, v)| f(k, &*v))\n+            .collect()\n+    }\n+\n+    /// The most interesting method: Providing a shared ref without\n+    /// holding the `RefCell` open, and inserting new data if the key\n+    /// is not used yet.\n+    /// `vacant` is called if the key is not found in the map;\n+    /// if it returns a reference, that is used directly, if it\n+    /// returns owned data, that is put into the map and returned.\n+    #[inline(always)]\n+    fn get_or<E>(\n+        &self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&V, E> {\n+        let val: *const V = match self.0.borrow_mut().entry(k) {\n+            Entry::Occupied(entry) => &**entry.get(),\n+            Entry::Vacant(entry) => &**entry.insert(Box::new(vacant()?)),\n+        };\n+        // This is safe because `val` points into a `Box`, that we know will not move and\n+        // will also not be dropped as long as the shared reference `self` is live.\n+        unsafe { Ok(&*val) }\n+    }\n+\n+    #[inline(always)]\n+    fn get_mut_or<E>(\n+        &mut self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&mut V, E>\n+    {\n+        match self.0.get_mut().entry(k) {\n+            Entry::Occupied(e) => Ok(e.into_mut()),\n+            Entry::Vacant(e) => {\n+                let v = vacant()?;\n+                Ok(e.insert(Box::new(v)))\n+            }\n+        }\n+    }\n+}"}]}