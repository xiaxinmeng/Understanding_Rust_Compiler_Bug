{"sha": "c76125742a3d7ab9f6ad9fbaba8174f959adc18b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NjEyNTc0MmEzZDdhYjlmNmFkOWZiYWJhODE3NGY5NTlhZGMxOGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-01T17:26:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-01T17:26:24Z"}, "message": "refactor header parsing so it can work \"in-place\"", "tree": {"sha": "7737d288da69bdcfc2650e14cd56f2dc0ea4615c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7737d288da69bdcfc2650e14cd56f2dc0ea4615c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c76125742a3d7ab9f6ad9fbaba8174f959adc18b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c76125742a3d7ab9f6ad9fbaba8174f959adc18b", "html_url": "https://github.com/rust-lang/rust/commit/c76125742a3d7ab9f6ad9fbaba8174f959adc18b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c76125742a3d7ab9f6ad9fbaba8174f959adc18b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24f0851e670530b48ba0c098044a7fb235847501", "url": "https://api.github.com/repos/rust-lang/rust/commits/24f0851e670530b48ba0c098044a7fb235847501", "html_url": "https://github.com/rust-lang/rust/commit/24f0851e670530b48ba0c098044a7fb235847501"}], "stats": {"total": 126, "additions": 64, "deletions": 62}, "files": [{"sha": "d5745ab8b34cff37ae3f4e53db68d172e7a74c86", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/c76125742a3d7ab9f6ad9fbaba8174f959adc18b/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c76125742a3d7ab9f6ad9fbaba8174f959adc18b/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=c76125742a3d7ab9f6ad9fbaba8174f959adc18b", "patch": "@@ -54,80 +54,101 @@ pub struct TestProps {\n \n // Load any test directives embedded in the file\n pub fn load_props(testfile: &Path) -> TestProps {\n-    let mut error_patterns = Vec::new();\n-    let mut aux_builds = Vec::new();\n-    let mut exec_env = Vec::new();\n-    let mut compile_flags = None;\n-    let mut run_flags = None;\n-    let mut pp_exact = None;\n-    let mut check_lines = Vec::new();\n-    let mut build_aux_docs = false;\n-    let mut force_host = false;\n-    let mut check_stdout = false;\n-    let mut no_prefer_dynamic = false;\n-    let mut pretty_expanded = false;\n-    let mut pretty_mode = None;\n-    let mut pretty_compare_only = false;\n-    let mut forbid_output = Vec::new();\n+    let error_patterns = Vec::new();\n+    let aux_builds = Vec::new();\n+    let exec_env = Vec::new();\n+    let compile_flags = None;\n+    let run_flags = None;\n+    let pp_exact = None;\n+    let check_lines = Vec::new();\n+    let build_aux_docs = false;\n+    let force_host = false;\n+    let check_stdout = false;\n+    let no_prefer_dynamic = false;\n+    let pretty_expanded = false;\n+    let pretty_compare_only = false;\n+    let forbid_output = Vec::new();\n+    let mut props = TestProps {\n+        error_patterns: error_patterns,\n+        compile_flags: compile_flags,\n+        run_flags: run_flags,\n+        pp_exact: pp_exact,\n+        aux_builds: aux_builds,\n+        exec_env: exec_env,\n+        check_lines: check_lines,\n+        build_aux_docs: build_aux_docs,\n+        force_host: force_host,\n+        check_stdout: check_stdout,\n+        no_prefer_dynamic: no_prefer_dynamic,\n+        pretty_expanded: pretty_expanded,\n+        pretty_mode: format!(\"normal\"),\n+        pretty_compare_only: pretty_compare_only,\n+        forbid_output: forbid_output,\n+    };\n+    load_props_into(&mut props, testfile);\n+    props\n+}\n+\n+pub fn load_props_into(props: &mut TestProps, testfile: &Path) {\n     iter_header(testfile, &mut |ln| {\n         if let Some(ep) = parse_error_pattern(ln) {\n-           error_patterns.push(ep);\n+            props.error_patterns.push(ep);\n         }\n \n-        if compile_flags.is_none() {\n-            compile_flags = parse_compile_flags(ln);\n+        if props.compile_flags.is_none() {\n+            props.compile_flags = parse_compile_flags(ln);\n         }\n \n-        if run_flags.is_none() {\n-            run_flags = parse_run_flags(ln);\n+        if props.run_flags.is_none() {\n+            props.run_flags = parse_run_flags(ln);\n         }\n \n-        if pp_exact.is_none() {\n-            pp_exact = parse_pp_exact(ln, testfile);\n+        if props.pp_exact.is_none() {\n+            props.pp_exact = parse_pp_exact(ln, testfile);\n         }\n \n-        if !build_aux_docs {\n-            build_aux_docs = parse_build_aux_docs(ln);\n+        if !props.build_aux_docs {\n+            props.build_aux_docs = parse_build_aux_docs(ln);\n         }\n \n-        if !force_host {\n-            force_host = parse_force_host(ln);\n+        if !props.force_host {\n+            props.force_host = parse_force_host(ln);\n         }\n \n-        if !check_stdout {\n-            check_stdout = parse_check_stdout(ln);\n+        if !props.check_stdout {\n+            props.check_stdout = parse_check_stdout(ln);\n         }\n \n-        if !no_prefer_dynamic {\n-            no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n+        if !props.no_prefer_dynamic {\n+            props.no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n         }\n \n-        if !pretty_expanded {\n-            pretty_expanded = parse_pretty_expanded(ln);\n+        if !props.pretty_expanded {\n+            props.pretty_expanded = parse_pretty_expanded(ln);\n         }\n \n-        if pretty_mode.is_none() {\n-            pretty_mode = parse_pretty_mode(ln);\n+        if let Some(m) = parse_pretty_mode(ln) {\n+            props.pretty_mode = m;\n         }\n \n-        if !pretty_compare_only {\n-            pretty_compare_only = parse_pretty_compare_only(ln);\n+        if !props.pretty_compare_only {\n+            props.pretty_compare_only = parse_pretty_compare_only(ln);\n         }\n \n         if let  Some(ab) = parse_aux_build(ln) {\n-            aux_builds.push(ab);\n+            props.aux_builds.push(ab);\n         }\n \n         if let Some(ee) = parse_exec_env(ln) {\n-            exec_env.push(ee);\n+            props.exec_env.push(ee);\n         }\n \n         if let Some(cl) =  parse_check_line(ln) {\n-            check_lines.push(cl);\n+            props.check_lines.push(cl);\n         }\n \n         if let Some(of) = parse_forbid_output(ln) {\n-            forbid_output.push(of);\n+            props.forbid_output.push(of);\n         }\n \n         true\n@@ -136,30 +157,12 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n         match env::var(key) {\n             Ok(val) =>\n-                if exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n-                    exec_env.push((key.to_owned(), val))\n+                if props.exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n+                    props.exec_env.push((key.to_owned(), val))\n                 },\n             Err(..) => {}\n         }\n     }\n-\n-    TestProps {\n-        error_patterns: error_patterns,\n-        compile_flags: compile_flags,\n-        run_flags: run_flags,\n-        pp_exact: pp_exact,\n-        aux_builds: aux_builds,\n-        exec_env: exec_env,\n-        check_lines: check_lines,\n-        build_aux_docs: build_aux_docs,\n-        force_host: force_host,\n-        check_stdout: check_stdout,\n-        no_prefer_dynamic: no_prefer_dynamic,\n-        pretty_expanded: pretty_expanded,\n-        pretty_mode: pretty_mode.unwrap_or(\"normal\".to_owned()),\n-        pretty_compare_only: pretty_compare_only,\n-        forbid_output: forbid_output,\n-    }\n }\n \n pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n@@ -253,8 +256,7 @@ fn iter_header(testfile: &Path, it: &mut FnMut(&str) -> bool) -> bool {\n         // with a warm page cache. Maybe with a cold one.\n         let ln = ln.unwrap();\n         let ln = ln.trim();\n-        if ln.starts_with(\"fn\") ||\n-                ln.starts_with(\"mod\") {\n+        if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return true;\n         } else if ln.starts_with(\"//\") {\n             if !it(&ln[2..]) {"}]}