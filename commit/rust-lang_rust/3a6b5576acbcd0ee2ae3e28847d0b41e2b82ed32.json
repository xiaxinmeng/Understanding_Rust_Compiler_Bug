{"sha": "3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNmI1NTc2YWNiY2QwZWUyYWUzZTI4ODQ3ZDBiNDFlMmI4MmVkMzI=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-02T23:23:52Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-02T23:35:25Z"}, "message": "Refactor make_fp_cmp_glue and make_integral_cmp_glue into one.", "tree": {"sha": "68254ffdf0c57a969eb845deb606f61f2234a814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68254ffdf0c57a969eb845deb606f61f2234a814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32", "html_url": "https://github.com/rust-lang/rust/commit/3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12f86e6f2f5e7a5fc4ea61f3c63c790be100688f", "url": "https://api.github.com/repos/rust-lang/rust/commits/12f86e6f2f5e7a5fc4ea61f3c63c790be100688f", "html_url": "https://github.com/rust-lang/rust/commit/12f86e6f2f5e7a5fc4ea61f3c63c790be100688f"}], "stats": {"total": 168, "additions": 95, "deletions": 73}, "files": [{"sha": "1f7c180b1559a66ab6ba93ca0837c0826e676447", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 95, "deletions": 73, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32", "patch": "@@ -2396,11 +2396,11 @@ fn make_cmp_glue(&@block_ctxt cx,\n \n             // If we hit == all the way through the minimum-shared-length\n             // section, default to judging the relative sequence lengths.\n-            r = compare_integral_values(scx,\n-                                        vec_fill(scx, lhs),\n-                                        vec_fill(scx, rhs),\n-                                        false,\n-                                        llop);\n+            r = compare_numerical_values(scx,\n+                                         vec_fill(scx, lhs),\n+                                         vec_fill(scx, rhs),\n+                                         unsigned_int,\n+                                         llop);\n             r.bcx.build.Store(r.val, flag);\n \n         } else {\n@@ -2486,88 +2486,111 @@ fn make_cmp_glue(&@block_ctxt cx,\n     }\n }\n \n+// Used only for creating scalar comparsion glue.\n+tag numerical_type {\n+    signed_int;\n+    unsigned_int;\n+    floating_point;\n+}\n+\n // A helper function to create scalar comparison glue.\n fn make_scalar_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n                         &ty::t t, ValueRef llop) {\n-    if (ty::type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n-        make_fp_cmp_glue(cx, lhs, rhs, t, llop);\n-        ret;\n-    }\n+    // assert ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t);\n \n-    if (ty::type_is_integral(cx.fcx.lcx.ccx.tcx, t) ||\n-            ty::type_is_bool(cx.fcx.lcx.ccx.tcx, t)) {\n-        make_integral_cmp_glue(cx, lhs, rhs, t, llop);\n-        ret;\n-    }\n+    // In most cases, we need to know whether to do signed, unsigned, or float\n+    // comparison.\n+    auto f = bind make_numerical_cmp_glue(cx, lhs, rhs, _, llop);\n \n-    if (ty::type_is_nil(cx.fcx.lcx.ccx.tcx, t)) {\n-        cx.build.Store(C_bool(true), cx.fcx.llretptr);\n-        cx.build.RetVoid();\n-        ret;\n+    // FIXME: this could be a lot shorter if we could combine multiple cases\n+    // of alt expressions (issue #449).\n+    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+        case (ty::ty_nil) { \n+            cx.build.Store(C_bool(true), cx.fcx.llretptr);\n+            cx.build.RetVoid();\n+        }\n+        case (ty::ty_bool) { f(unsigned_int); }\n+        case (ty::ty_int) { f(signed_int); }\n+        case (ty::ty_float) { f(floating_point); }\n+        case (ty::ty_uint) { f(unsigned_int); }\n+        case (ty::ty_machine(_)) {\n+            // Floating point machine types\n+            if (ty::type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n+                f(floating_point);\n+            } \n+            // Signed, integral machine types\n+            else if (ty::type_is_signed(cx.fcx.lcx.ccx.tcx, t)) {\n+                f(signed_int);\n+            }\n+            // Unsigned, integral machine types\n+            else { f(unsigned_int); }\n+        }\n+        case (ty::ty_char)  { f(unsigned_int); }\n+        case (ty::ty_type)  {\n+            trans_fail(cx, none[common::span],\n+                       \"attempt to compare values of type type\");\n+        }\n+        case (ty::ty_native) {\n+            trans_fail(cx, none[common::span],\n+                       \"attempt to compare values of type native\");\n+        }\n+        case (_) {\n+            // Should never get here, because t is scalar.\n+            fail;\n+        }\n     }\n-\n-    trans_fail(cx, none[common::span],\n-               \"attempt to compare values of type \" +\n-               ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n }\n \n-// A helper function to create floating point comparison glue.\n-fn make_fp_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n-                    &ty::t fptype, ValueRef llop) {\n-    auto last_cx = new_sub_block_ctxt(cx, \"last\");\n-\n-    auto eq_cx = new_sub_block_ctxt(cx, \"eq\");\n-    auto eq_result = eq_cx.build.FCmp(lib::llvm::LLVMRealUEQ, lhs, rhs);\n-    eq_cx.build.Br(last_cx.llbb);\n-\n-    auto lt_cx = new_sub_block_ctxt(cx, \"lt\");\n-    auto lt_result = lt_cx.build.FCmp(lib::llvm::LLVMRealULT, lhs, rhs);\n-    lt_cx.build.Br(last_cx.llbb);\n-\n-    auto le_cx = new_sub_block_ctxt(cx, \"le\");\n-    auto le_result = le_cx.build.FCmp(lib::llvm::LLVMRealULE, lhs, rhs);\n-    le_cx.build.Br(last_cx.llbb);\n-\n-    auto unreach_cx = new_sub_block_ctxt(cx, \"unreach\");\n-    unreach_cx.build.Unreachable();\n-\n-    auto llswitch = cx.build.Switch(llop, unreach_cx.llbb, 3u);\n-    llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_eq), eq_cx.llbb);\n-    llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_lt), lt_cx.llbb);\n-    llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_le), le_cx.llbb);\n-\n-    auto last_result =\n-        last_cx.build.Phi(T_i1(), [eq_result, lt_result, le_result],\n-                          [eq_cx.llbb, lt_cx.llbb, le_cx.llbb]);\n-    last_cx.build.Store(last_result, cx.fcx.llretptr);\n-    last_cx.build.RetVoid();\n-}\n-\n-// A helper function to compare integral values. This is used by both\n-// `make_integral_cmp_glue` and `make_cmp_glue`.\n-fn compare_integral_values(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n-                           bool signed, ValueRef llop) -> result {\n-    auto lt_cmp; auto le_cmp;\n-    if (signed) {\n-        lt_cmp = lib::llvm::LLVMIntSLT;\n-        le_cmp = lib::llvm::LLVMIntSLE;\n-    } else {\n-        lt_cmp = lib::llvm::LLVMIntULT;\n-        le_cmp = lib::llvm::LLVMIntULE;\n+// A helper function to compare numerical values.\n+fn compare_numerical_values(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n+                            numerical_type nt, ValueRef llop) -> result {\n+    auto eq_cmp; auto lt_cmp; auto le_cmp;\n+    alt (nt) {\n+        case (floating_point) {\n+            eq_cmp = lib::llvm::LLVMRealUEQ;\n+            lt_cmp = lib::llvm::LLVMRealULT;\n+            le_cmp = lib::llvm::LLVMRealULE;\n+        }\n+        case (signed_int) {\n+            eq_cmp = lib::llvm::LLVMIntEQ;\n+            lt_cmp = lib::llvm::LLVMIntSLT;\n+            le_cmp = lib::llvm::LLVMIntSLE;\n+        }\n+        case (unsigned_int) {\n+            eq_cmp = lib::llvm::LLVMIntEQ;\n+            lt_cmp = lib::llvm::LLVMIntULT;\n+            le_cmp = lib::llvm::LLVMIntULE;\n+        }\n+    }\n+    \n+    // FIXME: This wouldn't be necessary if we could bind methods off of\n+    // objects and therefore abstract over FCmp and ICmp (issue #435).  Then\n+    // we could just write, e.g., \"cmp_fn = bind cx.build.FCmp(_, _, _);\" in\n+    // the above, and \"auto eq_result = cmp_fn(eq_cmp, lhs, rhs);\" in the\n+    // below.\n+    fn generic_cmp(&@block_ctxt cx, numerical_type nt,\n+                   uint op, ValueRef lhs, ValueRef rhs) -> ValueRef {\n+        let ValueRef r;\n+        if (nt == floating_point) {\n+            r = cx.build.FCmp(op, lhs, rhs);\n+        } else {\n+            r = cx.build.ICmp(op, lhs, rhs);\n+        }\n+        ret r;\n     }\n \n     auto last_cx = new_sub_block_ctxt(cx, \"last\");\n \n     auto eq_cx = new_sub_block_ctxt(cx, \"eq\");\n-    auto eq_result = eq_cx.build.ICmp(lib::llvm::LLVMIntEQ, lhs, rhs);\n+    auto eq_result = generic_cmp(eq_cx, nt, eq_cmp, lhs, rhs);\n     eq_cx.build.Br(last_cx.llbb);\n \n     auto lt_cx = new_sub_block_ctxt(cx, \"lt\");\n-    auto lt_result = lt_cx.build.ICmp(lt_cmp, lhs, rhs);\n+    auto lt_result = generic_cmp(lt_cx, nt, lt_cmp, lhs, rhs);\n     lt_cx.build.Br(last_cx.llbb);\n \n     auto le_cx = new_sub_block_ctxt(cx, \"le\");\n-    auto le_result = le_cx.build.ICmp(le_cmp, lhs, rhs);\n+    auto le_result = generic_cmp(le_cx, nt, le_cmp, lhs, rhs);\n     le_cx.build.Br(last_cx.llbb);\n \n     auto unreach_cx = new_sub_block_ctxt(cx, \"unreach\");\n@@ -2584,11 +2607,10 @@ fn compare_integral_values(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n     ret res(last_cx, last_result);\n }\n \n-// A helper function to create integral comparison glue.\n-fn make_integral_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n-                          &ty::t intype, ValueRef llop) {\n-    auto r = compare_integral_values(cx, lhs, rhs,\n-        ty::type_is_signed(cx.fcx.lcx.ccx.tcx, intype), llop);\n+// A helper function to create numerical comparison glue.\n+fn make_numerical_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n+                          numerical_type nt, ValueRef llop) {\n+    auto r = compare_numerical_values(cx, lhs, rhs, nt, llop);\n     r.bcx.build.Store(r.val, r.bcx.fcx.llretptr);\n     r.bcx.build.RetVoid();\n }"}]}