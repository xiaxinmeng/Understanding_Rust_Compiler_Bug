{"sha": "557210a68839286ebafa1e1565b978566b38a6f1", "node_id": "C_kwDOAAsO6NoAKDU1NzIxMGE2ODgzOTI4NmViYWZhMWUxNTY1Yjk3ODU2NmIzOGE2ZjE", "commit": {"author": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-09-08T11:35:28Z"}, "committer": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-09-26T06:34:02Z"}, "message": "Begining of lsif", "tree": {"sha": "4915917f6078fbc344ae2a0b6d297e1512b00c59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4915917f6078fbc344ae2a0b6d297e1512b00c59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/557210a68839286ebafa1e1565b978566b38a6f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/557210a68839286ebafa1e1565b978566b38a6f1", "html_url": "https://github.com/rust-lang/rust/commit/557210a68839286ebafa1e1565b978566b38a6f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/557210a68839286ebafa1e1565b978566b38a6f1/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d401f2a062ffc4b458f158f535478d6cc8d09f44", "url": "https://api.github.com/repos/rust-lang/rust/commits/d401f2a062ffc4b458f158f535478d6cc8d09f44", "html_url": "https://github.com/rust-lang/rust/commit/d401f2a062ffc4b458f158f535478d6cc8d09f44"}], "stats": {"total": 552, "additions": 550, "deletions": 2}, "files": [{"sha": "3879da6d039cdee1c2f1fe5d2f6871930f879e5d", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -46,6 +46,7 @@ mod references;\n mod rename;\n mod runnables;\n mod ssr;\n+mod static_index;\n mod status;\n mod syntax_highlighting;\n mod syntax_tree;\n@@ -86,6 +87,7 @@ pub use crate::{\n     references::ReferenceSearchResult,\n     rename::RenameError,\n     runnables::{Runnable, RunnableKind, TestId},\n+    static_index::{StaticIndex, StaticIndexedFile},\n     syntax_highlighting::{\n         tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},\n         HlRange,"}, {"sha": "1b384853beb06d1759939d9c981176a3a81b7b64", "filename": "crates/ide/src/static_index.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -0,0 +1,60 @@\n+use hir::{db::HirDatabase, Crate, Module};\n+use ide_db::base_db::{FileId, SourceDatabaseExt};\n+use ide_db::RootDatabase;\n+use rustc_hash::FxHashSet;\n+\n+use crate::{Analysis, Cancellable, Fold};\n+\n+/// A static representation of fully analyzed source code.\n+///\n+/// The intended use-case is powering read-only code browsers and emitting LSIF\n+pub struct StaticIndex {\n+    pub files: Vec<StaticIndexedFile>,\n+}\n+\n+pub struct StaticIndexedFile {\n+    pub file_id: FileId,\n+    pub folds: Vec<Fold>,\n+}\n+\n+fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {\n+    let mut worklist: Vec<_> =\n+        Crate::all(db).into_iter().map(|krate| krate.root_module(db)).collect();\n+    let mut modules = Vec::new();\n+\n+    while let Some(module) = worklist.pop() {\n+        modules.push(module);\n+        worklist.extend(module.children(db));\n+    }\n+\n+    modules\n+}\n+\n+impl StaticIndex {\n+    pub fn compute(db: &RootDatabase, analysis: &Analysis) -> Cancellable<StaticIndex> {\n+        let work = all_modules(db).into_iter().filter(|module| {\n+            let file_id = module.definition_source(db).file_id.original_file(db);\n+            let source_root = db.file_source_root(file_id);\n+            let source_root = db.source_root(source_root);\n+            !source_root.is_library\n+        });\n+\n+        let mut visited_files = FxHashSet::default();\n+        let mut result_files = Vec::<StaticIndexedFile>::new();\n+        for module in work {\n+            let file_id = module.definition_source(db).file_id.original_file(db);\n+            if !visited_files.contains(&file_id) {\n+                //let path = vfs.file_path(file_id);\n+                //let path = path.as_path().unwrap();\n+                //let doc_id = lsif.add(Element::Vertex(Vertex::Document(Document {\n+                //    language_id: Language::Rust,\n+                //    uri: lsp_types::Url::from_file_path(path).unwrap(),\n+                //})));\n+                let folds = analysis.folding_ranges(file_id)?;\n+                result_files.push(StaticIndexedFile { file_id, folds });\n+                visited_files.insert(file_id);\n+            }\n+        }\n+        Ok(StaticIndex { files: result_files })\n+    }\n+}"}, {"sha": "74c041020be1e9deef084c2b4a99457062a0307d", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -87,6 +87,7 @@ fn try_main() -> Result<()> {\n         flags::RustAnalyzerCmd::Diagnostics(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Ssr(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Search(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::Lsif(cmd) => cmd.run()?,\n     }\n     Ok(())\n }"}, {"sha": "6ccdaa86dd628786d33a9142e3b199f2dbd5bfa2", "filename": "crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -8,6 +8,7 @@ mod highlight;\n mod analysis_stats;\n mod diagnostics;\n mod ssr;\n+mod lsif;\n \n mod progress_report;\n "}, {"sha": "55a542c3c16d50752d3ccd3655b7ecccdfdffc03", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -367,8 +367,6 @@ fn expr_syntax_range(\n ) -> Option<(VfsPath, LineCol, LineCol)> {\n     let src = sm.expr_syntax(expr_id);\n     if let Ok(src) = src {\n-        // FIXME: it might be nice to have a function (on Analysis?) that goes from Source<T> -> (LineCol, LineCol) directly\n-        // But also, we should just turn the type mismatches into diagnostics and provide these\n         let root = db.parse_or_expand(src.file_id).unwrap();\n         let node = src.map(|e| e.to_node(&root).syntax().clone());\n         let original_range = node.as_ref().original_file_range(db);"}, {"sha": "b759d912c968b437fff810fe99cd761282db59e9", "filename": "crates/rust-analyzer/src/cli/flags.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -102,6 +102,10 @@ xflags::xflags! {\n         }\n \n         cmd proc-macro {}\n+\n+        cmd lsif\n+            required path: PathBuf\n+        {}\n     }\n }\n \n@@ -129,6 +133,7 @@ pub enum RustAnalyzerCmd {\n     Ssr(Ssr),\n     Search(Search),\n     ProcMacro(ProcMacro),\n+    Lsif(Lsif),\n }\n \n #[derive(Debug)]\n@@ -190,6 +195,11 @@ pub struct Search {\n #[derive(Debug)]\n pub struct ProcMacro;\n \n+#[derive(Debug)]\n+pub struct Lsif {\n+    pub path: PathBuf,\n+}\n+\n impl RustAnalyzer {\n     pub const HELP: &'static str = Self::HELP_;\n "}, {"sha": "fbd5b642a6b05dfc6176129322aba2e546707d3a", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -0,0 +1,116 @@\n+//! Lsif generator\n+\n+use std::env;\n+\n+use ide::{StaticIndex, StaticIndexedFile};\n+use ide_db::LineIndexDatabase;\n+\n+use ide_db::base_db::salsa::{self, ParallelDatabase};\n+use lsp_types::NumberOrString;\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n+use vfs::AbsPathBuf;\n+\n+use crate::cli::lsif::lsif_types::{Document, Vertex};\n+use crate::cli::{\n+    flags,\n+    load_cargo::{load_workspace, LoadCargoConfig},\n+    Result,\n+};\n+use crate::line_index::LineIndex;\n+use crate::to_proto;\n+\n+/// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n+struct Snap<DB>(DB);\n+impl<DB: ParallelDatabase> Clone for Snap<salsa::Snapshot<DB>> {\n+    fn clone(&self) -> Snap<salsa::Snapshot<DB>> {\n+        Snap(self.0.snapshot())\n+    }\n+}\n+\n+mod lsif_types;\n+use lsif_types::*;\n+\n+#[derive(Default)]\n+struct LsifManager {\n+    count: i32,\n+}\n+\n+#[derive(Clone, Copy)]\n+struct Id(i32);\n+\n+impl From<Id> for NumberOrString {\n+    fn from(Id(x): Id) -> Self {\n+        NumberOrString::Number(x)\n+    }\n+}\n+\n+impl LsifManager {\n+    fn add(&mut self, data: Element) -> Id {\n+        let id = Id(self.count);\n+        self.emit(&serde_json::to_string(&Entry { id: id.into(), data }).unwrap());\n+        self.count += 1;\n+        id\n+    }\n+\n+    // FIXME: support file in addition to stdout here\n+    fn emit(&self, data: &str) {\n+        println!(\"{}\", data);\n+    }\n+}\n+\n+impl flags::Lsif {\n+    pub fn run(self) -> Result<()> {\n+        let cargo_config = CargoConfig::default();\n+        let no_progress = &|_| ();\n+        let load_cargo_config = LoadCargoConfig {\n+            load_out_dirs_from_check: true,\n+            with_proc_macro: true,\n+            prefill_caches: false,\n+        };\n+        let path = AbsPathBuf::assert(env::current_dir()?.join(&self.path));\n+        let manifest = ProjectManifest::discover_single(&path)?;\n+\n+        let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n+\n+        let (host, vfs, _proc_macro) = load_workspace(workspace, &load_cargo_config)?;\n+        let db = host.raw_database();\n+        let analysis = host.analysis();\n+\n+        let si = StaticIndex::compute(db, &analysis)?;\n+\n+        let mut lsif = LsifManager::default();\n+        lsif.add(Element::Vertex(Vertex::MetaData {\n+            version: String::from(\"0.5.0\"),\n+            project_root: lsp_types::Url::from_file_path(path).unwrap(),\n+            position_encoding: Encoding::Utf16,\n+            tool_info: None,\n+        }));\n+        for StaticIndexedFile { file_id, folds } in si.files {\n+            let path = vfs.file_path(file_id);\n+            let path = path.as_path().unwrap();\n+            let doc_id = lsif.add(Element::Vertex(Vertex::Document(Document {\n+                language_id: Language::Rust,\n+                uri: lsp_types::Url::from_file_path(path).unwrap(),\n+            })));\n+            let text = analysis.file_text(file_id)?;\n+            let line_index = db.line_index(file_id);\n+            let result = folds\n+                .into_iter()\n+                .map(|it| {\n+                    to_proto::folding_range(\n+                        &*text,\n+                        &LineIndex::with_default_options(line_index.clone()),\n+                        false,\n+                        it,\n+                    )\n+                })\n+                .collect();\n+            let folding_id = lsif.add(Element::Vertex(Vertex::FoldingRangeResult { result }));\n+            lsif.add(Element::Edge(Edge::FoldingRange(EdgeData {\n+                in_v: folding_id.into(),\n+                out_v: doc_id.into(),\n+            })));\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "bd29fd3ad8fba3973fffe3a12ef1cdbfa377cd22", "filename": "crates/rust-analyzer/src/cli/lsif/lsif_types.rs", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif%2Flsif_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif%2Flsif_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif%2Flsif_types.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -0,0 +1,354 @@\n+use lsp_types::FoldingRange;\n+use serde::{Deserialize, Serialize};\n+\n+pub(crate) type RangeId = lsp_types::NumberOrString;\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(untagged)]\n+pub(crate) enum LocationOrRangeId {\n+    Location(lsp_types::Location),\n+    RangeId(RangeId),\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct Entry {\n+    pub(crate) id: lsp_types::NumberOrString,\n+    #[serde(flatten)]\n+    pub(crate) data: Element,\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+#[serde(tag = \"type\")]\n+pub(crate) enum Element {\n+    Vertex(Vertex),\n+    Edge(Edge),\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+pub(crate) struct ToolInfo {\n+    name: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    args: Option<Vec<String>>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    version: Option<String>,\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+pub(crate) enum Encoding {\n+    /// Currently only 'utf-16' is supported due to the limitations in LSP.\n+    #[serde(rename = \"utf-16\")]\n+    Utf16,\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+#[serde(tag = \"label\")]\n+pub(crate) enum Vertex {\n+    #[serde(rename_all = \"camelCase\")]\n+    MetaData {\n+        /// The version of the LSIF format using semver notation. See https://semver.org/. Please note\n+        /// the version numbers starting with 0 don't adhere to semver and adopters have to assume\n+        /// that each new version is breaking.\n+        version: String,\n+\n+        /// The project root (in form of an URI) used to compute this dump.\n+        project_root: lsp_types::Url,\n+\n+        /// The string encoding used to compute line and character values in\n+        /// positions and ranges.\n+        position_encoding: Encoding,\n+\n+        /// Information about the tool that created the dump\n+        #[serde(skip_serializing_if = \"Option::is_none\")]\n+        tool_info: Option<ToolInfo>,\n+    },\n+    /// https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#the-project-vertex\n+    Project(Project),\n+    Document(Document),\n+    /// https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#ranges\n+    Range(lsp_types::Range),\n+    /// https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#result-set\n+    ResultSet(ResultSet),\n+\n+    // FIXME: support all kind of results\n+    DefinitionResult {\n+        result: DefinitionResultType,\n+    },\n+    FoldingRangeResult {\n+        result: Vec<FoldingRange>,\n+    },\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+#[serde(tag = \"label\")]\n+pub(crate) enum Edge {\n+    Contains(EdgeData),\n+    RefersTo(EdgeData),\n+    Item(Item),\n+\n+    // Methods\n+    #[serde(rename = \"textDocument/definition\")]\n+    Definition(EdgeData),\n+    #[serde(rename = \"textDocument/declaration\")]\n+    Declaration(EdgeData),\n+    #[serde(rename = \"textDocument/hover\")]\n+    Hover(EdgeData),\n+    #[serde(rename = \"textDocument/references\")]\n+    References(EdgeData),\n+    #[serde(rename = \"textDocument/implementation\")]\n+    Implementation(EdgeData),\n+    #[serde(rename = \"textDocument/typeDefinition\")]\n+    TypeDefinition(EdgeData),\n+    #[serde(rename = \"textDocument/foldingRange\")]\n+    FoldingRange(EdgeData),\n+    #[serde(rename = \"textDocument/documentLink\")]\n+    DocumentLink(EdgeData),\n+    #[serde(rename = \"textDocument/documentSymbol\")]\n+    DocumentSymbol(EdgeData),\n+    #[serde(rename = \"textDocument/diagnostic\")]\n+    Diagnostic(EdgeData),\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct EdgeData {\n+    pub(crate) in_v: lsp_types::NumberOrString,\n+    pub(crate) out_v: lsp_types::NumberOrString,\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(untagged)]\n+pub(crate) enum DefinitionResultType {\n+    Scalar(LocationOrRangeId),\n+    Array(LocationOrRangeId),\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+#[serde(tag = \"property\")]\n+pub(crate) enum Item {\n+    Definition(EdgeData),\n+    Reference(EdgeData),\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct Document {\n+    pub(crate) uri: lsp_types::Url,\n+    pub(crate) language_id: Language,\n+}\n+\n+/// https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#result-set\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct ResultSet {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    key: Option<String>,\n+}\n+\n+/// https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#the-project-vertex\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct Project {\n+    project_file: lsp_types::Url,\n+    language_id: Language,\n+}\n+\n+/// https://github.com/Microsoft/language-server-protocol/issues/213\n+/// For examples, see: https://code.visualstudio.com/docs/languages/identifiers.\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"lowercase\")]\n+pub(crate) enum Language {\n+    Rust,\n+    TypeScript,\n+    #[serde(other)]\n+    Other,\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn metadata() {\n+        let data = Entry {\n+            id: lsp_types::NumberOrString::Number(1),\n+            data: Element::Vertex(Vertex::MetaData {\n+                version: String::from(\"0.4.3\"),\n+                project_root: lsp_types::Url::from_file_path(\"/hello/world\").unwrap(),\n+                position_encoding: Encoding::Utf16,\n+                tool_info: Some(ToolInfo {\n+                    name: String::from(\"lsif-tsc\"),\n+                    args: Some(vec![String::from(\"-p\"), String::from(\".\")]),\n+                    version: Some(String::from(\"0.7.2\")),\n+                }),\n+            }),\n+        };\n+        let text = r#\"{\"id\":1,\"type\":\"vertex\",\"label\":\"metaData\",\"version\":\"0.4.3\",\"projectRoot\":\"file:///hello/world\",\"positionEncoding\":\"utf-16\",\"toolInfo\":{\"name\":\"lsif-tsc\",\"args\":[\"-p\",\".\"],\"version\":\"0.7.2\"}}\"#\n+            .replace(' ', \"\");\n+        assert_eq!(serde_json::to_string(&data).unwrap(), text);\n+        assert_eq!(serde_json::from_str::<Entry>(&text).unwrap(), data);\n+    }\n+\n+    #[test]\n+    fn document() {\n+        let data = Entry {\n+            id: lsp_types::NumberOrString::Number(1),\n+            data: Element::Vertex(Vertex::Document(Document {\n+                uri: lsp_types::Url::from_file_path(\"/Users/dirkb/sample.ts\").unwrap(),\n+                language_id: Language::TypeScript,\n+            })),\n+        };\n+\n+        let text = r#\"{ \"id\": 1, \"type\": \"vertex\", \"label\": \"document\", \"uri\": \"file:///Users/dirkb/sample.ts\", \"languageId\": \"typescript\" }\"#\n+            .replace(' ', \"\");\n+\n+        assert_eq!(serde_json::to_string(&data).unwrap(), text);\n+        assert_eq!(serde_json::from_str::<Entry>(&text).unwrap(), data);\n+    }\n+\n+    #[test]\n+    fn range() {\n+        let data = Entry {\n+            id: lsp_types::NumberOrString::Number(4),\n+            data: Element::Vertex(Vertex::Range(lsp_types::Range::new(\n+                lsp_types::Position::new(0, 9),\n+                lsp_types::Position::new(0, 12),\n+            ))),\n+        };\n+\n+        let text = r#\"{ \"id\": 4, \"type\": \"vertex\", \"label\": \"range\", \"start\": { \"line\": 0, \"character\": 9}, \"end\": { \"line\": 0, \"character\": 12 } }\"#\n+            .replace(' ', \"\");\n+\n+        assert_eq!(serde_json::to_string(&data).unwrap(), text);\n+        assert_eq!(serde_json::from_str::<Entry>(&text).unwrap(), data);\n+    }\n+\n+    #[test]\n+    fn contains() {\n+        let data = Entry {\n+            id: lsp_types::NumberOrString::Number(5),\n+            data: Element::Edge(Edge::Contains(EdgeData {\n+                in_v: lsp_types::NumberOrString::Number(4),\n+                out_v: lsp_types::NumberOrString::Number(1),\n+            })),\n+        };\n+\n+        let text = r#\"{ \"id\": 5, \"type\": \"edge\", \"label\": \"contains\", \"outV\": 1, \"inV\": 4}\"#\n+            .replace(' ', \"\");\n+\n+        assert_eq!(\n+            serde_json::from_str::<serde_json::Value>(&text).unwrap(),\n+            serde_json::to_value(&data).unwrap()\n+        );\n+    }\n+\n+    #[test]\n+    fn refers_to() {\n+        let data = Entry {\n+            id: lsp_types::NumberOrString::Number(5),\n+            data: Element::Edge(Edge::RefersTo(EdgeData {\n+                in_v: lsp_types::NumberOrString::Number(2),\n+                out_v: lsp_types::NumberOrString::Number(3),\n+            })),\n+        };\n+\n+        let text = r#\"{ \"id\": 5, \"type\": \"edge\", \"label\": \"refersTo\", \"outV\": 3, \"inV\": 2}\"#\n+            .replace(' ', \"\");\n+\n+        assert_eq!(\n+            serde_json::from_str::<serde_json::Value>(&text).unwrap(),\n+            serde_json::to_value(&data).unwrap()\n+        );\n+    }\n+\n+    #[test]\n+    fn result_set() {\n+        let data = Entry {\n+            id: lsp_types::NumberOrString::Number(2),\n+            data: Element::Vertex(Vertex::ResultSet(ResultSet { key: None })),\n+        };\n+\n+        let text = r#\"{ \"id\": 2, \"type\": \"vertex\", \"label\": \"resultSet\" }\"#.replace(' ', \"\");\n+\n+        assert_eq!(serde_json::to_string(&data).unwrap(), text);\n+        assert_eq!(serde_json::from_str::<Entry>(&text).unwrap(), data);\n+\n+        let data = Entry {\n+            id: lsp_types::NumberOrString::Number(4),\n+            data: Element::Vertex(Vertex::ResultSet(ResultSet {\n+                key: Some(String::from(\"hello\")),\n+            })),\n+        };\n+\n+        let text = r#\"{ \"id\": 4, \"type\": \"vertex\", \"label\": \"resultSet\", \"key\": \"hello\" }\"#\n+            .replace(' ', \"\");\n+\n+        assert_eq!(serde_json::to_string(&data).unwrap(), text);\n+        assert_eq!(serde_json::from_str::<Entry>(&text).unwrap(), data);\n+    }\n+\n+    #[test]\n+    fn definition() {\n+        let data = Entry {\n+            id: lsp_types::NumberOrString::Number(21),\n+            data: Element::Edge(Edge::Item(Item::Definition(EdgeData {\n+                in_v: lsp_types::NumberOrString::Number(18),\n+                out_v: lsp_types::NumberOrString::Number(16),\n+            }))),\n+        };\n+\n+        let text = r#\"{ \"id\": 21, \"type\": \"edge\", \"label\": \"item\", \"property\": \"definition\", \"outV\": 16, \"inV\": 18}\"#\n+            .replace(' ', \"\");\n+\n+        assert_eq!(\n+            serde_json::from_str::<serde_json::Value>(&text).unwrap(),\n+            serde_json::to_value(&data).unwrap()\n+        );\n+    }\n+\n+    mod methods {\n+        use super::*;\n+\n+        #[test]\n+        fn references() {\n+            let data = Entry {\n+                id: lsp_types::NumberOrString::Number(17),\n+                data: Element::Edge(Edge::References(EdgeData {\n+                    in_v: lsp_types::NumberOrString::Number(16),\n+                    out_v: lsp_types::NumberOrString::Number(15),\n+                })),\n+            };\n+\n+            let text = r#\"{ \"id\": 17, \"type\": \"edge\", \"label\": \"textDocument/references\", \"outV\": 15, \"inV\": 16 }\"#;\n+\n+            assert_eq!(\n+                serde_json::from_str::<serde_json::Value>(&text).unwrap(),\n+                serde_json::to_value(&data).unwrap()\n+            );\n+        }\n+\n+        #[test]\n+        fn definition() {\n+            let data = Entry {\n+                id: lsp_types::NumberOrString::Number(13),\n+                data: Element::Vertex(Vertex::DefinitionResult {\n+                    result: DefinitionResultType::Scalar(LocationOrRangeId::RangeId(\n+                        lsp_types::NumberOrString::Number(7),\n+                    )),\n+                }),\n+            };\n+\n+            let text =\n+                r#\"{ \"id\": 13, \"type\": \"vertex\", \"label\": \"definitionResult\", \"result\": 7 }\"#;\n+\n+            assert_eq!(\n+                serde_json::from_str::<serde_json::Value>(&text).unwrap(),\n+                serde_json::to_value(&data).unwrap()\n+            );\n+        }\n+    }\n+}"}, {"sha": "6d46171cc3ab8579699a24c12a854dd8316d8218", "filename": "crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557210a68839286ebafa1e1565b978566b38a6f1/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=557210a68839286ebafa1e1565b978566b38a6f1", "patch": "@@ -18,6 +18,12 @@ pub(crate) struct LineIndex {\n     pub(crate) encoding: OffsetEncoding,\n }\n \n+impl LineIndex {\n+    pub(crate) fn with_default_options(index: Arc<ide::LineIndex>) -> Self {\n+        Self { index, endings: LineEndings::Unix, encoding: OffsetEncoding::Utf8 }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub(crate) enum LineEndings {\n     Unix,"}]}