{"sha": "2f91ba05fd930e003bb17b763a32382cfe4392a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmOTFiYTA1ZmQ5MzBlMDAzYmIxN2I3NjNhMzIzODJjZmU0MzkyYTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-09-02T11:50:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-09-06T15:18:10Z"}, "message": "implement a debugging \"shadow graph\"\n\nThe shadow graph supercedes the existing code that checked for\nreads/writes without an active task and now adds the ability\nto filter for specific edges.", "tree": {"sha": "7507f91d061ec523fa0dcb998ee1eef69ff8b4f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7507f91d061ec523fa0dcb998ee1eef69ff8b4f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f91ba05fd930e003bb17b763a32382cfe4392a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f91ba05fd930e003bb17b763a32382cfe4392a8", "html_url": "https://github.com/rust-lang/rust/commit/2f91ba05fd930e003bb17b763a32382cfe4392a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f91ba05fd930e003bb17b763a32382cfe4392a8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c2f3ff44263b813d4211150613edff0c5c92c30", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2f3ff44263b813d4211150613edff0c5c92c30", "html_url": "https://github.com/rust-lang/rust/commit/4c2f3ff44263b813d4211150613edff0c5c92c30"}], "stats": {"total": 204, "additions": 176, "deletions": 28}, "files": [{"sha": "48f5b7ea2595d70c37eef2066452456661c10d4e", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=2f91ba05fd930e003bb17b763a32382cfe4392a8", "patch": "@@ -341,6 +341,8 @@ path is found (as demonstrated above).\n \n ### Debugging the dependency graph\n \n+#### Dumping the graph\n+\n The compiler is also capable of dumping the dependency graph for your\n debugging pleasure. To do so, pass the `-Z dump-dep-graph` flag. The\n graph will be dumped to `dep_graph.{txt,dot}` in the current\n@@ -392,6 +394,35 @@ This will dump out all the nodes that lead from `Hir(foo)` to\n `TypeckItemBody(bar)`, from which you can (hopefully) see the source\n of the erroneous edge.\n \n+#### Tracking down incorrect edges\n+\n+Sometimes, after you dump the dependency graph, you will find some\n+path that should not exist, but you will not be quite sure how it came\n+to be. **When the compiler is built with debug assertions,** it can\n+help you track that down. Simply set the `RUST_FORBID_DEP_GRAPH_EDGE`\n+environment variable to a filter. Every edge created in the dep-graph\n+will be tested against that filter -- if it matches, a `bug!` is\n+reported, so you can easily see the backtrace (`RUST_BACKTRACE=1`).\n+\n+The syntax for these filters is the same as described in the previous\n+section. However, note that this filter is applied to every **edge**\n+and doesn't handle longer paths in the graph, unlike the previous\n+section.\n+\n+Example:\n+\n+You find that there is a path from the `Hir` of `foo` to the type\n+check of `bar` and you don't think there should be. You dump the\n+dep-graph as described in the previous section and open `dep-graph.txt`\n+to see something like:\n+\n+    Hir(foo) -> Collect(bar)\n+    Collect(bar) -> TypeckItemBody(bar)\n+    \n+That first edge looks suspicious to you. So you set\n+`RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n+then observe the backtrace. Voila, bug fixed!\n+\n ### Inlining of HIR nodes\n \n For the time being, at least, we still sometimes \"inline\" HIR nodes"}, {"sha": "5b15c5e67174e2d1618495cbc0449b8aaef79591", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=2f91ba05fd930e003bb17b763a32382cfe4392a8", "patch": "@@ -66,4 +66,11 @@ impl EdgeFilter {\n             })\n         }\n     }\n+\n+    pub fn test<D: Clone + Debug>(&self,\n+                                  source: &DepNode<D>,\n+                                  target: &DepNode<D>)\n+                                  -> bool {\n+        self.source.test(source) && self.target.test(target)\n+    }\n }"}, {"sha": "9c00e95c17e05f9078405da28e443cc95d026ff1", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=2f91ba05fd930e003bb17b763a32382cfe4392a8", "patch": "@@ -15,6 +15,7 @@ mod edges;\n mod graph;\n mod query;\n mod raii;\n+mod shadow;\n mod thread;\n mod visit;\n "}, {"sha": "e038997e0ad428f6ce69fd9ac63446b56a7783ea", "filename": "src/librustc/dep_graph/shadow.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=2f91ba05fd930e003bb17b763a32382cfe4392a8", "patch": "@@ -0,0 +1,123 @@\n+//! The \"Shadow Graph\" is maintained on the main thread and which\n+//! tracks each message relating to the dep-graph and applies some\n+//! sanity checks as they go by. If an error results, it means you get\n+//! a nice stack-trace telling you precisely what caused the error.\n+//!\n+//! NOTE: This is a debugging facility which can potentially have non-trivial\n+//! runtime impact. Therefore, it is largely compiled out if\n+//! debug-assertions are not enabled.\n+//!\n+//! The basic sanity check, always enabled, is that there is always a\n+//! task (or ignore) on the stack when you do read/write.\n+//!\n+//! Optionally, if you specify RUST_FORBID_DEP_GRAPH_EDGE, you can\n+//! specify an edge filter to be applied to each edge as it is\n+//! created.  See `./README.md` for details.\n+\n+use hir::def_id::DefId;\n+use std::cell::{BorrowState, RefCell};\n+use std::env;\n+\n+use super::DepNode;\n+use super::thread::DepMessage;\n+use super::debug::EdgeFilter;\n+\n+pub struct ShadowGraph {\n+    // if you push None onto the stack, that corresponds to an Ignore\n+    stack: RefCell<Vec<Option<DepNode<DefId>>>>,\n+    forbidden_edge: Option<EdgeFilter>,\n+}\n+\n+const ENABLED: bool = cfg!(debug_assertions);\n+\n+impl ShadowGraph {\n+    pub fn new() -> Self {\n+        let forbidden_edge = if !ENABLED {\n+            None\n+        } else {\n+            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+                Ok(s) => {\n+                    match EdgeFilter::new(&s) {\n+                        Ok(f) => Some(f),\n+                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+                    }\n+                }\n+                Err(_) => None,\n+            }\n+        };\n+\n+        ShadowGraph {\n+            stack: RefCell::new(vec![]),\n+            forbidden_edge: forbidden_edge,\n+        }\n+    }\n+\n+    pub fn enqueue(&self, message: &DepMessage) {\n+        if ENABLED {\n+            match self.stack.borrow_state() {\n+                BorrowState::Unused => {}\n+                _ => {\n+                    // When we apply edge filters, that invokes the\n+                    // Debug trait on DefIds, which in turn reads from\n+                    // various bits of state and creates reads! Ignore\n+                    // those recursive reads.\n+                    return;\n+                }\n+            }\n+\n+            let mut stack = self.stack.borrow_mut();\n+            match *message {\n+                DepMessage::Read(ref n) => self.check_edge(Some(Some(n)), top(&stack)),\n+                DepMessage::Write(ref n) => self.check_edge(top(&stack), Some(Some(n))),\n+                DepMessage::PushTask(ref n) => stack.push(Some(n.clone())),\n+                DepMessage::PushIgnore => stack.push(None),\n+                DepMessage::PopTask(_) |\n+                DepMessage::PopIgnore => {\n+                    // we could easily check that the stack is\n+                    // well-formed here, but since we use closures and\n+                    // RAII accessors, this bug basically never\n+                    // happens, so it seems not worth the overhead\n+                    stack.pop();\n+                }\n+                DepMessage::Query => (),\n+            }\n+        }\n+    }\n+\n+    fn check_edge(&self,\n+                  source: Option<Option<&DepNode<DefId>>>,\n+                  target: Option<Option<&DepNode<DefId>>>) {\n+        assert!(ENABLED);\n+        match (source, target) {\n+            // cannot happen, one side is always Some(Some(_))\n+            (None, None) => unreachable!(),\n+\n+            // nothing on top of the stack\n+            (None, Some(n)) | (Some(n), None) => bug!(\"read/write of {:?} but no current task\", n),\n+\n+            // this corresponds to an Ignore being top of the stack\n+            (Some(None), _) | (_, Some(None)) => (),\n+\n+            // a task is on top of the stack\n+            (Some(Some(source)), Some(Some(target))) => {\n+                if let Some(ref forbidden_edge) = self.forbidden_edge {\n+                    if forbidden_edge.test(source, target) {\n+                        bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Do a little juggling: we get back a reference to an option at the\n+// top of the stack, convert it to an optional reference.\n+fn top<'s>(stack: &'s Vec<Option<DepNode<DefId>>>) -> Option<Option<&'s DepNode<DefId>>> {\n+    stack.last()\n+        .map(|n: &'s Option<DepNode<DefId>>| -> Option<&'s DepNode<DefId>> {\n+            // (*)\n+            // (*) type annotation just there to clarify what would\n+            // otherwise be some *really* obscure code\n+            n.as_ref()\n+        })\n+}"}, {"sha": "90c42d66b7adfea37a5a24548838683fa2b3f935", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=2f91ba05fd930e003bb17b763a32382cfe4392a8", "patch": "@@ -20,13 +20,13 @@\n \n use hir::def_id::DefId;\n use rustc_data_structures::veccell::VecCell;\n-use std::cell::Cell;\n use std::sync::mpsc::{self, Sender, Receiver};\n use std::thread;\n \n use super::DepGraphQuery;\n use super::DepNode;\n use super::edges::DepGraphEdges;\n+use super::shadow::ShadowGraph;\n \n #[derive(Debug)]\n pub enum DepMessage {\n@@ -42,12 +42,16 @@ pub enum DepMessage {\n pub struct DepGraphThreadData {\n     enabled: bool,\n \n-    // Local counter that just tracks how many tasks are pushed onto the\n-    // stack, so that we still get an error in the case where one is\n-    // missing. If dep-graph construction is enabled, we'd get the same\n-    // error when processing tasks later on, but that's annoying because\n-    // it lacks precision about the source of the error.\n-    tasks_pushed: Cell<usize>,\n+    // The \"shadow graph\" is a debugging aid. We give it each message\n+    // in real time as it arrives and it checks for various errors\n+    // (for example, a read/write when there is no current task; it\n+    // can also apply user-defined filters; see `shadow` module for\n+    // details). This only occurs if debug-assertions are enabled.\n+    //\n+    // Note that in some cases the same errors will occur when the\n+    // data is processed off the main thread, but that's annoying\n+    // because it lacks precision about the source of the error.\n+    shadow_graph: ShadowGraph,\n \n     // current buffer, where we accumulate messages\n     messages: VecCell<DepMessage>,\n@@ -76,7 +80,7 @@ impl DepGraphThreadData {\n \n         DepGraphThreadData {\n             enabled: enabled,\n-            tasks_pushed: Cell::new(0),\n+            shadow_graph: ShadowGraph::new(),\n             messages: VecCell::with_capacity(INITIAL_CAPACITY),\n             swap_in: rx2,\n             swap_out: tx1,\n@@ -118,21 +122,7 @@ impl DepGraphThreadData {\n     /// the buffer is full, this may swap.)\n     #[inline]\n     pub fn enqueue(&self, message: DepMessage) {\n-        // Regardless of whether dep graph construction is enabled, we\n-        // still want to check that we always have a valid task on the\n-        // stack when a read/write/etc event occurs.\n-        match message {\n-            DepMessage::Read(_) | DepMessage::Write(_) =>\n-                if self.tasks_pushed.get() == 0 {\n-                    self.invalid_message(\"read/write but no current task\")\n-                },\n-            DepMessage::PushTask(_) | DepMessage::PushIgnore =>\n-                self.tasks_pushed.set(self.tasks_pushed.get() + 1),\n-            DepMessage::PopTask(_) | DepMessage::PopIgnore =>\n-                self.tasks_pushed.set(self.tasks_pushed.get() - 1),\n-            DepMessage::Query =>\n-                (),\n-        }\n+        self.shadow_graph.enqueue(&message);\n \n         if self.enabled {\n             self.enqueue_enabled(message);\n@@ -147,11 +137,6 @@ impl DepGraphThreadData {\n             self.swap();\n         }\n     }\n-\n-    // Outline this too.\n-    fn invalid_message(&self, string: &str) {\n-        bug!(\"{}; see src/librustc/dep_graph/README.md for more information\", string)\n-    }\n }\n \n /// Definition of the depgraph thread."}, {"sha": "d2a2f8a972d96224ef23e2439b8835425474bdf3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f91ba05fd930e003bb17b763a32382cfe4392a8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2f91ba05fd930e003bb17b763a32382cfe4392a8", "patch": "@@ -24,6 +24,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]"}]}