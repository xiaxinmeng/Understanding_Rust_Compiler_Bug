{"sha": "31ac29d9899c063fdee7a78988990f2b037bef7b", "node_id": "C_kwDOAAsO6NoAKDMxYWMyOWQ5ODk5YzA2M2ZkZWU3YTc4OTg4OTkwZjJiMDM3YmVmN2I", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-17T12:41:12Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-18T07:11:15Z"}, "message": "update project to emulate a projection cache", "tree": {"sha": "c21b72577bbd2e778f8738965624c62a9dd68f6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c21b72577bbd2e778f8738965624c62a9dd68f6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ac29d9899c063fdee7a78988990f2b037bef7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ac29d9899c063fdee7a78988990f2b037bef7b", "html_url": "https://github.com/rust-lang/rust/commit/31ac29d9899c063fdee7a78988990f2b037bef7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ac29d9899c063fdee7a78988990f2b037bef7b/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a757d6ee4229bd7e022a2f3f26946cf05fddbcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a757d6ee4229bd7e022a2f3f26946cf05fddbcf", "html_url": "https://github.com/rust-lang/rust/commit/9a757d6ee4229bd7e022a2f3f26946cf05fddbcf"}], "stats": {"total": 138, "additions": 124, "deletions": 14}, "files": [{"sha": "9b7feb50537871d09d66ef7212a1aed5899095b0", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ac29d9899c063fdee7a78988990f2b037bef7b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ac29d9899c063fdee7a78988990f2b037bef7b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=31ac29d9899c063fdee7a78988990f2b037bef7b", "patch": "@@ -3,6 +3,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::{InferCtxt, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::DUMMY_SP;\n \n@@ -16,6 +17,7 @@ use super::Goal;\n /// help.\n pub(super) trait InferCtxtExt<'tcx> {\n     fn next_ty_infer(&self) -> Ty<'tcx>;\n+    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx>;\n \n     fn eq<T: ToTrace<'tcx>>(\n         &self,\n@@ -32,6 +34,12 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             span: DUMMY_SP,\n         })\n     }\n+    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n+        self.next_const_var(\n+            ty,\n+            ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span: DUMMY_SP },\n+        )\n+    }\n \n     #[instrument(level = \"debug\", skip(self, param_env), ret)]\n     fn eq<T: ToTrace<'tcx>>("}, {"sha": "435f2877fb3292bc9ac0cbd881204a9f61039162", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 115, "deletions": 13, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/31ac29d9899c063fdee7a78988990f2b037bef7b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ac29d9899c063fdee7a78988990f2b037bef7b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=31ac29d9899c063fdee7a78988990f2b037bef7b", "patch": "@@ -2,7 +2,7 @@ use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n-use super::{Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -11,19 +11,112 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{ProjectionPredicate, TypeSuperVisitable, TypeVisitor};\n use rustc_span::DUMMY_SP;\n use std::iter;\n+use std::ops::ControlFlow;\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_projection_goal(\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = self.assemble_and_evaluate_candidates(goal);\n-        self.merge_project_candidates(candidates)\n+        // To only compute normalization ones for each projection we only\n+        // normalize if the expected term is an unconstrained inference variable.\n+        //\n+        // E.g. for `<T as Trait>::Assoc = u32` we recursively compute the goal\n+        // `exists<U> <T as Trait>::Assoc = U` and then take the resulting type for\n+        // `U` and equate it with `u32`. This means that we don't need a separate\n+        // projection cache in the solver.\n+        if self.term_is_fully_unconstrained(goal) {\n+            let candidates = self.assemble_and_evaluate_candidates(goal);\n+            self.merge_project_candidates(candidates)\n+        } else {\n+            let predicate = goal.predicate;\n+            let unconstrained_rhs = match predicate.term.unpack() {\n+                ty::TermKind::Ty(_) => self.infcx.next_ty_infer().into(),\n+                ty::TermKind::Const(ct) => self.infcx.next_const_infer(ct.ty()).into(),\n+            };\n+            let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n+                projection_ty: goal.predicate.projection_ty,\n+                term: unconstrained_rhs,\n+            });\n+            let (_has_changed, normalize_certainty) =\n+                self.evaluate_goal(goal.with(self.tcx(), unconstrained_predicate))?;\n+\n+            let nested_eq_goals =\n+                self.infcx.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n+            self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n+        }\n+    }\n+\n+    /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n+    ///\n+    /// This is the case if the `term` is an inference variable in the innermost universe\n+    /// and does not occur in any other part of the predicate.\n+    fn term_is_fully_unconstrained(&self, goal: Goal<'tcx, ProjectionPredicate<'tcx>>) -> bool {\n+        let infcx = self.infcx;\n+        let term_is_infer = match goal.predicate.term.unpack() {\n+            ty::TermKind::Ty(ty) => {\n+                if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n+                    match infcx.probe_ty_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == infcx.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+            ty::TermKind::Const(ct) => {\n+                if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n+                    match self.infcx.probe_const_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == infcx.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+\n+        struct ContainsTerm<'tcx> {\n+            term: ty::Term<'tcx>,\n+        }\n+        impl<'tcx> TypeVisitor<'tcx> for ContainsTerm<'tcx> {\n+            type BreakTy = ();\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if t.needs_infer() {\n+                    if ty::Term::from(t) == self.term {\n+                        ControlFlow::BREAK\n+                    } else {\n+                        t.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            }\n+\n+            fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if c.needs_infer() {\n+                    if ty::Term::from(c) == self.term {\n+                        ControlFlow::BREAK\n+                    } else {\n+                        c.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            }\n+        }\n+\n+        let mut visitor = ContainsTerm { term: goal.predicate.term };\n+\n+        term_is_infer\n+            && goal.predicate.projection_ty.visit_with(&mut visitor).is_continue()\n+            && goal.param_env.visit_with(&mut visitor).is_continue()\n     }\n \n     fn merge_project_candidates(\n@@ -124,14 +217,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             nested_goals.extend(where_clause_bounds);\n             let trait_ref_certainty = ecx.evaluate_all(nested_goals)?;\n \n+            // In case the associated item is hidden due to specialization, we have to\n+            // return ambiguity this would otherwise be incomplete, resulting in\n+            // unsoundness during coherence (#105782).\n             let Some(assoc_def) = fetch_eligible_assoc_item_def(\n                 ecx.infcx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n                 impl_def_id\n-            ) else {\n-                return Err(NoSolution);\n+            )? else {\n+                let certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n+                return Ok(trait_ref_certainty.unify_and(certainty));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -178,9 +275,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            let nested_goals =\n-                ecx.infcx.eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))?;\n-            let rhs_certainty = ecx.evaluate_all(nested_goals)?;\n+            // The term of our goal should be fully unconstrained, so this should never fail.\n+            //\n+            // It can however be ambiguous when the resolved type is a projection.\n+            let nested_goals = ecx\n+                .infcx\n+                .eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))\n+                .expect(\"failed to unify with unconstrained term\");\n+            let rhs_certainty =\n+                ecx.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n \n             Ok(trait_ref_certainty.unify_and(rhs_certainty))\n         })\n@@ -217,10 +320,9 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n     goal_trait_ref: ty::TraitRef<'tcx>,\n     trait_assoc_def_id: DefId,\n     impl_def_id: DefId,\n-) -> Option<LeafDef> {\n+) -> Result<Option<LeafDef>, NoSolution> {\n     let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n-        .map_err(|ErrorGuaranteed { .. }| ())\n-        .ok()?;\n+        .map_err(|ErrorGuaranteed { .. }| NoSolution)?;\n \n     let eligible = if node_item.is_final() {\n         // Non-specializable items are always projectable.\n@@ -239,5 +341,5 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n         }\n     };\n \n-    if eligible { Some(node_item) } else { None }\n+    if eligible { Ok(Some(node_item)) } else { Ok(None) }\n }"}, {"sha": "0030e9aa3e5149343098dda7c96c3989f92889ae", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ac29d9899c063fdee7a78988990f2b037bef7b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ac29d9899c063fdee7a78988990f2b037bef7b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=31ac29d9899c063fdee7a78988990f2b037bef7b", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> SearchGraph<'tcx> {\n         }\n     }\n \n-    /// We cannot simply store the result of [EvalCtxt::compute_goal] as we have to deal with\n+    /// We cannot simply store the result of [super::EvalCtxt::compute_goal] as we have to deal with\n     /// coinductive cycles.\n     ///\n     /// When we encounter a coinductive cycle, we have to prove the final result of that cycle"}]}