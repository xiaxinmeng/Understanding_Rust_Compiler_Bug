{"sha": "02134464b0ac3cb64e221fd008b8b9e6bad1d932", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMTM0NDY0YjBhYzNjYjY0ZTIyMWZkMDA4YjhiOWU2YmFkMWQ5MzI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-19T17:52:41Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-19T17:52:41Z"}, "message": "progress", "tree": {"sha": "b8706a0fa786f94f66318a3560a5ecf6a10e3f8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8706a0fa786f94f66318a3560a5ecf6a10e3f8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02134464b0ac3cb64e221fd008b8b9e6bad1d932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02134464b0ac3cb64e221fd008b8b9e6bad1d932", "html_url": "https://github.com/rust-lang/rust/commit/02134464b0ac3cb64e221fd008b8b9e6bad1d932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02134464b0ac3cb64e221fd008b8b9e6bad1d932/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3be2643cb2a64f2667fc187ed9899f291714e85a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3be2643cb2a64f2667fc187ed9899f291714e85a", "html_url": "https://github.com/rust-lang/rust/commit/3be2643cb2a64f2667fc187ed9899f291714e85a"}], "stats": {"total": 140, "additions": 135, "deletions": 5}, "files": [{"sha": "668befb4bf5fb4a8d8a1cd70d01d736952e73423", "filename": "ffi.md", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/02134464b0ac3cb64e221fd008b8b9e6bad1d932/ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/02134464b0ac3cb64e221fd008b8b9e6bad1d932/ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ffi.md?ref=02134464b0ac3cb64e221fd008b8b9e6bad1d932", "patch": "@@ -0,0 +1,45 @@\n+% Interfacing with other Languages (FFI)\n+\n+*Obviously* we'd all love to live in a **glorious** world where everything is\n+written in Rust, Rust, and More Rust. Tragically, programs have been written\n+in Not Rust for over 50 years. Crufty enterprises are doomed to\n+support ancient code bases, and greybeard programmers stuck in their ways\n+*insist* on writing programs in other languages, even to this day!\n+\n+In all seriousness, there's a myriad of reasons for your codebase to be a\n+hybrid of different languages, and Rust is well-designed to interface with\n+all of them as painlessly as possible. It does this through the tried and\n+true strategy of all languages: pretend to be C, and understand C.\n+\n+Thanks to Rust's minimal runtime and C-like semantics, this is about as\n+painless as FFI with C++. Obviously, most of Rust's features are completely\n+incompatible with other languages: tagged unions, zero-sized-types, dynamically-\n+sized types, destructors, methods, traits, references, and lifetimes are all\n+concepts that you won't be able to expose or accept in your foreign function\n+interface.\n+\n+All mapping through C will give you is functions, structs, globals, raw pointers,\n+and C-like enums. That's it. Rust's default data layouts are also incompatible\n+with the C layout. See [the section on data layout][data.html] for details.\n+Long story short: mark FFI structs and enums with `#[repr(C)]`, mark FFI\n+functions as `extern`.\n+\n+## Runtime\n+\n+Rust's runtime is sufficiently minimal that it requires *no* special handling.\n+You don't need to set anything up. You don't need to tear anything down.\n+Awesome.\n+\n+The only runtime detail you *really* need to worry about is unwinding. Rust's\n+unwinding model is not defined to be incompatible with any particular language.\n+That means that if you call Rust from another language and it unwinds into the\n+calling language, this will cause Undefined Behaviour. Similarly, if another\n+language unwinds into Rust, it will also cause Undefined Behaviour.\n+\n+Rust can't really do anything about other languages unwinding into it (FFI is unsafe\n+for a reason!), but you can be a good FFI citizen by catching panics in any\n+FFI functions you export. Rust provides `thread::catch_panic` for exactly this.\n+Unfortunately, this API is still unstable.\n+\n+## libc\n+"}, {"sha": "ebb74bd299b469e1f5e32f2b86d090e84a34da01", "filename": "lifetimes.md", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/02134464b0ac3cb64e221fd008b8b9e6bad1d932/lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/02134464b0ac3cb64e221fd008b8b9e6bad1d932/lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lifetimes.md?ref=02134464b0ac3cb64e221fd008b8b9e6bad1d932", "patch": "@@ -60,6 +60,7 @@ read-write lock.\n \n \n \n+\n ## Lifetimes\n \n Rust's static checks are managed by the *borrow checker* (borrowck), which tracks\n@@ -219,6 +220,77 @@ these are unstable due to their awkward nature and questionable utility.\n \n \n \n+\n+## Higher-Rank Lifetimes\n+\n+Generics in Rust generally allow types to be instantiated with arbitrary\n+associated lifetimes, but this fixes the lifetimes they work with once\n+instantiated. For almost all types, this is exactly the desired behaviour.\n+For example slice::Iter can work with arbitrary lifetimes, determined by the\n+slice that instantiates it. However *once* Iter is instantiated the lifetimes\n+it works with cannot be changed. It returns references that live for some\n+particular `'a`.\n+\n+However some types are more flexible than this. In particular, a single\n+instantiation of a function can process arbitrary lifetimes:\n+\n+```rust\n+fn identity(input: &u8) -> &u8 { input }\n+```\n+\n+What is *the* lifetime that identity works with? There is none. If you think\n+this is \"cheating\" because functions are statically instantiated, then you need\n+only consider the equivalent closure:\n+\n+```rust\n+let identity = |input: &u8| input;\n+```\n+\n+These functions are *higher ranked* over the lifetimes they work with. This means\n+that they're generic over what they handle *after instantiation*. For most things\n+this would pose a massive problem, but because lifetimes don't *exist* at runtime,\n+this is really just a compile-time mechanism. The Fn traits contain sugar that\n+allows higher-rank lifetimes to simply be expressed by simply omitting lifetimes:\n+\n+\n+```rust\n+fn main() {\n+    foo(|input| input);\n+}\n+\n+fn foo<F>(f: F)\n+    // F is higher-ranked over the lifetime these references have\n+    where F: Fn(&u8) -> &u8\n+{\n+    f(&0);\n+    f(&1);\n+}\n+```\n+\n+The desugaring of this is actually unstable:\n+\n+```\n+#![feature(unboxed_closures)]\n+\n+fn main() {\n+    foo(|input| input);\n+}\n+\n+fn foo<F>(f: F)\n+    where F: for<'a> Fn<(&'a u8,), Output=&'a u8>\n+{\n+    f(&0);\n+    f(&1);\n+}\n+```\n+\n+`for<'a>` is how we declare a higher-ranked lifetime. Unfortunately higher-ranked\n+lifetimes are still fairly new, and are missing a few features to make them\n+maximally useful outside of the Fn traits.\n+\n+\n+\n+\n ## Subtyping and Variance\n \n Although Rust doesn't have any notion of inheritance, it *does* include subtyping.\n@@ -227,12 +299,15 @@ from scopes, we can partially order them based on an *outlives* relationship. We\n can even express this as a generic bound: `T: 'a` specifies that `T` *outlives* `'a`.\n \n We can then define subtyping on lifetimes in terms of lifetimes: `'a : 'b` implies\n-`'a <: b` -- if `'a' outlives `'b`, then `'a` is a subtype of `'b`. This is a very\n+`'a <: b` -- if `'a` outlives `'b`, then `'a` is a subtype of `'b`. This is a very\n large source of confusion, because a bigger scope is a *sub type* of a smaller scope.\n This does in fact make sense. The intuitive reason for this is that if you expect an\n `&'a u8`, then it's totally fine for me to hand you an `&'static u8`, in the same way\n that if you expect an Animal in Java, it's totally fine for me to hand you a Cat.\n \n+(Note, the subtyping relationship and typed-ness of lifetimes is a fairly arbitrary\n+construct that some disagree with. I just find that it simplifies this analysis.)\n+\n Variance is where things get really harsh.\n \n Variance is a property that *type constructors* have. A type constructor in Rust\n@@ -278,7 +353,7 @@ fn overwrite<T: Copy>(input: &mut T, new: &mut T) {\n \n The signature of `overwrite` is clearly valid: it takes mutable references to two values\n of the same type, and replaces one with the other. We have seen already that `&` is\n-covariant, and `'static` is a subtype of *any* `'a', so `&'static str` is a\n+covariant, and `'static` is a subtype of *any* `'a`, so `&'static str` is a\n subtype of `&'a str`. Therefore, if `&mut` was\n *also* covariant, then the lifetime of the `&'static str` would successfully be\n \"shrunk\" down to the shorter lifetime of the string, and `replace` would be\n@@ -341,8 +416,16 @@ respectively.\n ## PhantomData and PhantomFn\n \n This is all well and good for the types the standard library provides, but\n-how is variance determined for type that *you* define? The variance of a type\n-over its generic arguments is determined by how they're stored.\n+how is variance determined for type that *you* define? A struct is, informally\n+speaking, covariant over all its fields (and an enum over its variants). This\n+basically means that it inherits the variance of its fields. If a struct `Foo`\n+has a generic argument `A` that is used in a field `a`, then Foo's variance\n+over `A` is exactly `a`'s variance. However this is complicated if `A` is used\n+in multiple fields.\n+\n+* If all uses of A are covariant, then Foo is covariant over A\n+* If all uses of A are contravariant, then Foo is contravariant over A\n+* Otherwise, Foo is invariant over A\n \n ```rust\n struct Foo<'a, 'b, A, B, C, D, E, F, G, H> {\n@@ -360,7 +443,7 @@ struct Foo<'a, 'b, A, B, C, D, E, F, G, H> {\n \n However when working with unsafe code, we can often end up in a situation where\n types or lifetimes are logically associated with a struct, but not actually\n-reachable. This most commonly occurs with lifetimes. For instance, the `Iter`\n+part of a field. This most commonly occurs with lifetimes. For instance, the `Iter`\n for `&'a [T]` is (approximately) defined as follows:\n \n ```"}, {"sha": "8da5b78cadb40a81d0816c1e7facd60ce2bba6da", "filename": "no_std.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02134464b0ac3cb64e221fd008b8b9e6bad1d932/no_std.md", "raw_url": "https://github.com/rust-lang/rust/raw/02134464b0ac3cb64e221fd008b8b9e6bad1d932/no_std.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/no_std.md?ref=02134464b0ac3cb64e221fd008b8b9e6bad1d932", "patch": "@@ -0,0 +1,2 @@\n+% Eliminating the Runtime (no_std)\n+"}]}