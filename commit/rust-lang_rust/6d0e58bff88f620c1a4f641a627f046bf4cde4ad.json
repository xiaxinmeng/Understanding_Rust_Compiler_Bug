{"sha": "6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMGU1OGJmZjg4ZjYyMGMxYTRmNjQxYTYyN2YwNDZiZjRjZGU0YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-23T19:26:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-23T19:26:35Z"}, "message": "Auto merge of #69393 - Dylan-DPC:rollup-rxbd1zg, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #69336 (Do not ping the infrastructure team on toolstate changes)\n - #69351 (Improve external MinGW detection)\n - #69361 (parse: allow `type Foo: Ord` syntactically)\n - #69375 (Rename CodeMap to SourceMap follow up)\n - #69376 (parser: Cleanup `Parser::bump_with` and its uses)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1d68f7c1f1aadd1ce180daf6b6dd3b5d09d02972", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d68f7c1f1aadd1ce180daf6b6dd3b5d09d02972"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "html_url": "https://github.com/rust-lang/rust/commit/6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1f395de642e8be7bcbbd2bd8aaadab715851f49", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f395de642e8be7bcbbd2bd8aaadab715851f49", "html_url": "https://github.com/rust-lang/rust/commit/b1f395de642e8be7bcbbd2bd8aaadab715851f49"}, {"sha": "d6414f5f8c30593cd250fddf315e6f0098c3239a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6414f5f8c30593cd250fddf315e6f0098c3239a", "html_url": "https://github.com/rust-lang/rust/commit/d6414f5f8c30593cd250fddf315e6f0098c3239a"}], "stats": {"total": 658, "additions": 357, "deletions": 301}, "files": [{"sha": "1a9c5d1f13fe1608e23a1c385edf2ec3deeb289d", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -149,7 +149,7 @@ impl<'a> StableHashingContext<'a> {\n     #[inline]\n     pub fn source_map(&mut self) -> &mut CachingSourceMapView<'a> {\n         match self.caching_source_map {\n-            Some(ref mut cm) => cm,\n+            Some(ref mut sm) => sm,\n             ref mut none => {\n                 *none = Some(CachingSourceMapView::new(self.raw_source_map));\n                 none.as_mut().unwrap()"}, {"sha": "7b5faa2423aea80b0f2c0c398dfb85a77e3af50e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -106,10 +106,10 @@ pub fn report_unstable(\n     };\n \n     let msp: MultiSpan = span.into();\n-    let cm = &sess.parse_sess.source_map();\n+    let sm = &sess.parse_sess.source_map();\n     let span_key = msp.primary_span().and_then(|sp: Span| {\n         if !sp.is_dummy() {\n-            let file = cm.lookup_char_pos(sp.lo()).file;\n+            let file = sm.lookup_char_pos(sp.lo()).file;\n             if file.name.is_macros() { None } else { Some(span) }\n         } else {\n             None"}, {"sha": "1a19fab0265e677f7f6e15722294981f209f0728", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -297,28 +297,28 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n-            ItemKind::TyAlias(ref ty, ref generics) => match ty.kind.opaque_top_hack() {\n+            ItemKind::TyAlias(ref generics, _, Some(ref ty)) => match ty.kind.opaque_top_hack() {\n                 None => {\n                     let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                     let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n                     hir::ItemKind::TyAlias(ty, generics)\n                 }\n                 Some(bounds) => {\n+                    let ctx = || ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc);\n                     let ty = hir::OpaqueTy {\n-                        generics: self.lower_generics(\n-                            generics,\n-                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n-                        ),\n-                        bounds: self.lower_param_bounds(\n-                            bounds,\n-                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n-                        ),\n+                        generics: self.lower_generics(generics, ctx()),\n+                        bounds: self.lower_param_bounds(bounds, ctx()),\n                         impl_trait_fn: None,\n                         origin: hir::OpaqueTyOrigin::TypeAlias,\n                     };\n                     hir::ItemKind::OpaqueTy(ty)\n                 }\n             },\n+            ItemKind::TyAlias(ref generics, _, None) => {\n+                let ty = self.arena.alloc(self.ty(span, hir::TyKind::Err));\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n+                hir::ItemKind::TyAlias(ty, generics)\n+            }\n             ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n                 hir::EnumDef {\n                     variants: self.arena.alloc_from_iter("}, {"sha": "9bb46009fe64b25ed4b64a38ad3545b9a1f12c01", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     ItemKind::Struct(_, ref generics)\n                     | ItemKind::Union(_, ref generics)\n                     | ItemKind::Enum(_, ref generics)\n-                    | ItemKind::TyAlias(_, ref generics)\n+                    | ItemKind::TyAlias(ref generics, ..)\n                     | ItemKind::Trait(_, _, ref generics, ..) => {\n                         let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n                         let count = generics"}, {"sha": "a9844a7059e552f1fa9c2d7f629013cfc744d85f", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -969,6 +969,13 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 let msg = \"free static item without body\";\n                 self.error_item_without_body(item.span, \"static\", msg, \" = <expr>;\");\n             }\n+            ItemKind::TyAlias(_, ref bounds, ref body) => {\n+                if body.is_none() {\n+                    let msg = \"free type alias without body\";\n+                    self.error_item_without_body(item.span, \"type\", msg, \" = <type>;\");\n+                }\n+                self.check_type_no_bounds(bounds, \"this context\");\n+            }\n             _ => {}\n         }\n "}, {"sha": "5bddae0d49e7d83840e581059dbc37c638814f09", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -372,7 +372,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, decl_macro, i.span, msg);\n             }\n \n-            ast::ItemKind::TyAlias(ref ty, ..) => self.check_impl_trait(&ty),\n+            ast::ItemKind::TyAlias(_, _, Some(ref ty)) => self.check_impl_trait(&ty),\n \n             _ => {}\n         }"}, {"sha": "548ae6e7e63c4e47ba786d41f02b1d7e1edcd468", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -47,15 +47,15 @@ pub struct NoAnn;\n impl PpAnn for NoAnn {}\n \n pub struct Comments<'a> {\n-    cm: &'a SourceMap,\n+    sm: &'a SourceMap,\n     comments: Vec<comments::Comment>,\n     current: usize,\n }\n \n impl<'a> Comments<'a> {\n-    pub fn new(cm: &'a SourceMap, filename: FileName, input: String) -> Comments<'a> {\n-        let comments = comments::gather_comments(cm, filename, input);\n-        Comments { cm, comments, current: 0 }\n+    pub fn new(sm: &'a SourceMap, filename: FileName, input: String) -> Comments<'a> {\n+        let comments = comments::gather_comments(sm, filename, input);\n+        Comments { sm, comments, current: 0 }\n     }\n \n     pub fn next(&self) -> Option<comments::Comment> {\n@@ -71,8 +71,8 @@ impl<'a> Comments<'a> {\n             if cmnt.style != comments::Trailing {\n                 return None;\n             }\n-            let span_line = self.cm.lookup_char_pos(span.hi());\n-            let comment_line = self.cm.lookup_char_pos(cmnt.pos);\n+            let span_line = self.sm.lookup_char_pos(span.hi());\n+            let comment_line = self.sm.lookup_char_pos(cmnt.pos);\n             let next = next_pos.unwrap_or_else(|| cmnt.pos + BytePos(1));\n             if span.hi() < cmnt.pos && cmnt.pos < next && span_line.line == comment_line.line {\n                 return Some(cmnt);\n@@ -95,7 +95,7 @@ crate const INDENT_UNIT: usize = 4;\n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(\n-    cm: &'a SourceMap,\n+    sm: &'a SourceMap,\n     krate: &ast::Crate,\n     filename: FileName,\n     input: String,\n@@ -106,7 +106,7 @@ pub fn print_crate<'a>(\n ) -> String {\n     let mut s = State {\n         s: pp::mk_printer(),\n-        comments: Some(Comments::new(cm, filename, input)),\n+        comments: Some(Comments::new(sm, filename, input)),\n         ann,\n         is_expanded,\n     };\n@@ -522,8 +522,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.hardbreak();\n             }\n         }\n-        if let Some(cm) = self.comments() {\n-            cm.current += 1;\n+        if let Some(cmnts) = self.comments() {\n+            cmnts.current += 1;\n         }\n     }\n \n@@ -1185,18 +1185,10 @@ impl<'a> State<'a> {\n                 self.s.word(ga.asm.to_string());\n                 self.end();\n             }\n-            ast::ItemKind::TyAlias(ref ty, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"type\"));\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n-                self.end(); // end the inner ibox\n-\n-                self.print_where_clause(&generics.where_clause);\n-                self.s.space();\n-                self.word_space(\"=\");\n-                self.print_type(ty);\n-                self.s.word(\";\");\n-                self.end(); // end the outer ibox\n+            ast::ItemKind::TyAlias(ref generics, ref bounds, ref ty) => {\n+                let def = ast::Defaultness::Final;\n+                let ty = ty.as_deref();\n+                self.print_associated_type(item.ident, generics, bounds, ty, &item.vis, def);\n             }\n             ast::ItemKind::Enum(ref enum_definition, ref params) => {\n                 self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);"}, {"sha": "236a7243998f6a0ee0dd6f11250a9ffd6b41a344", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -452,8 +452,8 @@ pub fn print_after_hir_lowering<'tcx>(\n             call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n-                let cm = sess.source_map();\n-                *out = pprust_hir::print_crate(cm, krate, src_name, src, annotation.pp_ann())\n+                let sm = sess.source_map();\n+                *out = pprust_hir::print_crate(sm, krate, src_name, src, annotation.pp_ann())\n             })\n         }\n "}, {"sha": "1f6e268b5065fc157b9eea0a25088661924086e5", "filename": "src/librustc_errors/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_errors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_errors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fjson.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -373,13 +373,13 @@ impl DiagnosticSpan {\n \n impl DiagnosticSpanLine {\n     fn line_from_source_file(\n-        fm: &rustc_span::SourceFile,\n+        sf: &rustc_span::SourceFile,\n         index: usize,\n         h_start: usize,\n         h_end: usize,\n     ) -> DiagnosticSpanLine {\n         DiagnosticSpanLine {\n-            text: fm.get_line(index).map_or(String::new(), |l| l.into_owned()),\n+            text: sf.get_line(index).map_or(String::new(), |l| l.into_owned()),\n             highlight_start: h_start,\n             highlight_end: h_end,\n         }\n@@ -392,13 +392,13 @@ impl DiagnosticSpanLine {\n         je.sm\n             .span_to_lines(span)\n             .map(|lines| {\n-                let fm = &*lines.file;\n+                let sf = &*lines.file;\n                 lines\n                     .lines\n                     .iter()\n                     .map(|line| {\n                         DiagnosticSpanLine::line_from_source_file(\n-                            fm,\n+                            sf,\n                             line.line_index,\n                             line.start_col.0 + 1,\n                             line.end_col.0 + 1,"}, {"sha": "1a0fe3435213000aa14b28b55f426860b6b5a245", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -144,7 +144,7 @@ pub struct SubstitutionPart {\n impl CodeSuggestion {\n     /// Returns the assembled code suggestions, whether they should be shown with an underline\n     /// and whether the substitution only differs in capitalization.\n-    pub fn splice_lines(&self, cm: &SourceMap) -> Vec<(String, Vec<SubstitutionPart>, bool)> {\n+    pub fn splice_lines(&self, sm: &SourceMap) -> Vec<(String, Vec<SubstitutionPart>, bool)> {\n         use rustc_span::{CharPos, Pos};\n \n         fn push_trailing(\n@@ -176,7 +176,7 @@ impl CodeSuggestion {\n             .filter(|subst| {\n                 // Suggestions coming from macros can have malformed spans. This is a heavy\n                 // handed approach to avoid ICEs by ignoring the suggestion outright.\n-                let invalid = subst.parts.iter().any(|item| cm.is_valid_span(item.span).is_err());\n+                let invalid = subst.parts.iter().any(|item| sm.is_valid_span(item.span).is_err());\n                 if invalid {\n                     debug!(\"splice_lines: suggestion contains an invalid span: {:?}\", subst);\n                 }\n@@ -193,7 +193,7 @@ impl CodeSuggestion {\n                 let hi = substitution.parts.iter().map(|part| part.span.hi()).max()?;\n                 let bounding_span = Span::with_root_ctxt(lo, hi);\n                 // The different spans might belong to different contexts, if so ignore suggestion.\n-                let lines = cm.span_to_lines(bounding_span).ok()?;\n+                let lines = sm.span_to_lines(bounding_span).ok()?;\n                 assert!(!lines.lines.is_empty());\n \n                 // To build up the result, we do this for each span:\n@@ -205,36 +205,36 @@ impl CodeSuggestion {\n                 // - splice in the span substitution\n                 //\n                 // Finally push the trailing line segment of the last span\n-                let fm = &lines.file;\n-                let mut prev_hi = cm.lookup_char_pos(bounding_span.lo());\n+                let sf = &lines.file;\n+                let mut prev_hi = sm.lookup_char_pos(bounding_span.lo());\n                 prev_hi.col = CharPos::from_usize(0);\n \n-                let mut prev_line = fm.get_line(lines.lines[0].line_index);\n+                let mut prev_line = sf.get_line(lines.lines[0].line_index);\n                 let mut buf = String::new();\n \n                 for part in &substitution.parts {\n-                    let cur_lo = cm.lookup_char_pos(part.span.lo());\n+                    let cur_lo = sm.lookup_char_pos(part.span.lo());\n                     if prev_hi.line == cur_lo.line {\n                         push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, Some(&cur_lo));\n                     } else {\n                         push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n                         // push lines between the previous and current span (if any)\n                         for idx in prev_hi.line..(cur_lo.line - 1) {\n-                            if let Some(line) = fm.get_line(idx) {\n+                            if let Some(line) = sf.get_line(idx) {\n                                 buf.push_str(line.as_ref());\n                                 buf.push('\\n');\n                             }\n                         }\n-                        if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n+                        if let Some(cur_line) = sf.get_line(cur_lo.line - 1) {\n                             let end = std::cmp::min(cur_line.len(), cur_lo.col.to_usize());\n                             buf.push_str(&cur_line[..end]);\n                         }\n                     }\n                     buf.push_str(&part.snippet);\n-                    prev_hi = cm.lookup_char_pos(part.span.hi());\n-                    prev_line = fm.get_line(prev_hi.line - 1);\n+                    prev_hi = sm.lookup_char_pos(part.span.hi());\n+                    prev_line = sf.get_line(prev_hi.line - 1);\n                 }\n-                let only_capitalization = is_case_difference(cm, &buf, bounding_span);\n+                let only_capitalization = is_case_difference(sm, &buf, bounding_span);\n                 // if the replacement already ends with a newline, don't print the next line\n                 if !buf.ends_with('\\n') {\n                     push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n@@ -363,23 +363,23 @@ impl Handler {\n         color_config: ColorConfig,\n         can_emit_warnings: bool,\n         treat_err_as_bug: Option<usize>,\n-        cm: Option<Lrc<SourceMap>>,\n+        sm: Option<Lrc<SourceMap>>,\n     ) -> Self {\n         Self::with_tty_emitter_and_flags(\n             color_config,\n-            cm,\n+            sm,\n             HandlerFlags { can_emit_warnings, treat_err_as_bug, ..Default::default() },\n         )\n     }\n \n     pub fn with_tty_emitter_and_flags(\n         color_config: ColorConfig,\n-        cm: Option<Lrc<SourceMap>>,\n+        sm: Option<Lrc<SourceMap>>,\n         flags: HandlerFlags,\n     ) -> Self {\n         let emitter = Box::new(EmitterWriter::stderr(\n             color_config,\n-            cm,\n+            sm,\n             false,\n             false,\n             None,"}, {"sha": "c9faa299d372e0f2e2aad6f3081b02fe8365550b", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -140,13 +140,13 @@ pub const INDENT_UNIT: usize = 4;\n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(\n-    cm: &'a SourceMap,\n+    sm: &'a SourceMap,\n     krate: &hir::Crate<'_>,\n     filename: FileName,\n     input: String,\n     ann: &'a dyn PpAnn,\n ) -> String {\n-    let mut s = State::new_from_input(cm, filename, input, ann);\n+    let mut s = State::new_from_input(sm, filename, input, ann);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -158,12 +158,12 @@ pub fn print_crate<'a>(\n \n impl<'a> State<'a> {\n     pub fn new_from_input(\n-        cm: &'a SourceMap,\n+        sm: &'a SourceMap,\n         filename: FileName,\n         input: String,\n         ann: &'a dyn PpAnn,\n     ) -> State<'a> {\n-        State { s: pp::mk_printer(), comments: Some(Comments::new(cm, filename, input)), ann }\n+        State { s: pp::mk_printer(), comments: Some(Comments::new(sm, filename, input)), ann }\n     }\n }\n "}, {"sha": "008658dff425ba3c8591ebbad4b4e40eb65b1a78", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -194,7 +194,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     tcx: TyCtxt<'tcx>,\n     region: ty::Region<'tcx>,\n ) -> (String, Option<Span>) {\n-    let cm = tcx.sess.source_map();\n+    let sm = tcx.sess.source_map();\n \n     let scope = region.free_region_binding_scope(tcx);\n     let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n@@ -207,7 +207,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     };\n     let (prefix, span) = match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = cm.def_span(tcx.hir().span(node));\n+            let mut sp = sm.def_span(tcx.hir().span(node));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n@@ -216,7 +216,7 @@ fn msg_span_from_early_bound_and_free_regions(\n             (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n         }\n         ty::ReFree(ty::FreeRegion { bound_region: ty::BoundRegion::BrNamed(_, name), .. }) => {\n-            let mut sp = cm.def_span(tcx.hir().span(node));\n+            let mut sp = sm.def_span(tcx.hir().span(node));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n             {\n@@ -230,7 +230,7 @@ fn msg_span_from_early_bound_and_free_regions(\n             }\n             _ => (\n                 format!(\"the lifetime `{}` as defined on\", region),\n-                cm.def_span(tcx.hir().span(node)),\n+                sm.def_span(tcx.hir().span(node)),\n             ),\n         },\n         _ => bug!(),"}, {"sha": "3ae97ed5f88229331505f2b2d5087f648d8c6f44", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -1625,10 +1625,10 @@ impl<'a> Parser<'a> {\n         let hi = self.token.span;\n \n         if require_comma {\n-            let cm = self.sess.source_map();\n+            let sm = self.sess.source_map();\n             self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)]).map_err(\n                 |mut err| {\n-                    match (cm.span_to_lines(expr.span), cm.span_to_lines(arm_start_span)) {\n+                    match (sm.span_to_lines(expr.span), sm.span_to_lines(arm_start_span)) {\n                         (Ok(ref expr_lines), Ok(ref arm_start_lines))\n                             if arm_start_lines.lines[0].end_col == expr_lines.lines[0].end_col\n                                 && expr_lines.lines.len() == 2"}, {"sha": "328cf11c53247fc47669ed45b3d3e6516f1eee34", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -156,8 +156,7 @@ impl<'a> Parser<'a> {\n             self.parse_item_mod(attrs)?\n         } else if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n-            let (ident, ty, generics) = self.parse_type_alias()?;\n-            (ident, ItemKind::TyAlias(ty, generics))\n+            self.parse_type_alias()?\n         } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             self.parse_item_enum()?\n@@ -676,7 +675,10 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n     ) -> PResult<'a, (Ident, AssocItemKind)> {\n         if self.eat_keyword(kw::Type) {\n-            self.parse_assoc_ty()\n+            match self.parse_type_alias()? {\n+                (ident, ItemKind::TyAlias(a, b, c)) => Ok((ident, AssocItemKind::TyAlias(a, b, c))),\n+                _ => unreachable!(),\n+            }\n         } else if self.check_fn_front_matter() {\n             let (ident, sig, generics, body) = self.parse_fn(at_end, attrs, req_name)?;\n             Ok((ident, AssocItemKind::Fn(sig, generics, body)))\n@@ -700,10 +702,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses the following grammar:\n-    ///\n-    ///     AssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_assoc_ty(&mut self) -> PResult<'a, (Ident, AssocItemKind)> {\n+    /// Parses a `type` alias with the following grammar:\n+    /// ```\n+    /// TypeAlias = \"type\" Ident Generics {\":\" GenericBounds}? {\"=\" Ty}? \";\" ;\n+    /// ```\n+    /// The `\"type\"` has already been eaten.\n+    fn parse_type_alias(&mut self) -> PResult<'a, (Ident, ItemKind)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -715,7 +719,7 @@ impl<'a> Parser<'a> {\n         let default = if self.eat(&token::Eq) { Some(self.parse_ty()?) } else { None };\n         self.expect_semi()?;\n \n-        Ok((ident, AssocItemKind::TyAlias(generics, bounds, default)))\n+        Ok((ident, ItemKind::TyAlias(generics, bounds, default)))\n     }\n \n     /// Parses a `UseTree`.\n@@ -989,18 +993,6 @@ impl<'a> Parser<'a> {\n         P(Ty { kind: TyKind::Infer, span: id.span, id: ast::DUMMY_NODE_ID })\n     }\n \n-    /// Parses the grammar:\n-    ///     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n-    fn parse_type_alias(&mut self) -> PResult<'a, (Ident, P<Ty>, Generics)> {\n-        let ident = self.parse_ident()?;\n-        let mut tps = self.parse_generics()?;\n-        tps.where_clause = self.parse_where_clause()?;\n-        self.expect(&token::Eq)?;\n-        let ty = self.parse_ty()?;\n-        self.expect_semi()?;\n-        Ok((ident, ty, tps))\n-    }\n-\n     /// Parses an enum declaration.\n     fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n         let id = self.parse_ident()?;"}, {"sha": "75d4b3750f164ff53a344ac96237a092345a3c88", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 51, "deletions": 127, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -601,141 +601,76 @@ impl<'a> Parser<'a> {\n         )\n     }\n \n-    /// Expects and consumes a `+`. if `+=` is seen, replaces it with a `=`\n-    /// and continues. If a `+` is not seen, returns `false`.\n-    ///\n-    /// This is used when token-splitting `+=` into `+`.\n-    /// See issue #47856 for an example of when this may occur.\n-    fn eat_plus(&mut self) -> bool {\n-        self.expected_tokens.push(TokenType::Token(token::BinOp(token::Plus)));\n-        match self.token.kind {\n-            token::BinOp(token::Plus) => {\n-                self.bump();\n+    /// Eats the expected token if it's present possibly breaking\n+    /// compound tokens like multi-character operators in process.\n+    /// Returns `true` if the token was eaten.\n+    fn break_and_eat(&mut self, expected: TokenKind) -> bool {\n+        if self.token.kind == expected {\n+            self.bump();\n+            return true;\n+        }\n+        match self.token.kind.break_two_token_op() {\n+            Some((first, second)) if first == expected => {\n+                let first_span = self.sess.source_map().start_point(self.token.span);\n+                let second_span = self.token.span.with_lo(first_span.hi());\n+                self.set_token(Token::new(first, first_span));\n+                self.bump_with(Token::new(second, second_span));\n                 true\n             }\n-            token::BinOpEq(token::Plus) => {\n-                let start_point = self.sess.source_map().start_point(self.token.span);\n-                self.bump_with(token::Eq, self.token.span.with_lo(start_point.hi()));\n-                true\n+            _ => {\n+                self.expected_tokens.push(TokenType::Token(expected));\n+                false\n             }\n-            _ => false,\n         }\n     }\n \n-    /// Expects and consumes an `&`. If `&&` is seen, replaces it with a single\n-    /// `&` and continues. If an `&` is not seen, signals an error.\n+    /// Eats `+` possibly breaking tokens like `+=` in process.\n+    fn eat_plus(&mut self) -> bool {\n+        self.break_and_eat(token::BinOp(token::Plus))\n+    }\n+\n+    /// Eats `&` possibly breaking tokens like `&&` in process.\n+    /// Signals an error if `&` is not eaten.\n     fn expect_and(&mut self) -> PResult<'a, ()> {\n-        self.expected_tokens.push(TokenType::Token(token::BinOp(token::And)));\n-        match self.token.kind {\n-            token::BinOp(token::And) => {\n-                self.bump();\n-                Ok(())\n-            }\n-            token::AndAnd => {\n-                let start_point = self.sess.source_map().start_point(self.token.span);\n-                Ok(self\n-                    .bump_with(token::BinOp(token::And), self.token.span.with_lo(start_point.hi())))\n-            }\n-            _ => self.unexpected(),\n-        }\n+        if self.break_and_eat(token::BinOp(token::And)) { Ok(()) } else { self.unexpected() }\n     }\n \n-    /// Expects and consumes an `|`. If `||` is seen, replaces it with a single\n-    /// `|` and continues. If an `|` is not seen, signals an error.\n+    /// Eats `|` possibly breaking tokens like `||` in process.\n+    /// Signals an error if `|` was not eaten.\n     fn expect_or(&mut self) -> PResult<'a, ()> {\n-        self.expected_tokens.push(TokenType::Token(token::BinOp(token::Or)));\n-        match self.token.kind {\n-            token::BinOp(token::Or) => {\n-                self.bump();\n-                Ok(())\n-            }\n-            token::OrOr => {\n-                let start_point = self.sess.source_map().start_point(self.token.span);\n-                Ok(self\n-                    .bump_with(token::BinOp(token::Or), self.token.span.with_lo(start_point.hi())))\n-            }\n-            _ => self.unexpected(),\n-        }\n+        if self.break_and_eat(token::BinOp(token::Or)) { Ok(()) } else { self.unexpected() }\n     }\n \n-    /// Attempts to consume a `<`. If `<<` is seen, replaces it with a single\n-    /// `<` and continue. If `<-` is seen, replaces it with a single `<`\n-    /// and continue. If a `<` is not seen, returns false.\n-    ///\n-    /// This is meant to be used when parsing generics on a path to get the\n-    /// starting token.\n+    /// Eats `<` possibly breaking tokens like `<<` in process.\n     fn eat_lt(&mut self) -> bool {\n-        self.expected_tokens.push(TokenType::Token(token::Lt));\n-        let ate = match self.token.kind {\n-            token::Lt => {\n-                self.bump();\n-                true\n-            }\n-            token::BinOp(token::Shl) => {\n-                let start_point = self.sess.source_map().start_point(self.token.span);\n-                self.bump_with(token::Lt, self.token.span.with_lo(start_point.hi()));\n-                true\n-            }\n-            token::LArrow => {\n-                let start_point = self.sess.source_map().start_point(self.token.span);\n-                self.bump_with(\n-                    token::BinOp(token::Minus),\n-                    self.token.span.with_lo(start_point.hi()),\n-                );\n-                true\n-            }\n-            _ => false,\n-        };\n-\n+        let ate = self.break_and_eat(token::Lt);\n         if ate {\n             // See doc comment for `unmatched_angle_bracket_count`.\n             self.unmatched_angle_bracket_count += 1;\n             self.max_angle_bracket_count += 1;\n             debug!(\"eat_lt: (increment) count={:?}\", self.unmatched_angle_bracket_count);\n         }\n-\n         ate\n     }\n \n+    /// Eats `<` possibly breaking tokens like `<<` in process.\n+    /// Signals an error if `<` was not eaten.\n     fn expect_lt(&mut self) -> PResult<'a, ()> {\n-        if !self.eat_lt() { self.unexpected() } else { Ok(()) }\n+        if self.eat_lt() { Ok(()) } else { self.unexpected() }\n     }\n \n-    /// Expects and consumes a single `>` token. if a `>>` is seen, replaces it\n-    /// with a single `>` and continues. If a `>` is not seen, signals an error.\n+    /// Eats `>` possibly breaking tokens like `>>` in process.\n+    /// Signals an error if `>` was not eaten.\n     fn expect_gt(&mut self) -> PResult<'a, ()> {\n-        self.expected_tokens.push(TokenType::Token(token::Gt));\n-        let ate = match self.token.kind {\n-            token::Gt => {\n-                self.bump();\n-                Some(())\n-            }\n-            token::BinOp(token::Shr) => {\n-                let start_point = self.sess.source_map().start_point(self.token.span);\n-                Some(self.bump_with(token::Gt, self.token.span.with_lo(start_point.hi())))\n-            }\n-            token::BinOpEq(token::Shr) => {\n-                let start_point = self.sess.source_map().start_point(self.token.span);\n-                Some(self.bump_with(token::Ge, self.token.span.with_lo(start_point.hi())))\n-            }\n-            token::Ge => {\n-                let start_point = self.sess.source_map().start_point(self.token.span);\n-                Some(self.bump_with(token::Eq, self.token.span.with_lo(start_point.hi())))\n-            }\n-            _ => None,\n-        };\n-\n-        match ate {\n-            Some(_) => {\n-                // See doc comment for `unmatched_angle_bracket_count`.\n-                if self.unmatched_angle_bracket_count > 0 {\n-                    self.unmatched_angle_bracket_count -= 1;\n-                    debug!(\"expect_gt: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n-                }\n-\n-                Ok(())\n+        if self.break_and_eat(token::Gt) {\n+            // See doc comment for `unmatched_angle_bracket_count`.\n+            if self.unmatched_angle_bracket_count > 0 {\n+                self.unmatched_angle_bracket_count -= 1;\n+                debug!(\"expect_gt: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n             }\n-            None => self.unexpected(),\n+            Ok(())\n+        } else {\n+            self.unexpected()\n         }\n     }\n \n@@ -903,41 +838,30 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Advance the parser by one token.\n-    pub fn bump(&mut self) {\n+    /// Advance the parser by one token using provided token as the next one.\n+    fn bump_with(&mut self, next_token: Token) {\n+        // Bumping after EOF is a bad sign, usually an infinite loop.\n         if self.prev_token.kind == TokenKind::Eof {\n-            // Bumping after EOF is a bad sign, usually an infinite loop.\n             let msg = \"attempted to bump the parser past EOF (may be stuck in a loop)\";\n             self.span_bug(self.token.span, msg);\n         }\n \n         // Update the current and previous tokens.\n         self.prev_token = self.token.take();\n         self.unnormalized_prev_token = self.unnormalized_token.take();\n-        let next_token = self.next_tok(self.unnormalized_prev_token.span);\n         self.set_token(next_token);\n \n         // Update fields derived from the previous token.\n         self.prev_span = self.unnormalized_prev_token.span;\n \n+        // Diagnostics.\n         self.expected_tokens.clear();\n     }\n \n-    /// Advances the parser using provided token as a next one. Use this when\n-    /// consuming a part of a token. For example a single `<` from `<<`.\n-    /// FIXME: this function sets the previous token data to some semi-nonsensical values\n-    /// which kind of work because they are currently used in very limited ways in practice.\n-    /// Correct token kinds and spans need to be calculated instead.\n-    fn bump_with(&mut self, next: TokenKind, span: Span) {\n-        // Update the current and previous tokens.\n-        self.prev_token = self.token.take();\n-        self.unnormalized_prev_token = self.unnormalized_token.take();\n-        self.set_token(Token::new(next, span));\n-\n-        // Update fields derived from the previous token.\n-        self.prev_span = self.unnormalized_prev_token.span.with_hi(span.lo());\n-\n-        self.expected_tokens.clear();\n+    /// Advance the parser by one token.\n+    pub fn bump(&mut self) {\n+        let next_token = self.next_tok(self.unnormalized_token.span);\n+        self.bump_with(next_token);\n     }\n \n     /// Look-ahead `dist` tokens of `self.token` and get access to that token there."}, {"sha": "f0bb3cd08ad826b3c6b936d21a360c60c2c800eb", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -144,11 +144,11 @@ enum LiveNodeKind {\n }\n \n fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n-    let cm = tcx.sess.source_map();\n+    let sm = tcx.sess.source_map();\n     match lnk {\n-        UpvarNode(s) => format!(\"Upvar node [{}]\", cm.span_to_string(s)),\n-        ExprNode(s) => format!(\"Expr node [{}]\", cm.span_to_string(s)),\n-        VarDefNode(s) => format!(\"Var def node [{}]\", cm.span_to_string(s)),\n+        UpvarNode(s) => format!(\"Upvar node [{}]\", sm.span_to_string(s)),\n+        ExprNode(s) => format!(\"Expr node [{}]\", sm.span_to_string(s)),\n+        VarDefNode(s) => format!(\"Var def node [{}]\", sm.span_to_string(s)),\n         ExitNode => \"Exit node\".to_owned(),\n     }\n }"}, {"sha": "383bfe18fd00b6f74105697f6111e4ae307bd4bd", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -718,8 +718,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items live in the type namespace.\n-            ItemKind::TyAlias(ref ty, _) => {\n-                let def_kind = match ty.kind.opaque_top_hack() {\n+            ItemKind::TyAlias(_, _, ref ty) => {\n+                let def_kind = match ty.as_deref().and_then(|ty| ty.kind.opaque_top_hack()) {\n                     None => DefKind::TyAlias,\n                     Some(_) => DefKind::OpaqueTy,\n                 };"}, {"sha": "7c48ccfaddd3addcc7f31044ac078219556f58c5", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -90,9 +90,9 @@ impl<'tcx> Into<MissingLifetimeSpot<'tcx>> for &'tcx hir::Generics<'tcx> {\n /// *Attention*: the method used is very fragile since it essentially duplicates the work of the\n /// parser. If you need to use this function or something similar, please consider updating the\n /// `source_map` functions and this function to something more robust.\n-fn reduce_impl_span_to_impl_keyword(cm: &SourceMap, impl_span: Span) -> Span {\n-    let impl_span = cm.span_until_char(impl_span, '<');\n-    let impl_span = cm.span_until_whitespace(impl_span);\n+fn reduce_impl_span_to_impl_keyword(sm: &SourceMap, impl_span: Span) -> Span {\n+    let impl_span = sm.span_until_char(impl_span, '<');\n+    let impl_span = sm.span_until_whitespace(impl_span);\n     impl_span\n }\n \n@@ -136,14 +136,14 @@ impl<'a> Resolver<'a> {\n                 );\n                 err.span_label(span, format!(\"use of generic parameter from outer function\"));\n \n-                let cm = self.session.source_map();\n+                let sm = self.session.source_map();\n                 match outer_res {\n                     Res::SelfTy(maybe_trait_defid, maybe_impl_defid) => {\n                         if let Some(impl_span) =\n                             maybe_impl_defid.and_then(|def_id| self.definitions.opt_span(def_id))\n                         {\n                             err.span_label(\n-                                reduce_impl_span_to_impl_keyword(cm, impl_span),\n+                                reduce_impl_span_to_impl_keyword(sm, impl_span),\n                                 \"`Self` type implicitly declared here, by this `impl`\",\n                             );\n                         }\n@@ -180,15 +180,15 @@ impl<'a> Resolver<'a> {\n                     // Try to retrieve the span of the function signature and generate a new\n                     // message with a local type or const parameter.\n                     let sugg_msg = &format!(\"try using a local generic parameter instead\");\n-                    if let Some((sugg_span, snippet)) = cm.generate_local_type_param_snippet(span) {\n+                    if let Some((sugg_span, snippet)) = sm.generate_local_type_param_snippet(span) {\n                         // Suggest the modification to the user\n                         err.span_suggestion(\n                             sugg_span,\n                             sugg_msg,\n                             snippet,\n                             Applicability::MachineApplicable,\n                         );\n-                    } else if let Some(sp) = cm.generate_fn_name_span(span) {\n+                    } else if let Some(sp) = sm.generate_fn_name_span(span) {\n                         err.span_label(\n                             sp,\n                             format!(\"try adding a local generic parameter in this method instead\"),"}, {"sha": "74628e6e5a03ee1603993c4305b9ce4dd18d5fbe", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -797,7 +797,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         debug!(\"(resolving item) resolving {} ({:?})\", name, item.kind);\n \n         match item.kind {\n-            ItemKind::TyAlias(_, ref generics) | ItemKind::Fn(_, ref generics, _) => {\n+            ItemKind::TyAlias(ref generics, _, _) | ItemKind::Fn(_, ref generics, _) => {\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                     visit::walk_item(this, item)\n                 });"}, {"sha": "6a6fba8270b4306343c4b5c3333048509e1bed0f", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -725,21 +725,21 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n \n     /// Only used in a specific case of type ascription suggestions\n     fn get_colon_suggestion_span(&self, start: Span) -> Span {\n-        let cm = self.r.session.source_map();\n-        start.to(cm.next_point(start))\n+        let sm = self.r.session.source_map();\n+        start.to(sm.next_point(start))\n     }\n \n     fn type_ascription_suggestion(&self, err: &mut DiagnosticBuilder<'_>, base_span: Span) {\n-        let cm = self.r.session.source_map();\n-        let base_snippet = cm.span_to_snippet(base_span);\n+        let sm = self.r.session.source_map();\n+        let base_snippet = sm.span_to_snippet(base_span);\n         if let Some(sp) = self.diagnostic_metadata.current_type_ascription.last() {\n             let mut sp = *sp;\n             loop {\n                 // Try to find the `:`; bail on first non-':' / non-whitespace.\n-                sp = cm.next_point(sp);\n-                if let Ok(snippet) = cm.span_to_snippet(sp.to(cm.next_point(sp))) {\n-                    let line_sp = cm.lookup_char_pos(sp.hi()).line;\n-                    let line_base_sp = cm.lookup_char_pos(base_span.lo()).line;\n+                sp = sm.next_point(sp);\n+                if let Ok(snippet) = sm.span_to_snippet(sp.to(sm.next_point(sp))) {\n+                    let line_sp = sm.lookup_char_pos(sp.hi()).line;\n+                    let line_base_sp = sm.lookup_char_pos(base_span.lo()).line;\n                     if snippet == \":\" {\n                         let mut show_label = true;\n                         if line_sp != line_base_sp {\n@@ -753,7 +753,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                             let colon_sp = self.get_colon_suggestion_span(sp);\n                             let after_colon_sp =\n                                 self.get_colon_suggestion_span(colon_sp.shrink_to_hi());\n-                            if !cm\n+                            if !sm\n                                 .span_to_snippet(after_colon_sp)\n                                 .map(|s| s == \" \")\n                                 .unwrap_or(false)\n@@ -770,8 +770,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                                 let mut sp = after_colon_sp;\n                                 for _ in 0..100 {\n                                     // Try to find an assignment\n-                                    sp = cm.next_point(sp);\n-                                    let snippet = cm.span_to_snippet(sp.to(cm.next_point(sp)));\n+                                    sp = sm.next_point(sp);\n+                                    let snippet = sm.span_to_snippet(sp.to(sm.next_point(sp)));\n                                     match snippet {\n                                         Ok(ref x) if x.as_str() == \"=\" => {\n                                             err.span_suggestion("}, {"sha": "442f3b695a26f6db5d463df31ae033b39f621811", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -1233,8 +1233,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n         let qualname =\n             format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(id)));\n \n-        let cm = self.tcx.sess.source_map();\n-        let filename = cm.span_to_filename(span);\n+        let sm = self.tcx.sess.source_map();\n+        let filename = sm.span_to_filename(span);\n         let data_id = id_from_node_id(id, &self.save_ctxt);\n         let children = m.items.iter().map(|i| id_from_node_id(i.id, &self.save_ctxt)).collect();\n         let span = self.span_from_span(span);\n@@ -1311,12 +1311,15 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 self.process_mod(item);\n                 visit::walk_mod(self, m);\n             }\n-            TyAlias(ref ty, ref ty_params) => {\n+            TyAlias(ref ty_params, _, ref ty) => {\n                 let qualname = format!(\n                     \"::{}\",\n                     self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id))\n                 );\n-                let value = ty_to_string(&ty);\n+                let value = match ty {\n+                    Some(ty) => ty_to_string(&ty),\n+                    None => \"_\".to_string(),\n+                };\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n                     let id = id_from_node_id(item.id, &self.save_ctxt);\n@@ -1341,7 +1344,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                     );\n                 }\n \n-                self.visit_ty(&ty);\n+                walk_list!(self, visit_ty, ty);\n                 self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Mac(_) => (),"}, {"sha": "43a0cfecd3ed00feff03fa34b8556bd99bb14ff6", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -66,9 +66,9 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     fn span_from_span(&self, span: Span) -> SpanData {\n         use rls_span::{Column, Row};\n \n-        let cm = self.tcx.sess.source_map();\n-        let start = cm.lookup_char_pos(span.lo());\n-        let end = cm.lookup_char_pos(span.hi());\n+        let sm = self.tcx.sess.source_map();\n+        let start = sm.lookup_char_pos(span.lo());\n+        let end = sm.lookup_char_pos(span.hi());\n \n         SpanData {\n             file_name: start.file.name.to_string().into(),\n@@ -258,8 +258,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id))\n                 );\n \n-                let cm = self.tcx.sess.source_map();\n-                let filename = cm.span_to_filename(m.inner);\n+                let sm = self.tcx.sess.source_map();\n+                let filename = sm.span_to_filename(m.inner);\n \n                 filter!(self.span_utils, item.ident.span);\n "}, {"sha": "2c07ed0571bded679dfe65a0fe4a79ac7aac2946", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -423,12 +423,15 @@ impl Sig for ast::Item {\n \n                 Ok(Signature { text, defs, refs: vec![] })\n             }\n-            ast::ItemKind::TyAlias(ref ty, ref generics) => {\n+            ast::ItemKind::TyAlias(ref generics, _, ref ty) => {\n                 let text = \"type \".to_owned();\n                 let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n \n                 sig.text.push_str(\" = \");\n-                let ty = ty.make(offset + sig.text.len(), id, scx)?;\n+                let ty = match ty {\n+                    Some(ty) => ty.make(offset + sig.text.len(), id, scx)?,\n+                    None => Err(\"Ty\")?,\n+                };\n                 sig.text.push_str(&ty.text);\n                 sig.text.push(';');\n "}, {"sha": "6d4f4be03ecb2d5bff5da8fefa727ac43b4e532a", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -124,9 +124,9 @@ pub struct ParseSess {\n \n impl ParseSess {\n     pub fn new(file_path_mapping: FilePathMapping) -> Self {\n-        let cm = Lrc::new(SourceMap::new(file_path_mapping));\n-        let handler = Handler::with_tty_emitter(ColorConfig::Auto, true, None, Some(cm.clone()));\n-        ParseSess::with_span_handler(handler, cm)\n+        let sm = Lrc::new(SourceMap::new(file_path_mapping));\n+        let handler = Handler::with_tty_emitter(ColorConfig::Auto, true, None, Some(sm.clone()));\n+        ParseSess::with_span_handler(handler, sm)\n     }\n \n     pub fn with_span_handler(handler: Handler, source_map: Lrc<SourceMap>) -> Self {\n@@ -148,9 +148,9 @@ impl ParseSess {\n     }\n \n     pub fn with_silent_emitter() -> Self {\n-        let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let handler = Handler::with_emitter(false, None, Box::new(SilentEmitter));\n-        ParseSess::with_span_handler(handler, cm)\n+        ParseSess::with_span_handler(handler, sm)\n     }\n \n     #[inline]"}, {"sha": "d6725160a5d022939ecf7e84d315b77258344a8a", "filename": "src/librustc_span/caching_source_map_view.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_span%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_span%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fcaching_source_map_view.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -13,14 +13,14 @@ struct CacheEntry {\n }\n \n #[derive(Clone)]\n-pub struct CachingSourceMapView<'cm> {\n-    source_map: &'cm SourceMap,\n+pub struct CachingSourceMapView<'sm> {\n+    source_map: &'sm SourceMap,\n     line_cache: [CacheEntry; 3],\n     time_stamp: usize,\n }\n \n-impl<'cm> CachingSourceMapView<'cm> {\n-    pub fn new(source_map: &'cm SourceMap) -> CachingSourceMapView<'cm> {\n+impl<'sm> CachingSourceMapView<'sm> {\n+    pub fn new(source_map: &'sm SourceMap) -> CachingSourceMapView<'sm> {\n         let files = source_map.files();\n         let first_file = files[0].clone();\n         let entry = CacheEntry {"}, {"sha": "c289176c3038c64103abdeddfa0d97423d40d0ab", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -324,13 +324,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         hir_id: hir::HirId,\n         sp: Span,\n     ) -> bool {\n-        let cm = self.sess().source_map();\n+        let sm = self.sess().source_map();\n         let parent_id = self.tcx.hir().get_parent_node(hir_id);\n         if let Some(parent) = self.tcx.hir().find(parent_id) {\n             // Account for fields\n             if let Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) = parent\n             {\n-                if let Ok(src) = cm.span_to_snippet(sp) {\n+                if let Ok(src) = sm.span_to_snippet(sp) {\n                     for field in *fields {\n                         if field.ident.as_str() == src && field.is_shorthand {\n                             return true;\n@@ -364,9 +364,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Option<(Span, &'static str, String)> {\n-        let cm = self.sess().source_map();\n+        let sm = self.sess().source_map();\n         let sp = expr.span;\n-        if !cm.span_to_filename(sp).is_real() {\n+        if !sm.span_to_filename(sp).is_real() {\n             // Ignore if span is from within a macro #41858, #58298. We previously used the macro\n             // call span, but that breaks down when the type error comes from multiple calls down.\n             return None;\n@@ -388,7 +388,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if arr == self.tcx.types.u8 =>\n                 {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n-                        if let Ok(src) = cm.span_to_snippet(sp) {\n+                        if let Ok(src) = sm.span_to_snippet(sp) {\n                             if src.starts_with(\"b\\\"\") {\n                                 return Some((\n                                     sp,\n@@ -403,7 +403,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if arr == self.tcx.types.u8 =>\n                 {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n-                        if let Ok(src) = cm.span_to_snippet(sp) {\n+                        if let Ok(src) = sm.span_to_snippet(sp) {\n                             if src.starts_with(\"\\\"\") {\n                                 return Some((\n                                     sp,\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             sugg_sp = arg.span;\n                         }\n                     }\n-                    if let Ok(src) = cm.span_to_snippet(sugg_sp) {\n+                    if let Ok(src) = sm.span_to_snippet(sugg_sp) {\n                         let needs_parens = match expr.kind {\n                             // parenthesize if needed (Issue #46756)\n                             hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => true,\n@@ -480,7 +480,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 //                                   |     |\n                                 //    consider dereferencing here: `*opt`  |\n                                 // expected mutable reference, found enum `Option`\n-                                if let Ok(src) = cm.span_to_snippet(left_expr.span) {\n+                                if let Ok(src) = sm.span_to_snippet(left_expr.span) {\n                                     return Some((\n                                         left_expr.span,\n                                         \"consider dereferencing here to assign to the mutable \\\n@@ -516,8 +516,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n-                if !cm.span_to_filename(expr.span).is_real() {\n-                    if let Ok(code) = cm.span_to_snippet(sp) {\n+                if !sm.span_to_filename(expr.span).is_real() {\n+                    if let Ok(code) = sm.span_to_snippet(sp) {\n                         if code.chars().next() == Some('&') {\n                             return Some((\n                                 sp,\n@@ -528,7 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     return None;\n                 }\n-                if let Ok(code) = cm.span_to_snippet(expr.span) {\n+                if let Ok(code) = sm.span_to_snippet(expr.span) {\n                     return Some((sp, \"consider removing the borrow\", code));\n                 }\n             }\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let is_copy = self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp);\n \n                 if is_copy && impls_deref {\n-                    if let Ok(code) = cm.span_to_snippet(sp) {\n+                    if let Ok(code) = sm.span_to_snippet(sp) {\n                         let message = if checked_ty.is_region_ptr() {\n                             \"consider dereferencing the borrow\"\n                         } else {"}, {"sha": "a8e5a0ddf26869f341c63d8269a8e04deaf431be", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -33,8 +33,8 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n             );\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n-            let cm = self.tcx.sess.source_map();\n-            let sp = cm.def_span(item.span);\n+            let sm = self.tcx.sess.source_map();\n+            let sp = sm.def_span(item.span);\n             match traits::orphan_check(self.tcx, def_id) {\n                 Ok(()) => {}\n                 Err(traits::OrphanCheckErr::NonLocalInputType(tys)) => {"}, {"sha": "50c780e9ecb52e77e46f6c504b1c2c5a21e5c900", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -263,9 +263,9 @@ impl Clean<Item> for doctree::Module<'_> {\n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n-            let cm = cx.sess().source_map();\n-            let outer = cm.lookup_char_pos(self.where_outer.lo());\n-            let inner = cm.lookup_char_pos(self.where_inner.lo());\n+            let sm = cx.sess().source_map();\n+            let outer = sm.lookup_char_pos(self.where_outer.lo());\n+            let inner = sm.lookup_char_pos(self.where_inner.lo());\n             if outer.file.start_pos == inner.file.start_pos {\n                 // mod foo { ... }\n                 self.where_outer\n@@ -1917,10 +1917,10 @@ impl Clean<Span> for rustc_span::Span {\n             return Span::empty();\n         }\n \n-        let cm = cx.sess().source_map();\n-        let filename = cm.span_to_filename(*self);\n-        let lo = cm.lookup_char_pos(self.lo());\n-        let hi = cm.lookup_char_pos(self.hi());\n+        let sm = cx.sess().source_map();\n+        let filename = sm.span_to_filename(*self);\n+        let lo = sm.lookup_char_pos(self.lo());\n+        let hi = sm.lookup_char_pos(self.hi());\n         Span {\n             filename,\n             loline: lo.line,"}, {"sha": "8c4e65765d32f63df410be5754ff3f40c4eec906", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -177,7 +177,7 @@ pub fn new_handler(\n             Box::new(\n                 EmitterWriter::stderr(\n                     color_config,\n-                    source_map.map(|cm| cm as _),\n+                    source_map.map(|sm| sm as _),\n                     short,\n                     debugging_opts.teach,\n                     debugging_opts.terminal_width,"}, {"sha": "849c5c3e0722030058f1c90d276f78c210a4a924", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -38,11 +38,11 @@ pub fn render_with_highlighting(\n     }\n \n     let sess = ParseSess::with_silent_emitter();\n-    let fm = sess\n+    let sf = sess\n         .source_map()\n         .new_source_file(FileName::Custom(String::from(\"rustdoc-highlighting\")), src.to_owned());\n     let highlight_result = rustc_driver::catch_fatal_errors(|| {\n-        let lexer = lexer::StringReader::new(&sess, fm, None);\n+        let lexer = lexer::StringReader::new(&sess, sf, None);\n         let mut classifier = Classifier::new(lexer, sess.source_map());\n \n         let mut highlighted_source = vec![];"}, {"sha": "a6dad3c392044399c3c7b3009758c296973f6ad9", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -32,9 +32,9 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n \n         let emitter = BufferEmitter { messages: Lrc::clone(&buffered_messages) };\n \n-        let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let handler = Handler::with_emitter(false, None, Box::new(emitter));\n-        let sess = ParseSess::with_span_handler(handler, cm);\n+        let sess = ParseSess::with_span_handler(handler, sm);\n         let source_file = sess.source_map().new_source_file(\n             FileName::Custom(String::from(\"doctest\")),\n             dox[code_block.code].to_owned(),"}, {"sha": "5dd7bd82755752e8ef5eb290bc86ad9a22d8879f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -402,12 +402,12 @@ pub fn make_test(\n \n             // Any errors in parsing should also appear when the doctest is compiled for real, so just\n             // send all the errors that libsyntax emits directly into a `Sink` instead of stderr.\n-            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let emitter =\n                 EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n             // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n             let handler = Handler::with_emitter(false, None, box emitter);\n-            let sess = ParseSess::with_span_handler(handler, cm);\n+            let sess = ParseSess::with_span_handler(handler, sm);\n \n             let mut found_main = false;\n             let mut found_extern_crate = cratename.is_none();"}, {"sha": "849950e939a02c8c94e6ebf9a93acaf2920a83bb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -2524,7 +2524,7 @@ pub enum ItemKind {\n     /// A type alias (`type`).\n     ///\n     /// E.g., `type Foo = Bar<u8>;`.\n-    TyAlias(P<Ty>, Generics),\n+    TyAlias(Generics, GenericBounds, Option<P<Ty>>),\n     /// An enum definition (`enum`).\n     ///\n     /// E.g., `enum Foo<A, B> { C<A>, D<B> }`.\n@@ -2594,7 +2594,7 @@ impl ItemKind {\n     pub fn generics(&self) -> Option<&Generics> {\n         match self {\n             Self::Fn(_, generics, _)\n-            | Self::TyAlias(_, generics)\n+            | Self::TyAlias(generics, ..)\n             | Self::Enum(_, generics)\n             | Self::Struct(_, generics)\n             | Self::Union(_, generics)"}, {"sha": "02f790dfbb4e97a41f614052bd9ac59e39a3958c", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -902,9 +902,10 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n         ItemKind::Mod(m) => vis.visit_mod(m),\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n         ItemKind::GlobalAsm(_ga) => {}\n-        ItemKind::TyAlias(ty, generics) => {\n-            vis.visit_ty(ty);\n+        ItemKind::TyAlias(generics, bounds, ty) => {\n             vis.visit_generics(generics);\n+            visit_bounds(bounds, vis);\n+            visit_opt(ty, |ty| vis.visit_ty(ty));\n         }\n         ItemKind::Enum(EnumDef { variants }, generics) => {\n             variants.flat_map_in_place(|variant| vis.flat_map_variant(variant));"}, {"sha": "6eeee49881579606ab27497d798620cea6ba5296", "filename": "src/libsyntax/token.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftoken.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -270,6 +270,39 @@ impl TokenKind {\n         Literal(Lit::new(kind, symbol, suffix))\n     }\n \n+    // An approximation to proc-macro-style single-character operators used by rustc parser.\n+    // If the operator token can be broken into two tokens, the first of which is single-character,\n+    // then this function performs that operation, otherwise it returns `None`.\n+    pub fn break_two_token_op(&self) -> Option<(TokenKind, TokenKind)> {\n+        Some(match *self {\n+            Le => (Lt, Eq),\n+            EqEq => (Eq, Eq),\n+            Ne => (Not, Eq),\n+            Ge => (Gt, Eq),\n+            AndAnd => (BinOp(And), BinOp(And)),\n+            OrOr => (BinOp(Or), BinOp(Or)),\n+            BinOp(Shl) => (Lt, Lt),\n+            BinOp(Shr) => (Gt, Gt),\n+            BinOpEq(Plus) => (BinOp(Plus), Eq),\n+            BinOpEq(Minus) => (BinOp(Minus), Eq),\n+            BinOpEq(Star) => (BinOp(Star), Eq),\n+            BinOpEq(Slash) => (BinOp(Slash), Eq),\n+            BinOpEq(Percent) => (BinOp(Percent), Eq),\n+            BinOpEq(Caret) => (BinOp(Caret), Eq),\n+            BinOpEq(And) => (BinOp(And), Eq),\n+            BinOpEq(Or) => (BinOp(Or), Eq),\n+            BinOpEq(Shl) => (Lt, Le),\n+            BinOpEq(Shr) => (Gt, Ge),\n+            DotDot => (Dot, Dot),\n+            DotDotDot => (Dot, DotDot),\n+            ModSep => (Colon, Colon),\n+            RArrow => (BinOp(Minus), Gt),\n+            LArrow => (Lt, BinOp(Minus)),\n+            FatArrow => (Eq, Gt),\n+            _ => return None,\n+        })\n+    }\n+\n     /// Returns tokens that are likely to be typed accidentally instead of the current token.\n     /// Enables better error recovery when the wrong token is found.\n     pub fn similar_tokens(&self) -> Option<Vec<TokenKind>> {"}, {"sha": "0e42ae11fa2faaa07e77d1e050cd329c930ef131", "filename": "src/libsyntax/util/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fcomments.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -189,8 +189,8 @@ fn split_block_comment_into_lines(text: &str, col: CharPos) -> Vec<String> {\n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comment> {\n-    let cm = SourceMap::new(sm.path_mapping().clone());\n-    let source_file = cm.new_source_file(path, src);\n+    let sm = SourceMap::new(sm.path_mapping().clone());\n+    let source_file = sm.new_source_file(path, src);\n     let text = (*source_file.src.as_ref().unwrap()).clone();\n \n     let text: &str = text.as_str();"}, {"sha": "bd35918dba72888345f59f10bd6110e1051b4be3", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -312,9 +312,10 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n         ItemKind::GlobalAsm(ref ga) => visitor.visit_global_asm(ga),\n-        ItemKind::TyAlias(ref typ, ref generics) => {\n-            visitor.visit_ty(typ);\n-            visitor.visit_generics(generics)\n+        ItemKind::TyAlias(ref generics, ref bounds, ref ty) => {\n+            visitor.visit_generics(generics);\n+            walk_list!(visitor, visit_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, ty);\n         }\n         ItemKind::Enum(ref enum_definition, ref generics) => {\n             visitor.visit_generics(generics);"}, {"sha": "e60cc153e670fbe0103316d217aacc470b2f4937", "filename": "src/test/ui/parser/bounds-lifetime-where.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime-where.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -5,6 +5,6 @@ type A where 'a:, = u8; // OK\n type A where 'a: 'b + 'c = u8; // OK\n type A where = u8; // OK\n type A where 'a: 'b + = u8; // OK\n-type A where , = u8; //~ ERROR expected one of `=`, lifetime, or type, found `,`\n+type A where , = u8; //~ ERROR expected one of `;`, `=`, lifetime, or type, found `,`\n \n fn main() {}"}, {"sha": "950fa46c66b7e3bd38722b31bfb0771fb57ecb77", "filename": "src/test/ui/parser/bounds-lifetime-where.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime-where.stderr?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `=`, lifetime, or type, found `,`\n+error: expected one of `;`, `=`, lifetime, or type, found `,`\n   --> $DIR/bounds-lifetime-where.rs:8:14\n    |\n LL | type A where , = u8;\n-   |              ^ expected one of `=`, lifetime, or type\n+   |              ^ expected one of `;`, `=`, lifetime, or type\n \n error: aborting due to previous error\n "}, {"sha": "9db4111fbabd9167f28cdd21544f2a4192b70787", "filename": "src/test/ui/parser/item-free-type-bounds-semantic-fail.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-semantic-fail.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -0,0 +1,20 @@\n+fn main() {}\n+\n+fn semantics() {\n+    type A: Ord;\n+    //~^ ERROR bounds on `type`s in this context have no effect\n+    //~| ERROR free type alias without body\n+    type B: Ord = u8;\n+    //~^ ERROR bounds on `type`s in this context have no effect\n+    type C: Ord where 'static: 'static = u8;\n+    //~^ ERROR bounds on `type`s in this context have no effect\n+    type D<_T>: Ord;\n+    //~^ ERROR bounds on `type`s in this context have no effect\n+    //~| ERROR free type alias without body\n+    type E<_T>: Ord = u8;\n+    //~^ ERROR bounds on `type`s in this context have no effect\n+    //~| ERROR type parameter `_T` is unused\n+    type F<_T>: Ord where 'static: 'static = u8;\n+    //~^ ERROR bounds on `type`s in this context have no effect\n+    //~| ERROR type parameter `_T` is unused\n+}"}, {"sha": "1b086512891f21a9b3b40af542ce1ec0bcb8bc6c", "filename": "src/test/ui/parser/item-free-type-bounds-semantic-fail.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-semantic-fail.stderr?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -0,0 +1,67 @@\n+error: free type alias without body\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:4:5\n+   |\n+LL |     type A: Ord;\n+   |     ^^^^^^^^^^^-\n+   |                |\n+   |                help: provide a definition for the type: `= <type>;`\n+\n+error: bounds on `type`s in this context have no effect\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:4:13\n+   |\n+LL |     type A: Ord;\n+   |             ^^^\n+\n+error: bounds on `type`s in this context have no effect\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:7:13\n+   |\n+LL |     type B: Ord = u8;\n+   |             ^^^\n+\n+error: bounds on `type`s in this context have no effect\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:9:13\n+   |\n+LL |     type C: Ord where 'static: 'static = u8;\n+   |             ^^^\n+\n+error: free type alias without body\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:11:5\n+   |\n+LL |     type D<_T>: Ord;\n+   |     ^^^^^^^^^^^^^^^-\n+   |                    |\n+   |                    help: provide a definition for the type: `= <type>;`\n+\n+error: bounds on `type`s in this context have no effect\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:11:17\n+   |\n+LL |     type D<_T>: Ord;\n+   |                 ^^^\n+\n+error: bounds on `type`s in this context have no effect\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:14:17\n+   |\n+LL |     type E<_T>: Ord = u8;\n+   |                 ^^^\n+\n+error: bounds on `type`s in this context have no effect\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:17:17\n+   |\n+LL |     type F<_T>: Ord where 'static: 'static = u8;\n+   |                 ^^^\n+\n+error[E0091]: type parameter `_T` is unused\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:14:12\n+   |\n+LL |     type E<_T>: Ord = u8;\n+   |            ^^ unused type parameter\n+\n+error[E0091]: type parameter `_T` is unused\n+  --> $DIR/item-free-type-bounds-semantic-fail.rs:17:12\n+   |\n+LL |     type F<_T>: Ord where 'static: 'static = u8;\n+   |            ^^ unused type parameter\n+\n+error: aborting due to 10 previous errors\n+\n+For more information about this error, try `rustc --explain E0091`."}, {"sha": "58fc926d08f3e55975be5a4ae66efa60ba04bd79", "filename": "src/test/ui/parser/item-free-type-bounds-syntactic-pass.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0e58bff88f620c1a4f641a627f046bf4cde4ad/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-type-bounds-syntactic-pass.rs?ref=6d0e58bff88f620c1a4f641a627f046bf4cde4ad", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    type A: Ord;\n+    type B: Ord = u8;\n+    type C: Ord where 'static: 'static = u8;\n+    type D<_T>: Ord;\n+    type E<_T>: Ord = u8;\n+    type F<_T>: Ord where 'static: 'static = u8;\n+}"}]}