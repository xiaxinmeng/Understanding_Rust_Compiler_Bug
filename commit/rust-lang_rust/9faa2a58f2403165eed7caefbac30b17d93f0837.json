{"sha": "9faa2a58f2403165eed7caefbac30b17d93f0837", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYWEyYTU4ZjI0MDMxNjVlZWQ3Y2FlZmJhYzMwYjE3ZDkzZjA4Mzc=", "commit": {"author": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2014-02-15T06:26:51Z"}, "committer": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2014-03-12T20:34:05Z"}, "message": "Suggest explicit lifetime parameter on some errors\n\nSome types of error are caused by missing lifetime parameter on function\nor method declaration. In such cases, this commit generates some\nsuggestion about what the function declaration could be. This does not\nsupport method declaration yet.", "tree": {"sha": "f15f9c0d97bffcfbde9df4a5f7cceace0a6b6da6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f15f9c0d97bffcfbde9df4a5f7cceace0a6b6da6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9faa2a58f2403165eed7caefbac30b17d93f0837", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9faa2a58f2403165eed7caefbac30b17d93f0837", "html_url": "https://github.com/rust-lang/rust/commit/9faa2a58f2403165eed7caefbac30b17d93f0837", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9faa2a58f2403165eed7caefbac30b17d93f0837/comments", "author": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed2b3a2f0b8e0737b38528aa7d64efb176c7e2a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed2b3a2f0b8e0737b38528aa7d64efb176c7e2a8", "html_url": "https://github.com/rust-lang/rust/commit/ed2b3a2f0b8e0737b38528aa7d64efb176c7e2a8"}], "stats": {"total": 749, "additions": 743, "deletions": 6}, "files": [{"sha": "a01fd4d86ade3b2f3c2540a7393838c92244ea53", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 625, "deletions": 4, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9faa2a58f2403165eed7caefbac30b17d93f0837", "patch": "@@ -59,8 +59,9 @@ time of error detection.\n \n */\n \n+use collections::HashSet;\n use middle::ty;\n-use middle::ty::Region;\n+use middle::ty::{Region, ReFree};\n use middle::typeck::infer;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::TypeTrace;\n@@ -71,8 +72,19 @@ use middle::typeck::infer::region_inference::RegionResolutionError;\n use middle::typeck::infer::region_inference::ConcreteFailure;\n use middle::typeck::infer::region_inference::SubSupConflict;\n use middle::typeck::infer::region_inference::SupSupConflict;\n+use middle::typeck::infer::region_inference::ProcessedErrors;\n+use middle::typeck::infer::region_inference::SameRegions;\n+use std::cell::{Cell, RefCell};\n+use std::char::from_u32;\n+use std::vec_ng::Vec;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::ast_util;\n+use syntax::ast_util::name_to_dummy_lifetime;\n+use syntax::opt_vec;\n use syntax::opt_vec::OptVec;\n use syntax::parse::token;\n+use syntax::print::pprust;\n use util::ppaux::UserString;\n use util::ppaux::bound_region_to_str;\n use util::ppaux::note_and_explain_region;\n@@ -81,6 +93,11 @@ pub trait ErrorReporting {\n     fn report_region_errors(&self,\n                             errors: &OptVec<RegionResolutionError>);\n \n+    fn process_errors(&self, errors: &OptVec<RegionResolutionError>)\n+                      -> OptVec<RegionResolutionError>;\n+\n+    fn report_type_error(&self, trace: TypeTrace, terr: &ty::type_err);\n+\n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err);\n@@ -110,6 +127,13 @@ pub trait ErrorReporting {\n                                region1: Region,\n                                origin2: SubregionOrigin,\n                                region2: Region);\n+\n+    fn report_processed_errors(&self,\n+                               var_origin: &[RegionVariableOrigin],\n+                               trace_origin: &[(TypeTrace, ty::type_err)],\n+                               same_regions: &[SameRegions]);\n+\n+    fn give_suggestion(&self, same_regions: &[SameRegions]);\n }\n \n trait ErrorReportingHelpers {\n@@ -118,11 +142,19 @@ trait ErrorReportingHelpers {\n \n     fn note_region_origin(&self,\n                           origin: SubregionOrigin);\n+\n+    fn give_expl_lifetime_param(&self,\n+                                inputs: Vec<ast::Arg>,\n+                                output: ast::P<ast::Ty>,\n+                                item: ast::P<ast::Item>,\n+                                generics: ast::Generics);\n }\n \n impl ErrorReporting for InferCtxt {\n     fn report_region_errors(&self,\n                             errors: &OptVec<RegionResolutionError>) {\n+        let p_errors = self.process_errors(errors);\n+        let errors = if p_errors.is_empty() { errors } else { &p_errors };\n         for error in errors.iter() {\n             match *error {\n                 ConcreteFailure(origin, sub, sup) => {\n@@ -144,13 +176,140 @@ impl ErrorReporting for InferCtxt {\n                                                  origin1, r1,\n                                                  origin2, r2);\n                 }\n+\n+                ProcessedErrors(ref var_origins,\n+                                ref trace_origins,\n+                                ref same_regions) => {\n+                    if !same_regions.is_empty() {\n+                        self.report_processed_errors(var_origins.as_slice(),\n+                                                     trace_origins.as_slice(),\n+                                                     same_regions.as_slice());\n+                    }\n+                }\n             }\n         }\n     }\n \n-    fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace,\n-                                     terr: &ty::type_err) {\n+    // This method goes through all the errors and try to group certain types\n+    // of error together, for the purpose of suggesting explicit lifetime\n+    // parameters to the user. This is done so that we can have a more\n+    // complete view of what lifetimes should be the same.\n+    // If the return value is an empty vector, it means that processing\n+    // failed (so the return value of this method should not be used)\n+    fn process_errors(&self, errors: &OptVec<RegionResolutionError>)\n+                      -> OptVec<RegionResolutionError> {\n+        let mut var_origins = Vec::new();\n+        let mut trace_origins = Vec::new();\n+        let mut same_regions = Vec::new();\n+        let mut processed_errors = opt_vec::Empty;\n+        for error in errors.iter() {\n+            match *error {\n+                ConcreteFailure(origin, sub, sup) => {\n+                    let trace = match origin {\n+                        infer::Subtype(trace) => Some(trace),\n+                        _ => None,\n+                    };\n+                    match free_regions_from_same_fn(self.tcx, sub, sup) {\n+                        Some(ref same_frs) if trace.is_some() => {\n+                            let trace = trace.unwrap();\n+                            let terr = ty::terr_regions_does_not_outlive(sup,\n+                                                                         sub);\n+                            trace_origins.push((trace, terr));\n+                            append_to_same_regions(&mut same_regions, same_frs);\n+                        }\n+                        _ => processed_errors.push((*error).clone()),\n+                    }\n+                }\n+                SubSupConflict(var_origin, _, sub_r, _, sup_r) => {\n+                    match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n+                        Some(ref same_frs) => {\n+                            var_origins.push(var_origin);\n+                            append_to_same_regions(&mut same_regions, same_frs);\n+                        }\n+                        None => processed_errors.push((*error).clone()),\n+                    }\n+                }\n+                SupSupConflict(..) => processed_errors.push((*error).clone()),\n+                _ => ()  // This shouldn't happen\n+            }\n+        }\n+        if !same_regions.is_empty() {\n+            let common_scope_id = same_regions.get(0).scope_id;\n+            for sr in same_regions.iter() {\n+                // Since ProcessedErrors is used to reconstruct the function\n+                // declaration, we want to make sure that they are, in fact,\n+                // from the same scope\n+                if sr.scope_id != common_scope_id {\n+                    return opt_vec::Empty;\n+                }\n+            }\n+            let pe = ProcessedErrors(var_origins, trace_origins, same_regions);\n+            processed_errors.push(pe);\n+        }\n+        return processed_errors;\n+\n+\n+        struct FreeRegionsFromSameFn {\n+            sub_fr: ty::FreeRegion,\n+            sup_fr: ty::FreeRegion,\n+            scope_id: ast::NodeId\n+        }\n+\n+        fn free_regions_from_same_fn(tcx: ty::ctxt,\n+                                     sub: Region,\n+                                     sup: Region)\n+                                     -> Option<FreeRegionsFromSameFn> {\n+            let (scope_id, fr1, fr2) = match (sub, sup) {\n+                (ReFree(fr1), ReFree(fr2)) => {\n+                    if fr1.scope_id != fr2.scope_id {\n+                        return None\n+                    }\n+                    assert!(fr1.scope_id == fr2.scope_id);\n+                    (fr1.scope_id, fr1, fr2)\n+                },\n+                _ => return None\n+            };\n+            let parent = tcx.map.get_parent(scope_id);\n+            let parent_node = tcx.map.find(parent);\n+            match parent_node {\n+                Some(node) => match node {\n+                    ast_map::NodeItem(item) => match item.node {\n+                        // FIXME: handle method\n+                        ast::ItemFn(..) => {\n+                            let fr_from_same_fn = FreeRegionsFromSameFn {\n+                                sub_fr: fr1,\n+                                sup_fr: fr2,\n+                                scope_id: scope_id\n+                            };\n+                            Some(fr_from_same_fn)\n+                        },\n+                        _ => None\n+                    },\n+                    _ => None\n+                },\n+                None => None\n+            }\n+        }\n+\n+        fn append_to_same_regions(same_regions: &mut Vec<SameRegions>,\n+                                  same_frs: &FreeRegionsFromSameFn) {\n+            let scope_id = same_frs.scope_id;\n+            let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n+            for sr in same_regions.mut_iter() {\n+                if sr.contains(&sup_fr.bound_region)\n+                   && scope_id == sr.scope_id {\n+                    sr.push(sub_fr.bound_region);\n+                    return\n+                }\n+            }\n+            same_regions.push(SameRegions {\n+                scope_id: scope_id,\n+                regions: vec!(sub_fr.bound_region, sup_fr.bound_region)\n+            })\n+        }\n+    }\n+\n+    fn report_type_error(&self, trace: TypeTrace, terr: &ty::type_err) {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n@@ -174,7 +333,12 @@ impl ErrorReporting for InferCtxt {\n                  message_root_str,\n                  expected_found_str,\n                  ty::type_err_to_str(self.tcx, terr)));\n+    }\n \n+    fn report_and_explain_type_error(&self,\n+                                     trace: TypeTrace,\n+                                     terr: &ty::type_err) {\n+        self.report_type_error(trace, terr);\n         ty::note_and_explain_type_err(self.tcx, terr);\n     }\n \n@@ -468,9 +632,407 @@ impl ErrorReporting for InferCtxt {\n \n         self.note_region_origin(origin2);\n     }\n+\n+    fn report_processed_errors(&self,\n+                               var_origins: &[RegionVariableOrigin],\n+                               trace_origins: &[(TypeTrace, ty::type_err)],\n+                               same_regions: &[SameRegions]) {\n+        self.give_suggestion(same_regions);\n+        for vo in var_origins.iter() {\n+            self.report_inference_failure(*vo);\n+        }\n+        for &(trace, terr) in trace_origins.iter() {\n+            self.report_type_error(trace, &terr);\n+        }\n+    }\n+\n+    fn give_suggestion(&self, same_regions: &[SameRegions]) {\n+        let scope_id = same_regions[0].scope_id;\n+        let parent = self.tcx.map.get_parent(scope_id);\n+        let parent_node = self.tcx.map.find(parent);\n+        let node_inner = match parent_node {\n+            Some(node) => match node {\n+                ast_map::NodeItem(item) => match item.node {\n+                    // FIXME: handling method\n+                    ast::ItemFn(ref fn_decl, _, _, ref gen, _) => {\n+                        Some((item, fn_decl, gen))\n+                    },\n+                    _ => None\n+                },\n+                _ => None\n+            },\n+            None => None\n+        };\n+        let (item, fn_decl, generics) = node_inner.expect(\"expect item fn\");\n+        let rebuilder = Rebuilder::new(self.tcx, *fn_decl,\n+                                       generics, same_regions);\n+        let (inputs, output, generics) = rebuilder.rebuild();\n+        self.give_expl_lifetime_param(inputs, output, item, generics);\n+    }\n+}\n+\n+struct Rebuilder<'a> {\n+    tcx: ty::ctxt,\n+    fn_decl: ast::P<ast::FnDecl>,\n+    generics: &'a ast::Generics,\n+    same_regions: &'a [SameRegions],\n+    life_giver: LifeGiver,\n+    cur_anon: Cell<uint>,\n+    inserted_anons: RefCell<HashSet<uint>>,\n+}\n+\n+impl<'a> Rebuilder<'a> {\n+    fn new(tcx: ty::ctxt,\n+           fn_decl: ast::P<ast::FnDecl>,\n+           generics: &'a ast::Generics,\n+           same_regions: &'a [SameRegions])\n+           -> Rebuilder<'a> {\n+        Rebuilder {\n+            tcx: tcx,\n+            fn_decl: fn_decl,\n+            generics: generics,\n+            same_regions: same_regions,\n+            life_giver: LifeGiver::with_taken(generics.lifetimes.as_slice()),\n+            cur_anon: Cell::new(0),\n+            inserted_anons: RefCell::new(HashSet::new()),\n+        }\n+    }\n+\n+    fn rebuild(&self) -> (Vec<ast::Arg>, ast::P<ast::Ty>, ast::Generics) {\n+        let mut inputs = self.fn_decl.inputs.clone();\n+        let mut output = self.fn_decl.output;\n+        for sr in self.same_regions.iter() {\n+            self.cur_anon.set(0);\n+            self.offset_cur_anon();\n+            let (anon_nums, region_names) =\n+                                self.extract_anon_nums_and_names(sr);\n+            let lifetime = self.life_giver.give_lifetime();\n+            inputs = self.rebuild_args_ty(inputs.as_slice(), lifetime,\n+                                          &anon_nums, &region_names);\n+            output = self.rebuild_arg_ty_or_output(output, lifetime,\n+                                                   &anon_nums, &region_names);\n+        }\n+        let generated_lifetimes = self.life_giver.get_generated_lifetimes();\n+        let all_region_names = self.extract_all_region_names();\n+        let generics = self.rebuild_generics(self.generics,\n+                                             generated_lifetimes,\n+                                             &all_region_names);\n+        (inputs, output, generics)\n+    }\n+\n+    fn extract_anon_nums_and_names(&self, same_regions: &SameRegions)\n+                                   -> (HashSet<uint>, HashSet<ast::Name>) {\n+        let mut anon_nums = HashSet::new();\n+        let mut region_names = HashSet::new();\n+        for br in same_regions.regions.iter() {\n+            match *br {\n+                ty::BrAnon(i) => {\n+                    anon_nums.insert(i);\n+                }\n+                ty::BrNamed(_, name) => {\n+                    region_names.insert(name);\n+                }\n+                _ => ()\n+            }\n+        }\n+        (anon_nums, region_names)\n+    }\n+\n+    fn extract_all_region_names(&self) -> HashSet<ast::Name> {\n+        let mut all_region_names = HashSet::new();\n+        for sr in self.same_regions.iter() {\n+            for br in sr.regions.iter() {\n+                match *br {\n+                    ty::BrNamed(_, name) => {\n+                        all_region_names.insert(name);\n+                    }\n+                    _ => ()\n+                }\n+            }\n+        }\n+        all_region_names\n+    }\n+\n+    fn inc_cur_anon(&self, n: uint) {\n+        let anon = self.cur_anon.get();\n+        self.cur_anon.set(anon+n);\n+    }\n+\n+    fn offset_cur_anon(&self) {\n+        let mut anon = self.cur_anon.get();\n+        let inserted_anons = self.inserted_anons.borrow();\n+        while inserted_anons.get().contains(&anon) {\n+            anon += 1;\n+        }\n+        self.cur_anon.set(anon);\n+    }\n+\n+    fn inc_and_offset_cur_anon(&self, n: uint) {\n+        self.inc_cur_anon(n);\n+        self.offset_cur_anon();\n+    }\n+\n+    fn track_anon(&self, anon: uint) {\n+        let mut inserted_anons = self.inserted_anons.borrow_mut();\n+        inserted_anons.get().insert(anon);\n+    }\n+\n+    fn rebuild_generics(&self,\n+                        generics: &ast::Generics,\n+                        add: Vec<ast::Lifetime>,\n+                        remove: &HashSet<ast::Name>)\n+                        -> ast::Generics {\n+        let mut lifetimes = Vec::new();\n+        for lt in add.iter() {\n+            lifetimes.push(*lt);\n+        }\n+        for lt in generics.lifetimes.iter() {\n+            if !remove.contains(&lt.name) {\n+                lifetimes.push((*lt).clone());\n+            }\n+        }\n+        ast::Generics {\n+            lifetimes: lifetimes,\n+            ty_params: generics.ty_params.clone()\n+        }\n+    }\n+\n+    fn rebuild_args_ty(&self,\n+                       inputs: &[ast::Arg],\n+                       lifetime: ast::Lifetime,\n+                       anon_nums: &HashSet<uint>,\n+                       region_names: &HashSet<ast::Name>)\n+                       -> Vec<ast::Arg> {\n+        let mut new_inputs = Vec::new();\n+        for arg in inputs.iter() {\n+            let new_ty = self.rebuild_arg_ty_or_output(arg.ty, lifetime,\n+                                                       anon_nums, region_names);\n+            let possibly_new_arg = ast::Arg {\n+                ty: new_ty,\n+                pat: arg.pat,\n+                id: arg.id\n+            };\n+            new_inputs.push(possibly_new_arg);\n+        }\n+        new_inputs\n+    }\n+\n+    fn rebuild_arg_ty_or_output(&self,\n+                                ty: ast::P<ast::Ty>,\n+                                lifetime: ast::Lifetime,\n+                                anon_nums: &HashSet<uint>,\n+                                region_names: &HashSet<ast::Name>)\n+                                -> ast::P<ast::Ty> {\n+        let mut new_ty = ty;\n+        let mut ty_queue = vec!(ty);\n+        let mut cur_ty;\n+        while !ty_queue.is_empty() {\n+            cur_ty = ty_queue.shift().unwrap();\n+            match cur_ty.node {\n+                ast::TyRptr(lt_opt, mut_ty) => {\n+                    match lt_opt {\n+                        Some(lt) => if region_names.contains(&lt.name) {\n+                            new_ty = self.rebuild_ty(new_ty, cur_ty,\n+                                                     lifetime, None);\n+                        },\n+                        None => {\n+                            let anon = self.cur_anon.get();\n+                            if anon_nums.contains(&anon) {\n+                                new_ty = self.rebuild_ty(new_ty, cur_ty,\n+                                                         lifetime, None);\n+                                self.track_anon(anon);\n+                            }\n+                            self.inc_and_offset_cur_anon(1);\n+                        }\n+                    }\n+                    ty_queue.push(mut_ty.ty);\n+                }\n+                ast::TyPath(ref path, _, id) => {\n+                    let def_map = self.tcx.def_map.borrow();\n+                    let a_def = match def_map.get().find(&id) {\n+                        None => self.tcx.sess.fatal(format!(\"unbound path {}\",\n+                                                    pprust::path_to_str(path))),\n+                        Some(&d) => d\n+                    };\n+                    match a_def {\n+                        ast::DefTy(did) | ast::DefStruct(did) => {\n+                            let ty::ty_param_bounds_and_ty {\n+                                generics: generics,\n+                                ty: _\n+                            } = ty::lookup_item_type(self.tcx, did);\n+\n+                            let expected = generics.region_param_defs().len();\n+                            let lifetimes = &path.segments.last()\n+                                                 .unwrap().lifetimes;\n+                            let mut insert = Vec::new();\n+                            if lifetimes.len() == 0 {\n+                                let anon = self.cur_anon.get();\n+                                for (i, a) in range(anon,\n+                                                    anon+expected).enumerate() {\n+                                    if anon_nums.contains(&a) {\n+                                        insert.push(i);\n+                                    }\n+                                    self.track_anon(a);\n+                                }\n+                                self.inc_and_offset_cur_anon(expected);\n+                            } else {\n+                                for (i, lt) in lifetimes.iter().enumerate() {\n+                                    if region_names.contains(&lt.name) {\n+                                        insert.push(i);\n+                                    }\n+                                }\n+                            }\n+                            for i in insert.iter() {\n+                                new_ty = self.rebuild_ty(new_ty, cur_ty,\n+                                                         lifetime,\n+                                                         Some((*i, expected)));\n+                            }\n+                        }\n+                        _ => ()\n+                    }\n+\n+                }\n+                _ => ty_queue.push_all_move(ast_util::get_inner_tys(cur_ty))\n+            }\n+        }\n+        new_ty\n+    }\n+\n+    fn rebuild_ty(&self,\n+                  from: ast::P<ast::Ty>,\n+                  to: ast::P<ast::Ty>,\n+                  lifetime: ast::Lifetime,\n+                  index_opt: Option<(uint, uint)>)\n+                  -> ast::P<ast::Ty> {\n+\n+        fn build_to(from: ast::P<ast::Ty>,\n+                    to: ast::P<ast::Ty>)\n+                    -> ast::P<ast::Ty> {\n+            if from.id == to.id {\n+                return to;\n+            }\n+            let new_node = match from.node {\n+                ast::TyRptr(ref lifetime, ref mut_ty) => {\n+                    let new_mut_ty = ast::MutTy {\n+                        ty: build_to(mut_ty.ty, to),\n+                        mutbl: mut_ty.mutbl\n+                    };\n+                    ast::TyRptr(*lifetime, new_mut_ty)\n+                }\n+                ast::TyPtr(ref mut_ty) => {\n+                    let new_mut_ty = ast::MutTy {\n+                        ty: build_to(mut_ty.ty, to),\n+                        mutbl: mut_ty.mutbl\n+                    };\n+                    ast::TyPtr(new_mut_ty)\n+                }\n+                ast::TyBox(ref ty) => ast::TyBox(build_to(*ty, to)),\n+                ast::TyVec(ref ty) => ast::TyVec(build_to(*ty, to)),\n+                ast::TyUniq(ref ty) => ast::TyUniq(build_to(*ty, to)),\n+                ast::TyFixedLengthVec(ref ty, ref e) => {\n+                    ast::TyFixedLengthVec(build_to(*ty, to), *e)\n+                }\n+                ast::TyTup(ref tys) => {\n+                    let mut new_tys = Vec::new();\n+                    for ty in tys.iter() {\n+                        new_tys.push(build_to(*ty, to));\n+                    }\n+                    ast::TyTup(new_tys)\n+                }\n+                ref other => other.clone()\n+            };\n+            @ast::Ty { id: from.id, node: new_node, span: from.span }\n+        }\n+\n+        let new_ty_node = match to.node {\n+            ast::TyRptr(_, mut_ty) => ast::TyRptr(Some(lifetime), mut_ty),\n+            ast::TyPath(ref path, ref bounds, id) => {\n+                let (index, expected) = match index_opt {\n+                    Some((i, e)) => (i, e),\n+                    None => fail!(\"expect index_opt in rebuild_ty/ast::TyPath\")\n+                };\n+                let new_path = self.rebuild_path(path, index,\n+                                                 expected, lifetime);\n+                ast::TyPath(new_path, bounds.clone(), id)\n+            }\n+            _ => fail!(\"expect ast::TyRptr or ast::TyPath\")\n+        };\n+        let new_ty = @ast::Ty {\n+            id: to.id,\n+            node: new_ty_node,\n+            span: to.span\n+        };\n+        build_to(from, new_ty)\n+    }\n+\n+    fn rebuild_path(&self,\n+                    path: &ast::Path,\n+                    index: uint,\n+                    expected: uint,\n+                    lifetime: ast::Lifetime)\n+                    -> ast::Path {\n+        let last_seg = path.segments.last().unwrap();\n+        let mut new_lts = Vec::new();\n+        if last_seg.lifetimes.len() == 0 {\n+            for i in range(0, expected) {\n+                if i == index {\n+                    new_lts.push(lifetime);\n+                } else {\n+                    new_lts.push(self.life_giver.give_lifetime());\n+                }\n+            }\n+        } else {\n+            for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n+                if i == index {\n+                    new_lts.push(lifetime);\n+                } else {\n+                    new_lts.push(*lt);\n+                }\n+            }\n+        }\n+        let new_seg = ast::PathSegment {\n+            identifier: last_seg.identifier,\n+            lifetimes: new_lts,\n+            types: last_seg.types.clone(),\n+        };\n+        let mut new_segs = Vec::new();\n+        new_segs.push_all(path.segments.init());\n+        new_segs.push(new_seg);\n+        ast::Path {\n+            span: path.span,\n+            global: path.global,\n+            segments: new_segs\n+        }\n+    }\n }\n \n impl ErrorReportingHelpers for InferCtxt {\n+    fn give_expl_lifetime_param(&self,\n+                                inputs: Vec<ast::Arg>,\n+                                output: ast::P<ast::Ty>,\n+                                item: ast::P<ast::Item>,\n+                                generics: ast::Generics) {\n+        let (fn_decl, purity, ident) = match item.node {\n+            // FIXME: handling method\n+            ast::ItemFn(ref fn_decl, ref purity, _, _, _) => {\n+                (fn_decl, purity, item.ident)\n+            },\n+            _ => fail!(\"Expect function or method\")\n+\n+        };\n+        let fd = ast::FnDecl {\n+            inputs: inputs,\n+            output: output,\n+            cf: fn_decl.cf,\n+            variadic: fn_decl.variadic\n+        };\n+        let suggested_fn =\n+            pprust::fun_to_str(&fd, *purity, ident, None, &generics);\n+        let msg = format!(\"consider using an explicit lifetime \\\n+                           parameter as shown: {}\", suggested_fn);\n+        self.tcx.sess.span_note(item.span, msg);\n+    }\n+\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n         let var_description = match var_origin {\n@@ -665,3 +1227,62 @@ impl Resolvable for @ty::TraitRef {\n     }\n }\n \n+// LifeGiver is responsible for generating fresh lifetime names\n+struct LifeGiver {\n+    taken: HashSet<~str>,\n+    counter: Cell<uint>,\n+    generated: RefCell<Vec<ast::Lifetime>>,\n+}\n+\n+impl LifeGiver {\n+    // FIXME: `taken` needs to include names from higher scope, too\n+    fn with_taken(taken: &[ast::Lifetime]) -> LifeGiver {\n+        let mut taken_ = HashSet::new();\n+        for lt in taken.iter() {\n+            let lt_name = token::get_name(lt.name).get().to_owned();\n+            taken_.insert(lt_name);\n+        }\n+        LifeGiver {\n+            taken: taken_,\n+            counter: Cell::new(0),\n+            generated: RefCell::new(Vec::new()),\n+        }\n+    }\n+\n+    fn inc_counter(&self) {\n+        let c = self.counter.get();\n+        self.counter.set(c+1);\n+    }\n+\n+    fn give_lifetime(&self) -> ast::Lifetime {\n+        let mut lifetime;\n+        loop {\n+            let s = num_to_str(self.counter.get());\n+            if !self.taken.contains(&s) {\n+                lifetime = name_to_dummy_lifetime(\n+                                    token::str_to_ident(s.as_slice()).name);\n+                let mut generated = self.generated.borrow_mut();\n+                generated.get().push(lifetime);\n+                break;\n+            }\n+            self.inc_counter();\n+        }\n+        self.inc_counter();\n+        return lifetime;\n+\n+        // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n+        fn num_to_str(counter: uint) -> ~str {\n+            let mut s = ~\"\";\n+            let (n, r) = (counter/26 + 1, counter % 26);\n+            let letter: char = from_u32((r+97) as u32).unwrap();\n+            for _ in range(0, n) {\n+                s.push_char(letter);\n+            }\n+            return s;\n+        }\n+    }\n+\n+    fn get_generated_lifetimes(&self) -> Vec<ast::Lifetime> {\n+        self.generated.get()\n+    }\n+}"}, {"sha": "e10aa8159d0e4d1f939f93a5fe6623aacaeab9bb", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=9faa2a58f2403165eed7caefbac30b17d93f0837", "patch": "@@ -202,6 +202,7 @@ pub enum SubregionOrigin {\n /// Reasons to create a region inference variable\n ///\n /// See `error_reporting.rs` for more details\n+#[deriving(Clone)]\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring"}, {"sha": "a90c89db49f424c5599a336e35c836c78a6e2d40", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=9faa2a58f2403165eed7caefbac30b17d93f0837", "patch": "@@ -12,12 +12,12 @@\n \n \n use middle::ty;\n-use middle::ty::{FreeRegion, Region, RegionVid, Vid};\n+use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid, Vid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound,\n                  ReLateBound};\n use middle::ty::{ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::typeck::infer::cres;\n-use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n+use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin, TypeTrace};\n use middle::typeck::infer;\n use middle::graph;\n use middle::graph::{Direction, NodeIndex};\n@@ -60,6 +60,7 @@ pub enum CombineMapType {\n     Lub, Glb\n }\n \n+#[deriving(Clone)]\n pub enum RegionResolutionError {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n@@ -83,6 +84,41 @@ pub enum RegionResolutionError {\n     SupSupConflict(RegionVariableOrigin,\n                    SubregionOrigin, Region,\n                    SubregionOrigin, Region),\n+\n+    /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n+    /// more specific errors message by suggesting to the user where they\n+    /// should put a lifetime. In those cases we process and put those errors\n+    /// into `ProcessedErrors` before we do any reporting.\n+    ProcessedErrors(Vec<RegionVariableOrigin>,\n+                    Vec<(TypeTrace, ty::type_err)>,\n+                    Vec<SameRegions>),\n+}\n+\n+/// SameRegions is used to group regions that we think are the same and would\n+/// like to indicate so to the user.\n+/// For example, the following function\n+/// ```\n+/// struct Foo { bar: int }\n+/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b int {\n+///    &x.bar\n+/// }\n+/// ```\n+/// would report an error because we expect 'a and 'b to match, and so we group\n+/// 'a and 'b together inside a SameRegions struct\n+#[deriving(Clone)]\n+pub struct SameRegions {\n+    scope_id: ast::NodeId,\n+    regions: Vec<BoundRegion>\n+}\n+\n+impl SameRegions {\n+    pub fn contains(&self, other: &BoundRegion) -> bool {\n+        self.regions.contains(other)\n+    }\n+\n+    pub fn push(&mut self, other: BoundRegion) {\n+        self.regions.push(other);\n+    }\n }\n \n pub type CombineMap = HashMap<TwoRegions, RegionVid>;"}, {"sha": "da6278aaae9ea0adf070261de4425298cd03e439", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9faa2a58f2403165eed7caefbac30b17d93f0837", "patch": "@@ -11,6 +11,7 @@\n use ast::*;\n use ast;\n use ast_util;\n+use codemap;\n use codemap::Span;\n use opt_vec;\n use parse::token;\n@@ -208,6 +209,12 @@ pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> @Pat {\n                 span: s }\n }\n \n+pub fn name_to_dummy_lifetime(name: Name) -> Lifetime {\n+    Lifetime { id: DUMMY_NODE_ID,\n+               span: codemap::DUMMY_SP,\n+               name: name }\n+}\n+\n pub fn is_unguarded(a: &Arm) -> bool {\n     match a.guard {\n       None => true,\n@@ -684,6 +691,20 @@ pub fn lit_is_str(lit: @Lit) -> bool {\n     }\n }\n \n+pub fn get_inner_tys(ty: P<Ty>) -> Vec<P<Ty>> {\n+    match ty.node {\n+        ast::TyRptr(_, mut_ty) | ast::TyPtr(mut_ty) => {\n+            vec!(mut_ty.ty)\n+        }\n+        ast::TyBox(ty)\n+        | ast::TyVec(ty)\n+        | ast::TyUniq(ty)\n+        | ast::TyFixedLengthVec(ty, _) => vec!(ty),\n+        ast::TyTup(ref tys) => tys.clone(),\n+        _ => Vec::new()\n+    }\n+}\n+\n \n #[cfg(test)]\n mod test {"}, {"sha": "709f15d3552458159c2fdcfe57e0ad54b9250ee2", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faa2a58f2403165eed7caefbac30b17d93f0837/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=9faa2a58f2403165eed7caefbac30b17d93f0837", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+struct Foo<'x> { bar: int }\n+fn foo1(x: &Foo) -> &int {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo1<'a>(x: &'a Foo) -> &'a int\n+    &x.bar //~ ERROR: cannot infer\n+}\n+\n+fn foo2<'a, 'b>(x: &'a Foo) -> &'b int {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo2<'c>(x: &'c Foo) -> &'c int\n+    &x.bar //~ ERROR: cannot infer\n+}\n+\n+fn foo3(x: &Foo) -> (&int, &int) {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo3<'a>(x: &'a Foo) -> (&'a int, &'a int)\n+    (&x.bar, &x.bar) //~ ERROR: cannot infer\n+    //~^ ERROR: cannot infer\n+}\n+\n+fn foo4<'a, 'b>(x: &'a Foo) -> (&'b int, &'a int, &int) {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo4<'c>(x: &'c Foo) -> (&'c int, &'c int, &'c int)\n+    (&x.bar, &x.bar, &x.bar) //~ ERROR: cannot infer\n+    //~^ ERROR: cannot infer\n+}\n+\n+fn foo5(x: &int) -> &int {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo5<'a>(x: &'a int) -> &'a int\n+    x //~ ERROR: mismatched types\n+    //~^ ERROR: cannot infer\n+}\n+\n+struct Bar<'x, 'y, 'z> { bar: &'y int, baz: int }\n+fn bar1(x: &Bar) -> (&int, &int, &int) {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar1<'a, 'b, 'c, 'd>(x: &'d Bar<'b, 'a, 'c>) -> (&'a int, &'d int, &'d int)\n+    (x.bar, &x.baz, &x.baz) //~ ERROR: mismatched types\n+    //~^ ERROR: cannot infer\n+    //~^^ ERROR: cannot infer\n+}\n+\n+fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&int, &int, &int) {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar2<'d, 'e, 'a, 'c>(x: &'e Bar<'a, 'd, 'c>) -> (&'d int, &'e int, &'e int)\n+    (x.bar, &x.baz, &x.baz) //~ ERROR: mismatched types\n+    //~^ ERROR: cannot infer\n+    //~^^ ERROR: cannot infer\n+}\n+\n+\n+fn main() {}"}]}