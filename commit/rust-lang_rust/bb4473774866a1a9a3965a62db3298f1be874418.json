{"sha": "bb4473774866a1a9a3965a62db3298f1be874418", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNDQ3Mzc3NDg2NmExYTlhMzk2NWE2MmRiMzI5OGYxYmU4NzQ0MTg=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-03T22:22:11Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-29T00:40:47Z"}, "message": "libcollections: Use NonZero in Vec.", "tree": {"sha": "ea523de3e9476f207ff04ca79d3915eb19cb03b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea523de3e9476f207ff04ca79d3915eb19cb03b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb4473774866a1a9a3965a62db3298f1be874418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb4473774866a1a9a3965a62db3298f1be874418", "html_url": "https://github.com/rust-lang/rust/commit/bb4473774866a1a9a3965a62db3298f1be874418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb4473774866a1a9a3965a62db3298f1be874418/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef5da14edb09d6425b1b6576d418e12c268ddf17", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5da14edb09d6425b1b6576d418e12c268ddf17", "html_url": "https://github.com/rust-lang/rust/commit/ef5da14edb09d6425b1b6576d418e12c268ddf17"}], "stats": {"total": 57, "additions": 32, "deletions": 25}, "files": [{"sha": "0739cef335336040259d0f5588fa404c522c1ef4", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bb4473774866a1a9a3965a62db3298f1be874418/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4473774866a1a9a3965a62db3298f1be874418/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=bb4473774866a1a9a3965a62db3298f1be874418", "patch": "@@ -58,7 +58,7 @@ use core::kinds::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n use core::num::{Int, UnsignedInt};\n use core::ops;\n-use core::ptr::{mod, Unique};\n+use core::ptr::{mod, NonZero};\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n@@ -133,7 +133,7 @@ use slice::CloneSliceExt;\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Vec<T> {\n-    ptr: Unique<T>,\n+    ptr: NonZero<*mut T>,\n     len: uint,\n     cap: uint,\n }\n@@ -176,7 +176,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { ptr: Unique(EMPTY as *mut T), len: 0, cap: 0 }\n+        Vec { ptr: NonZero(EMPTY as *mut T), len: 0, cap: 0 }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -209,15 +209,15 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: Unique(EMPTY as *mut T), len: 0, cap: uint::MAX }\n+            Vec { ptr: NonZero(EMPTY as *mut T), len: 0, cap: uint::MAX }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             if ptr.is_null() { ::alloc::oom() }\n-            Vec { ptr: Unique(ptr as *mut T), len: 0, cap: capacity }\n+            Vec { ptr: NonZero(ptr as *mut T), len: 0, cap: capacity }\n         }\n     }\n \n@@ -284,7 +284,7 @@ impl<T> Vec<T> {\n     #[unstable = \"needs finalization\"]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n-        Vec { ptr: Unique(ptr), len: length, cap: capacity }\n+        Vec { ptr: NonZero(ptr), len: length, cap: capacity }\n     }\n \n     /// Creates a vector by copying the elements from a raw pointer.\n@@ -792,22 +792,24 @@ impl<T> Vec<T> {\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n+        let NonZero(ptr) = self.ptr;\n         if self.len == 0 {\n             if self.cap != 0 {\n                 unsafe {\n-                    dealloc(self.ptr.0, self.cap)\n+                    dealloc(ptr, self.cap)\n                 }\n                 self.cap = 0;\n             }\n         } else {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at\n                 // least this large.\n-                self.ptr = Unique(reallocate(self.ptr.0 as *mut u8,\n-                                               self.cap * mem::size_of::<T>(),\n-                                               self.len * mem::size_of::<T>(),\n-                                               mem::min_align_of::<T>()) as *mut T);\n-                if self.ptr.0.is_null() { ::alloc::oom() }\n+                let ptr = reallocate(ptr as *mut u8,\n+                                     self.cap * mem::size_of::<T>(),\n+                                     self.len * mem::size_of::<T>(),\n+                                     mem::min_align_of::<T>()) as *mut T;\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero(ptr);\n             }\n             self.cap = self.len;\n         }\n@@ -865,9 +867,10 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        let NonZero(ptr) = self.ptr;\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr.0 as *const T,\n+                data: ptr as *const T,\n                 len: self.len,\n             })\n         }\n@@ -890,9 +893,9 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n-            let ptr = self.ptr.0;\n+            let NonZero(ptr) = self.ptr;\n             let cap = self.cap;\n-            let begin = self.ptr.0 as *const T;\n+            let begin = ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n                 (ptr as uint + self.len()) as *const T\n             } else {\n@@ -1110,14 +1113,16 @@ impl<T> Vec<T> {\n             let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n             if old_size > size { panic!(\"capacity overflow\") }\n             unsafe {\n-                self.ptr = Unique(alloc_or_realloc(self.ptr.0, old_size, size));\n-                if self.ptr.0.is_null() { ::alloc::oom() }\n+                let NonZero(ptr) = self.ptr;\n+                let ptr = alloc_or_realloc(ptr, old_size, size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero(ptr);\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }\n \n         unsafe {\n-            let end = self.ptr.0.offset(self.len as int);\n+            let NonZero(end) = self.ptr.offset(self.len as int);\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -1231,10 +1236,10 @@ impl<T> Vec<T> {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n-                self.ptr = Unique(alloc_or_realloc(self.ptr.0,\n-                                                     self.cap * mem::size_of::<T>(),\n-                                                     size));\n-                if self.ptr.0.is_null() { ::alloc::oom() }\n+                let NonZero(ptr) = self.ptr;\n+                let ptr = alloc_or_realloc(ptr, self.cap * mem::size_of::<T>(), size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero(ptr);\n             }\n             self.cap = capacity;\n         }\n@@ -1355,9 +1360,10 @@ impl<T> AsSlice<T> for Vec<T> {\n     #[inline]\n     #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n+        let NonZero(ptr) = self.ptr;\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr.0 as *const T,\n+                data: ptr as *const T,\n                 len: self.len\n             })\n         }\n@@ -1382,7 +1388,8 @@ impl<T> Drop for Vec<T> {\n                 for x in self.iter() {\n                     ptr::read(x);\n                 }\n-                dealloc(self.ptr.0, self.cap)\n+                let NonZero(ptr) = self.ptr;\n+                dealloc(ptr, self.cap)\n             }\n         }\n     }\n@@ -1420,7 +1427,7 @@ impl<T> IntoIter<T> {\n             for _x in self { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n-            Vec { ptr: Unique(allocation), cap: cap, len: 0 }\n+            Vec { ptr: NonZero(allocation), cap: cap, len: 0 }\n         }\n     }\n "}]}