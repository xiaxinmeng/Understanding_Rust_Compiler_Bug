{"sha": "c3f84960aa99529a3afc8f28c16e657fb071db5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZjg0OTYwYWE5OTUyOWEzYWZjOGYyOGMxNmU2NTdmYjA3MWRiNWY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-15T11:53:09Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-15T11:53:09Z"}, "message": "Flatten expr module", "tree": {"sha": "ec1b28ac2a90ebbc42d88be3a79065f71ff55db9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec1b28ac2a90ebbc42d88be3a79065f71ff55db9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3f84960aa99529a3afc8f28c16e657fb071db5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3f84960aa99529a3afc8f28c16e657fb071db5f", "html_url": "https://github.com/rust-lang/rust/commit/c3f84960aa99529a3afc8f28c16e657fb071db5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3f84960aa99529a3afc8f28c16e657fb071db5f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f6c0c314b749e25431f3fd6caaac5d3270751b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f6c0c314b749e25431f3fd6caaac5d3270751b6", "html_url": "https://github.com/rust-lang/rust/commit/2f6c0c314b749e25431f3fd6caaac5d3270751b6"}], "stats": {"total": 271, "additions": 130, "deletions": 141}, "files": [{"sha": "078bd86090e87547587d93bebc748206c7c27447", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3f84960aa99529a3afc8f28c16e657fb071db5f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f84960aa99529a3afc8f28c16e657fb071db5f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=c3f84960aa99529a3afc8f28c16e657fb071db5f", "patch": "@@ -23,7 +23,7 @@ use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n use crate::{\n     adt::VariantDef,\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    expr::{validation::ExprValidator, BindingAnnotation, Body, BodySourceMap, Pat, PatId},\n+    expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     generics::{GenericDef, HasGenericParams},\n     ids::{\n         AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,"}, {"sha": "e3733779e9c106a1a375b50071e3257d11895516", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 129, "deletions": 3, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c3f84960aa99529a3afc8f28c16e657fb071db5f/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f84960aa99529a3afc8f28c16e657fb071db5f/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=c3f84960aa99529a3afc8f28c16e657fb071db5f", "patch": "@@ -1,12 +1,19 @@\n //! FIXME: write short doc here\n \n-pub(crate) mod validation;\n-\n use std::sync::Arc;\n \n+use hir_def::path::known;\n+use hir_expand::diagnostics::DiagnosticSink;\n+use ra_syntax::ast;\n use ra_syntax::AstPtr;\n+use rustc_hash::FxHashSet;\n \n-use crate::{db::HirDatabase, DefWithBody, HasBody, Resolver};\n+use crate::{\n+    db::HirDatabase,\n+    diagnostics::{MissingFields, MissingOkInTailExpr},\n+    ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n+    Adt, DefWithBody, Function, HasBody, Name, Path, Resolver,\n+};\n \n pub use hir_def::{\n     body::{\n@@ -42,3 +49,122 @@ pub(crate) fn resolver_for_scope(\n     }\n     r\n }\n+\n+pub(crate) struct ExprValidator<'a, 'b: 'a> {\n+    func: Function,\n+    infer: Arc<InferenceResult>,\n+    sink: &'a mut DiagnosticSink<'b>,\n+}\n+\n+impl<'a, 'b> ExprValidator<'a, 'b> {\n+    pub(crate) fn new(\n+        func: Function,\n+        infer: Arc<InferenceResult>,\n+        sink: &'a mut DiagnosticSink<'b>,\n+    ) -> ExprValidator<'a, 'b> {\n+        ExprValidator { func, infer, sink }\n+    }\n+\n+    pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n+        let body = self.func.body(db);\n+\n+        for e in body.exprs() {\n+            if let (id, Expr::RecordLit { path, fields, spread }) = e {\n+                self.validate_record_literal(id, path, fields, *spread, db);\n+            }\n+        }\n+\n+        let body_expr = &body[body.body_expr()];\n+        if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n+            self.validate_results_in_tail_expr(body.body_expr(), *t, db);\n+        }\n+    }\n+\n+    fn validate_record_literal(\n+        &mut self,\n+        id: ExprId,\n+        _path: &Option<Path>,\n+        fields: &[RecordLitField],\n+        spread: Option<ExprId>,\n+        db: &impl HirDatabase,\n+    ) {\n+        if spread.is_some() {\n+            return;\n+        }\n+\n+        let struct_def = match self.infer[id].as_adt() {\n+            Some((Adt::Struct(s), _)) => s,\n+            _ => return,\n+        };\n+\n+        let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n+        let missed_fields: Vec<Name> = struct_def\n+            .fields(db)\n+            .iter()\n+            .filter_map(|f| {\n+                let name = f.name(db);\n+                if lit_fields.contains(&name) {\n+                    None\n+                } else {\n+                    Some(name)\n+                }\n+            })\n+            .collect();\n+        if missed_fields.is_empty() {\n+            return;\n+        }\n+        let source_map = self.func.body_source_map(db);\n+\n+        if let Some(source_ptr) = source_map.expr_syntax(id) {\n+            if let Some(expr) = source_ptr.ast.a() {\n+                let root = source_ptr.file_syntax(db);\n+                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n+                    if let Some(field_list) = record_lit.record_field_list() {\n+                        self.sink.push(MissingFields {\n+                            file: source_ptr.file_id,\n+                            field_list: AstPtr::new(&field_list),\n+                            missed_fields,\n+                        })\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn validate_results_in_tail_expr(\n+        &mut self,\n+        body_id: ExprId,\n+        id: ExprId,\n+        db: &impl HirDatabase,\n+    ) {\n+        // the mismatch will be on the whole block currently\n+        let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n+            Some(m) => m,\n+            None => return,\n+        };\n+\n+        let std_result_path = known::std_result_result();\n+\n+        let resolver = self.func.resolver(db);\n+        let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n+            Some(it) => it,\n+            _ => return,\n+        };\n+\n+        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum));\n+        let params = match &mismatch.expected {\n+            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n+            _ => return,\n+        };\n+\n+        if params.len() == 2 && &params[0] == &mismatch.actual {\n+            let source_map = self.func.body_source_map(db);\n+\n+            if let Some(source_ptr) = source_map.expr_syntax(id) {\n+                if let Some(expr) = source_ptr.ast.a() {\n+                    self.sink.push(MissingOkInTailExpr { file: source_ptr.file_id, expr });\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3054f1dcedf405270db5e98109734d55d5666e31", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6c0c314b749e25431f3fd6caaac5d3270751b6/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=2f6c0c314b749e25431f3fd6caaac5d3270751b6", "patch": "@@ -1,137 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use std::sync::Arc;\n-\n-use hir_def::path::known;\n-use hir_expand::diagnostics::DiagnosticSink;\n-use ra_syntax::ast;\n-use rustc_hash::FxHashSet;\n-\n-use crate::{\n-    db::HirDatabase,\n-    diagnostics::{MissingFields, MissingOkInTailExpr},\n-    expr::AstPtr,\n-    ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n-    Adt, Function, Name, Path,\n-};\n-\n-use super::{Expr, ExprId, RecordLitField};\n-\n-pub(crate) struct ExprValidator<'a, 'b: 'a> {\n-    func: Function,\n-    infer: Arc<InferenceResult>,\n-    sink: &'a mut DiagnosticSink<'b>,\n-}\n-\n-impl<'a, 'b> ExprValidator<'a, 'b> {\n-    pub(crate) fn new(\n-        func: Function,\n-        infer: Arc<InferenceResult>,\n-        sink: &'a mut DiagnosticSink<'b>,\n-    ) -> ExprValidator<'a, 'b> {\n-        ExprValidator { func, infer, sink }\n-    }\n-\n-    pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n-        let body = self.func.body(db);\n-\n-        for e in body.exprs() {\n-            if let (id, Expr::RecordLit { path, fields, spread }) = e {\n-                self.validate_record_literal(id, path, fields, *spread, db);\n-            }\n-        }\n-\n-        let body_expr = &body[body.body_expr()];\n-        if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n-            self.validate_results_in_tail_expr(body.body_expr(), *t, db);\n-        }\n-    }\n-\n-    fn validate_record_literal(\n-        &mut self,\n-        id: ExprId,\n-        _path: &Option<Path>,\n-        fields: &[RecordLitField],\n-        spread: Option<ExprId>,\n-        db: &impl HirDatabase,\n-    ) {\n-        if spread.is_some() {\n-            return;\n-        }\n-\n-        let struct_def = match self.infer[id].as_adt() {\n-            Some((Adt::Struct(s), _)) => s,\n-            _ => return,\n-        };\n-\n-        let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n-        let missed_fields: Vec<Name> = struct_def\n-            .fields(db)\n-            .iter()\n-            .filter_map(|f| {\n-                let name = f.name(db);\n-                if lit_fields.contains(&name) {\n-                    None\n-                } else {\n-                    Some(name)\n-                }\n-            })\n-            .collect();\n-        if missed_fields.is_empty() {\n-            return;\n-        }\n-        let source_map = self.func.body_source_map(db);\n-\n-        if let Some(source_ptr) = source_map.expr_syntax(id) {\n-            if let Some(expr) = source_ptr.ast.a() {\n-                let root = source_ptr.file_syntax(db);\n-                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n-                    if let Some(field_list) = record_lit.record_field_list() {\n-                        self.sink.push(MissingFields {\n-                            file: source_ptr.file_id,\n-                            field_list: AstPtr::new(&field_list),\n-                            missed_fields,\n-                        })\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn validate_results_in_tail_expr(\n-        &mut self,\n-        body_id: ExprId,\n-        id: ExprId,\n-        db: &impl HirDatabase,\n-    ) {\n-        // the mismatch will be on the whole block currently\n-        let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n-            Some(m) => m,\n-            None => return,\n-        };\n-\n-        let std_result_path = known::std_result_result();\n-\n-        let resolver = self.func.resolver(db);\n-        let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n-            Some(it) => it,\n-            _ => return,\n-        };\n-\n-        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum));\n-        let params = match &mismatch.expected {\n-            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n-            _ => return,\n-        };\n-\n-        if params.len() == 2 && &params[0] == &mismatch.actual {\n-            let source_map = self.func.body_source_map(db);\n-\n-            if let Some(source_ptr) = source_map.expr_syntax(id) {\n-                if let Some(expr) = source_ptr.ast.a() {\n-                    self.sink.push(MissingOkInTailExpr { file: source_ptr.file_id, expr });\n-                }\n-            }\n-        }\n-    }\n-}"}]}