{"sha": "d0a746ecfae82c30cc9e440449fa6bd340305216", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYTc0NmVjZmFlODJjMzBjYzllNDQwNDQ5ZmE2YmQzNDAzMDUyMTY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-01T09:33:21Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-01T09:33:21Z"}, "message": "remove AllocId generalization of Pointer", "tree": {"sha": "5bfa7ee0c18ea255fa1e8288d8632d5c5d2b2c57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bfa7ee0c18ea255fa1e8288d8632d5c5d2b2c57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0a746ecfae82c30cc9e440449fa6bd340305216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0a746ecfae82c30cc9e440449fa6bd340305216", "html_url": "https://github.com/rust-lang/rust/commit/d0a746ecfae82c30cc9e440449fa6bd340305216", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0a746ecfae82c30cc9e440449fa6bd340305216/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd0bacc694d7d8175804bb6f690cb846bfa4a9ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0bacc694d7d8175804bb6f690cb846bfa4a9ee", "html_url": "https://github.com/rust-lang/rust/commit/bd0bacc694d7d8175804bb6f690cb846bfa4a9ee"}], "stats": {"total": 72, "additions": 33, "deletions": 39}, "files": [{"sha": "848c7fe61d4d7411cfd0f6113703ce8a7bf19b88", "filename": "src/librustc_middle/mir/interpret/pointer.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs?ref=d0a746ecfae82c30cc9e440449fa6bd340305216", "patch": "@@ -101,18 +101,14 @@ pub trait PointerArithmetic: HasDataLayout {\n \n impl<T: HasDataLayout> PointerArithmetic for T {}\n \n-/// `Pointer` is generic over the type that represents a reference to `Allocation`s,\n-/// thus making it possible for the most convenient representation to be used in\n-/// each context.\n+/// Represents a pointer in the Miri engine.\n ///\n-/// Defaults to the index based and loosely coupled `AllocId`.\n-///\n-/// `Pointer` is also generic over the `Tag` associated with each pointer,\n+/// `Pointer` is generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n #[derive(HashStable)]\n-pub struct Pointer<Tag = (), Id = AllocId> {\n-    pub alloc_id: Id,\n+pub struct Pointer<Tag = ()> {\n+    pub alloc_id: AllocId,\n     pub offset: Size,\n     pub tag: Tag,\n }\n@@ -123,7 +119,7 @@ static_assert_size!(Pointer, 16);\n // all the Miri types.\n // We have to use `Debug` output for the tag, because `()` does not implement\n // `Display` so we cannot specialize that.\n-impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Pointer<Tag, Id> {\n+impl<Tag: fmt::Debug> fmt::Debug for Pointer<Tag> {\n     default fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if f.alternate() {\n             write!(f, \"{:#?}+0x{:x}[{:?}]\", self.alloc_id, self.offset.bytes(), self.tag)\n@@ -133,7 +129,7 @@ impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Pointer<Tag, Id> {\n     }\n }\n // Specialization for no tag\n-impl<Id: fmt::Debug> fmt::Debug for Pointer<(), Id> {\n+impl fmt::Debug for Pointer<()> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if f.alternate() {\n             write!(f, \"{:#?}+0x{:x}\", self.alloc_id, self.offset.bytes())"}, {"sha": "ed779d52fb50c96a69c3ccda663ae91fa31ea904", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=d0a746ecfae82c30cc9e440449fa6bd340305216", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// of a simple value or a pointer into another `Allocation`\n #[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n #[derive(HashStable)]\n-pub enum Scalar<Tag = (), Id = AllocId> {\n+pub enum Scalar<Tag = ()> {\n     /// The raw bytes of a simple value.\n     Raw {\n         /// The first `size` bytes of `data` are the value.\n@@ -101,15 +101,15 @@ pub enum Scalar<Tag = (), Id = AllocId> {\n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n     /// relocation and its associated offset together as a `Pointer` here.\n-    Ptr(Pointer<Tag, Id>),\n+    Ptr(Pointer<Tag>),\n }\n \n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(Scalar, 24);\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Scalar<Tag, Id> {\n+impl<Tag: fmt::Debug> fmt::Debug for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr) => write!(f, \"{:?}\", ptr),\n@@ -542,8 +542,8 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable, HashStable, Hash)]\n-pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n-    Scalar(Scalar<Tag, Id>),\n+pub enum ScalarMaybeUndef<Tag = ()> {\n+    Scalar(Scalar<Tag>),\n     Undef,\n }\n \n@@ -563,7 +563,7 @@ impl<Tag> From<Pointer<Tag>> for ScalarMaybeUndef<Tag> {\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for ScalarMaybeUndef<Tag, Id> {\n+impl<Tag: fmt::Debug> fmt::Debug for ScalarMaybeUndef<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ScalarMaybeUndef::Undef => write!(f, \"<uninitialized>\"),"}, {"sha": "f668bafe0803f02a939b8217f444ffd737afef56", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d0a746ecfae82c30cc9e440449fa6bd340305216", "patch": "@@ -11,7 +11,7 @@ use rustc_macros::HashStable;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{\n-    sign_extend, truncate, AllocId, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n+    sign_extend, truncate, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n@@ -103,16 +103,16 @@ pub enum StackPopCleanup {\n \n /// State of a local variable including a memoized layout\n #[derive(Clone, PartialEq, Eq, HashStable)]\n-pub struct LocalState<'tcx, Tag = (), Id = AllocId> {\n-    pub value: LocalValue<Tag, Id>,\n+pub struct LocalState<'tcx, Tag = ()> {\n+    pub value: LocalValue<Tag>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     #[stable_hasher(ignore)]\n     pub layout: Cell<Option<TyAndLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable)] // Miri debug-prints these\n-pub enum LocalValue<Tag = (), Id = AllocId> {\n+pub enum LocalValue<Tag = ()> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n     /// This local is alive but not yet initialized. It can be written to\n@@ -125,7 +125,7 @@ pub enum LocalValue<Tag = (), Id = AllocId> {\n     /// This is an optimization over just always having a pointer here;\n     /// we can thus avoid doing an allocation when the local just stores\n     /// immediate values *and* never has its address taken.\n-    Live(Operand<Tag, Id>),\n+    Live(Operand<Tag>),\n }\n \n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {"}, {"sha": "a7107de6c71842a1a720a320aee66f600ecff11e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=d0a746ecfae82c30cc9e440449fa6bd340305216", "patch": "@@ -15,7 +15,7 @@ use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, Integer, LayoutOf,\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    from_known_layout, sign_extend, truncate, AllocId, ConstValue, GlobalId, InterpCx,\n+    from_known_layout, sign_extend, truncate, ConstValue, GlobalId, InterpCx,\n     InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUndef,\n };\n \n@@ -27,9 +27,9 @@ use super::{\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n-pub enum Immediate<Tag = (), Id = AllocId> {\n-    Scalar(ScalarMaybeUndef<Tag, Id>),\n-    ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n+pub enum Immediate<Tag = ()> {\n+    Scalar(ScalarMaybeUndef<Tag>),\n+    ScalarPair(ScalarMaybeUndef<Tag>, ScalarMaybeUndef<Tag>),\n }\n \n impl<Tag> From<ScalarMaybeUndef<Tag>> for Immediate<Tag> {\n@@ -145,9 +145,9 @@ impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n-pub enum Operand<Tag = (), Id = AllocId> {\n-    Immediate(Immediate<Tag, Id>),\n-    Indirect(MemPlace<Tag, Id>),\n+pub enum Operand<Tag = ()> {\n+    Immediate(Immediate<Tag>),\n+    Indirect(MemPlace<Tag>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "fee9ca0c02e39d3170f4b0eaa1f33fc97c908900", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0a746ecfae82c30cc9e440449fa6bd340305216/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d0a746ecfae82c30cc9e440449fa6bd340305216", "patch": "@@ -20,9 +20,9 @@ use super::{\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n /// Information required for the sound usage of a `MemPlace`.\n-pub enum MemPlaceMeta<Tag = (), Id = AllocId> {\n+pub enum MemPlaceMeta<Tag = ()> {\n     /// The unsized payload (e.g. length for slices or vtable pointer for trait objects).\n-    Meta(Scalar<Tag, Id>),\n+    Meta(Scalar<Tag>),\n     /// `Sized` types or unsized `extern type`\n     None,\n     /// The address of this place may not be taken. This protects the `MemPlace` from coming from\n@@ -32,8 +32,8 @@ pub enum MemPlaceMeta<Tag = (), Id = AllocId> {\n     Poison,\n }\n \n-impl<Tag, Id> MemPlaceMeta<Tag, Id> {\n-    pub fn unwrap_meta(self) -> Scalar<Tag, Id> {\n+impl<Tag> MemPlaceMeta<Tag> {\n+    pub fn unwrap_meta(self) -> Scalar<Tag> {\n         match self {\n             Self::Meta(s) => s,\n             Self::None | Self::Poison => {\n@@ -47,9 +47,7 @@ impl<Tag, Id> MemPlaceMeta<Tag, Id> {\n             Self::None | Self::Poison => false,\n         }\n     }\n-}\n \n-impl<Tag> MemPlaceMeta<Tag> {\n     pub fn erase_tag(self) -> MemPlaceMeta<()> {\n         match self {\n             Self::Meta(s) => MemPlaceMeta::Meta(s.erase_tag()),\n@@ -60,22 +58,22 @@ impl<Tag> MemPlaceMeta<Tag> {\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n-pub struct MemPlace<Tag = (), Id = AllocId> {\n+pub struct MemPlace<Tag = ()> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n     /// However, it may never be undef.\n-    pub ptr: Scalar<Tag, Id>,\n+    pub ptr: Scalar<Tag>,\n     pub align: Align,\n     /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g., `extern type`).\n-    pub meta: MemPlaceMeta<Tag, Id>,\n+    pub meta: MemPlaceMeta<Tag>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n-pub enum Place<Tag = (), Id = AllocId> {\n+pub enum Place<Tag = ()> {\n     /// A place referring to a value allocated in the `Memory` system.\n-    Ptr(MemPlace<Tag, Id>),\n+    Ptr(MemPlace<Tag>),\n \n     /// To support alloc-free locals, we are able to write directly to a local.\n     /// (Without that optimization, we'd just always be a `MemPlace`.)"}]}