{"sha": "510ba031dcf119e81834babf83e671b2cc00416a", "node_id": "C_kwDOAAsO6NoAKDUxMGJhMDMxZGNmMTE5ZTgxODM0YmFiZjgzZTY3MWIyY2MwMDQxNmE", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-08-10T16:30:47Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-08-15T11:26:35Z"}, "message": "errors: move translation logic into module\n\nJust moving code around so that triagebot can ping relevant parties when\ntranslation logic is modified.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "ef2711d898d3a8fa001fca4dda5b4bc28f3b24cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef2711d898d3a8fa001fca4dda5b4bc28f3b24cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/510ba031dcf119e81834babf83e671b2cc00416a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/510ba031dcf119e81834babf83e671b2cc00416a", "html_url": "https://github.com/rust-lang/rust/commit/510ba031dcf119e81834babf83e671b2cc00416a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/510ba031dcf119e81834babf83e671b2cc00416a/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ce76091c7cef21692a15dce1f0a4c415d245be4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce76091c7cef21692a15dce1f0a4c415d245be4", "html_url": "https://github.com/rust-lang/rust/commit/6ce76091c7cef21692a15dce1f0a4c415d245be4"}], "stats": {"total": 363, "additions": 200, "deletions": 163}, "files": [{"sha": "2930d09d71f1a61c8c690e24256c6cadc7ceb7e1", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=510ba031dcf119e81834babf83e671b2cc00416a", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n-use rustc_errors::{DiagnosticId, FatalError, Handler, Level};\n+use rustc_errors::{translation::Translate, DiagnosticId, FatalError, Handler, Level};\n use rustc_fs_util::link_or_copy;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental::{\n@@ -1740,6 +1740,16 @@ impl SharedEmitter {\n     }\n }\n \n+impl Translate for SharedEmitter {\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+        panic!(\"shared emitter attempted to translate a diagnostic\");\n+    }\n+}\n+\n impl Emitter for SharedEmitter {\n     fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n         let fluent_args = self.to_fluent_args(diag.args());\n@@ -1761,14 +1771,6 @@ impl Emitter for SharedEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n-\n-    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n-        None\n-    }\n-\n-    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n-        panic!(\"shared emitter attempted to translate a diagnostic\");\n-    }\n }\n \n impl SharedEmitterMain {"}, {"sha": "b32fc3c719bbd91adbdeebe2d62cb97cfd69b7f0", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=510ba031dcf119e81834babf83e671b2cc00416a", "patch": "@@ -7,6 +7,7 @@\n \n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n+use crate::translation::Translate;\n use crate::{\n     CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, Emitter, FluentBundle,\n     LazyFallbackBundle, Level, MultiSpan, Style, SubDiagnostic,\n@@ -32,6 +33,16 @@ pub struct AnnotateSnippetEmitterWriter {\n     macro_backtrace: bool,\n }\n \n+impl Translate for AnnotateSnippetEmitterWriter {\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        self.fluent_bundle.as_ref()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &FluentBundle {\n+        &**self.fallback_bundle\n+    }\n+}\n+\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n@@ -63,14 +74,6 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         self.source_map.as_ref()\n     }\n \n-    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n-        self.fluent_bundle.as_ref()\n-    }\n-\n-    fn fallback_fluent_bundle(&self) -> &FluentBundle {\n-        &**self.fallback_bundle\n-    }\n-\n     fn should_show_explain(&self) -> bool {\n         !self.short_message\n     }"}, {"sha": "6c1bfcb9919eb9df89a3124f90bf16a655da2645", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 18, "deletions": 110, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=510ba031dcf119e81834babf83e671b2cc00416a", "patch": "@@ -14,10 +14,10 @@ use rustc_span::{FileLines, SourceFile, Span};\n \n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n+use crate::translation::Translate;\n use crate::{\n-    CodeSuggestion, Diagnostic, DiagnosticArg, DiagnosticId, DiagnosticMessage, FluentBundle,\n-    Handler, LazyFallbackBundle, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight,\n-    SuggestionStyle,\n+    CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, FluentBundle, Handler,\n+    LazyFallbackBundle, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n };\n \n use rustc_lint_defs::pluralize;\n@@ -200,7 +200,7 @@ impl Margin {\n const ANONYMIZED_LINE_NUM: &str = \"LL\";\n \n /// Emitter trait for emitting errors.\n-pub trait Emitter {\n+pub trait Emitter: Translate {\n     /// Emit a structured diagnostic.\n     fn emit_diagnostic(&mut self, diag: &Diagnostic);\n \n@@ -231,102 +231,6 @@ pub trait Emitter {\n \n     fn source_map(&self) -> Option<&Lrc<SourceMap>>;\n \n-    /// Return `FluentBundle` with localized diagnostics for the locale requested by the user. If no\n-    /// language was requested by the user then this will be `None` and `fallback_fluent_bundle`\n-    /// should be used.\n-    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>>;\n-\n-    /// Return `FluentBundle` with localized diagnostics for the default locale of the compiler.\n-    /// Used when the user has not requested a specific language or when a localized diagnostic is\n-    /// unavailable for the requested locale.\n-    fn fallback_fluent_bundle(&self) -> &FluentBundle;\n-\n-    /// Convert diagnostic arguments (a rustc internal type that exists to implement\n-    /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n-    ///\n-    /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n-    /// passed around as a reference thereafter.\n-    fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n-        FromIterator::from_iter(args.to_vec().drain(..))\n-    }\n-\n-    /// Convert `DiagnosticMessage`s to a string, performing translation if necessary.\n-    fn translate_messages(\n-        &self,\n-        messages: &[(DiagnosticMessage, Style)],\n-        args: &FluentArgs<'_>,\n-    ) -> Cow<'_, str> {\n-        Cow::Owned(\n-            messages.iter().map(|(m, _)| self.translate_message(m, args)).collect::<String>(),\n-        )\n-    }\n-\n-    /// Convert a `DiagnosticMessage` to a string, performing translation if necessary.\n-    fn translate_message<'a>(\n-        &'a self,\n-        message: &'a DiagnosticMessage,\n-        args: &'a FluentArgs<'_>,\n-    ) -> Cow<'_, str> {\n-        trace!(?message, ?args);\n-        let (identifier, attr) = match message {\n-            DiagnosticMessage::Str(msg) => return Cow::Borrowed(&msg),\n-            DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n-        };\n-\n-        let translate_with_bundle = |bundle: &'a FluentBundle| -> Option<(Cow<'_, str>, Vec<_>)> {\n-            let message = bundle.get_message(&identifier)?;\n-            let value = match attr {\n-                Some(attr) => message.get_attribute(attr)?.value(),\n-                None => message.value()?,\n-            };\n-            debug!(?message, ?value);\n-\n-            let mut errs = vec![];\n-            let translated = bundle.format_pattern(value, Some(&args), &mut errs);\n-            debug!(?translated, ?errs);\n-            Some((translated, errs))\n-        };\n-\n-        self.fluent_bundle()\n-            .and_then(|bundle| translate_with_bundle(bundle))\n-            // If `translate_with_bundle` returns `None` with the primary bundle, this is likely\n-            // just that the primary bundle doesn't contain the message being translated, so\n-            // proceed to the fallback bundle.\n-            //\n-            // However, when errors are produced from translation, then that means the translation\n-            // is broken (e.g. `{$foo}` exists in a translation but `foo` isn't provided).\n-            //\n-            // In debug builds, assert so that compiler devs can spot the broken translation and\n-            // fix it..\n-            .inspect(|(_, errs)| {\n-                debug_assert!(\n-                    errs.is_empty(),\n-                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n-                    identifier,\n-                    attr,\n-                    args,\n-                    errs\n-                );\n-            })\n-            // ..otherwise, for end users, an error about this wouldn't be useful or actionable, so\n-            // just hide it and try with the fallback bundle.\n-            .filter(|(_, errs)| errs.is_empty())\n-            .or_else(|| translate_with_bundle(self.fallback_fluent_bundle()))\n-            .map(|(translated, errs)| {\n-                // Always bail out for errors with the fallback bundle.\n-                assert!(\n-                    errs.is_empty(),\n-                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n-                    identifier,\n-                    attr,\n-                    args,\n-                    errs\n-                );\n-                translated\n-            })\n-            .expect(\"failed to find message in primary or fallback fluent bundles\")\n-    }\n-\n     /// Formats the substitutions of the primary_span\n     ///\n     /// There are a lot of conditions to this method, but in short:\n@@ -616,18 +520,20 @@ pub trait Emitter {\n     }\n }\n \n-impl Emitter for EmitterWriter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        self.sm.as_ref()\n-    }\n-\n+impl Translate for EmitterWriter {\n     fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n         self.fluent_bundle.as_ref()\n     }\n \n     fn fallback_fluent_bundle(&self) -> &FluentBundle {\n         &**self.fallback_bundle\n     }\n+}\n+\n+impl Emitter for EmitterWriter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        self.sm.as_ref()\n+    }\n \n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n         let fluent_args = self.to_fluent_args(diag.args());\n@@ -672,18 +578,20 @@ pub struct SilentEmitter {\n     pub fatal_note: Option<String>,\n }\n \n-impl Emitter for SilentEmitter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-\n+impl Translate for SilentEmitter {\n     fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n         None\n     }\n \n     fn fallback_fluent_bundle(&self) -> &FluentBundle {\n         panic!(\"silent emitter attempted to translate message\")\n     }\n+}\n+\n+impl Emitter for SilentEmitter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n \n     fn emit_diagnostic(&mut self, d: &Diagnostic) {\n         if d.level == Level::Fatal {"}, {"sha": "1680c6accd78c8fc018581f4d1f955e0eda3bcc8", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=510ba031dcf119e81834babf83e671b2cc00416a", "patch": "@@ -13,6 +13,7 @@ use rustc_span::source_map::{FilePathMapping, SourceMap};\n \n use crate::emitter::{Emitter, HumanReadableErrorType};\n use crate::registry::Registry;\n+use crate::translation::Translate;\n use crate::DiagnosticId;\n use crate::{\n     CodeSuggestion, FluentBundle, LazyFallbackBundle, MultiSpan, SpanLabel, SubDiagnostic,\n@@ -122,6 +123,16 @@ impl JsonEmitter {\n     }\n }\n \n+impl Translate for JsonEmitter {\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        self.fluent_bundle.as_ref()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &FluentBundle {\n+        &**self.fallback_bundle\n+    }\n+}\n+\n impl Emitter for JsonEmitter {\n     fn emit_diagnostic(&mut self, diag: &crate::Diagnostic) {\n         let data = Diagnostic::from_errors_diagnostic(diag, self);\n@@ -189,14 +200,6 @@ impl Emitter for JsonEmitter {\n         Some(&self.sm)\n     }\n \n-    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n-        self.fluent_bundle.as_ref()\n-    }\n-\n-    fn fallback_fluent_bundle(&self) -> &FluentBundle {\n-        &**self.fallback_bundle\n-    }\n-\n     fn should_show_explain(&self) -> bool {\n         !matches!(self.json_rendered, HumanReadableErrorType::Short(_))\n     }"}, {"sha": "53e787afc38f1155adb39f0986a7f63ab0bd2731", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=510ba031dcf119e81834babf83e671b2cc00416a", "patch": "@@ -58,6 +58,7 @@ mod lock;\n pub mod registry;\n mod snippet;\n mod styled_buffer;\n+pub mod translation;\n \n pub use snippet::Style;\n "}, {"sha": "65338f56d9ccb5ea545c607095c61966e8191f4e", "filename": "compiler/rustc_errors/src/translation.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510ba031dcf119e81834babf83e671b2cc00416a/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=510ba031dcf119e81834babf83e671b2cc00416a", "patch": "@@ -0,0 +1,103 @@\n+use crate::snippet::Style;\n+use crate::{DiagnosticArg, DiagnosticMessage, FluentBundle};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::FluentArgs;\n+use std::borrow::Cow;\n+\n+pub trait Translate {\n+    /// Return `FluentBundle` with localized diagnostics for the locale requested by the user. If no\n+    /// language was requested by the user then this will be `None` and `fallback_fluent_bundle`\n+    /// should be used.\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>>;\n+\n+    /// Return `FluentBundle` with localized diagnostics for the default locale of the compiler.\n+    /// Used when the user has not requested a specific language or when a localized diagnostic is\n+    /// unavailable for the requested locale.\n+    fn fallback_fluent_bundle(&self) -> &FluentBundle;\n+\n+    /// Convert diagnostic arguments (a rustc internal type that exists to implement\n+    /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n+    ///\n+    /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n+    /// passed around as a reference thereafter.\n+    fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n+        FromIterator::from_iter(args.to_vec().drain(..))\n+    }\n+\n+    /// Convert `DiagnosticMessage`s to a string, performing translation if necessary.\n+    fn translate_messages(\n+        &self,\n+        messages: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n+    ) -> Cow<'_, str> {\n+        Cow::Owned(\n+            messages.iter().map(|(m, _)| self.translate_message(m, args)).collect::<String>(),\n+        )\n+    }\n+\n+    /// Convert a `DiagnosticMessage` to a string, performing translation if necessary.\n+    fn translate_message<'a>(\n+        &'a self,\n+        message: &'a DiagnosticMessage,\n+        args: &'a FluentArgs<'_>,\n+    ) -> Cow<'_, str> {\n+        trace!(?message, ?args);\n+        let (identifier, attr) = match message {\n+            DiagnosticMessage::Str(msg) => return Cow::Borrowed(&msg),\n+            DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n+        };\n+\n+        let translate_with_bundle = |bundle: &'a FluentBundle| -> Option<(Cow<'_, str>, Vec<_>)> {\n+            let message = bundle.get_message(&identifier)?;\n+            let value = match attr {\n+                Some(attr) => message.get_attribute(attr)?.value(),\n+                None => message.value()?,\n+            };\n+            debug!(?message, ?value);\n+\n+            let mut errs = vec![];\n+            let translated = bundle.format_pattern(value, Some(&args), &mut errs);\n+            debug!(?translated, ?errs);\n+            Some((translated, errs))\n+        };\n+\n+        self.fluent_bundle()\n+            .and_then(|bundle| translate_with_bundle(bundle))\n+            // If `translate_with_bundle` returns `None` with the primary bundle, this is likely\n+            // just that the primary bundle doesn't contain the message being translated, so\n+            // proceed to the fallback bundle.\n+            //\n+            // However, when errors are produced from translation, then that means the translation\n+            // is broken (e.g. `{$foo}` exists in a translation but `foo` isn't provided).\n+            //\n+            // In debug builds, assert so that compiler devs can spot the broken translation and\n+            // fix it..\n+            .inspect(|(_, errs)| {\n+                debug_assert!(\n+                    errs.is_empty(),\n+                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n+                    identifier,\n+                    attr,\n+                    args,\n+                    errs\n+                );\n+            })\n+            // ..otherwise, for end users, an error about this wouldn't be useful or actionable, so\n+            // just hide it and try with the fallback bundle.\n+            .filter(|(_, errs)| errs.is_empty())\n+            .or_else(|| translate_with_bundle(self.fallback_fluent_bundle()))\n+            .map(|(translated, errs)| {\n+                // Always bail out for errors with the fallback bundle.\n+                assert!(\n+                    errs.is_empty(),\n+                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n+                    identifier,\n+                    attr,\n+                    args,\n+                    errs\n+                );\n+                translated\n+            })\n+            .expect(\"failed to find message in primary or fallback fluent bundles\")\n+    }\n+}"}, {"sha": "381ac7a5deef1ad580d4d7237f1ee2d72a91736e", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/510ba031dcf119e81834babf83e671b2cc00416a/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510ba031dcf119e81834babf83e671b2cc00416a/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=510ba031dcf119e81834babf83e671b2cc00416a", "patch": "@@ -1,7 +1,8 @@\n //! Validates syntax inside Rust code blocks (\\`\\`\\`rust).\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{\n-    emitter::Emitter, Applicability, Diagnostic, Handler, LazyFallbackBundle, LintDiagnosticBuilder,\n+    emitter::Emitter, translation::Translate, Applicability, Diagnostic, Handler,\n+    LazyFallbackBundle, LintDiagnosticBuilder,\n };\n use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n@@ -181,6 +182,16 @@ struct BufferEmitter {\n     fallback_bundle: LazyFallbackBundle,\n }\n \n+impl Translate for BufferEmitter {\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+        &**self.fallback_bundle\n+    }\n+}\n+\n impl Emitter for BufferEmitter {\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n         let mut buffer = self.buffer.borrow_mut();\n@@ -194,12 +205,4 @@ impl Emitter for BufferEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n-\n-    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n-        None\n-    }\n-\n-    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n-        &**self.fallback_bundle\n-    }\n }"}, {"sha": "6efeee98fea6c2671446bd45e03216a2a55bbdf0", "filename": "src/tools/rustfmt/src/parse/session.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/510ba031dcf119e81834babf83e671b2cc00416a/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510ba031dcf119e81834babf83e671b2cc00416a/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs?ref=510ba031dcf119e81834babf83e671b2cc00416a", "patch": "@@ -3,6 +3,7 @@ use std::sync::atomic::{AtomicBool, Ordering};\n \n use rustc_data_structures::sync::{Lrc, Send};\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n+use rustc_errors::translation::Translate;\n use rustc_errors::{ColorConfig, Diagnostic, Handler, Level as DiagnosticLevel};\n use rustc_session::parse::ParseSess as RawParseSess;\n use rustc_span::{\n@@ -28,19 +29,24 @@ pub(crate) struct ParseSess {\n /// Emitter which discards every error.\n struct SilentEmitter;\n \n-impl Emitter for SilentEmitter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-    fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+impl Translate for SilentEmitter {\n     fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n         None\n     }\n+\n     fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n         panic!(\"silent emitter attempted to translate a diagnostic\");\n     }\n }\n \n+impl Emitter for SilentEmitter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n+\n+    fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+}\n+\n fn silent_emitter() -> Box<dyn Emitter + Send> {\n     Box::new(SilentEmitter {})\n }\n@@ -62,10 +68,21 @@ impl SilentOnIgnoredFilesEmitter {\n     }\n }\n \n+impl Translate for SilentOnIgnoredFilesEmitter {\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        self.emitter.fluent_bundle()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+        self.emitter.fallback_fluent_bundle()\n+    }\n+}\n+\n impl Emitter for SilentOnIgnoredFilesEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n     fn emit_diagnostic(&mut self, db: &Diagnostic) {\n         if db.level() == DiagnosticLevel::Fatal {\n             return self.handle_non_ignoreable_error(db);\n@@ -88,14 +105,6 @@ impl Emitter for SilentOnIgnoredFilesEmitter {\n         }\n         self.handle_non_ignoreable_error(db);\n     }\n-\n-    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n-        self.emitter.fluent_bundle()\n-    }\n-\n-    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n-        self.emitter.fallback_fluent_bundle()\n-    }\n }\n \n fn default_handler(\n@@ -340,19 +349,24 @@ mod tests {\n             num_emitted_errors: Lrc<AtomicU32>,\n         }\n \n+        impl Translate for TestEmitter {\n+            fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+                None\n+            }\n+\n+            fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+                panic!(\"test emitter attempted to translate a diagnostic\");\n+            }\n+        }\n+\n         impl Emitter for TestEmitter {\n             fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n                 None\n             }\n+\n             fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n                 self.num_emitted_errors.fetch_add(1, Ordering::Release);\n             }\n-            fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n-                None\n-            }\n-            fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n-                panic!(\"test emitter attempted to translate a diagnostic\");\n-            }\n         }\n \n         fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {"}]}