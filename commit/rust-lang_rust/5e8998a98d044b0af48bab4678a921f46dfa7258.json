{"sha": "5e8998a98d044b0af48bab4678a921f46dfa7258", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlODk5OGE5OGQwNDRiMGFmNDhiYWI0Njc4YTkyMWY0NmRmYTcyNTg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-02T11:47:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-02T11:47:24Z"}, "message": "Rollup merge of #59444 - cuviper:steps_between, r=scottmcm\n\nImplement useful steps_between for all integers\n\nWe can use `usize::try_from` to convert steps from any size of integer.\nThis enables a meaningful `size_hint()` for larger ranges, rather than\nalways just `(0, None)`. Now they return the true `(len, Some(len))`\nwhen it fits, otherwise `(usize::MAX, None)` for overflow.", "tree": {"sha": "9f1d7a3c7197065bb47d6fb16a5022fcf15634c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f1d7a3c7197065bb47d6fb16a5022fcf15634c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e8998a98d044b0af48bab4678a921f46dfa7258", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJco0vMCRBK7hj4Ov3rIwAAdHIIAI3rvw3Uz9NcKBsFDLVhlqD+\nmhjopmwwQ++PC7VeOmcosSskJUApsSRZl2MuPmKZJmY7Dnv35crPvdbxQXWB/NcJ\nkAn7ixT0eT4eWoWiTE0HGfhD/Skuvi7Q8LCgvte2f0IocfG2pDtOIrMlxHCaqgPg\niH84wrQx8LOnaNftpdhteRmE/PD+7beiYnA9sYlUrEmI+6RDtt8zMDynzmLBEgX0\nWBbBnQXym8lFYiLChfw5eNb5OiOJYgNRRy1qS3XgxZ7Nm2vBykTRsaInkPimR3if\nqNfLG8Qmk6kq2KLcX3dcGv69/wcxzJfWwLAyfD+iaiSJETkZUpJsLWVpoxNxpjs=\n=dOjk\n-----END PGP SIGNATURE-----\n", "payload": "tree 9f1d7a3c7197065bb47d6fb16a5022fcf15634c7\nparent d86a8f3563e32b85d47c494bfdd08e4a39b8df4a\nparent a548d835ce29da1e3df044309c962f45a061f260\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554205644 +0200\ncommitter GitHub <noreply@github.com> 1554205644 +0200\n\nRollup merge of #59444 - cuviper:steps_between, r=scottmcm\n\nImplement useful steps_between for all integers\n\nWe can use `usize::try_from` to convert steps from any size of integer.\nThis enables a meaningful `size_hint()` for larger ranges, rather than\nalways just `(0, None)`. Now they return the true `(len, Some(len))`\nwhen it fits, otherwise `(usize::MAX, None)` for overflow.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8998a98d044b0af48bab4678a921f46dfa7258", "html_url": "https://github.com/rust-lang/rust/commit/5e8998a98d044b0af48bab4678a921f46dfa7258", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e8998a98d044b0af48bab4678a921f46dfa7258/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d86a8f3563e32b85d47c494bfdd08e4a39b8df4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d86a8f3563e32b85d47c494bfdd08e4a39b8df4a", "html_url": "https://github.com/rust-lang/rust/commit/d86a8f3563e32b85d47c494bfdd08e4a39b8df4a"}, {"sha": "a548d835ce29da1e3df044309c962f45a061f260", "url": "https://api.github.com/repos/rust-lang/rust/commits/a548d835ce29da1e3df044309c962f45a061f260", "html_url": "https://github.com/rust-lang/rust/commit/a548d835ce29da1e3df044309c962f45a061f260"}], "stats": {"total": 122, "additions": 71, "deletions": 51}, "files": [{"sha": "aefed1890fef8bd8cd81242a05d1c765e3dee691", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 10, "deletions": 51, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5e8998a98d044b0af48bab4678a921f46dfa7258/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8998a98d044b0af48bab4678a921f46dfa7258/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=5e8998a98d044b0af48bab4678a921f46dfa7258", "patch": "@@ -68,11 +68,9 @@ macro_rules! step_impl_unsigned {\n                    issue = \"42168\")]\n         impl Step for $t {\n             #[inline]\n-            #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n                 if *start < *end {\n-                    // Note: We assume $t <= usize here\n-                    Some((*end - *start) as usize)\n+                    usize::try_from(*end - *start).ok()\n                 } else {\n                     Some(0)\n                 }\n@@ -98,13 +96,11 @@ macro_rules! step_impl_signed {\n                    issue = \"42168\")]\n         impl Step for $t {\n             #[inline]\n-            #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n                 if *start < *end {\n-                    // Note: We assume $t <= isize here\n-                    // Use .wrapping_sub and cast to usize to compute the\n-                    // difference that may not fit inside the range of isize.\n-                    Some((*end as isize).wrapping_sub(*start as isize) as usize)\n+                    // Use .wrapping_sub and cast to unsigned to compute the\n+                    // difference that may not fit inside the range of $t.\n+                    usize::try_from(end.wrapping_sub(*start) as $unsigned).ok()\n                 } else {\n                     Some(0)\n                 }\n@@ -134,46 +130,9 @@ macro_rules! step_impl_signed {\n     )*)\n }\n \n-macro_rules! step_impl_no_between {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"step_trait\",\n-                   reason = \"likely to be replaced by finer-grained traits\",\n-                   issue = \"42168\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn steps_between(_start: &Self, _end: &Self) -> Option<usize> {\n-                None\n-            }\n-\n-            #[inline]\n-            fn add_usize(&self, n: usize) -> Option<Self> {\n-                self.checked_add(n as $t)\n-            }\n-\n-            step_identical_methods!();\n-        }\n-    )*)\n-}\n-\n-step_impl_unsigned!(usize u8 u16);\n-#[cfg(not(target_pointer_width = \"16\"))]\n-step_impl_unsigned!(u32);\n-#[cfg(target_pointer_width = \"16\")]\n-step_impl_no_between!(u32);\n+step_impl_unsigned!(usize u8 u16 u32 u64 u128);\n step_impl_signed!([isize: usize] [i8: u8] [i16: u16]);\n-#[cfg(not(target_pointer_width = \"16\"))]\n-step_impl_signed!([i32: u32]);\n-#[cfg(target_pointer_width = \"16\")]\n-step_impl_no_between!(i32);\n-#[cfg(target_pointer_width = \"64\")]\n-step_impl_unsigned!(u64);\n-#[cfg(target_pointer_width = \"64\")]\n-step_impl_signed!([i64: u64]);\n-// If the target pointer width is not 64-bits, we\n-// assume here that it is less than 64-bits.\n-#[cfg(not(target_pointer_width = \"64\"))]\n-step_impl_no_between!(u64 i64);\n-step_impl_no_between!(u128 i128);\n+step_impl_signed!([i32: u32] [i64: u64] [i128: u128]);\n \n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n@@ -229,7 +188,7 @@ impl<A: Step> Iterator for ops::Range<A> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         match Step::steps_between(&self.start, &self.end) {\n             Some(hint) => (hint, Some(hint)),\n-            None => (0, None)\n+            None => (usize::MAX, None)\n         }\n     }\n \n@@ -273,8 +232,8 @@ range_incl_exact_iter_impl!(u8 u16 i8 i16);\n //\n // They need to guarantee that .size_hint() is either exact, or that\n // the upper bound is None when it does not fit the type limits.\n-range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n-range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n+range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n+range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n@@ -350,7 +309,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n         match Step::steps_between(&self.start, &self.end) {\n             Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n-            None => (0, None),\n+            None => (usize::MAX, None),\n         }\n     }\n "}, {"sha": "d5b581d336d2f6f254a4fd7e10c6d6c418ca18f2", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5e8998a98d044b0af48bab4678a921f46dfa7258/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8998a98d044b0af48bab4678a921f46dfa7258/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=5e8998a98d044b0af48bab4678a921f46dfa7258", "patch": "@@ -1,4 +1,5 @@\n use core::cell::Cell;\n+use core::convert::TryFrom;\n use core::iter::*;\n use core::{i8, i16, isize};\n use core::usize;\n@@ -1800,6 +1801,66 @@ fn test_range_inclusive_folds() {\n     assert!(it.is_empty());\n }\n \n+#[test]\n+fn test_range_size_hint() {\n+    use core::usize::MAX as UMAX;\n+    assert_eq!((0..0usize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..100usize).size_hint(), (100, Some(100)));\n+    assert_eq!((0..UMAX).size_hint(), (UMAX, Some(UMAX)));\n+\n+    let umax = u128::try_from(UMAX).unwrap();\n+    assert_eq!((0..0u128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..100u128).size_hint(), (100, Some(100)));\n+    assert_eq!((0..umax).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((0..umax + 1).size_hint(), (UMAX, None));\n+\n+    use core::isize::{MAX as IMAX, MIN as IMIN};\n+    assert_eq!((0..0isize).size_hint(), (0, Some(0)));\n+    assert_eq!((-100..100isize).size_hint(), (200, Some(200)));\n+    assert_eq!((IMIN..IMAX).size_hint(), (UMAX, Some(UMAX)));\n+\n+    let imin = i128::try_from(IMIN).unwrap();\n+    let imax = i128::try_from(IMAX).unwrap();\n+    assert_eq!((0..0i128).size_hint(), (0, Some(0)));\n+    assert_eq!((-100..100i128).size_hint(), (200, Some(200)));\n+    assert_eq!((imin..imax).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((imin..imax + 1).size_hint(), (UMAX, None));\n+}\n+\n+#[test]\n+fn test_range_inclusive_size_hint() {\n+    use core::usize::MAX as UMAX;\n+    assert_eq!((1..=0usize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0usize).size_hint(), (1, Some(1)));\n+    assert_eq!((0..=100usize).size_hint(), (101, Some(101)));\n+    assert_eq!((0..=UMAX - 1).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((0..=UMAX).size_hint(), (UMAX, None));\n+\n+    let umax = u128::try_from(UMAX).unwrap();\n+    assert_eq!((1..=0u128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0u128).size_hint(), (1, Some(1)));\n+    assert_eq!((0..=100u128).size_hint(), (101, Some(101)));\n+    assert_eq!((0..=umax - 1).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((0..=umax).size_hint(), (UMAX, None));\n+    assert_eq!((0..=umax + 1).size_hint(), (UMAX, None));\n+\n+    use core::isize::{MAX as IMAX, MIN as IMIN};\n+    assert_eq!((0..=-1isize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0isize).size_hint(), (1, Some(1)));\n+    assert_eq!((-100..=100isize).size_hint(), (201, Some(201)));\n+    assert_eq!((IMIN..=IMAX - 1).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((IMIN..=IMAX).size_hint(), (UMAX, None));\n+\n+    let imin = i128::try_from(IMIN).unwrap();\n+    let imax = i128::try_from(IMAX).unwrap();\n+    assert_eq!((0..=-1i128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0i128).size_hint(), (1, Some(1)));\n+    assert_eq!((-100..=100i128).size_hint(), (201, Some(201)));\n+    assert_eq!((imin..=imax - 1).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((imin..=imax).size_hint(), (UMAX, None));\n+    assert_eq!((imin..=imax + 1).size_hint(), (UMAX, None));\n+}\n+\n #[test]\n fn test_repeat() {\n     let mut it = repeat(42);"}]}