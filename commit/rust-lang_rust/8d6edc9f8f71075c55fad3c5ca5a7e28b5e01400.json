{"sha": "8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNmVkYzlmOGY3MTA3NWM1NWZhZDNjNWNhNWE3ZTI4YjVlMDE0MDA=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-09-05T23:19:35Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-07T05:56:51Z"}, "message": "SGX target: implement synchronization primitives and threading", "tree": {"sha": "4341f8c3136f48d7f39731878693d3817d656835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4341f8c3136f48d7f39731878693d3817d656835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "html_url": "https://github.com/rust-lang/rust/commit/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/comments", "author": null, "committer": null, "parents": [{"sha": "1e44e2de6c302855c1da75f79227fca743d9b209", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e44e2de6c302855c1da75f79227fca743d9b209", "html_url": "https://github.com/rust-lang/rust/commit/1e44e2de6c302855c1da75f79227fca743d9b209"}], "stats": {"total": 908, "additions": 832, "deletions": 76}, "files": [{"sha": "c2aaeb98907454c069cfd9a88702e23bd1437a7c", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -26,6 +26,7 @@ const fn done<T>() -> *mut Arc<T> { 1_usize as *mut _ }\n unsafe impl<T> Sync for Lazy<T> {}\n \n impl<T> Lazy<T> {\n+    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Lazy<T> {\n         Lazy {\n             lock: Mutex::new(),"}, {"sha": "069cca3b98e2733951570a0d0e143c8365b4aebf", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -20,7 +20,7 @@ pub(super) mod panic;\n pub mod thread;\n pub mod tls;\n #[macro_use]\n-mod usercalls;\n+pub mod usercalls;\n \n global_asm!(concat!(usercalls_asm!(), include_str!(\"entry.S\")));\n \n@@ -59,14 +59,13 @@ unsafe extern \"C\" fn tcs_init(secondary: bool) {\n // (main function exists). If this is a library, the crate author should be\n // able to specify this\n #[no_mangle]\n-#[allow(unreachable_code)]\n extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> (u64, u64) {\n     // FIXME: how to support TLS in library mode?\n     let tls = Box::new(tls::Tls::new());\n     let _tls_guard = unsafe { tls.activate() };\n \n     if secondary {\n-        unimplemented!(\"thread entrypoint\");\n+        super::thread::Thread::entry();\n \n         (0, 0)\n     } else {"}, {"sha": "cf422e3e6aa1d402bbc220c4021db3b179a6290c", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -16,10 +16,22 @@ mod alloc;\n #[macro_use]\n mod raw;\n \n+pub fn launch_thread() -> IoResult<()> {\n+    unsafe { raw::launch_thread().from_sgx_result() }\n+}\n+\n pub fn exit(panic: bool) -> ! {\n     unsafe { raw::exit(panic) }\n }\n \n+pub fn wait(event_mask: u64, timeout: u64) -> IoResult<u64> {\n+    unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n+}\n+\n+pub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {\n+    unsafe { raw::send(event_set, tcs).from_sgx_result() }\n+}\n+\n pub fn alloc(size: usize, alignment: usize) -> IoResult<*mut u8> {\n     unsafe { raw::alloc(size, alignment).from_sgx_result() }\n }"}, {"sha": "83c20ace89bcef1259b208067bae296196aac974", "filename": "src/libstd/sys/sgx/alloc.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -12,28 +12,31 @@ extern crate dlmalloc;\n \n use alloc::{GlobalAlloc, Layout, System};\n \n-// FIXME: protect this value for concurrent access\n-static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n+use super::waitqueue::SpinMutex;\n+\n+// Using a SpinMutex because we never want to exit the enclave waiting for the\n+// allocator.\n+static DLMALLOC: SpinMutex<dlmalloc::Dlmalloc> = SpinMutex::new(dlmalloc::DLMALLOC_INIT);\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        DLMALLOC.malloc(layout.size(), layout.align())\n+        DLMALLOC.lock().malloc(layout.size(), layout.align())\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        DLMALLOC.calloc(layout.size(), layout.align())\n+        DLMALLOC.lock().calloc(layout.size(), layout.align())\n     }\n \n     #[inline]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-        DLMALLOC.free(ptr, layout.size(), layout.align())\n+        DLMALLOC.lock().free(ptr, layout.size(), layout.align())\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+        DLMALLOC.lock().realloc(ptr, layout.size(), layout.align(), new_size)\n     }\n }"}, {"sha": "d3e8165f3dfe7d818437d810308f2d5d36a6ca1f", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -11,33 +11,42 @@\n use sys::mutex::Mutex;\n use time::Duration;\n \n-pub struct Condvar { }\n+use super::waitqueue::{WaitVariable, WaitQueue, SpinMutex};\n+\n+pub struct Condvar {\n+    inner: SpinMutex<WaitVariable<()>>,\n+}\n \n impl Condvar {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Condvar {\n-        Condvar { }\n+        Condvar { inner: SpinMutex::new(WaitVariable::new(())) }\n     }\n \n     #[inline]\n     pub unsafe fn init(&mut self) {}\n \n     #[inline]\n     pub unsafe fn notify_one(&self) {\n+        let _ = WaitQueue::notify_one(self.inner.lock());\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n+        let _ = WaitQueue::notify_all(self.inner.lock());\n     }\n \n-    pub unsafe fn wait(&self, _mutex: &Mutex) {\n-        panic!(\"can't block with web assembly\")\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        let guard = self.inner.lock();\n+        mutex.unlock();\n+        WaitQueue::wait(guard);\n+        mutex.lock()\n     }\n \n     pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n-        panic!(\"can't block with web assembly\");\n+        panic!(\"timeout not supported in SGX\");\n     }\n \n     #[inline]\n-    pub unsafe fn destroy(&self) {\n-    }\n+    pub unsafe fn destroy(&self) {}\n }"}, {"sha": "68f7479d7cd9f60bb7b5af99520978b133455596", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -18,6 +18,7 @@ use os::raw::c_char;\n use sync::atomic::{AtomicBool, Ordering};\n \n pub mod abi;\n+mod waitqueue;\n \n pub mod alloc;\n pub mod args;"}, {"sha": "663361162bc6bbe7d07ae91ae884c129bf28bd2e", "filename": "src/libstd/sys/sgx/mutex.rs", "status": "modified", "additions": 98, "deletions": 24, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -8,71 +8,145 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cell::UnsafeCell;\n+use fortanix_sgx_abi::Tcs;\n+\n+use super::abi::thread;\n+\n+use super::waitqueue::{WaitVariable, WaitQueue, SpinMutex, NotifiedTcs, try_lock_or_false};\n \n pub struct Mutex {\n-    locked: UnsafeCell<bool>,\n+    inner: SpinMutex<WaitVariable<bool>>,\n }\n \n-unsafe impl Send for Mutex {}\n-unsafe impl Sync for Mutex {} // FIXME\n-\n+// Implementation according to \u201cOperating Systems: Three Easy Pieces\u201d, chapter 28\n impl Mutex {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Mutex {\n-        Mutex { locked: UnsafeCell::new(false) }\n+        Mutex { inner: SpinMutex::new(WaitVariable::new(false)) }\n     }\n \n     #[inline]\n-    pub unsafe fn init(&mut self) {\n-    }\n+    pub unsafe fn init(&mut self) {}\n \n     #[inline]\n     pub unsafe fn lock(&self) {\n-        let locked = self.locked.get();\n-        assert!(!*locked, \"cannot recursively acquire mutex\");\n-        *locked = true;\n+        let mut guard = self.inner.lock();\n+        if *guard.lock_var() {\n+            // Another thread has the lock, wait\n+            WaitQueue::wait(guard)\n+            // Another thread has passed the lock to us\n+        } else {\n+            // We are just now obtaining the lock\n+            *guard.lock_var_mut() = true;\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        *self.locked.get() = false;\n+        let guard = self.inner.lock();\n+        if let Err(mut guard) = WaitQueue::notify_one(guard) {\n+            // No other waiters, unlock\n+            *guard.lock_var_mut() = false;\n+        } else {\n+            // There was a thread waiting, just pass the lock\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        let locked = self.locked.get();\n-        if *locked {\n+        let mut guard = try_lock_or_false!(self.inner);\n+        if *guard.lock_var() {\n+            // Another thread has the lock\n             false\n         } else {\n-            *locked = true;\n+            // We are just now obtaining the lock\n+            *guard.lock_var_mut() = true;\n             true\n         }\n     }\n \n     #[inline]\n-    pub unsafe fn destroy(&self) {\n-    }\n+    pub unsafe fn destroy(&self) {}\n+}\n+\n+struct ReentrantLock {\n+    owner: Option<Tcs>,\n+    count: usize\n }\n \n-// FIXME\n pub struct ReentrantMutex {\n+    inner: SpinMutex<WaitVariable<ReentrantLock>>,\n }\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { }\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex {\n+            inner: SpinMutex::new(WaitVariable::new(ReentrantLock { owner: None, count: 0 }))\n+        }\n     }\n \n+    #[inline]\n     pub unsafe fn init(&mut self) {}\n \n-    pub unsafe fn lock(&self) {}\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let mut guard = self.inner.lock();\n+        match guard.lock_var().owner {\n+            Some(tcs) if tcs != thread::current() => {\n+                // Another thread has the lock, wait\n+                WaitQueue::wait(guard);\n+                // Another thread has passed the lock to us\n+            },\n+            _ => {\n+                // We are just now obtaining the lock\n+                guard.lock_var_mut().owner = Some(thread::current());\n+                guard.lock_var_mut().count += 1;\n+            },\n+        }\n+    }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        true\n+    pub unsafe fn unlock(&self) {\n+        let mut guard = self.inner.lock();\n+        if guard.lock_var().count > 1 {\n+            guard.lock_var_mut().count -= 1;\n+        } else {\n+            match WaitQueue::notify_one(guard) {\n+                Err(mut guard) => {\n+                    // No other waiters, unlock\n+                    guard.lock_var_mut().count = 0;\n+                    guard.lock_var_mut().owner = None;\n+                },\n+                Ok(mut guard) => {\n+                    // There was a thread waiting, just pass the lock\n+                    if let NotifiedTcs::Single(tcs) = guard.notified_tcs() {\n+                        guard.lock_var_mut().owner = Some(tcs)\n+                    } else {\n+                        unreachable!() // called notify_one\n+                    }\n+                }\n+            }\n+        }\n     }\n \n-    pub unsafe fn unlock(&self) {}\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let mut guard = try_lock_or_false!(self.inner);\n+        match guard.lock_var().owner {\n+            Some(tcs) if tcs != thread::current() => {\n+                // Another thread has the lock\n+                false\n+            },\n+            _ => {\n+                // We are just now obtaining the lock\n+                guard.lock_var_mut().owner = Some(thread::current());\n+                guard.lock_var_mut().count += 1;\n+                true\n+            },\n+        }\n+    }\n \n+    #[inline]\n     pub unsafe fn destroy(&self) {}\n }"}, {"sha": "cb25338ed46a216476a91e792b9c463adbc21505", "filename": "src/libstd/sys/sgx/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -92,7 +92,7 @@ pub fn env() -> Env {\n }\n \n pub fn getenv(_k: &OsStr) -> io::Result<Option<OsString>> {\n-    unsupported()\n+    Ok(None)\n }\n \n pub fn setenv(_k: &OsStr, _v: &OsStr) -> io::Result<()> {"}, {"sha": "7b6970b825f93cc71b056e3700acfe886fade64a", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 79, "deletions": 27, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -8,75 +8,127 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cell::UnsafeCell;\n+use num::NonZeroUsize;\n+\n+use super::waitqueue::{WaitVariable, WaitQueue, SpinMutex, NotifiedTcs, try_lock_or_false};\n \n pub struct RWLock {\n-    mode: UnsafeCell<isize>,\n+    readers: SpinMutex<WaitVariable<Option<NonZeroUsize>>>,\n+    writer: SpinMutex<WaitVariable<bool>>,\n }\n \n-unsafe impl Send for RWLock {}\n-unsafe impl Sync for RWLock {} // FIXME\n+//unsafe impl Send for RWLock {}\n+//unsafe impl Sync for RWLock {} // FIXME\n \n impl RWLock {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> RWLock {\n         RWLock {\n-            mode: UnsafeCell::new(0),\n+            readers: SpinMutex::new(WaitVariable::new(None)),\n+            writer: SpinMutex::new(WaitVariable::new(false))\n         }\n     }\n \n     #[inline]\n     pub unsafe fn read(&self) {\n-        let mode = self.mode.get();\n-        if *mode >= 0 {\n-            *mode += 1;\n+        let mut rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        if *wguard.lock_var() || !wguard.queue_empty() {\n+            // Another thread has or is waiting for the write lock, wait\n+            drop(wguard);\n+            WaitQueue::wait(rguard);\n+            // Another thread has passed the lock to us\n         } else {\n-            rtabort!(\"rwlock locked for writing\");\n+            // No waiting writers, acquire the read lock\n+            *rguard.lock_var_mut() =\n+                NonZeroUsize::new(rguard.lock_var().map_or(0, |n| n.get()) + 1);\n         }\n     }\n \n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        let mode = self.mode.get();\n-        if *mode >= 0 {\n-            *mode += 1;\n-            true\n-        } else {\n+        let mut rguard = try_lock_or_false!(self.readers);\n+        let wguard = try_lock_or_false!(self.writer);\n+        if *wguard.lock_var() || !wguard.queue_empty() {\n+            // Another thread has or is waiting for the write lock\n             false\n+        } else {\n+            // No waiting writers, acquire the read lock\n+            *rguard.lock_var_mut() =\n+                NonZeroUsize::new(rguard.lock_var().map_or(0, |n| n.get()) + 1);\n+            true\n         }\n     }\n \n     #[inline]\n     pub unsafe fn write(&self) {\n-        let mode = self.mode.get();\n-        if *mode == 0 {\n-            *mode = -1;\n+        let rguard = self.readers.lock();\n+        let mut wguard = self.writer.lock();\n+        if *wguard.lock_var() || rguard.lock_var().is_some() {\n+            // Another thread has the lock, wait\n+            drop(rguard);\n+            WaitQueue::wait(wguard);\n+            // Another thread has passed the lock to us\n         } else {\n-            rtabort!(\"rwlock locked for reading\")\n+            // We are just now obtaining the lock\n+            *wguard.lock_var_mut() = true;\n         }\n     }\n \n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        let mode = self.mode.get();\n-        if *mode == 0 {\n-            *mode = -1;\n-            true\n-        } else {\n+        let rguard = try_lock_or_false!(self.readers);\n+        let mut wguard = try_lock_or_false!(self.writer);\n+        if *wguard.lock_var() || rguard.lock_var().is_some() {\n+            // Another thread has the lock\n             false\n+        } else {\n+            // We are just now obtaining the lock\n+            *wguard.lock_var_mut() = true;\n+            true\n         }\n     }\n \n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        *self.mode.get() -= 1;\n+        let mut rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        *rguard.lock_var_mut() = NonZeroUsize::new(rguard.lock_var().unwrap().get() - 1);\n+        if rguard.lock_var().is_some() {\n+            // There are other active readers\n+        } else {\n+            if let Ok(mut wguard) = WaitQueue::notify_one(wguard) {\n+                // A writer was waiting, pass the lock\n+                *wguard.lock_var_mut() = true;\n+            } else {\n+                // No writers were waiting, the lock is released\n+                assert!(rguard.queue_empty());\n+            }\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        *self.mode.get() += 1;\n+        let rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        if let Err(mut wguard) = WaitQueue::notify_one(wguard) {\n+            // No writers waiting, release the write lock\n+            *wguard.lock_var_mut() = false;\n+            if let Ok(mut rguard) = WaitQueue::notify_all(rguard) {\n+                // One or more readers were waiting, pass the lock to them\n+                if let NotifiedTcs::All { count } = rguard.notified_tcs() {\n+                    *rguard.lock_var_mut() = Some(count)\n+                } else {\n+                    unreachable!() // called notify_all\n+                }\n+            } else {\n+                // No readers waiting, the lock is released\n+            }\n+        } else {\n+            // There was a thread waiting for write, just pass the lock\n+        }\n     }\n \n     #[inline]\n-    pub unsafe fn destroy(&self) {\n-    }\n+    pub unsafe fn destroy(&self) {}\n }"}, {"sha": "9de12a5e6f154367a005a5c64f52081385efb37b", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -11,35 +11,85 @@\n use boxed::FnBox;\n use ffi::CStr;\n use io;\n-use sys::{unsupported, Void};\n use time::Duration;\n \n-pub struct Thread(Void);\n+use super::abi::usercalls;\n+\n+pub struct Thread(task_queue::JoinHandle);\n \n pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n \n+mod task_queue {\n+    use sync::{Mutex, MutexGuard, Once};\n+    use sync::mpsc;\n+    use boxed::FnBox;\n+\n+    pub type JoinHandle = mpsc::Receiver<()>;\n+\n+    pub(super) struct Task {\n+        p: Box<dyn FnBox()>,\n+        done: mpsc::Sender<()>,\n+    }\n+\n+    impl Task {\n+        pub(super) fn new(p: Box<dyn FnBox()>) -> (Task, JoinHandle) {\n+            let (done, recv) = mpsc::channel();\n+            (Task { p, done }, recv)\n+        }\n+\n+        pub(super) fn run(self) {\n+            (self.p)();\n+            let _ = self.done.send(());\n+        }\n+    }\n+\n+    static TASK_QUEUE_INIT: Once = Once::new();\n+    static mut TASK_QUEUE: Option<Mutex<Vec<Task>>> = None;\n+\n+    pub(super) fn lock() -> MutexGuard<'static, Vec<Task>> {\n+        unsafe {\n+            TASK_QUEUE_INIT.call_once(|| TASK_QUEUE = Some(Default::default()) );\n+            TASK_QUEUE.as_ref().unwrap().lock().unwrap()\n+        }\n+    }\n+}\n+\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(_stack: usize, _p: Box<dyn FnBox()>)\n+    pub unsafe fn new(_stack: usize, p: Box<dyn FnBox()>)\n         -> io::Result<Thread>\n     {\n-        unsupported()\n+        let mut queue_lock = task_queue::lock();\n+        usercalls::launch_thread()?;\n+        let (task, handle) = task_queue::Task::new(p);\n+        queue_lock.push(task);\n+        Ok(Thread(handle))\n+    }\n+\n+    pub(super) fn entry() {\n+        let mut guard = task_queue::lock();\n+        let task = guard.pop().expect(\"Thread started but no tasks pending\");\n+        drop(guard); // make sure to not hold the task queue lock longer than necessary\n+        task.run()\n     }\n \n     pub fn yield_now() {\n-        // do nothing\n+        assert_eq!(\n+            usercalls::wait(0, usercalls::WAIT_NO).unwrap_err().kind(),\n+            io::ErrorKind::WouldBlock\n+        );\n     }\n \n     pub fn set_name(_name: &CStr) {\n-        // nope\n+        // FIXME: could store this pointer in TLS somewhere\n     }\n \n     pub fn sleep(_dur: Duration) {\n-        panic!(\"can't sleep\");\n+        panic!(\"can't sleep\"); // FIXME\n     }\n \n     pub fn join(self) {\n-        match self.0 {}\n+        let _ = self.0.recv();\n     }\n }\n "}, {"sha": "ec1135ba30c4ba1184c7d978ccb15ae7c1e9a0a1", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -0,0 +1,552 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A simple queue implementation for synchronization primitives.\n+///\n+/// This queue is used to implement condition variable and mutexes.\n+///\n+/// Users of this API are expected to use the `WaitVariable<T>` type. Since\n+/// that type is not `Sync`, it needs to be protected by e.g. a `SpinMutex` to\n+/// allow shared access.\n+///\n+/// Since userspace may send spurious wake-ups, the wakeup event state is\n+/// recorded in the enclave. The wakeup event state is protected by a spinlock.\n+/// The queue and associated wait state are stored in a `WaitVariable`.\n+\n+use ops::{Deref, DerefMut};\n+use num::NonZeroUsize;\n+\n+use fortanix_sgx_abi::{Tcs, EV_UNPARK, WAIT_INDEFINITE};\n+use super::abi::usercalls;\n+use super::abi::thread;\n+\n+use self::unsafe_list::{UnsafeList, UnsafeListEntry};\n+pub use self::spin_mutex::{SpinMutex, SpinMutexGuard, try_lock_or_false};\n+\n+/// An queue entry in a `WaitQueue`.\n+struct WaitEntry {\n+    /// TCS address of the thread that is waiting\n+    tcs: Tcs,\n+    /// Whether this thread has been notified to be awoken\n+    wake: bool\n+}\n+\n+/// Data stored with a `WaitQueue` alongside it. This ensures accesses to the\n+/// queue and the data are synchronized, since the type itself is not `Sync`.\n+///\n+/// Consumers of this API should use a synchronization primitive for shared\n+/// access, such as `SpinMutex`.\n+#[derive(Default)]\n+pub struct WaitVariable<T> {\n+    queue: WaitQueue,\n+    lock: T\n+}\n+\n+impl<T> WaitVariable<T> {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn new(var: T) -> Self {\n+        WaitVariable {\n+            queue: WaitQueue::new(),\n+            lock: var\n+        }\n+    }\n+\n+    pub fn queue_empty(&self) -> bool {\n+        self.queue.is_empty()\n+    }\n+\n+    pub fn lock_var(&self) -> &T {\n+        &self.lock\n+    }\n+\n+    pub fn lock_var_mut(&mut self) -> &mut T {\n+        &mut self.lock\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum NotifiedTcs {\n+    Single(Tcs),\n+    All { count: NonZeroUsize }\n+}\n+\n+/// An RAII guard that will notify a set of target threads as well as unlock\n+/// a mutex on drop.\n+pub struct WaitGuard<'a, T: 'a> {\n+    mutex_guard: Option<SpinMutexGuard<'a, WaitVariable<T>>>,\n+    notified_tcs: NotifiedTcs\n+}\n+\n+/// A queue of threads that are waiting on some synchronization primitive.\n+///\n+/// `UnsafeList` entries are allocated on the waiting thread's stack. This\n+/// avoids any global locking that might happen in the heap allocator. This is\n+/// safe because the waiting thread will not return from that stack frame until\n+/// after it is notified. The notifying thread ensures to clean up any\n+/// references to the list entries before sending the wakeup event.\n+pub struct WaitQueue {\n+    // We use an inner Mutex here to protect the data in the face of spurious\n+    // wakeups.\n+    inner: UnsafeList<SpinMutex<WaitEntry>>,\n+}\n+unsafe impl Send for WaitQueue {}\n+\n+impl Default for WaitQueue {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<'a, T> WaitGuard<'a, T> {\n+    /// Returns which TCSes will be notified when this guard drops.\n+    pub fn notified_tcs(&self) -> NotifiedTcs {\n+        self.notified_tcs\n+    }\n+}\n+\n+impl<'a, T> Deref for WaitGuard<'a, T> {\n+    type Target = SpinMutexGuard<'a, WaitVariable<T>>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.mutex_guard.as_ref().unwrap()\n+    }\n+}\n+\n+impl<'a, T> DerefMut for WaitGuard<'a, T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.mutex_guard.as_mut().unwrap()\n+    }\n+}\n+\n+impl<'a, T> Drop for WaitGuard<'a, T> {\n+    fn drop(&mut self) {\n+        drop(self.mutex_guard.take());\n+        let target_tcs = match self.notified_tcs {\n+            NotifiedTcs::Single(tcs) => Some(tcs),\n+            NotifiedTcs::All { .. } => None\n+        };\n+        usercalls::send(EV_UNPARK, target_tcs).unwrap();\n+    }\n+}\n+\n+impl WaitQueue {\n+    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+    pub const fn new() -> Self {\n+        WaitQueue {\n+            inner: UnsafeList::new()\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+\n+    /// Add the calling thread to the WaitVariable's wait queue, then wait\n+    /// until a wakeup event.\n+    ///\n+    /// This function does not return until this thread has been awoken.\n+    pub fn wait<T>(mut guard: SpinMutexGuard<WaitVariable<T>>) {\n+        unsafe {\n+            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n+                tcs: thread::current(),\n+                wake: false\n+            }));\n+            let entry = guard.queue.inner.push(&mut entry);\n+            drop(guard);\n+            while !entry.lock().wake {\n+                assert_eq!(\n+                    usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap() & EV_UNPARK,\n+                    EV_UNPARK\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Either find the next waiter on the wait queue, or return the mutex\n+    /// guard unchanged.\n+    ///\n+    /// If a waiter is found, a `WaitGuard` is returned which will notify the\n+    /// waiter when it is dropped.\n+    pub fn notify_one<T>(mut guard: SpinMutexGuard<WaitVariable<T>>)\n+        -> Result<WaitGuard<T>, SpinMutexGuard<WaitVariable<T>>>\n+    {\n+        unsafe {\n+            if let Some(entry) = guard.queue.inner.pop() {\n+                let mut entry_guard = entry.lock();\n+                let tcs = entry_guard.tcs;\n+                entry_guard.wake = true;\n+                drop(entry);\n+                Ok(WaitGuard {\n+                    mutex_guard: Some(guard),\n+                    notified_tcs: NotifiedTcs::Single(tcs)\n+                })\n+            } else {\n+                Err(guard)\n+            }\n+        }\n+    }\n+\n+    /// Either find any and all waiters on the wait queue, or return the mutex\n+    /// guard unchanged.\n+    ///\n+    /// If at least one waiter is found, a `WaitGuard` is returned which will\n+    /// notify all waiters when it is dropped.\n+    pub fn notify_all<T>(mut guard: SpinMutexGuard<WaitVariable<T>>)\n+        -> Result<WaitGuard<T>, SpinMutexGuard<WaitVariable<T>>>\n+    {\n+        unsafe {\n+            let mut count = 0;\n+            while let Some(entry) = guard.queue.inner.pop() {\n+                count += 1;\n+                let mut entry_guard = entry.lock();\n+                entry_guard.wake = true;\n+            }\n+            if let Some(count) = NonZeroUsize::new(count) {\n+                Ok(WaitGuard {\n+                    mutex_guard: Some(guard),\n+                    notified_tcs: NotifiedTcs::All { count }\n+                })\n+            } else {\n+                Err(guard)\n+            }\n+        }\n+    }\n+}\n+\n+/// A doubly-linked list where callers are in charge of memory allocation\n+/// of the nodes in the list.\n+mod unsafe_list {\n+    use ptr::NonNull;\n+    use mem;\n+\n+    pub struct UnsafeListEntry<T> {\n+        next: NonNull<UnsafeListEntry<T>>,\n+        prev: NonNull<UnsafeListEntry<T>>,\n+        value: Option<T>\n+    }\n+\n+    impl<T> UnsafeListEntry<T> {\n+        fn dummy() -> Self {\n+            UnsafeListEntry {\n+                next: NonNull::dangling(),\n+                prev: NonNull::dangling(),\n+                value: None\n+            }\n+        }\n+\n+        pub fn new(value: T) -> Self {\n+            UnsafeListEntry {\n+                value: Some(value),\n+                ..Self::dummy()\n+            }\n+        }\n+    }\n+\n+    pub struct UnsafeList<T> {\n+        head_tail: NonNull<UnsafeListEntry<T>>,\n+        head_tail_entry: Option<UnsafeListEntry<T>>,\n+    }\n+\n+    impl<T> UnsafeList<T> {\n+        #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n+        pub const fn new() -> Self {\n+            unsafe {\n+                UnsafeList {\n+                    head_tail: NonNull::new_unchecked(1 as _),\n+                    head_tail_entry: None\n+                }\n+            }\n+        }\n+\n+        unsafe fn init(&mut self) {\n+            if self.head_tail_entry.is_none() {\n+                self.head_tail_entry = Some(UnsafeListEntry::dummy());\n+                self.head_tail = NonNull::new_unchecked(self.head_tail_entry.as_mut().unwrap());\n+                self.head_tail.as_mut().next = self.head_tail;\n+                self.head_tail.as_mut().prev = self.head_tail;\n+            }\n+        }\n+\n+        pub fn is_empty(&self) -> bool {\n+            unsafe {\n+                if self.head_tail_entry.is_some() {\n+                    let first = self.head_tail.as_ref().next;\n+                    if first == self.head_tail {\n+                        // ,-------> /---------\\ next ---,\n+                        // |         |head_tail|         |\n+                        // `--- prev \\---------/ <-------`\n+                        assert_eq!(self.head_tail.as_ref().prev, first);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                } else {\n+                    true\n+                }\n+            }\n+        }\n+\n+        /// Pushes an entry onto the back of the list.\n+        ///\n+        /// # Safety\n+        ///\n+        /// The entry must remain allocated until the entry is removed from the\n+        /// list AND the caller who popped is done using the entry.\n+        pub unsafe fn push<'a>(&mut self, entry: &'a mut UnsafeListEntry<T>) -> &'a T {\n+            self.init();\n+\n+            // BEFORE:\n+            //     /---------\\ next ---> /---------\\\n+            // ... |prev_tail|           |head_tail| ...\n+            //     \\---------/ <--- prev \\---------/\n+            //\n+            // AFTER:\n+            //     /---------\\ next ---> /-----\\ next ---> /---------\\\n+            // ... |prev_tail|           |entry|           |head_tail| ...\n+            //     \\---------/ <--- prev \\-----/ <--- prev \\---------/\n+            let mut entry = NonNull::new_unchecked(entry);\n+            let mut prev_tail = mem::replace(&mut self.head_tail.as_mut().prev, entry);\n+            entry.as_mut().prev = prev_tail;\n+            entry.as_mut().next = self.head_tail;\n+            prev_tail.as_mut().next = entry;\n+            (*entry.as_ptr()).value.as_ref().unwrap()\n+        }\n+\n+        /// Pops an entry from the front of the list.\n+        ///\n+        /// # Safety\n+        ///\n+        /// The caller must make sure to synchronize ending the borrow of the\n+        /// return value and deallocation of the containing entry.\n+        pub unsafe fn pop<'a>(&mut self) -> Option<&'a T> {\n+            self.init();\n+\n+            if self.is_empty() {\n+                None\n+            } else {\n+                // BEFORE:\n+                //     /---------\\ next ---> /-----\\ next ---> /------\\\n+                // ... |head_tail|           |first|           |second| ...\n+                //     \\---------/ <--- prev \\-----/ <--- prev \\------/\n+                //\n+                // AFTER:\n+                //     /---------\\ next ---> /------\\\n+                // ... |head_tail|           |second| ...\n+                //     \\---------/ <--- prev \\------/\n+                let mut first = self.head_tail.as_mut().next;\n+                let mut second = first.as_mut().next;\n+                self.head_tail.as_mut().next = second;\n+                second.as_mut().prev = self.head_tail;\n+                first.as_mut().next = NonNull::dangling();\n+                first.as_mut().prev = NonNull::dangling();\n+                Some((*first.as_ptr()).value.as_ref().unwrap())\n+            }\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use super::*;\n+        use cell::Cell;\n+\n+        unsafe fn assert_empty<T>(list: &mut UnsafeList<T>) {\n+            assert!(list.pop().is_none(), \"assertion failed: list is not empty\");\n+        }\n+\n+        #[test]\n+        fn init_empty() {\n+            unsafe {\n+                assert_empty(&mut UnsafeList::<i32>::new());\n+            }\n+        }\n+\n+        #[test]\n+        fn push_pop() {\n+            unsafe {\n+                let mut node = UnsafeListEntry::new(1234);\n+                let mut list = UnsafeList::new();\n+                assert_eq!(list.push(&mut node), &1234);\n+                assert_eq!(list.pop().unwrap(), &1234);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n+        #[test]\n+        fn complex_pushes_pops() {\n+            unsafe {\n+                let mut node1 = UnsafeListEntry::new(1234);\n+                let mut node2 = UnsafeListEntry::new(4567);\n+                let mut node3 = UnsafeListEntry::new(9999);\n+                let mut node4 = UnsafeListEntry::new(8642);\n+                let mut list = UnsafeList::new();\n+                list.push(&mut node1);\n+                list.push(&mut node2);\n+                assert_eq!(list.pop().unwrap(), &1234);\n+                list.push(&mut node3);\n+                assert_eq!(list.pop().unwrap(), &4567);\n+                assert_eq!(list.pop().unwrap(), &9999);\n+                assert_empty(&mut list);\n+                list.push(&mut node4);\n+                assert_eq!(list.pop().unwrap(), &8642);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n+        #[test]\n+        fn cell() {\n+            unsafe {\n+                let mut node = UnsafeListEntry::new(Cell::new(0));\n+                let mut list = UnsafeList::new();\n+                let noderef = list.push(&mut node);\n+                assert_eq!(noderef.get(), 0);\n+                list.pop().unwrap().set(1);\n+                assert_empty(&mut list);\n+                assert_eq!(noderef.get(), 1);\n+            }\n+        }\n+    }\n+}\n+\n+/// Trivial spinlock-based implementation of `sync::Mutex`.\n+// FIXME: Perhaps use Intel TSX to avoid locking?\n+mod spin_mutex {\n+    use cell::UnsafeCell;\n+    use sync::atomic::{AtomicBool, Ordering, spin_loop_hint};\n+    use ops::{Deref, DerefMut};\n+\n+    #[derive(Default)]\n+    pub struct SpinMutex<T> {\n+        value: UnsafeCell<T>,\n+        lock: AtomicBool,\n+    }\n+\n+    unsafe impl<T: Send> Send for SpinMutex<T> {}\n+    unsafe impl<T: Send> Sync for SpinMutex<T> {}\n+\n+    pub struct SpinMutexGuard<'a, T: 'a> {\n+        mutex: &'a SpinMutex<T>,\n+    }\n+\n+    impl<'a, T> !Send for SpinMutexGuard<'a, T> {}\n+    unsafe impl<'a, T: Sync> Sync for SpinMutexGuard<'a, T> {}\n+\n+    impl<T> SpinMutex<T> {\n+        pub const fn new(value: T) -> Self {\n+            SpinMutex {\n+                value: UnsafeCell::new(value),\n+                lock: AtomicBool::new(false)\n+            }\n+        }\n+\n+        #[inline(always)]\n+        pub fn lock(&self) -> SpinMutexGuard<T> {\n+            loop {\n+                match self.try_lock() {\n+                    None => while self.lock.load(Ordering::Relaxed) {\n+                        spin_loop_hint()\n+                    },\n+                    Some(guard) => return guard\n+                }\n+            }\n+        }\n+\n+        #[inline(always)]\n+        pub fn try_lock(&self) -> Option<SpinMutexGuard<T>> {\n+            if !self.lock.compare_and_swap(false, true, Ordering::Acquire) {\n+                Some(SpinMutexGuard {\n+                    mutex: self,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    pub macro try_lock_or_false {\n+        ($e:expr) => {\n+            if let Some(v) = $e.try_lock() {\n+                v\n+            } else {\n+                return false\n+            }\n+        }\n+    }\n+\n+    impl<'a, T> Deref for SpinMutexGuard<'a, T> {\n+        type Target = T;\n+\n+        fn deref(&self) -> &T {\n+            unsafe {\n+                &*self.mutex.value.get()\n+            }\n+        }\n+    }\n+\n+    impl<'a, T> DerefMut for SpinMutexGuard<'a, T> {\n+        fn deref_mut(&mut self) -> &mut T {\n+            unsafe {\n+                &mut*self.mutex.value.get()\n+            }\n+        }\n+    }\n+\n+    impl<'a, T> Drop for SpinMutexGuard<'a, T> {\n+        fn drop(&mut self) {\n+            self.mutex.lock.store(false, Ordering::Release)\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        #![allow(deprecated)]\n+\n+        use super::*;\n+        use sync::Arc;\n+        use thread;\n+\n+        #[test]\n+        fn sleep() {\n+            let mutex = Arc::new(SpinMutex::<i32>::default());\n+            let mutex2 = mutex.clone();\n+            let guard = mutex.lock();\n+            let t1 = thread::spawn(move || {\n+                *mutex2.lock() = 1;\n+            });\n+            thread::sleep_ms(50);\n+            assert_eq!(*guard, 0);\n+            drop(guard);\n+            t1.join().unwrap();\n+            assert_eq!(*mutex.lock(), 1);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use sync::Arc;\n+    use thread;\n+\n+    #[test]\n+    fn queue() {\n+        let wq = Arc::new(SpinMutex::<WaitVariable<()>>::default());\n+        let wq2 = wq.clone();\n+\n+        let locked = wq.lock();\n+\n+        let t1 = thread::spawn(move || {\n+            assert!(WaitQueue::notify_one(wq2.lock()).is_none())\n+        });\n+\n+        WaitQueue::wait(locked);\n+\n+        t1.join().unwrap();\n+    }\n+}"}, {"sha": "16bf0803a8dfee293a0c6e20b45ffb87d908aa90", "filename": "src/libstd/sys_common/condvar.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fcondvar.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -25,6 +25,7 @@ impl Condvar {\n     ///\n     /// Behavior is undefined if the condition variable is moved after it is\n     /// first used with any of the functions below.\n+    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n \n     /// Prepares the condition variable for use."}, {"sha": "87684237638987c805f1c3f7e7baf678a319376c", "filename": "src/libstd/sys_common/mutex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -27,6 +27,7 @@ impl Mutex {\n     /// Also, until `init` is called, behavior is undefined if this\n     /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n     /// are called by the thread currently holding the lock.\n+    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n     /// Prepare the mutex for use."}, {"sha": "a430c254d3c585f608b61fa360562f2a3c7cd74d", "filename": "src/libstd/sys_common/rwlock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400/src%2Flibstd%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Frwlock.rs?ref=8d6edc9f8f71075c55fad3c5ca5a7e28b5e01400", "patch": "@@ -22,6 +22,7 @@ impl RWLock {\n     ///\n     /// Behavior is undefined if the reader-writer lock is moved after it is\n     /// first used with any of the functions below.\n+    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n \n     /// Acquires shared access to the underlying lock, blocking the current"}]}