{"sha": "548067e00f64861915d2374082adc7796c73ceb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ODA2N2UwMGY2NDg2MTkxNWQyMzc0MDgyYWRjNzc5NmM3M2NlYjg=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-09T02:55:13Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-13T07:16:03Z"}, "message": "Remove `StringReader::terminator`.\n\nIt's silly for a hot function like `bump()` to have such an expensive\nbounds check. This patch replaces terminator with `end_src_index`.\n\nNote that the `self.terminator` check in `is_eof()` wasn't necessary\nbecause of the way `StringReader` is initialized.", "tree": {"sha": "5a602342e1e7b293b5749cb2a716e2c2e3d396ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a602342e1e7b293b5749cb2a716e2c2e3d396ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/548067e00f64861915d2374082adc7796c73ceb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/548067e00f64861915d2374082adc7796c73ceb8", "html_url": "https://github.com/rust-lang/rust/commit/548067e00f64861915d2374082adc7796c73ceb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/548067e00f64861915d2374082adc7796c73ceb8/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a090fbe02b6b20f0dce8acf07a0328375f91d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a090fbe02b6b20f0dce8acf07a0328375f91d68", "html_url": "https://github.com/rust-lang/rust/commit/7a090fbe02b6b20f0dce8acf07a0328375f91d68"}], "stats": {"total": 31, "additions": 11, "deletions": 20}, "files": [{"sha": "f80eaf0a9b446f7ec8b85ab8f8c7c604a38d41c0", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/548067e00f64861915d2374082adc7796c73ceb8/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548067e00f64861915d2374082adc7796c73ceb8/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=548067e00f64861915d2374082adc7796c73ceb8", "patch": "@@ -49,8 +49,8 @@ pub struct StringReader<'a> {\n     /// The current character (which has been read from self.pos)\n     pub ch: Option<char>,\n     pub filemap: Lrc<syntax_pos::FileMap>,\n-    /// If Some, stop reading the source at this position (inclusive).\n-    pub terminator: Option<BytePos>,\n+    /// Stop reading src at this index.\n+    pub end_src_index: usize,\n     /// Whether to record new-lines and multibyte chars in filemap.\n     /// This is only necessary the first time a filemap is lexed.\n     /// If part of a filemap is being re-lexed, this should be set to false.\n@@ -113,14 +113,7 @@ impl<'a> StringReader<'a> {\n         self.unwrap_or_abort(res)\n     }\n     fn is_eof(&self) -> bool {\n-        if self.ch.is_none() {\n-            return true;\n-        }\n-\n-        match self.terminator {\n-            Some(t) => self.next_pos > t,\n-            None => false,\n-        }\n+        self.ch.is_none()\n     }\n     /// Return the next token. EFFECT: advances the string_reader.\n     pub fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n@@ -185,7 +178,7 @@ impl<'a> StringReader<'a> {\n             col: CharPos(0),\n             ch: Some('\\n'),\n             filemap,\n-            terminator: None,\n+            end_src_index: src.len(),\n             save_new_lines_and_multibyte: true,\n             // dummy values; not read\n             peek_tok: token::Eof,\n@@ -222,7 +215,7 @@ impl<'a> StringReader<'a> {\n         // Seek the lexer to the right byte range.\n         sr.save_new_lines_and_multibyte = false;\n         sr.next_pos = span.lo();\n-        sr.terminator = Some(span.hi());\n+        sr.end_src_index = sr.src_index(span.hi());\n \n         sr.bump();\n \n@@ -441,8 +434,7 @@ impl<'a> StringReader<'a> {\n     /// discovered, add it to the FileMap's list of line start offsets.\n     pub fn bump(&mut self) {\n         let next_src_index = self.src_index(self.next_pos);\n-        let end_src_index = self.terminator.map_or(self.src.len(), |t| self.src_index(t));\n-        if next_src_index < end_src_index {\n+        if next_src_index < self.end_src_index {\n             let next_ch = char_at(&self.src, next_src_index);\n             let next_ch_len = next_ch.len_utf8();\n \n@@ -472,7 +464,7 @@ impl<'a> StringReader<'a> {\n \n     pub fn nextch(&self) -> Option<char> {\n         let next_src_index = self.src_index(self.next_pos);\n-        if next_src_index < self.src.len() {\n+        if next_src_index < self.end_src_index {\n             Some(char_at(&self.src, next_src_index))\n         } else {\n             None\n@@ -485,13 +477,12 @@ impl<'a> StringReader<'a> {\n \n     pub fn nextnextch(&self) -> Option<char> {\n         let next_src_index = self.src_index(self.next_pos);\n-        let s = &self.src[..];\n-        if next_src_index >= s.len() {\n+        if next_src_index >= self.end_src_index {\n             return None;\n         }\n-        let next_next_src_index = next_src_index + char_at(s, next_src_index).len_utf8();\n-        if next_next_src_index < s.len() {\n-            Some(char_at(s, next_next_src_index))\n+        let next_next_src_index = next_src_index + char_at(&self.src, next_src_index).len_utf8();\n+        if next_next_src_index < self.end_src_index {\n+            Some(char_at(&self.src, next_next_src_index))\n         } else {\n             None\n         }"}]}