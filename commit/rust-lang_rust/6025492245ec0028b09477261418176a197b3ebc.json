{"sha": "6025492245ec0028b09477261418176a197b3ebc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMjU0OTIyNDVlYzAwMjhiMDk0NzcyNjE0MTgxNzZhMTk3YjNlYmM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-09T01:21:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-09T01:21:20Z"}, "message": "Implement where_style Rfc", "tree": {"sha": "5aea68b0054a681226f2b15a036f6a1de89d3784", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aea68b0054a681226f2b15a036f6a1de89d3784"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6025492245ec0028b09477261418176a197b3ebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6025492245ec0028b09477261418176a197b3ebc", "html_url": "https://github.com/rust-lang/rust/commit/6025492245ec0028b09477261418176a197b3ebc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6025492245ec0028b09477261418176a197b3ebc/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b820d50ec06487eb5490b4a0048fdae76de11db8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b820d50ec06487eb5490b4a0048fdae76de11db8", "html_url": "https://github.com/rust-lang/rust/commit/b820d50ec06487eb5490b4a0048fdae76de11db8"}], "stats": {"total": 242, "additions": 232, "deletions": 10}, "files": [{"sha": "ea8ac6687a60d6822b9baa97c07ddb782c5ea3fd", "filename": "src/items.rs", "status": "modified", "additions": 89, "deletions": 10, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6025492245ec0028b09477261418176a197b3ebc/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6025492245ec0028b09477261418176a197b3ebc/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=6025492245ec0028b09477261418176a197b3ebc", "patch": "@@ -20,7 +20,7 @@ use expr::{is_empty_block, is_simple_block_stmt, rewrite_assign_rhs, type_annota\n use comment::{FindUncommented, contains_comment};\n use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n-use config::{Config, BlockIndentStyle, Density, ReturnIndent, BraceStyle, FnArgLayoutStyle};\n+use config::{Config, BlockIndentStyle, Density, ReturnIndent, BraceStyle, FnArgLayoutStyle, Style};\n use itertools::Itertools;\n \n use syntax::{ast, abi, codemap, ptr, symbol};\n@@ -520,13 +520,13 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n         let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n-                                                             context.config,\n                                                              context.config.item_brace_style,\n                                                              Shape::legacy(where_budget,\n                                                                            offset.block_only()),\n                                                              context.config.where_density,\n                                                              \"{\",\n                                                              false,\n+                                                             false,\n                                                              None));\n \n         if try_opt!(is_impl_single_line(context, &items, &result, &where_clause_str, &item)) {\n@@ -787,13 +787,13 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n-                                                             context.config,\n                                                              context.config.item_brace_style,\n                                                              Shape::legacy(where_budget,\n                                                                            offset.block_only()),\n                                                              where_density,\n                                                              \"{\",\n                                                              !has_body,\n+                                                             false,\n                                                              None));\n         // If the where clause cannot fit on the same line,\n         // put the where clause on a new line\n@@ -1002,12 +1002,12 @@ fn format_tuple_struct(context: &RewriteContext,\n                 try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,\n-                                          context.config,\n                                           context.config.item_brace_style,\n                                           Shape::legacy(where_budget, offset.block_only()),\n                                           Density::Compressed,\n                                           \";\",\n                                           true,\n+                                          false,\n                                           None))\n         }\n         None => \"\".to_owned(),\n@@ -1093,12 +1093,12 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          &generics.where_clause,\n-                                                         context.config,\n                                                          context.config.item_brace_style,\n                                                          Shape::legacy(where_budget, indent),\n                                                          context.config.where_density,\n                                                          \"=\",\n                                                          true,\n+                                                         false,\n                                                          Some(span.hi)));\n     result.push_str(&where_clause_str);\n     result.push_str(\" = \");\n@@ -1645,12 +1645,12 @@ fn rewrite_fn_base(context: &RewriteContext,\n     let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          where_clause,\n-                                                         context.config,\n                                                          context.config.fn_brace_style,\n                                                          Shape::legacy(where_budget, indent),\n                                                          where_density,\n                                                          \"{\",\n                                                          !has_body,\n+                                                         put_args_in_block && ret_str.is_empty(),\n                                                          Some(span.hi)));\n \n     if last_line_width(&result) + where_clause_str.len() > context.config.max_width &&\n@@ -1935,28 +1935,107 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     Some(result)\n }\n \n+//   fn reflow_list_node_with_rule(\n+//        &self,\n+//        node: &CompoundNode,\n+//        rule: &Rule,\n+//        args: &[Arg],\n+//        shape: &Shape\n+//    ) -> Result<String, ()>\n+//    where\n+//        T: Foo,\n+//    {\n+\n+\n+fn rewrite_where_clause_rfc_style(context: &RewriteContext,\n+                                  where_clause: &ast::WhereClause,\n+                                  shape: Shape,\n+                                  terminator: &str,\n+                                  suppress_comma: bool,\n+                                  // where clause can be kept on the current line.\n+                                  snuggle: bool,\n+                                  span_end: Option<BytePos>)\n+                                  -> Option<String> {\n+    let block_shape = shape.block();\n+\n+    let starting_newline = if snuggle {\n+        \" \".to_owned()\n+    } else {\n+        \"\\n\".to_owned() + &block_shape.indent.to_string(context.config)\n+    };\n+\n+    let clause_shape = block_shape.block_indent(context.config.tab_spaces);\n+    // each clause on one line, trailing comma (except if suppress_comma)\n+    let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n+    // If we don't have the start of the next span, then use the end of the\n+    // predicates, but that means we miss comments.\n+    let len = where_clause.predicates.len();\n+    let end_of_preds = span_for_where_pred(&where_clause.predicates[len - 1]).hi;\n+    let span_end = span_end.unwrap_or(end_of_preds);\n+    let items = itemize_list(context.codemap,\n+                             where_clause.predicates.iter(),\n+                             terminator,\n+                             |pred| span_for_where_pred(pred).lo,\n+                             |pred| span_for_where_pred(pred).hi,\n+                             |pred| pred.rewrite(context, clause_shape),\n+                             span_start,\n+                             span_end);\n+    let comma_tactic = if suppress_comma {\n+        SeparatorTactic::Never\n+    } else {\n+        SeparatorTactic::Always\n+    };\n+\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        separator: \",\",\n+        trailing_separator: comma_tactic,\n+        shape: clause_shape,\n+        ends_with_newline: true,\n+        config: context.config,\n+    };\n+    let preds_str = try_opt!(write_list(items, &fmt));\n+\n+    Some(format!(\"{}where\\n{}{}\",\n+                 starting_newline,\n+                 clause_shape.indent.to_string(context.config),\n+                 preds_str))\n+}\n+\n fn rewrite_where_clause(context: &RewriteContext,\n                         where_clause: &ast::WhereClause,\n-                        config: &Config,\n                         brace_style: BraceStyle,\n                         shape: Shape,\n                         density: Density,\n                         terminator: &str,\n                         suppress_comma: bool,\n+                        snuggle: bool,\n                         span_end: Option<BytePos>)\n                         -> Option<String> {\n     if where_clause.predicates.is_empty() {\n         return Some(String::new());\n     }\n \n+    if context.config.where_style == Style::Rfc {\n+        return rewrite_where_clause_rfc_style(context,\n+                                              where_clause,\n+                                              shape,\n+                                              terminator,\n+                                              suppress_comma,\n+                                              snuggle,\n+                                              span_end);\n+    }\n+\n     let extra_indent = match context.config.where_indent {\n         BlockIndentStyle::Inherit => Indent::empty(),\n-        BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => Indent::new(config.tab_spaces, 0),\n+        BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => {\n+            Indent::new(context.config.tab_spaces, 0)\n+        }\n     };\n \n     let offset = match context.config.where_pred_indent {\n         BlockIndentStyle::Inherit => shape.indent + extra_indent,\n-        BlockIndentStyle::Tabbed => shape.indent + extra_indent.block_indent(config),\n+        BlockIndentStyle::Tabbed => shape.indent + extra_indent.block_indent(context.config),\n         // 6 = \"where \".len()\n         BlockIndentStyle::Visual => shape.indent + extra_indent + 6,\n     };\n@@ -2046,13 +2125,13 @@ fn format_generics(context: &RewriteContext,\n         let budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n-                                                             context.config,\n                                                              brace_style,\n                                                              Shape::legacy(budget,\n                                                                            offset.block_only()),\n                                                              Density::Tall,\n                                                              terminator,\n                                                              false,\n+                                                             false,\n                                                              Some(span.hi)));\n         result.push_str(&where_clause_str);\n         if !force_same_line_brace &&"}, {"sha": "d8a014c4a910ddde809923c68e84defe0353ad7d", "filename": "tests/source/where-clause-rfc.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6025492245ec0028b09477261418176a197b3ebc/tests%2Fsource%2Fwhere-clause-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6025492245ec0028b09477261418176a197b3ebc/tests%2Fsource%2Fwhere-clause-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fwhere-clause-rfc.rs?ref=6025492245ec0028b09477261418176a197b3ebc", "patch": "@@ -0,0 +1,44 @@\n+// rustfmt-fn_args_layout: Block\n+// rustfmt-where_style: Rfc\n+\n+fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape) where T: FOo, U: Bar {\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape) where T: FOo {\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape, shape: &Shape) where T: FOo, U: Bar {\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape, shape: &Shape) where T: FOo {\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape) -> Option<String> where T: FOo, U: Bar {\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape) -> Option<String> where T: FOo {\n+    let mut effects = HashMap::new();\n+}\n+\n+pub trait Test {\n+    fn very_long_method_name<F>(self, f: F) -> MyVeryLongReturnType where F: FnMut(Self::Item) -> bool;\n+\n+    fn exactly_100_chars1<F>(self, f: F) -> MyVeryLongReturnType where F: FnMut(Self::Item) -> bool;\n+}\n+\n+fn very_long_function_name<F>(very_long_argument: F) -> MyVeryLongReturnType where F: FnMut(Self::Item) -> bool { }\n+\n+struct VeryLongTupleStructName<A, B, C, D, E>(LongLongTypename, LongLongTypename, i32, i32) where A: LongTrait;\n+\n+struct Exactly100CharsToSemicolon<A, B, C, D, E>\n+    (LongLongTypename, i32, i32)\n+    where A: LongTrait1234;\n+\n+struct AlwaysOnNextLine<LongLongTypename, LongTypename, A, B, C, D, E, F> where A: LongTrait {\n+    x: i32\n+}"}, {"sha": "fd912e794ccbc21165d7a5f9b15871a0d2890a36", "filename": "tests/target/where-clause-rfc.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6025492245ec0028b09477261418176a197b3ebc/tests%2Ftarget%2Fwhere-clause-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6025492245ec0028b09477261418176a197b3ebc/tests%2Ftarget%2Fwhere-clause-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fwhere-clause-rfc.rs?ref=6025492245ec0028b09477261418176a197b3ebc", "patch": "@@ -0,0 +1,99 @@\n+// rustfmt-fn_args_layout: Block\n+// rustfmt-where_style: Rfc\n+\n+fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape)\n+where\n+    T: FOo,\n+    U: Bar,\n+{\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape)\n+where\n+    T: FOo,\n+{\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(\n+    node: &CompoundNode,\n+    rule: &Rule,\n+    args: &[Arg],\n+    shape: &Shape,\n+    shape: &Shape\n+) where\n+    T: FOo,\n+    U: Bar,\n+{\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(\n+    node: &CompoundNode,\n+    rule: &Rule,\n+    args: &[Arg],\n+    shape: &Shape,\n+    shape: &Shape\n+) where\n+    T: FOo,\n+{\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(\n+    node: &CompoundNode,\n+    rule: &Rule,\n+    args: &[Arg],\n+    shape: &Shape\n+) -> Option<String>\n+where\n+    T: FOo,\n+    U: Bar,\n+{\n+    let mut effects = HashMap::new();\n+}\n+\n+fn reflow_list_node_with_rule(\n+    node: &CompoundNode,\n+    rule: &Rule,\n+    args: &[Arg],\n+    shape: &Shape\n+) -> Option<String>\n+where\n+    T: FOo,\n+{\n+    let mut effects = HashMap::new();\n+}\n+\n+pub trait Test {\n+    fn very_long_method_name<F>(self, f: F) -> MyVeryLongReturnType\n+    where\n+        F: FnMut(Self::Item) -> bool;\n+\n+    fn exactly_100_chars1<F>(self, f: F) -> MyVeryLongReturnType\n+    where\n+        F: FnMut(Self::Item) -> bool;\n+}\n+\n+fn very_long_function_name<F>(very_long_argument: F) -> MyVeryLongReturnType\n+where\n+    F: FnMut(Self::Item)\n+             -> bool\n+{\n+}\n+\n+struct VeryLongTupleStructName<A, B, C, D, E>(LongLongTypename, LongLongTypename, i32, i32)\n+where\n+    A: LongTrait;\n+\n+struct Exactly100CharsToSemicolon<A, B, C, D, E>(LongLongTypename, i32, i32)\n+where\n+    A: LongTrait1234;\n+\n+struct AlwaysOnNextLine<LongLongTypename, LongTypename, A, B, C, D, E, F>\n+where\n+    A: LongTrait,\n+{\n+    x: i32,\n+}"}]}