{"sha": "b4af87406b2e8da7e6437115bbdde59a71f3a4e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YWY4NzQwNmIyZThkYTdlNjQzNzExNWJiZGRlNTlhNzFmM2E0ZTc=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-11T11:16:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-11T11:16:00Z"}, "message": "Rollup merge of #73155 - marmeladema:save-analysis-various-fixes, r=Xanewok\n\nsave_analysis: better handle paths and functions signature\n\nThis should improve slightly some possible regressions due to hir rework.\n\nr? @Xanewok", "tree": {"sha": "68059431a1b252f9acb07d4572af510a025036dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68059431a1b252f9acb07d4572af510a025036dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4af87406b2e8da7e6437115bbdde59a71f3a4e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe4hJxCRBK7hj4Ov3rIwAAdHIIAKzBHzVGmVY79Q6Od5NSJBvu\ncMXxm9uaASfYSHpb3oRFxaS8HBdjx0jXN78WmdabY96KIAH+BmG/OiuhpYOb5fed\n3AS6q79l/hbiwtr9et4N76XXKOoI+mlWrRbDcd1ejKr+a4Jjzx3JBCfxWC858vZA\nfCSVP16ta9CfVephjxMbACWsVSFtG72tszQIKHW8GZLP+fUvoHMCzbioHCU4bcZB\nLm6nJSPG9k5Bx7Ih34fsnHVJNzvmOr1O+i6UolVz8sOkaLKJmvYS0xz0hU7hga5D\nEYVPDC+w3k5S9KcCGf8FXI1nfOGBM0oJyyDF9gYY23jaAxK3iBkbw499gG0s9wQ=\n=jchI\n-----END PGP SIGNATURE-----\n", "payload": "tree 68059431a1b252f9acb07d4572af510a025036dd\nparent 12e5a69fee94501f2ae33583b6600394401d23f1\nparent 5bfa7f0ff4804c688d271eb79ba2f7c993dd7a1e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1591874160 +0200\ncommitter GitHub <noreply@github.com> 1591874160 +0200\n\nRollup merge of #73155 - marmeladema:save-analysis-various-fixes, r=Xanewok\n\nsave_analysis: better handle paths and functions signature\n\nThis should improve slightly some possible regressions due to hir rework.\n\nr? @Xanewok\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4af87406b2e8da7e6437115bbdde59a71f3a4e7", "html_url": "https://github.com/rust-lang/rust/commit/b4af87406b2e8da7e6437115bbdde59a71f3a4e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e5a69fee94501f2ae33583b6600394401d23f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e5a69fee94501f2ae33583b6600394401d23f1", "html_url": "https://github.com/rust-lang/rust/commit/12e5a69fee94501f2ae33583b6600394401d23f1"}, {"sha": "5bfa7f0ff4804c688d271eb79ba2f7c993dd7a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bfa7f0ff4804c688d271eb79ba2f7c993dd7a1e", "html_url": "https://github.com/rust-lang/rust/commit/5bfa7f0ff4804c688d271eb79ba2f7c993dd7a1e"}], "stats": {"total": 219, "additions": 142, "deletions": 77}, "files": [{"sha": "da8956ccb4da483d08091253a6c9b222754b3f79", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=b4af87406b2e8da7e6437115bbdde59a71f3a4e7", "patch": "@@ -227,6 +227,28 @@ pub fn path_to_string(segment: &hir::Path<'_>) -> String {\n     to_string(NO_ANN, |s| s.print_path(segment, false))\n }\n \n+pub fn fn_to_string(\n+    decl: &hir::FnDecl<'_>,\n+    header: hir::FnHeader,\n+    name: Option<Symbol>,\n+    generics: &hir::Generics<'_>,\n+    vis: &hir::Visibility<'_>,\n+    arg_names: &[Ident],\n+    body_id: Option<hir::BodyId>,\n+) -> String {\n+    to_string(NO_ANN, |s| s.print_fn(decl, header, name, generics, vis, arg_names, body_id))\n+}\n+\n+pub fn enum_def_to_string(\n+    enum_definition: &hir::EnumDef<'_>,\n+    generics: &hir::Generics<'_>,\n+    name: Symbol,\n+    span: rustc_span::Span,\n+    visibility: &hir::Visibility<'_>,\n+) -> String {\n+    to_string(NO_ANN, |s| s.print_enum_def(enum_definition, generics, name, span, visibility))\n+}\n+\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) {\n         self.s.cbox(u);"}, {"sha": "fbde6bfd9aae61f7df61ef26c268ec76e7fd56c4", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 54, "deletions": 25, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b4af87406b2e8da7e6437115bbdde59a71f3a4e7", "patch": "@@ -20,7 +20,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir_pretty::{bounds_to_string, generic_params_to_string, ty_to_string};\n+use rustc_hir_pretty::{bounds_to_string, fn_to_string, generic_params_to_string, ty_to_string};\n use rustc_middle::hir::map::Map;\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n@@ -199,23 +199,23 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.dumper.compilation_opts(data);\n     }\n \n-    fn write_sub_paths(&mut self, path: &'tcx hir::Path<'tcx>) {\n-        for seg in path.segments {\n+    fn write_segments(&mut self, segments: impl IntoIterator<Item = &'tcx hir::PathSegment<'tcx>>) {\n+        for seg in segments {\n             if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n                 self.dumper.dump_ref(data);\n             }\n         }\n     }\n \n+    fn write_sub_paths(&mut self, path: &'tcx hir::Path<'tcx>) {\n+        self.write_segments(path.segments)\n+    }\n+\n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n     fn write_sub_paths_truncated(&mut self, path: &'tcx hir::Path<'tcx>) {\n         if let [segments @ .., _] = path.segments {\n-            for seg in segments {\n-                if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n-                    self.dumper.dump_ref(data);\n-                }\n-            }\n+            self.write_segments(segments)\n         }\n     }\n \n@@ -276,7 +276,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 }\n                 v.process_generic_params(&generics, &method_data.qualname, hir_id);\n \n-                method_data.value = crate::make_signature(&sig.decl, &generics);\n+                method_data.value =\n+                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, vis, &[], None);\n                 method_data.sig = sig::method_signature(hir_id, ident, generics, sig, &v.save_ctxt);\n \n                 v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, hir_id), method_data);\n@@ -643,7 +644,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.nest_tables(map.local_def_id(item.hir_id), |v| {\n             v.visit_ty(&typ);\n             if let &Some(ref trait_ref) = trait_ref {\n-                v.process_path(trait_ref.hir_ref_id, &trait_ref.path);\n+                v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n             }\n             v.process_generic_params(generics, \"\", item.hir_id);\n             for impl_item in impl_items {\n@@ -746,7 +747,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::Path<'tcx>) {\n+    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n         let path_data = self.save_ctxt.get_path_data(id, path);\n         if let Some(path_data) = path_data {\n             self.dumper.dump_ref(path_data);\n@@ -760,14 +761,30 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_path(&mut self, id: hir::HirId, path: &'tcx hir::Path<'tcx>) {\n-        if self.span.filter_generated(path.span) {\n+    fn process_path(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n+        let span = match path {\n+            hir::QPath::Resolved(_, path) => path.span,\n+            hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n+        };\n+        if self.span.filter_generated(span) {\n             return;\n         }\n         self.dump_path_ref(id, path);\n \n         // Type arguments\n-        for seg in path.segments {\n+        let segments = match path {\n+            hir::QPath::Resolved(ty, path) => {\n+                if let Some(ty) = ty {\n+                    self.visit_ty(ty);\n+                }\n+                path.segments\n+            }\n+            hir::QPath::TypeRelative(ty, segment) => {\n+                self.visit_ty(ty);\n+                std::slice::from_ref(*segment)\n+            }\n+        };\n+        for seg in segments {\n             if let Some(ref generic_args) = seg.args {\n                 for arg in generic_args.args {\n                     if let hir::GenericArg::Type(ref ty) = arg {\n@@ -777,7 +794,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             }\n         }\n \n-        self.write_sub_paths_truncated(path);\n+        if let hir::QPath::Resolved(_, path) = path {\n+            self.write_sub_paths_truncated(path);\n+        }\n     }\n \n     fn process_struct_lit(\n@@ -931,9 +950,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         for (id, ref path) in collector.collected_paths {\n-            if let hir::QPath::Resolved(_, path) = path {\n-                self.process_path(id, path);\n-            }\n+            self.process_path(id, path);\n         }\n     }\n \n@@ -1135,7 +1152,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_bounds(&mut self, bounds: hir::GenericBounds<'tcx>) {\n         for bound in bounds {\n             if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n-                self.process_path(trait_ref.trait_ref.hir_ref_id, &trait_ref.trait_ref.path)\n+                self.process_path(\n+                    trait_ref.trait_ref.hir_ref_id,\n+                    &hir::QPath::Resolved(None, &trait_ref.trait_ref.path),\n+                )\n             }\n         }\n     }\n@@ -1330,13 +1350,16 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         self.process_macro_use(t.span);\n         match t.kind {\n-            hir::TyKind::Path(hir::QPath::Resolved(_, path)) => {\n+            hir::TyKind::Path(ref path) => {\n                 if generated_code(t.span) {\n                     return;\n                 }\n \n                 if let Some(id) = self.lookup_def_id(t.hir_id) {\n-                    let sub_span = path.segments.last().unwrap().ident.span;\n+                    let sub_span = match path {\n+                        hir::QPath::Resolved(_, path) => path.segments.last().unwrap().ident.span,\n+                        hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n+                    };\n                     let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {\n                         kind: RefKind::Type,\n@@ -1345,8 +1368,10 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n                     });\n                 }\n \n-                self.write_sub_paths_truncated(path);\n-                intravisit::walk_path(self, path);\n+                if let hir::QPath::Resolved(_, path) = path {\n+                    self.write_sub_paths_truncated(path);\n+                }\n+                intravisit::walk_qpath(self, path, t.hir_id, t.span);\n             }\n             hir::TyKind::Array(ref ty, ref anon_const) => {\n                 self.visit_ty(ty);\n@@ -1355,6 +1380,10 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n                     v.visit_expr(&map.body(anon_const.body).value)\n                 });\n             }\n+            hir::TyKind::Def(item_id, _) => {\n+                let item = self.tcx.hir().item(item_id.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(item_id.id), |v| v.visit_item(item));\n+            }\n             _ => intravisit::walk_ty(self, t),\n         }\n     }\n@@ -1432,8 +1461,8 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n         self.visit_expr(&arm.body);\n     }\n \n-    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n-        self.process_path(id, p);\n+    fn visit_qpath(&mut self, path: &'tcx hir::QPath<'tcx>, id: hir::HirId, _: Span) {\n+        self.process_path(id, path);\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {"}, {"sha": "8a456c903ecdfef473b0a50355ebbc088f346598", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b4af87406b2e8da7e6437115bbdde59a71f3a4e7", "patch": "@@ -13,11 +13,11 @@ use rustc_ast::ast::{self};\n use rustc_ast::util::comments::strip_doc_comment_decoration;\n use rustc_ast_pretty::pprust::attribute_to_string;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorOf, DefKind as HirDefKind, Res};\n+use rustc_hir::def::{DefKind as HirDefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n-use rustc_hir_pretty::ty_to_string;\n+use rustc_hir_pretty::{enum_def_to_string, fn_to_string, ty_to_string};\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::cstore::ExternCrate;\n use rustc_middle::middle::privacy::AccessLevels;\n@@ -135,7 +135,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n         let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n         match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(ref decl, arg_names, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n@@ -144,7 +144,23 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(decl, generics),\n+                    value: fn_to_string(\n+                        decl,\n+                        hir::FnHeader {\n+                            // functions in extern block are implicitly unsafe\n+                            unsafety: hir::Unsafety::Unsafe,\n+                            // functions in extern block cannot be const\n+                            constness: hir::Constness::NotConst,\n+                            abi: self.tcx.hir().get_foreign_abi(item.hir_id),\n+                            // functions in extern block cannot be async\n+                            asyncness: hir::IsAsync::NotAsync,\n+                        },\n+                        Some(item.ident.name),\n+                        generics,\n+                        &item.vis,\n+                        arg_names,\n+                        None,\n+                    ),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n@@ -191,7 +207,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(&sig.decl, generics),\n+                    value: fn_to_string(\n+                        sig.decl,\n+                        sig.header,\n+                        Some(item.ident.name),\n+                        generics,\n+                        &item.vis,\n+                        &[],\n+                        None,\n+                    ),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n@@ -268,13 +292,12 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            hir::ItemKind::Enum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, ref generics) => {\n                 let name = item.ident.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n                 filter!(self.span_utils, item.ident.span);\n-                let variants_str =\n-                    def.variants.iter().map(|v| v.ident.to_string()).collect::<Vec<_>>().join(\", \");\n-                let value = format!(\"{}::{{{}}}\", name, variants_str);\n+                let value =\n+                    enum_def_to_string(def, generics, item.ident.name, item.span, &item.vis);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n                     id: id_from_def_id(def_id),\n@@ -579,7 +602,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     ref_id: def_id.or(decl_id).map(id_from_def_id).unwrap_or_else(null_id),\n                 }))\n             }\n-            hir::ExprKind::Path(hir::QPath::Resolved(_, path)) => {\n+            hir::ExprKind::Path(ref path) => {\n                 self.get_path_data(expr.hir_id, path).map(Data::RefData)\n             }\n             _ => {\n@@ -631,8 +654,12 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self, id: hir::HirId, path: &hir::Path<'_>) -> Option<Ref> {\n-        path.segments.last().and_then(|seg| {\n+    pub fn get_path_data(&self, id: hir::HirId, path: &hir::QPath<'_>) -> Option<Ref> {\n+        let segment = match path {\n+            hir::QPath::Resolved(_, path) => path.segments.last(),\n+            hir::QPath::TypeRelative(_, segment) => Some(*segment),\n+        };\n+        segment.and_then(|seg| {\n             self.get_path_segment_data(seg).or_else(|| self.get_path_segment_data_with_id(seg, id))\n         })\n     }\n@@ -681,20 +708,16 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Def(HirDefKind::ConstParam, def_id) => {\n                 Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(def_id) })\n             }\n-            Res::Def(HirDefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                // This is a reference to a tuple struct where the def_id points\n+            Res::Def(HirDefKind::Ctor(_, ..), def_id) => {\n+                // This is a reference to a tuple struct or an enum variant where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n-                // def, so adjust to point to the tuple struct itself.\n+                // def, so adjust to point to the tuple struct or enum variant itself.\n                 let parent_def_id = self.tcx.parent(def_id).unwrap();\n                 Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(parent_def_id) })\n             }\n-            Res::Def(\n-                HirDefKind::Static\n-                | HirDefKind::Const\n-                | HirDefKind::AssocConst\n-                | HirDefKind::Ctor(..),\n-                _,\n-            ) => Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(res.def_id()) }),\n+            Res::Def(HirDefKind::Static | HirDefKind::Const | HirDefKind::AssocConst, _) => {\n+                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(res.def_id()) })\n+            }\n             Res::Def(HirDefKind::AssocFn, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n@@ -844,31 +867,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n }\n \n-fn make_signature(decl: &hir::FnDecl<'_>, generics: &hir::Generics<'_>) -> String {\n-    let mut sig = \"fn \".to_owned();\n-    if !generics.params.is_empty() {\n-        sig.push('<');\n-        sig.push_str(\n-            &generics\n-                .params\n-                .iter()\n-                .map(|param| param.name.ident().to_string())\n-                .collect::<Vec<_>>()\n-                .join(\", \"),\n-        );\n-        sig.push_str(\"> \");\n-    }\n-    sig.push('(');\n-    sig.push_str(&decl.inputs.iter().map(ty_to_string).collect::<Vec<_>>().join(\", \"));\n-    sig.push(')');\n-    match decl.output {\n-        hir::FnRetTy::DefaultReturn(_) => sig.push_str(\" -> ()\"),\n-        hir::FnRetTy::Return(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n-    }\n-\n-    sig\n-}\n-\n // An AST visitor for collecting paths (e.g., the names of structs) and formal\n // variables (idents) from patterns.\n struct PathCollector<'l> {"}, {"sha": "5f337f5f77033ab064d9919dfc4ef16126f41f6b", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4af87406b2e8da7e6437115bbdde59a71f3a4e7/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=b4af87406b2e8da7e6437115bbdde59a71f3a4e7", "patch": "@@ -281,6 +281,22 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                     })\n                 }\n             }\n+            hir::TyKind::Path(hir::QPath::TypeRelative(ty, segment)) => {\n+                let nested_ty = ty.make(offset + 1, id, scx)?;\n+                let prefix = format!(\"<{}>::\", nested_ty.text,);\n+\n+                let name = path_segment_to_string(segment);\n+                let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n+                let id = id_from_def_id(res.def_id());\n+\n+                let start = offset + prefix.len();\n+                let end = start + name.len();\n+                Ok(Signature {\n+                    text: prefix + &name,\n+                    defs: vec![],\n+                    refs: vec![SigElement { id, start, end }],\n+                })\n+            }\n             hir::TyKind::TraitObject(bounds, ..) => {\n                 // FIXME recurse into bounds\n                 let bounds: Vec<hir::GenericBound<'_>> = bounds\n@@ -308,11 +324,11 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                 let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n                 Ok(replace_text(nested_ty, text))\n             }\n-            hir::TyKind::Typeof(_)\n-            | hir::TyKind::Infer\n-            | hir::TyKind::Def(..)\n-            | hir::TyKind::Path(..)\n-            | hir::TyKind::Err => Err(\"Ty\"),\n+            hir::TyKind::Def(item_id, _) => {\n+                let item = scx.tcx.hir().item(item_id.id);\n+                item.make(offset, Some(item_id.id), scx)\n+            }\n+            hir::TyKind::Typeof(_) | hir::TyKind::Infer | hir::TyKind::Err => Err(\"Ty\"),\n         }\n     }\n }"}]}