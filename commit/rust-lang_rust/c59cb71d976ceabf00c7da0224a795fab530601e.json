{"sha": "c59cb71d976ceabf00c7da0224a795fab530601e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1OWNiNzFkOTc2Y2VhYmYwMGM3ZGEwMjI0YTc5NWZhYjUzMDYwMWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-26T21:58:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-26T21:58:16Z"}, "message": "Auto merge of #37419 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\n- Successful merges: #36206, #37144, #37391, #37394, #37396, #37398, #37414\n- Failed merges:", "tree": {"sha": "7b07c6b19df2843426f2ee453317a2a4d9fd44b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b07c6b19df2843426f2ee453317a2a4d9fd44b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c59cb71d976ceabf00c7da0224a795fab530601e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c59cb71d976ceabf00c7da0224a795fab530601e", "html_url": "https://github.com/rust-lang/rust/commit/c59cb71d976ceabf00c7da0224a795fab530601e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c59cb71d976ceabf00c7da0224a795fab530601e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "html_url": "https://github.com/rust-lang/rust/commit/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f"}, {"sha": "48b022838b28d046e127d24caa6a9dee5460fa08", "url": "https://api.github.com/repos/rust-lang/rust/commits/48b022838b28d046e127d24caa6a9dee5460fa08", "html_url": "https://github.com/rust-lang/rust/commit/48b022838b28d046e127d24caa6a9dee5460fa08"}], "stats": {"total": 149, "additions": 90, "deletions": 59}, "files": [{"sha": "1e2f061b06745484e11f70c522e36eae44ae5df3", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -240,7 +240,7 @@ fn main() {\n \n In other words, the mutable borrow is held through the rest of our example. What\n we want is for the mutable borrow by `y` to end so that the resource can be\n-returned to the owner, `x`. `x` can then provide a immutable borrow to `println!`.\n+returned to the owner, `x`. `x` can then provide an immutable borrow to `println!`.\n In Rust, borrowing is tied to the scope that the borrow is valid for. And our\n scopes look like this:\n "}, {"sha": "7fdf7e903d5ca9c3a76d6b278bf975f21ee9d2ff", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -166,7 +166,7 @@ use super::range::RangeArgument;\n /// # Slicing\n ///\n /// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n-/// To get a slice, use \"&\". Example:\n+/// To get a slice, use `&`. Example:\n ///\n /// ```\n /// fn read_slice(slice: &[usize]) {\n@@ -203,33 +203,33 @@ use super::range::RangeArgument;\n ///\n /// # Guarantees\n ///\n-/// Due to its incredibly fundamental nature, Vec makes a lot of guarantees\n+/// Due to its incredibly fundamental nature, `Vec` makes a lot of guarantees\n /// about its design. This ensures that it's as low-overhead as possible in\n /// the general case, and can be correctly manipulated in primitive ways\n /// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n /// If additional type parameters are added (e.g. to support custom allocators),\n /// overriding their defaults may change the behavior.\n ///\n-/// Most fundamentally, Vec is and always will be a (pointer, capacity, length)\n+/// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)\n /// triplet. No more, no less. The order of these fields is completely\n /// unspecified, and you should use the appropriate methods to modify these.\n /// The pointer will never be null, so this type is null-pointer-optimized.\n ///\n /// However, the pointer may not actually point to allocated memory. In particular,\n-/// if you construct a Vec with capacity 0 via [`Vec::new()`], [`vec![]`][`vec!`],\n+/// if you construct a `Vec` with capacity 0 via [`Vec::new()`], [`vec![]`][`vec!`],\n /// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit()`]\n /// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n /// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n-/// the `Vec` may not report a [`capacity()`] of 0*. Vec will allocate if and only\n+/// the `Vec` may not report a [`capacity()`] of 0*. `Vec` will allocate if and only\n /// if [`mem::size_of::<T>()`]` * capacity() > 0`. In general, `Vec`'s allocation\n /// details are subtle enough that it is strongly recommended that you only\n-/// free memory allocated by a Vec by creating a new Vec and dropping it.\n+/// free memory allocated by a `Vec` by creating a new `Vec` and dropping it.\n ///\n /// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n /// (as defined by the allocator Rust is configured to use by default), and its\n /// pointer points to [`len()`] initialized elements in order (what you would see\n-/// if you coerced it to a slice), followed by `[capacity()][`capacity()`] -\n-/// [len()][`len()`]` logically uninitialized elements.\n+/// if you coerced it to a slice), followed by [`capacity()`]` - `[`len()`]\n+/// logically uninitialized elements.\n ///\n /// `Vec` will never perform a \"small optimization\" where elements are actually\n /// stored on the stack for two reasons:\n@@ -249,8 +249,8 @@ use super::range::RangeArgument;\n /// [`shrink_to_fit`][`shrink_to_fit()`].\n ///\n /// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n-/// sufficient. [`push`] and [`insert`] *will* (re)allocate if `[len()][`len()`]\n-/// == [capacity()][`capacity()`]`. That is, the reported capacity is completely\n+/// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n+/// [`len()`]` == `[`capacity()`]. That is, the reported capacity is completely\n /// accurate, and can be relied on. It can even be used to manually free the memory\n /// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n /// when not necessary.\n@@ -261,11 +261,10 @@ use super::range::RangeArgument;\n /// strategy is used will of course guarantee `O(1)` amortized [`push`].\n ///\n /// `vec![x; n]`, `vec![a, b, c, d]`, and\n-/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all\n-/// produce a `Vec` with exactly the requested capacity. If `[len()][`len()`] ==\n-/// [capacity()][`capacity()`]`, (as is the case for the [`vec!`] macro), then a\n-/// `Vec<T>` can be converted to and from a [`Box<[T]>`] without reallocating or\n-/// moving the elements.\n+/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n+/// with exactly the requested capacity. If [`len()`]` == `[`capacity()`],\n+/// (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\n+/// and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n ///\n /// `Vec` will not specifically overwrite any data that is removed from it,\n /// but also won't specifically preserve it. Its uninitialized memory is\n@@ -292,7 +291,7 @@ use super::range::RangeArgument;\n /// [`push`]: ../../std/vec/struct.Vec.html#method.push\n /// [`insert`]: ../../std/vec/struct.Vec.html#method.insert\n /// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n-/// [`Box<[T]>`]: ../../std/boxed/struct.Box.html\n+/// [owned slice]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n@@ -329,9 +328,10 @@ impl<T> Vec<T> {\n     /// reallocating. If `capacity` is 0, the vector will not allocate.\n     ///\n     /// It is important to note that this function does not specify the *length*\n-    /// of the returned vector, but only the *capacity*. (For an explanation of\n-    /// the difference between length and capacity, see the main `Vec<T>` docs\n-    /// above, 'Capacity and reallocation'.)\n+    /// of the returned vector, but only the *capacity*. For an explanation of\n+    /// the difference between length and capacity, see *[Capacity and reallocation]*.\n+    ///\n+    /// [Capacity and reallocation]: #capacity-and-reallocation\n     ///\n     /// # Examples\n     ///\n@@ -497,13 +497,13 @@ impl<T> Vec<T> {\n         self.buf.shrink_to_fit(self.len);\n     }\n \n-    /// Converts the vector into [`Box<[T]>`].\n+    /// Converts the vector into [`Box<[T]>`][owned slice].\n     ///\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with [`into_vec()`] is equivalent to calling\n     /// [`shrink_to_fit()`].\n     ///\n-    /// [`Box<[T]>`]: ../../std/boxed/struct.Box.html\n+    /// [owned slice]: ../../std/boxed/struct.Box.html\n     /// [`into_vec()`]: ../../std/primitive.slice.html#method.into_vec\n     /// [`shrink_to_fit()`]: #method.shrink_to_fit\n     ///\n@@ -779,7 +779,7 @@ impl<T> Vec<T> {\n \n     /// Retains only the elements specified by the predicate.\n     ///\n-    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n+    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n     /// This method operates in place and preserves the order of the retained\n     /// elements.\n     ///"}, {"sha": "e1ea40809da07c58713c887ee8bb0432eb70e073", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -59,10 +59,12 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n                 // Check later.\n                 return;\n             }\n-            self.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                  id,\n-                                  span,\n-                                  \"unused import\".to_string());\n+            let msg = if let Ok(snippet) = self.session.codemap().span_to_snippet(span) {\n+                format!(\"unused import: `{}`\", snippet)\n+            } else {\n+                \"unused import\".to_string()\n+            };\n+            self.session.add_lint(lint::builtin::UNUSED_IMPORTS, id, span, msg);\n         } else {\n             // This trait import is definitely used, in a way other than\n             // method resolution."}, {"sha": "1c60ccb9765880f8a197eeeecb6171b6aa10f79a", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -854,9 +854,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let path_data = match path_data {\n             Some(pd) => pd,\n             None => {\n-                span_bug!(path.span,\n-                          \"Unexpected def kind while looking up path in `{}`\",\n-                          self.span.snippet(path.span))\n+                return;\n             }\n         };\n "}, {"sha": "c137fca58afb961abf695875872b30fe927f7270", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -1261,18 +1261,36 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         if bounds.len() > 1 {\n+            let spans = bounds.iter().map(|b| {\n+                self.tcx().impl_or_trait_items(b.def_id()).iter()\n+                .find(|&&def_id| {\n+                    match self.tcx().impl_or_trait_item(def_id) {\n+                        ty::TypeTraitItem(ref item) => item.name.as_str() == assoc_name,\n+                        _ => false\n+                    }\n+                })\n+                .and_then(|&def_id| self.tcx().map.as_local_node_id(def_id))\n+                .and_then(|node_id| self.tcx().map.opt_span(node_id))\n+            });\n+\n             let mut err = struct_span_err!(\n                 self.tcx().sess, span, E0221,\n                 \"ambiguous associated type `{}` in bounds of `{}`\",\n                 assoc_name,\n                 ty_param_name);\n             err.span_label(span, &format!(\"ambiguous associated type `{}`\", assoc_name));\n \n-            for bound in &bounds {\n-                span_note!(&mut err, span,\n-                           \"associated type `{}` could derive from `{}`\",\n-                           ty_param_name,\n-                           bound);\n+            for span_and_bound in spans.zip(&bounds) {\n+                if let Some(span) = span_and_bound.0 {\n+                    err.span_label(span, &format!(\"ambiguous `{}` from `{}`\",\n+                                                  assoc_name,\n+                                                  span_and_bound.1));\n+                } else {\n+                    span_note!(&mut err, span,\n+                               \"associated type `{}` could derive from `{}`\",\n+                               ty_param_name,\n+                               span_and_bound.1);\n+                }\n             }\n             err.emit();\n         }"}, {"sha": "7e41a672bf32541e831591b66a9f0b675913364e", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -30,10 +30,13 @@ impl<'a, 'tcx> UnusedTraitImportVisitor<'a, 'tcx> {\n         if self.tcx.used_trait_imports.borrow().contains(&id) {\n             return;\n         }\n-        self.tcx.sess.add_lint(lint::builtin::UNUSED_IMPORTS,\n-                               id,\n-                               span,\n-                               \"unused import\".to_string());\n+\n+        let msg = if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+            format!(\"unused import: `{}`\", snippet)\n+        } else {\n+            \"unused import\".to_string()\n+        };\n+        self.tcx.sess.add_lint(lint::builtin::UNUSED_IMPORTS, id, span, msg);\n     }\n }\n "}, {"sha": "7143a26d1339e169e21524f86d8f7bbe1915a27c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -1317,7 +1317,7 @@ pub enum UnstableFeatures {\n     /// Hard errors for unstable features are active, as on\n     /// beta/stable channels.\n     Disallow,\n-    /// Allow features to me activated, as on nightly.\n+    /// Allow features to be activated, as on nightly.\n     Allow,\n     /// Errors are bypassed for bootstrapping. This is required any time\n     /// during the build that feature-related lints are set to warn or above"}, {"sha": "aed2b4084e8103f3e4fb19ac192ba74d2d5db2f5", "filename": "src/test/compile-fail/E0221.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Ftest%2Fcompile-fail%2FE0221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Ftest%2Fcompile-fail%2FE0221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0221.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -12,17 +12,27 @@ trait T1 {}\n trait T2 {}\n \n trait Foo {\n-    type A: T1;\n+    type A: T1; //~ NOTE: ambiguous `A` from `Foo`\n }\n \n trait Bar : Foo {\n-    type A: T2;\n+    type A: T2; //~ NOTE: ambiguous `A` from `Bar`\n     fn do_something() {\n         let _: Self::A;\n         //~^ ERROR E0221\n         //~| NOTE ambiguous associated type `A`\n-        //~| NOTE associated type `Self` could derive from `Foo`\n-        //~| NOTE associated type `Self` could derive from `Bar`\n+    }\n+}\n+\n+trait T3 {}\n+\n+trait My : std::str::FromStr {\n+    type Err: T3; //~ NOTE: ambiguous `Err` from `My`\n+    fn test() {\n+        let _: Self::Err;\n+        //~^ ERROR E0221\n+        //~| NOTE ambiguous associated type `Err`\n+        //~| NOTE associated type `Self` could derive from `std::str::FromStr`\n     }\n }\n "}, {"sha": "b33bbfd84258fe88828ebf57e503b00ad57ad0bf", "filename": "src/test/compile-fail/associated-type-projection-from-multiple-supertraits.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -13,13 +13,19 @@\n \n pub trait Vehicle {\n     type Color;\n+    //~^ NOTE ambiguous `Color` from `Vehicle`\n+    //~| NOTE ambiguous `Color` from `Vehicle`\n+    //~| NOTE ambiguous `Color` from `Vehicle`\n \n     fn go(&self) {  }\n }\n \n pub trait Box {\n     type Color;\n-\n+    //~^ NOTE ambiguous `Color` from `Box`\n+    //~| NOTE ambiguous `Color` from `Box`\n+    //~| NOTE ambiguous `Color` from `Box`\n+    //\n     fn mail(&self) {  }\n }\n \n@@ -29,24 +35,18 @@ pub trait BoxCar : Box + Vehicle {\n fn dent<C:BoxCar>(c: C, color: C::Color) {\n     //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n     //~| NOTE ambiguous associated type `Color`\n-    //~| NOTE could derive from `Vehicle`\n-    //~| NOTE could derive from `Box`\n }\n \n fn dent_object<COLOR>(c: BoxCar<Color=COLOR>) {\n     //~^ ERROR ambiguous associated type\n     //~| ERROR the value of the associated type `Color` (from the trait `Vehicle`) must be specified\n     //~| NOTE ambiguous associated type `Color`\n-    //~| NOTE could derive from `Vehicle`\n-    //~| NOTE could derive from `Box`\n     //~| NOTE missing associated type `Color` value\n }\n \n fn paint<C:BoxCar>(c: C, d: C::Color) {\n     //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n     //~| NOTE ambiguous associated type `Color`\n-    //~| NOTE could derive from `Vehicle`\n-    //~| NOTE could derive from `Box`\n }\n \n pub fn main() { }"}, {"sha": "3f91c3e1e5c796fab129ac2964153ae0eb36ddf7", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -17,19 +17,19 @@ use std::mem::*;            // shouldn't get errors for not using\n                             // everything imported\n \n // Should get errors for both 'Some' and 'None'\n-use std::option::Option::{Some, None}; //~ ERROR unused import\n-                                     //~^ ERROR unused import\n+use std::option::Option::{Some, None}; //~ ERROR unused import: `Some`\n+                                    //~^ ERROR unused import: `None`\n \n-use test::A;       //~ ERROR unused import\n+use test::A;       //~ ERROR unused import: `test::A`\n // Be sure that if we just bring some methods into scope that they're also\n // counted as being used.\n use test::B;\n // But only when actually used: do not get confused by the method with the same name.\n-use test::B2; //~ ERROR unused import\n+use test::B2; //~ ERROR unused import: `test::B2`\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use test2::{foo, bar}; //~ ERROR unused import\n+use test2::{foo, bar}; //~ ERROR unused import: `bar`\n \n mod test2 {\n     pub fn foo() {}\n@@ -57,7 +57,7 @@ mod bar {\n \n     pub mod c {\n         use foo::Point;\n-        use foo::Square; //~ ERROR unused import\n+        use foo::Square; //~ ERROR unused import: `foo::Square`\n         pub fn cc(_p: Point) -> super::Square {\n             fn f() -> super::Square {\n                 super::Square\n@@ -73,7 +73,7 @@ mod bar {\n }\n \n fn g() {\n-    use self::g; //~ ERROR unused import\n+    use self::g; //~ ERROR unused import: `self::g`\n     fn f() {\n         self::g();\n     }\n@@ -82,7 +82,7 @@ fn g() {\n // c.f. issue #35135\n #[allow(unused_variables)]\n fn h() {\n-    use test2::foo; //~ ERROR unused import\n+    use test2::foo; //~ ERROR unused import: `test2::foo`\n     let foo = 0;\n }\n "}]}