{"sha": "62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZGM3YzVjNmI3ODEwZTQyN2Y1YmZlOWViZjkyZjgxZTY2OTZhY2Y=", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2020-09-02T23:42:00Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2020-09-05T00:01:18Z"}, "message": "fix: inner attribute formatting", "tree": {"sha": "98cdc868a15501022948378f802abd793e7d3a20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98cdc868a15501022948378f802abd793e7d3a20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf", "html_url": "https://github.com/rust-lang/rust/commit/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89b7f5f38260437db50ece8d48418f90bf1e42ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/89b7f5f38260437db50ece8d48418f90bf1e42ec", "html_url": "https://github.com/rust-lang/rust/commit/89b7f5f38260437db50ece8d48418f90bf1e42ec"}], "stats": {"total": 157, "additions": 98, "deletions": 59}, "files": [{"sha": "4da89e760adc5405192326b40e98b392fe9c1df2", "filename": "src/formatting.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf", "patch": "@@ -11,6 +11,7 @@ use self::newline_style::apply_newline_style;\n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n use crate::issues::BadIssueSeeker;\n+use crate::modules::Module;\n use crate::syntux::parser::{DirectoryOwnership, Parser, ParserError};\n use crate::syntux::session::ParseSess;\n use crate::utils::count_newlines;\n@@ -102,8 +103,7 @@ fn format_project<T: FormatHandler>(\n             continue;\n         }\n         should_emit_verbose(input_is_stdin, config, || println!(\"Formatting {}\", path));\n-        let is_root = path == main_file;\n-        context.format_file(path, &module, is_root)?;\n+        context.format_file(path, &module)?;\n     }\n     timer = timer.done_formatting();\n \n@@ -134,13 +134,8 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n     }\n \n     // Formats a single file/module.\n-    fn format_file(\n-        &mut self,\n-        path: FileName,\n-        module: &ast::Mod,\n-        is_root: bool,\n-    ) -> Result<(), ErrorKind> {\n-        let snippet_provider = self.parse_session.snippet_provider(module.inner);\n+    fn format_file(&mut self, path: FileName, module: &Module<'_>) -> Result<(), ErrorKind> {\n+        let snippet_provider = self.parse_session.snippet_provider(module.as_ref().inner);\n         let mut visitor = FmtVisitor::from_parse_sess(\n             &self.parse_session,\n             &self.config,\n@@ -149,19 +144,9 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n         );\n         visitor.skip_context.update_with_attrs(&self.krate.attrs);\n \n-        // Format inner attributes if available.\n-        if !self.krate.attrs.is_empty() && is_root {\n-            visitor.skip_empty_lines(snippet_provider.end_pos());\n-            if visitor.visit_attrs(&self.krate.attrs, ast::AttrStyle::Inner) {\n-                visitor.push_rewrite(module.inner, None);\n-            } else {\n-                visitor.format_separate_mod(module, snippet_provider.end_pos());\n-            }\n-        } else {\n-            visitor.last_pos = snippet_provider.start_pos();\n-            visitor.skip_empty_lines(snippet_provider.end_pos());\n-            visitor.format_separate_mod(module, snippet_provider.end_pos());\n-        };\n+        visitor.last_pos = snippet_provider.start_pos();\n+        visitor.skip_empty_lines(snippet_provider.end_pos());\n+        visitor.format_separate_mod(module, snippet_provider.end_pos());\n \n         debug_assert_eq!(\n             visitor.line_number,"}, {"sha": "b4d2f1fc822fd181f7b68fa65e99fef5248bf17d", "filename": "src/modules.rs", "status": "modified", "additions": 82, "deletions": 31, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf", "patch": "@@ -3,6 +3,7 @@ use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n \n use rustc_ast::ast;\n+use rustc_ast::attr::HasAttrs;\n use rustc_ast::visit::Visitor;\n use rustc_span::symbol::{self, sym, Symbol};\n use thiserror::Error;\n@@ -18,12 +19,48 @@ use crate::utils::contains_skip;\n \n mod visitor;\n \n-type FileModMap<'ast> = BTreeMap<FileName, Cow<'ast, ast::Mod>>;\n+type FileModMap<'ast> = BTreeMap<FileName, Module<'ast>>;\n \n lazy_static! {\n     static ref CFG_IF: Symbol = Symbol::intern(\"cfg_if\");\n }\n \n+/// Represents module with its inner attributes.\n+#[derive(Debug, Clone)]\n+pub(crate) struct Module<'a> {\n+    ast_mod: Cow<'a, ast::Mod>,\n+    inner_attr: Vec<ast::Attribute>,\n+}\n+\n+impl<'a> Module<'a> {\n+    pub(crate) fn new(ast_mod: Cow<'a, ast::Mod>, attrs: &[ast::Attribute]) -> Self {\n+        let inner_attr = attrs\n+            .iter()\n+            .filter(|attr| attr.style == ast::AttrStyle::Inner)\n+            .cloned()\n+            .collect();\n+        Module {\n+            ast_mod,\n+            inner_attr,\n+        }\n+    }\n+}\n+\n+impl<'a> HasAttrs for Module<'a> {\n+    fn attrs(&self) -> &[ast::Attribute] {\n+        &self.inner_attr\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<ast::Attribute>)) {\n+        f(&mut self.inner_attr)\n+    }\n+}\n+\n+impl<'a> AsRef<ast::Mod> for Module<'a> {\n+    fn as_ref(&self) -> &ast::Mod {\n+        &self.ast_mod\n+    }\n+}\n+\n /// Maps each module to the corresponding file.\n pub(crate) struct ModResolver<'ast, 'sess> {\n     parse_sess: &'sess ParseSess,\n@@ -53,9 +90,9 @@ pub(crate) enum ModuleResolutionErrorKind {\n #[derive(Clone)]\n enum SubModKind<'a, 'ast> {\n     /// `mod foo;`\n-    External(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>),\n+    External(PathBuf, DirectoryOwnership, Module<'ast>),\n     /// `mod foo;` with multiple sources.\n-    MultiExternal(Vec<(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>)>),\n+    MultiExternal(Vec<(PathBuf, DirectoryOwnership, Module<'ast>)>),\n     /// `mod foo {}`\n     Internal(&'a ast::Item),\n }\n@@ -94,8 +131,10 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             self.visit_mod_from_ast(&krate.module)?;\n         }\n \n-        self.file_map\n-            .insert(root_filename, Cow::Borrowed(&krate.module));\n+        self.file_map.insert(\n+            root_filename,\n+            Module::new(Cow::Borrowed(&krate.module), &krate.attrs),\n+        );\n         Ok(self.file_map)\n     }\n \n@@ -105,7 +144,10 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         visitor.visit_item(&item);\n         for module_item in visitor.mods() {\n             if let ast::ItemKind::Mod(ref sub_mod) = module_item.item.kind {\n-                self.visit_sub_mod(&module_item.item, Cow::Owned(sub_mod.clone()))?;\n+                self.visit_sub_mod(\n+                    &module_item.item,\n+                    Module::new(Cow::Owned(sub_mod.clone()), &module_item.item.attrs),\n+                )?;\n             }\n         }\n         Ok(())\n@@ -120,7 +162,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             }\n \n             if let ast::ItemKind::Mod(ref sub_mod) = item.kind {\n-                self.visit_sub_mod(&item, Cow::Owned(sub_mod.clone()))?;\n+                self.visit_sub_mod(&item, Module::new(Cow::Owned(sub_mod.clone()), &item.attrs))?;\n             }\n         }\n         Ok(())\n@@ -134,7 +176,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             }\n \n             if let ast::ItemKind::Mod(ref sub_mod) = item.kind {\n-                self.visit_sub_mod(item, Cow::Borrowed(sub_mod))?;\n+                self.visit_sub_mod(item, Module::new(Cow::Borrowed(sub_mod), &item.attrs))?;\n             }\n         }\n         Ok(())\n@@ -143,12 +185,12 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     fn visit_sub_mod(\n         &mut self,\n         item: &'c ast::Item,\n-        sub_mod: Cow<'ast, ast::Mod>,\n+        sub_mod: Module<'ast>,\n     ) -> Result<(), ModuleResolutionError> {\n         let old_directory = self.directory.clone();\n         let sub_mod_kind = self.peek_sub_mod(item, &sub_mod)?;\n         if let Some(sub_mod_kind) = sub_mod_kind {\n-            self.insert_sub_mod(sub_mod_kind.clone(), sub_mod.clone())?;\n+            self.insert_sub_mod(sub_mod_kind.clone())?;\n             self.visit_sub_mod_inner(sub_mod, sub_mod_kind)?;\n         }\n         self.directory = old_directory;\n@@ -159,7 +201,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     fn peek_sub_mod(\n         &self,\n         item: &'c ast::Item,\n-        sub_mod: &Cow<'ast, ast::Mod>,\n+        sub_mod: &Module<'ast>,\n     ) -> Result<Option<SubModKind<'c, 'ast>>, ModuleResolutionError> {\n         if contains_skip(&item.attrs) {\n             return Ok(None);\n@@ -178,7 +220,6 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     fn insert_sub_mod(\n         &mut self,\n         sub_mod_kind: SubModKind<'c, 'ast>,\n-        _sub_mod: Cow<'ast, ast::Mod>,\n     ) -> Result<(), ModuleResolutionError> {\n         match sub_mod_kind {\n             SubModKind::External(mod_path, _, sub_mod) => {\n@@ -200,7 +241,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n \n     fn visit_sub_mod_inner(\n         &mut self,\n-        sub_mod: Cow<'ast, ast::Mod>,\n+        sub_mod: Module<'ast>,\n         sub_mod_kind: SubModKind<'c, 'ast>,\n     ) -> Result<(), ModuleResolutionError> {\n         match sub_mod_kind {\n@@ -230,13 +271,13 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n \n     fn visit_sub_mod_after_directory_update(\n         &mut self,\n-        sub_mod: Cow<'ast, ast::Mod>,\n+        sub_mod: Module<'ast>,\n         directory: Option<Directory>,\n     ) -> Result<(), ModuleResolutionError> {\n         if let Some(directory) = directory {\n             self.directory = directory;\n         }\n-        match sub_mod {\n+        match sub_mod.ast_mod {\n             Cow::Borrowed(sub_mod) => self.visit_mod_from_ast(sub_mod),\n             Cow::Owned(sub_mod) => self.visit_mod_outside_ast(sub_mod),\n         }\n@@ -247,7 +288,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         &self,\n         mod_name: symbol::Ident,\n         attrs: &[ast::Attribute],\n-        sub_mod: &Cow<'ast, ast::Mod>,\n+        sub_mod: &Module<'ast>,\n     ) -> Result<Option<SubModKind<'c, 'ast>>, ModuleResolutionError> {\n         let relative = match self.directory.ownership {\n             DirectoryOwnership::Owned { relative } => relative,\n@@ -257,12 +298,13 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             if self.parse_sess.is_file_parsed(&path) {\n                 return Ok(None);\n             }\n-            return match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.inner) {\n+            return match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.ast_mod.inner)\n+            {\n                 Ok((_, ref attrs)) if contains_skip(attrs) => Ok(None),\n-                Ok((m, _)) => Ok(Some(SubModKind::External(\n+                Ok(m) => Ok(Some(SubModKind::External(\n                     path,\n                     DirectoryOwnership::Owned { relative: None },\n-                    Cow::Owned(m),\n+                    Module::new(Cow::Owned(m.0), &m.1),\n                 ))),\n                 Err(ParserError::ParseError) => Err(ModuleResolutionError {\n                     module: mod_name.to_string(),\n@@ -300,13 +342,19 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                         return Ok(Some(SubModKind::MultiExternal(mods_outside_ast)));\n                     }\n                 }\n-                match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.inner) {\n+                match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.ast_mod.inner) {\n                     Ok((_, ref attrs)) if contains_skip(attrs) => Ok(None),\n-                    Ok((m, _)) if outside_mods_empty => {\n-                        Ok(Some(SubModKind::External(path, ownership, Cow::Owned(m))))\n-                    }\n-                    Ok((m, _)) => {\n-                        mods_outside_ast.push((path.clone(), ownership, Cow::Owned(m)));\n+                    Ok(m) if outside_mods_empty => Ok(Some(SubModKind::External(\n+                        path,\n+                        ownership,\n+                        Module::new(Cow::Owned(m.0), &m.1),\n+                    ))),\n+                    Ok(m) => {\n+                        mods_outside_ast.push((\n+                            path.clone(),\n+                            ownership,\n+                            Module::new(Cow::Owned(m.0), &m.1),\n+                        ));\n                         if should_insert {\n                             mods_outside_ast.push((path, ownership, sub_mod.clone()));\n                         }\n@@ -368,8 +416,8 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     fn find_mods_outside_of_ast(\n         &self,\n         attrs: &[ast::Attribute],\n-        sub_mod: &Cow<'ast, ast::Mod>,\n-    ) -> Vec<(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>)> {\n+        sub_mod: &Module<'ast>,\n+    ) -> Vec<(PathBuf, DirectoryOwnership, Module<'ast>)> {\n         // Filter nested path, like `#[cfg_attr(feature = \"foo\", path = \"bar.rs\")]`.\n         let mut path_visitor = visitor::PathVisitor::default();\n         for attr in attrs.iter() {\n@@ -393,17 +441,20 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                 ));\n                 continue;\n             }\n-            let m = match Parser::parse_file_as_module(self.parse_sess, &actual_path, sub_mod.inner)\n-            {\n+            let m = match Parser::parse_file_as_module(\n+                self.parse_sess,\n+                &actual_path,\n+                sub_mod.ast_mod.inner,\n+            ) {\n                 Ok((_, ref attrs)) if contains_skip(attrs) => continue,\n-                Ok((m, _)) => m,\n+                Ok(m) => m,\n                 Err(..) => continue,\n             };\n \n             result.push((\n                 actual_path,\n                 DirectoryOwnership::Owned { relative: None },\n-                Cow::Owned(m),\n+                Module::new(Cow::Owned(m.0), &m.1),\n             ))\n         }\n         result"}, {"sha": "779a3a268ef2a570537d0f93d02df382af0d6d64", "filename": "src/visitor.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf", "patch": "@@ -1,7 +1,7 @@\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n \n-use rustc_ast::{ast, token::DelimToken, visit};\n+use rustc_ast::{ast, attr::HasAttrs, token::DelimToken, visit};\n use rustc_span::{symbol, BytePos, Pos, Span};\n \n use crate::attr::*;\n@@ -16,6 +16,7 @@ use crate::items::{\n     StaticParts, StructParts,\n };\n use crate::macros::{macro_style, rewrite_macro, rewrite_macro_def, MacroPosition};\n+use crate::modules::Module;\n use crate::rewrite::{Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::skip::{is_skip_attr, SkipContext};\n@@ -938,10 +939,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub(crate) fn format_separate_mod(&mut self, m: &ast::Mod, end_pos: BytePos) {\n+    pub(crate) fn format_separate_mod(&mut self, m: &Module<'_>, end_pos: BytePos) {\n         self.block_indent = Indent::empty();\n-        self.walk_mod_items(m);\n-        self.format_missing_with_indent(end_pos);\n+        if self.visit_attrs(m.attrs(), ast::AttrStyle::Inner) {\n+            self.push_skipped_with_span(m.attrs(), m.as_ref().inner, m.as_ref().inner);\n+        } else {\n+            self.walk_mod_items(m.as_ref());\n+            self.format_missing_with_indent(end_pos);\n+        }\n     }\n \n     pub(crate) fn skip_empty_lines(&mut self, end_pos: BytePos) {"}, {"sha": "60d246dd5fb45f456bf4d2d84c28fe1b6e3ed4c3", "filename": "tests/target/inner-module-path/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/tests%2Ftarget%2Finner-module-path%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf/tests%2Ftarget%2Finner-module-path%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Finner-module-path%2Flib.rs?ref=62dc7c5c6b7810e427f5bfe9ebf92f81e6696acf", "patch": "@@ -1,5 +1,3 @@\n-// rustfmt-recursive: true\n-\n #[path = \".\"]\n mod a {\n     mod b;"}]}