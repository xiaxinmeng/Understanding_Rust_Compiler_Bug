{"sha": "50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYjhiYzhjOGNjODRiNjUzZmExNGZlMmZlNGM3Mjg0ZTcwYzQxM2Q=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-01T08:31:58Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-02T06:48:52Z"}, "message": "hir: remove NodeId from Pat and FieldPat", "tree": {"sha": "5190ec43fc1f40fd5b9e7fb7098840cd97ed3142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5190ec43fc1f40fd5b9e7fb7098840cd97ed3142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "html_url": "https://github.com/rust-lang/rust/commit/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77fa041fc1ca58b2ccbdb600f39aa92da1276970", "url": "https://api.github.com/repos/rust-lang/rust/commits/77fa041fc1ca58b2ccbdb600f39aa92da1276970", "html_url": "https://github.com/rust-lang/rust/commit/77fa041fc1ca58b2ccbdb600f39aa92da1276970"}], "stats": {"total": 189, "additions": 87, "deletions": 102}, "files": [{"sha": "5a95681d667fb828102c4915e6a126d0b03a8739", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -3740,12 +3740,11 @@ impl<'a> LoweringContext<'a> {\n                 let fs = fields\n                     .iter()\n                     .map(|f| {\n-                        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n                         Spanned {\n                             span: f.span,\n                             node: hir::FieldPat {\n-                                id: node_id,\n                                 hir_id,\n                                 ident: f.node.ident,\n                                 pat: self.lower_pat(&f.node.pat),\n@@ -3777,9 +3776,8 @@ impl<'a> LoweringContext<'a> {\n             PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(p.id);\n         P(hir::Pat {\n-            id: node_id,\n             hir_id,\n             node,\n             span: p.span,\n@@ -4353,7 +4351,7 @@ impl<'a> LoweringContext<'a> {\n                 let iter = self.str_to_ident(\"iter\");\n \n                 let next_ident = self.str_to_ident(\"__next\");\n-                let next_pat = self.pat_ident_binding_mode(\n+                let (next_pat, next_pat_nid) = self.pat_ident_binding_mode(\n                     desugared_span,\n                     next_ident,\n                     hir::BindingAnnotation::Mutable,\n@@ -4362,9 +4360,9 @@ impl<'a> LoweringContext<'a> {\n                 // `::std::option::Option::Some(val) => next = val`\n                 let pat_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n-                    let val_pat = self.pat_ident(pat.span, val_ident);\n-                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat.id));\n-                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat.id));\n+                    let (val_pat, val_pat_nid) = self.pat_ident(pat.span, val_ident);\n+                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_nid));\n+                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_nid));\n                     let assign = P(self.expr(\n                         pat.span,\n                         hir::ExprKind::Assign(next_expr, val_expr),\n@@ -4383,15 +4381,15 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 // `mut iter`\n-                let iter_pat = self.pat_ident_binding_mode(\n+                let (iter_pat, iter_pat_nid) = self.pat_ident_binding_mode(\n                     desugared_span,\n                     iter,\n                     hir::BindingAnnotation::Mutable\n                 );\n \n                 // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                 let match_expr = {\n-                    let iter = P(self.expr_ident(head_sp, iter, iter_pat.id));\n+                    let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n                     let next_path = &[\"iter\", \"Iterator\", \"next\"];\n                     let next_path = P(self.expr_std_path(head_sp, next_path, None, ThinVec::new()));\n@@ -4415,7 +4413,7 @@ impl<'a> LoweringContext<'a> {\n                     span: head_sp,\n                 };\n \n-                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat.id));\n+                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_nid));\n \n                 // `let mut __next`\n                 let next_let = self.stmt_let_pat(\n@@ -4542,11 +4540,11 @@ impl<'a> LoweringContext<'a> {\n                 // `Ok(val) => #[allow(unreachable_code)] val,`\n                 let ok_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n-                    let val_pat = self.pat_ident(e.span, val_ident);\n+                    let (val_pat, val_pat_nid) = self.pat_ident(e.span, val_ident);\n                     let val_expr = P(self.expr_ident_with_attrs(\n                         e.span,\n                         val_ident,\n-                        val_pat.id,\n+                        val_pat_nid,\n                         ThinVec::from(attrs.clone()),\n                     ));\n                     let ok_pat = self.pat_ok(e.span, val_pat);\n@@ -4558,12 +4556,12 @@ impl<'a> LoweringContext<'a> {\n                 //              return Try::from_error(From::from(err)),`\n                 let err_arm = {\n                     let err_ident = self.str_to_ident(\"err\");\n-                    let err_local = self.pat_ident(e.span, err_ident);\n+                    let (err_local, err_local_nid) = self.pat_ident(e.span, err_ident);\n                     let from_expr = {\n                         let path = &[\"convert\", \"From\", \"from\"];\n                         let from = P(self.expr_std_path(\n                                 e.span, path, None, ThinVec::new()));\n-                        let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n+                        let err_expr = self.expr_ident(e.span, err_ident, err_local_nid);\n \n                         self.expr_call(e.span, from, hir_vec![err_expr])\n                     };\n@@ -4911,15 +4909,15 @@ impl<'a> LoweringContext<'a> {\n         ident: Ident,\n         ex: P<hir::Expr>,\n     ) -> (hir::Stmt, NodeId) {\n-        let pat = if mutbl {\n+        let (pat, pat_nid) = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, hir::BindingAnnotation::Mutable)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let pat_id = pat.id;\n+\n         (\n             self.stmt_let_pat(sp, Some(ex), pat, hir::LocalSource::Normal),\n-            pat_id,\n+            pat_nid,\n         )\n     }\n \n@@ -4977,7 +4975,7 @@ impl<'a> LoweringContext<'a> {\n         self.pat(span, pt)\n     }\n \n-    fn pat_ident(&mut self, span: Span, ident: Ident) -> P<hir::Pat> {\n+    fn pat_ident(&mut self, span: Span, ident: Ident) -> (P<hir::Pat>, NodeId) {\n         self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n     }\n \n@@ -4986,25 +4984,26 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         ident: Ident,\n         bm: hir::BindingAnnotation,\n-    ) -> P<hir::Pat> {\n+    ) -> (P<hir::Pat>, NodeId) {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n \n-        P(hir::Pat {\n-            id: node_id,\n-            hir_id,\n-            node: hir::PatKind::Binding(bm, node_id, hir_id, ident.with_span_pos(span), None),\n-            span,\n-        })\n+        (\n+            P(hir::Pat {\n+                hir_id,\n+                node: hir::PatKind::Binding(bm, node_id, hir_id, ident.with_span_pos(span), None),\n+                span,\n+            }),\n+            node_id\n+        )\n     }\n \n     fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n         self.pat(span, hir::PatKind::Wild)\n     }\n \n     fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         P(hir::Pat {\n-            id: node_id,\n             hir_id,\n             node: pat,\n             span,"}, {"sha": "d632810d006e86a45406ce2bdf7bf4b2541e1e5c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -834,15 +834,14 @@ pub struct Block {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Pat {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub node: PatKind,\n     pub span: Span,\n }\n \n impl fmt::Debug for Pat {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"pat({}: {})\", self.id,\n+        write!(f, \"pat({}: {})\", self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_pat(self)))\n     }\n }\n@@ -897,7 +896,6 @@ impl Pat {\n /// except `is_shorthand` is true.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FieldPat {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     /// The identifier for the field.\n     pub ident: Ident,"}, {"sha": "f46ef20aaf19c67f5f43f6aaa81db36fb7b5455f", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -421,7 +421,6 @@ impl_stable_hash_for!(struct hir::Block {\n });\n \n impl_stable_hash_for!(struct hir::Pat {\n-    id -> _,\n     hir_id -> _,\n     node,\n     span,\n@@ -430,7 +429,6 @@ impl_stable_hash_for!(struct hir::Pat {\n impl_stable_hash_for_spanned!(hir::FieldPat);\n \n impl_stable_hash_for!(struct hir::FieldPat {\n-    id -> _,\n     hir_id -> _,\n     ident -> (ident.name),\n     pat,"}, {"sha": "6e8b661b7b895b1714730e47c8c1b13148734175", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -19,7 +19,6 @@ use crate::ty::{self, TyCtxt, adjustment};\n use crate::hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use crate::util::nodemap::ItemLocalSet;\n@@ -74,7 +73,7 @@ pub trait Delegate<'tcx> {\n \n     // The local variable `id` is declared but not initialized.\n     fn decl_without_init(&mut self,\n-                         id: ast::NodeId,\n+                         id: hir::HirId,\n                          span: Span);\n \n     // The path at `cmt` is being assigned to.\n@@ -609,8 +608,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 local.pat.each_binding(|_, hir_id, span, _| {\n-                    let node_id = self.mc.tcx.hir().hir_to_node_id(hir_id);\n-                    self.delegate.decl_without_init(node_id, span);\n+                    self.delegate.decl_without_init(hir_id, span);\n                 })\n             }\n "}, {"sha": "a3e8598194e790550f12d5a3ff5f08a412a571b7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -88,7 +88,7 @@ pub enum Categorization<'tcx> {\n     ThreadLocal(ty::Region<'tcx>),       // value that cannot move, but still restricted in scope\n     StaticItem,\n     Upvar(Upvar),                        // upvar referenced by closure env\n-    Local(ast::NodeId),                  // local variable\n+    Local(hir::HirId),                   // local variable\n     Deref(cmt<'tcx>, PointerKind<'tcx>), // deref of a ptr\n     Interior(cmt<'tcx>, InteriorKind),   // something interior: field, tuple, etc\n     Downcast(cmt<'tcx>, DefId),          // selects a particular enum variant (*1)\n@@ -198,9 +198,9 @@ pub struct cmt_<'tcx> {\n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n pub enum ImmutabilityBlame<'tcx> {\n-    ImmLocal(ast::NodeId),\n+    ImmLocal(hir::HirId),\n     ClosureEnv(LocalDefId),\n-    LocalDeref(ast::NodeId),\n+    LocalDeref(hir::HirId),\n     AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n }\n \n@@ -230,8 +230,8 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Deref(ref base_cmt, BorrowedPtr(ty::ImmBorrow, _)) => {\n                 // try to figure out where the immutable reference came from\n                 match base_cmt.cat {\n-                    Categorization::Local(node_id) =>\n-                        Some(ImmutabilityBlame::LocalDeref(node_id)),\n+                    Categorization::Local(hir_id) =>\n+                        Some(ImmutabilityBlame::LocalDeref(hir_id)),\n                     Categorization::Interior(ref base_cmt, InteriorField(field_index)) => {\n                         base_cmt.resolve_field(field_index.0).map(|(adt_def, field_def)| {\n                             ImmutabilityBlame::AdtFieldDeref(adt_def, field_def)\n@@ -247,8 +247,8 @@ impl<'tcx> cmt_<'tcx> {\n                     _ => None\n                 }\n             }\n-            Categorization::Local(node_id) => {\n-                Some(ImmutabilityBlame::ImmLocal(node_id))\n+            Categorization::Local(hir_id) => {\n+                Some(ImmutabilityBlame::ImmLocal(hir_id))\n             }\n             Categorization::Rvalue(..) |\n             Categorization::Upvar(..) |\n@@ -741,7 +741,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 Ok(cmt_ {\n                     hir_id,\n                     span,\n-                    cat: Categorization::Local(vid),\n+                    cat: Categorization::Local(self.tcx.hir().node_to_hir_id(vid)),\n                     mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n                     ty: expr_ty,\n                     note: NoteNone\n@@ -1495,7 +1495,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"non-place\".into()\n             }\n             Categorization::Local(vid) => {\n-                if tcx.hir().is_argument(vid) {\n+                if tcx.hir().is_argument(tcx.hir().hir_to_node_id(vid)) {\n                     \"argument\"\n                 } else {\n                     \"local variable\""}, {"sha": "3375a6219fdf50f14cee881c7d3d90b90b453723", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -2397,7 +2397,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let help_name = if let Some(body) = parent {\n                 let arg = &self.tcx.hir().body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir().node_to_pretty_string(arg.pat.id))\n+                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(arg.pat.hir_id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };"}, {"sha": "bd854e3aa3c812597e77a46ec51a4d2c4704e812", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -17,7 +17,6 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt, RegionKind};\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Node;\n@@ -177,7 +176,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         self.check_assignment(assignment_id.local_id, assignment_span, assignee_cmt);\n     }\n \n-    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n+    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) { }\n }\n \n pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n@@ -887,11 +886,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // Check for reassignments to (immutable) local variables. This\n         // needs to be done here instead of in check_loans because we\n         // depend on move data.\n-        if let Categorization::Local(local_id) = assignee_cmt.cat {\n+        if let Categorization::Local(hir_id) = assignee_cmt.cat {\n             let lp = opt_loan_path(assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n-                    let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                     self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                 } else {\n                     self.bccx.report_reassigned_immutable_variable("}, {"sha": "310a9a2ef8dad57320cae6f8fb42ed47640d2068", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -11,7 +11,6 @@ use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::ty::{self, Ty};\n \n use std::rc::Rc;\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::*;\n use rustc::hir::Node;\n@@ -48,9 +47,9 @@ pub enum PatternSource<'tcx> {\n /// with a reference to the let\n fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n-    let parent = tcx.hir().get_parent_node(pat.id);\n+    let parent = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n \n-    match tcx.hir().get(parent) {\n+    match tcx.hir().get_by_hir_id(parent) {\n         Node::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n@@ -67,11 +66,10 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n \n pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              move_data: &MoveData<'tcx>,\n-                             var_id: ast::NodeId,\n+                             var_id: hir::HirId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    let hir_id = bccx.tcx.hir().node_to_hir_id(var_id);\n-    move_data.add_move(bccx.tcx, loan_path, hir_id.local_id, Declared);\n+    move_data.add_move(bccx.tcx, loan_path, var_id.local_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,"}, {"sha": "0e08b62668ac8f7d72c99b71c144e97e21027286", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -104,8 +104,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             Categorization::Upvar(..) => {\n                 self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n-            Categorization::Local(local_id) => {\n-                let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n+            Categorization::Local(hir_id) => {\n                 self.bccx.tcx.mk_region(ty::ReScope(\n                     self.bccx.region_scope_tree.var_scope(hir_id.local_id)))\n             }"}, {"sha": "bf730ba41f42845b3100edd21fe05111df730bfe", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -147,10 +147,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                                         assignee_cmt);\n     }\n \n-    fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n+    fn decl_without_init(&mut self, id: hir::HirId, _span: Span) {\n         let ty = self.bccx\n                      .tables\n-                     .node_type(self.bccx.tcx.hir().node_to_hir_id(id));\n+                     .node_type(id);\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }\n@@ -438,9 +438,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n         while let Some(current_path) = wrapped_path {\n             wrapped_path = match current_path.kind {\n-                LpVar(local_id) => {\n+                LpVar(hir_id) => {\n                     if !through_borrow {\n-                        let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                         self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                     }\n                     None"}, {"sha": "6d0efb163b8f7f9314614280a90627a9cb0321d9", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -335,7 +335,7 @@ impl<'tcx> Hash for LoanPath<'tcx> {\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathKind<'tcx> {\n-    LpVar(ast::NodeId),                         // `x` in README.md\n+    LpVar(hir::HirId),                          // `x` in README.md\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n     LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n     LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n@@ -417,8 +417,7 @@ fn closure_to_block(closure_id: LocalDefId,\n impl<'a, 'tcx> LoanPath<'tcx> {\n     pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n         match self.kind {\n-            LpVar(local_id) => {\n-                let hir_id = bccx.tcx.hir().node_to_hir_id(local_id);\n+            LpVar(hir_id) => {\n                 bccx.region_scope_tree.var_scope(hir_id.local_id)\n             }\n             LpUpvar(upvar_id) => {\n@@ -919,7 +918,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.note_immutability_blame(\n                     &mut db,\n                     err.cmt.immutability_blame(),\n-                    self.tcx.hir().hir_to_node_id(err.cmt.hir_id)\n+                    err.cmt.hir_id\n                 );\n                 db.emit();\n                 self.signal_error();\n@@ -1135,7 +1134,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.note_immutability_blame(\n             &mut err,\n             blame,\n-            self.tcx.hir().hir_to_node_id(cmt.hir_id)\n+            cmt.hir_id\n         );\n \n         if is_closure {\n@@ -1175,8 +1174,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n-        let pat = match self.tcx.hir().get(node_id) {\n+    fn local_binding_mode(&self, hir_id: hir::HirId) -> ty::BindingMode {\n+        let pat = match self.tcx.hir().get_by_hir_id(hir_id) {\n             Node::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n@@ -1192,16 +1191,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_ty(&self, node_id: ast::NodeId) -> (Option<&hir::Ty>, bool) {\n-        let parent = self.tcx.hir().get_parent_node(node_id);\n-        let parent_node = self.tcx.hir().get(parent);\n+    fn local_ty(&self, hir_id: hir::HirId) -> (Option<&hir::Ty>, bool) {\n+        let parent = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+        let parent_node = self.tcx.hir().get_by_hir_id(parent);\n \n         // The parent node is like a fn\n         if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n             // `nid`'s parent's `Body`\n             let fn_body = self.tcx.hir().body(fn_like.body());\n             // Get the position of `node_id` in the arguments list\n-            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == node_id);\n+            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.hir_id == hir_id);\n             if let Some(i) = arg_pos {\n                 // The argument's `Ty`\n                 (Some(&fn_like.decl().inputs[i]),\n@@ -1217,17 +1216,17 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn note_immutability_blame(&self,\n                                db: &mut DiagnosticBuilder<'_>,\n                                blame: Option<ImmutabilityBlame<'_>>,\n-                               error_node_id: ast::NodeId) {\n+                               error_hir_id: hir::HirId) {\n         match blame {\n             None => {}\n             Some(ImmutabilityBlame::ClosureEnv(_)) => {}\n-            Some(ImmutabilityBlame::ImmLocal(node_id)) => {\n-                self.note_immutable_local(db, error_node_id, node_id)\n+            Some(ImmutabilityBlame::ImmLocal(hir_id)) => {\n+                self.note_immutable_local(db, error_hir_id, hir_id)\n             }\n-            Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n-                match self.local_binding_mode(node_id) {\n+            Some(ImmutabilityBlame::LocalDeref(hir_id)) => {\n+                match self.local_binding_mode(hir_id) {\n                     ty::BindByReference(..) => {\n-                        let let_span = self.tcx.hir().span(node_id);\n+                        let let_span = self.tcx.hir().span_by_hir_id(hir_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n                         if let Some(replace_str) = suggestion {\n                             db.span_suggestion(\n@@ -1244,7 +1243,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                     }\n                     ty::BindByValue(..) => {\n-                        if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n+                        if let (Some(local_ty), is_implicit_self) = self.local_ty(hir_id) {\n                             if let Some(msg) =\n                                  self.suggest_mut_for_immutable(local_ty, is_implicit_self) {\n                                 db.span_label(local_ty.span, msg);\n@@ -1273,12 +1272,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n      // not a mutable reference) or to avoid borrowing altogether\n     fn note_immutable_local(&self,\n                             db: &mut DiagnosticBuilder<'_>,\n-                            borrowed_node_id: ast::NodeId,\n-                            binding_node_id: ast::NodeId) {\n-        let let_span = self.tcx.hir().span(binding_node_id);\n-        if let ty::BindByValue(..) = self.local_binding_mode(binding_node_id) {\n+                            borrowed_hir_id: hir::HirId,\n+                            binding_hir_id: hir::HirId) {\n+        let let_span = self.tcx.hir().span_by_hir_id(binding_hir_id);\n+        if let ty::BindByValue(..) = self.local_binding_mode(binding_hir_id) {\n             if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n-                let (ty, is_implicit_self) = self.local_ty(binding_node_id);\n+                let (ty, is_implicit_self) = self.local_ty(binding_hir_id);\n                 if is_implicit_self && snippet != \"self\" {\n                     // avoid suggesting `mut &self`.\n                     return\n@@ -1291,9 +1290,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     },\n                 )) = ty.map(|t| &t.node)\n                 {\n-                    let borrow_expr_id = self.tcx.hir().get_parent_node(borrowed_node_id);\n+                    let borrow_expr_id = self.tcx.hir().get_parent_node_by_hir_id(borrowed_hir_id);\n                     db.span_suggestion(\n-                        self.tcx.hir().span(borrow_expr_id),\n+                        self.tcx.hir().span_by_hir_id(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\\n                         immutable binding to a mutable reference\",\n                         snippet,\n@@ -1373,7 +1372,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.hir().span(local_id);\n+                    let span = self.tcx.hir().span_by_hir_id(local_id);\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n@@ -1401,7 +1400,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n             }\n             LpVar(id) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n+                out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n@@ -1512,7 +1511,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n@@ -1547,7 +1546,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_user_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {"}, {"sha": "1750aa62dd5e0f9d43b82e5123be8ddb327d3989", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -428,8 +428,8 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             }\n             pprust_hir::AnnNode::Pat(pat) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"pat node_id: {} hir local_id: {}\",\n-                                        pat.id, pat.hir_id.local_id.as_u32()))\n+                s.synth_comment(format!(\"pat hir_id: {} hir local_id: {}\",\n+                                        pat.hir_id, pat.hir_id.local_id.as_u32()))\n             }\n         }\n     }"}, {"sha": "8b16eeeea23c0513743a93004d93ac3113a85a36", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n         let tcx = self.tcx.global_tcx();\n-        let p = match tcx.hir().get(p.id) {\n+        let p = match tcx.hir().get_by_hir_id(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };"}, {"sha": "3d8c085567f1c2768d65dde4577b066655e3b535", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -24,7 +24,6 @@ use rustc::hir::{self, Pat, PatKind};\n use smallvec::smallvec;\n use std::slice;\n \n-use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n@@ -241,7 +240,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n-        let module = self.tcx.hir().get_module_parent(pat.id);\n+        let module = self.tcx.hir().get_module_parent_by_hir_id(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),\n@@ -586,7 +585,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n             ty::ImmBorrow | ty::UniqueImmBorrow => {}\n         }\n     }\n-    fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: hir::HirId, _: Span) {}\n     fn mutate(&mut self, _: hir::HirId, span: Span, _: &cmt_<'_>, mode: MutateMode) {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {"}, {"sha": "edd658254467f95a7da1721b7f2c5b43f36e104a", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -26,7 +26,6 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n-use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use log::debug;\n use Promotability::*;\n@@ -677,7 +676,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n         }\n     }\n \n-    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n+    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) {}\n     fn mutate(&mut self,\n               _assignment_id: hir::HirId,\n               _assignment_span: Span,"}, {"sha": "183667e224462a108d4df59055eaf37beadf7441", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -1008,9 +1008,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         if let PatKind::Binding(_, _, _, ident, _) = p.node {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n+            let node_id = self.fcx.tcx.hir().hir_to_node_id(p.hir_id);\n             if !self.fcx.tcx.features().unsized_locals {\n                 self.fcx.require_type_is_sized(var_ty, p.span,\n-                                               traits::VariableType(p.id));\n+                                               traits::VariableType(node_id));\n             }\n \n             debug!(\"Pattern binding {} is assigned to {} with type {:?}\","}, {"sha": "89e8b2b840d1fee0e5c7ed9392f271a87fd9984b", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=50b8bc8c8cc84b653fa14fe2fe4c7284e70c413d", "patch": "@@ -635,7 +635,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n+    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) {}\n \n     fn mutate(\n         &mut self,"}]}