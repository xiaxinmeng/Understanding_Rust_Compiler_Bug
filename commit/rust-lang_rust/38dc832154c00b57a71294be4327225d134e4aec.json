{"sha": "38dc832154c00b57a71294be4327225d134e4aec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZGM4MzIxNTRjMDBiNTdhNzEyOTRiZTQzMjcyMjVkMTM0ZTRhZWM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-11T01:47:32Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-11T22:51:09Z"}, "message": "Fix another default method ICE in type_use. Closes #7675.\n\nAlso reworks a bunch of type_use to make things work for default\nstatic methods soon.", "tree": {"sha": "56116c9de3a311ff08d8011243e3bde207258eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56116c9de3a311ff08d8011243e3bde207258eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38dc832154c00b57a71294be4327225d134e4aec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38dc832154c00b57a71294be4327225d134e4aec", "html_url": "https://github.com/rust-lang/rust/commit/38dc832154c00b57a71294be4327225d134e4aec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38dc832154c00b57a71294be4327225d134e4aec/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8e4301a5d78409ae05669be3514e848316e48f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e4301a5d78409ae05669be3514e848316e48f8", "html_url": "https://github.com/rust-lang/rust/commit/a8e4301a5d78409ae05669be3514e848316e48f8"}], "stats": {"total": 59, "additions": 39, "deletions": 20}, "files": [{"sha": "505353bc535a5dab9c5f42ec5ca790169ccd2c94", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/38dc832154c00b57a71294be4327225d134e4aec/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38dc832154c00b57a71294be4327225d134e4aec/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=38dc832154c00b57a71294be4327225d134e4aec", "patch": "@@ -49,6 +49,8 @@ pub type type_uses = uint; // Bitmask\n pub static use_repr: uint = 1;   /* Dependency on size/alignment/mode and\n                                      take/drop glue */\n pub static use_tydesc: uint = 2; /* Takes the tydesc, or compares */\n+pub static use_all: uint = use_repr|use_tydesc;\n+\n \n pub struct Context {\n     ccx: @mut CrateContext,\n@@ -57,6 +59,14 @@ pub struct Context {\n \n pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     -> @~[type_uses] {\n+\n+    fn store_type_uses(cx: Context, fn_id: def_id) -> @~[type_uses] {\n+        let Context { uses, ccx } = cx;\n+        let uses = @copy *uses; // freeze\n+        ccx.type_use_cache.insert(fn_id, uses);\n+        uses\n+    }\n+\n     match ccx.type_use_cache.find(&fn_id) {\n       Some(uses) => return *uses,\n       None => ()\n@@ -69,28 +79,25 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     };\n \n     // Conservatively assume full use for recursive loops\n-    ccx.type_use_cache.insert(fn_id, @vec::from_elem(n_tps, 3u));\n+    ccx.type_use_cache.insert(fn_id, @vec::from_elem(n_tps, use_all));\n \n     let cx = Context {\n         ccx: ccx,\n         uses: @mut vec::from_elem(n_tps, 0)\n     };\n-    match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n-        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n-        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-            for sig.inputs.iter().advance |arg| {\n-                type_needs(&cx, use_repr, *arg);\n-            }\n-        }\n-        _ => ()\n-    }\n \n-    if fn_id_loc.crate != local_crate {\n-        let Context { uses, _ } = cx;\n-        let uses = @copy *uses; // freeze\n-        ccx.type_use_cache.insert(fn_id, uses);\n-        return uses;\n+    // If the method is a default method, we mark all of the types as\n+    // used.  This is imprecise, but simple. Getting it right is\n+    // tricky because the substs on the call and the substs on the\n+    // default method differ, because of substs on the trait/impl.\n+    let is_default = ccx.tcx.provided_method_sources.contains_key(&fn_id_loc);\n+    // We also mark all of the params as used if it is an extern thing\n+    // that we haven't been able to inline yet.\n+    if is_default || fn_id_loc.crate != local_crate {\n+        for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_all; }\n+        return store_type_uses(cx, fn_id);\n     }\n+\n     let map_node = match ccx.tcx.items.find(&fn_id_loc.node) {\n         Some(x) => (/*bad*/copy *x),\n         None    => ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n@@ -106,7 +113,10 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n         // This will be a static trait method. For now, we just assume\n         // it fully depends on all of the type information. (Doing\n         // otherwise would require finding the actual implementation).\n-        for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_repr|use_tydesc;}\n+        for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_all;}\n+        // We need to return early, before the arguments are processed,\n+        // because of difficulties in the handling of Self.\n+        return store_type_uses(cx, fn_id);\n       }\n       ast_map::node_variant(_, _, _) => {\n         for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_repr;}\n@@ -171,10 +181,19 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                                 token::get_ident_interner())));\n       }\n     }\n-    let Context { uses, _ } = cx;\n-    let uses = @copy *uses; // freeze\n-    ccx.type_use_cache.insert(fn_id, uses);\n-    uses\n+\n+    // Now handle arguments\n+    match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n+        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n+        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n+            for sig.inputs.iter().advance |arg| {\n+                type_needs(&cx, use_repr, *arg);\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    store_type_uses(cx, fn_id)\n }\n \n pub fn type_needs(cx: &Context, use_: uint, ty: ty::t) {"}]}