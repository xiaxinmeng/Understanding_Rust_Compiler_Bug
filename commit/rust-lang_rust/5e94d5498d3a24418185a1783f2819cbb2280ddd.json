{"sha": "5e94d5498d3a24418185a1783f2819cbb2280ddd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOTRkNTQ5OGQzYTI0NDE4MTg1YTE3ODNmMjgxOWNiYjIyODBkZGQ=", "commit": {"author": {"name": "Joshua Barretto", "email": "barry.of.smith@gmail.com", "date": "2018-04-05T19:59:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-04-05T19:59:32Z"}, "message": "Merge pull request #1 from rust-lang/master\n\nMerge upstream changes", "tree": {"sha": "ad100bc79003d246837e5fc080b23f675d8c17c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad100bc79003d246837e5fc080b23f675d8c17c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e94d5498d3a24418185a1783f2819cbb2280ddd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaxoAkCRBK7hj4Ov3rIwAAdHIIAK/AzaKSUqNPytOEE017ScOr\naJYJZSYX9H8fEdXxexFJMNg6M3OOHSboC9GsfaiQY6HDJPz7+ujptgGYj7rTbDo7\nJQtBSbs6PHa1OzD73+pjTIa6LnGGuxThiLVxCiq8YoGn921OdtkQG0qwUUVbSOwB\nz4ry+ba3mE0GHlhhtNkBy8QI5odE4/xS/S1ECKqCJbFU4UPehhWXEZzsxwDl6pck\nCtfelZbJ0+pvvmJZ5m0rndvcWhszna+ENo2TNwMpdx4jRN4fW1tspxAFXdGUI/Rw\nolbCjEKaO5OSGlyhuvTQxCqMe2HnXPtrTS/3Wt/xDyBGfavSWXazzYyN7dYE8m4=\n=1Cgc\n-----END PGP SIGNATURE-----\n", "payload": "tree ad100bc79003d246837e5fc080b23f675d8c17c6\nparent 446285e45c02f71392c7084328dc167d2e1ff58c\nparent 7222241e7c2d7caf9ad6ee6e34748e4addfb8dd3\nauthor Joshua Barretto <barry.of.smith@gmail.com> 1522958372 +0100\ncommitter GitHub <noreply@github.com> 1522958372 +0100\n\nMerge pull request #1 from rust-lang/master\n\nMerge upstream changes"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e94d5498d3a24418185a1783f2819cbb2280ddd", "html_url": "https://github.com/rust-lang/rust/commit/5e94d5498d3a24418185a1783f2819cbb2280ddd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e94d5498d3a24418185a1783f2819cbb2280ddd/comments", "author": {"login": "zesterer", "id": 3268430, "node_id": "MDQ6VXNlcjMyNjg0MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/3268430?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zesterer", "html_url": "https://github.com/zesterer", "followers_url": "https://api.github.com/users/zesterer/followers", "following_url": "https://api.github.com/users/zesterer/following{/other_user}", "gists_url": "https://api.github.com/users/zesterer/gists{/gist_id}", "starred_url": "https://api.github.com/users/zesterer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zesterer/subscriptions", "organizations_url": "https://api.github.com/users/zesterer/orgs", "repos_url": "https://api.github.com/users/zesterer/repos", "events_url": "https://api.github.com/users/zesterer/events{/privacy}", "received_events_url": "https://api.github.com/users/zesterer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "446285e45c02f71392c7084328dc167d2e1ff58c", "url": "https://api.github.com/repos/rust-lang/rust/commits/446285e45c02f71392c7084328dc167d2e1ff58c", "html_url": "https://github.com/rust-lang/rust/commit/446285e45c02f71392c7084328dc167d2e1ff58c"}, {"sha": "7222241e7c2d7caf9ad6ee6e34748e4addfb8dd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7222241e7c2d7caf9ad6ee6e34748e4addfb8dd3", "html_url": "https://github.com/rust-lang/rust/commit/7222241e7c2d7caf9ad6ee6e34748e4addfb8dd3"}], "stats": {"total": 31606, "additions": 19137, "deletions": 12469}, "files": [{"sha": "36329ab91143c46e116609163e843124e5998e79", "filename": ".travis.yml", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -30,7 +30,6 @@ matrix:\n         SRC=.\n         DEPLOY_ALT=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n@@ -50,7 +49,6 @@ matrix:\n         RUST_CONFIGURE_ARGS=\"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler\"\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.8\n         MACOSX_STD_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n@@ -64,7 +62,6 @@ matrix:\n         RUST_CONFIGURE_ARGS=--build=i686-apple-darwin\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.8\n         MACOSX_STD_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n@@ -85,7 +82,6 @@ matrix:\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n@@ -99,7 +95,6 @@ matrix:\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n@@ -176,14 +171,11 @@ matrix:\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-distcheck\n       if: branch = auto\n-    - env: IMAGE=x86_64-gnu-incremental\n-      if: branch = auto\n \n     - stage: publish toolstate\n       if: branch = master AND type = push\n       before_install: []\n       install: []\n-      cache: false\n       sudo: false\n       script:\n         MESSAGE_FILE=$(mktemp -t msg.XXXXXX);\n@@ -201,7 +193,12 @@ env:\n     - secure: \"cFh8thThqEJLC98XKI5pfqflUzOlxsYPRW20AWRaYOOgYHPTiGWypTXiPbGSKaeAXTZoOA+DpQtEmefc0U6lt9dHc7a/MIaK6isFurjlnKYiLOeTruzyu1z7PWCeZ/jKXsU2RK/88DBtlNwfMdaMIeuKj14IVfpepPPL71ETbuk=\"\n \n before_install:\n-  - zcat $HOME/docker/rust-ci.tar.gz | docker load || true\n+  # We'll use the AWS cli to download/upload cached docker layers, so install\n+  # that here.\n+  - if [ \"$TRAVIS_OS_NAME\" = linux ]; then\n+      pip install --user awscli;\n+      export PATH=$PATH:$HOME/.local/bin;\n+    fi\n   - mkdir -p $HOME/rustsrc\n   # FIXME(#46924): these two commands are required to enable IPv6,\n   # they shouldn't exist, please revert once more official solutions appeared.\n@@ -223,7 +220,7 @@ install:\n             travis_retry brew update &&\n             travis_retry brew install xz;\n           fi &&\n-          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-apple-darwin &&\n+          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin &&\n             chmod +x /usr/local/bin/sccache &&\n           travis_retry curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n             chmod +x /usr/local/bin/stamp\n@@ -264,12 +261,6 @@ after_failure:\n       df -h;\n       du . | sort -nr | head -n100\n \n-  # One of these is the linux sccache log, one is the OSX sccache log. Instead\n-  # of worrying about what system we are just cat both. One of these commands\n-  # will fail but that's ok, they'll both get executed.\n-  - cat obj/tmp/sccache.log\n-  - cat /tmp/sccache.log\n-\n   # Random attempt at debugging currently. Just poking around in here to see if\n   # anything shows up.\n   - ls -lat $HOME/Library/Logs/DiagnosticReports/\n@@ -286,23 +277,9 @@ after_failure:\n   # it happened\n   - dmesg | grep -i kill\n \n-# Save tagged docker images we created and load them if they're available\n-# Travis saves caches whether the build failed or not, nuke rustsrc if\n-# the failure was while updating it (as it may be in a bad state)\n-# https://github.com/travis-ci/travis-ci/issues/4472\n-before_cache:\n-  - docker history -q rust-ci |\n-    grep -v missing |\n-    xargs docker save |\n-    gzip > $HOME/docker/rust-ci.tar.gz\n-\n notifications:\n   email: false\n \n-cache:\n-  directories:\n-    - $HOME/docker\n-\n before_deploy:\n   - mkdir -p deploy/$TRAVIS_COMMIT\n   - >"}, {"sha": "7a62405f059677affac001298e8f5fd2f9dbe515", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -594,7 +594,7 @@ If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n [inom]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-nominated\n [eeasy]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy\n [lru]: https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-asc\n-[rfcbot]: https://github.com/dikaiosune/rust-dashboard/blob/master/RFCBOT.md\n+[rfcbot]: https://github.com/anp/rfcbot-rs/\n \n ## Out-of-tree Contributions\n [out-of-tree-contributions]: #out-of-tree-contributions"}, {"sha": "39cef1e2a57703a9a2b95cf70f9909a4d7dc9699", "filename": "RELEASES.md", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1,3 +1,115 @@\n+Version 1.25.0 (2018-03-29)\n+==========================\n+\n+Language\n+--------\n+- [Stabilised `#[repr(align(x))]`.][47006] [RFC 1358]\n+- [You can now use nested groups of imports.][47948]\n+  e.g. `use std::{fs::File, io::Read, path::{Path, PathBuf}};`\n+- [You can now have `|` at the start of a match arm.][47947] e.g.\n+```rust\n+enum Foo { A, B, C }\n+\n+fn main() {\n+    let x = Foo::A;\n+    match x {\n+        | Foo::A\n+        | Foo::B => println!(\"AB\"),\n+        | Foo::C => println!(\"C\"),\n+    }\n+}\n+```\n+\n+Compiler\n+--------\n+- [Upgraded to LLVM 6.][47828]\n+- [Added `-C lto=val` option.][47521]\n+- [Added `i586-unknown-linux-musl` target][47282]\n+\n+Libraries\n+---------\n+- [Impl Send for `process::Command` on Unix.][47760]\n+- [Impl PartialEq and Eq for `ParseCharError`.][47790]\n+- [`UnsafeCell::into_inner` is now safe.][47204]\n+- [Implement libstd for CloudABI.][47268]\n+- [`Float::{from_bits, to_bits}` is now available in libcore.][46931]\n+- [Implement `AsRef<Path>` for Component][46985]\n+- [Implemented `Write` for `Cursor<&mut Vec<u8>>`][46830]\n+- [Moved `Duration` to libcore.][46666]\n+\n+Stabilized APIs\n+---------------\n+- [`Location::column`]\n+- [`ptr::NonNull`]\n+\n+The following functions can now be used in a constant expression.\n+eg. `static MINUTE: Duration = Duration::from_secs(60);`\n+- [`Duration::new`][47300]\n+- [`Duration::from_secs`][47300]\n+- [`Duration::from_millis`][47300]\n+\n+Cargo\n+-----\n+- [`cargo new` no longer removes `rust` or `rs` prefixs/suffixs.][cargo/5013]\n+- [`cargo new` now defaults to creating a binary crate, instead of a\n+  library crate.][cargo/5029]\n+\n+Misc\n+----\n+- [Rust by example is now shipped with new releases][46196]\n+\n+Compatibility Notes\n+-------------------\n+- [Deprecated `net::lookup_host`.][47510]\n+- [`rustdoc` has switched to pulldown as the default markdown renderer.][47398]\n+- The borrow checker was sometimes incorrectly permitting overlapping borrows\n+  around indexing operations (see [#47349][47349]). This has been fixed (which also\n+  enabled some correct code that used to cause errors (e.g. [#33903][33903] and [#46095][46095]).\n+- [Removed deprecated unstable attribute `#[simd]`.][47251]\n+\n+[33903]: https://github.com/rust-lang/rust/pull/33903\n+[47947]: https://github.com/rust-lang/rust/pull/47947\n+[47948]: https://github.com/rust-lang/rust/pull/47948\n+[47760]: https://github.com/rust-lang/rust/pull/47760\n+[47790]: https://github.com/rust-lang/rust/pull/47790\n+[47828]: https://github.com/rust-lang/rust/pull/47828\n+[47398]: https://github.com/rust-lang/rust/pull/47398\n+[47510]: https://github.com/rust-lang/rust/pull/47510\n+[47521]: https://github.com/rust-lang/rust/pull/47521\n+[47204]: https://github.com/rust-lang/rust/pull/47204\n+[47251]: https://github.com/rust-lang/rust/pull/47251\n+[47268]: https://github.com/rust-lang/rust/pull/47268\n+[47282]: https://github.com/rust-lang/rust/pull/47282\n+[47300]: https://github.com/rust-lang/rust/pull/47300\n+[47349]: https://github.com/rust-lang/rust/pull/47349\n+[46931]: https://github.com/rust-lang/rust/pull/46931\n+[46985]: https://github.com/rust-lang/rust/pull/46985\n+[47006]: https://github.com/rust-lang/rust/pull/47006\n+[46830]: https://github.com/rust-lang/rust/pull/46830\n+[46095]: https://github.com/rust-lang/rust/pull/46095\n+[46666]: https://github.com/rust-lang/rust/pull/46666\n+[46196]: https://github.com/rust-lang/rust/pull/46196\n+[cargo/5013]: https://github.com/rust-lang/cargo/pull/5013\n+[cargo/5029]: https://github.com/rust-lang/cargo/pull/5029\n+[RFC 1358]: https://github.com/rust-lang/rfcs/pull/1358\n+[`Location::column`]: https://doc.rust-lang.org/std/panic/struct.Location.html#method.column\n+[`ptr::NonNull`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html\n+\n+\n+Version 1.24.1 (2018-03-01)\n+==========================\n+\n+ - [Do not abort when unwinding through FFI][48251]\n+ - [Emit UTF-16 files for linker arguments on Windows][48318]\n+ - [Make the error index generator work again][48308]\n+ - [Cargo will warn on Windows 7 if an update is needed][cargo/5069].\n+\n+[48251]: https://github.com/rust-lang/rust/issues/48251\n+[48308]: https://github.com/rust-lang/rust/issues/48308\n+[48318]: https://github.com/rust-lang/rust/issues/48318\n+[cargo/5069]: https://github.com/rust-lang/cargo/pull/5069\n+\n+\n Version 1.24.0 (2018-02-15)\n ==========================\n "}, {"sha": "09c6fca5d02afc8f3f46bf8b4ea46eb5c9f2a958", "filename": "appveyor.yml", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -20,10 +20,10 @@ environment:\n     SCRIPT: python x.py test\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    SCRIPT: python x.py test --exclude src/test/run-pass --exclude src/test/compile-fail\n+    SCRIPT: make appveyor-subset-1\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    SCRIPT: python x.py test src/test/run-pass src/test/compile-fail\n+    SCRIPT: make appveyor-subset-2\n \n   # MSVC aux tests\n   - MSYS_BITS: 64\n@@ -53,13 +53,13 @@ environment:\n   # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: python x.py test --exclude src/test/run-pass --exclude src/test/compile-fail\n+    SCRIPT: make appveyor-subset-1\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: python x.py test src/test/run-pass src/test/compile-fail\n+    SCRIPT: make appveyor-subset-2\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n@@ -152,8 +152,8 @@ install:\n   - set PATH=C:\\Python27;%PATH%\n \n   # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-pc-windows-msvc\n-  - mv 2017-05-12-sccache-x86_64-pc-windows-msvc sccache.exe\n+  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-pc-windows-msvc\n+  - mv 2018-04-02-sccache-x86_64-pc-windows-msvc sccache.exe\n   - set PATH=%PATH%;%CD%\n \n   # Download and install ninja\n@@ -176,19 +176,13 @@ install:\n   - set PATH=%PATH%;%CD%\\handle\n   - handle.exe -accepteula -help\n \n-  # Attempt to debug sccache failures\n-  - set SCCACHE_ERROR_LOG=%CD%/sccache.log\n-\n test_script:\n   - if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n   - sh src/ci/init_repo.sh . /c/cache/rustsrc\n   - set SRC=.\n   - set NO_CCACHE=1\n   - sh src/ci/run.sh\n \n-on_failure:\n-  - cat %CD%\\sccache.log || exit 0\n-\n branches:\n   only:\n     - auto"}, {"sha": "9dd3002506e41cbe333d4cc8051dcf9d62071eb7", "filename": "config.toml.example", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -186,6 +186,10 @@\n # essentially skipping stage0 as the local compiler is recompiling itself again.\n #local-rebuild = false\n \n+# Print out how long each rustbuild step took (mostly intended for CI and\n+# tracking over time)\n+#print-step-timings = false\n+\n # =============================================================================\n # General install configuration options\n # =============================================================================\n@@ -267,6 +271,9 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n+# Build rustc with experimental parallelization\n+#experimental-parallel-queries = false\n+\n # The default linker that will be hard-coded into the generated compiler for\n # targets that don't specify linker explicitly in their target specifications.\n # Note that this is not the linker used to link said compiler."}, {"sha": "2f77d4125ab0e758cdd34e7e7111debcec200613", "filename": "src/Cargo.lock", "status": "modified", "additions": 428, "deletions": 446, "changes": 874, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "2f9c4e148a6bad72cc2c5be24ad9ae0a976122ea", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -42,3 +42,7 @@ serde_json = \"1.0.2\"\n toml = \"0.4\"\n lazy_static = \"0.2\"\n time = \"0.1\"\n+petgraph = \"0.4.12\"\n+\n+[dev-dependencies]\n+pretty_assertions = \"0.5\""}, {"sha": "6701f58ba8e92593589679caf6772aeb6c1d9395", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -31,9 +31,11 @@ extern crate bootstrap;\n \n use std::env;\n use std::ffi::OsString;\n-use std::str::FromStr;\n+use std::io;\n use std::path::PathBuf;\n-use std::process::{Command, ExitStatus};\n+use std::process::Command;\n+use std::str::FromStr;\n+use std::time::Instant;\n \n fn main() {\n     let mut args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -90,7 +92,7 @@ fn main() {\n     };\n     let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n-    let mut on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(|of| Command::new(of));\n+    let on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(|of| Command::new(of));\n \n     let rustc = env::var_os(rustc).unwrap_or_else(|| panic!(\"{:?} was not set\", rustc));\n     let libdir = env::var_os(libdir).unwrap_or_else(|| panic!(\"{:?} was not set\", libdir));\n@@ -103,6 +105,7 @@ fn main() {\n         .arg(format!(\"stage{}\", stage))\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n+    let mut maybe_crate = None;\n \n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n@@ -134,6 +137,7 @@ fn main() {\n             .find(|a| &*a[0] == \"--crate-name\")\n             .unwrap();\n         let crate_name = &*crate_name[1];\n+        maybe_crate = Some(crate_name);\n \n         // If we're compiling specifically the `panic_abort` crate then we pass\n         // the `-C panic=abort` option. Note that we do not do this for any\n@@ -281,31 +285,52 @@ fn main() {\n         eprintln!(\"libdir: {:?}\", libdir);\n     }\n \n-    // Actually run the compiler!\n-    std::process::exit(if let Some(ref mut on_fail) = on_fail {\n-        match cmd.status() {\n-            Ok(s) if s.success() => 0,\n-            _ => {\n-                println!(\"\\nDid not run successfully:\\n{:?}\\n-------------\", cmd);\n-                exec_cmd(on_fail).expect(\"could not run the backup command\");\n-                1\n+    if let Some(mut on_fail) = on_fail {\n+        let e = match cmd.status() {\n+            Ok(s) if s.success() => std::process::exit(0),\n+            e => e,\n+        };\n+        println!(\"\\nDid not run successfully: {:?}\\n{:?}\\n-------------\", e, cmd);\n+        exec_cmd(&mut on_fail).expect(\"could not run the backup command\");\n+        std::process::exit(1);\n+    }\n+\n+    if env::var_os(\"RUSTC_PRINT_STEP_TIMINGS\").is_some() {\n+        if let Some(krate) = maybe_crate {\n+            let start = Instant::now();\n+            let status = cmd\n+                .status()\n+                .expect(&format!(\"\\n\\n failed to run {:?}\", cmd));\n+            let dur = start.elapsed();\n+\n+            let is_test = args.iter().any(|a| a == \"--test\");\n+            eprintln!(\"[RUSTC-TIMING] {} test:{} {}.{:03}\",\n+                      krate.to_string_lossy(),\n+                      is_test,\n+                      dur.as_secs(),\n+                      dur.subsec_nanos() / 1_000_000);\n+\n+            match status.code() {\n+                Some(i) => std::process::exit(i),\n+                None => {\n+                    eprintln!(\"rustc exited with {}\", status);\n+                    std::process::exit(0xfe);\n+                }\n             }\n         }\n-    } else {\n-        std::process::exit(match exec_cmd(&mut cmd) {\n-            Ok(s) => s.code().unwrap_or(0xfe),\n-            Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n-        })\n-    })\n+    }\n+\n+    let code = exec_cmd(&mut cmd).expect(&format!(\"\\n\\n failed to run {:?}\", cmd));\n+    std::process::exit(code);\n }\n \n #[cfg(unix)]\n-fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n+fn exec_cmd(cmd: &mut Command) -> io::Result<i32> {\n     use std::os::unix::process::CommandExt;\n     Err(cmd.exec())\n }\n \n #[cfg(not(unix))]\n-fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n-    cmd.status()\n+fn exec_cmd(cmd: &mut Command) -> io::Result<i32> {\n+    cmd.status().map(|status| status.code().unwrap())\n }"}, {"sha": "cf54591f25cd576cd62fa204f939a95bfec1d40e", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -314,7 +314,7 @@ def __init__(self):\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n         self.clean = False\n         self.config_toml = ''\n-        self.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n+        self.rust_root = ''\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n         self.verbose = False\n@@ -647,7 +647,7 @@ def update_submodules(self):\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\":\n             return\n-        slow_submodules = self.get_toml('fast-submodule') == \"false\"\n+        slow_submodules = self.get_toml('fast-submodules') == \"false\"\n         start_time = time()\n         if slow_submodules:\n             print('Unconditionally updating all submodules')\n@@ -710,6 +710,7 @@ def bootstrap(help_triggered):\n     parser = argparse.ArgumentParser(description='Build rust')\n     parser.add_argument('--config')\n     parser.add_argument('--build')\n+    parser.add_argument('--src')\n     parser.add_argument('--clean', action='store_true')\n     parser.add_argument('-v', '--verbose', action='count', default=0)\n \n@@ -718,6 +719,7 @@ def bootstrap(help_triggered):\n \n     # Configure initial bootstrap\n     build = RustBuild()\n+    build.rust_root = args.src or os.path.abspath(os.path.join(__file__, '../../..'))\n     build.verbose = args.verbose\n     build.clean = args.clean\n \n@@ -788,6 +790,7 @@ def bootstrap(help_triggered):\n     env[\"SRC\"] = build.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n+    env[\"BUILD_DIR\"] = build.build_dir\n     run(args, env=env, verbose=build.verbose)\n \n "}, {"sha": "3f5ec4933d02b23d31469b3ea022b46fb1f0b323", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 578, "deletions": 20, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::any::Any;\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n use std::env;\n use std::fmt::Debug;\n@@ -18,6 +18,8 @@ use std::hash::Hash;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::time::{Instant, Duration};\n+use std::collections::HashMap;\n \n use compile;\n use install;\n@@ -34,12 +36,20 @@ use native;\n \n pub use Compiler;\n \n+use petgraph::Graph;\n+use petgraph::graph::NodeIndex;\n+\n pub struct Builder<'a> {\n     pub build: &'a Build,\n     pub top_stage: u32,\n     pub kind: Kind,\n     cache: Cache,\n     stack: RefCell<Vec<Box<Any>>>,\n+    time_spent_on_dependencies: Cell<Duration>,\n+    pub paths: Vec<PathBuf>,\n+    graph_nodes: RefCell<HashMap<String, NodeIndex>>,\n+    graph: RefCell<Graph<String, bool>>,\n+    parent: Cell<Option<NodeIndex>>,\n }\n \n impl<'a> Deref for Builder<'a> {\n@@ -308,19 +318,24 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps, test::RunPassFullDeps, test::RunFailFullDeps,\n                 test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n                 test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n-                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty, test::RunMake,\n+                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty,\n                 test::Crate, test::CrateLibrustc, test::CrateRustdoc, test::Linkcheck,\n                 test::Cargotest, test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n+                test::RunMakeFullDeps,\n                 test::Nomicon, test::Reference, test::RustdocBook, test::RustByExample,\n                 test::TheBook, test::UnstableBook,\n-                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme),\n+                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme,\n+                // Run run-make last, since these won't pass without make on Windows\n+                test::RunMake),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n-                doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n-                doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n-            Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n-                dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n-                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign),\n+                doc::Standalone, doc::Std, doc::Test, doc::WhitelistedRustc, doc::Rustc,\n+                doc::ErrorIndex, doc::Nomicon, doc::Reference, doc::Rustdoc, doc::RustByExample,\n+                doc::CargoBook),\n+            Kind::Dist => describe!(dist::Docs, dist::RustcDocs, dist::Mingw, dist::Rustc,\n+                dist::DebuggerScripts, dist::Std, dist::Analysis, dist::Src,\n+                dist::PlainSourceTarball, dist::Cargo, dist::Rls, dist::Rustfmt, dist::Extended,\n+                dist::HashSign),\n             Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n                 install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n         }\n@@ -343,6 +358,11 @@ impl<'a> Builder<'a> {\n             kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n+            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths: vec![],\n+            graph_nodes: RefCell::new(HashMap::new()),\n+            graph: RefCell::new(Graph::new()),\n+            parent: Cell::new(None),\n         };\n \n         let builder = &builder;\n@@ -359,7 +379,7 @@ impl<'a> Builder<'a> {\n         Some(help)\n     }\n \n-    pub fn run(build: &Build) {\n+    pub fn new(build: &Build) -> Builder {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n@@ -371,32 +391,40 @@ impl<'a> Builder<'a> {\n             Subcommand::Clean { .. } => panic!(),\n         };\n \n-        if let Some(path) = paths.get(0) {\n-            if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n-                return;\n-            }\n-        }\n-\n         let builder = Builder {\n             build,\n             top_stage: build.config.stage.unwrap_or(2),\n             kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n+            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths: paths.to_owned(),\n+            graph_nodes: RefCell::new(HashMap::new()),\n+            graph: RefCell::new(Graph::new()),\n+            parent: Cell::new(None),\n         };\n \n         if kind == Kind::Dist {\n-            assert!(!build.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n+            assert!(!builder.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n                 The distributed libraries would include all MIR (increasing binary size).\n                 The distributed MIR would include validation statements.\");\n         }\n \n-        StepDescription::run(&Builder::get_step_descriptions(builder.kind), &builder, paths);\n+        builder\n+    }\n+\n+    pub fn execute_cli(&self) -> Graph<String, bool> {\n+        self.run_step_descriptions(&Builder::get_step_descriptions(self.kind), &self.paths);\n+        self.graph.borrow().clone()\n     }\n \n     pub fn default_doc(&self, paths: Option<&[PathBuf]>) {\n         let paths = paths.unwrap_or(&[]);\n-        StepDescription::run(&Builder::get_step_descriptions(Kind::Doc), self, paths);\n+        self.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), paths);\n+    }\n+\n+    fn run_step_descriptions(&self, v: &[StepDescription], paths: &[PathBuf]) {\n+        StepDescription::run(v, self, paths);\n     }\n \n     /// Obtain a compiler at a given stage and for a given host. Explicitly does\n@@ -546,7 +574,9 @@ impl<'a> Builder<'a> {\n         let mut extra_args = env::var(&format!(\"RUSTFLAGS_STAGE_{}\", stage)).unwrap_or_default();\n         if stage != 0 {\n             let s = env::var(\"RUSTFLAGS_STAGE_NOT_0\").unwrap_or_default();\n-            extra_args.push_str(\" \");\n+            if !extra_args.is_empty() {\n+                extra_args.push_str(\" \");\n+            }\n             extra_args.push_str(&s);\n         }\n \n@@ -662,6 +692,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n         }\n \n+        if self.config.print_step_timings {\n+            cargo.env(\"RUSTC_PRINT_STEP_TIMINGS\", \"1\");\n+        }\n+\n         cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n         // Throughout the build Cargo can execute a number of build scripts\n@@ -813,12 +847,56 @@ impl<'a> Builder<'a> {\n             if let Some(out) = self.cache.get(&step) {\n                 self.build.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n \n+                {\n+                    let mut graph = self.graph.borrow_mut();\n+                    let parent = self.parent.get();\n+                    let us = *self.graph_nodes.borrow_mut()\n+                        .entry(format!(\"{:?}\", step))\n+                        .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n+                    if let Some(parent) = parent {\n+                        graph.add_edge(parent, us, false);\n+                    }\n+                }\n+\n                 return out;\n             }\n             self.build.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n             stack.push(Box::new(step.clone()));\n         }\n-        let out = step.clone().run(self);\n+\n+        let prev_parent = self.parent.get();\n+\n+        {\n+            let mut graph = self.graph.borrow_mut();\n+            let parent = self.parent.get();\n+            let us = *self.graph_nodes.borrow_mut()\n+                .entry(format!(\"{:?}\", step))\n+                .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n+            self.parent.set(Some(us));\n+            if let Some(parent) = parent {\n+                graph.add_edge(parent, us, true);\n+            }\n+        }\n+\n+        let (out, dur) = {\n+            let start = Instant::now();\n+            let zero = Duration::new(0, 0);\n+            let parent = self.time_spent_on_dependencies.replace(zero);\n+            let out = step.clone().run(self);\n+            let dur = start.elapsed();\n+            let deps = self.time_spent_on_dependencies.replace(parent + dur);\n+            (out, dur - deps)\n+        };\n+\n+        self.parent.set(prev_parent);\n+\n+        if self.build.config.print_step_timings && dur > Duration::from_millis(100) {\n+            println!(\"[TIMING] {:?} -- {}.{:03}\",\n+                     step,\n+                     dur.as_secs(),\n+                     dur.subsec_nanos() / 1_000_000);\n+        }\n+\n         {\n             let mut stack = self.stack.borrow_mut();\n             let cur_step = stack.pop().expect(\"step stack empty\");\n@@ -829,3 +907,483 @@ impl<'a> Builder<'a> {\n         out\n     }\n }\n+\n+#[cfg(test)]\n+mod __test {\n+    use config::Config;\n+    use std::thread;\n+    use super::*;\n+\n+    fn configure(host: &[&str], target: &[&str]) -> Config {\n+        let mut config = Config::default_opts();\n+        // don't save toolstates\n+        config.save_toolstates = None;\n+        config.run_host_only = true;\n+        config.dry_run = true;\n+        // try to avoid spurious failures in dist where we create/delete each others file\n+        let dir = config.out.join(\"tmp-rustbuild-tests\")\n+            .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n+        t!(fs::create_dir_all(&dir));\n+        config.out = dir;\n+        config.build = INTERNER.intern_str(\"A\");\n+        config.hosts = vec![config.build].clone().into_iter()\n+            .chain(host.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n+        config.targets = config.hosts.clone().into_iter()\n+            .chain(target.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n+        config\n+    }\n+\n+    fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n+        v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n+    }\n+\n+    #[test]\n+    fn dist_baseline() {\n+        let build = Build::new(configure(&[], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_targets() {\n+        let build = Build::new(configure(&[], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+            dist::Docs { stage: 2, host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.run_host_only = false; // as-if --target=C was passed\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+            dist::Docs { stage: 2, host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+    }\n+\n+    #[test]\n+    fn dist_with_same_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(builder.cache.all::<compile::Std>()), &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]);\n+    }\n+\n+    #[test]\n+    fn build_default() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert!(!builder.cache.all::<compile::Std>().is_empty());\n+        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+    }\n+\n+    #[test]\n+    fn build_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.run_host_only = false;\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert!(!builder.cache.all::<compile::Std>().is_empty());\n+        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]);\n+\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+    }\n+}"}, {"sha": "d81c6bc28e52705f06c463ad55b0b137eb7fa2e6", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -21,6 +21,7 @@ use std::mem;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n+use std::cmp::{PartialOrd, Ord, Ordering};\n \n use builder::Step;\n \n@@ -154,6 +155,19 @@ impl AsRef<OsStr> for Interned<String> {\n     }\n }\n \n+impl PartialOrd<Interned<String>> for Interned<String> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).partial_cmp(l.get(*other))\n+    }\n+}\n+\n+impl Ord for Interned<String> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).cmp(l.get(*other))\n+    }\n+}\n \n struct TyIntern<T> {\n     items: Vec<T>,\n@@ -264,4 +278,16 @@ impl Cache {\n                         .expect(\"invalid type mapped\");\n         stepcache.get(step).cloned()\n     }\n+\n+    #[cfg(test)]\n+    pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n+        let cache = self.0.get_mut();\n+        let type_id = TypeId::of::<S>();\n+        let mut v = cache.remove(&type_id)\n+            .map(|b| b.downcast::<HashMap<S, S::Output>>().expect(\"correct type\"))\n+            .map(|m| m.into_iter().collect::<Vec<_>>())\n+            .unwrap_or_default();\n+        v.sort_by_key(|&(a, _)| a);\n+        v\n+    }\n }"}, {"sha": "3453933a9652c0881188919706c5db4799ab43e2", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -24,7 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.26.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.27.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "a39fad67ebea4ac967bffe828dd8d39c7375b624", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -40,19 +40,20 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = builder.compiler(0, build.build);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n-\n         let out_dir = build.stage_out(compiler, Mode::Libstd);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n     }\n }\n \n@@ -86,21 +87,22 @@ impl Step for Rustc {\n         let compiler = builder.compiler(0, build.build);\n         let target = self.target;\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n-\n         let stage_out = builder.stage_out(compiler, Mode::Librustc);\n         build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n         build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n         rustc_cargo(build, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &librustc_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &librustc_stamp(build, compiler, target));\n     }\n }\n \n@@ -128,18 +130,20 @@ impl Step for Test {\n         let target = self.target;\n         let compiler = builder.compiler(0, build.build);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n         let out_dir = build.stage_out(compiler, Mode::Libtest);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"check\");\n         test_cargo(build, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &libtest_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &libtest_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libtest_stamp(build, compiler, target));\n     }\n }\n "}, {"sha": "9cc18464fea094668f1c716c74cffe340e233827", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 186, "deletions": 137, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -16,6 +16,7 @@\n //! compiler. This module is also responsible for assembling the sysroot as it\n //! goes along from the output of the previous stage.\n \n+use std::borrow::Cow;\n use std::env;\n use std::fs::{self, File};\n use std::io::BufReader;\n@@ -29,15 +30,15 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, copy, read_stamp_file, CiEnv};\n+use util::{exe, libdir, is_dylib, CiEnv};\n use {Build, Compiler, Mode};\n use native;\n use tool;\n \n use cache::{INTERNER, Interned};\n use builder::{Step, RunConfig, ShouldRun, Builder};\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n     pub target: Interned<String>,\n     pub compiler: Compiler,\n@@ -76,7 +77,7 @@ impl Step for Std {\n                 compiler: from,\n                 target,\n             });\n-            println!(\"Uplifting stage1 std ({} -> {})\", from.host, target);\n+            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", from.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the musl startup objects.\n@@ -93,19 +94,19 @@ impl Step for Std {\n             return;\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n-\n         if target.contains(\"musl\") {\n             let libdir = builder.sysroot_libdir(compiler, target);\n             copy_musl_third_party_objects(build, target, &libdir);\n         }\n \n-        let out_dir = build.stage_out(compiler, Mode::Libstd);\n+        let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        build.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),\n@@ -129,7 +130,7 @@ fn copy_musl_third_party_objects(build: &Build,\n                                  target: Interned<String>,\n                                  into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n+        build.copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n \n@@ -139,48 +140,58 @@ pub fn std_cargo(build: &Builder,\n                  compiler: &Compiler,\n                  target: Interned<String>,\n                  cargo: &mut Command) {\n-    let mut features = build.std_features();\n-\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n-    // When doing a local rebuild we tell cargo that we're stage1 rather than\n-    // stage0. This works fine if the local rust and being-built rust have the\n-    // same view of what the default allocator is, but fails otherwise. Since\n-    // we don't have a way to express an allocator preference yet, work\n-    // around the issue in the case of a local rebuild with jemalloc disabled.\n-    if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n-        features.push_str(\" force_alloc_system\");\n-    }\n+    if build.no_std(target) == Some(true) {\n+        // for no-std targets we only compile a few no_std crates\n+        cargo.arg(\"--features\").arg(\"c mem\")\n+            .args(&[\"-p\", \"alloc\"])\n+            .args(&[\"-p\", \"compiler_builtins\"])\n+            .args(&[\"-p\", \"std_unicode\"])\n+            .arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n+    } else {\n+        let mut features = build.std_features();\n+\n+        // When doing a local rebuild we tell cargo that we're stage1 rather than\n+        // stage0. This works fine if the local rust and being-built rust have the\n+        // same view of what the default allocator is, but fails otherwise. Since\n+        // we don't have a way to express an allocator preference yet, work\n+        // around the issue in the case of a local rebuild with jemalloc disabled.\n+        if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n+            features.push_str(\" force_alloc_system\");\n+        }\n \n-    if compiler.stage != 0 && build.config.sanitizers {\n-        // This variable is used by the sanitizer runtime crates, e.g.\n-        // rustc_lsan, to build the sanitizer runtime from C code\n-        // When this variable is missing, those crates won't compile the C code,\n-        // so we don't set this variable during stage0 where llvm-config is\n-        // missing\n-        // We also only build the runtimes when --enable-sanitizers (or its\n-        // config.toml equivalent) is used\n-        let llvm_config = build.ensure(native::Llvm {\n-            target: build.config.build,\n-            emscripten: false,\n-        });\n-        cargo.env(\"LLVM_CONFIG\", llvm_config);\n-    }\n+        if compiler.stage != 0 && build.config.sanitizers {\n+            // This variable is used by the sanitizer runtime crates, e.g.\n+            // rustc_lsan, to build the sanitizer runtime from C code\n+            // When this variable is missing, those crates won't compile the C code,\n+            // so we don't set this variable during stage0 where llvm-config is\n+            // missing\n+            // We also only build the runtimes when --enable-sanitizers (or its\n+            // config.toml equivalent) is used\n+            let llvm_config = build.ensure(native::Llvm {\n+                target: build.config.build,\n+                emscripten: false,\n+            });\n+            cargo.env(\"LLVM_CONFIG\", llvm_config);\n+        }\n \n-    cargo.arg(\"--features\").arg(features)\n-        .arg(\"--manifest-path\")\n-        .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n+        cargo.arg(\"--features\").arg(features)\n+            .arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n \n-    if let Some(target) = build.config.target_config.get(&target) {\n-        if let Some(ref jemalloc) = target.jemalloc {\n-            cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+        if let Some(target) = build.config.target_config.get(&target) {\n+            if let Some(ref jemalloc) = target.jemalloc {\n+                cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+            }\n         }\n-    }\n-    if target.contains(\"musl\") {\n-        if let Some(p) = build.musl_root(target) {\n-            cargo.env(\"MUSL_ROOT\", p);\n+        if target.contains(\"musl\") {\n+            if let Some(p) = build.musl_root(target) {\n+                cargo.env(\"MUSL_ROOT\", p);\n+            }\n         }\n     }\n }\n@@ -212,20 +223,20 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n-                target);\n+                target));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n \n         if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n             // be missing in stage0 and causes panic. See the `std()` function above\n             // for reason why the sanitizers are not built in stage0.\n-            copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n+            copy_apple_sanitizer_dylibs(&build, &build.native_dir(target), \"osx\", &libdir);\n         }\n \n         builder.ensure(tool::CleanTools {\n@@ -236,15 +247,15 @@ impl Step for StdLink {\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n+fn copy_apple_sanitizer_dylibs(build: &Build, native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n         src_path.push(\"build\");\n         src_path.push(\"lib\");\n         src_path.push(\"darwin\");\n         src_path.push(&filename);\n-        copy(&src_path, &into.join(filename));\n+        build.copy(&src_path, &into.join(filename));\n     }\n }\n \n@@ -300,23 +311,23 @@ impl Step for StartupObjects {\n                             .arg(src_file));\n             }\n \n-            copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            build.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n             let src = compiler_file(build,\n                                     build.cc(target),\n                                     target,\n                                     obj);\n-            copy(&src, &sysroot_dir.join(obj));\n+            build.copy(&src, &sysroot_dir.join(obj));\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Test {\n-    pub compiler: Compiler,\n     pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Test {\n@@ -351,7 +362,7 @@ impl Step for Test {\n                 compiler: builder.compiler(1, build.build),\n                 target,\n             });\n-            println!(\"Uplifting stage1 test ({} -> {})\", &build.build, target);\n+            build.info(&format!(\"Uplifting stage1 test ({} -> {})\", &build.build, target));\n             builder.ensure(TestLink {\n                 compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n@@ -360,13 +371,14 @@ impl Step for Test {\n             return;\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n-        let out_dir = build.stage_out(compiler, Mode::Libtest);\n+        let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n         test_cargo(build, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        build.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &libtest_stamp(build, compiler, target),\n@@ -412,13 +424,13 @@ impl Step for TestLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n-                target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n+                target));\n+        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n                     &libtest_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n@@ -428,10 +440,10 @@ impl Step for TestLink {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n-    pub compiler: Compiler,\n     pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Rustc {\n@@ -467,7 +479,7 @@ impl Step for Rustc {\n                 compiler: builder.compiler(1, build.build),\n                 target,\n             });\n-            println!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target);\n+            build.info(&format!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target));\n             builder.ensure(RustcLink {\n                 compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n@@ -481,17 +493,16 @@ impl Step for Rustc {\n             compiler: builder.compiler(self.compiler.stage, build.build),\n             target: build.build,\n         });\n-\n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        println!(\"Building stage{} compiler artifacts ({} -> {})\",\n-                 compiler.stage, &compiler.host, target);\n-\n-        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n-        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n-        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n+        let cargo_out = builder.cargo_out(compiler, Mode::Librustc, target);\n+        build.clear_if_dirty(&cargo_out, &libstd_stamp(build, compiler, target));\n+        build.clear_if_dirty(&cargo_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n         rustc_cargo(build, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        build.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n+                 compiler.stage, &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),\n@@ -568,13 +579,13 @@ impl Step for RustcLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n                  target_compiler.stage,\n                  compiler.stage,\n                  &compiler.host,\n                  target_compiler.host,\n-                 target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n+                 target));\n+        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n                        &librustc_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n@@ -634,8 +645,6 @@ impl Step for CodegenBackend {\n             .arg(build.src.join(\"src/librustc_trans/Cargo.toml\"));\n         rustc_cargo_env(build, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n-\n         match &*self.backend {\n             \"llvm\" | \"emscripten\" => {\n                 // Build LLVM for our target. This will implicitly build the\n@@ -649,8 +658,8 @@ impl Step for CodegenBackend {\n                     features.push_str(\" emscripten\");\n                 }\n \n-                println!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n-                         compiler.stage, &compiler.host, target, self.backend);\n+                build.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n+                         compiler.stage, &compiler.host, target, self.backend));\n \n                 // Pass down configuration from the LLVM build into the build of\n                 // librustc_llvm and librustc_trans.\n@@ -685,10 +694,15 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = build.cargo_out(compiler, Mode::Librustc, target)\n             .join(\".tmp.stamp\");\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n         let files = run_cargo(build,\n                               cargo.arg(\"--features\").arg(features),\n                               &tmp_stamp,\n                               false);\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let mut files = files.into_iter()\n             .filter(|f| {\n                 let filename = f.file_name().unwrap().to_str().unwrap();\n@@ -732,6 +746,10 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     let dst = builder.sysroot_codegen_backends(target_compiler);\n     t!(fs::create_dir_all(&dst));\n \n+    if builder.config.dry_run {\n+        return;\n+    }\n+\n     for backend in builder.config.rust_codegen_backends.iter() {\n         let stamp = codegen_backend_stamp(build, compiler, target, *backend);\n         let mut dylib = String::new();\n@@ -747,7 +765,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n                     backend,\n                     &filename[dot..])\n         };\n-        copy(&file, &dst.join(target_filename));\n+        build.copy(&file, &dst.join(target_filename));\n     }\n }\n \n@@ -763,7 +781,7 @@ fn copy_lld_to_sysroot(builder: &Builder,\n     t!(fs::create_dir_all(&dst));\n \n     let exe = exe(\"lld\", &target);\n-    copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n+    builder.copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n@@ -835,7 +853,7 @@ impl Step for Sysroot {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, PartialOrd, Ord, Clone, PartialEq, Eq, Hash)]\n pub struct Assemble {\n     /// The compiler which we will produce in this step. Assemble itself will\n     /// take care of ensuring that the necessary prerequisites to do so exist,\n@@ -915,7 +933,7 @@ impl Step for Assemble {\n             }\n         }\n \n-        let lld_install = if build.config.lld_enabled && target_compiler.stage > 0 {\n+        let lld_install = if build.config.lld_enabled {\n             Some(builder.ensure(native::Lld {\n                 target: target_compiler.host,\n             }))\n@@ -925,17 +943,17 @@ impl Step for Assemble {\n \n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n-        println!(\"Assembling stage{} compiler ({})\", stage, host);\n+        build.info(&format!(\"Assembling stage{} compiler ({})\", stage, host));\n \n         // Link in all dylibs to the libdir\n         let sysroot = builder.sysroot(target_compiler);\n         let sysroot_libdir = sysroot.join(libdir(&*host));\n         t!(fs::create_dir_all(&sysroot_libdir));\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n-        for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n+        for f in builder.read_dir(&src_libdir) {\n             let filename = f.file_name().into_string().unwrap();\n             if is_dylib(&filename) {\n-                copy(&f.path(), &sysroot_libdir.join(&filename));\n+                builder.copy(&f.path(), &sysroot_libdir.join(&filename));\n             }\n         }\n \n@@ -953,7 +971,7 @@ impl Step for Assemble {\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);\n         let _ = fs::remove_file(&compiler);\n-        copy(&rustc, &compiler);\n+        builder.copy(&rustc, &compiler);\n \n         target_compiler\n     }\n@@ -963,10 +981,10 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(build: &Build, sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    for path in read_stamp_file(stamp) {\n-        copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+    for path in build.read_stamp_file(stamp) {\n+        build.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -996,24 +1014,10 @@ fn stderr_isatty() -> bool {\n pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: bool)\n     -> Vec<PathBuf>\n {\n-    // Instruct Cargo to give us json messages on stdout, critically leaving\n-    // stderr as piped so we can get those pretty colors.\n-    cargo.arg(\"--message-format\").arg(\"json\")\n-         .stdout(Stdio::piped());\n-\n-    if stderr_isatty() && build.ci_env == CiEnv::None {\n-        // since we pass message-format=json to cargo, we need to tell the rustc\n-        // wrapper to give us colored output if necessary. This is because we\n-        // only want Cargo's JSON output, not rustcs.\n-        cargo.env(\"RUSTC_COLOR\", \"1\");\n+    if build.config.dry_run {\n+        return Vec::new();\n     }\n \n-    build.verbose(&format!(\"running: {:?}\", cargo));\n-    let mut child = match cargo.spawn() {\n-        Ok(child) => child,\n-        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cargo, e),\n-    };\n-\n     // `target_root_dir` looks like $dir/$target/release\n     let target_root_dir = stamp.parent().unwrap();\n     // `target_deps_dir` looks like $dir/$target/release/deps\n@@ -1028,46 +1032,33 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let stdout = BufReader::new(child.stdout.take().unwrap());\n-    for line in stdout.lines() {\n-        let line = t!(line);\n-        let json: serde_json::Value = if line.starts_with(\"{\") {\n-            t!(serde_json::from_str(&line))\n-        } else {\n-            // If this was informational, just print it out and continue\n-            println!(\"{}\", line);\n-            continue\n+    let ok = stream_cargo(build, cargo, &mut |msg| {\n+        let filenames = match msg {\n+            CargoMessage::CompilerArtifact { filenames, .. } => filenames,\n+            _ => return,\n         };\n-        if json[\"reason\"].as_str() != Some(\"compiler-artifact\") {\n-            if build.config.rustc_error_format.as_ref().map_or(false, |e| e == \"json\") {\n-                // most likely not a cargo message, so let's send it out as well\n-                println!(\"{}\", line);\n-            }\n-            continue\n-        }\n-        for filename in json[\"filenames\"].as_array().unwrap() {\n-            let filename = filename.as_str().unwrap();\n+        for filename in filenames {\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n                !is_dylib(&filename) &&\n                !(is_check && filename.ends_with(\".rmeta\")) {\n-                continue\n+                return;\n             }\n \n-            let filename = Path::new(filename);\n+            let filename = Path::new(&*filename);\n \n             // If this was an output file in the \"host dir\" we don't actually\n             // worry about it, it's not relevant for us.\n             if filename.starts_with(&host_root_dir) {\n-                continue;\n+                return;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n                 deps.push(filename.to_path_buf());\n-                continue;\n+                return;\n             }\n \n             // Otherwise this was a \"top level artifact\" which right now doesn't\n@@ -1088,15 +1079,10 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n \n             toplevel.push((file_stem, extension, expected_len));\n         }\n-    }\n+    });\n \n-    // Make sure Cargo actually succeeded after we read all of its stdout.\n-    let status = t!(child.wait());\n-    if !status.success() {\n-        panic!(\"command did not execute successfully: {:?}\\n\\\n-                expected success, got: {}\",\n-               cargo,\n-               status);\n+    if !ok {\n+        panic!(\"cargo must succeed\");\n     }\n \n     // Ok now we need to actually find all the files listed in `toplevel`. We've\n@@ -1155,7 +1141,7 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n     if stamp_contents == new_contents && max <= stamp_mtime {\n-        build.verbose(&format!(\"not updating {:?}; contents equal and {} <= {}\",\n+        build.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n                 stamp, max, stamp_mtime));\n         return deps\n     }\n@@ -1167,3 +1153,66 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n     t!(t!(File::create(stamp)).write_all(&new_contents));\n     deps\n }\n+\n+pub fn stream_cargo(\n+    build: &Build,\n+    cargo: &mut Command,\n+    cb: &mut FnMut(CargoMessage),\n+) -> bool {\n+    if build.config.dry_run {\n+        return true;\n+    }\n+    // Instruct Cargo to give us json messages on stdout, critically leaving\n+    // stderr as piped so we can get those pretty colors.\n+    cargo.arg(\"--message-format\").arg(\"json\")\n+         .stdout(Stdio::piped());\n+\n+    if stderr_isatty() && build.ci_env == CiEnv::None {\n+        // since we pass message-format=json to cargo, we need to tell the rustc\n+        // wrapper to give us colored output if necessary. This is because we\n+        // only want Cargo's JSON output, not rustcs.\n+        cargo.env(\"RUSTC_COLOR\", \"1\");\n+    }\n+\n+    build.verbose(&format!(\"running: {:?}\", cargo));\n+    let mut child = match cargo.spawn() {\n+        Ok(child) => child,\n+        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cargo, e),\n+    };\n+\n+    // Spawn Cargo slurping up its JSON output. We'll start building up the\n+    // `deps` array of all files it generated along with a `toplevel` array of\n+    // files we need to probe for later.\n+    let stdout = BufReader::new(child.stdout.take().unwrap());\n+    for line in stdout.lines() {\n+        let line = t!(line);\n+        match serde_json::from_str::<CargoMessage>(&line) {\n+            Ok(msg) => cb(msg),\n+            // If this was informational, just print it out and continue\n+            Err(_) => println!(\"{}\", line)\n+        }\n+    }\n+\n+    // Make sure Cargo actually succeeded after we read all of its stdout.\n+    let status = t!(child.wait());\n+    if !status.success() {\n+        eprintln!(\"command did not execute successfully: {:?}\\n\\\n+                  expected success, got: {}\",\n+                 cargo,\n+                 status);\n+    }\n+    status.success()\n+}\n+\n+#[derive(Deserialize)]\n+#[serde(tag = \"reason\", rename_all = \"kebab-case\")]\n+pub enum CargoMessage<'a> {\n+    CompilerArtifact {\n+        package_id: Cow<'a, str>,\n+        features: Vec<Cow<'a, str>>,\n+        filenames: Vec<Cow<'a, str>>,\n+    },\n+    BuildScriptExecuted {\n+        package_id: Cow<'a, str>,\n+    }\n+}"}, {"sha": "863abd14935a8f3493b0994ac4314e8bce5cb804", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -15,7 +15,7 @@\n \n use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::File;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process;\n@@ -45,6 +45,7 @@ pub struct Config {\n     pub ninja: bool,\n     pub verbose: usize,\n     pub submodules: bool,\n+    pub fast_submodules: bool,\n     pub compiler_docs: bool,\n     pub docs: bool,\n     pub locked_deps: bool,\n@@ -68,6 +69,7 @@ pub struct Config {\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n+    pub dry_run: bool,\n \n     // llvm codegen options\n     pub llvm_enabled: bool,\n@@ -121,6 +123,7 @@ pub struct Config {\n     pub quiet_tests: bool,\n     pub test_miri: bool,\n     pub save_toolstates: Option<PathBuf>,\n+    pub print_step_timings: bool,\n \n     // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n@@ -141,6 +144,7 @@ pub struct Config {\n     // These are either the stage0 downloaded binaries or the locally installed ones.\n     pub initial_cargo: PathBuf,\n     pub initial_rustc: PathBuf,\n+    pub out: PathBuf,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -157,6 +161,7 @@ pub struct Target {\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n     pub qemu_rootfs: Option<PathBuf>,\n+    pub no_std: bool,\n }\n \n /// Structure of the `config.toml` file that configuration is read from.\n@@ -190,6 +195,7 @@ struct Build {\n     compiler_docs: Option<bool>,\n     docs: Option<bool>,\n     submodules: Option<bool>,\n+    fast_submodules: Option<bool>,\n     gdb: Option<String>,\n     locked_deps: Option<bool>,\n     vendor: Option<bool>,\n@@ -204,6 +210,7 @@ struct Build {\n     openssl_static: Option<bool>,\n     configure_args: Option<Vec<String>>,\n     local_rebuild: Option<bool>,\n+    print_step_timings: Option<bool>,\n }\n \n /// TOML representation of various global install decisions.\n@@ -313,11 +320,8 @@ struct TomlTarget {\n }\n \n impl Config {\n-    pub fn parse(args: &[String]) -> Config {\n-        let flags = Flags::parse(&args);\n-        let file = flags.config.clone();\n+    pub fn default_opts() -> Config {\n         let mut config = Config::default();\n-        config.exclude = flags.exclude;\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.llvm_version_check = true;\n@@ -326,6 +330,7 @@ impl Config {\n         config.rust_optimize = true;\n         config.rust_optimize_tests = true;\n         config.submodules = true;\n+        config.fast_submodules = true;\n         config.docs = true;\n         config.rust_rpath = true;\n         config.channel = \"dev\".to_string();\n@@ -336,15 +341,38 @@ impl Config {\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n         config.rust_codegen_backends_dir = \"codegen-backends\".to_owned();\n \n+        // set by bootstrap.py\n+        config.src = env::var_os(\"SRC\").map(PathBuf::from).expect(\"'SRC' to be set\");\n+        config.build = INTERNER.intern_str(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n+        config.out = env::var_os(\"BUILD_DIR\").map(PathBuf::from).expect(\"'BUILD_DIR' set\");\n+\n+        let stage0_root = config.out.join(&config.build).join(\"stage0/bin\");\n+        config.initial_rustc = stage0_root.join(exe(\"rustc\", &config.build));\n+        config.initial_cargo = stage0_root.join(exe(\"cargo\", &config.build));\n+\n+        config\n+    }\n+\n+    pub fn parse(args: &[String]) -> Config {\n+        let flags = Flags::parse(&args);\n+        let file = flags.config.clone();\n+        let mut config = Config::default_opts();\n+        config.exclude = flags.exclude;\n         config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n-        config.src = flags.src;\n         config.jobs = flags.jobs;\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n+        config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n \n+        if config.dry_run {\n+            let dir = config.out.join(\"tmp-dry-run\");\n+            t!(fs::create_dir_all(&dir));\n+            config.out = dir;\n+        }\n+\n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n         config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n \n@@ -363,12 +391,7 @@ impl Config {\n         }).unwrap_or_else(|| TomlConfig::default());\n \n         let build = toml.build.clone().unwrap_or(Build::default());\n-        set(&mut config.build, build.build.clone().map(|x| INTERNER.intern_string(x)));\n-        set(&mut config.build, flags.build);\n-        if config.build.is_empty() {\n-            // set by bootstrap.py\n-            config.build = INTERNER.intern_str(&env::var(\"BUILD\").unwrap());\n-        }\n+        // set by bootstrap.py\n         config.hosts.push(config.build.clone());\n         for host in build.host.iter() {\n             let host = INTERNER.intern_str(host);\n@@ -402,6 +425,7 @@ impl Config {\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n+        set(&mut config.fast_submodules, build.fast_submodules);\n         set(&mut config.locked_deps, build.locked_deps);\n         set(&mut config.vendor, build.vendor);\n         set(&mut config.full_bootstrap, build.full_bootstrap);\n@@ -413,6 +437,7 @@ impl Config {\n         set(&mut config.openssl_static, build.openssl_static);\n         set(&mut config.configure_args, build.configure_args);\n         set(&mut config.local_rebuild, build.local_rebuild);\n+        set(&mut config.print_step_timings, build.print_step_timings);\n         config.verbose = cmp::max(config.verbose, flags.verbose);\n \n         if let Some(ref install) = toml.install {\n@@ -507,13 +532,13 @@ impl Config {\n                 let mut target = Target::default();\n \n                 if let Some(ref s) = cfg.llvm_config {\n-                    target.llvm_config = Some(env::current_dir().unwrap().join(s));\n+                    target.llvm_config = Some(config.src.join(s));\n                 }\n                 if let Some(ref s) = cfg.jemalloc {\n-                    target.jemalloc = Some(env::current_dir().unwrap().join(s));\n+                    target.jemalloc = Some(config.src.join(s));\n                 }\n                 if let Some(ref s) = cfg.android_ndk {\n-                    target.ndk = Some(env::current_dir().unwrap().join(s));\n+                    target.ndk = Some(config.src.join(s));\n                 }\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n@@ -534,22 +559,12 @@ impl Config {\n             set(&mut config.rust_dist_src, t.src_tarball);\n         }\n \n-        let cwd = t!(env::current_dir());\n-        let out = cwd.join(\"build\");\n-\n-        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n-        config.initial_rustc = match build.rustc {\n-            Some(s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"rustc\", &config.build)),\n-        };\n-        config.initial_cargo = match build.cargo {\n-            Some(s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"cargo\", &config.build)),\n-        };\n-\n         // Now that we've reached the end of our configuration, infer the\n         // default values for all options that we haven't otherwise stored yet.\n \n+        set(&mut config.initial_rustc, build.rustc.map(PathBuf::from));\n+        set(&mut config.initial_rustc, build.cargo.map(PathBuf::from));\n+\n         let default = false;\n         config.llvm_assertions = llvm_assertions.unwrap_or(default);\n "}, {"sha": "a5c373d5d5e7729ad118615fc0395f33641f1e2c", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -44,6 +44,7 @@ def v(*args):\n o(\"docs\", \"build.docs\", \"build standard library documentation\")\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n+o(\"experimental-parallel-queries\", \"rust.experimental-parallel-queries\", \"build rustc with experimental parallelization\")\n o(\"test-miri\", \"rust.test-miri\", \"run miri's test suite\")\n o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n o(\"quiet-tests\", \"rust.quiet-tests\", \"enable quieter output when running tests\")"}, {"sha": "e1f5d34bf67235c5e2a58225e4e4903f5b6b55a4", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 205, "deletions": 173, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -20,15 +20,15 @@\n \n use std::env;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write};\n+use std::io::{Read, Write};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n use {Build, Compiler, Mode};\n use channel;\n-use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file, exe};\n+use util::{libdir, is_dylib, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n use native;\n@@ -61,7 +61,7 @@ fn rust_installer(builder: &Builder) -> Command {\n     builder.tool_cmd(Tool::RustInstaller)\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n     pub stage: u32,\n     pub host: Interned<String>,\n@@ -89,9 +89,9 @@ impl Step for Docs {\n \n         let name = pkgname(build, \"rust-docs\");\n \n-        println!(\"Dist docs ({})\", host);\n+        build.info(&format!(\"Dist docs ({})\", host));\n         if !build.config.docs {\n-            println!(\"\\tskipping - docs disabled\");\n+            build.info(&format!(\"\\tskipping - docs disabled\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n@@ -102,8 +102,8 @@ impl Step for Docs {\n \n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n-        let src = build.out.join(host).join(\"doc\");\n-        cp_r(&src, &dst);\n+        let src = build.doc_out(host);\n+        build.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -118,16 +118,71 @@ impl Step for Docs {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n \n-        // As part of this step, *also* copy the docs directory to a directory which\n-        // buildbot typically uploads.\n-        if host == build.build {\n-            let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&src, &dst);\n+        distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustcDocs {\n+    pub stage: u32,\n+    pub host: Interned<String>,\n+}\n+\n+impl Step for RustcDocs {\n+    type Output = PathBuf;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(RustcDocs {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Builds the `rustc-docs` installer component.\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        let name = pkgname(build, \"rustc-docs\");\n+\n+        build.info(&format!(\"Dist compiler docs ({})\", host));\n+        if !build.config.compiler_docs {\n+            build.info(&format!(\"\\tskipping - compiler docs disabled\"));\n+            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n+        builder.default_doc(None);\n+\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let _ = fs::remove_dir_all(&image);\n+\n+        let dst = image.join(\"share/doc/rust/html\");\n+        t!(fs::create_dir_all(&dst));\n+        let src = build.compiler_doc_out(host);\n+        build.cp_r(&src, &dst);\n+\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rustc-Documentation\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rustc-documentation-is-installed.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(\"--component-name=rustc-docs\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--bulk-dirs=share/doc/rust/html\");\n+        build.run(&mut cmd);\n+        build.remove_dir(&image);\n+\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n }\n@@ -237,37 +292,31 @@ fn make_win_dist(\n     let rustc_dlls = find_files(&rustc_dlls, &bin_path);\n     let target_libs = find_files(&target_libs, &lib_path);\n \n-    fn copy_to_folder(src: &Path, dest_folder: &Path) {\n-        let file_name = src.file_name().unwrap();\n-        let dest = dest_folder.join(file_name);\n-        copy(src, &dest);\n-    }\n-\n-    //Copy runtime dlls next to rustc.exe\n+    // Copy runtime dlls next to rustc.exe\n     let dist_bin_dir = rust_root.join(\"bin/\");\n     fs::create_dir_all(&dist_bin_dir).expect(\"creating dist_bin_dir failed\");\n     for src in rustc_dlls {\n-        copy_to_folder(&src, &dist_bin_dir);\n+        build.copy_to_folder(&src, &dist_bin_dir);\n     }\n \n     //Copy platform tools to platform-specific bin directory\n     let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n-        copy_to_folder(&src, &target_bin_dir);\n+        build.copy_to_folder(&src, &target_bin_dir);\n     }\n \n     //Copy platform libs to platform-specific lib directory\n     let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n-        copy_to_folder(&src, &target_lib_dir);\n+        build.copy_to_folder(&src, &target_lib_dir);\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Mingw {\n-    host: Interned<String>,\n+    pub host: Interned<String>,\n }\n \n impl Step for Mingw {\n@@ -294,7 +343,7 @@ impl Step for Mingw {\n             return None;\n         }\n \n-        println!(\"Dist mingw ({})\", host);\n+        build.info(&format!(\"Dist mingw ({})\", host));\n         let name = pkgname(build, \"rust-mingw\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -323,7 +372,7 @@ impl Step for Mingw {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     pub compiler: Compiler,\n }\n@@ -349,7 +398,7 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n-        println!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host);\n+        build.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host));\n         let name = pkgname(build, \"rustc\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -362,17 +411,17 @@ impl Step for Rustc {\n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n         let cp = |file: &str| {\n-            install(&build.src.join(file), &overlay, 0o644);\n+            build.install(&build.src.join(file), &overlay, 0o644);\n         };\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n         cp(\"README.md\");\n         // tiny morsel of metadata is used by rust-packaging\n         let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create(&overlay.join(\"version\"), &version);\n         if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n \n         // On MinGW we've got a few runtime DLL dependencies that we need to\n@@ -390,7 +439,7 @@ impl Step for Rustc {\n \n             let dst = image.join(\"share/doc\");\n             t!(fs::create_dir_all(&dst));\n-            cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n+            build.cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n         }\n \n         // Finally, wrap everything up in a nice tarball!\n@@ -407,8 +456,8 @@ impl Step for Rustc {\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n-        t!(fs::remove_dir_all(&overlay));\n+        build.remove_dir(&image);\n+        build.remove_dir(&overlay);\n \n         return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n \n@@ -420,17 +469,17 @@ impl Step for Rustc {\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n-            cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n+            build.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n+            build.install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir != \"bin\" {\n-                for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n+                for entry in build.read_dir(&src.join(libdir)) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            install(&entry.path(), &image.join(libdir), 0o644);\n+                            build.install(&entry.path(), &image.join(libdir), 0o644);\n                         }\n                     }\n                 }\n@@ -441,7 +490,7 @@ impl Step for Rustc {\n             let backends_rel = backends_src.strip_prefix(&src).unwrap();\n             let backends_dst = image.join(&backends_rel);\n             t!(fs::create_dir_all(&backends_dst));\n-            cp_r(&backends_src, &backends_dst);\n+            build.cp_r(&backends_src, &backends_dst);\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n@@ -456,7 +505,7 @@ impl Step for Rustc {\n                     .join(\"bin\")\n                     .join(&exe);\n                 t!(fs::create_dir_all(&dst.parent().unwrap()));\n-                copy(&src, &dst);\n+                build.copy(&src, &dst);\n             }\n \n             // Man pages\n@@ -466,13 +515,12 @@ impl Step for Rustc {\n             let month_year = t!(time::strftime(\"%B %Y\", &time::now()));\n             // don't use our `bootstrap::util::{copy, cp_r}`, because those try\n             // to hardlink, and we don't want to edit the source templates\n-            for entry_result in t!(fs::read_dir(man_src)) {\n-                let file_entry = t!(entry_result);\n+            for file_entry in build.read_dir(&man_src) {\n                 let page_src = file_entry.path();\n                 let page_dst = man_dst.join(file_entry.file_name());\n                 t!(fs::copy(&page_src, &page_dst));\n                 // template in month/year and version number\n-                replace_in_file(&page_dst,\n+                build.replace_in_file(&page_dst,\n                                 &[(\"<INSERT DATE HERE>\", &month_year),\n                                   (\"<INSERT VERSION HERE>\", channel::CFG_RELEASE_NUM)]);\n             }\n@@ -485,7 +533,7 @@ impl Step for Rustc {\n \n             // Misc license info\n             let cp = |file: &str| {\n-                install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n+                build.install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n             };\n             cp(\"COPYRIGHT\");\n             cp(\"LICENSE-APACHE\");\n@@ -523,11 +571,11 @@ impl Step for DebuggerScripts {\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n         t!(fs::create_dir_all(&dst));\n         let cp_debugger_script = |file: &str| {\n-            install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n+            build.install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n         };\n         if host.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n-            install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n \n             cp_debugger_script(\"natvis/intrinsic.natvis\");\n@@ -537,22 +585,22 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n             // gdb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n             cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n \n             // lldb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"lldb_rust_formatters.py\");\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub compiler: Compiler,\n     pub target: Interned<String>,\n@@ -579,12 +627,12 @@ impl Step for Std {\n         let target = self.target;\n \n         let name = pkgname(build, \"rust-std\");\n-        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target);\n+        build.info(&format!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target));\n \n         // The only true set of target libraries came from the build triple, so\n         // let's reduce redundant work by only producing archives from that host.\n         if compiler.host != build.build {\n-            println!(\"\\tskipping, not a build host\");\n+            build.info(&format!(\"\\tskipping, not a build host\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n@@ -594,7 +642,12 @@ impl Step for Std {\n         if build.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            builder.ensure(compile::Test { compiler, target });\n+            if build.no_std(target) == Some(true) {\n+                // the `test` doesn't compile for no-std targets\n+                builder.ensure(compile::Std { compiler, target });\n+            } else {\n+                builder.ensure(compile::Test { compiler, target });\n+            }\n         }\n \n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n@@ -604,7 +657,7 @@ impl Step for Std {\n         t!(fs::create_dir_all(&dst));\n         let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        cp_filtered(&src, &dst, &|path| {\n+        build.cp_filtered(&src, &dst, &|path| {\n             let name = path.file_name().and_then(|s| s.to_str());\n             name != Some(build.config.rust_codegen_backends_dir.as_str()) &&\n                 name != Some(\"bin\")\n@@ -623,7 +676,7 @@ impl Step for Std {\n            .arg(format!(\"--component-name=rust-std-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n@@ -656,11 +709,11 @@ impl Step for Analysis {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(build.config.extended);\n-        println!(\"Dist analysis\");\n+        build.info(&format!(\"Dist analysis\"));\n         let name = pkgname(build, \"rust-analysis\");\n \n         if &compiler.host != build.build {\n-            println!(\"\\tskipping, not a build host\");\n+            build.info(&format!(\"\\tskipping, not a build host\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n@@ -682,8 +735,8 @@ impl Step for Analysis {\n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n         t!(fs::create_dir_all(&dst));\n-        println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n-        cp_r(&image_src, &dst);\n+        build.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n+        build.cp_r(&image_src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -697,7 +750,7 @@ impl Step for Analysis {\n            .arg(format!(\"--component-name=rust-analysis-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n@@ -741,11 +794,11 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n     for item in src_dirs {\n         let dst = &dst_dir.join(item);\n         t!(fs::create_dir_all(dst));\n-        cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n+        build.cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Src;\n \n impl Step for Src {\n@@ -765,7 +818,7 @@ impl Step for Src {\n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n-        println!(\"Dist src\");\n+        build.info(&format!(\"Dist src\"));\n \n         let name = pkgname(build, \"rust-src\");\n         let image = tmpdir(build).join(format!(\"{}-image\", name));\n@@ -815,7 +868,7 @@ impl Step for Src {\n \n         copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n         for file in src_files.iter() {\n-            copy(&build.src.join(file), &dst_src.join(file));\n+            build.copy(&build.src.join(file), &dst_src.join(file));\n         }\n \n         // Create source tarball in rust-installer format\n@@ -832,14 +885,14 @@ impl Step for Src {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n \n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(&format!(\"{}.tar.gz\", name))\n     }\n }\n \n const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct PlainSourceTarball;\n \n impl Step for PlainSourceTarball {\n@@ -860,7 +913,7 @@ impl Step for PlainSourceTarball {\n     /// Creates the plain source tarball\n     fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n-        println!(\"Create plain source tarball\");\n+        build.info(&format!(\"Create plain source tarball\"));\n \n         // Make sure that the root folder of tarball has the correct name\n         let plain_name = format!(\"{}-src\", pkgname(build, \"rustc\"));\n@@ -888,13 +941,13 @@ impl Step for PlainSourceTarball {\n \n         // Copy the files normally\n         for item in &src_files {\n-            copy(&build.src.join(item), &plain_dst_src.join(item));\n+            build.copy(&build.src.join(item), &plain_dst_src.join(item));\n         }\n \n         // Create the version file\n-        write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n+        build.create(&plain_dst_src.join(\"version\"), &build.rust_version());\n         if let Some(sha) = build.rust_sha() {\n-            write_file(&plain_dst_src.join(\"git-commit-hash\"), sha.as_bytes());\n+            build.create(&plain_dst_src.join(\"git-commit-hash\"), &sha);\n         }\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n@@ -935,9 +988,9 @@ impl Step for PlainSourceTarball {\n         tarball.set_extension(\"\"); // strip .gz\n         tarball.set_extension(\"\"); // strip .tar\n         if let Some(dir) = tarball.parent() {\n-            t!(fs::create_dir_all(dir));\n+            build.create_dir(&dir);\n         }\n-        println!(\"running installer\");\n+        build.info(&format!(\"running installer\"));\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"tarball\")\n            .arg(\"--input\").arg(&plain_name)\n@@ -949,26 +1002,6 @@ impl Step for PlainSourceTarball {\n     }\n }\n \n-fn install(src: &Path, dstdir: &Path, perms: u32) {\n-    let dst = dstdir.join(src.file_name().unwrap());\n-    t!(fs::create_dir_all(dstdir));\n-    drop(fs::remove_file(&dst));\n-    {\n-        let mut s = t!(fs::File::open(&src));\n-        let mut d = t!(fs::File::create(&dst));\n-        io::copy(&mut s, &mut d).expect(\"failed to copy\");\n-    }\n-    chmod(&dst, perms);\n-}\n-\n-#[cfg(unix)]\n-fn chmod(path: &Path, perms: u32) {\n-    use std::os::unix::fs::*;\n-    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n-}\n-#[cfg(windows)]\n-fn chmod(_path: &Path, _perms: u32) {}\n-\n // We have to run a few shell scripts, which choke quite a bit on both `\\`\n // characters and on `C:\\` paths, so normalize both of them away.\n pub fn sanitize_sh(path: &Path) -> String {\n@@ -988,12 +1021,7 @@ pub fn sanitize_sh(path: &Path) -> String {\n     }\n }\n \n-fn write_file(path: &Path, data: &[u8]) {\n-    let mut vf = t!(fs::File::create(path));\n-    t!(vf.write_all(data));\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub stage: u32,\n     pub target: Interned<String>,\n@@ -1019,7 +1047,7 @@ impl Step for Cargo {\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist cargo stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = build.release_num(\"cargo\");\n@@ -1029,38 +1057,38 @@ impl Step for Cargo {\n         let tmp = tmpdir(build);\n         let image = tmp.join(\"cargo-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        build.create_dir(&image);\n \n         // Prepare the image directory\n-        t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n-        t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n+        build.create_dir(&image.join(\"share/zsh/site-functions\"));\n+        build.create_dir(&image.join(\"etc/bash_completion.d\"));\n         let cargo = builder.ensure(tool::Cargo {\n             compiler: builder.compiler(stage, build.build),\n             target\n         });\n-        install(&cargo, &image.join(\"bin\"), 0o755);\n+        build.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n-            install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n+            build.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n         }\n-        install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-        copy(&etc.join(\"cargo.bashcomp.sh\"),\n+        build.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n+        build.copy(&etc.join(\"cargo.bashcomp.sh\"),\n              &image.join(\"etc/bash_completion.d/cargo\"));\n         let doc = image.join(\"share/doc/cargo\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"cargo-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create_dir(&overlay);\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1080,7 +1108,7 @@ impl Step for Cargo {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n     pub stage: u32,\n     pub target: Interned<String>,\n@@ -1107,7 +1135,7 @@ impl Step for Rls {\n         let target = self.target;\n         assert!(build.config.extended);\n \n-        println!(\"Dist RLS stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n         let name = pkgname(build, \"rls\");\n@@ -1126,20 +1154,20 @@ impl Step for Rls {\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build RLS, skipping dist\"); None })?;\n \n-        install(&rls, &image.join(\"bin\"), 0o755);\n+        build.install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rls-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n         t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1161,7 +1189,7 @@ impl Step for Rls {\n }\n \n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n     pub stage: u32,\n     pub target: Interned<String>,\n@@ -1186,9 +1214,8 @@ impl Step for Rustfmt {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        assert!(build.config.extended);\n \n-        println!(\"Dist Rustfmt stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/rustfmt\");\n         let release_num = build.release_num(\"rustfmt\");\n         let name = pkgname(build, \"rustfmt\");\n@@ -1197,7 +1224,7 @@ impl Step for Rustfmt {\n         let tmp = tmpdir(build);\n         let image = tmp.join(\"rustfmt-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        build.create_dir(&image);\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n@@ -1209,21 +1236,21 @@ impl Step for Rustfmt {\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Cargofmt, skipping dist\"); None })?;\n \n-        install(&rustfmt, &image.join(\"bin\"), 0o755);\n-        install(&cargofmt, &image.join(\"bin\"), 0o755);\n+        build.install(&rustfmt, &image.join(\"bin\"), 0o755);\n+        build.install(&cargofmt, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rustfmt\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rustfmt-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create_dir(&overlay);\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1244,7 +1271,7 @@ impl Step for Rustfmt {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,\n     host: Interned<String>,\n@@ -1275,7 +1302,7 @@ impl Step for Extended {\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist extended stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n@@ -1301,15 +1328,15 @@ impl Step for Extended {\n         let work = tmp.join(\"work\");\n \n         let _ = fs::remove_dir_all(&overlay);\n-        install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n         let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create(&overlay.join(\"version\"), &version);\n         if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n-        install(&etc.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&etc.join(\"README.md\"), &overlay, 0o644);\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n@@ -1348,11 +1375,11 @@ impl Step for Extended {\n         build.run(&mut cmd);\n \n         let mut license = String::new();\n-        t!(t!(File::open(build.src.join(\"COPYRIGHT\"))).read_to_string(&mut license));\n+        license += &build.read(&build.src.join(\"COPYRIGHT\"));\n+        license += &build.read(&build.src.join(\"LICENSE-APACHE\"));\n+        license += &build.read(&build.src.join(\"LICENSE-MIT\"));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-APACHE\"))).read_to_string(&mut license));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-MIT\"))).read_to_string(&mut license));\n \n         let rtf = r\"{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\\nowwrap\\fs18\";\n         let mut rtf = rtf.to_string();\n@@ -1409,10 +1436,10 @@ impl Step for Extended {\n             };\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(pkg.join(name)));\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                build.create_dir(&pkg.join(name));\n+                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n                         &pkg.join(name));\n-                install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n                 pkgbuild(name);\n             };\n             prepare(\"rustc\");\n@@ -1426,12 +1453,12 @@ impl Step for Extended {\n             }\n \n             // create an 'uninstall' package\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n+            build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n             pkgbuild(\"uninstall\");\n \n-            t!(fs::create_dir_all(pkg.join(\"res\")));\n-            t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n-            install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n+            build.create_dir(&pkg.join(\"res\"));\n+            build.create(&pkg.join(\"res/LICENSE.txt\"), &license);\n+            build.install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n             cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n@@ -1447,18 +1474,18 @@ impl Step for Extended {\n             let _ = fs::remove_dir_all(&exe);\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(exe.join(name)));\n+                build.create_dir(&exe.join(name));\n                 let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n                     format!(\"{}-{}\", name, target)\n                 } else if name == \"rls\" {\n                     \"rls-preview\".to_string()\n                 } else {\n                     name.to_string()\n                 };\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n                             .join(dir),\n                         &exe.join(name));\n-                t!(fs::remove_file(exe.join(name).join(\"manifest.in\")));\n+                build.remove(&exe.join(name).join(\"manifest.in\"));\n             };\n             prepare(\"rustc\");\n             prepare(\"cargo\");\n@@ -1472,11 +1499,11 @@ impl Step for Extended {\n                 prepare(\"rust-mingw\");\n             }\n \n-            install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n-            install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-            install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n-            t!(t!(File::create(exe.join(\"LICENSE.txt\"))).write_all(license.as_bytes()));\n+            build.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n+            build.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n+            build.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n+            build.create(&exe.join(\"LICENSE.txt\"), &license);\n \n             // Generate exe installer\n             let mut cmd = Command::new(\"iscc\");\n@@ -1487,7 +1514,7 @@ impl Step for Extended {\n             }\n             add_env(build, &mut cmd, target);\n             build.run(&mut cmd);\n-            install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n+            build.install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n                     &distdir(build),\n                     0o755);\n \n@@ -1611,9 +1638,9 @@ impl Step for Extended {\n                 candle(\"GccGroup.wxs\".as_ref());\n             }\n \n-            t!(t!(File::create(exe.join(\"LICENSE.rtf\"))).write_all(rtf.as_bytes()));\n-            install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n+            build.create(&exe.join(\"LICENSE.rtf\"), &rtf);\n+            build.install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n \n             let filename = format!(\"{}-{}.msi\", pkgname(build, \"rust\"), target);\n             let mut cmd = Command::new(&light);\n@@ -1643,7 +1670,9 @@ impl Step for Extended {\n \n             build.run(&mut cmd);\n \n-            t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            if !build.config.dry_run {\n+                t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            }\n         }\n     }\n }\n@@ -1677,7 +1706,7 @@ fn add_env(build: &Build, cmd: &mut Command, target: Interned<String>) {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct HashSign;\n \n impl Step for HashSign {\n@@ -1695,6 +1724,9 @@ impl Step for HashSign {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n+        if build.config.dry_run {\n+            return;\n+        }\n         let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n         });\n@@ -1718,7 +1750,7 @@ impl Step for HashSign {\n         cmd.arg(build.package_vers(&build.release_num(\"rustfmt\")));\n         cmd.arg(addr);\n \n-        t!(fs::create_dir_all(distdir(build)));\n+        build.create_dir(&distdir(build));\n \n         let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n         t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));"}, {"sha": "4237ded2215c218e4fd8ed16e4d7d4a795fecc4b", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 154, "deletions": 54, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -17,19 +17,21 @@\n //! Everything here is basically just a shim around calling either `rustbook` or\n //! `rustdoc`.\n \n+use std::collections::HashSet;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-use Mode;\n+use {Build, Mode};\n use build_helper::up_to_date;\n \n-use util::{cp_r, symlink_dir};\n+use util::symlink_dir;\n use builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n use tool::Tool;\n use compile;\n use cache::{INTERNER, Interned};\n+use config::Config;\n \n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n@@ -167,7 +169,7 @@ impl Step for CargoBook {\n \n         let out = out.join(name);\n \n-        println!(\"Cargo Book ({}) - {}\", target, name);\n+        build.info(&format!(\"Cargo Book ({}) - {}\", target, name));\n \n         let _ = fs::remove_dir_all(&out);\n \n@@ -209,12 +211,13 @@ impl Step for RustbookSrc {\n         let src = src.join(name);\n         let index = out.join(\"index.html\");\n         let rustbook = builder.tool_exe(Tool::Rustbook);\n+        let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n             return\n         }\n-        println!(\"Rustbook ({}) - {}\", target, name);\n+        build.info(&format!(\"Rustbook ({}) - {}\", target, name));\n         let _ = fs::remove_dir_all(&out);\n-        build.run(builder.tool_cmd(Tool::Rustbook)\n+        build.run(rustbook_cmd\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -280,11 +283,11 @@ impl Step for TheBook {\n \n         // build the index page\n         let index = format!(\"{}/index.md\", name);\n-        println!(\"Documenting book index ({})\", target);\n+        build.info(&format!(\"Documenting book index ({})\", target));\n         invoke_rustdoc(builder, compiler, target, &index);\n \n         // build the redirect pages\n-        println!(\"Documenting book redirect pages ({})\", target);\n+        build.info(&format!(\"Documenting book redirect pages ({})\", target));\n         for file in t!(fs::read_dir(build.src.join(\"src/doc/book/redirects\"))) {\n             let file = t!(file);\n             let path = file.path();\n@@ -357,7 +360,7 @@ impl Step for Standalone {\n         let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n-        println!(\"Documenting standalone ({})\", target);\n+        build.info(&format!(\"Documenting standalone ({})\", target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n@@ -369,7 +372,7 @@ impl Step for Standalone {\n         let version_input = build.src.join(\"src/doc/version_info.html.template\");\n         let version_info = out.join(\"version_info.html\");\n \n-        if !up_to_date(&version_input, &version_info) {\n+        if !build.config.dry_run && !up_to_date(&version_input, &version_info) {\n             let mut info = String::new();\n             t!(t!(File::open(&version_input)).read_to_string(&mut info));\n             let info = info.replace(\"VERSION\", &build.rust_release())\n@@ -393,7 +396,7 @@ impl Step for Standalone {\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n                up_to_date(&version_info, &html) &&\n-               up_to_date(&rustdoc, &html) {\n+               (build.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n \n@@ -448,7 +451,7 @@ impl Step for Std {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} std ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -478,28 +481,24 @@ impl Step for Std {\n         // will also directly handle merging.\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&build.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n         compile::std_cargo(builder, &compiler, target, &mut cargo);\n \n-        // We don't want to build docs for internal std dependencies unless\n-        // in compiler-docs mode. When not in that mode, we whitelist the crates\n-        // for which docs must be built.\n-        if !build.config.compiler_docs {\n-            cargo.arg(\"--no-deps\");\n-            for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n-                cargo.arg(\"-p\").arg(krate);\n-                // Create all crate output directories first to make sure rustdoc uses\n-                // relative links.\n-                // FIXME: Cargo should probably do this itself.\n-                t!(fs::create_dir_all(out_dir.join(krate)));\n-            }\n+        // Keep a whitelist so we do not build internal stdlib crates, these will be\n+        // build by the rustc step later if enabled.\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+            // Create all crate output directories first to make sure rustdoc uses\n+            // relative links.\n+            // FIXME: Cargo should probably do this itself.\n+            t!(fs::create_dir_all(out_dir.join(krate)));\n         }\n \n-\n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n@@ -533,7 +532,7 @@ impl Step for Test {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} test ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -554,22 +553,22 @@ impl Step for Test {\n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"doc\");\n         compile::test_cargo(build, &compiler, target, &mut cargo);\n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rustc {\n+pub struct WhitelistedRustc {\n     stage: u32,\n     target: Interned<String>,\n }\n \n-impl Step for Rustc {\n+impl Step for WhitelistedRustc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -580,21 +579,26 @@ impl Step for Rustc {\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustc {\n+        run.builder.ensure(WhitelistedRustc {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    /// Generate all compiler documentation.\n+    /// Generate whitelisted compiler crate documentation.\n     ///\n-    /// This will generate all documentation for the compiler libraries and their\n-    /// dependencies. This is largely just a wrapper around `cargo doc`.\n+    /// This will generate all documentation for crates that are whitelisted\n+    /// to be included in the standard documentation. This documentation is\n+    /// included in the standard Rust documentation, so we should always\n+    /// document it and symlink to merge with the rest of the std and test\n+    /// documentation. We don't build other compiler documentation\n+    /// here as we want to be able to keep it separate from the standard\n+    /// documentation. This is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} compiler ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -615,26 +619,119 @@ impl Step for Rustc {\n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n         compile::rustc_cargo(build, &mut cargo);\n \n-        if build.config.compiler_docs {\n-            // src/rustc/Cargo.toml contains a bin crate called rustc which\n-            // would otherwise overwrite the docs for the real rustc lib crate.\n-            cargo.arg(\"-p\").arg(\"rustc_driver\");\n+        // We don't want to build docs for internal compiler dependencies in this\n+        // step (there is another step for that). Therefore, we whitelist the crates\n+        // for which docs must be built.\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"proc_macro\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+\n+        build.run(&mut cargo);\n+        build.cp_r(&my_out, &out);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustc {\n+    stage: u32,\n+    target: Interned<String>,\n+}\n+\n+impl Step for Rustc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.krate(\"rustc-main\").default_condition(builder.build.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustc {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Generate compiler documentation.\n+    ///\n+    /// This will generate all documentation for compiler and dependencies.\n+    /// Compiler documentation is distributed separately, so we make sure\n+    /// we do not merge it with the other documentation from std, test and\n+    /// proc_macros. This is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        build.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n+        let out = build.compiler_doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+        let compiler = builder.compiler(stage, build.build);\n+        let rustdoc = builder.rustdoc(compiler.host);\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n         } else {\n-            // Like with libstd above if compiler docs aren't enabled then we're not\n-            // documenting internal dependencies, so we have a whitelist.\n-            cargo.arg(\"--no-deps\");\n-            for krate in &[\"proc_macro\"] {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n+            compiler\n+        };\n+\n+        if !build.config.compiler_docs {\n+            build.info(&format!(\"\\tskipping - compiler docs disabled\"));\n+            return;\n+        }\n+\n+        // Build libstd docs so that we generate relative links\n+        builder.ensure(Std { stage, target });\n+\n+        builder.ensure(compile::Rustc { compiler, target });\n+        let out_dir = build.stage_out(compiler, Mode::Librustc)\n+                           .join(target).join(\"doc\");\n+        // We do not symlink to the same shared folder that already contains std library\n+        // documentation from previous steps as we do not want to include that.\n+        build.clear_if_dirty(&out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &out, &out_dir));\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        compile::rustc_cargo(build, &mut cargo);\n+\n+        // Only include compiler crates, no dependencies of those, such as `libc`.\n+        cargo.arg(\"--no-deps\");\n+\n+        // Find dependencies for top level crates.\n+        let mut compiler_crates = HashSet::new();\n+        for root_crate in &[\"rustc\", \"rustc_driver\"] {\n+            let interned_root_crate = INTERNER.intern_str(root_crate);\n+            find_compiler_crates(&build, &interned_root_crate, &mut compiler_crates);\n+        }\n+\n+        for krate in &compiler_crates {\n+            cargo.arg(\"-p\").arg(krate);\n         }\n \n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+    }\n+}\n+\n+fn find_compiler_crates(\n+    build: &Build,\n+    name: &Interned<String>,\n+    crates: &mut HashSet<Interned<String>>\n+) {\n+    // Add current crate.\n+    crates.insert(*name);\n+\n+    // Look for dependencies.\n+    for dep in build.crates.get(name).unwrap().deps.iter() {\n+        if build.crates.get(dep).unwrap().is_local(build) {\n+            find_compiler_crates(build, dep, crates);\n+        }\n     }\n }\n \n@@ -665,7 +762,7 @@ impl Step for ErrorIndex {\n         let build = builder.build;\n         let target = self.target;\n \n-        println!(\"Documenting error index ({})\", target);\n+        build.info(&format!(\"Documenting error index ({})\", target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let mut index = builder.tool_cmd(Tool::ErrorIndex);\n@@ -710,10 +807,10 @@ impl Step for UnstableBookGen {\n             target,\n         });\n \n-        println!(\"Generating unstable book md files ({})\", target);\n+        build.info(&format!(\"Generating unstable book md files ({})\", target));\n         let out = build.md_doc_out(target).join(\"unstable-book\");\n-        t!(fs::create_dir_all(&out));\n-        t!(fs::remove_dir_all(&out));\n+        build.create_dir(&out);\n+        build.remove_dir(&out);\n         let mut cmd = builder.tool_cmd(Tool::UnstableBookGen);\n         cmd.arg(build.src.join(\"src\"));\n         cmd.arg(out);\n@@ -722,7 +819,10 @@ impl Step for UnstableBookGen {\n     }\n }\n \n-fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n+fn symlink_dir_force(config: &Config, src: &Path, dst: &Path) -> io::Result<()> {\n+    if config.dry_run {\n+        return Ok(());\n+    }\n     if let Ok(m) = fs::symlink_metadata(dst) {\n         if m.file_type().is_dir() {\n             try!(fs::remove_dir_all(dst));\n@@ -735,5 +835,5 @@ fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n         }\n     }\n \n-    symlink_dir(src, dst)\n+    symlink_dir(config, src, dst)\n }"}, {"sha": "cd304fb26e0bfcb939cf226951a19c58c170d4f3", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -13,7 +13,6 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::env;\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n@@ -33,17 +32,16 @@ pub struct Flags {\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,\n-    pub build: Option<Interned<String>>,\n \n     pub host: Vec<Interned<String>>,\n     pub target: Vec<Interned<String>>,\n     pub config: Option<PathBuf>,\n-    pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub dry_run: bool,\n }\n \n pub enum Subcommand {\n@@ -114,6 +112,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n         opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n+        opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n         opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n@@ -278,10 +277,6 @@ Arguments:\n             _ => { }\n         };\n         // Get any optional paths which occur after the subcommand\n-        let cwd = t!(env::current_dir());\n-        let src = matches.opt_str(\"src\").map(PathBuf::from)\n-            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n-            .unwrap_or(cwd.clone());\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n@@ -371,10 +366,10 @@ Arguments:\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage,\n+            dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n             host: split(matches.opt_strs(\"host\"))\n                 .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             target: split(matches.opt_strs(\"target\"))\n@@ -385,7 +380,6 @@ Arguments:\n             incremental: matches.opt_present(\"incremental\"),\n             exclude: split(matches.opt_strs(\"exclude\"))\n                 .into_iter().map(|p| p.into()).collect::<Vec<_>>(),\n-            src,\n         }\n     }\n }"}, {"sha": "4b05cac1ce6979123e0637c5169c9dd2a4b9dff4", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -63,7 +63,7 @@ fn install_sh(\n     host: Option<Interned<String>>\n ) {\n     let build = builder.build;\n-    println!(\"Install {} stage{} ({:?})\", package, stage, host);\n+    build.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n     let prefix_default = PathBuf::from(\"/usr/local\");\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n@@ -212,15 +212,16 @@ install!((self, builder, _config),\n             Self::should_install(builder) {\n             install_rls(builder, self.stage, self.target);\n         } else {\n-            println!(\"skipping Install RLS stage{} ({})\", self.stage, self.target);\n+            builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n         if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n             install_rustfmt(builder, self.stage, self.target);\n         } else {\n-            println!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target);\n+            builder.info(\n+                &format!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target));\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {"}, {"sha": "ea4368c0323fbd761b127afd0e32a3a65222a869", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 247, "deletions": 25, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -114,7 +114,7 @@\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n #![deny(warnings)]\n-#![feature(core_intrinsics)]\n+#![feature(conservative_impl_trait, fs_read_write, core_intrinsics)]\n #![feature(slice_concat_ext)]\n \n #[macro_use]\n@@ -131,20 +131,27 @@ extern crate getopts;\n extern crate num_cpus;\n extern crate toml;\n extern crate time;\n+extern crate petgraph;\n+\n+#[cfg(test)]\n+#[macro_use]\n+extern crate pretty_assertions;\n \n #[cfg(unix)]\n extern crate libc;\n \n use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs::{self, OpenOptions, File};\n+use std::io::{self, Seek, SeekFrom, Write, Read};\n use std::path::{PathBuf, Path};\n use std::process::{self, Command};\n use std::slice;\n+use std::str;\n \n use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n+use filetime::FileTime;\n \n use util::{exe, libdir, OutputFolder, CiEnv};\n \n@@ -198,7 +205,7 @@ use toolstate::ToolState;\n /// Each compiler has a `stage` that it is associated with and a `host` that\n /// corresponds to the platform the compiler runs on. This structure is used as\n /// a parameter to many methods below.\n-#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+#[derive(Eq, PartialOrd, Ord, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct Compiler {\n     stage: u32,\n     host: Interned<String>,\n@@ -254,6 +261,10 @@ pub struct Build {\n     ci_env: CiEnv,\n     delayed_failures: RefCell<Vec<String>>,\n     prerelease_version: Cell<Option<u32>>,\n+    tool_artifacts: RefCell<HashMap<\n+        Interned<String>,\n+        HashMap<String, (&'static str, PathBuf, Vec<String>)>\n+    >>,\n }\n \n #[derive(Debug)]\n@@ -305,9 +316,8 @@ impl Build {\n     ///\n     /// By default all build output will be placed in the current directory.\n     pub fn new(config: Config) -> Build {\n-        let cwd = t!(env::current_dir());\n         let src = config.src.clone();\n-        let out = cwd.join(\"build\");\n+        let out = config.out.clone();\n \n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n             Some(sudo_user) => {\n@@ -323,7 +333,7 @@ impl Build {\n         let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n         let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n \n-        Build {\n+        let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             local_rebuild: config.local_rebuild,\n@@ -353,7 +363,31 @@ impl Build {\n             ci_env: CiEnv::current(),\n             delayed_failures: RefCell::new(Vec::new()),\n             prerelease_version: Cell::new(None),\n+            tool_artifacts: Default::default(),\n+        };\n+\n+        build.verbose(\"finding compilers\");\n+        cc_detect::find(&mut build);\n+        build.verbose(\"running sanity check\");\n+        sanity::check(&mut build);\n+\n+        // If local-rust is the same major.minor as the current version, then force a\n+        // local-rebuild\n+        let local_version_verbose = output(\n+            Command::new(&build.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n+        let local_release = local_version_verbose\n+            .lines().filter(|x| x.starts_with(\"release:\"))\n+            .next().unwrap().trim_left_matches(\"release:\").trim();\n+        let my_version = channel::CFG_RELEASE_NUM;\n+        if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n+            build.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n+            build.local_rebuild = true;\n         }\n+\n+        build.verbose(\"learning about cargo\");\n+        metadata::build(&mut build);\n+\n+        build\n     }\n \n     pub fn build_triple(&self) -> &[Interned<String>] {\n@@ -372,25 +406,28 @@ impl Build {\n             return clean::clean(self, all);\n         }\n \n-        self.verbose(\"finding compilers\");\n-        cc_detect::find(self);\n-        self.verbose(\"running sanity check\");\n-        sanity::check(self);\n-        // If local-rust is the same major.minor as the current version, then force a local-rebuild\n-        let local_version_verbose = output(\n-            Command::new(&self.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n-        let local_release = local_version_verbose\n-            .lines().filter(|x| x.starts_with(\"release:\"))\n-            .next().unwrap().trim_left_matches(\"release:\").trim();\n-        let my_version = channel::CFG_RELEASE_NUM;\n-        if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n-            self.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n-            self.local_rebuild = true;\n+        {\n+            let builder = builder::Builder::new(&self);\n+            if let Some(path) = builder.paths.get(0) {\n+                if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n+                    return;\n+                }\n+            }\n         }\n-        self.verbose(\"learning about cargo\");\n-        metadata::build(self);\n \n-        builder::Builder::run(&self);\n+        if !self.config.dry_run {\n+            {\n+                self.config.dry_run = true;\n+                let builder = builder::Builder::new(&self);\n+                builder.execute_cli();\n+            }\n+            self.config.dry_run = false;\n+            let builder = builder::Builder::new(&self);\n+            builder.execute_cli();\n+        } else {\n+            let builder = builder::Builder::new(&self);\n+            let _ = builder.execute_cli();\n+        }\n \n         // Check for postponed failures from `test --no-fail-fast`.\n         let failures = self.delayed_failures.borrow();\n@@ -511,6 +548,11 @@ impl Build {\n         self.out.join(&*target).join(\"doc\")\n     }\n \n+    /// Output directory for all documentation for a target\n+    fn compiler_doc_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"compiler-doc\")\n+    }\n+\n     /// Output directory for some generated md crate documentation for a target (temporary)\n     fn md_doc_out(&self, target: Interned<String>) -> Interned<PathBuf> {\n         INTERNER.intern_path(self.out.join(&*target).join(\"md-doc\"))\n@@ -576,12 +618,14 @@ impl Build {\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run(&self, cmd: &mut Command) {\n+        if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_silent(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run_quiet(&self, cmd: &mut Command) {\n+        if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_suppressed(cmd)\n     }\n@@ -590,6 +634,7 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run(&self, cmd: &mut Command) -> bool {\n+        if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_silent(cmd)\n     }\n@@ -598,6 +643,7 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run_quiet(&self, cmd: &mut Command) -> bool {\n+        if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_suppressed(cmd)\n     }\n@@ -613,6 +659,11 @@ impl Build {\n         }\n     }\n \n+    fn info(&self, msg: &str) {\n+        if self.config.dry_run { return; }\n+        println!(\"{}\", msg);\n+    }\n+\n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n@@ -699,6 +750,12 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n+    /// Returns true if this is a no-std `target`, if defined\n+    fn no_std(&self, target: Interned<String>) -> Option<bool> {\n+        self.config.target_config.get(&target)\n+            .map(|t| t.no_std)\n+    }\n+\n     /// Returns whether the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n     fn remote_tested(&self, target: Interned<String>) -> bool {\n@@ -920,7 +977,7 @@ impl Build {\n     pub fn fold_output<D, F>(&self, name: F) -> Option<OutputFolder>\n         where D: Into<String>, F: FnOnce() -> D\n     {\n-        if self.ci_env == CiEnv::Travis {\n+        if !self.config.dry_run && self.ci_env == CiEnv::Travis {\n             Some(OutputFolder::new(name().into()))\n         } else {\n             None\n@@ -968,8 +1025,173 @@ impl Build {\n         }\n         ret\n     }\n+\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<PathBuf> {\n+        if self.config.dry_run {\n+            return Vec::new();\n+        }\n+\n+        let mut paths = Vec::new();\n+        let mut contents = Vec::new();\n+        t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+        // This is the method we use for extracting paths from the stamp file passed to us. See\n+        // run_cargo for more information (in compile.rs).\n+        for part in contents.split(|b| *b == 0) {\n+            if part.is_empty() {\n+                continue\n+            }\n+            let path = PathBuf::from(t!(str::from_utf8(part)));\n+            paths.push(path);\n+        }\n+        paths\n+    }\n+\n+    /// Copies a file from `src` to `dst`\n+    pub fn copy(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        let _ = fs::remove_file(&dst);\n+        // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n+        // windows), but if that fails just fall back to a slow `copy` operation.\n+        if let Ok(()) = fs::hard_link(src, dst) {\n+            return\n+        }\n+        if let Err(e) = fs::copy(src, dst) {\n+            panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n+                dst.display(), e)\n+        }\n+        let metadata = t!(src.metadata());\n+        t!(fs::set_permissions(dst, metadata.permissions()));\n+        let atime = FileTime::from_last_access_time(&metadata);\n+        let mtime = FileTime::from_last_modification_time(&metadata);\n+        t!(filetime::set_file_times(dst, atime, mtime));\n+    }\n+\n+    /// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n+    /// new string for each replacement.)\n+    pub fn replace_in_file(&self, path: &Path, replacements: &[(&str, &str)]) {\n+        if self.config.dry_run { return; }\n+        let mut contents = String::new();\n+        let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n+        t!(file.read_to_string(&mut contents));\n+        for &(target, replacement) in replacements {\n+            contents = contents.replace(target, replacement);\n+        }\n+        t!(file.seek(SeekFrom::Start(0)));\n+        t!(file.set_len(0));\n+        t!(file.write_all(contents.as_bytes()));\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called.\n+    pub fn cp_r(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        for f in t!(fs::read_dir(src)) {\n+            let f = t!(f);\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            if t!(f.file_type()).is_dir() {\n+                t!(fs::create_dir_all(&dst));\n+                self.cp_r(&path, &dst);\n+            } else {\n+                let _ = fs::remove_file(&dst);\n+                self.copy(&path, &dst);\n+            }\n+        }\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called. Unwanted files or directories can be skipped\n+    /// by returning `false` from the filter function.\n+    pub fn cp_filtered(&self, src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n+        // Immediately recurse with an empty relative path\n+        self.recurse_(src, dst, Path::new(\"\"), filter)\n+    }\n+\n+    // Inner function does the actual work\n+    fn recurse_(&self, src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n+        for f in self.read_dir(src) {\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            let relative = relative.join(name);\n+            // Only copy file or directory if the filter function returns true\n+            if filter(&relative) {\n+                if t!(f.file_type()).is_dir() {\n+                    let _ = fs::remove_dir_all(&dst);\n+                    self.create_dir(&dst);\n+                    self.recurse_(&path, &dst, &relative, filter);\n+                } else {\n+                    let _ = fs::remove_file(&dst);\n+                    self.copy(&path, &dst);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn copy_to_folder(&self, src: &Path, dest_folder: &Path) {\n+        let file_name = src.file_name().unwrap();\n+        let dest = dest_folder.join(file_name);\n+        self.copy(src, &dest);\n+    }\n+\n+    fn install(&self, src: &Path, dstdir: &Path, perms: u32) {\n+        if self.config.dry_run { return; }\n+        let dst = dstdir.join(src.file_name().unwrap());\n+        t!(fs::create_dir_all(dstdir));\n+        drop(fs::remove_file(&dst));\n+        {\n+            let mut s = t!(fs::File::open(&src));\n+            let mut d = t!(fs::File::create(&dst));\n+            io::copy(&mut s, &mut d).expect(\"failed to copy\");\n+        }\n+        chmod(&dst, perms);\n+    }\n+\n+    fn create(&self, path: &Path, s: &str) {\n+        if self.config.dry_run { return; }\n+        t!(fs::write(path, s));\n+    }\n+\n+    fn read(&self, path: &Path) -> String {\n+        if self.config.dry_run { return String::new(); }\n+        t!(fs::read_string(path))\n+    }\n+\n+    fn create_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::create_dir_all(dir))\n+    }\n+\n+    fn remove_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::remove_dir_all(dir))\n+    }\n+\n+    fn read_dir(&self, dir: &Path) -> impl Iterator<Item=fs::DirEntry> {\n+        let iter = match fs::read_dir(dir) {\n+            Ok(v) => v,\n+            Err(_) if self.config.dry_run => return vec![].into_iter(),\n+            Err(err) => panic!(\"could not read dir {:?}: {:?}\", dir, err),\n+        };\n+        iter.map(|e| t!(e)).collect::<Vec<_>>().into_iter()\n+    }\n+\n+    fn remove(&self, f: &Path) {\n+        if self.config.dry_run { return; }\n+        fs::remove_file(f).unwrap_or_else(|_| panic!(\"failed to remove {:?}\", f));\n+    }\n }\n \n+#[cfg(unix)]\n+fn chmod(path: &Path, perms: u32) {\n+    use std::os::unix::fs::*;\n+    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n+}\n+#[cfg(windows)]\n+fn chmod(_path: &Path, _perms: u32) {}\n+\n+\n impl<'a> Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {\n         self.stage = stage;"}, {"sha": "bcf2f6a675e02715340fcd22a0350c9d264703ef", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -85,5 +85,12 @@ check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n \t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-musl\n \n+TESTS_IN_2 := src/test/run-pass src/test/compile-fail src/test/run-pass-fulldeps\n+\n+appveyor-subset-1:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2:%=--exclude %)\n+appveyor-subset-2:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2)\n+\n \n .PHONY: dist"}, {"sha": "db5891afd6b1fa59ac73c7c7a9590511d64299c4", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -106,8 +106,8 @@ impl Step for Llvm {\n \n         let _folder = build.fold_output(|| \"llvm\");\n         let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n-        println!(\"Building {}LLVM for {}\", descriptor, target);\n-        let _time = util::timeit();\n+        build.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n+        let _time = util::timeit(&build);\n         t!(fs::create_dir_all(&out_dir));\n \n         // http://llvm.org/docs/CMake.html\n@@ -217,6 +217,11 @@ impl Step for Llvm {\n         //        libraries here, e.g. we just want a few components and a few\n         //        tools. Figure out how to filter them down and only build the right\n         //        tools and libs on all platforms.\n+\n+        if builder.config.dry_run {\n+            return build_llvm_config;\n+        }\n+\n         cfg.build();\n \n         t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n@@ -230,6 +235,10 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n         return\n     }\n \n+    if build.config.dry_run {\n+        return;\n+    }\n+\n     let mut cmd = Command::new(llvm_config);\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2)\n@@ -336,6 +345,9 @@ impl Step for Lld {\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder) -> PathBuf {\n+        if builder.config.dry_run {\n+            return PathBuf::from(\"lld-out-dir-test-gen\");\n+        }\n         let target = self.target;\n         let build = builder.build;\n \n@@ -351,8 +363,8 @@ impl Step for Lld {\n         }\n \n         let _folder = build.fold_output(|| \"lld\");\n-        println!(\"Building LLD for {}\", target);\n-        let _time = util::timeit();\n+        build.info(&format!(\"Building LLD for {}\", target));\n+        let _time = util::timeit(&build);\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cmake::Config::new(build.src.join(\"src/tools/lld\"));\n@@ -389,6 +401,9 @@ impl Step for TestHelpers {\n     /// Compiles the `rust_test_helpers.c` library which we used in various\n     /// `run-pass` test suites for ABI testing.\n     fn run(self, builder: &Builder) {\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let build = builder.build;\n         let target = self.target;\n         let dst = build.test_helpers_out(target);\n@@ -398,7 +413,7 @@ impl Step for TestHelpers {\n         }\n \n         let _folder = build.fold_output(|| \"build_test_helpers\");\n-        println!(\"Building test helpers\");\n+        build.info(&format!(\"Building test helpers\"));\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();\n \n@@ -441,6 +456,9 @@ impl Step for Openssl {\n     }\n \n     fn run(self, builder: &Builder) {\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let build = builder.build;\n         let target = self.target;\n         let out = match build.openssl_dir(target) {\n@@ -591,11 +609,11 @@ impl Step for Openssl {\n             configure.arg(\"no-asm\");\n         }\n         configure.current_dir(&obj);\n-        println!(\"Configuring openssl for {}\", target);\n+        build.info(&format!(\"Configuring openssl for {}\", target));\n         build.run_quiet(&mut configure);\n-        println!(\"Building openssl for {}\", target);\n+        build.info(&format!(\"Building openssl for {}\", target));\n         build.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n-        println!(\"Installing openssl for {}\", target);\n+        build.info(&format!(\"Installing openssl for {}\", target));\n         build.run_quiet(Command::new(\"make\").arg(\"install\").arg(\"-j1\").current_dir(&obj));\n \n         let mut f = t!(File::create(&stamp));"}, {"sha": "1b1cec5f18c07d530795f35ee5df4d4faa8145e8", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -169,6 +169,19 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n+        if target.contains(\"-none-\") {\n+            if build.no_std(*target).is_none() {\n+                let target = build.config.target_config.entry(target.clone())\n+                    .or_insert(Default::default());\n+\n+                target.no_std = true;\n+            }\n+\n+            if build.no_std(*target) == Some(false) {\n+                panic!(\"All the *-none-* targets are no-std targets\")\n+            }\n+        }\n+\n         // Make sure musl-root is valid\n         if target.contains(\"musl\") {\n             // If this is a native target (host is also musl) and no musl-root is given,"}, {"sha": "c175d2c69016f926ff6d24cdc74e97eb408b7d67", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 83, "deletions": 56, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -109,11 +109,11 @@ impl Step for Linkcheck {\n         let build = builder.build;\n         let host = self.host;\n \n-        println!(\"Linkcheck ({})\", host);\n+        build.info(&format!(\"Linkcheck ({})\", host));\n \n         builder.default_doc(None);\n \n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         try_run(build, builder.tool_cmd(Tool::Linkchecker)\n                               .arg(build.out.join(host).join(\"doc\")));\n     }\n@@ -164,7 +164,7 @@ impl Step for Cargotest {\n         let out_dir = build.out.join(\"ct\");\n         t!(fs::create_dir_all(&out_dir));\n \n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(build, cmd.arg(&build.initial_cargo)\n                           .arg(&out_dir)\n@@ -509,7 +509,7 @@ impl Step for RustdocJS {\n             });\n             builder.run(&mut command);\n         } else {\n-            println!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\");\n+            builder.info(&format!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"));\n         }\n     }\n }\n@@ -530,8 +530,6 @@ impl Step for Tidy {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        let _folder = build.fold_output(|| \"tidy\");\n-        println!(\"tidy check\");\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(build.src.join(\"src\"));\n         cmd.arg(&build.initial_cargo);\n@@ -541,6 +539,9 @@ impl Step for Tidy {\n         if build.config.quiet_tests {\n             cmd.arg(\"--quiet\");\n         }\n+\n+        let _folder = build.fold_output(|| \"tidy\");\n+        builder.info(&format!(\"tidy check\"));\n         try_run(build, &mut cmd);\n     }\n \n@@ -759,12 +760,18 @@ test!(RunFailFullDepsPretty {\n     host: true\n });\n \n-host_test!(RunMake {\n+default_test!(RunMake {\n     path: \"src/test/run-make\",\n     mode: \"run-make\",\n     suite: \"run-make\"\n });\n \n+host_test!(RunMakeFullDeps {\n+    path: \"src/test/run-make-fulldeps\",\n+    mode: \"run-make\",\n+    suite: \"run-make-fulldeps\"\n+});\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n     compiler: Compiler,\n@@ -827,18 +834,14 @@ impl Step for Compiletest {\n             // FIXME: Does pretty need librustc compiled? Note that there are\n             // fulldeps test suites with mode = pretty as well.\n             mode == \"pretty\" ||\n-            mode == \"rustdoc\" ||\n-            mode == \"run-make\" {\n+            mode == \"rustdoc\" {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n         builder.ensure(compile::Test { compiler, target });\n         builder.ensure(native::TestHelpers { target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n-        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n-        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target);\n         let mut cmd = builder.tool_cmd(Tool::Compiletest);\n \n         // compiletest currently has... a lot of arguments, so let's just pass all\n@@ -849,7 +852,7 @@ impl Step for Compiletest {\n         cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n \n         // Avoid depending on rustdoc when we don't need it.\n-        if mode == \"rustdoc\" || mode == \"run-make\" {\n+        if mode == \"rustdoc\" || (mode == \"run-make\" && suite.ends_with(\"fulldeps\")) {\n             cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n         }\n \n@@ -923,15 +926,17 @@ impl Step for Compiletest {\n                 target: build.config.build,\n                 emscripten: false,\n             });\n-            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n-            cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            if !build.config.dry_run {\n+                let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+                cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            }\n             if !build.is_rust_llvm(target) {\n                 cmd.arg(\"--system-llvm\");\n             }\n \n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n-            if suite == \"run-make\" {\n+            if !build.config.dry_run && suite == \"run-make-fulldeps\" {\n                 let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n                 cmd.arg(\"--cc\").arg(build.cc(target))\n@@ -944,12 +949,13 @@ impl Step for Compiletest {\n                 }\n             }\n         }\n-        if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally don't work without LLVM\");\n+        if suite == \"run-make-fulldeps\" && !build.config.llvm_enabled {\n+            builder.info(\n+                &format!(\"Ignoring run-make test suite as they generally don't work without LLVM\"));\n             return;\n         }\n \n-        if suite != \"run-make\" {\n+        if suite != \"run-make-fulldeps\" {\n             cmd.arg(\"--cc\").arg(\"\")\n                .arg(\"--cxx\").arg(\"\")\n                .arg(\"--cflags\").arg(\"\")\n@@ -998,7 +1004,10 @@ impl Step for Compiletest {\n \n         build.ci_env.force_coloring_in_ci(&mut cmd);\n \n-        let _time = util::timeit();\n+        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n+        builder.info(&format!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+                 suite, mode, &compiler.host, target));\n+        let _time = util::timeit(&build);\n         try_run(build, &mut cmd);\n     }\n }\n@@ -1033,9 +1042,10 @@ impl Step for DocTest {\n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n         let mut stack = vec![build.src.join(self.path)];\n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         let _folder = build.fold_output(|| format!(\"test_{}\", self.name));\n \n+        let mut files = Vec::new();\n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n                 stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n@@ -1052,7 +1062,13 @@ impl Step for DocTest {\n                 continue;\n             }\n \n-            let test_result = markdown_test(builder, compiler, &p);\n+            files.push(p);\n+        }\n+\n+        files.sort();\n+\n+        for file in files {\n+            let test_result = markdown_test(builder, compiler, &file);\n             if self.is_ext_doc {\n                 let toolstate = if test_result {\n                     ToolState::TestPass\n@@ -1142,34 +1158,39 @@ impl Step for ErrorIndex {\n \n         builder.ensure(compile::Std { compiler, target: compiler.host });\n \n-        let _folder = build.fold_output(|| \"test_error_index\");\n-        println!(\"Testing error-index stage{}\", compiler.stage);\n-\n         let dir = testdir(build, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         let output = dir.join(\"error-index.md\");\n \n-        let _time = util::timeit();\n-        build.run(builder.tool_cmd(Tool::ErrorIndex)\n-                    .arg(\"markdown\")\n-                    .arg(&output)\n-                    .env(\"CFG_BUILD\", &build.build)\n-                    .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir()));\n+        let mut tool = builder.tool_cmd(Tool::ErrorIndex);\n+        tool.arg(\"markdown\")\n+            .arg(&output)\n+            .env(\"CFG_BUILD\", &build.build)\n+            .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir());\n+\n \n+        let _folder = build.fold_output(|| \"test_error_index\");\n+        build.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n+        let _time = util::timeit(&build);\n+        build.run(&mut tool);\n         markdown_test(builder, compiler, &output);\n     }\n }\n \n fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n     let build = builder.build;\n-    let mut file = t!(File::open(markdown));\n-    let mut contents = String::new();\n-    t!(file.read_to_string(&mut contents));\n-    if !contents.contains(\"```\") {\n-        return true;\n+    match File::open(markdown) {\n+        Ok(mut file) => {\n+            let mut contents = String::new();\n+            t!(file.read_to_string(&mut contents));\n+            if !contents.contains(\"```\") {\n+                return true;\n+            }\n+        }\n+        Err(_) => {},\n     }\n \n-    println!(\"doc tests for: {}\", markdown.display());\n+    build.info(&format!(\"doc tests for: {}\", markdown.display()));\n     let mut cmd = builder.rustdoc_cmd(compiler.host);\n     build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n@@ -1400,11 +1421,6 @@ impl Step for Crate {\n             }\n             _ => panic!(\"can only test libraries\"),\n         };\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n-        });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n-                &compiler.host, target);\n \n         // Build up the base `cargo test` command.\n         //\n@@ -1436,8 +1452,6 @@ impl Step for Crate {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _time = util::timeit();\n-\n         if target.contains(\"emscripten\") {\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n                       build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n@@ -1446,8 +1460,8 @@ impl Step for Crate {\n             // The javascript shim implements the syscall interface so that test\n             // output can be correctly reported.\n             if !build.config.wasm_syscall {\n-                println!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n-                          test output may not be visible.\");\n+                build.info(&format!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n+                          test output may not be visible.\"));\n             }\n \n             // On the wasm32-unknown-unknown target we're using LTO which is\n@@ -1465,6 +1479,13 @@ impl Step for Crate {\n                       format!(\"{} run\",\n                               builder.tool_exe(Tool::RemoteTestClient).display()));\n         }\n+\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n+        });\n+        build.info(&format!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n+                &compiler.host, target));\n+        let _time = util::timeit(&build);\n         try_run(build, &mut cargo);\n     }\n }\n@@ -1513,12 +1534,6 @@ impl Step for CrateRustdoc {\n                                                  target,\n                                                  test_kind.subcommand(),\n                                                  \"src/tools/rustdoc\");\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n-        });\n-        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target);\n-\n         if test_kind.subcommand() == \"test\" && !build.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n@@ -1532,7 +1547,12 @@ impl Step for CrateRustdoc {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _time = util::timeit();\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n+        });\n+        build.info(&format!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n+                &compiler.host, target));\n+        let _time = util::timeit(&build);\n \n         try_run(build, &mut cargo);\n     }\n@@ -1579,7 +1599,7 @@ impl Step for RemoteCopyLibs {\n \n         builder.ensure(compile::Test { compiler, target });\n \n-        println!(\"REMOTE copy libs to emulator ({})\", target);\n+        build.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(build.out.join(\"tmp\")));\n \n         let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n@@ -1627,7 +1647,7 @@ impl Step for Distcheck {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        println!(\"Distcheck\");\n+        build.info(&format!(\"Distcheck\"));\n         let dir = build.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n@@ -1651,7 +1671,7 @@ impl Step for Distcheck {\n                          .current_dir(&dir));\n \n         // Now make sure that rust-src has all of libstd's dependencies\n-        println!(\"Distcheck rust-src\");\n+        build.info(&format!(\"Distcheck rust-src\"));\n         let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n@@ -1686,9 +1706,16 @@ impl Step for Bootstrap {\n         let mut cmd = Command::new(&build.initial_cargo);\n         cmd.arg(\"test\")\n            .current_dir(build.src.join(\"src/bootstrap\"))\n+           .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n            .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n            .env(\"RUSTC\", &build.initial_rustc);\n+        if let Some(flags) = option_env!(\"RUSTFLAGS\") {\n+            // Use the same rustc flags for testing as for \"normal\" compilation,\n+            // so that Cargo doesn\u2019t recompile the entire dependency graph every time:\n+            // https://github.com/rust-lang/rust/issues/49215\n+            cmd.env(\"RUSTFLAGS\", flags);\n+        }\n         if !build.fail_fast {\n             cmd.arg(\"--no-fail-fast\");\n         }"}, {"sha": "93b6153fcb2f8c58c2758f3a6284e54e5867df83", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 88, "deletions": 10, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -17,7 +17,7 @@ use std::slice::SliceConcatExt;\n use Mode;\n use Compiler;\n use builder::{Step, RunConfig, ShouldRun, Builder};\n-use util::{copy, exe, add_lib_path};\n+use util::{exe, add_lib_path};\n use compile::{self, libtest_stamp, libstd_stamp, librustc_stamp};\n use native;\n use channel::GitInfo;\n@@ -112,12 +112,85 @@ impl Step for ToolBuild {\n             Mode::Tool => panic!(\"unexpected Mode::Tool for tool build\")\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n-        println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n-\n         let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n         cargo.arg(\"--features\").arg(self.extra_features.join(\" \"));\n-        let is_expected = build.try_run(&mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n+        build.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n+        let mut duplicates = Vec::new();\n+        let is_expected = compile::stream_cargo(build, &mut cargo, &mut |msg| {\n+            // Only care about big things like the RLS/Cargo for now\n+            if tool != \"rls\" && tool != \"cargo\" {\n+                return\n+            }\n+            let (id, features, filenames) = match msg {\n+                compile::CargoMessage::CompilerArtifact {\n+                    package_id,\n+                    features,\n+                    filenames\n+                } => {\n+                    (package_id, features, filenames)\n+                }\n+                _ => return,\n+            };\n+            let features = features.iter().map(|s| s.to_string()).collect::<Vec<_>>();\n+\n+            for path in filenames {\n+                let val = (tool, PathBuf::from(&*path), features.clone());\n+                // we're only interested in deduplicating rlibs for now\n+                if val.1.extension().and_then(|s| s.to_str()) != Some(\"rlib\") {\n+                    continue\n+                }\n+\n+                // Don't worry about libs that turn out to be host dependencies\n+                // or build scripts, we only care about target dependencies that\n+                // are in `deps`.\n+                if let Some(maybe_target) = val.1\n+                    .parent()                   // chop off file name\n+                    .and_then(|p| p.parent())   // chop off `deps`\n+                    .and_then(|p| p.parent())   // chop off `release`\n+                    .and_then(|p| p.file_name())\n+                    .and_then(|p| p.to_str())\n+                {\n+                    if maybe_target != &*target {\n+                        continue\n+                    }\n+                }\n+\n+                let mut artifacts = build.tool_artifacts.borrow_mut();\n+                let prev_artifacts = artifacts\n+                    .entry(target)\n+                    .or_insert_with(Default::default);\n+                if let Some(prev) = prev_artifacts.get(&*id) {\n+                    if prev.1 != val.1 {\n+                        duplicates.push((\n+                            id.to_string(),\n+                            val,\n+                            prev.clone(),\n+                        ));\n+                    }\n+                    return\n+                }\n+                prev_artifacts.insert(id.to_string(), val);\n+            }\n+        });\n+\n+        if is_expected && duplicates.len() != 0 {\n+            println!(\"duplicate artfacts found when compiling a tool, this \\\n+                      typically means that something was recompiled because \\\n+                      a transitive dependency has different features activated \\\n+                      than in a previous build:\\n\");\n+            for (id, cur, prev) in duplicates {\n+                println!(\"  {}\", id);\n+                println!(\"    `{}` enabled features {:?} at {:?}\",\n+                         cur.0, cur.2, cur.1);\n+                println!(\"    `{}` enabled features {:?} at {:?}\",\n+                         prev.0, prev.2, prev.1);\n+            }\n+            println!(\"\");\n+            panic!(\"tools should not compile multiple copies of the same crate\");\n+        }\n+\n         build.save_toolstate(tool, if is_expected {\n             ToolState::TestFail\n         } else {\n@@ -134,7 +207,7 @@ impl Step for ToolBuild {\n             let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n                 .join(exe(tool, &compiler.host));\n             let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n-            copy(&cargo_out, &bin);\n+            build.copy(&cargo_out, &bin);\n             Some(bin)\n         }\n     }\n@@ -338,9 +411,10 @@ impl Step for Rustdoc {\n         };\n \n         builder.ensure(compile::Rustc { compiler: build_compiler, target });\n-\n-        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n-        println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n+        builder.ensure(compile::Rustc {\n+            compiler: build_compiler,\n+            target: builder.build.build,\n+        });\n \n         let mut cargo = prepare_tool_cargo(builder,\n                                            build_compiler,\n@@ -352,7 +426,11 @@ impl Step for Rustdoc {\n         cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n              .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n \n+        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n+        build.info(&format!(\"Building rustdoc for stage{} ({})\",\n+            target_compiler.stage, target_compiler.host));\n         build.run(&mut cargo);\n+\n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n         // rustdoc a different name.\n@@ -366,7 +444,7 @@ impl Step for Rustdoc {\n             t!(fs::create_dir_all(&bindir));\n             let bin_rustdoc = bindir.join(exe(\"rustdoc\", &*target_compiler.host));\n             let _ = fs::remove_file(&bin_rustdoc);\n-            copy(&tool_rustdoc, &bin_rustdoc);\n+            build.copy(&tool_rustdoc, &bin_rustdoc);\n             bin_rustdoc\n         } else {\n             tool_rustdoc"}, {"sha": "f8c7032369890b8472a66083dee9ae9b467d6abe", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 20, "deletions": 109, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -15,13 +15,14 @@\n \n use std::env;\n use std::str;\n-use std::fs::{self, File, OpenOptions};\n-use std::io::{self, Read, Write, Seek, SeekFrom};\n+use std::fs;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n \n-use filetime::{self, FileTime};\n+use config::Config;\n+use Build;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n@@ -32,102 +33,6 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Copies a file from `src` to `dst`\n-pub fn copy(src: &Path, dst: &Path) {\n-    let _ = fs::remove_file(&dst);\n-    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n-    // windows), but if that fails just fall back to a slow `copy` operation.\n-    if let Ok(()) = fs::hard_link(src, dst) {\n-        return\n-    }\n-    if let Err(e) = fs::copy(src, dst) {\n-        panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n-               dst.display(), e)\n-    }\n-    let metadata = t!(src.metadata());\n-    t!(fs::set_permissions(dst, metadata.permissions()));\n-    let atime = FileTime::from_last_access_time(&metadata);\n-    let mtime = FileTime::from_last_modification_time(&metadata);\n-    t!(filetime::set_file_times(dst, atime, mtime));\n-}\n-\n-/// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n-/// new string for each replacement.)\n-pub fn replace_in_file(path: &Path, replacements: &[(&str, &str)]) {\n-    let mut contents = String::new();\n-    let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n-    t!(file.read_to_string(&mut contents));\n-    for &(target, replacement) in replacements {\n-        contents = contents.replace(target, replacement);\n-    }\n-    t!(file.seek(SeekFrom::Start(0)));\n-    t!(file.set_len(0));\n-    t!(file.write_all(contents.as_bytes()));\n-}\n-\n-pub fn read_stamp_file(stamp: &Path) -> Vec<PathBuf> {\n-    let mut paths = Vec::new();\n-    let mut contents = Vec::new();\n-    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n-    // This is the method we use for extracting paths from the stamp file passed to us. See\n-    // run_cargo for more information (in compile.rs).\n-    for part in contents.split(|b| *b == 0) {\n-        if part.is_empty() {\n-            continue\n-        }\n-        let path = PathBuf::from(t!(str::from_utf8(part)));\n-        paths.push(path);\n-    }\n-    paths\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called.\n-pub fn cp_r(src: &Path, dst: &Path) {\n-    for f in t!(fs::read_dir(src)) {\n-        let f = t!(f);\n-        let path = f.path();\n-        let name = path.file_name().unwrap();\n-        let dst = dst.join(name);\n-        if t!(f.file_type()).is_dir() {\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&path, &dst);\n-        } else {\n-            let _ = fs::remove_file(&dst);\n-            copy(&path, &dst);\n-        }\n-    }\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called. Unwanted files or directories can be skipped\n-/// by returning `false` from the filter function.\n-pub fn cp_filtered(src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n-    // Inner function does the actual work\n-    fn recurse(src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n-        for f in t!(fs::read_dir(src)) {\n-            let f = t!(f);\n-            let path = f.path();\n-            let name = path.file_name().unwrap();\n-            let dst = dst.join(name);\n-            let relative = relative.join(name);\n-            // Only copy file or directory if the filter function returns true\n-            if filter(&relative) {\n-                if t!(f.file_type()).is_dir() {\n-                    let _ = fs::remove_dir_all(&dst);\n-                    t!(fs::create_dir(&dst));\n-                    recurse(&path, &dst, &relative, filter);\n-                } else {\n-                    let _ = fs::remove_file(&dst);\n-                    copy(&path, &dst);\n-                }\n-            }\n-        }\n-    }\n-    // Immediately recurse with an empty relative path\n-    recurse(src, dst, Path::new(\"\"), filter)\n-}\n-\n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n pub fn exe(name: &str, target: &str) -> String {\n@@ -196,25 +101,28 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n     buf\n }\n \n-pub struct TimeIt(Instant);\n+pub struct TimeIt(bool, Instant);\n \n /// Returns an RAII structure that prints out how long it took to drop.\n-pub fn timeit() -> TimeIt {\n-    TimeIt(Instant::now())\n+pub fn timeit(build: &Build) -> TimeIt {\n+    TimeIt(build.config.dry_run, Instant::now())\n }\n \n impl Drop for TimeIt {\n     fn drop(&mut self) {\n-        let time = self.0.elapsed();\n-        println!(\"\\tfinished in {}.{:03}\",\n-                 time.as_secs(),\n-                 time.subsec_nanos() / 1_000_000);\n+        let time = self.1.elapsed();\n+        if !self.0 {\n+            println!(\"\\tfinished in {}.{:03}\",\n+                    time.as_secs(),\n+                    time.subsec_nanos() / 1_000_000);\n+        }\n     }\n }\n \n /// Symlinks two directories, using junctions on Windows and normal symlinks on\n /// Unix.\n-pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n+pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n+    if config.dry_run { return Ok(()); }\n     let _ = fs::remove_dir(dest);\n     return symlink_dir_inner(src, dest);\n \n@@ -288,6 +196,7 @@ pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n                                nOutBufferSize: DWORD,\n                                lpBytesReturned: LPDWORD,\n                                lpOverlapped: LPOVERLAPPED) -> BOOL;\n+            fn CloseHandle(hObject: HANDLE) -> BOOL;\n         }\n \n         fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n@@ -341,11 +250,13 @@ pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n                                       &mut ret,\n                                       ptr::null_mut());\n \n-            if res == 0 {\n+            let out = if res == 0 {\n                 Err(io::Error::last_os_error())\n             } else {\n                 Ok(())\n-            }\n+            };\n+            CloseHandle(h);\n+            out\n         }\n     }\n }"}, {"sha": "01d704f816bbc8fc00813d2636f3fe44a847db35", "filename": "src/build_helper/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbuild_helper%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbuild_helper%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2FCargo.toml?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -6,6 +6,3 @@ authors = [\"The Rust Project Developers\"]\n [lib]\n name = \"build_helper\"\n path = \"lib.rs\"\n-\n-[dependencies]\n-filetime = \"0.1\""}, {"sha": "5a12afd03e13b820c891aec362d9b6f3c5683f70", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -10,14 +10,11 @@\n \n #![deny(warnings)]\n \n-extern crate filetime;\n-\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::{fs, env};\n-\n-use filetime::FileTime;\n+use std::time::{SystemTime, UNIX_EPOCH};\n \n /// A helper macro to `unwrap` a result except also print out details like:\n ///\n@@ -137,10 +134,8 @@ pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n }\n \n /// Returns the last-modified time for `path`, or zero if it doesn't exist.\n-pub fn mtime(path: &Path) -> FileTime {\n-    fs::metadata(path).map(|f| {\n-        FileTime::from_last_modification_time(&f)\n-    }).unwrap_or(FileTime::zero())\n+pub fn mtime(path: &Path) -> SystemTime {\n+    fs::metadata(path).and_then(|f| f.modified()).unwrap_or(UNIX_EPOCH)\n }\n \n /// Returns whether `dst` is up to date given that the file or files in `src`\n@@ -157,9 +152,9 @@ pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n         Err(e) => panic!(\"source {:?} failed to get metadata: {}\", src, e),\n     };\n     if meta.is_dir() {\n-        dir_up_to_date(src, &threshold)\n+        dir_up_to_date(src, threshold)\n     } else {\n-        FileTime::from_last_modification_time(&meta) <= threshold\n+        meta.modified().unwrap_or(UNIX_EPOCH) <= threshold\n     }\n }\n \n@@ -226,13 +221,13 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str) -> Result<NativeLibBoiler\n                            search_path)\n }\n \n-fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {\n+fn dir_up_to_date(src: &Path, threshold: SystemTime) -> bool {\n     t!(fs::read_dir(src)).map(|e| t!(e)).all(|e| {\n         let meta = t!(e.metadata());\n         if meta.is_dir() {\n             dir_up_to_date(&e.path(), threshold)\n         } else {\n-            FileTime::from_last_modification_time(&meta) < *threshold\n+            meta.modified().unwrap_or(UNIX_EPOCH) < threshold\n         }\n     })\n }"}, {"sha": "cddfa557f6aed7e43ac04c326cfe6509417e0c0d", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -32,5 +32,5 @@ ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=aarch64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e00c23dac89b087dd66edbec4e1ff6db704cb9fd", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -26,7 +26,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --i686-linux-android-ndk=/android/ndk/x86-14 \\\n       --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n-      --x86_64-linux-android-ndk=/android/ndk/x86_64-21\n+      --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n+      --disable-docs\n \n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n "}, {"sha": "6ddc5c1e04ae35223c38a6002ac6ef996f23a3e0", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -32,5 +32,5 @@ ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabi\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e4d4b2feeec40270c84f97b3277bfc4dfd6bb911", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -32,5 +32,5 @@ ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "99fe7bd7b8f7871fc5aa607f00ec2fb2103bfcb5", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -32,5 +32,5 @@ ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=armv7-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e12bed3abc5ad05dc401cb4d773cdb922bb32aac", "filename": "src/ci/docker/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -32,7 +32,8 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-i586=/musl-i586 \\\n       --musl-root-i686=/musl-i686 \\\n-      --enable-extended\n+      --enable-extended \\\n+      --disable-docs\n \n # Newer binutils broke things on some vms/distros (i.e., linking against\n # unknown relocs disabled by the following flag), so we need to go out of our"}, {"sha": "6f6a663a3309387abf8ec5785f5f1df2f7687aa3", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=i686-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "08020e533ff191ca565868062cef8f7d5ab55967", "filename": "src/ci/docker/dist-i686-linux/build-gcc.sh", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -17,6 +17,23 @@ GCC=4.8.5\n \n curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n cd gcc-$GCC\n+\n+# FIXME(#49246): Remove the `sed` below.\n+#\n+# On 2018 March 21st, two Travis builders' cache for Docker are suddenly invalidated. Normally this\n+# is fine, because we just need to rebuild the Docker image. However, it reveals a network issue:\n+# downloading from `ftp://gcc.gnu.org/` from Travis (using passive mode) often leads to \"Connection\n+# timed out\" error, and even when the download completed, the file is usually corrupted. This causes\n+# nothing to be landed that day.\n+#\n+# We observed that the `gcc-4.8.5.tar.bz2` above can be downloaded successfully, so as a stability\n+# improvement we try to download from the HTTPS mirror instead. Turns out this uncovered the third\n+# bug: the host `gcc.gnu.org` and `cygwin.com` share the same IP, and the TLS certificate of the\n+# latter host is presented to `wget`! Therefore, we choose to download from the insecure HTTP server\n+# instead here.\n+#\n+sed -i'' 's|ftp://gcc\\.gnu\\.org/|http://gcc.gnu.org/|g' ./contrib/download_prerequisites\n+\n ./contrib/download_prerequisites\n mkdir ../gcc-build\n cd ../gcc-build"}, {"sha": "aa31f50ba0343134bfbece006ad3faf6c13afc72", "filename": "src/ci/docker/dist-i686-linux/build-git.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -12,7 +12,7 @@\n set -ex\n source shared.sh\n \n-curl https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n+curl -L https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n \n cd git-2.10.0\n make configure"}, {"sha": "466def1f80fbfd9cbdbf6d86d5e4d98630f1bd1e", "filename": "src/ci/docker/dist-mips-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -22,5 +22,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "2205b733e99f1e5826fa92656fa68a94c509e30e", "filename": "src/ci/docker/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -21,5 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips64-unknown-linux-gnuabi64\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f1d9dad46ea3f6dd58be2443f5caef48940cd3f6", "filename": "src/ci/docker/dist-mips64el-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -22,5 +22,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips64el-unknown-linux-gnuabi64\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ee73e29c76e35926ee5389ecf998f47a29ce4c1a", "filename": "src/ci/docker/dist-mipsel-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -21,5 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mipsel-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f03aff060c1034065c5361930ac2fdf917129320", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -34,7 +34,7 @@ ENV \\\n \n ENV HOSTS=powerpc-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # FIXME(#36150) this will fail the bootstrap. Probably means something bad is"}, {"sha": "bb30210c0563aa5433672b744fab108100aa4f1f", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -35,5 +35,5 @@ ENV \\\n \n ENV HOSTS=powerpc64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ee9e4550483525ada46d587e492b623b07129d6b", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -32,5 +32,5 @@ ENV \\\n \n ENV HOSTS=powerpc64le-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "7ba6fe643c2ae80b9f59bdcdf4197db18fa3c736", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -34,5 +34,5 @@ ENV \\\n \n ENV HOSTS=s390x-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "00366301aa17aba600cb8c4f112a220124daab0c", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -20,7 +20,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   bzip2 \\\n   patch \\\n   libssl-dev \\\n-  pkg-config\n+  pkg-config \\\n+  gcc-arm-none-eabi \\\n+  libnewlib-arm-none-eabi\n \n WORKDIR /build\n \n@@ -66,6 +68,14 @@ RUN env \\\n     bash musl.sh mipsel && \\\n     rm -rf /build/*\n \n+# FIXME(mozilla/sccache#235) this shouldn't be necessary but is currently\n+# necessary to disambiguate the mips compiler with the mipsel compiler. We want\n+# to give these two wrapper scripts (currently identical ones) different hashes\n+# to ensure that sccache understands that they're different compilers.\n+RUN \\\n+  echo \"# a\" >> /usr/local/mips-linux-musl/bin/mips-openwrt-linux-musl-wrapper.sh && \\\n+  echo \"# b\" >> /usr/local/mipsel-linux-musl/bin/mipsel-openwrt-linux-musl-wrapper.sh\n+\n ENV TARGETS=asmjs-unknown-emscripten\n ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n@@ -78,6 +88,10 @@ ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n \n # FIXME: remove armv5te vars after https://github.com/alexcrichton/cc-rs/issues/271\n #        get fixed and cc update\n@@ -95,7 +109,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-aarch64=/musl-aarch64 \\\n       --musl-root-mips=/musl-mips \\\n       --musl-root-mipsel=/musl-mipsel \\\n-      --enable-emscripten\n+      --enable-emscripten \\\n+      --disable-docs\n \n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n "}, {"sha": "e8d6c12de4474284c529a8852863c81eb9ff317f", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -55,5 +55,5 @@ ENV TARGETS=$TARGETS,x86_64-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "698b81a92e935464724259a1e9b659c802351316", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "28c97e8c6dbf9b70987ca9b64c5c49d272add3ea", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -84,7 +84,8 @@ ENV HOSTS=x86_64-unknown-linux-gnu\n ENV RUST_CONFIGURE_ARGS \\\n       --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler\n+      --enable-profiler \\\n+      --enable-compiler-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "08020e533ff191ca565868062cef8f7d5ab55967", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -17,6 +17,23 @@ GCC=4.8.5\n \n curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n cd gcc-$GCC\n+\n+# FIXME(#49246): Remove the `sed` below.\n+#\n+# On 2018 March 21st, two Travis builders' cache for Docker are suddenly invalidated. Normally this\n+# is fine, because we just need to rebuild the Docker image. However, it reveals a network issue:\n+# downloading from `ftp://gcc.gnu.org/` from Travis (using passive mode) often leads to \"Connection\n+# timed out\" error, and even when the download completed, the file is usually corrupted. This causes\n+# nothing to be landed that day.\n+#\n+# We observed that the `gcc-4.8.5.tar.bz2` above can be downloaded successfully, so as a stability\n+# improvement we try to download from the HTTPS mirror instead. Turns out this uncovered the third\n+# bug: the host `gcc.gnu.org` and `cygwin.com` share the same IP, and the TLS certificate of the\n+# latter host is presented to `wget`! Therefore, we choose to download from the insecure HTTP server\n+# instead here.\n+#\n+sed -i'' 's|ftp://gcc\\.gnu\\.org/|http://gcc.gnu.org/|g' ./contrib/download_prerequisites\n+\n ./contrib/download_prerequisites\n mkdir ../gcc-build\n cd ../gcc-build"}, {"sha": "aa31f50ba0343134bfbece006ad3faf6c13afc72", "filename": "src/ci/docker/dist-x86_64-linux/build-git.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -12,7 +12,7 @@\n set -ex\n source shared.sh\n \n-curl https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n+curl -L https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n \n cd git-2.10.0\n make configure"}, {"sha": "06f8a2fbba836de9843927eb40b2392eb704cb0a", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -31,7 +31,8 @@ RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-x86_64=/musl-x86_64 \\\n-      --enable-extended\n+      --enable-extended \\\n+      --disable-docs\n \n # Newer binutils broke things on some vms/distros (i.e., linking against\n # unknown relocs disabled by the following flag), so we need to go out of our"}, {"sha": "a17a7ebc03dd165f92b588d2bf802d3b5d7ec754", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -33,5 +33,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-netbsd\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ea2387b67dbccf9379b5c017e383ef6f61b9c296", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -27,6 +27,21 @@ travis_fold start build_docker\n travis_time_start\n \n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n+    if [ \"$CI\" != \"\" ]; then\n+      cksum=$(find $docker_dir/$image $docker_dir/scripts -type f | \\\n+        sort | \\\n+        xargs cat | \\\n+        sha512sum | \\\n+        awk '{print $1}')\n+      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n+      url=\"https://s3-us-west-1.amazonaws.com/$SCCACHE_BUCKET/docker/$cksum\"\n+      echo \"Attempting to download $s3url\"\n+      set +e\n+      loaded_images=$(curl $url | docker load | sed 's/.* sha/sha/')\n+      set -e\n+      echo \"Downloaded containers:\\n$loaded_images\"\n+    fi\n+\n     dockerfile=\"$docker_dir/$image/Dockerfile\"\n     if [ -x /usr/bin/cygpath ]; then\n         context=\"`cygpath -w $docker_dir`\"\n@@ -40,6 +55,23 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -t rust-ci \\\n       -f \"$dockerfile\" \\\n       \"$context\"\n+\n+    if [ \"$s3url\" != \"\" ]; then\n+      digest=$(docker inspect rust-ci --format '{{.Id}}')\n+      echo \"Built container $digest\"\n+      if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then\n+        echo \"Uploading finished image to $s3url\"\n+        set +e\n+        docker history -q rust-ci | \\\n+          grep -v missing | \\\n+          xargs docker save | \\\n+          gzip | \\\n+          aws s3 cp - $s3url\n+        set -e\n+      else\n+        echo \"Looks like docker image is the same as before, not uploading\"\n+      fi\n+    fi\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n     if [ -n \"$TRAVIS_OS_NAME\" ]; then\n         echo Cannot run disabled images on travis!\n@@ -72,8 +104,6 @@ if [ \"$SCCACHE_BUCKET\" != \"\" ]; then\n     args=\"$args --env SCCACHE_REGION\"\n     args=\"$args --env AWS_ACCESS_KEY_ID\"\n     args=\"$args --env AWS_SECRET_ACCESS_KEY\"\n-    args=\"$args --env SCCACHE_ERROR_LOG=/tmp/sccache/sccache.log\"\n-    args=\"$args --volume $objdir/tmp:/tmp/sccache\"\n else\n     mkdir -p $HOME/.cache/sccache\n     args=\"$args --env SCCACHE_DIR=/sccache --volume $HOME/.cache/sccache:/sccache\""}, {"sha": "da52d08318115eb80a7cc39bb3ffde8e8439dad3", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -13,6 +13,6 @@\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl\n+  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "6c0ec1ad9d4e14879bf787dd3823a5a36d503539", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -26,6 +26,7 @@ ENV RUST_CONFIGURE_ARGS \\\n   --set rust.lld\n \n ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n+  src/test/run-make \\\n   src/test/ui \\\n   src/test/run-pass \\\n   src/test/compile-fail \\"}, {"sha": "ff6ab1013b4c22352c7ef29673099d5ca2755663", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -16,6 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+ENV PARALLEL_CHECK 1\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\"}, {"sha": "7304ed6015cc9042f5e552df3244d45f105d932e", "filename": "src/ci/docker/x86_64-gnu-incremental/Dockerfile", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,22 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n-ENV RUSTFLAGS -Zincremental=/tmp/rust-incr-cache\n-ENV RUST_CHECK_TARGET check\n-ENV CARGO_INCREMENTAL 0"}, {"sha": "f2664e6d196c7afcab810ab0ee15f5e30b14eb64", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -17,6 +17,7 @@ ci_dir=$(cd $(dirname $0) && pwd)\n . \"$ci_dir/shared.sh\"\n \n travis_fold start init_repo\n+travis_time_start\n \n REPO_DIR=\"$1\"\n CACHE_DIR=\"$2\"\n@@ -42,54 +43,39 @@ if grep -q RUST_RELEASE_CHANNEL=beta src/ci/run.sh; then\n   git fetch origin --unshallow beta master\n fi\n \n-travis_fold start update_cache\n-travis_time_start\n-\n-# Update the cache (a pristine copy of the rust source master)\n-retry sh -c \"rm -rf $cache_src_dir && mkdir -p $cache_src_dir && \\\n-    git clone --depth 1 https://github.com/rust-lang/rust.git $cache_src_dir\"\n-if [ -d $cache_src_dir/src/llvm ]; then\n-  (cd $cache_src_dir && git rm src/llvm)\n-fi\n-if [ -d $cache_src_dir/src/llvm-emscripten ]; then\n-  (cd $cache_src_dir && git rm src/llvm-emscripten)\n-fi\n-retry sh -c \"cd $cache_src_dir && \\\n-    git submodule deinit -f . && git submodule sync && git submodule update --init\"\n-\n-travis_fold end update_cache\n-travis_time_finish\n+function fetch_submodule {\n+    local module=$1\n+    local cached=\"download-${module//\\//-}.tar.gz\"\n+    retry sh -c \"rm -f $cached && \\\n+        curl -sSL -o $cached $2\"\n+    mkdir $module\n+    touch \"$module/.git\"\n+    tar -C $module --strip-components=1 -xf $cached\n+    rm $cached\n+}\n \n-travis_fold start update_submodules\n-travis_time_start\n-\n-# Update the submodules of the repo we're in, using the pristine repo as\n-# a cache for any object files\n-# No, `git submodule foreach` won't work:\n-# http://stackoverflow.com/questions/12641469/list-submodules-in-a-git-repository\n+included=\"src/llvm src/llvm-emscripten src/doc/book src/doc/rust-by-example\"\n modules=\"$(git config --file .gitmodules --get-regexp '\\.path$' | cut -d' ' -f2)\"\n-for module in $modules; do\n-    if [ \"$module\" = src/llvm ] || [ \"$module\" = src/llvm-emscripten ]; then\n+modules=($modules)\n+use_git=\"\"\n+urls=\"$(git config --file .gitmodules --get-regexp '\\.url$' | cut -d' ' -f2)\"\n+urls=($urls)\n+for i in ${!modules[@]}; do\n+    module=${modules[$i]}\n+    if [[ \" $included \" = *\" $module \"* ]]; then\n         commit=\"$(git ls-tree HEAD $module | awk '{print $3}')\"\n         git rm $module\n-        retry sh -c \"rm -f $commit.tar.gz && \\\n-            curl -sSL -O https://github.com/rust-lang/llvm/archive/$commit.tar.gz\"\n-        tar -C src/ -xf \"$commit.tar.gz\"\n-        rm \"$commit.tar.gz\"\n-        mv \"src/llvm-$commit\" $module\n-        continue\n-    fi\n-    if [ ! -e \"$cache_src_dir/$module/.git\" ]; then\n-        echo \"WARNING: $module not found in pristine repo\"\n-        retry sh -c \"git submodule deinit -f $module && \\\n-            git submodule update --init --recursive $module\"\n+        url=${urls[$i]}\n+        url=${url/\\.git/}\n+        fetch_submodule $module \"$url/archive/$commit.tar.gz\" &\n         continue\n+    else\n+        use_git=\"$use_git $module\"\n     fi\n-    retry sh -c \"git submodule deinit -f $module && \\\n-        git submodule update --init --recursive --reference $cache_src_dir/$module $module\"\n done\n-\n-travis_fold end update_submodules\n-travis_time_finish\n-\n+retry sh -c \"git submodule deinit -f $use_git && \\\n+    git submodule sync && \\\n+    git submodule update -j 16 --init --recursive $use_git\"\n+wait\n travis_fold end init_repo\n+travis_time_finish"}, {"sha": "44eae0d1800472eb9eb16a2a979fbafaf8584a92", "filename": "src/ci/run.sh", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -25,6 +25,8 @@ source \"$ci_dir/shared.sh\"\n \n if [ \"$TRAVIS\" == \"true\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-quiet-tests\"\n+else\n+    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings\"\n fi\n \n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-sccache\"\n@@ -72,6 +74,13 @@ fi\n # sccache server at the start of the build, but no need to worry if this fails.\n SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n \n+if [ \"$PARALLEL_CHECK\" != \"\" ]; then\n+  $SRC/configure --enable-experimental-parallel-queries\n+  python2.7 ../x.py check\n+  rm -f config.toml\n+  rm -rf build\n+fi\n+\n travis_fold start configure\n travis_time_start\n $SRC/configure $RUST_CONFIGURE_ARGS"}, {"sha": "b889e1e30c5e9953834aa9fa6c982bb28df46ac9", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1 +1 @@\n-Subproject commit 98921e9de849acdaeaed08cfad6758bb89769b7d\n+Subproject commit b889e1e30c5e9953834aa9fa6c982bb28df46ac9"}, {"sha": "2e36831d7e86f9e7bcb022eb7f5ff0d3d03d0969", "filename": "src/doc/index.md", "status": "modified", "additions": 63, "deletions": 46, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -6,55 +6,72 @@ nav {\n }\n </style>\n \n-This page is an overview of the documentation included with your Rust install.\n-Other unofficial documentation may exist elsewhere; for example, the [Rust\n-Learning] project collects documentation from the community, and [Docs.rs]\n-builds documentation for individual Rust packages.\n+Welcome to an overview of the documentation provided by the Rust project.\n+All of these projects are managed by the Docs Team; there are other\n+unofficial documentation resources as well!\n \n-# API Documentation\n+Many of these resources take the form of \"books\"; we collectively call these\n+\"The Rust Bookshelf.\" Some are large, some are small.\n \n-Rust provides a standard library with a number of features; [we host its\n-documentation here][api].\n+## Learn Rust\n \n-# Extended Error Documentation\n+If you'd like to learn Rust, this is the spot for you! All of these resources\n+assume that you have programmed before, but not in any specific language:\n+\n+### The Rust Programming Language\n+\n+Affectionately nicknamed \"the book,\" [The Rust Programming\n+Language](book/index.html) will give you an overview of the language from\n+first principles. You'll build a few projects along the way, and by the end,\n+you'll have a solid grasp of the language.\n+\n+### Rust By Example\n+\n+If reading multiple hundreds of pages about a language isn't your style, then\n+[Rust By Example](rust-by-example/index.html) has you covered. While the book talks about code with\n+a lot of words, RBE shows off a bunch of code, and keeps the talking to a\n+minimum. It also includes exercises!\n+\n+## Use Rust\n+\n+Once you've gotten familliar with the language, these resources can help you\n+when you're actually using it day-to-day.\n+\n+### The Standard Library\n+\n+Rust's standard library has [extensive API documentation](std/index.html),\n+with explanations of how to use various things, as well as example code for\n+accomplishing various tasks.\n+\n+### The Cargo Book\n+\n+[The Cargo Book](cargo/index.html) is a guide to Cargo, Rust's build tool and dependency manager.\n+\n+### The Rustdoc Book\n+\n+[The Rustdoc Book](rustdoc/index.html) describes our documentation tool, `rustdoc`.\n+\n+### Extended Error Listing\n \n Many of Rust's errors come with error codes, and you can request extended\n-diagnostics from the compiler on those errors. We also [have the text of those\n-extended errors on the web][err], if you prefer to read them that way.\n-\n-# The Rust Bookshelf\n-\n-Rust provides a number of book-length sets of documentation, collectively\n-nicknamed 'The Rust Bookshelf.'\n-\n-* [The Rust Programming Language][book] teaches you how to program in Rust.\n-* [Rust By Example][rbe] teaches you how to program in Rust using editable examples.\n-* [The Cargo Book][cargo-book] is a guide to Cargo, Rust's build tool and dependency manager.\n-* [The Unstable Book][unstable-book] has documentation for unstable features.\n-* [The Rustonomicon][nomicon] is your guidebook to the dark arts of unsafe Rust.\n-* [The Reference][ref] is not a formal spec, but is more detailed and comprehensive than the book.\n-* [The Rustdoc Book][rustdoc-book] describes our documentation tool, `rustdoc`.\n-\n-Initially, documentation lands in the Unstable Book, and then, as part of the\n-stabilization process, is moved into the Book, Nomicon, or Reference.\n-\n-Another few words about the reference: it is guaranteed to be accurate, but not\n-complete. We have a policy that features must have documentation to be stabilized,\n-but we did not always have this policy, and so there are some stable things that\n-are not yet in the reference. We're working on back-filling things that landed\n-before this policy was put into place. That work is being tracked\n-[here][refchecklist].\n-\n-[Rust Learning]: https://github.com/ctjhoa/rust-learning\n-[Docs.rs]: https://docs.rs/\n-[api]: std/index.html\n-[ref]: reference/index.html\n-[refchecklist]: https://github.com/rust-lang-nursery/reference/issues/9\n-[err]: error-index.html\n-[book]: book/index.html\n-[rbe]: rust-by-example/index.html\n-[nomicon]: nomicon/index.html\n-[unstable-book]: unstable-book/index.html\n-[rustdoc-book]: rustdoc/index.html\n-[cargo-book]: cargo/index.html\n+diagnostics from the compiler on those errors. You can also [read them\n+here](error-index.html), if you prefer to read them that way.\n+\n+## Master Rust\n+\n+Once you're quite familiar with the language, you may find these advanced\n+resources useful.\n+\n+### The Reference\n+\n+[The Reference](reference/index.html) is not a formal spec, but is more detailed and\n+comprehensive than the book.\n+\n+### The Rustonomicon\n+\n+[The Rustonomicon](nomicon/index.html) is your guidebook to the dark arts of unsafe\n+Rust. It's also sometimes called \"the 'nomicon.\"\n+\n+### The Unstable Book\n \n+[The Unstable Book](unstable-book/index.html) has documentation for unstable features."}, {"sha": "6a8f0a27e9a58c55c89d07bc43a176fdae5e051c", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1 +1 @@\n-Subproject commit ad5ddd62c098d5b424151beda574ae7df2154df1\n+Subproject commit 6a8f0a27e9a58c55c89d07bc43a176fdae5e051c"}, {"sha": "76296346e97c3702974d3398fdb94af9e10111a2", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1 +1 @@\n-Subproject commit 254df654a9b75abf6ca08806535dbe1fad41be3f\n+Subproject commit 76296346e97c3702974d3398fdb94af9e10111a2"}, {"sha": "d5ec87eabe5733cc2348c7dada89fc67c086f391", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1 +1 @@\n-Subproject commit ebb28c95b2ea68b96eddb9e71aff4d32eacc74f0\n+Subproject commit d5ec87eabe5733cc2348c7dada89fc67c086f391"}, {"sha": "46528187c11754eecbf2be1e59434bb2a3acaec5", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -5,3 +5,4 @@\n - [The `#[doc]` attribute](the-doc-attribute.md)\n - [Documentation tests](documentation-tests.md)\n - [Passes](passes.md)\n+- [Unstable features](unstable-features.md)"}, {"sha": "bf97fb4686180f981f7c9e4983606f9910455f1b", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -0,0 +1,375 @@\n+# Unstable features\n+\n+Rustdoc is under active developement, and like the Rust compiler, some features are only available\n+on the nightly releases. Some of these are new and need some more testing before they're able to get\n+released to the world at large, and some of them are tied to features in the Rust compiler that are\n+themselves unstable. Several features here require a matching `#![feature(...)]` attribute to\n+enable, and thus are more fully documented in the [Unstable Book]. Those sections will link over\n+there as necessary.\n+\n+[Unstable Book]: ../unstable-book/index.html\n+\n+## Nightly-gated functionality\n+\n+These features just require a nightly build to operate. Unlike the other features on this page,\n+these don't need to be \"turned on\" with a command-line flag or a `#![feature(...)]` attribute in\n+your crate. This can give them some subtle fallback modes when used on a stable release, so be\n+careful!\n+\n+### Error numbers for `compile-fail` doctests\n+\n+As detailed in [the chapter on documentation tests][doctest-attributes], you can add a\n+`compile_fail` attribute to a doctest to state that the test should fail to compile. However, on\n+nightly, you can optionally add an error number to state that a doctest should emit a specific error\n+number:\n+\n+[doctest-attributes]: documentation-tests.html#attributes\n+\n+``````markdown\n+```compile_fail,E0044\n+extern { fn some_func<T>(x: T); }\n+```\n+``````\n+\n+This is used by the error index to ensure that the samples that correspond to a given error number\n+properly emit that error code. However, these error codes aren't guaranteed to be the only thing\n+that a piece of code emits from version to version, so this is unlikely to be stabilized in the\n+future.\n+\n+Attempting to use these error numbers on stable will result in the code sample being interpreted as\n+plain text.\n+\n+### Linking to items by type\n+\n+As designed in [RFC 1946], Rustdoc can parse paths to items when you use them as links. To resolve\n+these type names, it uses the items currently in-scope, either by declaration or by `use` statement.\n+For modules, the \"active scope\" depends on whether the documentation is written outside the module\n+(as `///` comments on the `mod` statement) or inside the module (at `//!` comments inside the file\n+or block). For all other items, it uses the enclosing module's scope.\n+\n+[RFC 1946]: https://github.com/rust-lang/rfcs/pull/1946\n+\n+For example, in the following code:\n+\n+```rust\n+/// Does the thing.\n+pub fn do_the_thing(_: SomeType) {\n+\tprintln!(\"Let's do the thing!\");\n+}\n+\n+/// Token you use to [`do_the_thing`].\n+pub struct SomeType;\n+```\n+\n+The link to ``[`do_the_thing`]`` in `SomeType`'s docs will properly link to the page for `fn\n+do_the_thing`. Note that here, rustdoc will insert the link target for you, but manually writing the\n+target out also works:\n+\n+```rust\n+pub mod some_module {\n+\t/// Token you use to do the thing.\n+\tpub struct SomeStruct;\n+}\n+\n+/// Does the thing. Requires one [`SomeStruct`] for the thing to work.\n+///\n+/// [`SomeStruct`]: some_module::SomeStruct\n+pub fn do_the_thing(_: some_module::SomeStruct) {\n+\tprintln!(\"Let's do the thing!\");\n+}\n+```\n+\n+For more details, check out [the RFC][RFC 1946], and see [the tracking issue][43466] for more\n+information about what parts of the feature are available.\n+\n+[43466]: https://github.com/rust-lang/rust/issues/43466\n+\n+## Extensions to the `#[doc]` attribute\n+\n+These features operate by extending the `#[doc]` attribute, and thus can be caught by the compiler\n+and enabled with a `#![feature(...)]` attribute in your crate.\n+\n+### Documenting platform-/feature-specific information\n+\n+Because of the way Rustdoc documents a crate, the documentation it creates is specific to the target\n+rustc compiles for. Anything that's specific to any other target is dropped via `#[cfg]` attribute\n+processing early in the compilation process. However, Rustdoc has a trick up its sleeve to handle\n+platform-specific code if it *does* receive it.\n+\n+Because Rustdoc doesn't need to fully compile a crate to binary, it replaces function bodies with\n+`loop {}` to prevent having to process more than necessary. This means that any code within a\n+function that requires platform-specific pieces is ignored. Combined with a special attribute,\n+`#[doc(cfg(...))]`, you can tell Rustdoc exactly which platform something is supposed to run on,\n+ensuring that doctests are only run on the appropriate platforms.\n+\n+The `#[doc(cfg(...))]` attribute has another effect: When Rustdoc renders documentation for that\n+item, it will be accompanied by a banner explaining that the item is only available on certain\n+platforms.\n+\n+As mentioned earlier, getting the items to Rustdoc requires some extra preparation. The standard\n+library adds a `--cfg dox` flag to every Rustdoc command, but the same thing can be accomplished by\n+adding a feature to your Cargo.toml and adding `--feature dox` (or whatever you choose to name the\n+feature) to your `cargo doc` calls.\n+\n+Either way, once you create an environment for the documentation, you can start to augment your\n+`#[cfg]` attributes to allow both the target platform *and* the documentation configuration to leave\n+the item in. For example, `#[cfg(any(windows, feature = \"dox\"))]` will preserve the item either on\n+Windows or during the documentation process. Then, adding a new attribute `#[doc(cfg(windows))]`\n+will tell Rustdoc that the item is supposed to be used on Windows. For example:\n+\n+```rust\n+#![feature(doc_cfg)]\n+\n+/// Token struct that can only be used on Windows.\n+#[cfg(any(windows, feature = \"dox\"))]\n+#[doc(cfg(windows))]\n+pub struct WindowsToken;\n+\n+/// Token struct that can only be used on Unix.\n+#[cfg(any(unix, feature = \"dox\"))]\n+#[doc(cfg(unix))]\n+pub struct UnixToken;\n+```\n+\n+In this sample, the tokens will only appear on their respective platforms, but they will both appear\n+in documentation.\n+\n+`#[doc(cfg(...))]` was introduced to be used by the standard library and currently requires the\n+`#![feature(doc_cfg)]` feature gate. For more information, see [its chapter in the Unstable\n+Book][unstable-doc-cfg] and [its tracking issue][issue-doc-cfg].\n+\n+[unstable-doc-cfg]: ../unstable-book/language-features/doc-cfg.html\n+[issue-doc-cfg]: https://github.com/rust-lang/rust/issues/43781\n+\n+### Adding your trait to the \"Important Traits\" dialog\n+\n+Rustdoc keeps a list of a few traits that are believed to be \"fundamental\" to a given type when\n+implemented on it. These traits are intended to be the primary interface for their types, and are\n+often the only thing available to be documented on their types. For this reason, Rustdoc will track\n+when a given type implements one of these traits and call special attention to it when a function\n+returns one of these types. This is the \"Important Traits\" dialog, visible as a circle-i button next\n+to the function, which, when clicked, shows the dialog.\n+\n+In the standard library, the traits that qualify for inclusion are `Iterator`, `io::Read`, and\n+`io::Write`. However, rather than being implemented as a hard-coded list, these traits have a\n+special marker attribute on them: `#[doc(spotlight)]`. This means that you could apply this\n+attribute to your own trait to include it in the \"Important Traits\" dialog in documentation.\n+\n+The `#[doc(spotlight)]` attribute currently requires the `#![feature(doc_spotlight)]` feature gate.\n+For more information, see [its chapter in the Unstable Book][unstable-spotlight] and [its tracking\n+issue][issue-spotlight].\n+\n+[unstable-spotlight]: ../unstable-book/language-features/doc-spotlight.html\n+[issue-spotlight]: https://github.com/rust-lang/rust/issues/45040\n+\n+### Exclude certain dependencies from documentation\n+\n+The standard library uses several dependencies which, in turn, use several types and traits from the\n+standard library. In addition, there are several compiler-internal crates that are not considered to\n+be part of the official standard library, and thus would be a distraction to include in\n+documentation. It's not enough to exclude their crate documentation, since information about trait\n+implementations appears on the pages for both the type and the trait, which can be in different\n+crates!\n+\n+To prevent internal types from being included in documentation, the standard library adds an\n+attribute to their `extern crate` declarations: `#[doc(masked)]`. This causes Rustdoc to \"mask out\"\n+types from these crates when building lists of trait implementations.\n+\n+The `#[doc(masked)]` attribute is intended to be used internally, and requires the\n+`#![feature(doc_masked)]` feature gate.  For more information, see [its chapter in the Unstable\n+Book][unstable-masked] and [its tracking issue][issue-masked].\n+\n+[unstable-masked]: ../unstable-book/language-features/doc-masked.html\n+[issue-masked]: https://github.com/rust-lang/rust/issues/44027\n+\n+### Include external files as API documentation\n+\n+As designed in [RFC 1990], Rustdoc can read an external file to use as a type's documentation. This\n+is useful if certain documentation is so long that it would break the flow of reading the source.\n+Instead of writing it all inline, writing `#[doc(include = \"sometype.md\")]` (where `sometype.md` is\n+a file adjacent to the `lib.rs` for the crate) will ask Rustdoc to instead read that file and use it\n+as if it were written inline.\n+\n+[RFC 1990]: https://github.com/rust-lang/rfcs/pull/1990\n+\n+`#[doc(include = \"...\")]` currently requires the `#![feature(external_doc)]` feature gate. For more\n+information, see [its chapter in the Unstable Book][unstable-include] and [its tracking\n+issue][issue-include].\n+\n+[unstable-include]: ../unstable-book/language-features/external-doc.html\n+[issue-include]: https://github.com/rust-lang/rust/issues/44732\n+\n+## Unstable command-line arguments\n+\n+These features are enabled by passing a command-line flag to Rustdoc, but the flags in question are\n+themselves marked as unstable. To use any of these options, pass `-Z unstable-options` as well as\n+the flag in question to Rustdoc on the command-line. To do this from Cargo, you can either use the\n+`RUSTDOCFLAGS` environment variable or the `cargo rustdoc` command.\n+\n+### `--markdown-before-content`: include rendered Markdown before the content\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --markdown-before-content extra.md\n+$ rustdoc README.md -Z unstable-options --markdown-before-content extra.md\n+```\n+\n+Just like `--html-before-content`, this allows you to insert extra content inside the `<body>` tag\n+but before the other content `rustdoc` would normally produce in the rendered documentation.\n+However, instead of directly inserting the file verbatim, `rustdoc` will pass the files through a\n+Markdown renderer before inserting the result into the file.\n+\n+### `--markdown-after-content`: include rendered Markdown after the content\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --markdown-after-content extra.md\n+$ rustdoc README.md -Z unstable-options --markdown-after-content extra.md\n+```\n+\n+Just like `--html-after-content`, this allows you to insert extra content before the `</body>` tag\n+but after the other content `rustdoc` would normally produce in the rendered documentation.\n+However, instead of directly inserting the file verbatim, `rustdoc` will pass the files through a\n+Markdown renderer before inserting the result into the file.\n+\n+### `--playground-url`: control the location of the playground\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --playground-url https://play.rust-lang.org/\n+```\n+\n+When rendering a crate's docs, this flag gives the base URL of the Rust Playground, to use for\n+generating `Run` buttons. Unlike `--markdown-playground-url`, this argument works for standalone\n+Markdown files *and* Rust crates. This works the same way as adding `#![doc(html_playground_url =\n+\"url\")]` to your crate root, as mentioned in [the chapter about the `#[doc]`\n+attribute][doc-playground]. Please be aware that the official Rust Playground at\n+https://play.rust-lang.org does not have every crate available, so if your examples require your\n+crate, make sure the playground you provide has your crate available.\n+\n+[doc-playground]: the-doc-attribute.html#html_playground_url\n+\n+If both `--playground-url` and `--markdown-playground-url` are present when rendering a standalone\n+Markdown file, the URL given to `--markdown-playground-url` will take precedence. If both\n+`--playground-url` and `#![doc(html_playground_url = \"url\")]` are present when rendering crate docs,\n+the attribute will take precedence.\n+\n+### `--crate-version`: control the crate version\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --crate-version 1.3.37\n+```\n+\n+When `rustdoc` receives this flag, it will print an extra \"Version (version)\" into the sidebar of\n+the crate root's docs. You can use this flag to differentiate between different versions of your\n+library's documentation.\n+\n+### `--linker`: control the linker used for documentation tests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc --test src/lib.rs -Z unstable-options --linker foo\n+$ rustdoc --test README.md -Z unstable-options --linker foo\n+```\n+\n+When `rustdoc` runs your documentation tests, it needs to compile and link the tests as executables\n+before running them. This flag can be used to change the linker used on these executables. It's\n+equivalent to passing `-C linker=foo` to `rustc`.\n+\n+### `--sort-modules-by-appearance`: control how items on module pages are sorted\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --sort-modules-by-appearance\n+```\n+\n+Ordinarily, when `rustdoc` prints items in module pages, it will sort them alphabetically (taking\n+some consideration for their stability, and names that end in a number). Giving this flag to\n+`rustdoc` will disable this sorting and instead make it print the items in the order they appear in\n+the source.\n+\n+### `--themes`: provide additional themes\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --themes theme.css\n+```\n+\n+Giving this flag to `rustdoc` will make it copy your theme into the generated crate docs and enable\n+it in the theme selector. Note that `rustdoc` will reject your theme file if it doesn't style\n+everything the \"light\" theme does. See `--theme-checker` below for details.\n+\n+### `--theme-checker`: verify theme CSS for validity\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc -Z unstable-options --theme-checker theme.css\n+```\n+\n+Before including your theme in crate docs, `rustdoc` will compare all the CSS rules it contains\n+against the \"light\" theme included by default. Using this flag will allow you to see which rules are\n+missing if `rustdoc` rejects your theme.\n+\n+### `--resource-suffix`: modifying the name of CSS/JavaScript in crate docs\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --resource-suffix suf\n+```\n+\n+When rendering docs, `rustdoc` creates several CSS and JavaScript files as part of the output. Since\n+all these files are linked from every page, changing where they are can be cumbersome if you need to\n+specially cache them. This flag will rename all these files in the output to include the suffix in\n+the filename. For example, `light.css` would become `light-suf.css` with the above command.\n+\n+### `--display-warnings`: display warnings when documenting or running documentation tests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --display-warnings\n+$ rustdoc --test src/lib.rs -Z unstable-options --display-warnings\n+```\n+\n+The intent behind this flag is to allow the user to see warnings that occur within their library or\n+their documentation tests, which are usually suppressed. However, [due to a\n+bug][issue-display-warnings], this flag doesn't 100% work as intended. See the linked issue for\n+details.\n+\n+[issue-display-warnings]: https://github.com/rust-lang/rust/issues/41574\n+\n+### `--edition`: control the edition of docs and doctests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --edition 2018\n+$ rustdoc --test src/lib.rs -Z unstable-options --edition 2018\n+```\n+\n+This flag allows rustdoc to treat your rust code as the given edition. It will compile doctests with\n+the given edition as well. As with `rustc`, the default edition that `rustdoc` will use is `2015`\n+(the first edition).\n+\n+### `-Z force-unstable-if-unmarked`\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z force-unstable-if-unmarked\n+```\n+\n+This is an internal flag intended for the standard library and compiler that applies an\n+`#[unstable]` attribute to any dependent crate that doesn't have another stability attribute. This\n+allows `rustdoc` to be able to generate documentation for the compiler crates and the standard\n+library, as an equivalent command-line argument is provided to `rustc` when building those crates."}, {"sha": "0be6a321103f0858b9e0d70981b6a6414e72a47c", "filename": "src/doc/unstable-book/src/language-features/conservative-impl-trait.md", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,66 +0,0 @@\n-# `conservative_impl_trait`\n-\n-The tracking issue for this feature is: [#34511]\n-\n-[#34511]: https://github.com/rust-lang/rust/issues/34511\n-\n-------------------------\n-\n-The `conservative_impl_trait` feature allows a conservative form of abstract\n-return types.\n-\n-Abstract return types allow a function to hide a concrete return type behind a\n-trait interface similar to trait objects, while still generating the same\n-statically dispatched code as with concrete types.\n-\n-## Examples\n-\n-```rust\n-#![feature(conservative_impl_trait)]\n-\n-fn even_iter() -> impl Iterator<Item=u32> {\n-    (0..).map(|n| n * 2)\n-}\n-\n-fn main() {\n-    let first_four_even_numbers = even_iter().take(4).collect::<Vec<_>>();\n-    assert_eq!(first_four_even_numbers, vec![0, 2, 4, 6]);\n-}\n-```\n-\n-## Background\n-\n-In today's Rust, you can write function signatures like:\n-\n-````rust,ignore\n-fn consume_iter_static<I: Iterator<Item=u8>>(iter: I) { }\n-\n-fn consume_iter_dynamic(iter: Box<Iterator<Item=u8>>) { }\n-````\n-\n-In both cases, the function does not depend on the exact type of the argument.\n-The type held is \"abstract\", and is assumed only to satisfy a trait bound.\n-\n-* In the `_static` version using generics, each use of the function is\n-  specialized to a concrete, statically-known type, giving static dispatch,\n-  inline layout, and other performance wins.\n-* In the `_dynamic` version using trait objects, the concrete argument type is\n-  only known at runtime using a vtable.\n-\n-On the other hand, while you can write:\n-\n-````rust,ignore\n-fn produce_iter_dynamic() -> Box<Iterator<Item=u8>> { }\n-````\n-\n-...but you _cannot_ write something like:\n-\n-````rust,ignore\n-fn produce_iter_static() -> Iterator<Item=u8> { }\n-````\n-\n-That is, in today's Rust, abstract return types can only be written using trait\n-objects, which can be a significant performance penalty. This RFC proposes\n-\"unboxed abstract types\" as a way of achieving signatures like\n-`produce_iter_static`. Like generics, unboxed abstract types guarantee static\n-dispatch and inline data layout."}, {"sha": "8e888de90a95149ecf786f9b62e8588114623547", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -36,11 +36,11 @@ fn main() {\n         return \"foo\"\n     };\n \n-    match generator.resume() {\n+    match unsafe { generator.resume() } {\n         GeneratorState::Yielded(1) => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n-    match generator.resume() {\n+    match unsafe { generator.resume() } {\n         GeneratorState::Complete(\"foo\") => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n@@ -69,9 +69,9 @@ fn main() {\n     };\n \n     println!(\"1\");\n-    generator.resume();\n+    unsafe { generator.resume() };\n     println!(\"3\");\n-    generator.resume();\n+    unsafe { generator.resume() };\n     println!(\"5\");\n }\n ```\n@@ -92,7 +92,7 @@ The `Generator` trait in `std::ops` currently looks like:\n pub trait Generator {\n     type Yield;\n     type Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n }\n ```\n \n@@ -175,8 +175,8 @@ fn main() {\n         return ret\n     };\n \n-    generator.resume();\n-    generator.resume();\n+    unsafe { generator.resume() };\n+    unsafe { generator.resume() };\n }\n ```\n \n@@ -200,7 +200,7 @@ fn main() {\n             type Yield = i32;\n             type Return = &'static str;\n \n-            fn resume(&mut self) -> GeneratorState<i32, &'static str> {\n+            unsafe fn resume(&mut self) -> GeneratorState<i32, &'static str> {\n                 use std::mem;\n                 match mem::replace(self, __Generator::Done) {\n                     __Generator::Start(s) => {\n@@ -223,8 +223,8 @@ fn main() {\n         __Generator::Start(ret)\n     };\n \n-    generator.resume();\n-    generator.resume();\n+    unsafe { generator.resume() };\n+    unsafe { generator.resume() };\n }\n ```\n "}, {"sha": "a850b7644c3a76fee296606cf1ea858640251c41", "filename": "src/doc/unstable-book/src/language-features/i128-type.md", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,25 +0,0 @@\n-# `i128_type`\n-\n-The tracking issue for this feature is: [#35118]\n-\n-[#35118]: https://github.com/rust-lang/rust/issues/35118\n-\n-------------------------\n-\n-The `i128_type` feature adds support for 128 bit signed and unsigned integer\n-types.\n-\n-```rust\n-#![feature(i128_type)]\n-\n-fn main() {\n-    assert_eq!(1u128 + 1u128, 2u128);\n-    assert_eq!(u128::min_value(), 0);\n-    assert_eq!(u128::max_value(), 340282366920938463463374607431768211455);\n-\n-    assert_eq!(1i128 - 2i128, -1i128);\n-    assert_eq!(i128::min_value(), -170141183460469231731687303715884105728);\n-    assert_eq!(i128::max_value(), 170141183460469231731687303715884105727);\n-}\n-```\n-"}, {"sha": "cc542931cbe1fc01b10f1e2aef1bf2bc417b7298", "filename": "src/doc/unstable-book/src/language-features/match-default-bindings.md", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,58 +0,0 @@\n-# `match_default_bindings`\n-\n-The tracking issue for this feature is: [#42640]\n-\n-[#42640]: https://github.com/rust-lang/rust/issues/42640\n-\n-------------------------\n-\n-Match default bindings (also called \"default binding modes in match\") improves ergonomics for\n-pattern-matching on references by introducing automatic dereferencing (and a corresponding shift\n-in binding modes) for large classes of patterns that would otherwise not compile.\n-\n-For example, under match default bindings,\n-\n-```rust\n-#![feature(match_default_bindings)]\n-\n-fn main() {\n-    let x: &Option<_> = &Some(0);\n-\n-    match x {\n-        Some(y) => {\n-            println!(\"y={}\", *y);\n-        },\n-        None => {},\n-    }\n-}\n-```\n-\n-compiles and is equivalent to either of the below:\n-\n-```rust\n-fn main() {\n-    let x: &Option<_> = &Some(0);\n-\n-    match *x {\n-        Some(ref y) => {\n-            println!(\"y={}\", *y);\n-        },\n-        None => {},\n-    }\n-}\n-```\n-\n-or\n-\n-```rust\n-fn main() {\n-    let x: &Option<_> = &Some(0);\n-\n-    match x {\n-        &Some(ref y) => {\n-            println!(\"y={}\", *y);\n-        },\n-        &None => {},\n-    }\n-}\n-```"}, {"sha": "0858988952c105c3e987f16e977ed8510209aa61", "filename": "src/doc/unstable-book/src/language-features/repr128.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -0,0 +1,18 @@\n+# `repr128`\n+\n+The tracking issue for this feature is: [#35118]\n+\n+[#35118]: https://github.com/rust-lang/rust/issues/35118\n+\n+------------------------\n+\n+The `repr128` feature adds support for `#[repr(u128)]` on `enum`s.\n+\n+```rust\n+#![feature(repr128)]\n+\n+#[repr(u128)]\n+enum Foo {\n+    Bar(u64),\n+}\n+```"}, {"sha": "6b3c5e92720df6e9ef6ee001f4676c96dadadf98", "filename": "src/doc/unstable-book/src/language-features/universal-impl-trait.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,32 +0,0 @@\n-# `universal_impl_trait`\n-\n-The tracking issue for this feature is: [#34511].\n-\n-[#34511]: https://github.com/rust-lang/rust/issues/34511\n-\n---------------------\n-\n-The `universal_impl_trait` feature extends the [`conservative_impl_trait`]\n-feature allowing the `impl Trait` syntax in arguments (universal\n-quantification).\n-\n-[`conservative_impl_trait`]: ./language-features/conservative-impl-trait.html\n-\n-## Examples\n-\n-```rust\n-#![feature(universal_impl_trait)]\n-use std::ops::Not;\n-\n-fn any_zero(values: impl IntoIterator<Item = i32>) -> bool {\n-    for val in values { if val == 0 { return true; } }\n-    false\n-}\n-\n-fn main() {\n-    let test1 = -5..;\n-    let test2 = vec![1, 8, 42, -87, 60];\n-    assert!(any_zero(test1));\n-    assert!(bool::not(any_zero(test2)));\n-}\n-```"}, {"sha": "2e4bb1a5257c94b76899fc56324825666a4542be", "filename": "src/doc/unstable-book/src/library-features/splice.md", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,22 +0,0 @@\n-# `splice`\n-\n-The tracking issue for this feature is: [#44643]\n-\n-[#44643]: https://github.com/rust-lang/rust/issues/44643\n-\n-------------------------\n-\n-The `splice()` method on `String` allows you to replace a range\n-of values in a string with another range of values.\n-\n-A simple example:\n-\n-```rust\n-#![feature(splice)]\n-let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n-let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n-\n-// Replace the range up until the \u03b2 from the string\n-s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n-assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n-```"}, {"sha": "049444aa49bdd2ef90d7316c2e6d6d41bdf16f80", "filename": "src/doc/unstable-book/src/library-features/string-retain.md", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,23 +0,0 @@\n-# `string_retain`\n-\n-The tracking issue for this feature is: [#43874]\n-\n-[#43874]: https://github.com/rust-lang/rust/issues/43874\n-\n-------------------------\n-\n-Retains only the characters specified by the predicate.\n-\n-In other words, remove all characters `c` such that `f(c)` returns `false`.\n-This method operates in place and preserves the order of the retained\n-characters.\n-\n-```rust\n-#![feature(string_retain)]\n-\n-let mut s = String::from(\"f_o_ob_ar\");\n-\n-s.retain(|c| c != '_');\n-\n-assert_eq!(s, \"foobar\");\n-```"}, {"sha": "361e8d8e60eed9a48edc1c7a7023e7c3bb9ffadf", "filename": "src/etc/cat-and-grep.sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fetc%2Fcat-and-grep.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fetc%2Fcat-and-grep.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcat-and-grep.sh?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -63,6 +63,11 @@ done\n \n shift $((OPTIND - 1))\n \n+# use gnu version of tool if available (for bsd)\n+if command -v \"g${GREPPER}\"; then\n+    GREPPER=\"g${GREPPER}\"\n+fi\n+\n LOG=$(mktemp -t cgrep.XXXXXX)\n trap \"rm -f $LOG\" EXIT\n "}, {"sha": "a7da69f65faf2b3532cdc6537cff92a167a139ac", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1400,7 +1400,6 @@ nonblock_expr\n | BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1463,7 +1462,6 @@ expr\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1527,7 +1525,6 @@ expr_nostruct\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }"}, {"sha": "ccf2e2768d1a971d5362e49cd08aa4e67e1e2164", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -21,6 +21,7 @@ use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n+use core::heap::{Alloc, Layout};\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val, uninitialized};\n use core::ops::Deref;\n@@ -31,7 +32,7 @@ use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n \n-use heap::{Heap, Alloc, Layout, box_free};\n+use heap::{Heap, box_free};\n use boxed::Box;\n use string::String;\n use vec::Vec;"}, {"sha": "a43aadfe9a23a72c42b511a8c5a5a3f8add8c015", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -10,9 +10,10 @@\n \n #![deny(warnings)]\n \n-#![feature(i128_type)]\n+#![cfg_attr(stage0, feature(i128_type))]\n #![feature(rand)]\n #![feature(repr_simd)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(test)]\n \n extern crate rand;"}, {"sha": "a699ff9c0a76ec61d0a427ab58bfe10c23c09d72", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -284,6 +284,17 @@ macro_rules! sort_expensive {\n     }\n }\n \n+macro_rules! sort_lexicographic {\n+    ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n+            b.iter(|| v.clone().$f(|x| x.to_string()));\n+            b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n+        }\n+    }\n+}\n+\n sort!(sort, sort_small_ascending, gen_ascending, 10);\n sort!(sort, sort_small_descending, gen_descending, 10);\n sort!(sort, sort_small_random, gen_random, 10);\n@@ -312,6 +323,10 @@ sort!(sort_unstable, sort_unstable_large_big, gen_big_random, 10000);\n sort_strings!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n sort_expensive!(sort_unstable_by, sort_unstable_large_expensive, gen_random, 10000);\n \n+sort_lexicographic!(sort_by_key, sort_by_key_lexicographic, gen_random, 10000);\n+sort_lexicographic!(sort_unstable_by_key, sort_unstable_by_key_lexicographic, gen_random, 10000);\n+sort_lexicographic!(sort_by_cached_key, sort_by_cached_key_lexicographic, gen_random, 10000);\n+\n macro_rules! reverse {\n     ($name:ident, $ty:ty, $f:expr) => {\n         #[bench]"}, {"sha": "668b61c51d8bc0f8e3a39e496ecc0c79b2d5ed4e", "filename": "src/liballoc/binary_heap.rs", "status": "modified", "additions": 26, "deletions": 65, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -155,7 +155,7 @@\n #![allow(missing_docs)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::ops::{Deref, DerefMut, Place, Placer, InPlace};\n+use core::ops::{Deref, DerefMut};\n use core::iter::{FromIterator, FusedIterator};\n use core::mem::{swap, size_of};\n use core::ptr;\n@@ -509,6 +509,31 @@ impl<T: Ord> BinaryHeap<T> {\n         self.data.shrink_to_fit();\n     }\n \n+    /// Discards capacity with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to(10);\n+    /// assert!(heap.capacity() >= 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"0\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.data.shrink_to(min_capacity)\n+    }\n+\n     /// Removes the greatest item from the binary heap and returns it, or `None` if it\n     /// is empty.\n     ///\n@@ -1170,67 +1195,3 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-pub struct BinaryHeapPlace<'a, T: 'a>\n-where T: Clone + Ord {\n-    heap: *mut BinaryHeap<T>,\n-    place: vec::PlaceBack<'a, T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: Clone + Ord + fmt::Debug> fmt::Debug for BinaryHeapPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"BinaryHeapPlace\")\n-         .field(&self.place)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a> Placer<T> for &'a mut BinaryHeap<T>\n-where T: Clone + Ord {\n-    type Place = BinaryHeapPlace<'a, T>;\n-\n-    fn make_place(self) -> Self::Place {\n-        let ptr = self as *mut BinaryHeap<T>;\n-        let place = Placer::make_place(self.data.place_back());\n-        BinaryHeapPlace {\n-            heap: ptr,\n-            place,\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for BinaryHeapPlace<'a, T>\n-where T: Clone + Ord {\n-    fn pointer(&mut self) -> *mut T {\n-        self.place.pointer()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for BinaryHeapPlace<'a, T>\n-where T: Clone + Ord {\n-    type Owner = &'a T;\n-\n-    unsafe fn finalize(self) -> &'a T {\n-        self.place.finalize();\n-\n-        let heap: &mut BinaryHeap<T> = &mut *self.heap;\n-        let len = heap.len();\n-        let i = heap.sift_up(0, len - 1);\n-        heap.data.get_unchecked(i)\n-    }\n-}"}, {"sha": "c6741ddb822d5bb9114889bc71fdd2203f72e559", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -59,6 +59,7 @@ pub trait ToOwned {\n     /// let vv: Vec<i32> = v.to_owned();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"cloning is often expensive and is not expected to have side effects\"]\n     fn to_owned(&self) -> Self::Owned;\n \n     /// Uses borrowed data to replace owned data, usually by cloning."}, {"sha": "4f9dc61ce196be1306884c2afca4c9b71cdabe31", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 152, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -55,54 +55,21 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use heap::{Heap, Layout, Alloc};\n use raw_vec::RawVec;\n \n use core::any::Any;\n use core::borrow;\n use core::cmp::Ordering;\n use core::fmt;\n-use core::hash::{self, Hash, Hasher};\n+use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n-use core::marker::{self, Unpin, Unsize};\n+use core::marker::{Unpin, Unsize};\n use core::mem::{self, Pin};\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n-use core::ops::{BoxPlace, Boxed, InPlace, Place, Placer};\n use core::ptr::{self, NonNull, Unique};\n use core::convert::From;\n use str::from_boxed_utf8_unchecked;\n \n-/// A value that represents the heap. This is the default place that the `box`\n-/// keyword allocates into when no place is supplied.\n-///\n-/// The following two examples are equivalent:\n-///\n-/// ```\n-/// #![feature(box_heap)]\n-///\n-/// #![feature(box_syntax, placement_in_syntax)]\n-/// use std::boxed::HEAP;\n-///\n-/// fn main() {\n-///     let foo: Box<i32> = in HEAP { 5 };\n-///     let foo = box 5;\n-/// }\n-/// ```\n-#[unstable(feature = \"box_heap\",\n-           reason = \"may be renamed; uncertain about custom allocator design\",\n-           issue = \"27779\")]\n-pub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton: () };\n-\n-/// This the singleton type used solely for `boxed::HEAP`.\n-#[unstable(feature = \"box_heap\",\n-           reason = \"may be renamed; uncertain about custom allocator design\",\n-           issue = \"27779\")]\n-#[allow(missing_debug_implementations)]\n-#[derive(Copy, Clone)]\n-pub struct ExchangeHeapSingleton {\n-    _force_singleton: (),\n-}\n-\n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n@@ -111,121 +78,6 @@ pub struct ExchangeHeapSingleton {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<T: ?Sized>(Unique<T>);\n \n-/// `IntermediateBox` represents uninitialized backing storage for `Box`.\n-///\n-/// FIXME (pnkfelix): Ideally we would just reuse `Box<T>` instead of\n-/// introducing a separate `IntermediateBox<T>`; but then you hit\n-/// issues when you e.g. attempt to destructure an instance of `Box`,\n-/// since it is a lang item and so it gets special handling by the\n-/// compiler.  Easier just to make this parallel type for now.\n-///\n-/// FIXME (pnkfelix): Currently the `box` protocol only supports\n-/// creating instances of sized types. This IntermediateBox is\n-/// designed to be forward-compatible with a future protocol that\n-/// supports creating instances of unsized types; that is why the type\n-/// parameter has the `?Sized` generalization marker, and is also why\n-/// this carries an explicit size. However, it probably does not need\n-/// to carry the explicit alignment; that is just a work-around for\n-/// the fact that the `align_of` intrinsic currently requires the\n-/// input type to be Sized (which I do not think is strictly\n-/// necessary).\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-#[allow(missing_debug_implementations)]\n-pub struct IntermediateBox<T: ?Sized> {\n-    ptr: *mut u8,\n-    layout: Layout,\n-    marker: marker::PhantomData<*mut T>,\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-unsafe impl<T> Place<T> for IntermediateBox<T> {\n-    fn pointer(&mut self) -> *mut T {\n-        self.ptr as *mut T\n-    }\n-}\n-\n-unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n-    let p = b.ptr as *mut T;\n-    mem::forget(b);\n-    Box::from_raw(p)\n-}\n-\n-fn make_place<T>() -> IntermediateBox<T> {\n-    let layout = Layout::new::<T>();\n-\n-    let p = if layout.size() == 0 {\n-        mem::align_of::<T>() as *mut u8\n-    } else {\n-        unsafe {\n-            Heap.alloc(layout.clone()).unwrap_or_else(|err| {\n-                Heap.oom(err)\n-            })\n-        }\n-    };\n-\n-    IntermediateBox {\n-        ptr: p,\n-        layout,\n-        marker: marker::PhantomData,\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> BoxPlace<T> for IntermediateBox<T> {\n-    fn make_place() -> IntermediateBox<T> {\n-        make_place()\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> InPlace<T> for IntermediateBox<T> {\n-    type Owner = Box<T>;\n-    unsafe fn finalize(self) -> Box<T> {\n-        finalize(self)\n-    }\n-}\n-\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-impl<T> Boxed for Box<T> {\n-    type Data = T;\n-    type Place = IntermediateBox<T>;\n-    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> {\n-        finalize(b)\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> Placer<T> for ExchangeHeapSingleton {\n-    type Place = IntermediateBox<T>;\n-\n-    fn make_place(self) -> IntermediateBox<T> {\n-        make_place()\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T: ?Sized> Drop for IntermediateBox<T> {\n-    fn drop(&mut self) {\n-        if self.layout.size() > 0 {\n-            unsafe {\n-                Heap.dealloc(self.ptr, self.layout.clone())\n-            }\n-        }\n-    }\n-}\n-\n impl<T> Box<T> {\n     /// Allocates memory on the heap and then places `x` into it.\n     ///\n@@ -508,7 +360,7 @@ impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Hash> Hash for Box<T> {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n@@ -892,7 +744,7 @@ impl<T> Generator for Box<T>\n {\n     type Yield = T::Yield;\n     type Return = T::Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n         (**self).resume()\n     }\n }"}, {"sha": "c604df7049e0c02e10f53809f5c610986200b1a9", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -13,12 +13,12 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, Peekable, FusedIterator};\n use core::marker::PhantomData;\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::Index;\n+use core::ops::RangeBounds;\n use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n-use Bound::{Excluded, Included, Unbounded};\n-use range::RangeArgument;\n \n use super::node::{self, Handle, NodeRef, marker};\n use super::search;\n@@ -576,6 +576,33 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Returns the key-value pair corresponding to the supplied key.\n+    ///\n+    /// The supplied key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_get_key_value)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n+    /// assert_eq!(map.get_key_value(&2), None);\n+    /// ```\n+    #[unstable(feature = \"map_get_key_value\", issue = \"49347\")]\n+    pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n+        match search::search_tree(self.root.as_ref(), k) {\n+            Found(handle) => Some(handle.into_kv()),\n+            GoDown(_) => None,\n+        }\n+    }\n+\n     /// Returns `true` if the map contains a value for the specified key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering\n@@ -777,7 +804,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n-    /// use std::collections::Bound::Included;\n+    /// use std::ops::Bound::Included;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(3, \"a\");\n@@ -790,7 +817,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<K, V>\n-        where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n+        where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n     {\n         let root1 = self.root.as_ref();\n         let root2 = self.root.as_ref();\n@@ -830,7 +857,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<K, V>\n-        where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n+        where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n     {\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n@@ -1785,7 +1812,7 @@ fn last_leaf_edge<BorrowType, K, V>\n     }\n }\n \n-fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeArgument<Q>>(\n+fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R"}, {"sha": "49109d522e9651bb8e47ee2ff546b7ee9af28479", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -41,14 +41,14 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n+use core::heap::{Alloc, Layout};\n use core::marker::PhantomData;\n use core::mem;\n-use core::nonzero::NonZero;\n-use core::ptr::{self, Unique};\n+use core::ptr::{self, Unique, NonNull};\n use core::slice;\n \n use boxed::Box;\n-use heap::{Heap, Alloc, Layout};\n+use heap::Heap;\n \n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n@@ -149,14 +149,12 @@ impl<K, V> BoxedNode<K, V> {\n         }\n     }\n \n-    unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new_unchecked(ptr.get() as *mut LeafNode<K, V>) }\n+    unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n+        BoxedNode { ptr: Unique::from(ptr) }\n     }\n \n-    fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n-        unsafe {\n-            NonZero::from(self.ptr.as_ref())\n-        }\n+    fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n+        NonNull::from(self.ptr)\n     }\n }\n \n@@ -276,7 +274,7 @@ impl<K, V> Root<K, V> {\n ///   `NodeRef` could be pointing to either type of node.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n-    node: NonZero<*const LeafNode<K, V>>,\n+    node: NonNull<LeafNode<K, V>>,\n     // This is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>\n@@ -302,15 +300,15 @@ unsafe impl<K: Send, V: Send, Type> Send\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     fn as_internal(&self) -> &InternalNode<K, V> {\n         unsafe {\n-            &*(self.node.get() as *const InternalNode<K, V>)\n+            &*(self.node.as_ptr() as *mut InternalNode<K, V>)\n         }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe {\n-            &mut *(self.node.get() as *mut InternalNode<K, V>)\n+            &mut *(self.node.as_ptr() as *mut InternalNode<K, V>)\n         }\n     }\n }\n@@ -352,7 +350,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n     fn as_leaf(&self) -> &LeafNode<K, V> {\n         unsafe {\n-            &*self.node.get()\n+            self.node.as_ref()\n         }\n     }\n \n@@ -382,7 +380,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        if let Some(non_zero) = NonZero::new(self.as_leaf().parent as *const LeafNode<K, V>) {\n+        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n+        if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n                     height: self.height + 1,\n@@ -498,7 +497,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         unsafe {\n-            &mut *(self.node.get() as *mut LeafNode<K, V>)\n+            self.node.as_mut()\n         }\n     }\n \n@@ -1241,12 +1240,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 Heap.dealloc(\n-                    right_node.node.get() as *mut u8,\n+                    right_node.node.as_ptr() as *mut u8,\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n                 Heap.dealloc(\n-                    right_node.node.get() as *mut u8,\n+                    right_node.node.as_ptr() as *mut u8,\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }"}, {"sha": "2aad476d3153aead98448a4ddc9c6985df21c4e0", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -16,12 +16,11 @@ use core::cmp::{min, max};\n use core::fmt::Debug;\n use core::fmt;\n use core::iter::{Peekable, FromIterator, FusedIterator};\n-use core::ops::{BitOr, BitAnd, BitXor, Sub};\n+use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n \n use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n use super::Recover;\n-use range::RangeArgument;\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -240,7 +239,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n-    /// use std::collections::Bound::Included;\n+    /// use std::ops::Bound::Included;\n     ///\n     /// let mut set = BTreeSet::new();\n     /// set.insert(3);\n@@ -253,7 +252,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range<K: ?Sized, R>(&self, range: R) -> Range<T>\n-        where K: Ord, T: Borrow<K>, R: RangeArgument<K>\n+        where K: Ord, T: Borrow<K>, R: RangeBounds<K>\n     {\n         Range { iter: self.map.range(range) }\n     }"}, {"sha": "b2c4582e8406f4b5aaf30bc4fe9812f6083ea525", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -326,7 +326,7 @@\n //! sign := '+' | '-'\n //! width := count\n //! precision := count | '*'\n-//! type := identifier | ''\n+//! type := identifier | '?' | ''\n //! count := parameter | integer\n //! parameter := argument '$'\n //! ```\n@@ -516,17 +516,17 @@ pub use core::fmt::rt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Formatter, Result, Write};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{Octal, Binary};\n+pub use core::fmt::{Binary, Octal};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{Display, Debug};\n+pub use core::fmt::{Debug, Display};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerHex, UpperHex, Pointer};\n+pub use core::fmt::{LowerHex, Pointer, UpperHex};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{LowerExp, UpperExp};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::Error;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{ArgumentV1, Arguments, write};\n+pub use core::fmt::{write, ArgumentV1, Arguments};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n \n@@ -563,7 +563,8 @@ use string;\n pub fn format(args: Arguments) -> string::String {\n     let capacity = args.estimated_capacity();\n     let mut output = string::String::with_capacity(capacity);\n-    output.write_fmt(args)\n-          .expect(\"a formatting trait implementation returned an error\");\n+    output\n+        .write_fmt(args)\n+        .expect(\"a formatting trait implementation returned an error\");\n     output\n }"}, {"sha": "9296a1130718ee37ea8994c1004d58ea7a9883d5", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -19,7 +19,7 @@ use core::intrinsics::{min_align_of_val, size_of_val};\n use core::mem::{self, ManuallyDrop};\n use core::usize;\n \n-pub use allocator::*;\n+pub use core::heap::*;\n #[doc(hidden)]\n pub mod __core {\n     pub use core::*;"}, {"sha": "6ce2547ef6e6d1a8518d9b3835d3331234c0b94b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 11, "deletions": 66, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -76,18 +76,19 @@\n #![deny(missing_debug_implementations)]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(test, feature(placement_in))]\n #![cfg_attr(not(test), feature(core_float))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n+#![feature(allocator_api)]\n #![feature(allow_internal_unstable)]\n #![feature(ascii_ctype)]\n #![feature(box_into_raw_non_null)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![feature(collections_range)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n@@ -96,18 +97,15 @@\n #![feature(fmt_internals)]\n #![feature(from_ref)]\n #![feature(fundamental)]\n-#![feature(generic_param_attrs)]\n-#![feature(i128_type)]\n-#![feature(iter_rfold)]\n+#![cfg_attr(stage0, feature(generic_param_attrs))]\n+#![cfg_attr(stage0, feature(i128_type))]\n #![feature(lang_items)]\n #![feature(needs_allocator)]\n #![feature(nonzero)]\n #![feature(offset_to)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]\n #![feature(pin)]\n-#![feature(placement_in_syntax)]\n-#![feature(placement_new_protocol)]\n #![feature(ptr_internals)]\n #![feature(rustc_attrs)]\n #![feature(slice_get_slice)]\n@@ -126,8 +124,8 @@\n #![feature(pointer_methods)]\n #![feature(inclusive_range_fields)]\n \n-#![cfg_attr(not(test), feature(fn_traits, placement_new_protocol, swap_with_slice, i128))]\n-#![cfg_attr(test, feature(test, box_heap))]\n+#![cfg_attr(not(test), feature(fn_traits, swap_with_slice, i128))]\n+#![cfg_attr(test, feature(test))]\n \n // Allow testing this library\n \n@@ -145,9 +143,9 @@ extern crate std_unicode;\n #[macro_use]\n mod macros;\n \n-// Allocator trait and helper struct definitions\n-\n-pub mod allocator;\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"use the heap module in core, alloc, or std instead\")]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+pub use core::heap as allocator;\n \n // Heaps provided for low-level allocation strategies\n \n@@ -157,13 +155,12 @@ pub mod heap;\n \n // Need to conditionally define the mod from `boxed.rs` to avoid\n // duplicating the lang-items when building in test cfg; but also need\n-// to allow code to have `use boxed::HEAP;`\n-// and `use boxed::Box;` declarations.\n+// to allow code to have `use boxed::Box;` declarations.\n #[cfg(not(test))]\n pub mod boxed;\n #[cfg(test)]\n mod boxed {\n-    pub use std::boxed::{Box, IntermediateBox, HEAP};\n+    pub use std::boxed::Box;\n }\n #[cfg(test)]\n mod boxed_test;\n@@ -178,7 +175,6 @@ mod btree;\n pub mod borrow;\n pub mod fmt;\n pub mod linked_list;\n-pub mod range;\n pub mod slice;\n pub mod str;\n pub mod string;\n@@ -204,57 +200,6 @@ mod std {\n     pub use core::ops;      // RangeFull\n }\n \n-/// An endpoint of a range of keys.\n-///\n-/// # Examples\n-///\n-/// `Bound`s are range endpoints:\n-///\n-/// ```\n-/// #![feature(collections_range)]\n-///\n-/// use std::collections::range::RangeArgument;\n-/// use std::collections::Bound::*;\n-///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n-/// ```\n-///\n-/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n-/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n-///\n-/// ```\n-/// use std::collections::BTreeMap;\n-/// use std::collections::Bound::{Excluded, Included, Unbounded};\n-///\n-/// let mut map = BTreeMap::new();\n-/// map.insert(3, \"a\");\n-/// map.insert(5, \"b\");\n-/// map.insert(8, \"c\");\n-///\n-/// for (key, value) in map.range((Excluded(3), Included(8))) {\n-///     println!(\"{}: {}\", key, value);\n-/// }\n-///\n-/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n-/// ```\n-///\n-/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n-#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n-pub enum Bound<T> {\n-    /// An inclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Included(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n-    /// An exclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Excluded(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n-    /// An infinite endpoint. Indicates that there is no bound in this direction.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Unbounded,\n-}\n-\n /// An intermediate trait for specialization of `Extend`.\n #[doc(hidden)]\n trait SpecExtend<I: IntoIterator> {"}, {"sha": "129b3bc676432f058912c01ae3e834467ff34b0d", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 2, "deletions": 176, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -28,10 +28,9 @@ use core::hash::{Hasher, Hash};\n use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem;\n-use core::ops::{BoxPlace, InPlace, Place, Placer};\n-use core::ptr::{self, NonNull};\n+use core::ptr::NonNull;\n \n-use boxed::{Box, IntermediateBox};\n+use boxed::Box;\n use super::SpecExtend;\n \n /// A doubly-linked list with owned nodes.\n@@ -786,62 +785,6 @@ impl<T> LinkedList<T> {\n             old_len: old_len,\n         }\n     }\n-\n-    /// Returns a place for insertion at the front of the list.\n-    ///\n-    /// Using this method with placement syntax is equivalent to\n-    /// [`push_front`](#method.push_front), but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::LinkedList;\n-    ///\n-    /// let mut list = LinkedList::new();\n-    /// list.front_place() <- 2;\n-    /// list.front_place() <- 4;\n-    /// assert!(list.iter().eq(&[4, 2]));\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"method name and placement protocol are subject to change\",\n-               issue = \"30172\")]\n-    pub fn front_place(&mut self) -> FrontPlace<T> {\n-        FrontPlace {\n-            list: self,\n-            node: IntermediateBox::make_place(),\n-        }\n-    }\n-\n-    /// Returns a place for insertion at the back of the list.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_back`](#method.push_back),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::LinkedList;\n-    ///\n-    /// let mut list = LinkedList::new();\n-    /// list.back_place() <- 2;\n-    /// list.back_place() <- 4;\n-    /// assert!(list.iter().eq(&[2, 4]));\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"method name and placement protocol are subject to change\",\n-               issue = \"30172\")]\n-    pub fn back_place(&mut self) -> BackPlace<T> {\n-        BackPlace {\n-            list: self,\n-            node: IntermediateBox::make_place(),\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1242,123 +1185,6 @@ impl<T: Hash> Hash for LinkedList<T> {\n     }\n }\n \n-unsafe fn finalize<T>(node: IntermediateBox<Node<T>>) -> Box<Node<T>> {\n-    let mut node = node.finalize();\n-    ptr::write(&mut node.next, None);\n-    ptr::write(&mut node.prev, None);\n-    node\n-}\n-\n-/// A place for insertion at the front of a `LinkedList`.\n-///\n-/// See [`LinkedList::front_place`](struct.LinkedList.html#method.front_place) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-pub struct FrontPlace<'a, T: 'a> {\n-    list: &'a mut LinkedList<T>,\n-    node: IntermediateBox<Node<T>>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for FrontPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"FrontPlace\")\n-         .field(&self.list)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for FrontPlace<'a, T> {\n-    type Place = Self;\n-\n-    fn make_place(self) -> Self {\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for FrontPlace<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).element }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for FrontPlace<'a, T> {\n-    type Owner = ();\n-\n-    unsafe fn finalize(self) {\n-        let FrontPlace { list, node } = self;\n-        list.push_front_node(finalize(node));\n-    }\n-}\n-\n-/// A place for insertion at the back of a `LinkedList`.\n-///\n-/// See [`LinkedList::back_place`](struct.LinkedList.html#method.back_place) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-pub struct BackPlace<'a, T: 'a> {\n-    list: &'a mut LinkedList<T>,\n-    node: IntermediateBox<Node<T>>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for BackPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"BackPlace\")\n-         .field(&self.list)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for BackPlace<'a, T> {\n-    type Place = Self;\n-\n-    fn make_place(self) -> Self {\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for BackPlace<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).element }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for BackPlace<'a, T> {\n-    type Owner = ();\n-\n-    unsafe fn finalize(self) {\n-        let BackPlace { list, node } = self;\n-        list.push_back_node(finalize(node));\n-    }\n-}\n-\n // Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n #[allow(dead_code)]\n fn assert_covariance() {"}, {"sha": "b03abc8518087addd1b7d8976c3a0a1f45e06ca8", "filename": "src/liballoc/range.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,152 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"collections_range\",\n-            reason = \"waiting for dust to settle on inclusive ranges\",\n-            issue = \"30877\")]\n-\n-//! Range syntax.\n-\n-use core::ops::{RangeFull, Range, RangeTo, RangeFrom, RangeInclusive, RangeToInclusive};\n-use Bound::{self, Excluded, Included, Unbounded};\n-\n-/// `RangeArgument` is implemented by Rust's built-in range types, produced\n-/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n-pub trait RangeArgument<T: ?Sized> {\n-    /// Start index bound.\n-    ///\n-    /// Returns the start value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(alloc)]\n-    /// #![feature(collections_range)]\n-    ///\n-    /// extern crate alloc;\n-    ///\n-    /// # fn main() {\n-    /// use alloc::range::RangeArgument;\n-    /// use alloc::Bound::*;\n-    ///\n-    /// assert_eq!((..10).start(), Unbounded);\n-    /// assert_eq!((3..10).start(), Included(&3));\n-    /// # }\n-    /// ```\n-    fn start(&self) -> Bound<&T>;\n-\n-    /// End index bound.\n-    ///\n-    /// Returns the end value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(alloc)]\n-    /// #![feature(collections_range)]\n-    ///\n-    /// extern crate alloc;\n-    ///\n-    /// # fn main() {\n-    /// use alloc::range::RangeArgument;\n-    /// use alloc::Bound::*;\n-    ///\n-    /// assert_eq!((3..).end(), Unbounded);\n-    /// assert_eq!((3..10).end(), Excluded(&10));\n-    /// # }\n-    /// ```\n-    fn end(&self) -> Bound<&T>;\n-}\n-\n-// FIXME add inclusive ranges to RangeArgument\n-\n-impl<T: ?Sized> RangeArgument<T> for RangeFull {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for RangeFrom<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for RangeTo<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for Range<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> RangeArgument<T> for RangeInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> RangeArgument<T> for RangeToInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n-    fn start(&self) -> Bound<&T> {\n-        match *self {\n-            (Included(ref start), _) => Included(start),\n-            (Excluded(ref start), _) => Excluded(start),\n-            (Unbounded, _)           => Unbounded,\n-        }\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        match *self {\n-            (_, Included(ref end)) => Included(end),\n-            (_, Excluded(ref end)) => Excluded(end),\n-            (_, Unbounded)         => Unbounded,\n-        }\n-    }\n-}\n-\n-impl<'a, T: ?Sized + 'a> RangeArgument<T> for (Bound<&'a T>, Bound<&'a T>) {\n-    fn start(&self) -> Bound<&T> {\n-        self.0\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        self.1\n-    }\n-}"}, {"sha": "3edce8aebdf39fe5f1da4dc334cc029dd0ac5327", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use core::cmp;\n+use core::heap::{Alloc, Layout};\n use core::mem;\n use core::ops::Drop;\n use core::ptr::{self, Unique};\n use core::slice;\n-use heap::{Alloc, Layout, Heap};\n+use heap::Heap;\n use super::boxed::Box;\n use super::allocator::CollectionAllocErr;\n use super::allocator::CollectionAllocErr::*;"}, {"sha": "8bdc57f96a6d5c7dda2f334ebe75987f74ec7771", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -250,6 +250,7 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n+use core::heap::{Alloc, Layout};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unsize, PhantomData};\n@@ -259,7 +260,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use heap::{Heap, Alloc, Layout, box_free};\n+use heap::{Heap, box_free};\n use string::String;\n use vec::Vec;\n "}, {"sha": "68f2313843c313e0982ad607d9885d7b3cb4b0a5", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -102,6 +102,7 @@ use core::mem::size_of;\n use core::mem;\n use core::ptr;\n use core::slice as core_slice;\n+use core::{u8, u16, u32};\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n use boxed::Box;\n@@ -1302,7 +1303,8 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n log(m n))`\n+    /// worst-case, where the key function is `O(m)`.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -1328,12 +1330,82 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n-    pub fn sort_by_key<B, F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> B, B: Ord\n+    pub fn sort_by_key<K, F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n     {\n         merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Sorts the slice with a key extraction function.\n+    ///\n+    /// During sorting, the key function is called only once per element.\n+    ///\n+    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n + n log n)`\n+    /// worst-case, where the key function is `O(m)`.\n+    ///\n+    /// For simple key functions (e.g. functions that are property accesses or\n+    /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n+    /// faster.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// In the worst case, the algorithm allocates temporary storage in a `Vec<(K, usize)>` the\n+    /// length of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_sort_by_cached_key)]\n+    /// let mut v = [-5i32, 4, 32, -3, 2];\n+    ///\n+    /// v.sort_by_cached_key(|k| k.to_string());\n+    /// assert!(v == [-3, -5, 2, 32, 4]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[unstable(feature = \"slice_sort_by_cached_key\", issue = \"34447\")]\n+    #[inline]\n+    pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n+        macro_rules! sort_by_key {\n+            ($t:ty, $slice:ident, $f:ident) => ({\n+                let mut indices: Vec<_> =\n+                    $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n+                // The elements of `indices` are unique, as they are indexed, so any sort will be\n+                // stable with respect to the original slice. We use `sort_unstable` here because\n+                // it requires less memory allocation.\n+                indices.sort_unstable();\n+                for i in 0..$slice.len() {\n+                    let mut index = indices[i].1;\n+                    while (index as usize) < i {\n+                        index = indices[index as usize].1;\n+                    }\n+                    indices[i].1 = index;\n+                    $slice.swap(i, index as usize);\n+                }\n+            })\n+        }\n+\n+        let sz_u8    = mem::size_of::<(K, u8)>();\n+        let sz_u16   = mem::size_of::<(K, u16)>();\n+        let sz_u32   = mem::size_of::<(K, u32)>();\n+        let sz_usize = mem::size_of::<(K, usize)>();\n+\n+        let len = self.len();\n+        if sz_u8  < sz_u16   && len <= ( u8::MAX as usize) { return sort_by_key!( u8, self, f) }\n+        if sz_u16 < sz_u32   && len <= (u16::MAX as usize) { return sort_by_key!(u16, self, f) }\n+        if sz_u32 < sz_usize && len <= (u32::MAX as usize) { return sort_by_key!(u32, self, f) }\n+        sort_by_key!(usize, self, f)\n+    }\n+\n     /// Sorts the slice, but may not preserve the order of equal elements.\n     ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n@@ -1410,7 +1482,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n+    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n     ///\n     /// # Current implementation\n     ///\n@@ -1420,9 +1492,6 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n-    /// slice consists of several concatenated sorted sequences.\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1435,9 +1504,8 @@ impl<T> [T] {\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n     #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn sort_unstable_by_key<B, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> B,\n-              B: Ord\n+    pub fn sort_unstable_by_key<K, F>(&mut self, f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n     {\n         core_slice::SliceExt::sort_unstable_by_key(self, f);\n     }"}, {"sha": "d5ef41df0d850d5804299a328f617f411f3abdd2", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -2122,6 +2122,48 @@ impl str {\n         unsafe { String::from_utf8_unchecked(buf) }\n     }\n \n+    /// Returns true if this `str` is entirely whitespace, and false otherwise.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n+    /// Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert!(\"    \\t \".is_whitespace());\n+    ///\n+    /// // a non-breaking space\n+    /// assert!(\"\\u{A0}\".is_whitespace());\n+    ///\n+    /// assert!(!\"   \u8d8a\".is_whitespace());\n+    /// ```\n+    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n+    #[inline]\n+    pub fn is_whitespace(&self) -> bool {\n+        UnicodeStr::is_whitespace(self)\n+    }\n+\n+    /// Returns true if this `str` is entirely alphanumeric, and false otherwise.\n+    ///\n+    /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n+    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert!(\"\u06637\u09ecK\u0648\u85cf\".is_alphanumeric());\n+    /// assert!(!\"\u00be\u2460\".is_alphanumeric());\n+    /// ```\n+    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n+    #[inline]\n+    pub fn is_alphanumeric(&self) -> bool {\n+        UnicodeStr::is_alphanumeric(self)\n+    }\n+\n     /// Checks if all characters in this string are within the ASCII range.\n     ///\n     /// # Examples"}, {"sha": "b95aae02894ed758e1ba8acb86b716daceeeb673", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -59,15 +59,14 @@\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n use core::ptr;\n use core::str::pattern::Pattern;\n use std_unicode::lossy;\n use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n \n use borrow::{Cow, ToOwned};\n-use range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n@@ -1015,6 +1014,34 @@ impl String {\n         self.vec.shrink_to_fit()\n     }\n \n+    /// Shrinks the capacity of this `String` with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// let mut s = String::from(\"foo\");\n+    ///\n+    /// s.reserve(100);\n+    /// assert!(s.capacity() >= 100);\n+    ///\n+    /// s.shrink_to(10);\n+    /// assert!(s.capacity() >= 10);\n+    /// s.shrink_to(0);\n+    /// assert!(s.capacity() >= 3);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"0\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.vec.shrink_to(min_capacity)\n+    }\n+\n     /// Appends the given [`char`] to the end of this `String`.\n     ///\n     /// [`char`]: ../../std/primitive.char.html\n@@ -1177,16 +1204,14 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(string_retain)]\n-    ///\n     /// let mut s = String::from(\"f_o_ob_ar\");\n     ///\n     /// s.retain(|c| c != '_');\n     ///\n     /// assert_eq!(s, \"foobar\");\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"string_retain\", issue = \"43874\")]\n+    #[stable(feature = \"string_retain\", since = \"1.26.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(char) -> bool\n     {\n@@ -1458,7 +1483,7 @@ impl String {\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n@@ -1492,7 +1517,7 @@ impl String {\n         }\n     }\n \n-    /// Creates a splicing iterator that removes the specified range in the string,\n+    /// Removes the specified range in the string,\n     /// and replaces it with the given string.\n     /// The given string doesn't need to be the same length as the range.\n     ///\n@@ -1512,21 +1537,20 @@ impl String {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(splice)]\n     /// let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n     /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n     ///\n     /// // Replace the range up until the \u03b2 from the string\n-    /// s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n+    /// s.replace_range(..beta_offset, \"\u0391 is capital alpha; \");\n     /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n     /// ```\n-    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"44643\")]\n-    pub fn splice<R>(&mut self, range: R, replace_with: &str)\n-        where R: RangeArgument<usize>\n+    #[stable(feature = \"splice\", since = \"1.27.0\")]\n+    pub fn replace_range<R>(&mut self, range: R, replace_with: &str)\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n-        // The String version of Splice does not have the memory safety issues\n+        // Replace_range does not have the memory safety issues of a vector Splice.\n         // of the vector version. The data is just plain bytes.\n \n         match range.start() {\n@@ -1576,15 +1600,14 @@ impl FromUtf8Error {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(from_utf8_error_as_bytes)]\n     /// // some invalid bytes, in a vector\n     /// let bytes = vec![0, 159];\n     ///\n     /// let value = String::from_utf8(bytes);\n     ///\n     /// assert_eq!(&[0, 159], value.unwrap_err().as_bytes());\n     /// ```\n-    #[unstable(feature = \"from_utf8_error_as_bytes\", reason = \"recently added\", issue = \"40895\")]\n+    #[stable(feature = \"from_utf8_error_as_bytes\", since = \"1.26.0\")]\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.bytes[..]\n     }"}, {"sha": "8494463463cb941fa7873097ede52783ba4c5910", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -278,26 +278,6 @@ fn test_extend_specialization() {\n     assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n }\n \n-#[test]\n-fn test_placement() {\n-    let mut a = BinaryHeap::new();\n-    &mut a <- 2;\n-    &mut a <- 4;\n-    &mut a <- 3;\n-    assert_eq!(a.peek(), Some(&4));\n-    assert_eq!(a.len(), 3);\n-    &mut a <- 1;\n-    assert_eq!(a.into_sorted_vec(), vec![1, 2, 3, 4]);\n-}\n-\n-#[test]\n-fn test_placement_panic() {\n-    let mut heap = BinaryHeap::from(vec![1, 2, 3]);\n-    fn mkpanic() -> usize { panic!() }\n-    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { &mut heap <- mkpanic(); }));\n-    assert_eq!(heap.len(), 3);\n-}\n-\n #[allow(dead_code)]\n fn assert_covariance() {\n     fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {"}, {"sha": "6ebdb86cc4a9865a42bdde87419e87503ef249f0", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use std::collections::BTreeMap;\n-use std::collections::Bound::{self, Excluded, Included, Unbounded};\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n+use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::rc::Rc;\n \n use std::iter::FromIterator;"}, {"sha": "1a49fb9964ad727ef7c765c185f8024c35e56764", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -15,14 +15,13 @@\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n #![cfg_attr(stage0, feature(inclusive_range_syntax))]\n-#![feature(collection_placement)]\n #![feature(const_fn)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(iterator_step_by)]\n #![feature(pattern)]\n-#![feature(placement_in_syntax)]\n #![feature(rand)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(splice)]\n #![feature(str_escape)]\n #![feature(string_retain)]"}, {"sha": "99d9c51efc75790c2e552c89d6490423445a2292", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -425,6 +425,14 @@ fn test_sort() {\n                 v.sort_by(|a, b| b.cmp(a));\n                 assert!(v.windows(2).all(|w| w[0] >= w[1]));\n \n+                // Sort in lexicographic order.\n+                let mut v1 = orig.clone();\n+                let mut v2 = orig.clone();\n+                v1.sort_by_key(|x| x.to_string());\n+                v2.sort_by_cached_key(|x| x.to_string());\n+                assert!(v1.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n+                assert!(v1 == v2);\n+\n                 // Sort with many pre-sorted runs.\n                 let mut v = orig.clone();\n                 v.sort();\n@@ -477,24 +485,29 @@ fn test_sort_stability() {\n             // the second item represents which occurrence of that\n             // number this element is, i.e. the second elements\n             // will occur in sorted order.\n-            let mut v: Vec<_> = (0..len)\n+            let mut orig: Vec<_> = (0..len)\n                 .map(|_| {\n                     let n = thread_rng().gen::<usize>() % 10;\n                     counts[n] += 1;\n                     (n, counts[n])\n                 })\n                 .collect();\n \n-            // only sort on the first element, so an unstable sort\n+            let mut v = orig.clone();\n+            // Only sort on the first element, so an unstable sort\n             // may mix up the counts.\n             v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n-            // this comparison includes the count (the second item\n+            // This comparison includes the count (the second item\n             // of the tuple), so elements with equal first items\n             // will need to be ordered with increasing\n             // counts... i.e. exactly asserting that this sort is\n             // stable.\n             assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+            let mut v = orig.clone();\n+            v.sort_by_cached_key(|&(x, _)| x);\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n         }\n     }\n }\n@@ -1351,7 +1364,7 @@ fn test_copy_from_slice_dst_shorter() {\n const MAX_LEN: usize = 80;\n \n static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n-    // FIXME #5244: AtomicUsize is not Copy.\n+    // FIXME(RFC 1109): AtomicUsize is not Copy.\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),"}, {"sha": "cb4a17a22d8a4aa867a2676ff55c53eb06f51d64", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -443,53 +443,53 @@ fn test_drain() {\n }\n \n #[test]\n-fn test_splice() {\n+fn test_replace_range() {\n     let mut s = \"Hello, world!\".to_owned();\n-    s.splice(7..12, \"\u4e16\u754c\");\n+    s.replace_range(7..12, \"\u4e16\u754c\");\n     assert_eq!(s, \"Hello, \u4e16\u754c!\");\n }\n \n #[test]\n #[should_panic]\n-fn test_splice_char_boundary() {\n+fn test_replace_range_char_boundary() {\n     let mut s = \"Hello, \u4e16\u754c!\".to_owned();\n-    s.splice(..8, \"\");\n+    s.replace_range(..8, \"\");\n }\n \n #[test]\n-fn test_splice_inclusive_range() {\n+fn test_replace_range_inclusive_range() {\n     let mut v = String::from(\"12345\");\n-    v.splice(2..=3, \"789\");\n+    v.replace_range(2..=3, \"789\");\n     assert_eq!(v, \"127895\");\n-    v.splice(1..=2, \"A\");\n+    v.replace_range(1..=2, \"A\");\n     assert_eq!(v, \"1A895\");\n }\n \n #[test]\n #[should_panic]\n-fn test_splice_out_of_bounds() {\n+fn test_replace_range_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n-    s.splice(5..6, \"789\");\n+    s.replace_range(5..6, \"789\");\n }\n \n #[test]\n #[should_panic]\n-fn test_splice_inclusive_out_of_bounds() {\n+fn test_replace_range_inclusive_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n-    s.splice(5..=5, \"789\");\n+    s.replace_range(5..=5, \"789\");\n }\n \n #[test]\n-fn test_splice_empty() {\n+fn test_replace_range_empty() {\n     let mut s = String::from(\"12345\");\n-    s.splice(1..2, \"\");\n+    s.replace_range(1..2, \"\");\n     assert_eq!(s, \"1345\");\n }\n \n #[test]\n-fn test_splice_unbounded() {\n+fn test_replace_range_unbounded() {\n     let mut s = String::from(\"12345\");\n-    s.splice(.., \"\");\n+    s.replace_range(.., \"\");\n     assert_eq!(s, \"\");\n }\n "}, {"sha": "2895c53009d9ac9fae260e910bb5d148f34fc321", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -10,7 +10,7 @@\n \n use std::borrow::Cow;\n use std::mem::size_of;\n-use std::{usize, isize, panic};\n+use std::{usize, isize};\n use std::vec::{Drain, IntoIter};\n use std::collections::CollectionAllocErr::*;\n \n@@ -753,24 +753,6 @@ fn assert_covariance() {\n     }\n }\n \n-#[test]\n-fn test_placement() {\n-    let mut vec = vec![1];\n-    assert_eq!(vec.place_back() <- 2, &2);\n-    assert_eq!(vec.len(), 2);\n-    assert_eq!(vec.place_back() <- 3, &3);\n-    assert_eq!(vec.len(), 3);\n-    assert_eq!(&vec, &[1, 2, 3]);\n-}\n-\n-#[test]\n-fn test_placement_panic() {\n-    let mut vec = vec![1, 2, 3];\n-    fn mkpanic() -> usize { panic!() }\n-    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { vec.place_back() <- mkpanic(); }));\n-    assert_eq!(vec.len(), 3);\n-}\n-\n #[test]\n fn from_into_inner() {\n     let vec = vec![1, 2, 3];"}, {"sha": "75d3f01f8b601c0a930008dc42d92ef3dc75ac6c", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1004,28 +1004,6 @@ fn test_is_empty() {\n     assert!(v.into_iter().is_empty());\n }\n \n-#[test]\n-fn test_placement_in() {\n-    let mut buf: VecDeque<isize> = VecDeque::new();\n-    buf.place_back() <- 1;\n-    buf.place_back() <- 2;\n-    assert_eq!(buf, [1,2]);\n-\n-    buf.place_front() <- 3;\n-    buf.place_front() <- 4;\n-    assert_eq!(buf, [4,3,1,2]);\n-\n-    {\n-        let ptr_head = buf.place_front() <- 5;\n-        assert_eq!(*ptr_head, 5);\n-    }\n-    {\n-        let ptr_tail = buf.place_back() <- 6;\n-        assert_eq!(*ptr_tail, 6);\n-    }\n-    assert_eq!(buf, [5,4,3,1,2,6]);\n-}\n-\n #[test]\n fn test_reserve_exact_2() {\n     // This is all the same as test_reserve"}, {"sha": "4b883b5bce79bd48f714b5442340696024eea662", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 146, "deletions": 116, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -66,7 +66,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::cmp::Ordering;\n+use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume};\n@@ -75,7 +75,8 @@ use core::marker::PhantomData;\n use core::mem;\n #[cfg(not(test))]\n use core::num::Float;\n-use core::ops::{InPlace, Index, IndexMut, Place, Placer};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{Index, IndexMut, RangeBounds};\n use core::ops;\n use core::ptr;\n use core::ptr::NonNull;\n@@ -85,9 +86,7 @@ use borrow::ToOwned;\n use borrow::Cow;\n use boxed::Box;\n use raw_vec::RawVec;\n-use super::range::RangeArgument;\n use super::allocator::CollectionAllocErr;\n-use Bound::{Excluded, Included, Unbounded};\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n@@ -334,9 +333,10 @@ impl<T> Vec<T> {\n     /// The vector will be able to hold exactly `capacity` elements without\n     /// reallocating. If `capacity` is 0, the vector will not allocate.\n     ///\n-    /// It is important to note that this function does not specify the *length*\n-    /// of the returned vector, but only the *capacity*. For an explanation of\n-    /// the difference between length and capacity, see *[Capacity and reallocation]*.\n+    /// It is important to note that although the returned vector has the\n+    /// *capacity* specified, the vector will have a zero *length*. For an\n+    /// explanation of the difference between length and capacity, see\n+    /// *[Capacity and reallocation]*.\n     ///\n     /// [Capacity and reallocation]: #capacity-and-reallocation\n     ///\n@@ -586,6 +586,31 @@ impl<T> Vec<T> {\n         self.buf.shrink_to_fit(self.len);\n     }\n \n+    /// Shrinks the capacity of the vector with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// let mut vec = Vec::with_capacity(10);\n+    /// vec.extend([1, 2, 3].iter().cloned());\n+    /// assert_eq!(vec.capacity(), 10);\n+    /// vec.shrink_to(4);\n+    /// assert!(vec.capacity() >= 4);\n+    /// vec.shrink_to(0);\n+    /// assert!(vec.capacity() >= 3);\n+    /// ```\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"0\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.buf.shrink_to_fit(cmp::max(self.len, min_capacity));\n+    }\n+\n     /// Converts the vector into [`Box<[T]>`][owned slice].\n     ///\n     /// Note that this will drop any excess capacity.\n@@ -1040,29 +1065,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Returns a place for insertion at the back of the `Vec`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// let mut vec = vec![1, 2];\n-    /// vec.place_back() <- 3;\n-    /// vec.place_back() <- 4;\n-    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_back(&mut self) -> PlaceBack<T> {\n-        PlaceBack { vec: self }\n-    }\n-\n     /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///\n@@ -1150,7 +1152,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T>\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n@@ -1281,6 +1283,49 @@ impl<T> Vec<T> {\n         }\n         other\n     }\n+\n+    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n+    ///\n+    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n+    /// difference, with each additional slot filled with the result of\n+    /// calling the closure `f`. The return values from `f` will end up\n+    /// in the `Vec` in the order they have been generated.\n+    ///\n+    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n+    ///\n+    /// This method uses a closure to create new values on every push. If\n+    /// you'd rather [`Clone`] a given value, use [`resize`]. If you want\n+    /// to use the [`Default`] trait to generate values, you can pass\n+    /// [`Default::default()`] as the second argument..\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_resize_with)]\n+    ///\n+    /// let mut vec = vec![1, 2, 3];\n+    /// vec.resize_with(5, Default::default);\n+    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n+    ///\n+    /// let mut vec = vec![];\n+    /// let mut p = 1;\n+    /// vec.resize_with(4, || { p *= 2; p });\n+    /// assert_eq!(vec, [2, 4, 8, 16]);\n+    /// ```\n+    ///\n+    /// [`resize`]: #method.resize\n+    /// [`Clone`]: ../../std/clone/trait.Clone.html\n+    #[unstable(feature = \"vec_resize_with\", issue = \"41758\")]\n+    pub fn resize_with<F>(&mut self, new_len: usize, f: F)\n+        where F: FnMut() -> T\n+    {\n+        let len = self.len();\n+        if new_len > len {\n+            self.extend_with(new_len - len, ExtendFunc(f));\n+        } else {\n+            self.truncate(new_len);\n+        }\n+    }\n }\n \n impl<T: Clone> Vec<T> {\n@@ -1291,8 +1336,8 @@ impl<T: Clone> Vec<T> {\n     /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n     ///\n     /// This method requires [`Clone`] to be able clone the passed value. If\n-    /// you'd rather create a value with [`Default`] instead, see\n-    /// [`resize_default`].\n+    /// you need more flexibility (or want to rely on [`Default`] instead of\n+    /// [`Clone`]), use [`resize_with`].\n     ///\n     /// # Examples\n     ///\n@@ -1308,7 +1353,7 @@ impl<T: Clone> Vec<T> {\n     ///\n     /// [`Clone`]: ../../std/clone/trait.Clone.html\n     /// [`Default`]: ../../std/default/trait.Default.html\n-    /// [`resize_default`]: #method.resize_default\n+    /// [`resize_with`]: #method.resize_with\n     #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n@@ -1387,24 +1432,31 @@ impl<T: Default> Vec<T> {\n \n // This code generalises `extend_with_{element,default}`.\n trait ExtendWith<T> {\n-    fn next(&self) -> T;\n+    fn next(&mut self) -> T;\n     fn last(self) -> T;\n }\n \n struct ExtendElement<T>(T);\n impl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n-    fn next(&self) -> T { self.0.clone() }\n+    fn next(&mut self) -> T { self.0.clone() }\n     fn last(self) -> T { self.0 }\n }\n \n struct ExtendDefault;\n impl<T: Default> ExtendWith<T> for ExtendDefault {\n-    fn next(&self) -> T { Default::default() }\n+    fn next(&mut self) -> T { Default::default() }\n     fn last(self) -> T { Default::default() }\n }\n+\n+struct ExtendFunc<F>(F);\n+impl<T, F: FnMut() -> T> ExtendWith<T> for ExtendFunc<F> {\n+    fn next(&mut self) -> T { (self.0)() }\n+    fn last(mut self) -> T { (self.0)() }\n+}\n+\n impl<T> Vec<T> {\n     /// Extend the vector by `n` values, using the given generator.\n-    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, value: E) {\n+    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) {\n         self.reserve(n);\n \n         unsafe {\n@@ -1542,40 +1594,69 @@ impl SpecFromElem for u8 {\n     }\n }\n \n-macro_rules! impl_spec_from_elem {\n+impl<T: Clone + IsZero> SpecFromElem for T {\n+    #[inline]\n+    fn from_elem(elem: T, n: usize) -> Vec<T> {\n+        if elem.is_zero() {\n+            return Vec {\n+                buf: RawVec::with_capacity_zeroed(n),\n+                len: n,\n+            }\n+        }\n+        let mut v = Vec::with_capacity(n);\n+        v.extend_with(n, ExtendElement(elem));\n+        v\n+    }\n+}\n+\n+unsafe trait IsZero {\n+    /// Whether this value is zero\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_zero {\n     ($t: ty, $is_zero: expr) => {\n-        impl SpecFromElem for $t {\n+        unsafe impl IsZero for $t {\n             #[inline]\n-            fn from_elem(elem: $t, n: usize) -> Vec<$t> {\n-                if $is_zero(elem) {\n-                    return Vec {\n-                        buf: RawVec::with_capacity_zeroed(n),\n-                        len: n,\n-                    }\n-                }\n-                let mut v = Vec::with_capacity(n);\n-                v.extend_with(n, ExtendElement(elem));\n-                v\n+            fn is_zero(&self) -> bool {\n+                $is_zero(*self)\n             }\n         }\n-    };\n+    }\n }\n \n-impl_spec_from_elem!(i8, |x| x == 0);\n-impl_spec_from_elem!(i16, |x| x == 0);\n-impl_spec_from_elem!(i32, |x| x == 0);\n-impl_spec_from_elem!(i64, |x| x == 0);\n-impl_spec_from_elem!(i128, |x| x == 0);\n-impl_spec_from_elem!(isize, |x| x == 0);\n+impl_is_zero!(i8, |x| x == 0);\n+impl_is_zero!(i16, |x| x == 0);\n+impl_is_zero!(i32, |x| x == 0);\n+impl_is_zero!(i64, |x| x == 0);\n+impl_is_zero!(i128, |x| x == 0);\n+impl_is_zero!(isize, |x| x == 0);\n+\n+impl_is_zero!(u16, |x| x == 0);\n+impl_is_zero!(u32, |x| x == 0);\n+impl_is_zero!(u64, |x| x == 0);\n+impl_is_zero!(u128, |x| x == 0);\n+impl_is_zero!(usize, |x| x == 0);\n+\n+impl_is_zero!(char, |x| x == '\\0');\n+\n+impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n+impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n+\n+unsafe impl<T: ?Sized> IsZero for *const T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n \n-impl_spec_from_elem!(u16, |x| x == 0);\n-impl_spec_from_elem!(u32, |x| x == 0);\n-impl_spec_from_elem!(u64, |x| x == 0);\n-impl_spec_from_elem!(u128, |x| x == 0);\n-impl_spec_from_elem!(usize, |x| x == 0);\n+unsafe impl<T: ?Sized> IsZero for *mut T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n \n-impl_spec_from_elem!(f32, |x: f32| x == 0. && x.is_sign_positive());\n-impl_spec_from_elem!(f64, |x: f64| x == 0. && x.is_sign_positive());\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec\n@@ -1924,7 +2005,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n     pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n-        where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n+        where R: RangeBounds<usize>, I: IntoIterator<Item=T>\n     {\n         Splice {\n             drain: self.drain(range),\n@@ -2467,57 +2548,6 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Drain<'a, T> {}\n \n-/// A place for insertion at the back of a `Vec`.\n-///\n-/// See [`Vec::place_back`](struct.Vec.html#method.place_back) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceBack<'a, T: 'a> {\n-    vec: &'a mut Vec<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceBack<'a, T> {\n-    type Place = PlaceBack<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        // This will panic or abort if we would allocate > isize::MAX bytes\n-        // or if the length increment would overflow for zero-sized types.\n-        if self.vec.len == self.vec.buf.cap() {\n-            self.vec.buf.double();\n-        }\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceBack<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { self.vec.as_mut_ptr().offset(self.vec.len as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(mut self) -> &'a mut T {\n-        let ptr = self.pointer();\n-        self.vec.len += 1;\n-        &mut *ptr\n-    }\n-}\n-\n-\n /// A splicing iterator for `Vec`.\n ///\n /// This struct is created by the [`splice()`] method on [`Vec`]. See its"}, {"sha": "f28c8e389967f616e6cff139b74d81c2c03dd4f7", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 37, "deletions": 147, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -21,7 +21,8 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n-use core::ops::{Index, IndexMut, Place, Placer, InPlace};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{Index, IndexMut, RangeBounds};\n use core::ptr;\n use core::ptr::NonNull;\n use core::slice;\n@@ -32,8 +33,6 @@ use core::cmp;\n use raw_vec::RawVec;\n \n use super::allocator::CollectionAllocErr;\n-use super::range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n use super::vec::Vec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n@@ -676,9 +675,42 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn shrink_to_fit(&mut self) {\n+        self.shrink_to(0);\n+    }\n+\n+    /// Shrinks the capacity of the `VecDeque` with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::with_capacity(15);\n+    /// buf.extend(0..4);\n+    /// assert_eq!(buf.capacity(), 15);\n+    /// buf.shrink_to(6);\n+    /// assert!(buf.capacity() >= 6);\n+    /// buf.shrink_to(0);\n+    /// assert!(buf.capacity() >= 4);\n+    /// ```\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"0\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        assert!(self.capacity() >= min_capacity, \"Tried to shrink to a larger capacity\");\n+\n         // +1 since the ringbuffer always leaves one space empty\n         // len + 1 can't overflow for an existing, well-formed ringbuffer.\n-        let target_cap = cmp::max(self.len() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+        let target_cap = cmp::max(\n+            cmp::max(min_capacity, self.len()) + 1,\n+            MINIMUM_CAPACITY + 1\n+        ).next_power_of_two();\n+\n         if target_cap < self.cap() {\n             // There are three cases of interest:\n             //   All elements are out of desired bounds\n@@ -936,7 +968,7 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T>\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n@@ -1853,56 +1885,6 @@ impl<T> VecDeque<T> {\n             debug_assert!(!self.is_full());\n         }\n     }\n-\n-    /// Returns a place for insertion at the back of the `VecDeque`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_back`](#method.push_back),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// buf.place_back() <- 3;\n-    /// buf.place_back() <- 4;\n-    /// assert_eq!(&buf, &[3, 4]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_back(&mut self) -> PlaceBack<T> {\n-        PlaceBack { vec_deque: self }\n-    }\n-\n-    /// Returns a place for insertion at the front of the `VecDeque`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_front`](#method.push_front),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// buf.place_front() <- 3;\n-    /// buf.place_front() <- 4;\n-    /// assert_eq!(&buf, &[4, 3]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_front(&mut self) -> PlaceFront<T> {\n-        PlaceFront { vec_deque: self }\n-    }\n }\n \n impl<T: Clone> VecDeque<T> {\n@@ -2630,98 +2612,6 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     }\n }\n \n-/// A place for insertion at the back of a `VecDeque`.\n-///\n-/// See [`VecDeque::place_back`](struct.VecDeque.html#method.place_back) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceBack<'a, T: 'a> {\n-    vec_deque: &'a mut VecDeque<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceBack<'a, T> {\n-    type Place = PlaceBack<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        self.vec_deque.grow_if_necessary();\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceBack<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { self.vec_deque.ptr().offset(self.vec_deque.head as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(self) -> &'a mut T {\n-        let head = self.vec_deque.head;\n-        self.vec_deque.head = self.vec_deque.wrap_add(head, 1);\n-        &mut *(self.vec_deque.ptr().offset(head as isize))\n-    }\n-}\n-\n-/// A place for insertion at the front of a `VecDeque`.\n-///\n-/// See [`VecDeque::place_front`](struct.VecDeque.html#method.place_front) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceFront<'a, T: 'a> {\n-    vec_deque: &'a mut VecDeque<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceFront<'a, T> {\n-    type Place = PlaceFront<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        self.vec_deque.grow_if_necessary();\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceFront<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        let tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n-        unsafe { self.vec_deque.ptr().offset(tail as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceFront<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(self) -> &'a mut T {\n-        self.vec_deque.tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n-        &mut *(self.vec_deque.ptr().offset(self.vec_deque.tail as isize))\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test;"}, {"sha": "7a8d01e4ef8b88f7dddea1adc63f0e1b852baa73", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -15,7 +15,6 @@\n                       form or name\",\n             issue = \"27783\")]\n #![deny(warnings)]\n-#![feature(alloc)]\n #![feature(alloc_system)]\n #![feature(libc)]\n #![feature(linkage)]\n@@ -25,7 +24,6 @@\n #![cfg_attr(not(dummy_jemalloc), feature(allocator_api))]\n #![rustc_alloc_kind = \"exe\"]\n \n-extern crate alloc;\n extern crate alloc_system;\n extern crate libc;\n \n@@ -35,7 +33,7 @@ pub use contents::*;\n mod contents {\n     use core::ptr;\n \n-    use alloc::heap::{Alloc, AllocErr, Layout};\n+    use core::heap::{Alloc, AllocErr, Layout};\n     use alloc_system::System;\n     use libc::{c_int, c_void, size_t};\n "}, {"sha": "d4404e564e0639960873fbacd4bf616130142a3e", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -17,7 +17,6 @@\n             issue = \"32838\")]\n #![feature(global_allocator)]\n #![feature(allocator_api)]\n-#![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]\n@@ -43,9 +42,7 @@ const MIN_ALIGN: usize = 8;\n #[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-extern crate alloc;\n-\n-use self::alloc::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n+use core::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub struct System;\n@@ -125,7 +122,7 @@ mod platform {\n \n     use MIN_ALIGN;\n     use System;\n-    use alloc::heap::{Alloc, AllocErr, Layout};\n+    use core::heap::{Alloc, AllocErr, Layout};\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     unsafe impl<'a> Alloc for &'a System {\n@@ -134,6 +131,14 @@ mod platform {\n             let ptr = if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n                 libc::malloc(layout.size()) as *mut u8\n             } else {\n+                #[cfg(target_os = \"macos\")]\n+                {\n+                    if layout.align() > (1 << 31) {\n+                        return Err(AllocErr::Unsupported {\n+                            details: \"requested alignment too large\"\n+                        })\n+                    }\n+                }\n                 aligned_malloc(&layout)\n             };\n             if !ptr.is_null() {\n@@ -279,7 +284,7 @@ mod platform {\n \n     use MIN_ALIGN;\n     use System;\n-    use alloc::heap::{Alloc, AllocErr, Layout, CannotReallocInPlace};\n+    use core::heap::{Alloc, AllocErr, Layout, CannotReallocInPlace};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n@@ -491,7 +496,7 @@ mod platform {\n mod platform {\n     extern crate dlmalloc;\n \n-    use alloc::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n+    use core::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n     use System;\n     use self::dlmalloc::GlobalDlmalloc;\n "}, {"sha": "7eaf67e6ea66e30b991651b769f13f92d068f4a0", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -27,7 +27,7 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(generic_param_attrs)]\n+#![cfg_attr(stage0, feature(generic_param_attrs))]\n #![cfg_attr(test, feature(test))]\n \n #![allow(deprecated)]"}, {"sha": "2a2f6d96c8dc578d2474742f14c9bab0b36b0408", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1 +1 @@\n-Subproject commit 266ea0740a5bdd262a38bbd88fb55fc3d2a7a96e\n+Subproject commit 2a2f6d96c8dc578d2474742f14c9bab0b36b0408"}, {"sha": "87144c27c9e11b1b71749f832c354cba97ff59f6", "filename": "src/libcore/array.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -59,7 +59,7 @@ unsafe impl<T, A: Unsize<[T]>> FixedSizeArray<T> for A {\n }\n \n /// The error type returned when a conversion from a slice to an array fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Debug, Copy, Clone)]\n pub struct TryFromSliceError(());\n \n@@ -148,7 +148,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            #[stable(feature = \"try_from\", since = \"1.26.0\")]\n             impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n                 type Error = TryFromSliceError;\n \n@@ -162,7 +162,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            #[stable(feature = \"try_from\", since = \"1.26.0\")]\n             impl<'a, T> TryFrom<&'a mut [T]> for &'a mut [T; $N] {\n                 type Error = TryFromSliceError;\n "}, {"sha": "c8ee166fee3e9240383a7ff37c77a0c2e15be536", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -146,13 +146,12 @@\n //!\n //! ```\n //! #![feature(core_intrinsics)]\n-//! #![feature(shared)]\n //! use std::cell::Cell;\n-//! use std::ptr::Shared;\n+//! use std::ptr::NonNull;\n //! use std::intrinsics::abort;\n //!\n //! struct Rc<T: ?Sized> {\n-//!     ptr: Shared<RcBox<T>>\n+//!     ptr: NonNull<RcBox<T>>\n //! }\n //!\n //! struct RcBox<T: ?Sized> {"}, {"sha": "718c6b893edf229cfecf8ddb9d337521634136fd", "filename": "src/libcore/char.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -265,7 +265,7 @@ impl FromStr for char {\n }\n \n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl TryFrom<u32> for char {\n     type Error = CharTryFromError;\n \n@@ -280,11 +280,11 @@ impl TryFrom<u32> for char {\n }\n \n /// The error type returned when a conversion from u32 to char fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct CharTryFromError(());\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl fmt::Display for CharTryFromError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"converted integer out of range for `char`\".fmt(f)\n@@ -902,6 +902,16 @@ impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n             }\n         })\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.0.size_hint();\n+\n+        // A code point is at most 4 bytes long.\n+        let min_code_points = lower / 4;\n+\n+        (min_code_points, upper)\n+    }\n }\n \n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]"}, {"sha": "58a8439162c118586033a21603889c32ed6bed7e", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -87,6 +87,23 @@\n ///     fn clone(&self) -> Stats { *self }\n /// }\n /// ```\n+///\n+/// ## Additional implementors\n+///\n+/// In addition to the [implementors listed below][impls],\n+/// the following types also implement `Clone`:\n+///\n+/// * Function item types (i.e. the distinct types defined for each function)\n+/// * Function pointer types (e.g. `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Clone` (e.g. `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Clone` (e.g. `()`, `(i32, bool)`)\n+/// * Closure types, if they capture no value from the environment\n+///   or if all such captured values implement `Clone` themselves.\n+///   Note that variables captured by shared reference always implement `Clone`\n+///   (even if the referent doesn't),\n+///   while variables captured by mutable reference never implement `Clone`.\n+///\n+/// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n pub trait Clone : Sized {\n@@ -100,6 +117,7 @@ pub trait Clone : Sized {\n     /// assert_eq!(\"Hello\", hello.clone());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"cloning is often expensive and is not expected to have side effects\"]\n     fn clone(&self) -> Self;\n \n     /// Performs copy-assignment from `source`.\n@@ -130,3 +148,68 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n            reason = \"deriving hack, should not be public\",\n            issue = \"0\")]\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n+\n+/// Implementations of `Clone` for primitive types.\n+///\n+/// Implementations that cannot be described in Rust\n+/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n+#[cfg(not(stage0))]\n+mod impls {\n+\n+    use super::Clone;\n+\n+    macro_rules! impl_clone {\n+        ($($t:ty)*) => {\n+            $(\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                impl Clone for $t {\n+                    #[inline]\n+                    fn clone(&self) -> Self {\n+                        *self\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_clone! {\n+        usize u8 u16 u32 u64 u128\n+        isize i8 i16 i32 i64 i128\n+        f32 f64\n+        bool char\n+    }\n+\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n+    impl Clone for ! {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Clone for *const T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Clone for *mut T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    // Shared references can be cloned, but mutable references *cannot*!\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized> Clone for &'a T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+}"}, {"sha": "637213957848c6b7c01bf35fb791a96356669a76", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -48,25 +48,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use fmt;\n-\n-/// A type used as the error type for implementations of fallible conversion\n-/// traits in cases where conversions cannot actually fail.\n-///\n-/// Because `Infallible` has no variants, a value of this type can never exist.\n-/// It is used only to satisfy trait signatures that expect an error type, and\n-/// signals to both the compiler and the user that the error case is impossible.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub enum Infallible {}\n-\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl fmt::Display for Infallible {\n-    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-        }\n-    }\n-}\n /// A cheap reference-to-reference conversion. Used to convert a value to a\n /// reference value within generic code.\n ///\n@@ -341,22 +322,26 @@ pub trait From<T>: Sized {\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n /// [`Into`]: trait.Into.html\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     type Error;\n \n     /// Performs the conversion.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     fn try_into(self) -> Result<T, Self::Error>;\n }\n \n /// Attempt to construct `Self` via a conversion.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     type Error;\n \n     /// Performs the conversion.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     fn try_from(value: T) -> Result<Self, Self::Error>;\n }\n \n@@ -382,7 +367,7 @@ impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U>\n     }\n }\n \n-// FIXME (#23442): replace the above impls for &/&mut with the following more general one:\n+// FIXME (#45742): replace the above impls for &/&mut with the following more general one:\n // // As lifts over Deref\n // impl<D: ?Sized + Deref, U: ?Sized> AsRef<U> for D where D::Target: AsRef<U> {\n //     fn as_ref(&self) -> &U {\n@@ -399,7 +384,7 @@ impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U>\n     }\n }\n \n-// FIXME (#23442): replace the above impl for &mut with the following more general one:\n+// FIXME (#45742): replace the above impl for &mut with the following more general one:\n // // AsMut lifts over DerefMut\n // impl<D: ?Sized + Deref, U: ?Sized> AsMut<U> for D where D::Target: AsMut<U> {\n //     fn as_mut(&mut self) -> &mut U {\n@@ -424,7 +409,7 @@ impl<T> From<T> for T {\n \n \n // TryFrom implies TryInto\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl<T, U> TryInto<U> for T where U: TryFrom<T>\n {\n     type Error = U::Error;\n@@ -436,9 +421,9 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n \n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl<T, U> TryFrom<U> for T where T: From<U> {\n-    type Error = Infallible;\n+    type Error = !;\n \n     fn try_from(value: U) -> Result<Self, Self::Error> {\n         Ok(T::from(value))"}, {"sha": "d55219d7226e6d5fda7e7679df06994ab6a987f8", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -401,10 +401,21 @@ impl<'a> Arguments<'a> {\n /// safely be done, so no constructors are given and the fields are private\n /// to prevent modification.\n ///\n-/// The [`format_args!`] macro will safely create an instance of this structure\n-/// and pass it to a function or closure, passed as the first argument. The\n-/// macro validates the format string at compile-time so usage of the [`write`]\n-/// and [`format`] functions can be safely performed.\n+/// The [`format_args!`] macro will safely create an instance of this structure.\n+/// The macro validates the format string at compile-time so usage of the\n+/// [`write`] and [`format`] functions can be safely performed.\n+///\n+/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n+/// and `Display` contexts as seen below. The example also shows that `Debug`\n+/// and `Display` format to the same thing: the interpolated format string\n+/// in `format_args!`.\n+///\n+/// ```rust\n+/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// assert_eq!(\"1 foo 2\", display);\n+/// assert_eq!(display, debug);\n+/// ```\n ///\n /// [`format_args!`]: ../../std/macro.format_args.html\n /// [`format`]: ../../std/fmt/fn.format.html\n@@ -1553,23 +1564,32 @@ impl<'a> Formatter<'a> {\n     ///\n     /// ```rust\n     /// use std::fmt;\n+    /// use std::net::Ipv4Addr;\n     ///\n     /// struct Foo {\n     ///     bar: i32,\n     ///     baz: String,\n+    ///     addr: Ipv4Addr,\n     /// }\n     ///\n     /// impl fmt::Debug for Foo {\n     ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n     ///         fmt.debug_struct(\"Foo\")\n     ///             .field(\"bar\", &self.bar)\n     ///             .field(\"baz\", &self.baz)\n+    ///             .field(\"addr\", &format_args!(\"{}\", self.addr))\n     ///             .finish()\n     ///     }\n     /// }\n     ///\n-    /// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n-    /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n+    /// assert_eq!(\n+    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n+    ///     format!(\"{:?}\", Foo {\n+    ///         bar: 10,\n+    ///         baz: \"Hello World\".to_string(),\n+    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n+    ///     })\n+    /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n@@ -1583,20 +1603,24 @@ impl<'a> Formatter<'a> {\n     ///\n     /// ```rust\n     /// use std::fmt;\n+    /// use std::marker::PhantomData;\n     ///\n-    /// struct Foo(i32, String);\n+    /// struct Foo<T>(i32, String, PhantomData<T>);\n     ///\n-    /// impl fmt::Debug for Foo {\n+    /// impl<T> fmt::Debug for Foo<T> {\n     ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n     ///         fmt.debug_tuple(\"Foo\")\n     ///             .field(&self.0)\n     ///             .field(&self.1)\n+    ///             .field(&format_args!(\"_\"))\n     ///             .finish()\n     ///     }\n     /// }\n     ///\n-    /// // prints \"Foo(10, \"Hello World\")\"\n-    /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n+    /// assert_eq!(\n+    ///     \"Foo(10, \\\"Hello\\\", _)\",\n+    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), PhantomData::<u8>))\n+    /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n@@ -1646,6 +1670,41 @@ impl<'a> Formatter<'a> {\n     /// // prints \"{10, 11}\"\n     /// println!(\"{:?}\", Foo(vec![10, 11]));\n     /// ```\n+    ///\n+    /// [`format_args!`]: ../../std/macro.format_args.html\n+    ///\n+    /// In this more complex example, we use [`format_args!`] and `.debug_set()`\n+    /// to build a list of match arms:\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\n+    /// struct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n+    ///\n+    /// impl<'a, L, R> fmt::Debug for Arm<'a, L, R>\n+    /// where\n+    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n+    /// {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         L::fmt(&(self.0).0, fmt)?;\n+    ///         fmt.write_str(\" => \")?;\n+    ///         R::fmt(&(self.0).1, fmt)\n+    ///     }\n+    /// }\n+    ///\n+    /// impl<'a, K, V> fmt::Debug for Table<'a, K, V>\n+    /// where\n+    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n+    /// {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         fmt.debug_set()\n+    ///         .entries(self.0.iter().map(Arm))\n+    ///         .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n+    ///         .finish()\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n         builders::debug_set_new(self)"}, {"sha": "4451ab445cc5c9e5315598a76032d7aa50d0f13c", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -63,7 +63,7 @@ trait GenericRadix {\n         // characters for a base 2 number.\n         let zero = T::zero();\n         let is_nonnegative = x >= zero;\n-        let mut buf = [0; 128];\n+        let mut buf: [u8; 128] = unsafe { mem::uninitialized() };\n         let mut curr = buf.len();\n         let base = T::from_u8(Self::BASE);\n         if is_nonnegative {\n@@ -105,10 +105,6 @@ struct Binary;\n #[derive(Clone, PartialEq)]\n struct Octal;\n \n-/// A decimal (base 10) radix\n-#[derive(Clone, PartialEq)]\n-struct Decimal;\n-\n /// A hexadecimal (base 16) radix, formatted with lower-case characters\n #[derive(Clone, PartialEq)]\n struct LowerHex;\n@@ -134,7 +130,6 @@ macro_rules! radix {\n \n radix! { Binary,    2, \"0b\", x @  0 ...  1 => b'0' + x }\n radix! { Octal,     8, \"0o\", x @  0 ...  7 => b'0' + x }\n-radix! { Decimal,  10, \"\",   x @  0 ...  9 => b'0' + x }\n radix! { LowerHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n                              x @ 10 ... 15 => b'a' + (x - 10) }\n radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,"}, {"sha": "3e1f21cafe4124dfa754242990dd7fd8932ab662", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -308,7 +308,7 @@ pub trait Hasher {\n     }\n     /// Writes a single `u128` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    #[stable(feature = \"i128\", since = \"1.26.0\")]\n     fn write_u128(&mut self, i: u128) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 16]>(i) })\n     }\n@@ -348,7 +348,7 @@ pub trait Hasher {\n     }\n     /// Writes a single `i128` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    #[stable(feature = \"i128\", since = \"1.26.0\")]\n     fn write_i128(&mut self, i: i128) {\n         self.write_u128(i as u128)\n     }"}, {"sha": "fe19c923a58d153d2add0d72ed39c72b1e7e6929", "filename": "src/libcore/heap.rs", "status": "renamed", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fheap.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -15,11 +15,11 @@\n                       tracing garbage collector\",\n             issue = \"32838\")]\n \n-use core::cmp;\n-use core::fmt;\n-use core::mem;\n-use core::usize;\n-use core::ptr::{self, NonNull};\n+use cmp;\n+use fmt;\n+use mem;\n+use usize;\n+use ptr::{self, NonNull};\n \n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n@@ -65,13 +65,11 @@ pub struct Layout {\n \n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `None` if any of the following conditions\n+    /// or returns `None` if either of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must be a power of two,\n     ///\n-    /// * `align` must not exceed 2<sup>31</sup> (i.e. `1 << 31`),\n-    ///\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n     ///    must not overflow (i.e. the rounded value must be less than\n     ///    `usize::MAX`).\n@@ -81,10 +79,6 @@ impl Layout {\n             return None;\n         }\n \n-        if align > (1 << 31) {\n-            return None;\n-        }\n-\n         // (power-of-two implies align != 0.)\n \n         // Rounded up size is:\n@@ -113,9 +107,8 @@ impl Layout {\n     /// # Safety\n     ///\n     /// This function is unsafe as it does not verify that `align` is\n-    /// a power-of-two that is also less than or equal to 2<sup>31</sup>, nor\n-    /// that `size` aligned to `align` fits within the address space\n-    /// (i.e. the `Layout::from_size_align` preconditions).\n+    /// a power-of-two nor `size` aligned to `align` fits within the\n+    /// address space (i.e. the `Layout::from_size_align` preconditions).\n     #[inline]\n     pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Layout {\n         Layout { size: size, align: align }\n@@ -220,10 +213,10 @@ impl Layout {\n         let padded_size = self.size.checked_add(self.padding_needed_for(self.align))?;\n         let alloc_size = padded_size.checked_mul(n)?;\n \n-        // We can assume that `self.align` is a power-of-two that does\n-        // not exceed 2<sup>31</sup>. Furthermore, `alloc_size` has already been\n-        // rounded up to a multiple of `self.align`; therefore, the\n-        // call to `Layout::from_size_align` below should never panic.\n+        // We can assume that `self.align` is a power-of-two.\n+        // Furthermore, `alloc_size` has already been rounded up\n+        // to a multiple of `self.align`; therefore, the call to\n+        // `Layout::from_size_align` below should never panic.\n         Some((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))\n     }\n \n@@ -568,7 +561,7 @@ pub unsafe trait Alloc {\n     /// invoked method, and let the client decide whether to invoke\n     /// this `oom` method in response.\n     fn oom(&mut self, _: AllocErr) -> ! {\n-        unsafe { ::core::intrinsics::abort() }\n+        unsafe { ::intrinsics::abort() }\n     }\n \n     // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==", "previous_filename": "src/liballoc/allocator.rs"}, {"sha": "3b740adc46832d06e0c21c5429d5527542c62a04", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1314,6 +1314,11 @@ extern \"rust-intrinsic\" {\n     /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n     pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n+    /// Performs an exact division, resulting in undefined behavior where\n+    /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n+    #[cfg(not(stage0))]\n+    pub fn exact_div<T>(x: T, y: T) -> T;\n+\n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n     pub fn unchecked_div<T>(x: T, y: T) -> T;\n@@ -1396,3 +1401,8 @@ extern \"rust-intrinsic\" {\n     /// Probably will never become stable.\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n }\n+\n+#[cfg(stage0)]\n+pub unsafe fn exact_div<T>(a: T, b: T) -> T {\n+    unchecked_div(a, b)\n+}"}, {"sha": "4ccf446aa6346f007655b95e50ebe30e60881c1a", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -974,13 +974,13 @@ pub trait Iterator {\n     ///     // each iteration, we'll multiply the state by the element\n     ///     *state = *state * x;\n     ///\n-    ///     // the value passed on to the next iteration\n-    ///     Some(*state)\n+    ///     // then, we'll yield the negation of the state\n+    ///     Some(-*state)\n     /// });\n     ///\n-    /// assert_eq!(iter.next(), Some(1));\n-    /// assert_eq!(iter.next(), Some(2));\n-    /// assert_eq!(iter.next(), Some(6));\n+    /// assert_eq!(iter.next(), Some(-1));\n+    /// assert_eq!(iter.next(), Some(-2));\n+    /// assert_eq!(iter.next(), Some(-6));\n     /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n@@ -1368,6 +1368,7 @@ pub trait Iterator {\n     /// [`Result`]: ../../std/result/enum.Result.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n         FromIterator::from_iter(self)\n     }\n@@ -1446,7 +1447,6 @@ pub trait Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// let a = [1, 2, 3];\n     ///\n     /// // the checked sum of all of the elements of the array\n@@ -1458,7 +1458,6 @@ pub trait Iterator {\n     /// Short-circuiting:\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// let a = [10, 20, 30, 100, 40, 50];\n     /// let mut it = a.iter();\n     ///\n@@ -1472,7 +1471,7 @@ pub trait Iterator {\n     /// assert_eq!(it.next(), Some(&40));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n@@ -1495,7 +1494,6 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// use std::fs::rename;\n     /// use std::io::{stdout, Write};\n     /// use std::path::Path;\n@@ -1512,7 +1510,7 @@ pub trait Iterator {\n     /// assert_eq!(it.next(), Some(\"stale_bread.json\"));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n     fn try_for_each<F, R>(&mut self, mut f: F) -> R where\n         Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n     {\n@@ -1745,6 +1743,38 @@ pub trait Iterator {\n         }).break_value()\n     }\n \n+    /// Applies function to the elements of iterator and returns\n+    /// the first non-none result.\n+    ///\n+    /// `iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.\n+    ///\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(iterator_find_map)]\n+    /// let a = [\"lol\", \"NaN\", \"2\", \"5\"];\n+    ///\n+    /// let mut first_number = a.iter().find_map(|s| s.parse().ok());\n+    ///\n+    /// assert_eq!(first_number, Some(2));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_find_map\",\n+               reason = \"unstable new API\",\n+               issue = \"49602\")]\n+    fn find_map<B, F>(&mut self, mut f: F) -> Option<B> where\n+        Self: Sized,\n+        F: FnMut(Self::Item) -> Option<B>,\n+    {\n+        self.try_for_each(move |x| {\n+            match f(x) {\n+                Some(x) => LoopState::Break(x),\n+                None => LoopState::Continue(()),\n+            }\n+        }).break_value()\n+    }\n+\n     /// Searches for an element in an iterator, returning its index.\n     ///\n     /// `position()` takes a closure that returns `true` or `false`. It applies"}, {"sha": "1e8476d3880c8a4fc197c0c95e647ebca69ccf62", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1872,7 +1872,7 @@ impl<I: Iterator> Iterator for Peekable<I> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // FIXME(#6393): merge these when borrow-checking gets better.\n+        // FIXME(#43234): merge these when borrow-checking gets better.\n         if n == 0 {\n             match self.peeked.take() {\n                 Some(v) => v,"}, {"sha": "5d57207763e47b671306ca3674f20da7cfd7eb14", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -91,7 +91,7 @@ macro_rules! step_impl_unsigned {\n             #[inline]\n             #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n+                match <$t>::private_try_from(n) {\n                     Ok(n_as_t) => self.checked_add(n_as_t),\n                     Err(_) => None,\n                 }\n@@ -123,7 +123,7 @@ macro_rules! step_impl_signed {\n             #[inline]\n             #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n+                match <$unsigned>::private_try_from(n) {\n                     Ok(n_as_unsigned) => {\n                         // Wrapping in unsigned space handles cases like\n                         // `-120_i8.add_usize(200) == Some(80_i8)`,\n@@ -461,3 +461,74 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}\n+\n+/// Compensate removal of some impls per\n+/// https://github.com/rust-lang/rust/pull/49305#issuecomment-376293243\n+trait PrivateTryFromUsize: Sized {\n+    fn private_try_from(n: usize) -> Result<Self, ()>;\n+}\n+\n+impl<T> PrivateTryFromUsize for T where T: TryFrom<usize> {\n+    #[inline]\n+    fn private_try_from(n: usize) -> Result<Self, ()> {\n+        T::try_from(n).map_err(|_| ())\n+    }\n+}\n+\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($($target:ty),*) => {$(\n+        impl PrivateTryFromUsize for $target {\n+            #[inline]\n+            fn private_try_from(value: usize) -> Result<Self, ()> {\n+                Ok(value as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// unsigned to signed (only positive bound)\n+#[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\n+macro_rules! try_from_upper_bounded {\n+    ($($target:ty),*) => {$(\n+        impl PrivateTryFromUsize for $target {\n+            #[inline]\n+            fn private_try_from(u: usize) -> Result<$target, ()> {\n+                if u > (<$target>::max_value() as usize) {\n+                    Err(())\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_unbounded!(u16, u32, u64, u128);\n+    try_from_unbounded!(i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_upper_bounded!(u16);\n+    try_from_unbounded!(u32, u64, u128);\n+    try_from_upper_bounded!(i32);\n+    try_from_unbounded!(i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_upper_bounded!(u16, u32);\n+    try_from_unbounded!(u64, u128);\n+    try_from_upper_bounded!(i32, i64);\n+    try_from_unbounded!(i128);\n+}"}, {"sha": "ddbb59989424f11502b5c4b0f17e8f29498c571c", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -427,7 +427,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// let a = [\"1\", \"2\", \"3\"];\n     /// let sum = a.iter()\n     ///     .map(|&s| s.parse::<i32>())\n@@ -438,7 +437,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Short-circuiting:\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// let a = [\"1\", \"rust\", \"3\"];\n     /// let mut it = a.iter();\n     /// let sum = it\n@@ -452,7 +450,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(it.next_back(), Some(&\"1\"));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n@@ -491,7 +489,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iter_rfold)]\n     /// let a = [1, 2, 3];\n     ///\n     /// // the sum of all of the elements of a\n@@ -505,7 +502,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// and continuing with each element from the back until the front:\n     ///\n     /// ```\n-    /// #![feature(iter_rfold)]\n     /// let numbers = [1, 2, 3, 4, 5];\n     ///\n     /// let zero = \"0\".to_string();\n@@ -517,14 +513,14 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iter_rfold\", issue = \"44705\")]\n+    #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n     fn rfold<B, F>(mut self, accum: B, mut f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n         self.try_rfold(accum, move |acc, x| AlwaysOk(f(acc, x))).0\n     }\n \n-    /// Searches for an element of an iterator from the right that satisfies a predicate.\n+    /// Searches for an element of an iterator from the back that satisfies a predicate.\n     ///\n     /// `rfind()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, starting at the end, and if any\n@@ -547,8 +543,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iter_rfind)]\n-    ///\n     /// let a = [1, 2, 3];\n     ///\n     /// assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n@@ -559,8 +553,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Stopping at the first `true`:\n     ///\n     /// ```\n-    /// #![feature(iter_rfind)]\n-    ///\n     /// let a = [1, 2, 3];\n     ///\n     /// let mut iter = a.iter();\n@@ -571,7 +563,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(iter.next_back(), Some(&1));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iter_rfind\", issue = \"39480\")]\n+    #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n     fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n@@ -901,6 +893,15 @@ impl<I, T, E> Iterator for ResultShunt<I, E>\n             None => None,\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.error.is_some() {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n }\n \n #[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]"}, {"sha": "5a62b8438f93d2a8dccdd5568e36c00427f0dd99", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -78,14 +78,15 @@\n #![feature(doc_spotlight)]\n #![feature(fn_must_use)]\n #![feature(fundamental)]\n-#![feature(i128_type)]\n+#![cfg_attr(stage0, feature(i128_type))]\n #![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![feature(intrinsics)]\n #![feature(iterator_flatten)]\n #![feature(iterator_repeat_with)]\n #![feature(lang_items)]\n #![feature(link_llvm_intrinsics)]\n #![feature(exhaustive_patterns)]\n+#![feature(macro_at_most_once_rep)]\n #![feature(no_core)]\n #![feature(on_unimplemented)]\n #![feature(optin_builtin_traits)]\n@@ -185,6 +186,10 @@ pub mod hash;\n pub mod fmt;\n pub mod time;\n \n+/* Heap memory allocator trait */\n+#[allow(missing_docs)]\n+pub mod heap;\n+\n // note: does not need to be public\n mod char_private;\n mod iter_private;"}, {"sha": "885aabe08069d4e064cbebd9183819fe799084e8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -260,13 +260,29 @@ pub trait Unsize<T: ?Sized> {\n /// non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\n /// avoid a breaking API change.\n ///\n+/// ## Additional implementors\n+///\n+/// In addition to the [implementors listed below][impls],\n+/// the following types also implement `Copy`:\n+///\n+/// * Function item types (i.e. the distinct types defined for each function)\n+/// * Function pointer types (e.g. `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Copy` (e.g. `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Copy` (e.g. `()`, `(i32, bool)`)\n+/// * Closure types, if they capture no value from the environment\n+///   or if all such captured values implement `Copy` themselves.\n+///   Note that variables captured by shared reference always implement `Copy`\n+///   (even if the referent doesn't),\n+///   while variables captured by mutable reference never implement `Copy`.\n+///\n /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Drop`]: ../../std/ops/trait.Drop.html\n /// [`size_of::<T>`]: ../../std/mem/fn.size_of.html\n /// [`Clone`]: ../clone/trait.Clone.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`i32`]: ../../std/primitive.i32.html\n+/// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n@@ -588,3 +604,43 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// This trait is automatically implemented for almost every type.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n pub unsafe auto trait Unpin {}\n+\n+/// Implementations of `Copy` for primitive types.\n+///\n+/// Implementations that cannot be described in Rust\n+/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n+#[cfg(not(stage0))]\n+mod copy_impls {\n+\n+    use super::Copy;\n+\n+    macro_rules! impl_copy {\n+        ($($t:ty)*) => {\n+            $(\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                impl Copy for $t {}\n+            )*\n+        }\n+    }\n+\n+    impl_copy! {\n+        usize u8 u16 u32 u64 u128\n+        isize i8 i16 i32 i64 i128\n+        f32 f64\n+        bool char\n+    }\n+\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n+    impl Copy for ! {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Copy for *const T {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Copy for *mut T {}\n+\n+    // Shared references can be copied, but mutable references *cannot*!\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized> Copy for &'a T {}\n+\n+}"}, {"sha": "19836d98844e292d7be235601e344664faac182f", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n //! Exposes the NonZero lang item which provides optimization hints.\n-#![unstable(feature = \"nonzero\",\n-            reason = \"needs an RFC to flesh out the design\",\n-            issue = \"27730\")]\n+#![unstable(feature = \"nonzero\", reason = \"deprecated\", issue = \"49137\")]\n+#![rustc_deprecated(reason = \"use `std::ptr::NonNull` or `std::num::NonZero*` instead\",\n+                    since = \"1.26.0\")]\n+#![allow(deprecated)]\n \n use ops::CoerceUnsized;\n \n@@ -62,14 +63,11 @@ impl_zeroable_for_integer_types! {\n /// NULL or 0 that might allow certain optimizations.\n #[lang = \"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n-pub struct NonZero<T: Zeroable>(T);\n+pub struct NonZero<T: Zeroable>(pub(crate) T);\n \n impl<T: Zeroable> NonZero<T> {\n     /// Creates an instance of NonZero with the provided value.\n     /// You must indeed ensure that the value is actually \"non-zero\".\n-    #[unstable(feature = \"nonzero\",\n-               reason = \"needs an RFC to flesh out the design\",\n-               issue = \"27730\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(inner: T) -> Self {\n         NonZero(inner)"}, {"sha": "989376d1ac2d2021f891c83d4432791ddf6ee1d4", "filename": "src/libcore/num/i128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fnum%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fnum%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi128.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -12,6 +12,6 @@\n //!\n //! *[See also the `i128` primitive type](../../std/primitive.i128.html).*\n \n-#![unstable(feature = \"i128\", issue=\"35118\")]\n+#![stable(feature = \"i128\", since = \"1.26.0\")]\n \n-int_module! { i128, #[unstable(feature = \"i128\", issue=\"35118\")] }\n+int_module! { i128, #[stable(feature = \"i128\", since=\"1.26.0\")] }"}, {"sha": "dcda404721c160582bd9e6b5bde643b7179923c8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 150, "deletions": 100, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -12,12 +12,111 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use convert::{Infallible, TryFrom};\n+use convert::TryFrom;\n use fmt;\n use intrinsics;\n+#[allow(deprecated)] use nonzero::NonZero;\n use ops;\n use str::FromStr;\n \n+macro_rules! impl_nonzero_fmt {\n+    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+        $(\n+            #[$stability]\n+            #[allow(deprecated)]\n+            impl fmt::$Trait for $Ty {\n+                #[inline]\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    self.get().fmt(f)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+macro_rules! nonzero_integers {\n+    ( #[$stability: meta] #[$deprecation: meta] $( $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            /// An integer that is known not to equal zero.\n+            ///\n+            /// This may enable some memory layout optimization such as:\n+            ///\n+            /// ```rust\n+            /// # #![feature(nonzero)]\n+            /// use std::mem::size_of;\n+            /// assert_eq!(size_of::<Option<std::num::NonZeroU32>>(), size_of::<u32>());\n+            /// ```\n+            #[$stability]\n+            #[$deprecation]\n+            #[allow(deprecated)]\n+            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+            pub struct $Ty(NonZero<$Int>);\n+\n+            #[allow(deprecated)]\n+            impl $Ty {\n+                /// Create a non-zero without checking the value.\n+                ///\n+                /// # Safety\n+                ///\n+                /// The value must not be zero.\n+                #[$stability]\n+                #[inline]\n+                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n+                    $Ty(NonZero(n))\n+                }\n+\n+                /// Create a non-zero if the given value is not zero.\n+                #[$stability]\n+                #[inline]\n+                pub fn new(n: $Int) -> Option<Self> {\n+                    if n != 0 {\n+                        Some($Ty(NonZero(n)))\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Returns the value as a primitive type.\n+                #[$stability]\n+                #[inline]\n+                pub fn get(self) -> $Int {\n+                    self.0 .0\n+                }\n+\n+            }\n+\n+            impl_nonzero_fmt! {\n+                #[$stability]\n+                (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_integers! {\n+    #[unstable(feature = \"nonzero\", issue = \"49137\")]\n+    #[allow(deprecated)]  // Redundant, works around \"error: inconsistent lockstep iteration\"\n+    NonZeroU8(u8);\n+    NonZeroU16(u16);\n+    NonZeroU32(u32);\n+    NonZeroU64(u64);\n+    NonZeroU128(u128);\n+    NonZeroUsize(usize);\n+}\n+\n+nonzero_integers! {\n+    #[unstable(feature = \"nonzero\", issue = \"49137\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"\\\n+        signed non-zero integers are considered for removal due to lack of known use cases. \\\n+        If you\u2019re using them, please comment on https://github.com/rust-lang/rust/issues/49137\")]\n+    NonZeroI8(i8);\n+    NonZeroI16(i16);\n+    NonZeroI32(i32);\n+    NonZeroI64(i64);\n+    NonZeroI128(i128);\n+    NonZeroIsize(isize);\n+}\n+\n /// Provides intentionally-wrapped arithmetic on `T`.\n ///\n /// Operations like `+` on `u32` values is intended to never overflow,\n@@ -1546,11 +1645,7 @@ impl i64 {\n #[lang = \"i128\"]\n impl i128 {\n     int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n-        170141183460469231731687303715884105727, \"#![feature(i128_type)]\n-#![feature(i128)]\n-# fn main() {\n-\", \"\n-# }\" }\n+        170141183460469231731687303715884105727, \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n@@ -3404,12 +3499,7 @@ impl u64 {\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"#![feature(i128_type)]\n-#![feature(i128)]\n-\n-# fn main() {\n-\", \"\n-# }\" }\n+    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n@@ -3573,7 +3663,7 @@ macro_rules! from_str_radix_int_impl {\n from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n \n /// The error type returned when a checked integral type conversion fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Debug, Copy, Clone)]\n pub struct TryFromIntError(());\n \n@@ -3588,40 +3678,24 @@ impl TryFromIntError {\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl fmt::Display for TryFromIntError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         self.__description().fmt(fmt)\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl From<Infallible> for TryFromIntError {\n-    fn from(infallible: Infallible) -> TryFromIntError {\n-        match infallible {\n-        }\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+impl From<!> for TryFromIntError {\n+    fn from(never: !) -> TryFromIntError {\n+        never\n     }\n }\n \n-// no possible bounds violation\n-macro_rules! try_from_unbounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = Infallible;\n-\n-            #[inline]\n-            fn try_from(value: $source) -> Result<Self, Self::Error> {\n-                Ok(value as $target)\n-            }\n-        }\n-    )*}\n-}\n-\n // only negative bounds\n macro_rules! try_from_lower_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3640,7 +3714,7 @@ macro_rules! try_from_lower_bounded {\n // unsigned to signed (only positive bound)\n macro_rules! try_from_upper_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3659,7 +3733,7 @@ macro_rules! try_from_upper_bounded {\n // all other cases\n macro_rules! try_from_both_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3716,82 +3790,44 @@ try_from_both_bounded!(i128, u64, u32, u16, u8);\n try_from_upper_bounded!(usize, isize);\n try_from_lower_bounded!(isize, usize);\n \n+try_from_upper_bounded!(usize, u8);\n+try_from_upper_bounded!(usize, i8, i16);\n+try_from_both_bounded!(isize, u8);\n+try_from_both_bounded!(isize, i8);\n+\n #[cfg(target_pointer_width = \"16\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n-\n-    try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16);\n-    try_from_unbounded!(usize, i32, i64, i128);\n+    use convert::TryFrom;\n \n-    try_from_both_bounded!(isize, u8);\n+    // Fallible across platfoms, only implementation differs\n     try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8);\n-    try_from_unbounded!(isize, i16, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16);\n-    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16);\n     rev!(try_from_both_bounded, usize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u8);\n-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i16);\n-    rev!(try_from_both_bounded, isize, i32, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n-\n-    try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32);\n-    try_from_unbounded!(usize, i64, i128);\n+    use convert::TryFrom;\n \n-    try_from_both_bounded!(isize, u8, u16);\n+    // Fallible across platfoms, only implementation differs\n+    try_from_both_bounded!(isize, u16);\n     try_from_lower_bounded!(isize, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16);\n-    try_from_unbounded!(isize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16, u32);\n-    rev!(try_from_upper_bounded, usize, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32);\n     rev!(try_from_both_bounded, usize, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u8, u16);\n-    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i16, i32);\n-    rev!(try_from_both_bounded, isize, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"64\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n-\n-    try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n-    try_from_unbounded!(usize, i128);\n+    use convert::TryFrom;\n \n-    try_from_both_bounded!(isize, u8, u16, u32);\n+    // Fallible across platfoms, only implementation differs\n+    try_from_both_bounded!(isize, u16, u32);\n     try_from_lower_bounded!(isize, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16, i32);\n-    try_from_unbounded!(isize, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16, u32, u64);\n-    rev!(try_from_upper_bounded, usize, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n     rev!(try_from_both_bounded, usize, i128);\n-\n-    rev!(try_from_unbounded, isize, u8, u16, u32);\n-    rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i16, i32, i64);\n-    rev!(try_from_both_bounded, isize, i128);\n }\n \n #[doc(hidden)]\n@@ -3967,39 +4003,53 @@ macro_rules! impl_from {\n impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n-impl_from! { u64, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n \n // Signed -> Signed\n impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i32, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n-impl_from! { i64, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n \n // Unsigned -> Signed\n impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n-impl_from! { u64, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n+// which imply that pointer-sized integers must be at least 16 bits:\n+// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n+impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+\n+// RISC-V defines the possibility of a 128-bit address space (RV128).\n+\n+// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n+// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n+// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n+\n \n // Note: integers can only be represented with full precision in a float if\n // they fit in the significand, which is 24 bits in f32 and 53 bits in f64."}, {"sha": "e8c783a1bb542e20f573a3d6648a38cd61c36c83", "filename": "src/libcore/num/u128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fnum%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fnum%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu128.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -12,5 +12,5 @@\n //!\n //! *[See also the `u128` primitive type](../../std/primitive.u128.html).*\n \n-#![unstable(feature = \"i128\", issue=\"35118\")]\n-uint_module! { u128, #[unstable(feature = \"i128\", issue=\"35118\")] }\n+#![stable(feature = \"i128\", since = \"1.26.0\")]\n+uint_module! { u128, #[stable(feature = \"i128\", since=\"1.26.0\")] }"}, {"sha": "474f7e34c3470673e0def41a06f19a83fe568ab2", "filename": "src/libcore/ops/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -95,7 +95,7 @@\n pub trait Drop {\n     /// Executes the destructor for this type.\n     ///\n-    /// This method is called implilcitly when the value goes out of scope,\n+    /// This method is called implicitly when the value goes out of scope,\n     /// and cannot be called explicitly (this is compiler error [E0040]).\n     /// However, the [`std::mem::drop`] function in the prelude can be\n     /// used to call the argument's `Drop` implementation."}, {"sha": "4b70c5398be4f1e138cab935b7bc54cfed3d8b00", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -56,11 +56,11 @@ pub enum GeneratorState<Y, R> {\n ///         return \"foo\"\n ///     };\n ///\n-///     match generator.resume() {\n+///     match unsafe { generator.resume() } {\n ///         GeneratorState::Yielded(1) => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n-///     match generator.resume() {\n+///     match unsafe { generator.resume() } {\n ///         GeneratorState::Complete(\"foo\") => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n@@ -98,6 +98,10 @@ pub trait Generator {\n     /// generator will continue executing until it either yields or returns, at\n     /// which point this function will return.\n     ///\n+    /// The function is unsafe because it can be used on an immovable generator.\n+    /// After such a call, the immovable generator must not move again, but\n+    /// this is not enforced by the compiler.\n+    ///\n     /// # Return value\n     ///\n     /// The `GeneratorState` enum returned from this function indicates what\n@@ -116,7 +120,7 @@ pub trait Generator {\n     /// been returned previously. While generator literals in the language are\n     /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n     /// for all implementations of the `Generator` trait.\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n }\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n@@ -125,7 +129,7 @@ impl<'a, T> Generator for &'a mut T\n {\n     type Yield = T::Yield;\n     type Return = T::Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n         (**self).resume()\n     }\n }"}, {"sha": "ce4f45762de48d3571a3f8e68660262c6d844a75", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -161,7 +161,6 @@ mod drop;\n mod function;\n mod generator;\n mod index;\n-mod place;\n mod range;\n mod try;\n mod unsize;\n@@ -192,16 +191,13 @@ pub use self::index::{Index, IndexMut};\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-pub use self::range::{RangeInclusive, RangeToInclusive};\n+pub use self::range::{RangeInclusive, RangeToInclusive, RangeBounds, Bound};\n \n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::try::Try;\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub use self::generator::{Generator, GeneratorState};\n \n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n-\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n pub use self::unsize::CoerceUnsized;"}, {"sha": "b3dcf4e7ee9578c9e5155d563d332d10fe19e9ff", "filename": "src/libcore/ops/place.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Flibcore%2Fops%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Flibcore%2Fops%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fplace.rs?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,143 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Both `PLACE <- EXPR` and `box EXPR` desugar into expressions\n-/// that allocate an intermediate \"place\" that holds uninitialized\n-/// state.  The desugaring evaluates EXPR, and writes the result at\n-/// the address returned by the `pointer` method of this trait.\n-///\n-/// A `Place` can be thought of as a special representation for a\n-/// hypothetical `&uninit` reference (which Rust cannot currently\n-/// express directly). That is, it represents a pointer to\n-/// uninitialized storage.\n-///\n-/// The client is responsible for two steps: First, initializing the\n-/// payload (it can access its address via `pointer`). Second,\n-/// converting the agent to an instance of the owning pointer, via the\n-/// appropriate `finalize` method (see the `InPlace`.\n-///\n-/// If evaluating EXPR fails, then it is up to the destructor for the\n-/// implementation of Place to clean up any intermediate state\n-/// (e.g. deallocate box storage, pop a stack, etc).\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub unsafe trait Place<Data: ?Sized> {\n-    /// Returns the address where the input value will be written.\n-    /// Note that the data at this address is generally uninitialized,\n-    /// and thus one should use `ptr::write` for initializing it.\n-    ///\n-    /// This function must return a pointer through which a value\n-    /// of type `Data` can be written.\n-    fn pointer(&mut self) -> *mut Data;\n-}\n-\n-/// Interface to implementations of  `PLACE <- EXPR`.\n-///\n-/// `PLACE <- EXPR` effectively desugars into:\n-///\n-/// ```\n-/// # #![feature(placement_new_protocol, box_heap)]\n-/// # use std::ops::{Placer, Place, InPlace};\n-/// # #[allow(non_snake_case)]\n-/// # fn main() {\n-/// # let PLACE = std::boxed::HEAP;\n-/// # let EXPR = 1;\n-/// let p = PLACE;\n-/// let mut place = Placer::make_place(p);\n-/// let raw_place = Place::pointer(&mut place);\n-/// let value = EXPR;\n-/// unsafe {\n-///     std::ptr::write(raw_place, value);\n-///     InPlace::finalize(place)\n-/// }\n-/// # ; }\n-/// ```\n-///\n-/// The type of `PLACE <- EXPR` is derived from the type of `PLACE`;\n-/// if the type of `PLACE` is `P`, then the final type of the whole\n-/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n-/// traits).\n-///\n-/// Values for types implementing this trait usually are transient\n-/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n-/// or `Copy`, since the `make_place` method takes `self` by value.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Placer<Data: ?Sized> {\n-    /// `Place` is the intermediate agent guarding the\n-    /// uninitialized state for `Data`.\n-    type Place: InPlace<Data>;\n-\n-    /// Creates a fresh place from `self`.\n-    fn make_place(self) -> Self::Place;\n-}\n-\n-/// Specialization of `Place` trait supporting `PLACE <- EXPR`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait InPlace<Data: ?Sized>: Place<Data> {\n-    /// `Owner` is the type of the end value of `PLACE <- EXPR`\n-    ///\n-    /// Note that when `PLACE <- EXPR` is solely used for\n-    /// side-effecting an existing data-structure,\n-    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n-    /// information at all (e.g. it can be the unit type `()` in that\n-    /// case).\n-    type Owner;\n-\n-    /// Converts self into the final value, shifting\n-    /// deallocation/cleanup responsibilities (if any remain), over to\n-    /// the returned instance of `Owner` and forgetting self.\n-    unsafe fn finalize(self) -> Self::Owner;\n-}\n-\n-/// Core trait for the `box EXPR` form.\n-///\n-/// `box EXPR` effectively desugars into:\n-///\n-/// ```\n-/// # #![feature(placement_new_protocol)]\n-/// # use std::ops::{BoxPlace, Place, Boxed};\n-/// # #[allow(non_snake_case)]\n-/// # fn main() {\n-/// # let EXPR = 1;\n-/// let mut place = BoxPlace::make_place();\n-/// let raw_place = Place::pointer(&mut place);\n-/// let value = EXPR;\n-/// # let _: Box<_> =\n-/// unsafe {\n-///     ::std::ptr::write(raw_place, value);\n-///     Boxed::finalize(place)\n-/// }\n-/// # ; }\n-/// ```\n-///\n-/// The type of `box EXPR` is supplied from its surrounding\n-/// context; in the above expansion, the result type `T` is used\n-/// to determine which implementation of `Boxed` to use, and that\n-/// `<T as Boxed>` in turn dictates determines which\n-/// implementation of `BoxPlace` to use, namely:\n-/// `<<T as Boxed>::Place as BoxPlace>`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Boxed {\n-    /// The kind of data that is stored in this kind of box.\n-    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n-    /// The place that will negotiate the storage of the data.\n-    type Place: BoxPlace<Self::Data>;\n-\n-    /// Converts filled place into final owning value, shifting\n-    /// deallocation/cleanup responsibilities (if any remain), over to\n-    /// returned instance of `Self` and forgetting `filled`.\n-    unsafe fn finalize(filled: Self::Place) -> Self;\n-}\n-\n-/// Specialization of `Place` trait supporting `box EXPR`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n-    /// Creates a globally fresh place.\n-    fn make_place() -> Self;\n-}"}, {"sha": "3f6674071256696e45bf74c8229a05c85993dd71", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -442,3 +442,267 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n \n // RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n // because underflow would be possible with (..0).into()\n+\n+/// An endpoint of a range of keys.\n+///\n+/// # Examples\n+///\n+/// `Bound`s are range endpoints:\n+///\n+/// ```\n+/// #![feature(collections_range)]\n+///\n+/// use std::ops::Bound::*;\n+/// use std::ops::RangeBounds;\n+///\n+/// assert_eq!((..100).start(), Unbounded);\n+/// assert_eq!((1..12).start(), Included(&1));\n+/// assert_eq!((1..12).end(), Excluded(&12));\n+/// ```\n+///\n+/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n+/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n+///\n+/// ```\n+/// use std::collections::BTreeMap;\n+/// use std::ops::Bound::{Excluded, Included, Unbounded};\n+///\n+/// let mut map = BTreeMap::new();\n+/// map.insert(3, \"a\");\n+/// map.insert(5, \"b\");\n+/// map.insert(8, \"c\");\n+///\n+/// for (key, value) in map.range((Excluded(3), Included(8))) {\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n+/// ```\n+///\n+/// [`BTreeMap::range`]: ../../std/collections/btree_map/struct.BTreeMap.html#method.range\n+#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n+pub enum Bound<T> {\n+    /// An inclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Included(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n+    /// An exclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Excluded(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n+    /// An infinite endpoint. Indicates that there is no bound in this direction.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Unbounded,\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+/// `RangeBounds` is implemented by Rust's built-in range types, produced\n+/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+pub trait RangeBounds<T: ?Sized> {\n+    /// Start index bound.\n+    ///\n+    /// Returns the start value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections_range)]\n+    ///\n+    /// # fn main() {\n+    /// use std::ops::Bound::*;\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// assert_eq!((..10).start(), Unbounded);\n+    /// assert_eq!((3..10).start(), Included(&3));\n+    /// # }\n+    /// ```\n+    fn start(&self) -> Bound<&T>;\n+\n+    /// End index bound.\n+    ///\n+    /// Returns the end value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections_range)]\n+    ///\n+    /// # fn main() {\n+    /// use std::ops::Bound::*;\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// assert_eq!((3..).end(), Unbounded);\n+    /// assert_eq!((3..10).end(), Excluded(&10));\n+    /// # }\n+    /// ```\n+    fn end(&self) -> Bound<&T>;\n+}\n+\n+use self::Bound::{Excluded, Included, Unbounded};\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T: ?Sized> RangeBounds<T> for RangeFull {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeFrom<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeTo<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for Range<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeToInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n+    fn start(&self) -> Bound<&T> {\n+        match *self {\n+            (Included(ref start), _) => Included(start),\n+            (Excluded(ref start), _) => Excluded(start),\n+            (Unbounded, _)           => Unbounded,\n+        }\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        match *self {\n+            (_, Included(ref end)) => Included(end),\n+            (_, Excluded(ref end)) => Excluded(end),\n+            (_, Unbounded)         => Unbounded,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n+    fn start(&self) -> Bound<&T> {\n+        self.0\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        self.1\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeFrom<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeTo<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for Range<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeInclusive<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeToInclusive<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(self.end)\n+    }\n+}"}, {"sha": "ef6a8fb6a61c105686f26cef42068178ab4e46b1", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -20,7 +20,7 @@\n        any(from_method=\"from_error\", from_method=\"from_ok\"),\n        from_desugaring=\"?\"),\n       message=\"the `?` operator can only be used in a \\\n-               function that returns `Result` \\\n+               function that returns `Result` or `Option` \\\n                (or another type that implements `{Try}`)\",\n       label=\"cannot use the `?` operator in a function that returns `{Self}`\"),\n    on(all(from_method=\"into_result\", from_desugaring=\"?\"),"}, {"sha": "61ef6798b2efb2062d5c874f531c86171a573c22", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1188,6 +1188,16 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n                     None => None,\n                 }\n             }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                if self.found_none {\n+                    (0, Some(0))\n+                } else {\n+                    let (_, upper) = self.iter.size_hint();\n+                    (0, upper)\n+                }\n+            }\n         }\n \n         let mut adapter = Adapter { iter: iter.into_iter(), found_none: false };"}, {"sha": "5a54de06b5ef2bf55cd99509d1233582a5996db4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 255, "deletions": 20, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -23,7 +23,7 @@ use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n use mem;\n-use nonzero::NonZero;\n+#[allow(deprecated)] use nonzero::NonZero;\n \n use cmp::Ordering::{self, Less, Equal, Greater};\n \n@@ -669,7 +669,7 @@ impl<T: ?Sized> *const T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n-    /// This function returns `None` if `T` is a zero-sized typed.\n+    /// This function returns `None` if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -700,6 +700,124 @@ impl<T: ?Sized> *const T {\n         }\n     }\n \n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T`.\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        // This is the same sequence that Clang emits for pointer subtraction.\n+        // It can be neither `nsw` nor `nuw` because the input is treated as\n+        // unsigned but then the output is treated as signed, so neither works.\n+        let d = isize::wrapping_sub(self as _, origin as _);\n+        intrinsics::exact_div(d, pointee_size as _)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *const i32 = 3 as _;\n+    /// let ptr2: *const i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        let d = isize::wrapping_sub(self as _, origin as _);\n+        d.wrapping_div(pointee_size as _)\n+    }\n+\n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n     /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n@@ -1316,7 +1434,7 @@ impl<T: ?Sized> *mut T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n-    /// This function returns `None` if `T` is a zero-sized typed.\n+    /// This function returns `None` if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -1347,6 +1465,113 @@ impl<T: ?Sized> *mut T {\n         }\n     }\n \n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset-1\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T`.\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        (self as *const T).offset_from(origin)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *mut i32 = 3 as _;\n+    /// let ptr2: *mut i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+        (self as *const T).wrapping_offset_from(origin)\n+    }\n+\n     /// Computes the byte offset that needs to be applied in order to\n     /// make the pointer aligned to `align`.\n     /// If it is not possible to align the pointer, the implementation returns\n@@ -2285,6 +2510,7 @@ impl<T: ?Sized> PartialOrd for *mut T {\n #[unstable(feature = \"ptr_internals\", issue = \"0\",\n            reason = \"use NonNull instead and consider PhantomData<T> \\\n                      (if you also use #[may_dangle]), Send, and/or Sync\")]\n+#[allow(deprecated)]\n pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     // NOTE: this marker has no consequences for variance, but is necessary\n@@ -2332,24 +2558,29 @@ impl<T: Sized> Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n+        Unique { pointer: NonZero(ptr as _), _marker: PhantomData }\n     }\n \n     /// Creates a new `Unique` if `ptr` is non-null.\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        NonZero::new(ptr as *const T).map(|nz| Unique { pointer: nz, _marker: PhantomData })\n+        if !ptr.is_null() {\n+            Some(Unique { pointer: NonZero(ptr as _), _marker: PhantomData })\n+        } else {\n+            None\n+        }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n     pub fn as_ptr(self) -> *mut T {\n-        self.pointer.get() as *mut T\n+        self.pointer.0 as *mut T\n     }\n \n     /// Dereferences the content.\n@@ -2392,16 +2623,18 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n     }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n     fn from(reference: &'a T) -> Self {\n-        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n     }\n }\n \n@@ -2412,11 +2645,6 @@ impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n     }\n }\n \n-/// Previous name of `NonNull`.\n-#[rustc_deprecated(since = \"1.25.0\", reason = \"renamed to `NonNull`\")]\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-pub type Shared<T> = NonNull<T>;\n-\n /// `*mut T` but non-zero and covariant.\n ///\n /// This is often the correct thing to use when building data structures using\n@@ -2425,7 +2653,7 @@ pub type Shared<T> = NonNull<T>;\n ///\n /// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n /// is never dereferenced. This is so that enums may use this forbidden value\n-/// as a discriminant -- `Option<NonNull<T>>` has the same size as `NonNull<T>`.\n+/// as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n /// However the pointer may still dangle if it isn't dereferenced.\n ///\n /// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n@@ -2436,7 +2664,7 @@ pub type Shared<T> = NonNull<T>;\n /// provide a public API that follows the normal shared XOR mutable rules of Rust.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n pub struct NonNull<T: ?Sized> {\n-    pointer: NonZero<*const T>,\n+    #[allow(deprecated)] pointer: NonZero<*const T>,\n }\n \n /// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n@@ -2463,6 +2691,7 @@ impl<T: Sized> NonNull<T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<T: ?Sized> NonNull<T> {\n     /// Creates a new `NonNull`.\n     ///\n@@ -2471,19 +2700,23 @@ impl<T: ?Sized> NonNull<T> {\n     /// `ptr` must be non-null.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: NonZero::new_unchecked(ptr) }\n+        NonNull { pointer: NonZero(ptr as _) }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        NonZero::new(ptr as *const T).map(|nz| NonNull { pointer: nz })\n+        if !ptr.is_null() {\n+            Some(NonNull { pointer: NonZero(ptr as _) })\n+        } else {\n+            None\n+        }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub fn as_ptr(self) -> *mut T {\n-        self.pointer.get() as *mut T\n+        self.pointer.0 as *mut T\n     }\n \n     /// Dereferences the content.\n@@ -2581,15 +2814,17 @@ impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        NonNull { pointer: NonZero::from(reference) }\n+        NonNull { pointer: NonZero(reference as _) }\n     }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n     fn from(reference: &'a T) -> Self {\n-        NonNull { pointer: NonZero::from(reference) }\n+        NonNull { pointer: NonZero(reference as _) }\n     }\n }"}, {"sha": "1185b7acaae1f3101d34307983185843208ae8f0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -165,6 +165,37 @@ Section: Creating a string\n ///\n /// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n /// [`&str`]: ../../std/str/fn.from_utf8.html\n+///\n+/// # Examples\n+///\n+/// This error type\u2019s methods can be used to create functionality\n+/// similar to `String::from_utf8_lossy` without allocating heap memory:\n+///\n+/// ```\n+/// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n+///     loop {\n+///         match ::std::str::from_utf8(input) {\n+///             Ok(valid) => {\n+///                 push(valid);\n+///                 break\n+///             }\n+///             Err(error) => {\n+///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n+///                 unsafe {\n+///                     push(::std::str::from_utf8_unchecked(valid))\n+///                 }\n+///                 push(\"\\u{FFFD}\");\n+///\n+///                 if let Some(invalid_sequence_length) = error.error_len() {\n+///                     input = &after_valid[invalid_sequence_length..]\n+///                 } else {\n+///                     break\n+///                 }\n+///             }\n+///         }\n+///     }\n+/// }\n+/// ```\n #[derive(Copy, Eq, PartialEq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {"}, {"sha": "d336934ec7214ad56668dae5428abfef74ee7514", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 591, "deletions": 366, "changes": 957, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -205,8 +205,11 @@ pub enum Ordering {\n     /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n-    /// When coupled with a load, uses [`Acquire`] ordering, and with a store\n-    /// [`Release`] ordering.\n+    /// Has the effects of both [`Acquire`] and [`Release`] together.\n+    ///\n+    /// This ordering is only applicable for operations that combine both loads and stores.\n+    ///\n+    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n     ///\n     /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n     /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n@@ -948,6 +951,8 @@ macro_rules! atomic_int {\n      $stable_from:meta,\n      $stable_nand:meta,\n      $s_int_type:expr, $int_ref:expr,\n+     $extra_feature:expr,\n+     $min_fn:ident, $max_fn:ident,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n@@ -959,12 +964,7 @@ macro_rules! atomic_int {\n         /// ). For more about the differences between atomic types and\n         /// non-atomic types, please see the [module-level documentation].\n         ///\n-        /// Please note that examples are shared between atomic variants of\n-        /// primitive integer types, so it's normal that they are all\n-        /// demonstrating [`AtomicIsize`].\n-        ///\n         /// [module-level documentation]: index.html\n-        /// [`AtomicIsize`]: struct.AtomicIsize.html\n         #[$stable]\n         pub struct $atomic_type {\n             v: UnsafeCell<$int_type>,\n@@ -1001,396 +1001,549 @@ macro_rules! atomic_int {\n         unsafe impl Sync for $atomic_type {}\n \n         impl $atomic_type {\n-            /// Creates a new atomic integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::AtomicIsize;\n-            ///\n-            /// let atomic_forty_two  = AtomicIsize::new(42);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub const fn new(v: $int_type) -> Self {\n-                $atomic_type {v: UnsafeCell::new(v)}\n+            doc_comment! {\n+                concat!(\"Creates a new atomic integer.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub const fn new(v: $int_type) -> Self {\n+                    $atomic_type {v: UnsafeCell::new(v)}\n+                }\n             }\n \n-            /// Returns a mutable reference to the underlying integer.\n-            ///\n-            /// This is safe because the mutable reference guarantees that no other threads are\n-            /// concurrently accessing the atomic data.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let mut some_isize = AtomicIsize::new(10);\n-            /// assert_eq!(*some_isize.get_mut(), 10);\n-            /// *some_isize.get_mut() = 5;\n-            /// assert_eq!(some_isize.load(Ordering::SeqCst), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable_access]\n-            pub fn get_mut(&mut self) -> &mut $int_type {\n-                unsafe { &mut *self.v.get() }\n+            doc_comment! {\n+                concat!(\"Returns a mutable reference to the underlying integer.\n+\n+This is safe because the mutable reference guarantees that no other threads are\n+concurrently accessing the atomic data.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let mut some_var = \", stringify!($atomic_type), \"::new(10);\n+assert_eq!(*some_var.get_mut(), 10);\n+*some_var.get_mut() = 5;\n+assert_eq!(some_var.load(Ordering::SeqCst), 5);\n+```\"),\n+                #[inline]\n+                #[$stable_access]\n+                pub fn get_mut(&mut self) -> &mut $int_type {\n+                    unsafe { &mut *self.v.get() }\n+                }\n             }\n \n-            /// Consumes the atomic and returns the contained value.\n-            ///\n-            /// This is safe because passing `self` by value guarantees that no other threads are\n-            /// concurrently accessing the atomic data.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::AtomicIsize;\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            /// assert_eq!(some_isize.into_inner(), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable_access]\n-            pub fn into_inner(self) -> $int_type {\n-                self.v.into_inner()\n+            doc_comment! {\n+                concat!(\"Consumes the atomic and returns the contained value.\n+\n+This is safe because passing `self` by value guarantees that no other threads are\n+concurrently accessing the atomic data.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+assert_eq!(some_var.into_inner(), 5);\n+```\"),\n+                #[inline]\n+                #[$stable_access]\n+                pub fn into_inner(self) -> $int_type {\n+                    self.v.into_inner()\n+                }\n             }\n \n-            /// Loads a value from the atomic integer.\n-            ///\n-            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `order` is [`Release`] or [`AcqRel`].\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn load(&self, order: Ordering) -> $int_type {\n-                unsafe { atomic_load(self.v.get(), order) }\n+            doc_comment! {\n+                concat!(\"Loads a value from the atomic integer.\n+\n+`load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+# Panics\n+\n+Panics if `order` is [`Release`] or [`AcqRel`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.load(Ordering::Relaxed), 5);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn load(&self, order: Ordering) -> $int_type {\n+                    unsafe { atomic_load(self.v.get(), order) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer.\n-            ///\n-            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// some_isize.store(10, Ordering::Relaxed);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n-            ///\n-            /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            #[inline]\n-            #[$stable]\n-            pub fn store(&self, val: $int_type, order: Ordering) {\n-                unsafe { atomic_store(self.v.get(), val, order); }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer.\n+\n+`store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+some_var.store(10, Ordering::Relaxed);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\n+\n+# Panics\n+\n+Panics if `order` is [`Acquire`] or [`AcqRel`].\n+\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn store(&self, val: $int_type, order: Ordering) {\n+                    unsafe { atomic_store(self.v.get(), val, order); }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer, returning the previous value.\n-            ///\n-            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_swap(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer, returning the previous value.\n+\n+`swap` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_swap(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// The return value is always the previous value. If it is equal to `current`, then the\n-            /// value was updated.\n-            ///\n-            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-            /// ordering of this operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            ///\n-            /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn compare_and_swap(&self,\n-                                    current: $int_type,\n-                                    new: $int_type,\n-                                    order: Ordering) -> $int_type {\n-                match self.compare_exchange(current,\n-                                            new,\n-                                            order,\n-                                            strongest_failure_ordering(order)) {\n-                    Ok(x) => x,\n-                    Err(x) => x,\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+The return value is always the previous value. If it is equal to `current`, then the\n+value was updated.\n+\n+`compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+\n+assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn compare_and_swap(&self,\n+                                        current: $int_type,\n+                                        new: $int_type,\n+                                        order: Ordering) -> $int_type {\n+                    match self.compare_exchange(current,\n+                                                new,\n+                                                order,\n+                                                strongest_failure_ordering(order)) {\n+                        Ok(x) => x,\n+                        Err(x) => x,\n+                    }\n                 }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// The return value is a result indicating whether the new value was written and\n-            /// containing the previous value. On success this value is guaranteed to be equal to\n-            /// `current`.\n-            ///\n-            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-            /// ordering of this operation. The first describes the required ordering if\n-            /// the operation succeeds while the second describes the required ordering when\n-            /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-            /// must be equivalent or weaker than the success ordering.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.compare_exchange(5, 10,\n-            ///                                        Ordering::Acquire,\n-            ///                                        Ordering::Relaxed),\n-            ///            Ok(5));\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            ///\n-            /// assert_eq!(some_isize.compare_exchange(6, 12,\n-            ///                                        Ordering::SeqCst,\n-            ///                                        Ordering::Acquire),\n-            ///            Err(10));\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable_cxchg]\n-            pub fn compare_exchange(&self,\n-                                    current: $int_type,\n-                                    new: $int_type,\n-                                    success: Ordering,\n-                                    failure: Ordering) -> Result<$int_type, $int_type> {\n-                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+The return value is a result indicating whether the new value was written and\n+containing the previous value. On success this value is guaranteed to be equal to\n+`current`.\n+\n+`compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering if\n+the operation succeeds while the second describes the required ordering when\n+the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+must be equivalent or weaker than the success ordering.\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.compare_exchange(5, 10,\n+                                     Ordering::Acquire,\n+                                     Ordering::Relaxed),\n+           Ok(5));\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+\n+assert_eq!(some_var.compare_exchange(6, 12,\n+                                     Ordering::SeqCst,\n+                                     Ordering::Acquire),\n+           Err(10));\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\"),\n+                #[inline]\n+                #[$stable_cxchg]\n+                pub fn compare_exchange(&self,\n+                                        current: $int_type,\n+                                        new: $int_type,\n+                                        success: Ordering,\n+                                        failure: Ordering) -> Result<$int_type, $int_type> {\n+                    unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n-            /// when the comparison succeeds, which can result in more efficient code on some\n-            /// platforms. The return value is a result indicating whether the new value was\n-            /// written and containing the previous value.\n-            ///\n-            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-            /// ordering of this operation. The first describes the required ordering if the\n-            /// operation succeeds while the second describes the required ordering when the\n-            /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-            /// must be equivalent or weaker than the success ordering.\n-            ///\n-            /// [`compare_exchange`]: #method.compare_exchange\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let val = AtomicIsize::new(4);\n-            ///\n-            /// let mut old = val.load(Ordering::Relaxed);\n-            /// loop {\n-            ///     let new = old * 2;\n-            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-            ///         Ok(_) => break,\n-            ///         Err(x) => old = x,\n-            ///     }\n-            /// }\n-            /// ```\n-            #[inline]\n-            #[$stable_cxchg]\n-            pub fn compare_exchange_weak(&self,\n-                                         current: $int_type,\n-                                         new: $int_type,\n-                                         success: Ordering,\n-                                         failure: Ordering) -> Result<$int_type, $int_type> {\n-                unsafe {\n-                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n+when the comparison succeeds, which can result in more efficient code on some\n+platforms. The return value is a result indicating whether the new value was\n+written and containing the previous value.\n+\n+`compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering if the\n+operation succeeds while the second describes the required ordering when the\n+operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+must be equivalent or weaker than the success ordering.\n+\n+[`compare_exchange`]: #method.compare_exchange\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let val = \", stringify!($atomic_type), \"::new(4);\n+\n+let mut old = val.load(Ordering::Relaxed);\n+loop {\n+    let new = old * 2;\n+    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+        Ok(_) => break,\n+        Err(x) => old = x,\n+    }\n+}\n+```\"),\n+                #[inline]\n+                #[$stable_cxchg]\n+                pub fn compare_exchange_weak(&self,\n+                                             current: $int_type,\n+                                             new: $int_type,\n+                                             success: Ordering,\n+                                             failure: Ordering) -> Result<$int_type, $int_type> {\n+                    unsafe {\n+                        atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+                    }\n                 }\n             }\n \n-            /// Adds to the current value, returning the previous value.\n-            ///\n-            /// This operation wraps around on overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0);\n-            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_add(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Adds to the current value, returning the previous value.\n+\n+This operation wraps around on overflow.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0);\n+assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n+assert_eq!(foo.load(Ordering::SeqCst), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_add(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Subtracts from the current value, returning the previous value.\n-            ///\n-            /// This operation wraps around on overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0);\n-            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_sub(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Subtracts from the current value, returning the previous value.\n+\n+This operation wraps around on overflow.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(20);\n+assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n+assert_eq!(foo.load(Ordering::SeqCst), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_sub(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"and\" with the current value.\n-            ///\n-            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_and(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"and\\\" with the current value.\n+\n+Performs a bitwise \\\"and\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_and(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"nand\" with the current value.\n-            ///\n-            /// Performs a bitwise \"nand\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// #![feature(atomic_nand)]\n-            ///\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0xf731);\n-            /// assert_eq!(foo.fetch_nand(0x137f, Ordering::SeqCst), 0xf731);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), !(0xf731 & 0x137f));\n-            #[inline]\n-            #[$stable_nand]\n-            pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_nand(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"nand\\\" with the current value.\n+\n+Performs a bitwise \\\"nand\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"#![feature(atomic_nand)]\n+\n+use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0x13);\n+assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n+assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n+```\"),\n+                #[inline]\n+                #[$stable_nand]\n+                pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_nand(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"or\" with the current value.\n-            ///\n-            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_or(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"or\\\" with the current value.\n+\n+Performs a bitwise \\\"or\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_or(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"xor\" with the current value.\n-            ///\n-            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_xor(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"xor\\\" with the current value.\n+\n+Performs a bitwise \\\"xor\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_xor(self.v.get(), val, order) }\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Fetches the value, and applies a function to it that returns an optional\n+new value. Returns a `Result` (`Ok(_)` if the function returned `Some(_)`, else `Err(_)`) of the\n+previous value.\n+\n+Note: This may call the function multiple times if the value has been changed from other threads in\n+the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n+but once to the stored value.\n+\n+# Examples\n+\n+```rust\n+#![feature(no_more_cas)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let x = \", stringify!($atomic_type), \"::new(7);\n+assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n+assert_eq!(x.load(Ordering::SeqCst), 9);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"no_more_cas\",\n+                       reason = \"no more CAS loops in user code\",\n+                       issue = \"48655\")]\n+                pub fn fetch_update<F>(&self,\n+                                       mut f: F,\n+                                       fetch_order: Ordering,\n+                                       set_order: Ordering) -> Result<$int_type, $int_type>\n+                where F: FnMut($int_type) -> Option<$int_type> {\n+                    let mut prev = self.load(fetch_order);\n+                    while let Some(next) = f(prev) {\n+                        match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                            x @ Ok(_) => return x,\n+                            Err(next_prev) => prev = next_prev\n+                        }\n+                    }\n+                    Err(prev)\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Maximum with the current value.\n+\n+Finds the maximum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n+assert_eq!(foo.load(Ordering::SeqCst), 42);\n+```\n+\n+If you want to obtain the maximum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 42;\n+let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n+assert!(max_foo == 42);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $max_fn(self.v.get(), val, order) }\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Minimum with the current value.\n+\n+Finds the minimum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 23);\n+assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 22);\n+```\n+\n+If you want to obtain the minimum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 12;\n+let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n+assert_eq!(min_foo, 12);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $min_fn(self.v.get(), val, order) }\n+                }\n             }\n+\n         }\n     }\n }\n@@ -1404,6 +1557,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n@@ -1415,6 +1570,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1426,6 +1583,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1437,6 +1596,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1448,6 +1609,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1459,6 +1622,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1470,6 +1635,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1481,6 +1648,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1492,6 +1661,8 @@ atomic_int!{\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"isize\", \"../../../std/primitive.isize.html\",\n+    \"\",\n+    atomic_min, atomic_max,\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1503,6 +1674,8 @@ atomic_int!{\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"usize\", \"../../../std/primitive.usize.html\",\n+    \"\",\n+    atomic_umin, atomic_umax,\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n \n@@ -1680,6 +1853,58 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_max_acq(dst, val),\n+        Release => intrinsics::atomic_max_rel(dst, val),\n+        AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_max(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_min_acq(dst, val),\n+        Release => intrinsics::atomic_min_rel(dst, val),\n+        AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_min(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umax_acq(dst, val),\n+        Release => intrinsics::atomic_umax_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umax(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umin_acq(dst, val),\n+        Release => intrinsics::atomic_umin_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umin(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n /// An atomic fence.\n ///\n /// Depending on the specified order, a fence prevents the compiler and CPU from"}, {"sha": "950222dbcfa3fe8d303097e6832e0af6af648196", "filename": "src/libcore/tests/ascii.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use core::char::from_u32;\n-use std::ascii::AsciiExt;\n \n #[test]\n fn test_is_ascii() {\n@@ -143,8 +142,6 @@ macro_rules! assert_all {\n                            stringify!($what), b);\n                 }\n             }\n-            assert!($str.$what());\n-            assert!($str.as_bytes().$what());\n         )+\n     }};\n     ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))"}, {"sha": "2abac0cf1d5b93bd01ca47407eb4e0b997e3ce69", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1146,6 +1146,33 @@ fn test_find() {\n     assert!(v.iter().find(|&&x| x % 12 == 0).is_none());\n }\n \n+#[test]\n+fn test_find_map() {\n+    let xs: &[isize] = &[];\n+    assert_eq!(xs.iter().find_map(half_if_even), None);\n+    let xs: &[isize] = &[3, 5];\n+    assert_eq!(xs.iter().find_map(half_if_even), None);\n+    let xs: &[isize] = &[4, 5];\n+    assert_eq!(xs.iter().find_map(half_if_even), Some(2));\n+    let xs: &[isize] = &[3, 6];\n+    assert_eq!(xs.iter().find_map(half_if_even), Some(3));\n+\n+    let xs: &[isize] = &[1, 2, 3, 4, 5, 6, 7];\n+    let mut iter = xs.iter();\n+    assert_eq!(iter.find_map(half_if_even), Some(1));\n+    assert_eq!(iter.find_map(half_if_even), Some(2));\n+    assert_eq!(iter.find_map(half_if_even), Some(3));\n+    assert_eq!(iter.next(), Some(&7));\n+\n+    fn half_if_even(x: &isize) -> Option<isize> {\n+        if x % 2 == 0 {\n+            Some(x / 2)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[test]\n fn test_position() {\n     let v = &[1, 3, 9, 27, 103, 14, 11];"}, {"sha": "de7211e718c9f20333b33a576cbf019f71cc1389", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -23,13 +23,10 @@\n #![feature(fmt_internals)]\n #![feature(hashmap_internals)]\n #![feature(iterator_step_by)]\n-#![feature(i128_type)]\n+#![cfg_attr(stage0, feature(i128_type))]\n #![cfg_attr(stage0, feature(inclusive_range_syntax))]\n-#![feature(iterator_try_fold)]\n #![feature(iterator_flatten)]\n-#![feature(conservative_impl_trait)]\n-#![feature(iter_rfind)]\n-#![feature(iter_rfold)]\n+#![cfg_attr(stage0, feature(conservative_impl_trait))]\n #![feature(iterator_repeat_with)]\n #![feature(nonzero)]\n #![feature(pattern)]\n@@ -43,12 +40,12 @@\n #![feature(step_trait)]\n #![feature(test)]\n #![feature(trusted_len)]\n-#![feature(try_from)]\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n #![feature(atomic_nand)]\n #![feature(reverse_bits)]\n #![feature(inclusive_range_fields)]\n+#![feature(iterator_find_map)]\n \n extern crate core;\n extern crate test;"}, {"sha": "8d39298bac3d1b1b3cd13210987fac5e94a1bf71", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -8,36 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::nonzero::NonZero;\n+use core::num::NonZeroU32;\n use core::option::Option;\n use core::option::Option::{Some, None};\n use std::mem::size_of;\n \n #[test]\n fn test_create_nonzero_instance() {\n     let _a = unsafe {\n-        NonZero::new_unchecked(21)\n+        NonZeroU32::new_unchecked(21)\n     };\n }\n \n #[test]\n fn test_size_nonzero_in_option() {\n-    assert_eq!(size_of::<NonZero<u32>>(), size_of::<Option<NonZero<u32>>>());\n+    assert_eq!(size_of::<NonZeroU32>(), size_of::<Option<NonZeroU32>>());\n }\n \n #[test]\n fn test_match_on_nonzero_option() {\n     let a = Some(unsafe {\n-        NonZero::new_unchecked(42)\n+        NonZeroU32::new_unchecked(42)\n     });\n     match a {\n         Some(val) => assert_eq!(val.get(), 42),\n-        None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n+        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\")\n     }\n \n-    match unsafe { Some(NonZero::new_unchecked(43)) } {\n+    match unsafe { Some(NonZeroU32::new_unchecked(43)) } {\n         Some(val) => assert_eq!(val.get(), 43),\n-        None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n+        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\")\n     }\n }\n \n@@ -98,3 +98,26 @@ fn test_match_option_string() {\n         None => panic!(\"unexpected None while matching on Some(String { ... })\")\n     }\n }\n+\n+mod atom {\n+    use core::num::NonZeroU32;\n+\n+    #[derive(PartialEq, Eq)]\n+    pub struct Atom {\n+        index: NonZeroU32, // private\n+    }\n+    pub const FOO_ATOM: Atom = Atom { index: unsafe { NonZeroU32::new_unchecked(7) } };\n+}\n+\n+macro_rules! atom {\n+    (\"foo\") => { atom::FOO_ATOM }\n+}\n+\n+#[test]\n+fn test_match_nonzero_const_pattern() {\n+    match atom!(\"foo\") {\n+        // Using as a pattern is supported by the compiler:\n+        atom!(\"foo\") => {}\n+        _ => panic!(\"Expected the const item as a pattern to match.\")\n+    }\n+}"}, {"sha": "c7edb55b378c36ce1208c32a96ef6b448f15c778", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -37,15 +37,6 @@ mod flt2dec;\n mod dec2flt;\n mod bignum;\n \n-\n-/// Adds the attribute to all items in the block.\n-macro_rules! cfg_block {\n-    ($(#[$attr:meta]{$($it:item)*})*) => {$($(\n-        #[$attr]\n-        $it\n-    )*)*}\n-}\n-\n /// Groups items that assume the pointer width is either 16/32/64, and has to be altered if\n /// support for larger/smaller pointer widths are added in the future.\n macro_rules! assume_usize_width {\n@@ -318,42 +309,6 @@ assume_usize_width! {\n \n     test_impl_try_from_always_ok! { test_try_u16usize, u16, usize }\n     test_impl_try_from_always_ok! { test_try_i16isize, i16, isize }\n-\n-    test_impl_try_from_always_ok! { test_try_usizeu64, usize, u64 }\n-    test_impl_try_from_always_ok! { test_try_usizeu128, usize, u128 }\n-    test_impl_try_from_always_ok! { test_try_usizei128, usize, i128 }\n-\n-    test_impl_try_from_always_ok! { test_try_isizei64, isize, i64 }\n-    test_impl_try_from_always_ok! { test_try_isizei128, isize, i128 }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_always_ok! { test_try_usizeu16, usize, u16 }\n-            test_impl_try_from_always_ok! { test_try_isizei16, isize, i16 }\n-            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n-            test_impl_try_from_always_ok! { test_try_usizei32, usize, i32 }\n-            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n-            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n-            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n-            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_always_ok! { test_try_u32isize, u32, isize }\n-            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_always_ok! { test_try_u64usize, u64, usize }\n-            test_impl_try_from_always_ok! { test_try_i64isize, i64, isize }\n-        }\n-    );\n }\n \n /// Conversions where max of $source can be represented as $target,\n@@ -402,24 +357,6 @@ assume_usize_width! {\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu64, isize, u64 }\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu128, isize, u128 }\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeusize, isize, usize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu16, isize, u16 }\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n-\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64usize, i64, usize }\n-        }\n-    );\n }\n \n /// Conversions where max of $source can not be represented as $target,\n@@ -461,29 +398,9 @@ test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i64, u128, i64 }\n test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i128, u128, i128 }\n \n assume_usize_width! {\n-    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64isize, u64, isize }\n-    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128isize, u128, isize }\n-\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei8, usize, i8 }\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei16, usize, i16 }\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizeisize, usize, isize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei64, usize, i64 }\n-        }\n-    );\n }\n \n /// Conversions where min/max of $source can not be represented as $target.\n@@ -543,34 +460,6 @@ test_impl_try_from_same_sign_err! { test_try_i128i64, i128, i64 }\n \n assume_usize_width! {\n     test_impl_try_from_same_sign_err! { test_try_usizeu8, usize, u8 }\n-    test_impl_try_from_same_sign_err! { test_try_u128usize, u128, usize }\n-    test_impl_try_from_same_sign_err! { test_try_i128isize, i128, isize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_same_sign_err! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n-\n-            test_impl_try_from_same_sign_err! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n-            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n-\n-            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n-            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n-            test_impl_try_from_same_sign_err! { test_try_usizeu32, usize, u32 }\n-\n-            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n-            test_impl_try_from_same_sign_err! { test_try_isizei32, isize, i32 }\n-        }\n-    );\n }\n \n /// Conversions where neither the min nor the max of $source can be represented by\n@@ -615,22 +504,6 @@ test_impl_try_from_signed_to_unsigned_err! { test_try_i128u64, i128, u64 }\n assume_usize_width! {\n     test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu8, isize, u8 }\n     test_impl_try_from_signed_to_unsigned_err! { test_try_i128usize, i128, usize }\n-\n-    cfg_block! {\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i32usize, i32, usize }\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n-        }\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n-\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n-        }\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu32, isize, u32 }\n-        }\n-    }\n }\n \n macro_rules! test_float {"}, {"sha": "81fa0374f549e903f5384737f1d000d6c4a8ba2d", "filename": "src/libgetopts/lib.rs", "status": "removed", "additions": 0, "deletions": 1622, "changes": 1622, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=446285e45c02f71392c7084328dc167d2e1ff58c", "patch": "@@ -1,1622 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple getopt alternative.\n-//!\n-//! Construct a vector of options, either by using `reqopt`, `optopt`, and `optflag`\n-//! or by building them from components yourself, and pass them to `getopts`,\n-//! along with a vector of actual arguments (not including `argv[0]`). You'll\n-//! either get a failure code back, or a match. You'll have to verify whether\n-//! the amount of 'free' arguments in the match is what you expect. Use `opt_*`\n-//! accessors to get argument values out of the matches object.\n-//!\n-//! Single-character options are expected to appear on the command line with a\n-//! single preceding dash; multiple-character options are expected to be\n-//! proceeded by two dashes. Options that expect an argument accept their\n-//! argument following either a space or an equals sign. Single-character\n-//! options don't require the space.\n-//!\n-//! # Example\n-//!\n-//! The following example shows simple command line parsing for an application\n-//! that requires an input file to be specified, accepts an optional output\n-//! file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n-//!\n-//! ```{.rust}\n-//! #![feature(rustc_private)]\n-//!\n-//! extern crate getopts;\n-//! use getopts::{optopt,optflag,getopts,OptGroup,usage};\n-//! use std::env;\n-//!\n-//! fn do_work(inp: &str, out: Option<String>) {\n-//!     println!(\"{}\", inp);\n-//!     match out {\n-//!         Some(x) => println!(\"{}\", x),\n-//!         None => println!(\"No Output\"),\n-//!     }\n-//! }\n-//!\n-//! fn print_usage(program: &str, opts: &[OptGroup]) {\n-//!     let brief = format!(\"Usage: {} [options]\", program);\n-//!     print!(\"{}\", usage(&brief, opts));\n-//! }\n-//!\n-//! fn main() {\n-//!     let args: Vec<String> = env::args().collect();\n-//!\n-//!     let program = args[0].clone();\n-//!\n-//!     let opts = &[\n-//!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n-//!         optflag(\"h\", \"help\", \"print this help menu\")\n-//!     ];\n-//!     let matches = match getopts(&args[1..], opts) {\n-//!         Ok(m) => { m }\n-//!         Err(f) => { panic!(f.to_string()) }\n-//!     };\n-//!     if matches.opt_present(\"h\") {\n-//!         print_usage(&program, opts);\n-//!         return;\n-//!     }\n-//!     let output = matches.opt_str(\"o\");\n-//!     let input = if !matches.free.is_empty() {\n-//!         matches.free[0].clone()\n-//!     } else {\n-//!         print_usage(&program, opts);\n-//!         return;\n-//!     };\n-//!     do_work(&input, output);\n-//! }\n-//! ```\n-\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-\n-#![deny(missing_docs)]\n-#![deny(warnings)]\n-\n-use self::Name::*;\n-use self::HasArg::*;\n-use self::Occur::*;\n-use self::Fail::*;\n-use self::Optval::*;\n-use self::SplitWithinState::*;\n-use self::Whitespace::*;\n-use self::LengthLimit::*;\n-\n-use std::fmt;\n-use std::iter::repeat;\n-use std::result;\n-\n-/// Name of an option. Either a string or a single char.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Name {\n-    /// A string representing the long name of an option.\n-    /// For example: \"help\"\n-    Long(String),\n-    /// A char representing the short name of an option.\n-    /// For example: 'h'\n-    Short(char),\n-}\n-\n-/// Describes whether an option has an argument.\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum HasArg {\n-    /// The option requires an argument.\n-    Yes,\n-    /// The option takes no argument.\n-    No,\n-    /// The option argument is optional.\n-    Maybe,\n-}\n-\n-/// Describes how often an option may occur.\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum Occur {\n-    /// The option occurs once.\n-    Req,\n-    /// The option occurs at most once.\n-    Optional,\n-    /// The option occurs zero or more times.\n-    Multi,\n-}\n-\n-/// A description of a possible option.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Opt {\n-    /// Name of the option\n-    pub name: Name,\n-    /// Whether it has an argument\n-    pub hasarg: HasArg,\n-    /// How often it can occur\n-    pub occur: Occur,\n-    /// Which options it aliases\n-    pub aliases: Vec<Opt>,\n-}\n-\n-/// One group of options, e.g., both `-h` and `--help`, along with\n-/// their shared description and properties.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct OptGroup {\n-    /// Short name of the option, e.g. `h` for a `-h` option\n-    pub short_name: String,\n-    /// Long name of the option, e.g. `help` for a `--help` option\n-    pub long_name: String,\n-    /// Hint for argument, e.g. `FILE` for a `-o FILE` option\n-    pub hint: String,\n-    /// Description for usage help text\n-    pub desc: String,\n-    /// Whether option has an argument\n-    pub hasarg: HasArg,\n-    /// How often it can occur\n-    pub occur: Occur,\n-}\n-\n-/// Describes whether an option is given at all or has a value.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum Optval {\n-    Val(String),\n-    Given,\n-}\n-\n-/// The result of checking command line arguments. Contains a vector\n-/// of matches and a vector of free strings.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Matches {\n-    /// Options that matched\n-    opts: Vec<Opt>,\n-    /// Values of the Options that matched\n-    vals: Vec<Vec<Optval>>,\n-    /// Free string fragments\n-    pub free: Vec<String>,\n-}\n-\n-/// The type returned when the command line does not conform to the\n-/// expected format. Use the `Debug` implementation to output detailed\n-/// information.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Fail {\n-    /// The option requires an argument but none was passed.\n-    ArgumentMissing(String),\n-    /// The passed option is not declared among the possible options.\n-    UnrecognizedOption(String),\n-    /// A required option is not present.\n-    OptionMissing(String),\n-    /// A single occurrence option is being used multiple times.\n-    OptionDuplicated(String),\n-    /// There's an argument being passed to a non-argument option.\n-    UnexpectedArgument(String),\n-}\n-\n-/// The type of failure that occurred.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[allow(missing_docs)]\n-pub enum FailType {\n-    ArgumentMissing_,\n-    UnrecognizedOption_,\n-    OptionMissing_,\n-    OptionDuplicated_,\n-    UnexpectedArgument_,\n-}\n-\n-/// The result of parsing a command line with a set of options.\n-pub type Result = result::Result<Matches, Fail>;\n-\n-impl Name {\n-    fn from_str(nm: &str) -> Name {\n-        if nm.len() == 1 {\n-            Short(nm.chars().next().unwrap())\n-        } else {\n-            Long(nm.to_owned())\n-        }\n-    }\n-\n-    fn to_string(&self) -> String {\n-        match *self {\n-            Short(ch) => ch.to_string(),\n-            Long(ref s) => s.to_owned(),\n-        }\n-    }\n-}\n-\n-impl OptGroup {\n-    /// Translate OptGroup into Opt.\n-    /// (Both short and long names correspond to different Opts).\n-    pub fn long_to_short(&self) -> Opt {\n-        let OptGroup {\n-            short_name,\n-            long_name,\n-            hasarg,\n-            occur,\n-            ..\n-        } = (*self).clone();\n-\n-        match (short_name.len(), long_name.len()) {\n-            (0, 0) => panic!(\"this long-format option was given no name\"),\n-            (0, _) => {\n-                Opt {\n-                    name: Long((long_name)),\n-                    hasarg,\n-                    occur,\n-                    aliases: Vec::new(),\n-                }\n-            }\n-            (1, 0) => {\n-                Opt {\n-                    name: Short(short_name.chars().next().unwrap()),\n-                    hasarg,\n-                    occur,\n-                    aliases: Vec::new(),\n-                }\n-            }\n-            (1, _) => {\n-                Opt {\n-                    name: Long((long_name)),\n-                    hasarg,\n-                    occur,\n-                    aliases: vec![Opt {\n-                                      name: Short(short_name.chars().next().unwrap()),\n-                                      hasarg,\n-                                      occur,\n-                                      aliases: Vec::new(),\n-                                  }],\n-                }\n-            }\n-            _ => panic!(\"something is wrong with the long-form opt\"),\n-        }\n-    }\n-}\n-\n-impl Matches {\n-    fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(&self.opts[..], Name::from_str(nm)) {\n-            Some(id) => self.vals[id].clone(),\n-            None => panic!(\"No option '{}' defined\", nm),\n-        }\n-    }\n-\n-    fn opt_val(&self, nm: &str) -> Option<Optval> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            None\n-        } else {\n-            Some(vals[0].clone())\n-        }\n-    }\n-\n-    /// Returns true if an option was matched.\n-    pub fn opt_present(&self, nm: &str) -> bool {\n-        !self.opt_vals(nm).is_empty()\n-    }\n-\n-    /// Returns the number of times an option was matched.\n-    pub fn opt_count(&self, nm: &str) -> usize {\n-        self.opt_vals(nm).len()\n-    }\n-\n-    /// Returns true if any of several options were matched.\n-    pub fn opts_present(&self, names: &[String]) -> bool {\n-        for nm in names {\n-            match find_opt(&self.opts, Name::from_str(&**nm)) {\n-                Some(id) if !self.vals[id].is_empty() => return true,\n-                _ => (),\n-            };\n-        }\n-        false\n-    }\n-\n-    /// Returns the string argument supplied to one of several matching options or `None`.\n-    pub fn opts_str(&self, names: &[String]) -> Option<String> {\n-        for nm in names {\n-            if let Some(Val(ref s)) = self.opt_val(&nm[..]) {\n-                  return Some(s.clone())\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Returns a vector of the arguments provided to all matches of the given\n-    /// option.\n-    ///\n-    /// Used when an option accepts multiple values.\n-    pub fn opt_strs(&self, nm: &str) -> Vec<String> {\n-        let mut acc: Vec<String> = Vec::new();\n-        let r = self.opt_vals(nm);\n-        for v in &r {\n-            match *v {\n-                Val(ref s) => acc.push((*s).clone()),\n-                _ => (),\n-            }\n-        }\n-        acc\n-    }\n-\n-    /// Returns the string argument supplied to a matching option or `None`.\n-    pub fn opt_str(&self, nm: &str) -> Option<String> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            return None::<String>;\n-        }\n-        match vals[0] {\n-            Val(ref s) => Some((*s).clone()),\n-            _ => None,\n-        }\n-    }\n-\n-\n-    /// Returns the matching string, a default, or none.\n-    ///\n-    /// Returns none if the option was not present, `def` if the option was\n-    /// present but no argument was provided, and the argument if the option was\n-    /// present and an argument was provided.\n-    pub fn opt_default(&self, nm: &str, def: &str) -> Option<String> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            None\n-        } else {\n-            match vals[0] {\n-                Val(ref s) => Some((*s).clone()),\n-                _ => Some(def.to_owned()),\n-            }\n-        }\n-    }\n-}\n-\n-fn is_arg(arg: &str) -> bool {\n-    arg.len() > 1 && arg.as_bytes()[0] == b'-'\n-}\n-\n-fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n-    // Search main options.\n-    let pos = opts.iter().position(|opt| opt.name == nm);\n-    if pos.is_some() {\n-        return pos;\n-    }\n-\n-    // Search in aliases.\n-    for candidate in opts {\n-        if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n-            return opts.iter().position(|opt| opt.name == candidate.name);\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Create a long option that is required and takes an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Req,\n-    }\n-}\n-\n-/// Create a long option that is optional and takes an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that is optional and does not take an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: No,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that can occur more than once and does not\n-/// take an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: No,\n-        occur: Multi,\n-    }\n-}\n-\n-/// Create a long option that is optional and takes an optional argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Maybe,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that is optional, takes an argument, and may occur\n-/// multiple times.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Multi,\n-    }\n-}\n-\n-/// Create a generic option group, stating all parameters explicitly\n-pub fn opt(short_name: &str,\n-           long_name: &str,\n-           desc: &str,\n-           hint: &str,\n-           hasarg: HasArg,\n-           occur: Occur)\n-           -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg,\n-        occur,\n-    }\n-}\n-\n-impl fmt::Display for Fail {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ArgumentMissing(ref nm) => write!(f, \"Argument to option '{}' missing.\", *nm),\n-            UnrecognizedOption(ref nm) => write!(f, \"Unrecognized option: '{}'.\", *nm),\n-            OptionMissing(ref nm) => write!(f, \"Required option '{}' missing.\", *nm),\n-            OptionDuplicated(ref nm) => write!(f, \"Option '{}' given more than once.\", *nm),\n-            UnexpectedArgument(ref nm) => write!(f, \"Option '{}' does not take an argument.\", *nm),\n-        }\n-    }\n-}\n-\n-/// Parse command line arguments according to the provided options.\n-///\n-/// On success returns `Ok(Matches)`. Use methods such as `opt_present`\n-/// `opt_str`, etc. to interrogate results.\n-/// # Panics\n-///\n-/// Returns `Err(Fail)` on failure: use the `Debug` implementation of `Fail` to display\n-/// information about it.\n-pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n-    let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n-    let n_opts = opts.len();\n-\n-    fn f(_x: usize) -> Vec<Optval> {\n-        Vec::new()\n-    }\n-\n-    let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n-    let mut free: Vec<String> = Vec::new();\n-    let l = args.len();\n-    let mut i = 0;\n-    while i < l {\n-        let cur = args[i].clone();\n-        let curlen = cur.len();\n-        if !is_arg(&cur[..]) {\n-            free.push(cur);\n-        } else if cur == \"--\" {\n-            let mut j = i + 1;\n-            while j < l {\n-                free.push(args[j].clone());\n-                j += 1;\n-            }\n-            break;\n-        } else {\n-            let mut names;\n-            let mut i_arg = None;\n-            if cur.as_bytes()[1] == b'-' {\n-                let tail = &cur[2..curlen];\n-                let tail_eq: Vec<&str> = tail.splitn(2, '=').collect();\n-                if tail_eq.len() <= 1 {\n-                    names = vec![Long(tail.to_owned())];\n-                } else {\n-                    names = vec![Long(tail_eq[0].to_owned())];\n-                    i_arg = Some(tail_eq[1].to_owned());\n-                }\n-            } else {\n-                let mut j = 1;\n-                names = Vec::new();\n-                while j < curlen {\n-                    let ch = cur[j..].chars().next().unwrap();\n-                    let opt = Short(ch);\n-\n-                    // In a series of potential options (eg. -aheJ), if we\n-                    // see one which takes an argument, we assume all\n-                    // subsequent characters make up the argument. This\n-                    // allows options such as -L/usr/local/lib/foo to be\n-                    // interpreted correctly\n-\n-                    let opt_id = match find_opt(&opts, opt.clone()) {\n-                        Some(id) => id,\n-                        None => return Err(UnrecognizedOption(opt.to_string())),\n-                    };\n-\n-                    names.push(opt);\n-\n-                    let arg_follows = match opts[opt_id].hasarg {\n-                        Yes | Maybe => true,\n-                        No => false,\n-                    };\n-\n-                    let next = j + ch.len_utf8();\n-                    if arg_follows && next < curlen {\n-                        i_arg = Some((&cur[next..curlen]).to_owned());\n-                        break;\n-                    }\n-\n-                    j = next;\n-                }\n-            }\n-            let mut name_pos = 0;\n-            for nm in &names {\n-                name_pos += 1;\n-                let optid = match find_opt(&opts, (*nm).clone()) {\n-                    Some(id) => id,\n-                    None => return Err(UnrecognizedOption(nm.to_string())),\n-                };\n-                match opts[optid].hasarg {\n-                    No => {\n-                        if name_pos == names.len() && !i_arg.is_none() {\n-                            return Err(UnexpectedArgument(nm.to_string()));\n-                        }\n-                        let v = &mut vals[optid];\n-                        v.push(Given);\n-                    }\n-                    Maybe => {\n-                        if !i_arg.is_none() {\n-                            let v = &mut vals[optid];\n-                            v.push(Val((i_arg.clone()).unwrap()));\n-                        } else if name_pos < names.len() || i + 1 == l || is_arg(&args[i + 1][..]) {\n-                            let v = &mut vals[optid];\n-                            v.push(Given);\n-                        } else {\n-                            i += 1;\n-                            let v = &mut vals[optid];\n-                            v.push(Val(args[i].clone()));\n-                        }\n-                    }\n-                    Yes => {\n-                        if !i_arg.is_none() {\n-                            let v = &mut vals[optid];\n-                            v.push(Val(i_arg.clone().unwrap()));\n-                        } else if i + 1 == l {\n-                            return Err(ArgumentMissing(nm.to_string()));\n-                        } else {\n-                            i += 1;\n-                            let v = &mut vals[optid];\n-                            v.push(Val(args[i].clone()));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        i += 1;\n-    }\n-    for i in 0..n_opts {\n-        let n = vals[i].len();\n-        let occ = opts[i].occur;\n-        if occ == Req && n == 0 {\n-            return Err(OptionMissing(opts[i].name.to_string()));\n-        }\n-        if occ != Multi && n > 1 {\n-            return Err(OptionDuplicated(opts[i].name.to_string()));\n-        }\n-    }\n-    Ok(Matches {\n-        opts,\n-        vals,\n-        free,\n-    })\n-}\n-\n-/// Derive a usage message from a set of long options.\n-pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n-\n-    let desc_sep = format!(\"\\n{}\", repeat(\" \").take(24).collect::<String>());\n-\n-    let rows = opts.iter().map(|optref| {\n-        let OptGroup{short_name,\n-                     long_name,\n-                     hint,\n-                     desc,\n-                     hasarg,\n-                     ..} = (*optref).clone();\n-\n-        let mut row = repeat(\" \").take(4).collect::<String>();\n-\n-        // short option\n-        match short_name.len() {\n-            0 => {}\n-            1 => {\n-                row.push('-');\n-                row.push_str(&short_name[..]);\n-                row.push(' ');\n-            }\n-            _ => panic!(\"the short name should only be 1 ascii char long\"),\n-        }\n-\n-        // long option\n-        match long_name.len() {\n-            0 => {}\n-            _ => {\n-                row.push_str(\"--\");\n-                row.push_str(&long_name[..]);\n-                row.push(' ');\n-            }\n-        }\n-\n-        // arg\n-        match hasarg {\n-            No => {}\n-            Yes => row.push_str(&hint[..]),\n-            Maybe => {\n-                row.push('[');\n-                row.push_str(&hint[..]);\n-                row.push(']');\n-            }\n-        }\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        //\n-        // here we just need to indent the start of the description\n-        let rowlen = row.chars().count();\n-        if rowlen < 24 {\n-            for _ in 0..24 - rowlen {\n-                row.push(' ');\n-            }\n-        } else {\n-            row.push_str(&desc_sep[..]);\n-        }\n-\n-        // Normalize desc to contain words separated by one space character\n-        let mut desc_normalized_whitespace = String::new();\n-        for word in desc.split_whitespace() {\n-            desc_normalized_whitespace.push_str(word);\n-            desc_normalized_whitespace.push(' ');\n-        }\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        let mut desc_rows = Vec::new();\n-        each_split_within(&desc_normalized_whitespace[..], 54, |substr| {\n-            desc_rows.push(substr.to_owned());\n-            true\n-        });\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        //\n-        // wrapped description\n-        row.push_str(&desc_rows.join(&desc_sep[..]));\n-\n-        row\n-    });\n-\n-    format!(\"{}\\n\\nOptions:\\n{}\\n\",\n-            brief,\n-            rows.collect::<Vec<String>>().join(\"\\n\"))\n-}\n-\n-fn format_option(opt: &OptGroup) -> String {\n-    let mut line = String::new();\n-\n-    if opt.occur != Req {\n-        line.push('[');\n-    }\n-\n-    // Use short_name is possible, but fallback to long_name.\n-    if !opt.short_name.is_empty() {\n-        line.push('-');\n-        line.push_str(&opt.short_name[..]);\n-    } else {\n-        line.push_str(\"--\");\n-        line.push_str(&opt.long_name[..]);\n-    }\n-\n-    if opt.hasarg != No {\n-        line.push(' ');\n-        if opt.hasarg == Maybe {\n-            line.push('[');\n-        }\n-        line.push_str(&opt.hint[..]);\n-        if opt.hasarg == Maybe {\n-            line.push(']');\n-        }\n-    }\n-\n-    if opt.occur != Req {\n-        line.push(']');\n-    }\n-    if opt.occur == Multi {\n-        line.push_str(\"..\");\n-    }\n-\n-    line\n-}\n-\n-/// Derive a short one-line usage summary from a set of long options.\n-pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n-    let mut line = format!(\"Usage: {} \", program_name);\n-    line.push_str(&opts.iter()\n-                       .map(format_option)\n-                       .collect::<Vec<String>>()\n-                       .join(\" \")[..]);\n-    line\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SplitWithinState {\n-    A, // leading whitespace, initial state\n-    B, // words\n-    C, // internal and trailing whitespace\n-}\n-#[derive(Copy, Clone)]\n-enum Whitespace {\n-    Ws, // current char is whitespace\n-    Cr, // current char is not whitespace\n-}\n-#[derive(Copy, Clone)]\n-enum LengthLimit {\n-    UnderLim, // current char makes current substring still fit in limit\n-    OverLim, // current char makes current substring no longer fit in limit\n-}\n-\n-\n-/// Splits a string into substrings with possibly internal whitespace,\n-/// each of them at most `lim` bytes long. The substrings have leading and trailing\n-/// whitespace removed, and are only cut at whitespace boundaries.\n-///\n-/// Note: Function was moved here from `std::str` because this module is the only place that\n-/// uses it, and because it was too specific for a general string function.\n-///\n-/// # Panics\n-///\n-/// Panics during iteration if the string contains a non-whitespace\n-/// sequence longer than the limit.\n-fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool\n-    where F: FnMut(&str) -> bool\n-{\n-    // Just for fun, let's write this as a state machine:\n-\n-    let mut slice_start = 0;\n-    let mut last_start = 0;\n-    let mut last_end = 0;\n-    let mut state = A;\n-    let mut fake_i = ss.len();\n-    let mut lim = lim;\n-\n-    let mut cont = true;\n-\n-    // if the limit is larger than the string, lower it to save cycles\n-    if lim >= fake_i {\n-        lim = fake_i;\n-    }\n-\n-    let mut machine = |cont: &mut bool, (i, c): (usize, char)| -> bool {\n-        let whitespace = if c.is_whitespace() {\n-            Ws\n-        } else {\n-            Cr\n-        };\n-        let limit = if (i - slice_start + 1) <= lim {\n-            UnderLim\n-        } else {\n-            OverLim\n-        };\n-\n-        state = match (state, whitespace, limit) {\n-            (A, Ws, _) => A,\n-            (A, Cr, _) => {\n-                slice_start = i;\n-                last_start = i;\n-                B\n-            }\n-\n-            (B, Cr, UnderLim) => B,\n-            (B, Cr, OverLim) if (i - last_start + 1) > lim => {\n-                panic!(\"word starting with {} longer than limit!\",\n-                       &ss[last_start..i + 1])\n-            }\n-            (B, Cr, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                slice_start = last_start;\n-                B\n-            }\n-            (B, Ws, UnderLim) => {\n-                last_end = i;\n-                C\n-            }\n-            (B, Ws, OverLim) => {\n-                last_end = i;\n-                *cont = it(&ss[slice_start..last_end]);\n-                A\n-            }\n-\n-            (C, Cr, UnderLim) => {\n-                last_start = i;\n-                B\n-            }\n-            (C, Cr, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                slice_start = i;\n-                last_start = i;\n-                last_end = i;\n-                B\n-            }\n-            (C, Ws, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                A\n-            }\n-            (C, Ws, UnderLim) => C,\n-        };\n-\n-        *cont\n-    };\n-\n-    ss.char_indices().all(|x| machine(&mut cont, x));\n-\n-    // Let the automaton 'run out' by supplying trailing whitespace\n-    while cont &&\n-          match state {\n-        B | C => true,\n-        A => false,\n-    } {\n-        machine(&mut cont, (fake_i, ' '));\n-        fake_i += 1;\n-    }\n-    cont\n-}\n-\n-#[test]\n-fn test_split_within() {\n-    fn t(s: &str, i: usize, u: &[String]) {\n-        let mut v = Vec::new();\n-        each_split_within(s, i, |s| {\n-            v.push(s.to_string());\n-            true\n-        });\n-        assert!(v.iter().zip(u).all(|(a, b)| a == b));\n-    }\n-    t(\"\", 0, &[]);\n-    t(\"\", 15, &[]);\n-    t(\"hello\", 15, &[\"hello\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n-      15,\n-      &[\"Mary had a\".to_string(), \"little lamb\".to_string(), \"Little lamb\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n-      ::std::usize::MAX,\n-      &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use std::result::Result::{Err, Ok};\n-    use std::result;\n-\n-    // Tests for reqopt\n-    #[test]\n-    fn test_reqopt() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!(m.opt_present(\"t\"));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => {\n-                panic!(\"test_reqopt failed (long arg)\");\n-            }\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => {\n-                panic!(\"test_reqopt failed (short arg)\");\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optopt\n-    #[test]\n-    fn test_optopt() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optflag\n-    #[test]\n-    fn test_optflag() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert!(m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert!(m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_long_arg() {\n-        let args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(UnexpectedArgument(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_multi() {\n-        let args = vec![\"--test\".to_string(), \"-t\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_short_arg() {\n-        let args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                // The next variable after the flag is just a free argument\n-\n-                assert!(m.free[0] == \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optflagmulti\n-    #[test]\n-    fn test_optflagmulti_short1() {\n-        let args = vec![\"-v\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 1);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_short2a() {\n-        let args = vec![\"-v\".to_string(), \"-v\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_short2b() {\n-        let args = vec![\"-vv\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_long1() {\n-        let args = vec![\"--verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 1);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_long2() {\n-        let args = vec![\"--verbose\".to_string(), \"--verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_mix() {\n-        let args = vec![\"--verbose\".to_string(),\n-                        \"-v\".to_string(),\n-                        \"-vv\".to_string(),\n-                        \"verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 4);\n-                assert_eq!(m.opt_count(\"v\"), 4);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optmulti\n-    #[test]\n-    fn test_optmulti() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!(m.opt_present(\"t\"));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-                let pair = m.opt_strs(\"test\");\n-                assert!(pair[0] == \"20\");\n-                assert!(pair[1] == \"30\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unrecognized_option() {\n-        let long_args = vec![\"--untest\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(UnrecognizedOption(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-u\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(UnrecognizedOption(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_combined() {\n-        let args = vec![\"prog\".to_string(),\n-                        \"free1\".to_string(),\n-                        \"-s\".to_string(),\n-                        \"20\".to_string(),\n-                        \"free2\".to_string(),\n-                        \"--flag\".to_string(),\n-                        \"--long=30\".to_string(),\n-                        \"-f\".to_string(),\n-                        \"-m\".to_string(),\n-                        \"40\".to_string(),\n-                        \"-m\".to_string(),\n-                        \"50\".to_string(),\n-                        \"-n\".to_string(),\n-                        \"-A B\".to_string(),\n-                        \"-n\".to_string(),\n-                        \"-60 70\".to_string()];\n-        let opts = vec![optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n-                        optflag(\"\", \"flag\", \"a flag\"),\n-                        reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n-                        optflag(\"f\", \"\", \"another flag\"),\n-                        optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n-                        optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n-                        optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.free[0] == \"prog\");\n-                assert!(m.free[1] == \"free1\");\n-                assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n-                assert!(m.free[2] == \"free2\");\n-                assert!((m.opt_present(\"flag\")));\n-                assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n-                assert!((m.opt_present(\"f\")));\n-                let pair = m.opt_strs(\"m\");\n-                assert!(pair[0] == \"40\");\n-                assert!(pair[1] == \"50\");\n-                let pair = m.opt_strs(\"n\");\n-                assert!(pair[0] == \"-A B\");\n-                assert!(pair[1] == \"-60 70\");\n-                assert!((!m.opt_present(\"notpresent\")));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_multi() {\n-        let opts = vec![optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n-                        optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n-                        optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n-\n-        let args_single = vec![\"-e\".to_string(), \"foo\".to_string()];\n-        let matches_single = &match getopts(&args_single, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches_single.opts_present(&[\"e\".to_string()]));\n-        assert!(matches_single.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_single.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present(&[\"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_single.opts_present(&[]));\n-\n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\");\n-\n-        let args_both = vec![\"-e\".to_string(),\n-                             \"foo\".to_string(),\n-                             \"--encrypt\".to_string(),\n-                             \"foo\".to_string()];\n-        let matches_both = &match getopts(&args_both, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches_both.opts_present(&[\"e\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"encrypt\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_both.opts_present(&[\"f\".to_string()]));\n-        assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_both.opts_present(&[]));\n-\n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_nospace() {\n-        let args = vec![\"-Lfoo\".to_string(), \"-M.\".to_string()];\n-        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                        optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\");\n-        assert!(matches.opts_present(&[\"M\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"M\".to_string()]).unwrap(), \".\");\n-\n-    }\n-\n-    #[test]\n-    fn test_nospace_conflict() {\n-        let args = vec![\"-vvLverbose\".to_string(), \"-v\".to_string()];\n-        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                        optflagmulti(\"v\", \"verbose\", \"Verbose\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(e) => panic!(\"{}\", e),\n-        };\n-        assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\");\n-        assert!(matches.opts_present(&[\"v\".to_string()]));\n-        assert_eq!(3, matches.opt_count(\"v\"));\n-    }\n-\n-    #[test]\n-    fn test_long_to_short() {\n-        let mut short = Opt {\n-            name: Name::Long(\"banana\".to_string()),\n-            hasarg: HasArg::Yes,\n-            occur: Occur::Req,\n-            aliases: Vec::new(),\n-        };\n-        short.aliases = vec![Opt {\n-                                 name: Name::Short('b'),\n-                                 hasarg: HasArg::Yes,\n-                                 occur: Occur::Req,\n-                                 aliases: Vec::new(),\n-                             }];\n-        let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n-\n-        assert!(verbose.long_to_short() == short);\n-    }\n-\n-    #[test]\n-    fn test_aliases_long_and_short() {\n-        let opts = vec![optflagmulti(\"a\", \"apple\", \"Desc\")];\n-\n-        let args = vec![\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string()];\n-\n-        let matches = getopts(&args, &opts).unwrap();\n-        assert_eq!(3, matches.opt_count(\"a\"));\n-        assert_eq!(3, matches.opt_count(\"apple\"));\n-    }\n-\n-    #[test]\n-    fn test_usage() {\n-        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n-                             optflag(\"k\", \"kiwi\", \"Desc\"),\n-                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -b --banana VAL     Desc\n-    -a --012345678901234567890123456789 VAL\n-                        Desc\n-    -k --kiwi           Desc\n-    -p [VAL]            Desc\n-    -l VAL              Desc\n-\";\n-\n-        let generated_usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert_eq!(generated_usage, expected);\n-    }\n-\n-    #[test]\n-    fn test_usage_description_wrapping() {\n-        // indentation should be 24 spaces\n-        // lines wrap after 78: or rather descriptions wrap after 54\n-\n-        let optgroups = vec![optflag(\"k\",\n-                                     \"kiwi\",\n-                                     // 54\n-                                     \"This is a long description which won't be wrapped..+..\"),\n-                             optflag(\"a\",\n-                                     \"apple\",\n-                                     \"This is a long description which _will_ be wrapped..+..\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -k --kiwi           This is a long description which won't be wrapped..+..\n-    -a --apple          This is a long description which _will_ be\n-                        wrapped..+..\n-\";\n-\n-        let usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert!(usage == expected)\n-    }\n-\n-    #[test]\n-    fn test_usage_description_multibyte_handling() {\n-        let optgroups = vec![optflag(\"k\",\n-                                     \"k\\u{2013}w\\u{2013}\",\n-                                     \"The word kiwi is normally spelled with two i's\"),\n-                             optflag(\"a\",\n-                                     \"apple\",\n-                                     \"This \\u{201C}description\\u{201D} has some characters that \\\n-                                      could confuse the line wrapping; an apple costs 0.51\u20ac in \\\n-                                      some parts of Europe.\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -k --k\u2013w\u2013           The word kiwi is normally spelled with two i's\n-    -a --apple          This \u201cdescription\u201d has some characters that could\n-                        confuse the line wrapping; an apple costs 0.51\u20ac in\n-                        some parts of Europe.\n-\";\n-\n-        let usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert!(usage == expected)\n-    }\n-\n-    #[test]\n-    fn test_short_usage() {\n-        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n-                             optflag(\"k\", \"kiwi\", \"Desc\"),\n-                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n-\n-        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n-        let generated_usage = short_usage(\"fruits\", &optgroups);\n-\n-        assert_eq!(generated_usage, expected);\n-    }\n-\n-    #[test]\n-    fn test_args_with_equals() {\n-        let args = vec![\"--one\".to_string(), \"A=B\".to_string(),\n-                        \"--two=C=D\".to_string()];\n-        let opts = vec![optopt(\"o\", \"one\", \"One\", \"INFO\"),\n-                        optopt(\"t\", \"two\", \"Two\", \"INFO\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(e) => panic!(\"{}\", e)\n-        };\n-        assert_eq!(matches.opts_str(&[\"o\".to_string()]).unwrap(), \"A=B\");\n-        assert_eq!(matches.opts_str(&[\"t\".to_string()]).unwrap(), \"C=D\");\n-    }\n-}"}, {"sha": "a7e78a78e17c8776d7780008ccb3ce541ec64ae9", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1 +1 @@\n-Subproject commit ed04152aacf5b4798f78ff13396f3c04c0a77144\n+Subproject commit a7e78a78e17c8776d7780008ccb3ce541ec64ae9"}, {"sha": "007093981d3e19a6ee1ce62557b53627fc50c432", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 90, "deletions": 54, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -34,13 +34,12 @@\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n-#![feature(i128_type)]\n+#![cfg_attr(stage0, feature(i128_type))]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(lang_items)]\n #![feature(optin_builtin_traits)]\n \n-#[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors;\n@@ -156,7 +155,7 @@ impl IntoIterator for TokenStream {\n     type IntoIter = TokenTreeIter;\n \n     fn into_iter(self) -> TokenTreeIter {\n-        TokenTreeIter { cursor: self.0.trees(), next: None }\n+        TokenTreeIter { cursor: self.0.trees(), stack: Vec::new() }\n     }\n }\n \n@@ -554,7 +553,7 @@ impl Literal {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct TokenTreeIter {\n     cursor: tokenstream::Cursor,\n-    next: Option<tokenstream::TokenStream>,\n+    stack: Vec<TokenTree>,\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -563,9 +562,10 @@ impl Iterator for TokenTreeIter {\n \n     fn next(&mut self) -> Option<TokenTree> {\n         loop {\n-            let next =\n-                unwrap_or!(self.next.take().or_else(|| self.cursor.next_as_stream()), return None);\n-            let tree = TokenTree::from_internal(next, &mut self.next);\n+            let tree = self.stack.pop().or_else(|| {\n+                let next = self.cursor.next_as_stream()?;\n+                Some(TokenTree::from_internal(next, &mut self.stack))\n+            })?;\n             if tree.span.0 == DUMMY_SP {\n                 if let TokenNode::Group(Delimiter::None, stream) = tree.kind {\n                     self.cursor.insert(stream.0);\n@@ -598,12 +598,12 @@ impl Delimiter {\n }\n \n impl TokenTree {\n-    fn from_internal(stream: tokenstream::TokenStream, next: &mut Option<tokenstream::TokenStream>)\n+    fn from_internal(stream: tokenstream::TokenStream, stack: &mut Vec<TokenTree>)\n                 -> TokenTree {\n         use syntax::parse::token::*;\n \n         let (tree, is_joint) = stream.as_tree();\n-        let (mut span, token) = match tree {\n+        let (span, token) = match tree {\n             tokenstream::TokenTree::Token(span, token) => (span, token),\n             tokenstream::TokenTree::Delimited(span, delimed) => {\n                 let delimiter = Delimiter::from_internal(delimed.delim);\n@@ -615,34 +615,32 @@ impl TokenTree {\n         };\n \n         let op_kind = if is_joint { Spacing::Joint } else { Spacing::Alone };\n-        macro_rules! op {\n-            ($op:expr) => { TokenNode::Op($op, op_kind) }\n-        }\n-\n-        macro_rules! joint {\n-            ($first:expr, $rest:expr) => { joint($first, $rest, is_joint, &mut span, next) }\n+        macro_rules! tt {\n+            ($e:expr) => (TokenTree { span: Span(span), kind: $e })\n         }\n-\n-        fn joint(first: char, rest: Token, is_joint: bool, span: &mut syntax_pos::Span,\n-                 next: &mut Option<tokenstream::TokenStream>)\n-                 -> TokenNode {\n-            let (first_span, rest_span) = (*span, *span);\n-            *span = first_span;\n-            let tree = tokenstream::TokenTree::Token(rest_span, rest);\n-            *next = Some(if is_joint { tree.joint() } else { tree.into() });\n-            TokenNode::Op(first, Spacing::Joint)\n+        macro_rules! op {\n+            ($a:expr) => (TokenNode::Op($a, op_kind));\n+            ($a:expr, $b:expr) => ({\n+                stack.push(tt!(TokenNode::Op($b, op_kind).into()));\n+                TokenNode::Op($a, Spacing::Joint)\n+            });\n+            ($a:expr, $b:expr, $c:expr) => ({\n+                stack.push(tt!(TokenNode::Op($c, op_kind)));\n+                stack.push(tt!(TokenNode::Op($b, Spacing::Joint)));\n+                TokenNode::Op($a, Spacing::Joint)\n+            })\n         }\n \n         let kind = match token {\n             Eq => op!('='),\n             Lt => op!('<'),\n-            Le => joint!('<', Eq),\n-            EqEq => joint!('=', Eq),\n-            Ne => joint!('!', Eq),\n-            Ge => joint!('>', Eq),\n+            Le => op!('<', '='),\n+            EqEq => op!('=', '='),\n+            Ne => op!('!', '='),\n+            Ge => op!('>', '='),\n             Gt => op!('>'),\n-            AndAnd => joint!('&', BinOp(And)),\n-            OrOr => joint!('|', BinOp(Or)),\n+            AndAnd => op!('&', '&'),\n+            OrOr => op!('|', '|'),\n             Not => op!('!'),\n             Tilde => op!('~'),\n             BinOp(Plus) => op!('+'),\n@@ -653,36 +651,46 @@ impl TokenTree {\n             BinOp(Caret) => op!('^'),\n             BinOp(And) => op!('&'),\n             BinOp(Or) => op!('|'),\n-            BinOp(Shl) => joint!('<', Lt),\n-            BinOp(Shr) => joint!('>', Gt),\n-            BinOpEq(Plus) => joint!('+', Eq),\n-            BinOpEq(Minus) => joint!('-', Eq),\n-            BinOpEq(Star) => joint!('*', Eq),\n-            BinOpEq(Slash) => joint!('/', Eq),\n-            BinOpEq(Percent) => joint!('%', Eq),\n-            BinOpEq(Caret) => joint!('^', Eq),\n-            BinOpEq(And) => joint!('&', Eq),\n-            BinOpEq(Or) => joint!('|', Eq),\n-            BinOpEq(Shl) => joint!('<', Le),\n-            BinOpEq(Shr) => joint!('>', Ge),\n+            BinOp(Shl) => op!('<', '<'),\n+            BinOp(Shr) => op!('>', '>'),\n+            BinOpEq(Plus) => op!('+', '='),\n+            BinOpEq(Minus) => op!('-', '='),\n+            BinOpEq(Star) => op!('*', '='),\n+            BinOpEq(Slash) => op!('/', '='),\n+            BinOpEq(Percent) => op!('%', '='),\n+            BinOpEq(Caret) => op!('^', '='),\n+            BinOpEq(And) => op!('&', '='),\n+            BinOpEq(Or) => op!('|', '='),\n+            BinOpEq(Shl) => op!('<', '<', '='),\n+            BinOpEq(Shr) => op!('>', '>', '='),\n             At => op!('@'),\n             Dot => op!('.'),\n-            DotDot => joint!('.', Dot),\n-            DotDotDot => joint!('.', DotDot),\n-            DotDotEq => joint!('.', DotEq),\n+            DotDot => op!('.', '.'),\n+            DotDotDot => op!('.', '.', '.'),\n+            DotDotEq => op!('.', '.', '='),\n             Comma => op!(','),\n             Semi => op!(';'),\n             Colon => op!(':'),\n-            ModSep => joint!(':', Colon),\n-            RArrow => joint!('-', Gt),\n-            LArrow => joint!('<', BinOp(Minus)),\n-            FatArrow => joint!('=', Gt),\n+            ModSep => op!(':', ':'),\n+            RArrow => op!('-', '>'),\n+            LArrow => op!('<', '-'),\n+            FatArrow => op!('=', '>'),\n             Pound => op!('#'),\n             Dollar => op!('$'),\n             Question => op!('?'),\n \n-            Ident(ident) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n-            Literal(..) | DocComment(..) => TokenNode::Literal(self::Literal(token)),\n+            Ident(ident, false) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n+            Ident(ident, true) => TokenNode::Term(Term(Symbol::intern(&format!(\"r#{}\", ident)))),\n+            Literal(..) => TokenNode::Literal(self::Literal(token)),\n+            DocComment(c) => {\n+                let stream = vec![\n+                    tt!(TokenNode::Term(Term::intern(\"doc\"))),\n+                    tt!(op!('=')),\n+                    tt!(TokenNode::Literal(self::Literal(Literal(Lit::Str_(c), None)))),\n+                ].into_iter().collect();\n+                stack.push(tt!(TokenNode::Group(Delimiter::Bracket, stream)));\n+                op!('#')\n+            }\n \n             Interpolated(_) => {\n                 __internal::with_sess(|(sess, _)| {\n@@ -691,7 +699,7 @@ impl TokenTree {\n                 })\n             }\n \n-            DotEq => joint!('.', Eq),\n+            DotEq => op!('.', '='),\n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n             Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n         };\n@@ -713,11 +721,39 @@ impl TokenTree {\n             },\n             TokenNode::Term(symbol) => {\n                 let ident = ast::Ident { name: symbol.0, ctxt: self.span.0.ctxt() };\n+                let sym_str = symbol.0.as_str();\n                 let token =\n-                    if symbol.0.as_str().starts_with(\"'\") { Lifetime(ident) } else { Ident(ident) };\n+                    if sym_str.starts_with(\"'\") { Lifetime(ident) }\n+                    else if sym_str.starts_with(\"r#\") {\n+                        let name = Symbol::intern(&sym_str[2..]);\n+                        let ident = ast::Ident { name, ctxt: self.span.0.ctxt() };\n+                        Ident(ident, true)\n+                    } else { Ident(ident, false) };\n                 return TokenTree::Token(self.span.0, token).into();\n             }\n-            TokenNode::Literal(token) => return TokenTree::Token(self.span.0, token.0).into(),\n+            TokenNode::Literal(self::Literal(Literal(Lit::Integer(ref a), b)))\n+                if a.as_str().starts_with(\"-\") =>\n+            {\n+                let minus = BinOp(BinOpToken::Minus);\n+                let integer = Symbol::intern(&a.as_str()[1..]);\n+                let integer = Literal(Lit::Integer(integer), b);\n+                let a = TokenTree::Token(self.span.0, minus);\n+                let b = TokenTree::Token(self.span.0, integer);\n+                return vec![a, b].into_iter().collect()\n+            }\n+            TokenNode::Literal(self::Literal(Literal(Lit::Float(ref a), b)))\n+                if a.as_str().starts_with(\"-\") =>\n+            {\n+                let minus = BinOp(BinOpToken::Minus);\n+                let float = Symbol::intern(&a.as_str()[1..]);\n+                let float = Literal(Lit::Float(float), b);\n+                let a = TokenTree::Token(self.span.0, minus);\n+                let b = TokenTree::Token(self.span.0, float);\n+                return vec![a, b].into_iter().collect()\n+            }\n+            TokenNode::Literal(token) => {\n+                return TokenTree::Token(self.span.0, token.0).into()\n+            }\n         };\n \n         let token = match op {"}, {"sha": "8d6c7d68dfe23090441114164c8ebe0b661f0163", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -27,6 +27,7 @@ fn main() {\n                                    \"InstrProfilingFile.c\",\n                                    \"InstrProfilingMerge.c\",\n                                    \"InstrProfilingMergeFile.c\",\n+                                   \"InstrProfilingNameVar.c\",\n                                    \"InstrProfilingPlatformDarwin.c\",\n                                    \"InstrProfilingPlatformLinux.c\",\n                                    \"InstrProfilingPlatformOther.c\",\n@@ -42,6 +43,8 @@ fn main() {\n         cfg.define(\"strdup\", Some(\"_strdup\"));\n         cfg.define(\"open\", Some(\"_open\"));\n         cfg.define(\"fdopen\", Some(\"_fdopen\"));\n+        cfg.define(\"getpid\", Some(\"_getpid\"));\n+        cfg.define(\"fileno\", Some(\"_fileno\"));\n     } else {\n         // Turn off various features of gcc and such, mostly copying\n         // compiler-rt's build system already\n@@ -50,6 +53,7 @@ fn main() {\n         cfg.flag(\"-fomit-frame-pointer\");\n         cfg.flag(\"-ffreestanding\");\n         cfg.define(\"VISIBILITY_HIDDEN\", None);\n+        cfg.define(\"COMPILER_RT_HAS_UNAME\", Some(\"1\"));\n     }\n \n     for src in profile_sources {"}, {"sha": "2aae0f24d484932b27a9df391d174886cb3f9c33", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -56,3 +56,4 @@ byteorder = { version = \"1.1\", features = [\"i128\"]}\n #        later crate stop compiling. If you can remove this and everything\n #        compiles, then please feel free to do so!\n flate2 = \"1.0\"\n+tempdir = \"0.3\""}, {"sha": "1247db55f58506b0519a456a2137b88e3ce0ee0e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -473,8 +473,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         // Keep track of the previous guard expressions\n         let mut prev_guards = Vec::new();\n-        // Track if the previous pattern contained bindings or wildcards\n-        let mut prev_has_bindings = false;\n \n         for arm in arms {\n             // Add an exit node for when we've visited all the\n@@ -493,40 +491,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // Visit the guard expression\n                     let guard_exit = self.expr(&guard, guard_start);\n \n-                    let this_has_bindings = pat.contains_bindings_or_wild();\n-\n-                    // If both this pattern and the previous pattern\n-                    // were free of bindings, they must consist only\n-                    // of \"constant\" patterns. Note we cannot match an\n-                    // all-constant pattern, fail the guard, and then\n-                    // match *another* all-constant pattern. This is\n-                    // because if the previous pattern matches, then\n-                    // we *cannot* match this one, unless all the\n-                    // constants are the same (which is rejected by\n-                    // `check_match`).\n-                    //\n-                    // We can use this to be smarter about the flow\n-                    // along guards. If the previous pattern matched,\n-                    // then we know we will not visit the guard in\n-                    // this one (whether or not the guard succeeded),\n-                    // if the previous pattern failed, then we know\n-                    // the guard for that pattern will not have been\n-                    // visited. Thus, it is not possible to visit both\n-                    // the previous guard and the current one when\n-                    // both patterns consist only of constant\n-                    // sub-patterns.\n-                    //\n-                    // However, if the above does not hold, then all\n-                    // previous guards need to be wired to visit the\n-                    // current guard pattern.\n-                    if prev_has_bindings || this_has_bindings {\n-                        while let Some(prev) = prev_guards.pop() {\n-                            self.add_contained_edge(prev, guard_start);\n-                        }\n+                    // #47295: We used to have very special case code\n+                    // here for when a pair of arms are both formed\n+                    // solely from constants, and if so, not add these\n+                    // edges.  But this was not actually sound without\n+                    // other constraints that we stopped enforcing at\n+                    // some point.\n+                    while let Some(prev) = prev_guards.pop() {\n+                        self.add_contained_edge(prev, guard_start);\n                     }\n \n-                    prev_has_bindings = this_has_bindings;\n-\n                     // Push the guard onto the list of previous guards\n                     prev_guards.push(guard_exit);\n "}, {"sha": "d1f3736556c5dc28eaff476814ae693bc0dc412e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -579,17 +579,22 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n+    [] CheckItemWellFormed(DefId),\n+    [] CheckTraitItemWellFormed(DefId),\n+    [] CheckImplItemWellFormed(DefId),\n     [] ReachableNonGenerics(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n     [] DeriveRegistrarFn(CrateNum),\n     [input] CrateDisambiguator(CrateNum),\n     [input] CrateHash(CrateNum),\n     [input] OriginalCrateName(CrateNum),\n+    [input] ExtraFileName(CrateNum),\n \n     [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n     [] AllTraitImplementations(CrateNum),\n \n+    [] DllimportForeignItems(CrateNum),\n     [] IsDllimportForeignItem(DefId),\n     [] IsStaticallyIncludedForeignItem(DefId),\n     [] NativeLibraryKind(DefId),\n@@ -613,8 +618,6 @@ define_dep_nodes!( <'tcx>\n     [input] MissingExternCrateItem(CrateNum),\n     [input] UsedCrateSource(CrateNum),\n     [input] PostorderCnums,\n-    [] HasCloneClosures(CrateNum),\n-    [] HasCopyClosures(CrateNum),\n \n     // This query is not expected to have inputs -- as a result, it's\n     // not a good candidate for \"replay\" because it's essentially a\n@@ -647,9 +650,13 @@ define_dep_nodes!( <'tcx>\n \n     [] GetSymbolExportLevel(DefId),\n \n+    [] WasmCustomSections(CrateNum),\n+\n     [input] Features,\n \n     [] ProgramClausesFor(DefId),\n+    [] WasmImportModuleMap(CrateNum),\n+    [] ForeignModules(CrateNum),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "d60c22064d3a0cd0ee3900a1dec51d175e28ea58", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -476,10 +476,8 @@ impl DepGraph {\n             fingerprints.resize(current_dep_graph.nodes.len(), Fingerprint::ZERO);\n         }\n \n-        let nodes: IndexVec<_, (DepNode, Fingerprint)> =\n-            current_dep_graph.nodes.iter_enumerated().map(|(idx, &dep_node)| {\n-            (dep_node, fingerprints[idx])\n-        }).collect();\n+        let fingerprints = fingerprints.clone().convert_index_type();\n+        let nodes = current_dep_graph.nodes.clone().convert_index_type();\n \n         let total_edge_count: usize = current_dep_graph.edges.iter()\n                                                              .map(|v| v.len())\n@@ -503,6 +501,7 @@ impl DepGraph {\n \n         SerializedDepGraph {\n             nodes,\n+            fingerprints,\n             edge_list_indices,\n             edge_list_data,\n         }"}, {"sha": "669a99019aa60176de63f093266766a75d8638a4", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -23,7 +23,7 @@ impl PreviousDepGraph {\n     pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n         let index: FxHashMap<_, _> = data.nodes\n             .iter_enumerated()\n-            .map(|(idx, &(dep_node, _))| (dep_node, idx))\n+            .map(|(idx, &dep_node)| (dep_node, idx))\n             .collect();\n         PreviousDepGraph { data, index }\n     }\n@@ -41,7 +41,7 @@ impl PreviousDepGraph {\n \n     #[inline]\n     pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode {\n-        self.data.nodes[dep_node_index].0\n+        self.data.nodes[dep_node_index]\n     }\n \n     #[inline]\n@@ -58,14 +58,14 @@ impl PreviousDepGraph {\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n         self.index\n             .get(dep_node)\n-            .map(|&node_index| self.data.nodes[node_index].1)\n+            .map(|&node_index| self.data.fingerprints[node_index])\n     }\n \n     #[inline]\n     pub fn fingerprint_by_index(&self,\n                                 dep_node_index: SerializedDepNodeIndex)\n                                 -> Fingerprint {\n-        self.data.nodes[dep_node_index].1\n+        self.data.fingerprints[dep_node_index]\n     }\n \n     pub fn node_count(&self) -> usize {"}, {"sha": "60fc813a25d51eda38da1293b1a8943a89c35225", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -20,7 +20,10 @@ newtype_index!(SerializedDepNodeIndex);\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n     /// The set of all DepNodes in the graph\n-    pub nodes: IndexVec<SerializedDepNodeIndex, (DepNode, Fingerprint)>,\n+    pub nodes: IndexVec<SerializedDepNodeIndex, DepNode>,\n+    /// The set of all Fingerprints in the graph. Each Fingerprint corresponds to\n+    /// the DepNode at the same index in the nodes vector.\n+    pub fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint>,\n     /// For each DepNode, stores the list of edges originating from that\n     /// DepNode. Encoded as a [start, end) pair indexing into edge_list_data,\n     /// which holds the actual DepNodeIndices of the target nodes.\n@@ -35,6 +38,7 @@ impl SerializedDepGraph {\n     pub fn new() -> SerializedDepGraph {\n         SerializedDepGraph {\n             nodes: IndexVec::new(),\n+            fingerprints: IndexVec::new(),\n             edge_list_indices: IndexVec::new(),\n             edge_list_data: Vec::new(),\n         }"}, {"sha": "2662e70999196f458de10c16608a9f55b52e1558", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -887,65 +887,6 @@ foo(3_i8);\n // therefore the type-checker complains with this error code.\n ```\n \n-Here is a more subtle instance of the same problem, that can\n-arise with for-loops in Rust:\n-\n-```compile_fail\n-let vs: Vec<i32> = vec![1, 2, 3, 4];\n-for v in &vs {\n-    match v {\n-        1 => {},\n-        _ => {},\n-    }\n-}\n-```\n-\n-The above fails because of an analogous type mismatch,\n-though may be harder to see. Again, here are some\n-explanatory comments for the same example:\n-\n-```compile_fail\n-{\n-    let vs = vec![1, 2, 3, 4];\n-\n-    // `for`-loops use a protocol based on the `Iterator`\n-    // trait. Each item yielded in a `for` loop has the\n-    // type `Iterator::Item` -- that is, `Item` is the\n-    // associated type of the concrete iterator impl.\n-    for v in &vs {\n-//      ~    ~~~\n-//      |     |\n-//      |    We borrow `vs`, iterating over a sequence of\n-//      |    *references* of type `&Elem` (where `Elem` is\n-//      |    vector's element type). Thus, the associated\n-//      |    type `Item` must be a reference `&`-type ...\n-//      |\n-//  ... and `v` has the type `Iterator::Item`, as dictated by\n-//  the `for`-loop protocol ...\n-\n-        match v {\n-            1 => {}\n-//          ~\n-//          |\n-// ... but *here*, `v` is forced to have some integral type;\n-// only types like `u8`,`i8`,`u16`,`i16`, et cetera can\n-// match the pattern `1` ...\n-\n-            _ => {}\n-        }\n-\n-// ... therefore, the compiler complains, because it sees\n-// an attempt to solve the equations\n-// `some integral-type` = type-of-`v`\n-//                      = `Iterator::Item`\n-//                      = `&Elem` (i.e. `some reference type`)\n-//\n-// which cannot possibly all be true.\n-\n-    }\n-}\n-```\n-\n To avoid those issues, you have to make the types match correctly.\n So we can fix the previous examples like this:\n \n@@ -1764,12 +1705,12 @@ The `main` function was incorrectly declared.\n Erroneous code example:\n \n ```compile_fail,E0580\n-fn main() -> i32 { // error: main function has wrong type\n-    0\n+fn main(x: i32) { // error: main function has wrong type\n+    println!(\"{}\", x);\n }\n ```\n \n-The `main` function prototype should never take arguments or return type.\n+The `main` function prototype should never take arguments.\n Example:\n \n ```\n@@ -1789,8 +1730,6 @@ allowed as function return types.\n Erroneous code example:\n \n ```compile_fail,E0562\n-#![feature(conservative_impl_trait)]\n-\n fn main() {\n     let count_to_ten: impl Iterator<Item=usize> = 0..10;\n     // error: `impl Trait` not allowed outside of function and inherent method\n@@ -1804,8 +1743,6 @@ fn main() {\n Make sure `impl Trait` only appears in return-type position.\n \n ```\n-#![feature(conservative_impl_trait)]\n-\n fn count_to_n(n: usize) -> impl Iterator<Item=usize> {\n     0..n\n }\n@@ -2074,6 +2011,81 @@ a (non-transparent) struct containing a single float, while `Grams` is a\n transparent wrapper around a float. This can make a difference for the ABI.\n \"##,\n \n+E0909: r##\"\n+The `impl Trait` return type captures lifetime parameters that do not\n+appear within the `impl Trait` itself.\n+\n+Erroneous code example:\n+\n+```compile-fail,E0909\n+use std::cell::Cell;\n+\n+trait Trait<'a> { }\n+\n+impl<'a, 'b> Trait<'b> for Cell<&'a u32> { }\n+\n+fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n+where 'x: 'y\n+{\n+    x\n+}\n+```\n+\n+Here, the function `foo` returns a value of type `Cell<&'x u32>`,\n+which references the lifetime `'x`. However, the return type is\n+declared as `impl Trait<'y>` -- this indicates that `foo` returns\n+\"some type that implements `Trait<'y>`\", but it also indicates that\n+the return type **only captures data referencing the lifetime `'y`**.\n+In this case, though, we are referencing data with lifetime `'x`, so\n+this function is in error.\n+\n+To fix this, you must reference the lifetime `'x` from the return\n+type. For example, changing the return type to `impl Trait<'y> + 'x`\n+would work:\n+\n+```\n+use std::cell::Cell;\n+\n+trait Trait<'a> { }\n+\n+impl<'a,'b> Trait<'b> for Cell<&'a u32> { }\n+\n+fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y> + 'x\n+where 'x: 'y\n+{\n+    x\n+}\n+```\n+\"##,\n+\n+E0910: r##\"\n+This error indicates that a `#[non_exhaustive]` attribute was incorrectly placed\n+on something other than a struct or enum.\n+\n+Examples of erroneous code:\n+\n+```compile_fail,E0910\n+# #![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+trait Foo { }\n+```\n+\"##,\n+\n+E0911: r##\"\n+This error indicates that a `#[non_exhaustive]` attribute had a value. The\n+`#[non_exhaustive]` should be empty.\n+\n+Examples of erroneous code:\n+\n+```compile_fail,E0911\n+# #![feature(non_exhaustive)]\n+\n+#[non_exhaustive(anything)]\n+struct Foo;\n+```\n+\"##,\n+\n }\n \n "}, {"sha": "956cd17f38f214cd91f47550641f74cdb667742a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 133, "deletions": 11, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -14,6 +14,7 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n+use syntax_pos::Span;\n use ty::TyCtxt;\n \n use hir;\n@@ -25,6 +26,10 @@ enum Target {\n     Struct,\n     Union,\n     Enum,\n+    Const,\n+    ForeignMod,\n+    Expression,\n+    Statement,\n     Other,\n }\n \n@@ -35,6 +40,8 @@ impl Target {\n             hir::ItemStruct(..) => Target::Struct,\n             hir::ItemUnion(..) => Target::Union,\n             hir::ItemEnum(..) => Target::Enum,\n+            hir::ItemConst(..) => Target::Const,\n+            hir::ItemForeignMod(..) => Target::ForeignMod,\n             _ => Target::Other,\n         }\n     }\n@@ -55,25 +62,80 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                 .emit();\n         }\n \n+        let mut has_wasm_import_module = false;\n         for attr in &item.attrs {\n-            if let Some(name) = attr.name() {\n-                if name == \"inline\" {\n-                    self.check_inline(attr, item, target)\n+            if attr.check_name(\"inline\") {\n+                self.check_inline(attr, &item.span, target)\n+            } else if attr.check_name(\"non_exhaustive\") {\n+                self.check_non_exhaustive(attr, item, target)\n+            } else if attr.check_name(\"wasm_import_module\") {\n+                has_wasm_import_module = true;\n+                if attr.value_str().is_none() {\n+                    self.tcx.sess.span_err(attr.span, \"\\\n+                        must be of the form #[wasm_import_module = \\\"...\\\"]\");\n+                }\n+                if target != Target::ForeignMod {\n+                    self.tcx.sess.span_err(attr.span, \"\\\n+                        must only be attached to foreign modules\");\n+                }\n+            } else if attr.check_name(\"wasm_custom_section\") {\n+                if target != Target::Const {\n+                    self.tcx.sess.span_err(attr.span, \"only allowed on consts\");\n+                }\n+\n+                if attr.value_str().is_none() {\n+                    self.tcx.sess.span_err(attr.span, \"must be of the form \\\n+                        #[wasm_custom_section = \\\"foo\\\"]\");\n                 }\n             }\n         }\n \n+        if target == Target::ForeignMod &&\n+            !has_wasm_import_module &&\n+            self.tcx.sess.target.target.arch == \"wasm32\" &&\n+            false // FIXME: eventually enable this warning when stable\n+        {\n+            self.tcx.sess.span_warn(item.span, \"\\\n+                must have a #[wasm_import_module = \\\"...\\\"] attribute, this \\\n+                will become a hard error before too long\");\n+        }\n+\n         self.check_repr(item, target);\n     }\n \n     /// Check if an `#[inline]` is applied to a function.\n-    fn check_inline(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n+    fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) {\n         if target != Target::Fn {\n             struct_span_err!(self.tcx.sess,\n                              attr.span,\n                              E0518,\n                              \"attribute should be applied to function\")\n-                .span_label(item.span, \"not a function\")\n+                .span_label(*span, \"not a function\")\n+                .emit();\n+        }\n+    }\n+\n+    /// Check if the `#[non_exhaustive]` attribute on an `item` is valid.\n+    fn check_non_exhaustive(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n+        match target {\n+            Target::Struct | Target::Enum => { /* Valid */ },\n+            _ => {\n+                struct_span_err!(self.tcx.sess,\n+                                 attr.span,\n+                                 E0910,\n+                                 \"attribute can only be applied to a struct or enum\")\n+                    .span_label(item.span, \"not a struct or enum\")\n+                    .emit();\n+                return;\n+            }\n+        }\n+\n+        if attr.meta_item_list().is_some() || attr.value_str().is_some() {\n+            struct_span_err!(self.tcx.sess,\n+                             attr.span,\n+                             E0911,\n+                             \"attribute should be empty\")\n+                .span_label(item.span, \"not empty\")\n                 .emit();\n         }\n     }\n@@ -164,10 +226,12 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                 }\n                 _ => continue,\n             };\n-            struct_span_err!(self.tcx.sess, hint.span, E0517,\n-                             \"attribute should be applied to {}\", allowed_targets)\n-                .span_label(item.span, format!(\"not {} {}\", article, allowed_targets))\n-                .emit();\n+            self.emit_repr_error(\n+                hint.span,\n+                item.span,\n+                &format!(\"attribute should be applied to {}\", allowed_targets),\n+                &format!(\"not {} {}\", article, allowed_targets),\n+            )\n         }\n \n         // Just point at all repr hints if there are any incompatibilities.\n@@ -189,17 +253,75 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                        \"conflicting representation hints\");\n         }\n     }\n+\n+    fn emit_repr_error(\n+        &self,\n+        hint_span: Span,\n+        label_span: Span,\n+        hint_message: &str,\n+        label_message: &str,\n+    ) {\n+        struct_span_err!(self.tcx.sess, hint_span, E0517, \"{}\", hint_message)\n+            .span_label(label_span, label_message)\n+            .emit();\n+    }\n+\n+    fn check_stmt_attributes(&self, stmt: &hir::Stmt) {\n+        // When checking statements ignore expressions, they will be checked later\n+        if let hir::Stmt_::StmtDecl(_, _) = stmt.node {\n+            for attr in stmt.node.attrs() {\n+                if attr.check_name(\"inline\") {\n+                    self.check_inline(attr, &stmt.span, Target::Statement);\n+                }\n+                if attr.check_name(\"repr\") {\n+                    self.emit_repr_error(\n+                        attr.span,\n+                        stmt.span,\n+                        &format!(\"attribute should not be applied to a statement\"),\n+                        &format!(\"not a struct, enum or union\"),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr_attributes(&self, expr: &hir::Expr) {\n+        for attr in expr.attrs.iter() {\n+            if attr.check_name(\"inline\") {\n+                self.check_inline(attr, &expr.span, Target::Expression);\n+            }\n+            if attr.check_name(\"repr\") {\n+                self.emit_repr_error(\n+                    attr.span,\n+                    expr.span,\n+                    &format!(\"attribute should not be applied to an expression\"),\n+                    &format!(\"not defining a struct, enum or union\"),\n+                );\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let target = Target::from_item(item);\n         self.check_attributes(item, target);\n-        intravisit::walk_item(self, item);\n+        intravisit::walk_item(self, item)\n+    }\n+\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n+        self.check_stmt_attributes(stmt);\n+        intravisit::walk_stmt(self, stmt)\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        self.check_expr_attributes(expr);\n+        intravisit::walk_expr(self, expr)\n     }\n }\n "}, {"sha": "9f51eb8c35a82787f10c6143ca6ce0fcd9f87080", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -420,7 +420,10 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         LifetimeName::Name(name) => {\n             visitor.visit_name(lifetime.span, name);\n         }\n-        LifetimeName::Static | LifetimeName::Implicit | LifetimeName::Underscore => {}\n+        LifetimeName::Fresh(_) |\n+        LifetimeName::Static |\n+        LifetimeName::Implicit |\n+        LifetimeName::Underscore => {}\n     }\n }\n "}, {"sha": "5f9f37094f579a5bc01c546dcce43f066ba73de8", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1514, "deletions": 1149, "changes": 2663, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "e8bcbfbb77a1791cb03d6d65352566accc740c8a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -962,6 +962,7 @@ impl<'hir> Map<'hir> {\n             Some(NodeField(ref f)) => Some(&f.attrs[..]),\n             Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n+            Some(NodeTyParam(tp)) => Some(&tp.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             Some(NodeStructCtor(_)) => {"}, {"sha": "be8cceb61189633d6cb8337f18c817c336af6b54", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -203,9 +203,31 @@ pub struct Lifetime {\n \n #[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum LifetimeName {\n+    /// User typed nothing. e.g. the lifetime in `&u32`.\n     Implicit,\n+\n+    /// User typed `'_`.\n     Underscore,\n+\n+    /// Synthetic name generated when user elided a lifetime in an impl header,\n+    /// e.g. the lifetimes in cases like these:\n+    ///\n+    ///     impl Foo for &u32\n+    ///     impl Foo<'_> for u32\n+    ///\n+    /// in that case, we rewrite to\n+    ///\n+    ///     impl<'f> Foo for &'f u32\n+    ///     impl<'f> Foo<'f> for u32\n+    ///\n+    /// where `'f` is something like `Fresh(0)`. The indices are\n+    /// unique per impl, but not necessarily continuous.\n+    Fresh(usize),\n+\n+    /// User wrote `'static`\n     Static,\n+\n+    /// Some user-given name like `'x`\n     Name(Name),\n }\n \n@@ -214,7 +236,7 @@ impl LifetimeName {\n         use self::LifetimeName::*;\n         match *self {\n             Implicit => keywords::Invalid.name(),\n-            Underscore => keywords::UnderscoreLifetime.name(),\n+            Fresh(_) | Underscore => keywords::UnderscoreLifetime.name(),\n             Static => keywords::StaticLifetime.name(),\n             Name(name) => name,\n         }\n@@ -235,7 +257,13 @@ impl Lifetime {\n         use self::LifetimeName::*;\n         match self.name {\n             Implicit | Underscore => true,\n-            Static | Name(_) => false,\n+\n+            // It might seem surprising that `Fresh(_)` counts as\n+            // *not* elided -- but this is because, as far as the code\n+            // in the compiler is concerned -- `Fresh(_)` variants act\n+            // equivalently to \"some fresh name\". They correspond to\n+            // early-bound regions on an impl, in other words.\n+            Fresh(_) | Static | Name(_) => false,\n         }\n     }\n \n@@ -395,6 +423,15 @@ pub enum TyParamBound {\n     RegionTyParamBound(Lifetime),\n }\n \n+impl TyParamBound {\n+    pub fn span(&self) -> Span {\n+        match self {\n+            &TraitTyParamBound(ref t, ..) => t.span,\n+            &RegionTyParamBound(ref l) => l.span,\n+        }\n+    }\n+}\n+\n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -414,6 +451,7 @@ pub struct TyParam {\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n     pub synthetic: Option<SyntheticTyParamKind>,\n+    pub attrs: HirVec<Attribute>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -570,6 +608,16 @@ pub enum WherePredicate {\n     EqPredicate(WhereEqPredicate),\n }\n \n+impl WherePredicate {\n+    pub fn span(&self) -> Span {\n+        match self {\n+            &WherePredicate::BoundPredicate(ref p) => p.span,\n+            &WherePredicate::RegionPredicate(ref p) => p.span,\n+            &WherePredicate::EqPredicate(ref p) => p.span,\n+        }\n+    }\n+}\n+\n /// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {"}, {"sha": "1f00a3ab1f5ded464dc5fb701b7725ad9afa0a9e", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -31,6 +31,10 @@ impl<I> Iterator for EnumerateAndAdjust<I> where I: Iterator {\n             (if i < self.gap_pos { i } else { i + self.gap_len }, elem)\n         })\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.enumerate.size_hint()\n+    }\n }\n \n pub trait EnumerateAndAdjustIterator {"}, {"sha": "ff501f30c891a5cd46e93384e5cfcf3bea5804c4", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -13,7 +13,7 @@ pub use self::AnnNode::*;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n-use syntax::parse::ParseSess;\n+use syntax::parse::{token, ParseSess};\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n@@ -1561,7 +1561,11 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        self.s.word(&name.as_str())?;\n+        if token::is_raw_guess(ast::Ident::with_empty_ctxt(name)) {\n+            self.s.word(&format!(\"r#{}\", name))?;\n+        } else {\n+            self.s.word(&name.as_str())?;\n+        }\n         self.ann.post(self, NodeName(&name))\n     }\n "}, {"sha": "04b725957b627f41aef542b66288f58ea5c25fb4", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -15,6 +15,7 @@ use hir::map::definitions::Definitions;\n use ich::{self, CachingCodemapView, Fingerprint};\n use middle::cstore::CrateStore;\n use ty::{TyCtxt, fast_reject};\n+use mir::interpret::AllocId;\n use session::Session;\n \n use std::cmp::Ord;\n@@ -59,6 +60,8 @@ pub struct StableHashingContext<'a> {\n     // CachingCodemapView, so we initialize it lazily.\n     raw_codemap: &'a CodeMap,\n     caching_codemap: Option<CachingCodemapView<'a>>,\n+\n+    pub(super) alloc_id_recursion_tracker: FxHashSet<AllocId>,\n }\n \n #[derive(PartialEq, Eq, Clone, Copy)]\n@@ -102,6 +105,7 @@ impl<'a> StableHashingContext<'a> {\n             hash_spans: hash_spans_initial,\n             hash_bodies: true,\n             node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n+            alloc_id_recursion_tracker: Default::default(),\n         }\n     }\n "}, {"sha": "0071850e1052b5a77292d68d50e34c1a64ca6e89", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -33,7 +33,12 @@ impl_stable_hash_for!(struct middle::cstore::NativeLibrary {\n     kind,\n     name,\n     cfg,\n-    foreign_items\n+    foreign_module\n+});\n+\n+impl_stable_hash_for!(struct middle::cstore::ForeignModule {\n+    foreign_items,\n+    def_id\n });\n \n impl_stable_hash_for!(enum middle::cstore::LinkagePreference {"}, {"sha": "c3b3e10201f9920665028f7a8bb920035a09be43", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -145,6 +145,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n impl_stable_hash_for!(enum hir::LifetimeName {\n     Implicit,\n     Underscore,\n+    Fresh(index),\n     Static,\n     Name(name)\n });\n@@ -203,7 +204,8 @@ impl_stable_hash_for!(struct hir::TyParam {\n     default,\n     span,\n     pure_wrt_drop,\n-    synthetic\n+    synthetic,\n+    attrs\n });\n \n impl_stable_hash_for!(enum hir::GenericParam {"}, {"sha": "c73f171806e42510e766cc4f347143b4effe9f8a", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -277,6 +277,10 @@ for mir::StatementKind<'gcx> {\n                 op.hash_stable(hcx, hasher);\n                 places.hash_stable(hcx, hasher);\n             }\n+            mir::StatementKind::UserAssertTy(ref c_ty, ref local) => {\n+                c_ty.hash_stable(hcx, hasher);\n+                local.hash_stable(hcx, hasher);\n+            }\n             mir::StatementKind::Nop => {}\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 asm.hash_stable(hcx, hasher);"}, {"sha": "425459f448fad32b7fb6ac1ab26460f2a14c0cb9", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -318,7 +318,10 @@ fn hash_token<'a, 'gcx, W: StableHasherResult>(\n             opt_name.hash_stable(hcx, hasher);\n         }\n \n-        token::Token::Ident(ident) |\n+        token::Token::Ident(ident, is_raw) => {\n+            ident.name.hash_stable(hcx, hasher);\n+            is_raw.hash_stable(hcx, hasher);\n+        }\n         token::Token::Lifetime(ident) => ident.name.hash_stable(hcx, hasher),\n \n         token::Token::Interpolated(_) => {\n@@ -368,7 +371,6 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n });\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n-    BackArrow,\n     DotFill,\n     QuestionMark\n });"}, {"sha": "340dd32a237c01fa29240d207cd700435e35ebc6", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -188,6 +188,10 @@ for ty::adjustment::Adjust<'gcx> {\n impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n+impl_stable_hash_for!(enum ty::adjustment::AllowTwoPhase {\n+    Yes,\n+    No\n+});\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::adjustment::AutoBorrowMutability {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -379,13 +383,13 @@ impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n });\n \n enum AllocDiscriminant {\n-    Static,\n-    Constant,\n+    Alloc,\n+    ExternStatic,\n     Function,\n }\n impl_stable_hash_for!(enum self::AllocDiscriminant {\n-    Static,\n-    Constant,\n+    Alloc,\n+    ExternStatic,\n     Function\n });\n \n@@ -397,17 +401,23 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     ) {\n         ty::tls::with_opt(|tcx| {\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            if let Some(def_id) = tcx.interpret_interner.get_corresponding_static_def_id(*self) {\n-                AllocDiscriminant::Static.hash_stable(hcx, hasher);\n-                // statics are unique via their DefId\n-                def_id.hash_stable(hcx, hasher);\n-            } else if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n-                // not a static, can't be recursive, hash the allocation\n-                AllocDiscriminant::Constant.hash_stable(hcx, hasher);\n-                alloc.hash_stable(hcx, hasher);\n+            if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n+                AllocDiscriminant::Alloc.hash_stable(hcx, hasher);\n+                if !hcx.alloc_id_recursion_tracker.insert(*self) {\n+                    tcx\n+                        .interpret_interner\n+                        .get_corresponding_static_def_id(*self)\n+                        .hash_stable(hcx, hasher);\n+                    alloc.hash_stable(hcx, hasher);\n+                    assert!(hcx.alloc_id_recursion_tracker.remove(self));\n+                }\n             } else if let Some(inst) = tcx.interpret_interner.get_fn(*self) {\n                 AllocDiscriminant::Function.hash_stable(hcx, hasher);\n                 inst.hash_stable(hcx, hasher);\n+            } else if let Some(def_id) = tcx.interpret_interner\n+                                            .get_corresponding_static_def_id(*self) {\n+                AllocDiscriminant::ExternStatic.hash_stable(hcx, hasher);\n+                def_id.hash_stable(hcx, hasher);\n             } else {\n                 bug!(\"no allocation for {}\", self);\n             }\n@@ -1111,7 +1121,6 @@ for ty::steal::Steal<T>\n \n impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n     caller_bounds,\n-    universe,\n     reveal\n });\n \n@@ -1282,15 +1291,6 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ty::UniverseIndex {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.depth().hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl_stable_hash_for!(\n     impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n         variables, value"}, {"sha": "eb5df697216a362bd15164efa26b39d8fcaa57b4", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 182, "deletions": 57, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -14,10 +14,10 @@ use infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n use traits::{self, PredicateObligation};\n-use ty::{self, Ty};\n-use ty::fold::{BottomUpFolder, TypeFoldable};\n+use ty::{self, Ty, TyCtxt};\n+use ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use ty::outlives::Component;\n-use ty::subst::{Kind, UnpackedKind, Substs};\n+use ty::subst::{Kind, Substs, UnpackedKind};\n use util::nodemap::DefIdMap;\n \n pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n@@ -113,10 +113,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) -> InferOk<'tcx, (T, AnonTypeMap<'tcx>)> {\n         debug!(\n             \"instantiate_anon_types(value={:?}, parent_def_id={:?}, body_id={:?}, param_env={:?})\",\n-            value,\n-            parent_def_id,\n-            body_id,\n-            param_env,\n+            value, parent_def_id, body_id, param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n@@ -458,55 +455,184 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty = gcx.fold_regions(&instantiated_ty, &mut false, |r, _| {\n-            match *r {\n-                // 'static and early-bound regions are valid.\n-                ty::ReStatic | ty::ReEmpty => r,\n-\n-                // All other regions, we map them appropriately to their adjusted\n-                // indices, erroring if we find any lifetimes that were not mapped\n-                // into the new set.\n-                _ => if let Some(UnpackedKind::Lifetime(r1)) = map.get(&r.into())\n-                                                                  .map(|k| k.unpack()) {\n-                    r1\n-                } else {\n-                    // No mapping was found. This means that\n-                    // it is either a disallowed lifetime,\n-                    // which will be caught by regionck, or it\n-                    // is a region in a non-upvar closure\n-                    // generic, which is explicitly\n-                    // allowed. If that surprises you, read\n-                    // on.\n-                    //\n-                    // The case of closure is a somewhat\n-                    // subtle (read: hacky) consideration. The\n-                    // problem is that our closure types\n-                    // currently include all the lifetime\n-                    // parameters declared on the enclosing\n-                    // function, even if they are unused by\n-                    // the closure itself. We can't readily\n-                    // filter them out, so here we replace\n-                    // those values with `'empty`. This can't\n-                    // really make a difference to the rest of\n-                    // the compiler; those regions are ignored\n-                    // for the outlives relation, and hence\n-                    // don't affect trait selection or auto\n-                    // traits, and they are erased during\n-                    // trans.\n-                    gcx.types.re_empty\n-                },\n-            }\n-        });\n-\n+        let definition_ty =\n+            instantiated_ty.fold_with(&mut ReverseMapper::new(\n+                self.tcx,\n+                self.is_tainted_by_errors(),\n+                def_id,\n+                map,\n+                instantiated_ty,\n+            ));\n         debug!(\n             \"infer_anon_definition_from_instantiation: definition_ty={:?}\",\n             definition_ty\n         );\n \n+        // We can unwrap here because our reverse mapper always\n+        // produces things with 'gcx lifetime, though the type folder\n+        // obscures that.\n+        let definition_ty = gcx.lift(&definition_ty).unwrap();\n+\n         definition_ty\n     }\n }\n \n+struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+\n+    /// If errors have already been reported in this fn, we suppress\n+    /// our own errors because they are sometimes derivative.\n+    tainted_by_errors: bool,\n+\n+    anon_type_def_id: DefId,\n+    map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n+    map_missing_regions_to_empty: bool,\n+\n+    /// initially `Some`, set to `None` once error has been reported\n+    hidden_ty: Option<Ty<'tcx>>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> ReverseMapper<'cx, 'gcx, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tainted_by_errors: bool,\n+        anon_type_def_id: DefId,\n+        map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n+        hidden_ty: Ty<'tcx>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            tainted_by_errors,\n+            anon_type_def_id,\n+            map,\n+            map_missing_regions_to_empty: false,\n+            hidden_ty: Some(hidden_ty),\n+        }\n+    }\n+\n+    fn fold_kind_mapping_missing_regions_to_empty(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        self.map_missing_regions_to_empty = true;\n+        let kind = kind.fold_with(self);\n+        self.map_missing_regions_to_empty = false;\n+        kind\n+    }\n+\n+    fn fold_kind_normally(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        kind.fold_with(self)\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match r {\n+            // ignore bound regions that appear in the type (e.g., this\n+            // would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) => return r,\n+\n+            // ignore `'static`, as that can appear anywhere\n+            ty::ReStatic => return r,\n+\n+            _ => { }\n+        }\n+\n+        match self.map.get(&r.into()).map(|k| k.unpack()) {\n+            Some(UnpackedKind::Lifetime(r1)) => r1,\n+            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None => {\n+                if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n+                    if let Some(hidden_ty) = self.hidden_ty.take() {\n+                        let span = self.tcx.def_span(self.anon_type_def_id);\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0909,\n+                            \"hidden type for `impl Trait` captures lifetime that \\\n+                             does not appear in bounds\",\n+                        );\n+\n+                        // Assuming regionck succeeded, then we must\n+                        // be capturing *some* region from the fn\n+                        // header, and hence it must be free, so it's\n+                        // ok to invoke this fn (which doesn't accept\n+                        // all regions, and would ICE if an\n+                        // inappropriate region is given). We check\n+                        // `is_tainted_by_errors` by errors above, so\n+                        // we don't get in here unless regionck\n+                        // succeeded. (Note also that if regionck\n+                        // failed, then the regions we are attempting\n+                        // to map here may well be giving errors\n+                        // *because* the constraints were not\n+                        // satisfiable.)\n+                        self.tcx.note_and_explain_free_region(\n+                            &mut err,\n+                            &format!(\"hidden type `{}` captures \", hidden_ty),\n+                            r,\n+                            \"\"\n+                        );\n+\n+                        err.emit();\n+                    }\n+                }\n+                self.tcx.types.re_empty\n+            },\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                // I am a horrible monster and I pray for death. When\n+                // we encounter a closure here, it is always a closure\n+                // from within the function that we are currently\n+                // type-checking -- one that is now being encapsulated\n+                // in an existential abstract type. Ideally, we would\n+                // go through the types/lifetimes that it references\n+                // and treat them just like we would any other type,\n+                // which means we would error out if we find any\n+                // reference to a type/region that is not in the\n+                // \"reverse map\".\n+                //\n+                // **However,** in the case of closures, there is a\n+                // somewhat subtle (read: hacky) consideration. The\n+                // problem is that our closure types currently include\n+                // all the lifetime parameters declared on the\n+                // enclosing function, even if they are unused by the\n+                // closure itself. We can't readily filter them out,\n+                // so here we replace those values with `'empty`. This\n+                // can't really make a difference to the rest of the\n+                // compiler; those regions are ignored for the\n+                // outlives relation, and hence don't affect trait\n+                // selection or auto traits, and they are erased\n+                // during trans.\n+\n+                let generics = self.tcx.generics_of(def_id);\n+                let parent_len = generics.parent_count();\n+                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n+                    |(index, &kind)| {\n+                        if index < parent_len {\n+                            // Accommodate missing regions in the parent kinds...\n+                            self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                        } else {\n+                            // ...but not elsewhere.\n+                            self.fold_kind_normally(kind)\n+                        }\n+                    },\n+                ));\n+\n+                self.tcx.mk_closure(def_id, ty::ClosureSubsts { substs })\n+            }\n+\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+}\n+\n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     parent_def_id: DefId,\n@@ -565,12 +691,13 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             return self.fold_anon_ty(ty, def_id, substs);\n                         }\n \n-                        debug!(\"instantiate_anon_types_in_map: \\\n-                                encountered anon with wrong parent \\\n-                                def_id={:?} \\\n-                                anon_parent_def_id={:?}\",\n-                               def_id,\n-                               anon_parent_def_id);\n+                        debug!(\n+                            \"instantiate_anon_types_in_map: \\\n+                             encountered anon with wrong parent \\\n+                             def_id={:?} \\\n+                             anon_parent_def_id={:?}\",\n+                            def_id, anon_parent_def_id\n+                        );\n                     }\n                 }\n \n@@ -590,8 +717,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\",\n-            def_id,\n-            substs\n+            def_id, substs\n         );\n \n         // Use the same type variable if the exact same TyAnon appears more\n@@ -600,8 +726,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             return anon_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                       TypeVariableOrigin::TypeInference(span));\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n \n         let predicates_of = tcx.predicates_of(def_id);\n         let bounds = predicates_of.instantiate(tcx, substs);"}, {"sha": "4357c9a5a776acd3cdec0084200f0e8337b3972f", "filename": "src/librustc/infer/canonical.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -33,13 +33,15 @@\n \n use infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::Idx;\n+use serialize::UseSpecializedDecodable;\n use std::fmt::Debug;\n use std::ops::Index;\n use syntax::codemap::Span;\n use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n use ty::subst::{Kind, UnpackedKind};\n use ty::fold::{TypeFoldable, TypeFolder};\n+use util::captures::Captures;\n use util::common::CellUsizeExt;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -48,14 +50,16 @@ use rustc_data_structures::fx::FxHashMap;\n /// A \"canonicalized\" type `V` is one where all free inference\n /// variables have been rewriten to \"canonical vars\". These are\n /// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub struct Canonical<'gcx, V> {\n     pub variables: CanonicalVarInfos<'gcx>,\n     pub value: V,\n }\n \n pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n \n+impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> { }\n+\n /// A set of values corresponding to the canonical variables from some\n /// `Canonical`. You can give these values to\n /// `canonical_value.substitute` to substitute them into the canonical\n@@ -68,7 +72,7 @@ pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n /// You can also use `infcx.fresh_inference_vars_for_canonical_vars`\n /// to get back a `CanonicalVarValues` containing fresh inference\n /// variables.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n }\n@@ -77,15 +81,15 @@ pub struct CanonicalVarValues<'tcx> {\n /// canonical value. This is sufficient information for code to create\n /// a copy of the canonical value in some other inference context,\n /// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub struct CanonicalVarInfo {\n     pub kind: CanonicalVarKind,\n }\n \n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n /// in the type-theory sense of the term -- i.e., a \"meta\" type system\n /// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub enum CanonicalVarKind {\n     /// Some kind of type inference variable.\n     Ty(CanonicalTyVarKind),\n@@ -99,7 +103,7 @@ pub enum CanonicalVarKind {\n /// 22.) can only be instantiated with integral/float types (e.g.,\n /// usize or f32). In order to faithfully reproduce a type, we need to\n /// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub enum CanonicalTyVarKind {\n     /// General type variable `?T` that can be unified with arbitrary types.\n     General,\n@@ -250,8 +254,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 let ty = match ty_kind {\n                     CanonicalTyVarKind::General => {\n                         self.next_ty_var(\n-                            // FIXME(#48696) this handling of universes is not right.\n-                            ty::UniverseIndex::ROOT,\n                             TypeVariableOrigin::MiscVariable(span),\n                         )\n                     }\n@@ -382,7 +384,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         unsubstituted_region_constraints: &'a QueryRegionConstraints<'tcx>,\n         result_subst: &'a CanonicalVarValues<'tcx>,\n-    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + Captures<'gcx> + 'a {\n         let QueryRegionConstraints {\n             region_outlives,\n             ty_outlives,\n@@ -854,11 +856,14 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'g\n }\n \n CloneTypeFoldableAndLiftImpls! {\n+    ::infer::canonical::Certainty,\n+    ::infer::canonical::CanonicalVarInfo,\n+    ::infer::canonical::CanonicalVarKind,\n+}\n+\n+CloneTypeFoldableImpls! {\n     for <'tcx> {\n-        ::infer::canonical::Certainty,\n-        ::infer::canonical::CanonicalVarInfo,\n         ::infer::canonical::CanonicalVarInfos<'tcx>,\n-        ::infer::canonical::CanonicalVarKind,\n     }\n }\n \n@@ -869,6 +874,13 @@ BraceStructTypeFoldableImpl! {\n     } where C: TypeFoldable<'tcx>\n }\n \n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx, T> Lift<'tcx> for Canonical<'a, T> {\n+        type Lifted = Canonical<'tcx, T::Lifted>;\n+        variables, value\n+    } where T: Lift<'tcx>\n+}\n+\n impl<'tcx> CanonicalVarValues<'tcx> {\n     fn iter<'a>(&'a self) -> impl Iterator<Item = Kind<'tcx>> + 'a {\n         self.var_values.iter().cloned()"}, {"sha": "c2167751a27e7d099ec527fa2104357b27ddb6bf", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -407,7 +407,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        TypeVariableValue::Unknown { universe } => {\n+                        TypeVariableValue::Unknown { .. } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),\n@@ -424,7 +424,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             }\n \n                             let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(universe, false, origin);\n+                            let new_var_id = variables.new_var(false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);"}, {"sha": "961dd70a4685204b927909c1738f9f3463b73b6b", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -141,11 +141,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n                         // This variable was created during the\n                         // fudging. Recreate it with a fresh variable\n                         // here.\n-                        //\n-                        // The ROOT universe is fine because we only\n-                        // ever invoke this routine at the\n-                        // \"item-level\" of inference.\n-                        self.infcx.next_ty_var(ty::UniverseIndex::ROOT, origin)\n+                        self.infcx.next_ty_var(origin)\n                     }\n                 }\n             }"}, {"sha": "28aba51ab372468b403f4ff62525bb9d176db1c4", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -88,17 +88,13 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I\n         // think this suffices. -nmatsakis\n-        (&ty::TyInfer(TyVar(a_vid)), _) => {\n-            let universe = infcx.type_variables.borrow_mut().probe(a_vid).universe().unwrap();\n-            let v = infcx.next_ty_var(universe,\n-                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (&ty::TyInfer(TyVar(..)), _) => {\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, b, a)?;\n             Ok(v)\n         }\n-        (_, &ty::TyInfer(TyVar(b_vid))) => {\n-            let universe = infcx.type_variables.borrow_mut().probe(b_vid).universe().unwrap();\n-            let v = infcx.next_ty_var(universe,\n-                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (_, &ty::TyInfer(TyVar(..))) => {\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "032a5c59d2dcaac063b1e11b2687fab781ad75b9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -837,25 +837,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self,\n-                          universe: ty::UniverseIndex,\n-                          diverging: bool,\n-                          origin: TypeVariableOrigin)\n-                          -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(universe, diverging, origin)\n+            .new_var(diverging, origin)\n     }\n \n-    pub fn next_ty_var(&self, universe: ty::UniverseIndex, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(universe, false, origin))\n+    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self,\n-                                 universe: ty::UniverseIndex,\n-                                 origin: TypeVariableOrigin)\n-                                 -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(universe, true, origin))\n+    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -910,14 +903,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// use an inference variable for `C` with `[T, U]`\n     /// as the substitutions for the default, `(T, U)`.\n     pub fn type_var_for_def(&self,\n-                            universe: ty::UniverseIndex,\n                             span: Span,\n                             def: &ty::TypeParameterDef)\n                             -> Ty<'tcx> {\n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(universe,\n-                                     false,\n+                            .new_var(false,\n                                      TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n \n         self.tcx.mk_var(ty_var_id)\n@@ -926,14 +917,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_item(&self,\n-                                 universe: ty::UniverseIndex,\n                                  span: Span,\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n         Substs::for_item(self.tcx, def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, _| {\n-            self.type_var_for_def(universe, span, def)\n+            self.type_var_for_def(span, def)\n         })\n     }\n "}, {"sha": "4bc64acc7630690ddae18eda0394d5bfbe7bd3d0", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -11,7 +11,7 @@\n use infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n-use traits::FulfillmentContext;\n+use traits::{FulfillmentContext, TraitEngine};\n use ty::{self, Ty, TypeFoldable};\n use ty::outlives::Component;\n use ty::wf;"}, {"sha": "4113a2dd4178bfd8e92a162d6e8d2c6ab673c642", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -48,7 +48,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     glbs: CombineMap<'tcx>,\n \n     /// Number of skolemized variables currently active.\n-    skolemization_count: ty::UniverseIndex,\n+    skolemization_count: u32,\n \n     /// Global counter used during the GLB algorithm to create unique\n     /// names for fresh bound regions\n@@ -233,7 +233,7 @@ type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n pub struct RegionSnapshot {\n     length: usize,\n     region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n-    skolemization_count: ty::UniverseIndex,\n+    skolemization_count: u32,\n }\n \n /// When working with skolemized regions, we often wish to find all of\n@@ -277,7 +277,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n-            skolemization_count: ty::UniverseIndex::ROOT,\n+            skolemization_count: 0,\n             bound_count: 0,\n             undo_log: Vec::new(),\n             unification_table: ut::UnificationTable::new(),\n@@ -329,7 +329,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             unification_table,\n         } = self;\n \n-        assert_eq!(skolemization_count.as_usize(), 0);\n+        assert_eq!(*skolemization_count, 0);\n \n         // Clear the tables of (lubs, glbs), so that we will create\n         // fresh regions if we do a LUB operation. As it happens,\n@@ -375,7 +375,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n             self.skolemization_count == snapshot.skolemization_count,\n-            \"failed to pop skolemized regions: {:?} now vs {:?} at start\",\n+            \"failed to pop skolemized regions: {} now vs {} at start\",\n             self.skolemization_count,\n             snapshot.skolemization_count\n         );\n@@ -485,9 +485,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n \n-        let universe = self.skolemization_count.subuniverse();\n-        self.skolemization_count = universe;\n-        tcx.mk_region(ReSkolemized(universe, br))\n+        let sc = self.skolemization_count;\n+        self.skolemization_count = sc + 1;\n+        tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n@@ -505,34 +505,34 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n-            self.skolemization_count.as_usize() >= skols.len(),\n+            self.skolemization_count as usize >= skols.len(),\n             \"popping more skolemized variables than actually exist, \\\n              sc now = {}, skols.len = {}\",\n-            self.skolemization_count.as_usize(),\n+            self.skolemization_count,\n             skols.len()\n         );\n \n-        let last_to_pop = self.skolemization_count.subuniverse();\n-        let first_to_pop = ty::UniverseIndex::from(last_to_pop.as_u32() - (skols.len() as u32));\n+        let last_to_pop = self.skolemization_count;\n+        let first_to_pop = last_to_pop - (skols.len() as u32);\n \n         assert!(\n             first_to_pop >= snapshot.skolemization_count,\n             \"popping more regions than snapshot contains, \\\n-             sc now = {:?}, sc then = {:?}, skols.len = {}\",\n+             sc now = {}, sc then = {}, skols.len = {}\",\n             self.skolemization_count,\n             snapshot.skolemization_count,\n             skols.len()\n         );\n         debug_assert! {\n             skols.iter()\n                  .all(|&k| match *k {\n-                     ty::ReSkolemized(universe, _) =>\n-                         universe >= first_to_pop &&\n-                         universe < last_to_pop,\n+                     ty::ReSkolemized(index, _) =>\n+                         index.index >= first_to_pop &&\n+                         index.index < last_to_pop,\n                      _ =>\n                          false\n                  }),\n-            \"invalid skolemization keys or keys out of range ({:?}..{:?}): {:?}\",\n+            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n             snapshot.skolemization_count,\n             self.skolemization_count,\n             skols\n@@ -867,7 +867,7 @@ impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(\n             f,\n-            \"RegionSnapshot(length={},skolemization={:?})\",\n+            \"RegionSnapshot(length={},skolemization={})\",\n             self.length,\n             self.skolemization_count\n         )"}, {"sha": "91df6cabf3a8b88c4ae0e5a6a5b947a494638aa7", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -78,33 +78,17 @@ struct TypeVariableData {\n #[derive(Copy, Clone, Debug)]\n pub enum TypeVariableValue<'tcx> {\n     Known { value: Ty<'tcx> },\n-    Unknown { universe: ty::UniverseIndex },\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum ProbeTyValue<'tcx> {\n-    Ty(Ty<'tcx>),\n-    Vid(ty::TyVid),\n+    Unknown,\n }\n \n impl<'tcx> TypeVariableValue<'tcx> {\n-    /// If this value is known, returns the type it is known to be.\n-    /// Otherwise, `None`.\n     pub fn known(&self) -> Option<Ty<'tcx>> {\n         match *self {\n             TypeVariableValue::Unknown { .. } => None,\n             TypeVariableValue::Known { value } => Some(value),\n         }\n     }\n \n-    /// If this value is unknown, returns the universe, otherwise `None`.\n-    pub fn universe(&self) -> Option<ty::UniverseIndex> {\n-        match *self {\n-            TypeVariableValue::Unknown { universe } => Some(universe),\n-            TypeVariableValue::Known { .. } => None,\n-        }\n-    }\n-\n     pub fn is_unknown(&self) -> bool {\n         match *self {\n             TypeVariableValue::Unknown { .. } => true,\n@@ -197,11 +181,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///   The code in this module doesn't care, but it can be useful\n     ///   for improving error messages.\n     pub fn new_var(&mut self,\n-                   universe: ty::UniverseIndex,\n                    diverging: bool,\n                    origin: TypeVariableOrigin)\n                    -> ty::TyVid {\n-        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown);\n \n         let sub_key = self.sub_relations.new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n@@ -453,12 +436,8 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n             (&TypeVariableValue::Known { .. }, &TypeVariableValue::Unknown { .. }) => Ok(*value1),\n             (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n \n-            // If both sides are unknown, we need to pick the most restrictive universe.\n-            (&TypeVariableValue::Unknown { universe: universe1 },\n-             &TypeVariableValue::Unknown { universe: universe2 }) => {\n-                let universe = cmp::min(universe1, universe2);\n-                Ok(TypeVariableValue::Unknown { universe })\n-            }\n+            // If both sides are *unknown*, it hardly matters, does it?\n+            (&TypeVariableValue::Unknown, &TypeVariableValue::Unknown) => Ok(*value1),\n         }\n     }\n }"}, {"sha": "dcad8132c2b2478a0b3eac0d0475010b8d647e67", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -43,20 +43,19 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(conservative_impl_trait)]\n+#![cfg_attr(stage0, feature(conservative_impl_trait))]\n #![feature(const_fn)]\n-#![feature(copy_closures, clone_closures)]\n+#![cfg_attr(stage0, feature(copy_closures, clone_closures))]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(dyn_trait)]\n #![feature(entry_or_default)]\n #![feature(from_ref)]\n #![feature(fs_read_write)]\n-#![feature(i128)]\n-#![feature(i128_type)]\n+#![cfg_attr(stage0, feature(i128_type, i128))]\n #![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![cfg_attr(windows, feature(libc))]\n-#![feature(match_default_bindings)]\n+#![cfg_attr(stage0, feature(match_default_bindings))]\n #![feature(macro_lifetime_matcher)]\n #![feature(macro_vis_matcher)]\n #![feature(exhaustive_patterns)]\n@@ -69,8 +68,8 @@\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n-#![feature(underscore_lifetimes)]\n-#![feature(universal_impl_trait)]\n+#![cfg_attr(stage0, feature(underscore_lifetimes))]\n+#![cfg_attr(stage0, feature(universal_impl_trait))]\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n #![feature(catch_expr)]\n@@ -157,6 +156,7 @@ pub mod traits;\n pub mod ty;\n \n pub mod util {\n+    pub mod captures;\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;"}, {"sha": "97cfcf0f60795a07080b82d196a545aee8e14db9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -260,6 +260,12 @@ declare_lint! {\n     \"floating-point literals cannot be used in patterns\"\n }\n \n+declare_lint! {\n+    pub UNSTABLE_NAME_COLLISION,\n+    Warn,\n+    \"detects name collision with an existing but unstable method\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -307,7 +313,8 @@ impl LintPass for HardwiredLints {\n             SINGLE_USE_LIFETIME,\n             TYVAR_BEHIND_RAW_POINTER,\n             ELIDED_LIFETIME_IN_PATH,\n-            BARE_TRAIT_OBJECT\n+            BARE_TRAIT_OBJECT,\n+            UNSTABLE_NAME_COLLISION,\n         )\n     }\n }"}, {"sha": "3c833251f72a78c410b5ab735ced0fb569791bc9", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -41,7 +41,7 @@ use util::nodemap::FxHashMap;\n use std::default::Default as StdDefault;\n use std::cell::{Ref, RefCell};\n use syntax::ast;\n-use syntax::epoch;\n+use syntax::edition;\n use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n use hir;\n@@ -103,9 +103,9 @@ pub struct FutureIncompatibleInfo {\n     pub id: LintId,\n     /// e.g., a URL for an issue/PR/RFC or error code\n     pub reference: &'static str,\n-    /// If this is an epoch fixing lint, the epoch in which\n+    /// If this is an edition fixing lint, the edition in which\n     /// this lint becomes obsolete\n-    pub epoch: Option<epoch::Epoch>,\n+    pub edition: Option<edition::Edition>,\n }\n \n /// The target of the `by_name` map, which accounts for renaming/deprecation.\n@@ -201,11 +201,11 @@ impl LintStore {\n                                         sess: Option<&Session>,\n                                         lints: Vec<FutureIncompatibleInfo>) {\n \n-        for epoch in epoch::ALL_EPOCHS {\n-            let lints = lints.iter().filter(|f| f.epoch == Some(*epoch)).map(|f| f.id)\n+        for edition in edition::ALL_EDITIONS {\n+            let lints = lints.iter().filter(|f| f.edition == Some(*edition)).map(|f| f.id)\n                              .collect::<Vec<_>>();\n             if !lints.is_empty() {\n-                self.register_group(sess, false, epoch.lint_name(), lints)\n+                self.register_group(sess, false, edition.lint_name(), lints)\n             }\n         }\n "}, {"sha": "1497be2d5ba0d35448feeed03c0ca4dcce1a95fd", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -42,7 +42,7 @@ use session::{Session, DiagnosticMessageId};\n use std::hash;\n use syntax::ast;\n use syntax::codemap::MultiSpan;\n-use syntax::epoch::Epoch;\n+use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n use syntax::visit as ast_visit;\n use syntax_pos::Span;\n@@ -77,8 +77,8 @@ pub struct Lint {\n     /// e.g. \"imports that are never used\"\n     pub desc: &'static str,\n \n-    /// Deny lint after this epoch\n-    pub epoch_deny: Option<Epoch>,\n+    /// Deny lint after this edition\n+    pub edition_deny: Option<Edition>,\n }\n \n impl Lint {\n@@ -88,8 +88,8 @@ impl Lint {\n     }\n \n     pub fn default_level(&self, session: &Session) -> Level {\n-        if let Some(epoch_deny) = self.epoch_deny {\n-            if session.epoch() >= epoch_deny {\n+        if let Some(edition_deny) = self.edition_deny {\n+            if session.edition() >= edition_deny {\n                 return Level::Deny\n             }\n         }\n@@ -100,20 +100,20 @@ impl Lint {\n /// Declare a static item of type `&'static Lint`.\n #[macro_export]\n macro_rules! declare_lint {\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr, $epoch: expr) => (\n+    ($vis: vis $NAME: ident, $Level: ident, $desc: expr, $edition: expr) => (\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n             default_level: $crate::lint::$Level,\n             desc: $desc,\n-            epoch_deny: Some($epoch)\n+            edition_deny: Some($edition)\n         };\n     );\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n             default_level: $crate::lint::$Level,\n             desc: $desc,\n-            epoch_deny: None,\n+            edition_deny: None,\n         };\n     );\n }\n@@ -498,15 +498,21 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n     // Check for future incompatibility lints and issue a stronger warning.\n     let lints = sess.lint_store.borrow();\n-    if let Some(future_incompatible) = lints.future_incompatible(LintId::of(lint)) {\n-        let future = if let Some(epoch) = future_incompatible.epoch {\n-            format!(\"the {} epoch\", epoch)\n+    let lint_id = LintId::of(lint);\n+    if let Some(future_incompatible) = lints.future_incompatible(lint_id) {\n+        const STANDARD_MESSAGE: &str =\n+            \"this was previously accepted by the compiler but is being phased out; \\\n+             it will become a hard error\";\n+\n+        let explanation = if lint_id == LintId::of(::lint::builtin::UNSTABLE_NAME_COLLISION) {\n+            \"once this method is added to the standard library, \\\n+             there will be ambiguity here, which will cause a hard error!\"\n+                .to_owned()\n+        } else if let Some(edition) = future_incompatible.edition {\n+            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n         } else {\n-            \"a future release\".to_owned()\n+            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n         };\n-        let explanation = format!(\"this was previously accepted by the compiler \\\n-                                   but is being phased out; \\\n-                                   it will become a hard error in {}!\", future);\n         let citation = format!(\"for more information, see {}\",\n                                future_incompatible.reference);\n         err.warn(&explanation);"}, {"sha": "19a7576b7ceac4ed1abd99d739a9c89751ebb46b", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -19,7 +19,7 @@ use graphviz::IntoCow;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n pub type EvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ConstEvalErr<'tcx>>;\n \n@@ -52,7 +52,7 @@ impl<'tcx> ConstVal<'tcx> {\n #[derive(Clone, Debug)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub kind: Rc<ErrKind<'tcx>>,\n+    pub kind: Lrc<ErrKind<'tcx>>,\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "add9b621596b63219db2d406dab8020c0a4bb13a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -132,7 +132,13 @@ pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Symbol,\n     pub cfg: Option<ast::MetaItem>,\n+    pub foreign_module: Option<DefId>,\n+}\n+\n+#[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n+pub struct ForeignModule {\n     pub foreign_items: Vec<DefId>,\n+    pub def_id: DefId,\n }\n \n pub enum LoadedMacro {"}, {"sha": "abd52624c30d4c6b96e7d4083c764ccdd7b28bcd", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -318,6 +318,11 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt,\n         return true;\n     }\n \n+    // These constants are special for wasm\n+    if attr::contains_name(attrs, \"wasm_custom_section\") {\n+        return true;\n+    }\n+\n     tcx.lint_level_at_node(lint::builtin::DEAD_CODE, id).0 == lint::Allow\n }\n "}, {"sha": "7e1b7c08c3dad99fc22c4566c84cf15a3e78082e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -353,8 +353,8 @@ pub struct ScopeTree {\n     /// the result of `g()` occurs after the yield (and therefore\n     /// doesn't). If we want to infer that, we can look at the\n     /// postorder traversal:\n-    /// ```\n-    /// `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n+    /// ```plain,ignore\n+    ///     `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n     /// ```\n     ///\n     /// In which we can easily see that `Call#1` occurs before the yield,"}, {"sha": "ceda72dcd7ae0ab51976be10386baf0c636bd5fb", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 95, "deletions": 70, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -31,6 +31,7 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n+use session::Session;\n use std::slice;\n use rustc::lint;\n \n@@ -468,11 +469,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemFn(ref decl, _, _, _, ref generics, _) => {\n-                self.visit_early_late(None,\n-                                      decl,\n-                                      generics,\n-                                      |this| {\n-                                          intravisit::walk_item(this, item);\n+                self.visit_early_late(None, decl, generics, |this| {\n+                    intravisit::walk_item(this, item);\n                 });\n             }\n \n@@ -505,7 +503,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 } else {\n                     0\n                 };\n-                let lifetimes = generics.lifetimes()\n+                let lifetimes = generics\n+                    .lifetimes()\n                     .map(|def| Region::early(&self.tcx.hir, &mut index, def))\n                     .collect();\n                 let next_early_index = index + generics.ty_params().count() as u32;\n@@ -526,12 +525,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         match item.node {\n             hir::ForeignItemFn(ref decl, _, ref generics) => {\n-                self.visit_early_late(None,\n-                                      decl,\n-                                      generics,\n-                                      |this| {\n-                                          intravisit::walk_foreign_item(this, item);\n-                                      })\n+                self.visit_early_late(None, decl, generics, |this| {\n+                    intravisit::walk_foreign_item(this, item);\n+                })\n             }\n             hir::ForeignItemStatic(..) => {\n                 intravisit::walk_foreign_item(self, item);\n@@ -586,7 +582,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // cc #48468\n                         self.resolve_elided_lifetimes(slice::from_ref(lifetime), false)\n                     }\n-                    LifetimeName::Static | LifetimeName::Name(_) => {\n+                    LifetimeName::Fresh(_) | LifetimeName::Static | LifetimeName::Name(_) => {\n                         // If the user wrote an explicit name, use that.\n                         self.visit_lifetime(lifetime);\n                     }\n@@ -670,7 +666,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 if let Some(elision_region) = elision {\n                     let scope = Scope::Elision {\n                         elide: Elide::Exact(elision_region),\n-                        s: self.scope\n+                        s: self.scope,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         let scope = Scope::Binder {\n@@ -716,12 +712,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n-            },\n+            }\n             Type(ref bounds, ref ty) => {\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.lifetimes()\n+                let lifetimes = generics\n+                    .lifetimes()\n                     .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n                     .collect();\n \n@@ -741,12 +738,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.visit_ty(ty);\n                     }\n                 });\n-            },\n+            }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(trait_item.generics.params.is_empty());\n                 intravisit::walk_trait_item(self, trait_item);\n-            },\n+            }\n         }\n     }\n \n@@ -761,12 +758,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n                 )\n-            },\n+            }\n             Type(ref ty) => {\n                 let generics = &impl_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.lifetimes()\n+                let lifetimes = generics\n+                    .lifetimes()\n                     .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n                     .collect();\n \n@@ -781,12 +779,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n                 });\n-            },\n+            }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(impl_item.generics.params.is_empty());\n                 intravisit::walk_impl_item(self, impl_item);\n-            },\n+            }\n         }\n     }\n \n@@ -822,7 +820,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         check_mixed_explicit_and_in_band_defs(\n             self.tcx,\n-            &generics.lifetimes().cloned().collect::<Vec<_>>()\n+            &generics.lifetimes().cloned().collect::<Vec<_>>(),\n         );\n         for ty_param in generics.ty_params() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n@@ -842,7 +840,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n-                            lifetimes: bound_generic_params.lifetimes()\n+                            lifetimes: bound_generic_params\n+                                .lifetimes()\n                                 .map(|def| Region::late(&self.tcx.hir, def))\n                                 .collect(),\n                             s: self.scope,\n@@ -890,8 +889,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        if !self.trait_ref_hack ||\n-            trait_ref.bound_generic_params.iter().any(|p| p.is_lifetime_param())\n+        if !self.trait_ref_hack\n+            || trait_ref\n+                .bound_generic_params\n+                .iter()\n+                .any(|p| p.is_lifetime_param())\n         {\n             if self.trait_ref_hack {\n                 span_err!(\n@@ -903,7 +905,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref.bound_generic_params\n+                lifetimes: trait_ref\n+                    .bound_generic_params\n                     .lifetimes()\n                     .map(|def| Region::late(&self.tcx.hir, def))\n                     .collect(),\n@@ -1144,7 +1147,8 @@ fn compute_object_lifetime_defaults(\n                         .map(|set| match *set {\n                             Set1::Empty => \"BaseDefault\".to_string(),\n                             Set1::One(Region::Static) => \"'static\".to_string(),\n-                            Set1::One(Region::EarlyBound(i, _, _)) => generics.lifetimes()\n+                            Set1::One(Region::EarlyBound(i, _, _)) => generics\n+                                .lifetimes()\n                                 .nth(i as usize)\n                                 .unwrap()\n                                 .lifetime\n@@ -1182,7 +1186,8 @@ fn object_lifetime_defaults_for_item(\n         }\n     }\n \n-    generics.ty_params()\n+    generics\n+        .ty_params()\n         .map(|param| {\n             let mut set = Set1::Empty;\n \n@@ -1278,17 +1283,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if let hir::map::NodeLifetime(hir_lifetime) = this.tcx.hir.get(node_id) {\n                         let span = hir_lifetime.span;\n                         let id = hir_lifetime.id;\n-                        debug!(\"id ={:?} span = {:?} hir_lifetime = {:?}\",\n-                            node_id,\n-                            span,\n-                            hir_lifetime);\n+                        debug!(\n+                            \"id ={:?} span = {:?} hir_lifetime = {:?}\",\n+                            node_id, span, hir_lifetime\n+                        );\n \n                         this.tcx\n-                            .struct_span_lint_node(lint::builtin::SINGLE_USE_LIFETIME,\n-                                                   id,\n-                                                   span,\n-                                                   &format!(\"lifetime name `{}` only used once\",\n-                                                   hir_lifetime.name.name()))\n+                            .struct_span_lint_node(\n+                                lint::builtin::SINGLE_USE_LIFETIME,\n+                                id,\n+                                span,\n+                                &format!(\n+                                    \"lifetime name `{}` only used once\",\n+                                    hir_lifetime.name.name()\n+                                ),\n+                            )\n                             .emit();\n                     }\n                 }\n@@ -1379,8 +1388,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     abstract_type_parent,\n                     ..\n-                } if (!only_abstract_type_parent || abstract_type_parent)\n-                => return next_early_index,\n+                } if (!only_abstract_type_parent || abstract_type_parent) =>\n+                {\n+                    return next_early_index\n+                }\n \n                 Scope::Binder { s, .. }\n                 | Scope::Body { s, .. }\n@@ -1698,8 +1709,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            hir::map::NodeForeignItem(_) | hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) =>\n-                None,\n+            hir::map::NodeForeignItem(_) | hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {\n@@ -1894,7 +1904,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     lint::builtin::ELIDED_LIFETIME_IN_PATH,\n                     id,\n                     span,\n-                    &format!(\"hidden lifetime parameters are deprecated, try `Foo<'_>`\"))\n+                    &format!(\"hidden lifetime parameters are deprecated, try `Foo<'_>`\"),\n+                )\n                 .emit();\n         }\n         let error = loop {\n@@ -1933,25 +1944,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            span,\n-            E0106,\n-            \"missing lifetime specifier{}\",\n-            if lifetime_refs.len() > 1 { \"s\" } else { \"\" }\n-        );\n-        let msg = if lifetime_refs.len() > 1 {\n-            format!(\"expected {} lifetime parameters\", lifetime_refs.len())\n-        } else {\n-            format!(\"expected lifetime parameter\")\n-        };\n-        err.span_label(span, msg);\n+        let mut err = report_missing_lifetime_specifiers(self.tcx.sess, span, lifetime_refs.len());\n \n         if let Some(params) = error {\n             if lifetime_refs.len() == 1 {\n                 self.report_elision_failure(&mut err, params);\n             }\n         }\n+\n         err.emit();\n     }\n \n@@ -2086,7 +2086,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         );\n                         err.emit();\n                     }\n-                    hir::LifetimeName::Implicit | hir::LifetimeName::Name(_) => {}\n+                    hir::LifetimeName::Fresh(_) | hir::LifetimeName::Implicit |\n+                    hir::LifetimeName::Name(_) => {}\n                 }\n             }\n \n@@ -2138,17 +2139,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             ))\n                             .emit();\n                     }\n-                    hir::LifetimeName::Implicit | hir::LifetimeName::Name(_) => {\n+                    hir::LifetimeName::Fresh(_) | hir::LifetimeName::Implicit |\n+                    hir::LifetimeName::Name(_) => {\n                         self.resolve_lifetime_ref(bound);\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn check_lifetime_def_for_shadowing(&self,\n-                                        mut old_scope: ScopeRef,\n-                                        lifetime: &'tcx hir::Lifetime) {\n+    fn check_lifetime_def_for_shadowing(\n+        &self,\n+        mut old_scope: ScopeRef,\n+        lifetime: &'tcx hir::Lifetime,\n+    ) {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n             if lifetime.name.name() == label {\n@@ -2216,14 +2220,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.map.defs.insert(lifetime_ref.id, def);\n \n         match def {\n-            Region::LateBoundAnon(..) |\n-            Region::Static => {\n+            Region::LateBoundAnon(..) | Region::Static => {\n                 // These are anonymous lifetimes or lifetimes that are not declared.\n             }\n \n-            Region::Free(_, def_id) |\n-            Region::LateBound(_, def_id, _) |\n-            Region::EarlyBound(_, def_id, _) => {\n+            Region::Free(_, def_id)\n+            | Region::LateBound(_, def_id, _)\n+            | Region::EarlyBound(_, def_id, _) => {\n                 // A lifetime declared by the user.\n                 if !self.lifetime_uses.contains_key(&def_id) {\n                     self.lifetime_uses\n@@ -2255,8 +2258,7 @@ fn insert_late_bound_lifetimes(\n ) {\n     debug!(\n         \"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n-        decl,\n-        generics\n+        decl, generics\n     );\n \n     let mut constrained_by_input = ConstrainedCollector {\n@@ -2335,8 +2337,7 @@ fn insert_late_bound_lifetimes(\n         debug!(\n             \"insert_late_bound_lifetimes: \\\n              lifetime {:?} with id {:?} is late-bound\",\n-            lifetime.lifetime.name,\n-            lifetime.lifetime.id\n+            lifetime.lifetime.name, lifetime.lifetime.id\n         );\n \n         let inserted = map.late_bound.insert(lifetime.lifetime.id);\n@@ -2403,3 +2404,27 @@ fn insert_late_bound_lifetimes(\n         }\n     }\n }\n+\n+pub fn report_missing_lifetime_specifiers(\n+    sess: &Session,\n+    span: Span,\n+    count: usize,\n+) -> DiagnosticBuilder<'_> {\n+    let mut err = struct_span_err!(\n+        sess,\n+        span,\n+        E0106,\n+        \"missing lifetime specifier{}\",\n+        if count > 1 { \"s\" } else { \"\" }\n+    );\n+\n+    let msg = if count > 1 {\n+        format!(\"expected {} lifetime parameters\", count)\n+    } else {\n+        format!(\"expected lifetime parameter\")\n+    };\n+\n+    err.span_label(span, msg);\n+\n+    err\n+}"}, {"sha": "328b2db2b58282ade9b5d6267842fb50af59aa29", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 114, "deletions": 38, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -470,10 +470,50 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir.krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n }\n \n+/// Check whether an item marked with `deprecated(since=\"X\")` is currently\n+/// deprecated (i.e. whether X is not greater than the current rustc version).\n+pub fn deprecation_in_effect(since: &str) -> bool {\n+    fn parse_version(ver: &str) -> Vec<u32> {\n+        // We ignore non-integer components of the version (e.g. \"nightly\").\n+        ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n+    }\n+\n+    if let Some(rustc) = option_env!(\"CFG_RELEASE\") {\n+        let since: Vec<u32> = parse_version(since);\n+        let rustc: Vec<u32> = parse_version(rustc);\n+        // We simply treat invalid `since` attributes as relating to a previous\n+        // Rust version, thus always displaying the warning.\n+        if since.len() != 3 {\n+            return true;\n+        }\n+        since <= rustc\n+    } else {\n+        // By default, a deprecation warning applies to\n+        // the current version of the compiler.\n+        true\n+    }\n+}\n+\n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n+/// Result of `TyCtxt::eval_stability`.\n+pub enum EvalResult {\n+    /// We can use the item because it is stable or we provided the\n+    /// corresponding feature gate.\n+    Allow,\n+    /// We cannot use the item because it is unstable and we did not provide the\n+    /// corresponding feature gate.\n+    Deny {\n+        feature: Symbol,\n+        reason: Option<Symbol>,\n+        issue: u32,\n+    },\n+    /// The item does not have the `#[stable]` or `#[unstable]` marker assigned.\n+    Unmarked,\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // (See issue #38412)\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n@@ -509,14 +549,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn check_stability(self, def_id: DefId, id: NodeId, span: Span) {\n+    /// Evaluates the stability of an item.\n+    ///\n+    /// Returns `EvalResult::Allow` if the item is stable, or unstable but the corresponding\n+    /// `#![feature]` has been provided. Returns `EvalResult::Deny` which describes the offending\n+    /// unstable feature otherwise.\n+    ///\n+    /// If `id` is `Some(_)`, this function will also check if the item at `def_id` has been\n+    /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n+    /// `id`.\n+    pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n         if span.allows_unstable() {\n             debug!(\"stability: \\\n                     skipping span={:?} since it is internal\", span);\n-            return;\n+            return EvalResult::Allow;\n         }\n \n-        let lint_deprecated = |def_id: DefId, note: Option<Symbol>| {\n+        let lint_deprecated = |def_id: DefId, id: NodeId, note: Option<Symbol>| {\n             let path = self.item_path_str(def_id);\n \n             let msg = if let Some(note) = note {\n@@ -526,30 +575,39 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             self.lint_node(lint::builtin::DEPRECATED, id, span, &msg);\n+            if id == ast::DUMMY_NODE_ID {\n+                span_bug!(span, \"emitted a deprecated lint with dummy node id: {:?}\", def_id);\n+            }\n         };\n \n         // Deprecated attributes apply in-crate and cross-crate.\n-        if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-            let skip = if id == ast::DUMMY_NODE_ID {\n-                true\n-            } else {\n+        if let Some(id) = id {\n+            if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n+                // If the deprecation is scheduled for a future Rust\n+                // version, then we should display no warning message.\n+                let deprecated_in_future_version = if let Some(sym) = depr_entry.attr.since {\n+                    let since = sym.as_str();\n+                    !deprecation_in_effect(&since)\n+                } else {\n+                    false\n+                };\n+\n                 let parent_def_id = self.hir.local_def_id(self.hir.get_parent(id));\n-                self.lookup_deprecation_entry(parent_def_id).map_or(false, |parent_depr| {\n-                    parent_depr.same_origin(&depr_entry)\n-                })\n+                let skip = deprecated_in_future_version ||\n+                           self.lookup_deprecation_entry(parent_def_id)\n+                               .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n+                if !skip {\n+                    lint_deprecated(def_id, id, depr_entry.attr.note);\n+                }\n             };\n-\n-            if !skip {\n-                lint_deprecated(def_id, depr_entry.attr.note);\n-            }\n         }\n \n         let is_staged_api = self.lookup_stability(DefId {\n             index: CRATE_DEF_INDEX,\n             ..def_id\n         }).is_some();\n         if !is_staged_api {\n-            return;\n+            return EvalResult::Allow;\n         }\n \n         let stability = self.lookup_stability(def_id);\n@@ -558,26 +616,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(&Stability{rustc_depr: Some(attr::RustcDeprecation { reason, .. }), ..})\n                 = stability {\n-            if id != ast::DUMMY_NODE_ID {\n-                lint_deprecated(def_id, Some(reason));\n+            if let Some(id) = id {\n+                lint_deprecated(def_id, id, Some(reason));\n             }\n         }\n \n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !def_id.is_local();\n         if !cross_crate {\n-            return\n+            return EvalResult::Allow;\n         }\n \n         // Issue 38412: private items lack stability markers.\n         if self.skip_stability_check_due_to_privacy(def_id) {\n-            return\n+            return EvalResult::Allow;\n         }\n \n         match stability {\n-            Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n-                if self.stability().active_features.contains(feature) {\n-                    return\n+            Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n+                if self.stability().active_features.contains(&feature) {\n+                    return EvalResult::Allow;\n                 }\n \n                 // When we're compiling the compiler itself we may pull in\n@@ -589,19 +647,41 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // the `-Z force-unstable-if-unmarked` flag present (we're\n                 // compiling a compiler crate), then let this missing feature\n                 // annotation slide.\n-                if *feature == \"rustc_private\" && issue == 27812 {\n+                if feature == \"rustc_private\" && issue == 27812 {\n                     if self.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-                        return\n+                        return EvalResult::Allow;\n                     }\n                 }\n \n-                let msg = match *reason {\n-                    Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n-                                           feature.as_str(), &r),\n+                EvalResult::Deny { feature, reason, issue }\n+            }\n+            Some(_) => {\n+                // Stable APIs are always ok to call and deprecated APIs are\n+                // handled by the lint emitting logic above.\n+                EvalResult::Allow\n+            }\n+            None => {\n+                EvalResult::Unmarked\n+            }\n+        }\n+    }\n+\n+    /// Checks if an item is stable or error out.\n+    ///\n+    /// If the item defined by `def_id` is unstable and the corresponding `#![feature]` does not\n+    /// exist, emits an error.\n+    ///\n+    /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n+    /// not `None`, a deprecated lint attached to `id` will be emitted.\n+    pub fn check_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) {\n+        match self.eval_stability(def_id, id, span) {\n+            EvalResult::Allow => {}\n+            EvalResult::Deny { feature, reason, issue } => {\n+                let msg = match reason {\n+                    Some(r) => format!(\"use of unstable library feature '{}': {}\", feature, r),\n                     None => format!(\"use of unstable library feature '{}'\", &feature)\n                 };\n \n-\n                 let msp: MultiSpan = span.into();\n                 let cm = &self.sess.parse_sess.codemap();\n                 let span_key = msp.primary_span().and_then(|sp: Span|\n@@ -624,12 +704,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n-            Some(_) => {\n-                // Stable APIs are always ok to call and deprecated APIs are\n-                // handled by the lint emitting logic above.\n-            }\n-            None => {\n-                span_bug!(span, \"encountered unmarked API\");\n+            EvalResult::Unmarked => {\n+                span_bug!(span, \"encountered unmarked API: {:?}\", def_id);\n             }\n         }\n     }\n@@ -655,7 +731,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     None => return,\n                 };\n                 let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-                self.tcx.check_stability(def_id, item.id, item.span);\n+                self.tcx.check_stability(def_id, Some(item.id), item.span);\n             }\n \n             // For implementations of traits, check the stability of each item\n@@ -668,8 +744,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)\n                             .find(|item| item.name == impl_item.name).map(|item| item.def_id);\n                         if let Some(def_id) = trait_item_def_id {\n-                            // Pass `DUMMY_NODE_ID` to skip deprecation warnings.\n-                            self.tcx.check_stability(def_id, ast::DUMMY_NODE_ID, impl_item.span);\n+                            // Pass `None` to skip deprecation warnings.\n+                            self.tcx.check_stability(def_id, None, impl_item.span);\n                         }\n                     }\n                 }\n@@ -705,7 +781,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match path.def {\n             Def::Local(..) | Def::Upvar(..) |\n             Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {}\n-            _ => self.tcx.check_stability(path.def.def_id(), id, path.span)\n+            _ => self.tcx.check_stability(path.def.def_id(), Some(id), path.span)\n         }\n         intravisit::walk_path(self, path)\n     }"}, {"sha": "e242ec4985ab4ae838f7a974aef0776fcf4fc4d4", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -156,6 +156,8 @@ impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n \n pub const ALLOC_DISCRIMINANT: usize = 0;\n pub const FN_DISCRIMINANT: usize = 1;\n+pub const EXTERN_STATIC_DISCRIMINANT: usize = 2;\n+pub const SHORTHAND_START: usize = 3;\n \n pub fn specialized_encode_alloc_id<\n     'a, 'tcx,\n@@ -173,13 +175,18 @@ pub fn specialized_encode_alloc_id<\n         trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n         ALLOC_DISCRIMINANT.encode(encoder)?;\n         alloc.encode(encoder)?;\n+        // encode whether this allocation is the root allocation of a static\n         tcx.interpret_interner\n             .get_corresponding_static_def_id(alloc_id)\n             .encode(encoder)?;\n     } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n         trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n         FN_DISCRIMINANT.encode(encoder)?;\n         fn_instance.encode(encoder)?;\n+    } else if let Some(did) = tcx.interpret_interner.get_corresponding_static_def_id(alloc_id) {\n+        // extern \"C\" statics don't have allocations, just encode its def_id\n+        EXTERN_STATIC_DISCRIMINANT.encode(encoder)?;\n+        did.encode(encoder)?;\n     } else {\n         bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n     }\n@@ -225,6 +232,13 @@ pub fn specialized_decode_alloc_id<\n             cache(decoder, pos, id);\n             Ok(id)\n         },\n+        EXTERN_STATIC_DISCRIMINANT => {\n+            trace!(\"creating extern static alloc id at {}\", pos);\n+            let did = DefId::decode(decoder)?;\n+            let alloc_id = tcx.interpret_interner.reserve();\n+            tcx.interpret_interner.cache(did, alloc_id);\n+            Ok(alloc_id)\n+        },\n         shorthand => {\n             trace!(\"loading shorthand {}\", shorthand);\n             short(decoder, shorthand)"}, {"sha": "9ed4e6a8e00ae5e3c7bc325362c6c9288fe1eedc", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -27,7 +27,7 @@ use hir::def_id::DefId;\n use mir::visit::MirVisitable;\n use mir::interpret::{Value, PrimVal};\n use ty::subst::{Subst, Substs};\n-use ty::{self, AdtDef, ClosureSubsts, Region, Ty, TyCtxt, GeneratorInterior};\n+use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, Region, Ty, TyCtxt, GeneratorInterior};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::TypeAndMut;\n use util::ppaux;\n@@ -1253,6 +1253,23 @@ pub enum StatementKind<'tcx> {\n     /// (The starting point(s) arise implicitly from borrows.)\n     EndRegion(region::Scope),\n \n+    /// Encodes a user's type assertion. These need to be preserved intact so that NLL can respect\n+    /// them. For example:\n+    ///\n+    ///     let (a, b): (T, U) = y;\n+    ///\n+    /// Here we would insert a `UserAssertTy<(T, U)>(y)` instruction to check that the type of `y`\n+    /// is the right thing.\n+    ///\n+    /// `CanonicalTy` is used to capture \"inference variables\" from the user's types. For example:\n+    ///\n+    ///     let x: Vec<_> = ...;\n+    ///     let y: &u32 = ...;\n+    ///\n+    /// would result in `Vec<?0>` and `&'?0 u32` respectively (where `?0` is a canonicalized\n+    /// variable).\n+    UserAssertTy(CanonicalTy<'tcx>, Local),\n+\n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n }\n@@ -1324,6 +1341,8 @@ impl<'tcx> Debug for Statement<'tcx> {\n             InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n             },\n+            UserAssertTy(ref c_ty, ref local) => write!(fmt, \"UserAssertTy({:?}, {:?})\",\n+                                                        c_ty, local),\n             Nop => write!(fmt, \"nop\"),\n         }\n     }\n@@ -2184,6 +2203,7 @@ EnumTypeFoldableImpl! {\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n         (StatementKind::Validate)(a, b),\n         (StatementKind::EndRegion)(a),\n+        (StatementKind::UserAssertTy)(a, b),\n         (StatementKind::Nop),\n     }\n }"}, {"sha": "666ca5eabe81b93485f5ba5cf3718ceaef1b43e1", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -77,8 +77,18 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n \n         None\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // All the blocks, minus the number of blocks we've visited.\n+        let remaining = self.mir.basic_blocks().len() - self.visited.count();\n+\n+        // We will visit all remaining blocks exactly once.\n+        (remaining, Some(remaining))\n+    }\n }\n \n+impl<'a, 'tcx> ExactSizeIterator for Preorder<'a, 'tcx> {}\n+\n /// Postorder traversal of a graph.\n ///\n /// Postorder traversal is when each node is visited after all of it's\n@@ -210,8 +220,18 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n \n         next.map(|(bb, _)| (bb, &self.mir[bb]))\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // All the blocks, minus the number of blocks we've visited.\n+        let remaining = self.mir.basic_blocks().len() - self.visited.count();\n+\n+        // We will visit all remaining blocks exactly once.\n+        (remaining, Some(remaining))\n+    }\n }\n \n+impl<'a, 'tcx> ExactSizeIterator for Postorder<'a, 'tcx> {}\n+\n /// Reverse postorder traversal of a graph\n ///\n /// Reverse postorder is the reverse order of a postorder traversal.\n@@ -276,4 +296,10 @@ impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n \n         self.blocks.get(self.idx).map(|&bb| (bb, &self.mir[bb]))\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.idx, Some(self.idx))\n+    }\n }\n+\n+impl<'a, 'tcx> ExactSizeIterator for ReversePostorder<'a, 'tcx> {}"}, {"sha": "a3fdb6f73abb0e97f13c49244a33f39fa16ff7d3", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use ty::subst::Substs;\n-use ty::{ClosureSubsts, Region, Ty, GeneratorInterior};\n+use ty::{CanonicalTy, ClosureSubsts, Region, Ty, GeneratorInterior};\n use mir::*;\n use syntax_pos::Span;\n \n@@ -144,6 +144,13 @@ macro_rules! make_mir_visitor {\n                 self.super_operand(operand, location);\n             }\n \n+            fn visit_user_assert_ty(&mut self,\n+                                    c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                    local: & $($mutability)* Local,\n+                                    location: Location) {\n+                self.super_user_assert_ty(c_ty, local, location);\n+            }\n+\n             fn visit_place(&mut self,\n                             place: & $($mutability)* Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n@@ -376,6 +383,10 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(input, location);\n                         }\n                     }\n+                    StatementKind::UserAssertTy(ref $($mutability)* c_ty,\n+                                                ref $($mutability)* local) => {\n+                        self.visit_user_assert_ty(c_ty, local, location);\n+                    }\n                     StatementKind::Nop => {}\n                 }\n             }\n@@ -619,6 +630,13 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n+            fn super_user_assert_ty(&mut self,\n+                                    _c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                    local: & $($mutability)* Local,\n+                                    location: Location) {\n+                self.visit_local(local, PlaceContext::Validate, location);\n+            }\n+\n             fn super_place(&mut self,\n                             place: & $($mutability)* Place<'tcx>,\n                             context: PlaceContext<'tcx>,"}, {"sha": "59d1a298eaa69ae6fab6d2bd1e173d227724186a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -21,14 +21,14 @@ use session::search_paths::SearchPaths;\n \n use ich::StableHashingContext;\n use rustc_back::{LinkerFlavor, PanicStrategy, RelroLevel};\n-use rustc_back::target::Target;\n+use rustc_back::target::{Target, TargetTriple};\n use rustc_data_structures::stable_hasher::ToStableHashKey;\n use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n use syntax::codemap::{FileName, FilePathMapping};\n-use syntax::epoch::Epoch;\n+use syntax::edition::Edition;\n use syntax::parse::token;\n use syntax::parse;\n use syntax::symbol::Symbol;\n@@ -47,7 +47,7 @@ use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n use std::collections::HashSet;\n use std::iter::FromIterator;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n pub struct Config {\n     pub target: Target,\n@@ -367,7 +367,7 @@ top_level_options!(\n         libs: Vec<(String, Option<String>, Option<cstore::NativeLibraryKind>)> [TRACKED],\n         maybe_sysroot: Option<PathBuf> [TRACKED],\n \n-        target_triple: String [TRACKED],\n+        target_triple: TargetTriple [TRACKED],\n \n         test: bool [TRACKED],\n         error_format: ErrorOutputType [UNTRACKED],\n@@ -567,7 +567,7 @@ pub fn basic_options() -> Options {\n         output_types: OutputTypes(BTreeMap::new()),\n         search_paths: SearchPaths::new(),\n         maybe_sysroot: None,\n-        target_triple: host_triple().to_string(),\n+        target_triple: TargetTriple::from_triple(host_triple()),\n         test: false,\n         incremental: None,\n         debugging_opts: basic_debugging_options(),\n@@ -771,7 +771,7 @@ macro_rules! options {\n             Some(\"`string` or `string=string`\");\n         pub const parse_lto: Option<&'static str> =\n             Some(\"one of `thin`, `fat`, or omitted\");\n-        pub const parse_epoch: Option<&'static str> =\n+        pub const parse_edition: Option<&'static str> =\n             Some(\"one of: `2015`, `2018`\");\n     }\n \n@@ -780,7 +780,7 @@ macro_rules! options {\n         use super::{$struct_name, Passes, SomePasses, AllPasses, Sanitizer, Lto};\n         use rustc_back::{LinkerFlavor, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n-        use syntax::epoch::Epoch;\n+        use syntax::edition::Edition;\n \n         $(\n             pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n@@ -983,11 +983,11 @@ macro_rules! options {\n             true\n         }\n \n-        fn parse_epoch(slot: &mut Epoch, v: Option<&str>) -> bool {\n+        fn parse_edition(slot: &mut Edition, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => {\n-                    let epoch = s.parse();\n-                    if let Ok(parsed) = epoch {\n+                    let edition = s.parse();\n+                    if let Ok(parsed) = edition {\n                         *slot = parsed;\n                         true\n                     } else {\n@@ -1208,6 +1208,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"set the MIR optimization level (0-3, default: 1)\"),\n     mutable_noalias: bool = (false, parse_bool, [UNTRACKED],\n           \"emit noalias metadata for mutable references\"),\n+    arg_align_attributes: bool = (false, parse_bool, [UNTRACKED],\n+          \"emit align metadata for reference arguments\"),\n     dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: String = (String::from(\"mir_dump\"), parse_string, [UNTRACKED],\n@@ -1247,10 +1249,20 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"extra arguments to prepend to the linker invocation (space separated)\"),\n     profile: bool = (false, parse_bool, [TRACKED],\n                      \"insert profiling code\"),\n+    pgo_gen: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"Generate PGO profile data, to a given file, or to the default \\\n+         location if it's empty.\"),\n+    pgo_use: String = (String::new(), parse_string, [TRACKED],\n+        \"Use PGO profile data from the given profile file.\"),\n+    disable_instrumentation_preinliner: bool =\n+        (false, parse_bool, [TRACKED], \"Disable the instrumentation pre-inliner, \\\n+        useful for profiling / PGO.\"),\n     relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n         \"choose which RELRO level to use\"),\n     nll: bool = (false, parse_bool, [UNTRACKED],\n                  \"run the non-lexical lifetimes MIR pass\"),\n+    disable_nll_user_type_assert: bool = (false, parse_bool, [UNTRACKED],\n+        \"disable user provided type assertion in NLL\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in trans and LLVM\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n@@ -1280,16 +1292,18 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         `everybody_loops` (all function bodies replaced with `loop {}`),\n         `hir` (the HIR), `hir,identified`, or\n         `hir,typed` (HIR with types for each node).\"),\n-    epoch: Epoch = (Epoch::Epoch2015, parse_epoch, [TRACKED],\n-        \"The epoch to build Rust with. Newer epochs may include features\n-         that require breaking changes. The default epoch is 2015 (the first\n-         epoch). Crates compiled with different epochs can be linked together.\"),\n+    edition: Edition = (Edition::Edition2015, parse_edition, [TRACKED],\n+        \"The edition to build Rust with. Newer editions may include features\n+         that require breaking changes. The default edition is 2015 (the first\n+         edition). Crates compiled with different editions can be linked together.\"),\n     run_dsymutil: Option<bool> = (None, parse_opt_bool, [TRACKED],\n           \"run `dsymutil` and delete intermediate object files\"),\n     ui_testing: bool = (false, parse_bool, [UNTRACKED],\n           \"format compiler diagnostics in a way that's better suitable for UI testing\"),\n     embed_bitcode: bool = (false, parse_bool, [TRACKED],\n           \"embed LLVM bitcode in object files\"),\n+    strip_debuginfo_if_disabled: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"tell the linker to strip debuginfo when building without debuginfo enabled.\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1767,6 +1781,13 @@ pub fn build_session_options_and_crate_config(\n         );\n     }\n \n+    if debugging_opts.pgo_gen.is_some() && !debugging_opts.pgo_use.is_empty() {\n+        early_error(\n+            error_format,\n+            \"options `-Z pgo-gen` and `-Z pgo-use` are exclusive\",\n+        );\n+    }\n+\n     let mut output_types = BTreeMap::new();\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n@@ -1901,9 +1922,21 @@ pub fn build_session_options_and_crate_config(\n     let cg = cg;\n \n     let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));\n-    let target = matches\n-        .opt_str(\"target\")\n-        .unwrap_or(host_triple().to_string());\n+    let target_triple = if let Some(target) = matches.opt_str(\"target\") {\n+        if target.ends_with(\".json\") {\n+            let path = Path::new(&target);\n+            match TargetTriple::from_path(&path) {\n+                Ok(triple) => triple,\n+                Err(_) => {\n+                    early_error(error_format, &format!(\"target file {:?} does not exist\", path))\n+                }\n+            }\n+        } else {\n+            TargetTriple::TargetTriple(target)\n+        }\n+    } else {\n+        TargetTriple::from_triple(host_triple())\n+    };\n     let opt_level = {\n         if matches.opt_present(\"O\") {\n             if cg.opt_level.is_some() {\n@@ -2111,7 +2144,7 @@ pub fn build_session_options_and_crate_config(\n             output_types: OutputTypes(output_types),\n             search_paths,\n             maybe_sysroot: sysroot_opt,\n-            target_triple: target,\n+            target_triple,\n             test,\n             incremental,\n             debugging_opts,\n@@ -2258,10 +2291,11 @@ mod dep_tracking {\n     use std::hash::Hash;\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n-    use super::{CrateType, DebugInfoLevel, Epoch, ErrorOutputType, Lto, OptLevel, OutputTypes,\n+    use super::{CrateType, DebugInfoLevel, Edition, ErrorOutputType, Lto, OptLevel, OutputTypes,\n                 Passes, Sanitizer};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_back::{PanicStrategy, RelroLevel};\n+    use rustc_back::target::TargetTriple;\n \n     pub trait DepTrackingHash {\n         fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType);\n@@ -2320,7 +2354,8 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(cstore::NativeLibraryKind);\n     impl_dep_tracking_hash_via_hash!(Sanitizer);\n     impl_dep_tracking_hash_via_hash!(Option<Sanitizer>);\n-    impl_dep_tracking_hash_via_hash!(Epoch);\n+    impl_dep_tracking_hash_via_hash!(Edition);\n+    impl_dep_tracking_hash_via_hash!(TargetTriple);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n@@ -2880,6 +2915,14 @@ mod tests {\n         opts.debugging_opts.tls_model = Some(String::from(\"tls model\"));\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n+        opts = reference.clone();\n+        opts.debugging_opts.pgo_gen = Some(String::from(\"abc\"));\n+        assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.pgo_use = String::from(\"abc\");\n+        assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n         opts = reference.clone();\n         opts.cg.metadata = vec![String::from(\"A\"), String::from(\"B\")];\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "77cf50a8341edbaf0805c07ccb814a5568d596fa", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -31,7 +31,7 @@ use rustc_data_structures::sync::{Lrc, Lock};\n use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder, DiagnosticId};\n use errors::emitter::{Emitter, EmitterWriter};\n-use syntax::epoch::Epoch;\n+use syntax::edition::Edition;\n use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::symbol::Symbol;\n@@ -42,7 +42,7 @@ use syntax::feature_gate::AttributeType;\n use syntax_pos::{MultiSpan, Span};\n \n use rustc_back::{LinkerFlavor, PanicStrategy};\n-use rustc_back::target::Target;\n+use rustc_back::target::{Target, TargetTriple};\n use rustc_data_structures::flock;\n use jobserver::Client;\n \n@@ -707,7 +707,7 @@ impl Session {\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n         filesearch::FileSearch::new(\n             self.sysroot(),\n-            &self.opts.target_triple,\n+            self.opts.target_triple.triple(),\n             &self.opts.search_paths,\n             kind,\n         )\n@@ -976,13 +976,13 @@ impl Session {\n         self.opts.debugging_opts.teach && !self.parse_sess.span_diagnostic.code_emitted(code)\n     }\n \n-    /// Are we allowed to use features from the Rust 2018 epoch?\n+    /// Are we allowed to use features from the Rust 2018 edition?\n     pub fn rust_2018(&self) -> bool {\n-        self.opts.debugging_opts.epoch >= Epoch::Epoch2018\n+        self.opts.debugging_opts.edition >= Edition::Edition2018\n     }\n \n-    pub fn epoch(&self) -> Epoch {\n-        self.opts.debugging_opts.epoch\n+    pub fn edition(&self) -> Edition {\n+        self.opts.debugging_opts.edition\n     }\n }\n \n@@ -1085,7 +1085,8 @@ pub fn build_session_(\n     span_diagnostic: errors::Handler,\n     codemap: Lrc<codemap::CodeMap>,\n ) -> Session {\n-    let host = match Target::search(config::host_triple()) {\n+    let host_triple = TargetTriple::from_triple(config::host_triple());\n+    let host = match Target::search(&host_triple) {\n         Ok(t) => t,\n         Err(e) => {\n             span_diagnostic"}, {"sha": "d2dca9f60845a42ee91d7c2d1e47b344633a786a", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -78,4 +78,11 @@ impl<'a> Iterator for Iter<'a> {\n             }\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // This iterator will never return more elements than the base iterator;\n+        // but it can ignore all the remaining elements.\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper)\n+    }\n }"}, {"sha": "31f8af1f96872a94189d9e9e0ef32da0e801d285", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -92,9 +92,7 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n                                        -> ty::ImplHeader<'tcx>\n {\n     let tcx = selcx.tcx();\n-    let impl_substs = selcx.infcx().fresh_substs_for_item(param_env.universe,\n-                                                          DUMMY_SP,\n-                                                          impl_def_id);\n+    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n     let header = ty::ImplHeader {\n         impl_def_id,"}, {"sha": "8eee6f35ab9565680c6de5376fe7584d1fc7a607", "filename": "src/librustc/traits/engine.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use ty::{self, Ty, TyCtxt};\n+use hir::def_id::DefId;\n+\n+use super::{FulfillmentContext, FulfillmentError};\n+use super::{ObligationCause, PendingPredicateObligation, PredicateObligation};\n+\n+pub trait TraitEngine<'tcx>: 'tcx {\n+    fn normalize_projection_type<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx>;\n+\n+    fn register_bound<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        cause: ObligationCause<'tcx>,\n+    );\n+\n+    fn register_predicate_obligation<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    );\n+\n+    fn select_all_or_error<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn select_where_possible<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>>;\n+}\n+\n+impl<'a, 'gcx, 'tcx> dyn TraitEngine<'tcx> {\n+    pub fn new(_tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+        Box::new(FulfillmentContext::new())\n+    }\n+\n+    pub fn register_predicate_obligations<I>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        obligations: I,\n+    ) where\n+        I: IntoIterator<Item = PredicateObligation<'tcx>>,\n+    {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+}"}, {"sha": "d2bde14732bbcdab4eca9a21ea495311826b497d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -292,9 +292,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.for_each_relevant_impl(\n             trait_ref.def_id, trait_self_ty, |def_id| {\n-                let impl_substs = self.fresh_substs_for_item(param_env.universe,\n-                                                             obligation.cause.span,\n-                                                             def_id);\n+                let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()\n@@ -443,10 +441,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             4\n         };\n+\n+        let normalize = |candidate| self.tcx.global_tcx().infer_ctxt().enter(|ref infcx| {\n+            let normalized = infcx\n+                .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                .normalize(candidate)\n+                .ok();\n+            match normalized {\n+                Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n+                None => format!(\"\\n  {:?}\", candidate),\n+            }\n+        });\n+\n         err.help(&format!(\"the following implementations were found:{}{}\",\n-                          &impl_candidates[0..end].iter().map(|candidate| {\n-                              format!(\"\\n  {:?}\", candidate)\n-                          }).collect::<String>(),\n+                          &impl_candidates[0..end].iter().map(normalize).collect::<String>(),\n                           if impl_candidates.len() > 5 {\n                               format!(\"\\nand {} others\", impl_candidates.len() - 4)\n                           } else {\n@@ -585,20 +593,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                          trait_ref.to_predicate(), post_message)\n                             }));\n \n+                        let explanation =\n+                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n+                                \"consider using `()`, or a `Result`\".to_owned()\n+                            } else {\n+                                format!(\"{}the trait `{}` is not implemented for `{}`\",\n+                                        pre_message,\n+                                        trait_ref,\n+                                        trait_ref.self_ty())\n+                            };\n+\n                         if let Some(ref s) = label {\n                             // If it has a custom \"#[rustc_on_unimplemented]\"\n                             // error message, let's display it as the label!\n                             err.span_label(span, s.as_str());\n-                            err.help(&format!(\"{}the trait `{}` is not implemented for `{}`\",\n-                                              pre_message,\n-                                              trait_ref,\n-                                              trait_ref.self_ty()));\n+                            err.help(&explanation);\n                         } else {\n-                            err.span_label(span,\n-                                           &*format!(\"{}the trait `{}` is not implemented for `{}`\",\n-                                                     pre_message,\n-                                                     trait_ref,\n-                                                     trait_ref.self_ty()));\n+                            err.span_label(span, explanation);\n                         }\n                         if let Some(ref s) = note {\n                             // If it has a custom \"#[rustc_on_unimplemented]\" note, let's display it\n@@ -1272,7 +1283,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                            -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-            param_env: ty::ParamEnv<'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n@@ -1282,14 +1292,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n-                    let param_env = self.param_env;\n-                    self.var_map\n-                        .entry(ty)\n-                        .or_insert_with(|| {\n-                            let origin = TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP,\n-                                                                                     name);\n-                            infcx.next_ty_var(param_env.universe, origin)\n-                        })\n+                    self.var_map.entry(ty).or_insert_with(||\n+                        infcx.next_ty_var(\n+                            TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP, name)))\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -1301,7 +1306,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n                 infcx: self,\n-                param_env,\n                 var_map: FxHashMap()\n             });\n "}, {"sha": "1c091d68a2ef1474271ff7cb64f858a560c05b67", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -21,6 +21,7 @@ use middle::const_val::{ConstEvalErr, ErrKind};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n+use super::engine::TraitEngine;\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n@@ -85,19 +86,72 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n+    pub fn register_predicate_obligations<I>(&mut self,\n+                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             obligations: I)\n+        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n+    {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+\n+    /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n+    /// only attempts to select obligations that haven't been seen before.\n+    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n+              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n+        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n+\n+        let mut errors = Vec::new();\n+\n+        loop {\n+            debug!(\"select: starting another iteration\");\n+\n+            // Process pending obligations.\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n+                selcx,\n+                register_region_obligations: self.register_region_obligations\n+            });\n+            debug!(\"select: outcome={:?}\", outcome);\n+\n+            // FIXME: if we kept the original cache key, we could mark projection\n+            // obligations as complete for the projection cache here.\n+\n+            errors.extend(\n+                outcome.errors.into_iter()\n+                              .map(|e| to_fulfillment_error(e)));\n+\n+            // If nothing new was added, no need to keep looping.\n+            if outcome.stalled {\n+                break;\n+            }\n+        }\n+\n+        debug!(\"select({} predicates remaining, {} errors) done\",\n+               self.predicates.len(), errors.len());\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+}\n+\n+impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// \"Normalize\" a projection type `<SomeType as SomeTrait>::X` by\n     /// creating a fresh type variable `$0` as well as a projection\n     /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n     /// inference engine runs, it will attempt to find an impl of\n     /// `SomeTrait` or a where clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n-    pub fn normalize_projection_type(&mut self,\n-                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                     param_env: ty::ParamEnv<'tcx>,\n-                                     projection_ty: ty::ProjectionTy<'tcx>,\n-                                     cause: ObligationCause<'tcx>)\n-                                     -> Ty<'tcx>\n+    fn normalize_projection_type<'a, 'gcx>(&mut self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                 param_env: ty::ParamEnv<'tcx>,\n+                                 projection_ty: ty::ProjectionTy<'tcx>,\n+                                 cause: ObligationCause<'tcx>)\n+                                 -> Ty<'tcx>\n     {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n@@ -125,12 +179,12 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Requires that `ty` must implement the trait with `def_id` in\n     /// the given environment. This trait must not have any type\n     /// parameters (except for `Self`).\n-    pub fn register_bound(&mut self,\n-                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: Ty<'tcx>,\n-                          def_id: DefId,\n-                          cause: ObligationCause<'tcx>)\n+    fn register_bound<'a, 'gcx>(&mut self,\n+                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      ty: Ty<'tcx>,\n+                      def_id: DefId,\n+                      cause: ObligationCause<'tcx>)\n     {\n         let trait_ref = ty::TraitRef {\n             def_id,\n@@ -144,9 +198,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligation(&mut self,\n-                                         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                         obligation: PredicateObligation<'tcx>)\n+    fn register_predicate_obligation<'a, 'gcx>(&mut self,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                     obligation: PredicateObligation<'tcx>)\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n@@ -162,19 +216,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligations<I>(&mut self,\n-                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             obligations: I)\n-        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n-    {\n-        for obligation in obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-    }\n-\n-    pub fn select_all_or_error(&mut self,\n-                               infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                               -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_all_or_error<'a, 'gcx>(&mut self,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n \n@@ -190,58 +234,17 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_where_possible(&mut self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                                 -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_where_possible<'a, 'gcx>(&mut self,\n+                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                             -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n     }\n \n-    pub fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n+    fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n         self.predicates.pending_obligations()\n     }\n-\n-    /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n-    /// only attempts to select obligations that haven't been seen before.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n-              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n-        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n-\n-        let mut errors = Vec::new();\n-\n-        loop {\n-            debug!(\"select: starting another iteration\");\n-\n-            // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n-                selcx,\n-                register_region_obligations: self.register_region_obligations\n-            });\n-            debug!(\"select: outcome={:?}\", outcome);\n-\n-            // FIXME: if we kept the original cache key, we could mark projection\n-            // obligations as complete for the projection cache here.\n-\n-            errors.extend(\n-                outcome.errors.into_iter()\n-                              .map(|e| to_fulfillment_error(e)));\n-\n-            // If nothing new was added, no need to keep looping.\n-            if outcome.stalled {\n-                break;\n-            }\n-        }\n-\n-        debug!(\"select({} predicates remaining, {} errors) done\",\n-               self.predicates.len(), errors.len());\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(errors)\n-        }\n-    }\n }\n \n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {"}, {"sha": "2ce1b75e3151fa5e3d86b4393d2e6cdee6fe4202", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -34,7 +34,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n-pub use self::fulfill::FulfillmentContext;\n+pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal, Normalized};\n@@ -45,6 +45,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::IntercrateAmbiguityCause;\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n+pub use self::engine::TraitEngine;\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n@@ -54,6 +55,7 @@ pub use self::util::transitive_bounds;\n \n mod coherence;\n pub mod error_reporting;\n+mod engine;\n mod fulfill;\n mod project;\n mod object_safety;\n@@ -610,8 +612,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            predicates);\n \n     let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                           unnormalized_env.reveal,\n-                                           unnormalized_env.universe);\n+                                           unnormalized_env.reveal);\n \n     tcx.infer_ctxt().enter(|infcx| {\n         // FIXME. We should really... do something with these region\n@@ -685,9 +686,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n                predicates);\n \n-        ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                          unnormalized_env.reveal,\n-                          unnormalized_env.universe)\n+        ty::ParamEnv::new(tcx.intern_predicates(&predicates), unnormalized_env.reveal)\n     })\n }\n "}, {"sha": "2a62d0b5ee39a282db94d4fd89611ce153e45d4e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -477,7 +477,6 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             let tcx = selcx.infcx().tcx;\n             let def_id = projection_ty.item_def_id;\n             let ty_var = selcx.infcx().next_ty_var(\n-                param_env.universe,\n                 TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n                 projection_ty,\n@@ -798,7 +797,6 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let tcx = selcx.infcx().tcx;\n     let def_id = projection_ty.item_def_id;\n     let new_value = selcx.infcx().next_ty_var(\n-        param_env.universe,\n         TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n         value: new_value,"}, {"sha": "af1d2c77c28a867bf40460843ebb964cffef6772", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -15,7 +15,7 @@ use std::iter::FromIterator;\n use traits::query::CanonicalTyGoal;\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Kind;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -183,13 +183,13 @@ impl_stable_hash_for!(struct DropckOutlivesResult<'tcx> {\n \n impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for QueryResult<'tcx, DropckOutlivesResult<'tcx>> {\n     // we ought to intern this, but I'm too lazy just now\n-    type Canonicalized = Rc<Canonical<'gcx, QueryResult<'gcx, DropckOutlivesResult<'gcx>>>>;\n+    type Canonicalized = Lrc<Canonical<'gcx, QueryResult<'gcx, DropckOutlivesResult<'gcx>>>>;\n \n     fn intern(\n         _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n         value: Canonical<'gcx, Self::Lifted>,\n     ) -> Self::Canonicalized {\n-        Rc::new(value)\n+        Lrc::new(value)\n     }\n }\n "}, {"sha": "63f50cff4c2ad2c01a37626d52bfe00d9a5e8b25", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -17,7 +17,7 @@ use infer::at::At;\n use infer::canonical::{Canonical, Canonicalize, QueryResult};\n use middle::const_val::ConstVal;\n use mir::interpret::GlobalId;\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use traits::query::CanonicalProjectionGoal;\n use traits::project::Normalized;\n@@ -259,13 +259,13 @@ impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, ty::Pr\n \n impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for QueryResult<'tcx, NormalizationResult<'tcx>> {\n     // we ought to intern this, but I'm too lazy just now\n-    type Canonicalized = Rc<Canonical<'gcx, QueryResult<'gcx, NormalizationResult<'gcx>>>>;\n+    type Canonicalized = Lrc<Canonical<'gcx, QueryResult<'gcx, NormalizationResult<'gcx>>>>;\n \n     fn intern(\n         _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n         value: Canonical<'gcx, Self::Lifted>,\n     ) -> Self::Canonicalized {\n-        Rc::new(value)\n+        Lrc::new(value)\n     }\n }\n "}, {"sha": "b1649686323f8750e09e47f33be76fdf28a7f839", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -362,7 +362,9 @@ enum EvaluationResult {\n     /// When checking `foo`, we have to prove `T: Trait`. This basically\n     /// translates into this:\n     ///\n+    /// ```plain,ignore\n     ///     (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n+    /// ```\n     ///\n     /// When we try to prove it, we first go the first option, which\n     /// recurses. This shows us that the impl is \"useless\" - it won't\n@@ -2061,11 +2063,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match self_ty.sty {\n             ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyError => {\n+                Where(ty::Binder(Vec::new()))\n+            }\n+\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n-            ty::TyRawPtr(..) | ty::TyError | ty::TyNever |\n+            ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                Where(ty::Binder(Vec::new()))\n+                // Implementations provided in libcore\n+                None\n             }\n \n             ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n@@ -2086,14 +2092,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::TyClosure(def_id, substs) => {\n                 let trait_id = obligation.predicate.def_id();\n-                let copy_closures =\n-                    Some(trait_id) == self.tcx().lang_items().copy_trait() &&\n-                    self.tcx().has_copy_closures(def_id.krate);\n-                let clone_closures =\n-                    Some(trait_id) == self.tcx().lang_items().clone_trait() &&\n-                    self.tcx().has_clone_closures(def_id.krate);\n-\n-                if copy_closures || clone_closures {\n+                let is_copy_trait = Some(trait_id) == self.tcx().lang_items().copy_trait();\n+                let is_clone_trait = Some(trait_id) == self.tcx().lang_items().clone_trait();\n+                if is_copy_trait || is_clone_trait {\n                     Where(ty::Binder(substs.upvar_tys(def_id, self.tcx()).collect()))\n                 } else {\n                     Never\n@@ -3045,8 +3046,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             snapshot);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n-        let impl_substs = self.infcx.fresh_substs_for_item(obligation.param_env.universe,\n-                                                           obligation.cause.span,\n+        let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,\n                                                            impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),"}, {"sha": "30b2c55afa1948c5c9f24277655d78d5d15fae8e", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -26,7 +26,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use ty::subst::{Subst, Substs};\n-use traits::{self, ObligationCause};\n+use traits::{self, ObligationCause, TraitEngine};\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n@@ -221,7 +221,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n-    let target_substs = infcx.fresh_substs_for_item(param_env.universe, DUMMY_SP, target_impl);\n+    let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                        param_env,\n                                                                        target_impl,"}, {"sha": "e56a8662f3eb4346747c3ae36e083d49422c6a8d", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -19,6 +19,7 @@ use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Name;\n+use util::captures::Captures;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n@@ -313,9 +314,10 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                 -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+    pub fn items(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n         tcx.associated_items(self.def_id())\n     }\n \n@@ -367,9 +369,13 @@ impl<'a, 'gcx, 'tcx> Ancestors {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-    pub fn defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, trait_item_name: Name,\n-                trait_item_kind: ty::AssociatedKind, trait_def_id: DefId)\n-                -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + 'a {\n+    pub fn defs(\n+        self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        trait_item_name: Name,\n+        trait_item_kind: ty::AssociatedKind,\n+        trait_def_id: DefId,\n+    ) -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + Captures<'gcx> + Captures<'tcx> + 'a {\n         self.flat_map(move |node| {\n             node.items(tcx).filter(move |impl_item| {\n                 impl_item.kind == trait_item_kind &&"}, {"sha": "31e851126d76ad495b8abf0d2513357d890c6ef4", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -18,7 +18,8 @@ use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n use infer::InferCtxt;\n use syntax_pos::Span;\n-use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n+use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n+             TraitEngine, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n use ty::fold::TypeFoldable;"}, {"sha": "9e38911f53c9a0ec179cb93f5428725b1e771349", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -347,6 +347,11 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n             }\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.base_iterator.size_hint();\n+        (0, upper)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "a0c31e8b509239230c7b909d180bf3f86f9f224a", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -119,9 +119,27 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n     }\n }\n \n+/// At least for initial deployment, we want to limit two-phase borrows to\n+/// only a few specific cases. Right now, those mostly \"things that desugar\"\n+/// into method calls\n+///     - using x.some_method() syntax, where some_method takes &mut self\n+///     - using Foo::some_method(&mut x, ...) syntax\n+///     - binary assignment operators (+=, -=, *=, etc.)\n+/// Anything else should be rejected until generalized two phase borrow support\n+/// is implemented. Right now, dataflow can't handle the general case where there\n+/// is more than one use of a mutable borrow, and we don't want to accept too much\n+/// new code via two-phase borrows, so we try to limit where we create two-phase\n+/// capable mutable borrows.\n+/// See #49434 for tracking.\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AllowTwoPhase {\n+    Yes,\n+    No\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrowMutability {\n-    Mutable { allow_two_phase_borrow: bool },\n+    Mutable { allow_two_phase_borrow: AllowTwoPhase },\n     Immutable,\n }\n "}, {"sha": "4e15f0711a5aa2a6b88bc71cde1635b801215117", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -17,6 +17,7 @@\n // persisting to incr. comp. caches.\n \n use hir::def_id::{DefId, CrateNum};\n+use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::{Decodable, Decoder, Encoder, Encodable, opaque};\n use std::hash::Hash;\n@@ -239,6 +240,19 @@ pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n               .mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n+#[inline]\n+pub fn decode_canonical_var_infos<'a, 'tcx, D>(decoder: &mut D)\n+    -> Result<CanonicalVarInfos<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let len = decoder.read_usize()?;\n+    let interned: Result<Vec<CanonicalVarInfo>, _> = (0..len).map(|_| Decodable::decode(decoder))\n+                                                             .collect();\n+    Ok(decoder.tcx()\n+              .intern_canonical_var_infos(interned?.as_slice()))\n+}\n+\n #[inline]\n pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n                                  -> Result<&'tcx ty::Const<'tcx>, D::Error>\n@@ -262,6 +276,7 @@ macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n             use super::$DecoderName;\n+            use $crate::infer::canonical::CanonicalVarInfos;\n             use $crate::ty;\n             use $crate::ty::codec::*;\n             use $crate::ty::subst::Substs;\n@@ -364,6 +379,14 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n+            impl<$($typaram),*> SpecializedDecoder<CanonicalVarInfos<'tcx>>\n+                for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self)\n+                    -> Result<CanonicalVarInfos<'tcx>, Self::Error> {\n+                    decode_canonical_var_infos(self)\n+                }\n+            }\n+\n             impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::Const<'tcx>>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {"}, {"sha": "3326af21bd6049e2d9577b9645cfa6aafd46106c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 236, "deletions": 70, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -48,6 +48,7 @@ use ty::layout::{LayoutDetails, TargetDataLayout};\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n+use ty::CanonicalTy;\n use util::nodemap::{NodeMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -161,12 +162,12 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n                  -> Ty<'tcx> {\n         let ty = {\n             let mut interner = self.type_.borrow_mut();\n-            let global_interner = global_interners.map(|interners| {\n-                interners.type_.borrow_mut()\n-            });\n             if let Some(&Interned(ty)) = interner.get(&st) {\n                 return ty;\n             }\n+            let global_interner = global_interners.map(|interners| {\n+                interners.type_.borrow_mut()\n+            });\n             if let Some(ref interner) = global_interner {\n                 if let Some(&Interned(ty)) = interner.get(&st) {\n                     return ty;\n@@ -344,6 +345,10 @@ pub struct TypeckTables<'tcx> {\n     /// method calls, including those of overloaded operators.\n     type_dependent_defs: ItemLocalMap<Def>,\n \n+    /// Stores the canonicalized types provided by the user. See also `UserAssertTy` statement in\n+    /// MIR.\n+    user_provided_tys: ItemLocalMap<CanonicalTy<'tcx>>,\n+\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n@@ -420,6 +425,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         TypeckTables {\n             local_id_root,\n             type_dependent_defs: ItemLocalMap(),\n+            user_provided_tys: ItemLocalMap(),\n             node_types: ItemLocalMap(),\n             node_substs: ItemLocalMap(),\n             adjustments: ItemLocalMap(),\n@@ -461,6 +467,20 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n+    pub fn user_provided_tys(&self) -> LocalTableInContext<CanonicalTy<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.user_provided_tys\n+        }\n+    }\n+\n+    pub fn user_provided_tys_mut(&mut self) -> LocalTableInContextMut<CanonicalTy<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.user_provided_tys\n+        }\n+    }\n+\n     pub fn node_types(&self) -> LocalTableInContext<Ty<'tcx>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n@@ -685,6 +705,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n         let ty::TypeckTables {\n             local_id_root,\n             ref type_dependent_defs,\n+            ref user_provided_tys,\n             ref node_types,\n             ref node_substs,\n             ref adjustments,\n@@ -704,6 +725,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             type_dependent_defs.hash_stable(hcx, hasher);\n+            user_provided_tys.hash_stable(hcx, hasher);\n             node_types.hash_stable(hcx, hasher);\n             node_substs.hash_stable(hcx, hasher);\n             adjustments.hash_stable(hcx, hasher);\n@@ -1010,17 +1032,16 @@ impl<'tcx> InterpretInterner<'tcx> {\n     }\n }\n \n-impl<'tcx> GlobalCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Get the global TyCtxt.\n-    pub fn global_tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    #[inline]\n+    pub fn global_tcx(self) -> TyCtxt<'a, 'gcx, 'gcx> {\n         TyCtxt {\n-            gcx: self,\n-            interners: &self.global_interners\n+            gcx: self.gcx,\n+            interners: &self.gcx.global_interners,\n         }\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_generics(self, generics: ty::Generics) -> &'gcx ty::Generics {\n         self.global_arenas.generics.alloc(generics)\n     }\n@@ -1081,12 +1102,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         alloc: interpret::Allocation,\n     ) -> &'gcx interpret::Allocation {\n-        if let Some(alloc) = self.interpret_interner.inner.borrow().allocs.get(&alloc) {\n+        let allocs = &mut self.interpret_interner.inner.borrow_mut().allocs;\n+        if let Some(alloc) = allocs.get(&alloc) {\n             return alloc;\n         }\n \n         let interned = self.global_arenas.const_allocs.alloc(alloc);\n-        if let Some(prev) = self.interpret_interner.inner.borrow_mut().allocs.replace(interned) {\n+        if let Some(prev) = allocs.replace(interned) {\n             bug!(\"Tried to overwrite interned Allocation: {:#?}\", prev)\n         }\n         interned\n@@ -1113,24 +1135,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n-        if let Some(st) = self.stability_interner.borrow().get(&stab) {\n+        let mut stability_interner = self.stability_interner.borrow_mut();\n+        if let Some(st) = stability_interner.get(&stab) {\n             return st;\n         }\n \n         let interned = self.global_interners.arena.alloc(stab);\n-        if let Some(prev) = self.stability_interner.borrow_mut().replace(interned) {\n+        if let Some(prev) = stability_interner.replace(interned) {\n             bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n         }\n         interned\n     }\n \n     pub fn intern_layout(self, layout: LayoutDetails) -> &'gcx LayoutDetails {\n-        if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n+        let mut layout_interner = self.layout_interner.borrow_mut();\n+        if let Some(layout) = layout_interner.get(&layout) {\n             return layout;\n         }\n \n         let interned = self.global_arenas.layout.alloc(layout);\n-        if let Some(prev) = self.layout_interner.borrow_mut().replace(interned) {\n+        if let Some(prev) = layout_interner.replace(interned) {\n             bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n         }\n         interned\n@@ -1220,7 +1244,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                     Lrc::new(StableVec::new(v)));\n         }\n \n-        tls::enter_global(GlobalCtxt {\n+        let gcx = &GlobalCtxt {\n             sess: s,\n             cstore,\n             global_arenas: &arenas.global,\n@@ -1261,7 +1285,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             all_traits: RefCell::new(None),\n             tx_to_llvm_workers: tx,\n             output_filenames: Arc::new(output_filenames.clone()),\n-       }, f)\n+        };\n+\n+        tls::enter_global(gcx, f)\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {\n@@ -1485,11 +1511,28 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n     /// Call the closure with a local `TyCtxt` using the given arena.\n-    pub fn enter_local<F, R>(&self, arena: &'tcx DroplessArena, f: F) -> R\n-        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    pub fn enter_local<F, R>(\n+        &self,\n+        arena: &'tcx DroplessArena,\n+        f: F\n+    ) -> R\n+    where\n+        F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n         let interners = CtxtInterners::new(arena);\n-        tls::enter(self, &interners, f)\n+        let tcx = TyCtxt {\n+            gcx: self,\n+            interners: &interners,\n+        };\n+        ty::tls::with_related_context(tcx.global_tcx(), |icx| {\n+            let new_icx = ty::tls::ImplicitCtxt {\n+                tcx,\n+                query: icx.query.clone(),\n+            };\n+            ty::tls::enter_context(&new_icx, |new_icx| {\n+                f(new_icx.tcx)\n+            })\n+        })\n     }\n }\n \n@@ -1635,84 +1678,215 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Predicate<'a>> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<CanonicalVarInfo> {\n+    type Lifted = &'tcx Slice<CanonicalVarInfo>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        if self.len() == 0 {\n+            return Some(Slice::empty());\n+        }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub mod tls {\n-    use super::{CtxtInterners, GlobalCtxt, TyCtxt};\n+    use super::{GlobalCtxt, TyCtxt};\n \n     use std::cell::Cell;\n     use std::fmt;\n+    use std::mem;\n     use syntax_pos;\n+    use ty::maps;\n+    use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n+    use rustc_data_structures::OnDrop;\n+    use rustc_data_structures::sync::Lrc;\n+\n+    /// This is the implicit state of rustc. It contains the current\n+    /// TyCtxt and query. It is updated when creating a local interner or\n+    /// executing a new query. Whenever there's a TyCtxt value available\n+    /// you should also have access to an ImplicitCtxt through the functions\n+    /// in this module.\n+    #[derive(Clone)]\n+    pub struct ImplicitCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+        /// The current TyCtxt. Initially created by `enter_global` and updated\n+        /// by `enter_local` with a new local interner\n+        pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+\n+        /// The current query job, if any. This is updated by start_job in\n+        /// ty::maps::plumbing when executing a query\n+        pub query: Option<Lrc<maps::QueryJob<'gcx>>>,\n+    }\n+\n+    // A thread local value which stores a pointer to the current ImplicitCtxt\n+    thread_local!(static TLV: Cell<usize> = Cell::new(0));\n \n-    /// Marker types used for the scoped TLS slot.\n-    /// The type context cannot be used directly because the scoped TLS\n-    /// in libstd doesn't allow types generic over lifetimes.\n-    enum ThreadLocalGlobalCtxt {}\n-    enum ThreadLocalInterners {}\n+    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n+        let old = get_tlv();\n+        let _reset = OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n+        TLV.with(|tlv| tlv.set(value));\n+        f()\n+    }\n \n-    thread_local! {\n-        static TLS_TCX: Cell<Option<(*const ThreadLocalGlobalCtxt,\n-                                     *const ThreadLocalInterners)>> = Cell::new(None)\n+    fn get_tlv() -> usize {\n+        TLV.with(|tlv| tlv.get())\n     }\n \n+    /// This is a callback from libsyntax as it cannot access the implicit state\n+    /// in librustc otherwise\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter) -> fmt::Result {\n         with(|tcx| {\n             write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n         })\n     }\n \n-    pub fn enter_global<'gcx, F, R>(gcx: GlobalCtxt<'gcx>, f: F) -> R\n-        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n+    /// This is a callback from libsyntax as it cannot access the implicit state\n+    /// in librustc otherwise. It is used to when diagnostic messages are\n+    /// emitted and stores them in the current query, if there is one.\n+    fn track_diagnostic(diagnostic: &Diagnostic) {\n+        with_context(|context| {\n+            if let Some(ref query) = context.query {\n+                query.diagnostics.lock().push(diagnostic.clone());\n+            }\n+        })\n+    }\n+\n+    /// Sets up the callbacks from libsyntax on the current thread\n+    pub fn with_thread_locals<F, R>(f: F) -> R\n+        where F: FnOnce() -> R\n     {\n         syntax_pos::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n-            let result = enter(&gcx, &gcx.global_interners, f);\n-            span_dbg.set(original_span_debug);\n-            result\n+\n+            let _on_drop = OnDrop(move || {\n+                span_dbg.set(original_span_debug);\n+            });\n+\n+            TRACK_DIAGNOSTICS.with(|current| {\n+                let original = current.get();\n+                current.set(track_diagnostic);\n+\n+                let _on_drop = OnDrop(move || {\n+                    current.set(original);\n+                });\n+\n+                f()\n+            })\n         })\n     }\n \n-    pub fn enter<'a, 'gcx: 'tcx, 'tcx, F, R>(gcx: &'a GlobalCtxt<'gcx>,\n-                                             interners: &'a CtxtInterners<'tcx>,\n-                                             f: F) -> R\n-        where F: FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    /// Sets `context` as the new current ImplicitCtxt for the duration of the function `f`\n+    pub fn enter_context<'a, 'gcx: 'tcx, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'gcx, 'tcx>,\n+                                                     f: F) -> R\n+        where F: FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n-        let gcx_ptr = gcx as *const _ as *const ThreadLocalGlobalCtxt;\n-        let interners_ptr = interners as *const _ as *const ThreadLocalInterners;\n-        TLS_TCX.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some((gcx_ptr, interners_ptr)));\n-            let ret = f(TyCtxt {\n-                gcx,\n-                interners,\n-            });\n-            tls.set(prev);\n-            ret\n+        set_tlv(context as *const _ as usize, || {\n+            f(&context)\n         })\n     }\n \n-    pub fn with<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    /// Enters GlobalCtxt by setting up libsyntax callbacks and\n+    /// creating a initial TyCtxt and ImplicitCtxt.\n+    /// This happens once per rustc session and TyCtxts only exists\n+    /// inside the `f` function.\n+    pub fn enter_global<'gcx, F, R>(gcx: &GlobalCtxt<'gcx>, f: F) -> R\n+        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n     {\n-        TLS_TCX.with(|tcx| {\n-            let (gcx, interners) = tcx.get().unwrap();\n-            let gcx = unsafe { &*(gcx as *const GlobalCtxt) };\n-            let interners = unsafe { &*(interners as *const CtxtInterners) };\n-            f(TyCtxt {\n+        with_thread_locals(|| {\n+            let tcx = TyCtxt {\n                 gcx,\n-                interners,\n+                interners: &gcx.global_interners,\n+            };\n+            let icx = ImplicitCtxt {\n+                tcx,\n+                query: None,\n+            };\n+            enter_context(&icx, |_| {\n+                f(tcx)\n             })\n         })\n     }\n \n-    pub fn with_opt<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n+    /// Allows access to the current ImplicitCtxt in a closure if one is available\n+    pub fn with_context_opt<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'gcx, 'tcx>>) -> R\n     {\n-        if TLS_TCX.with(|tcx| tcx.get().is_some()) {\n-            with(|v| f(Some(v)))\n-        } else {\n+        let context = get_tlv();\n+        if context == 0 {\n             f(None)\n+        } else {\n+            unsafe { f(Some(&*(context as *const ImplicitCtxt))) }\n         }\n     }\n+\n+    /// Allows access to the current ImplicitCtxt.\n+    /// Panics if there is no ImplicitCtxt available\n+    pub fn with_context<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n+    }\n+\n+    /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n+    /// interner as the tcx argument passed in. This means the closure is given an ImplicitCtxt\n+    /// with the same 'gcx lifetime as the TyCtxt passed in.\n+    /// This will panic if you pass it a TyCtxt which has a different global interner from\n+    /// the current ImplicitCtxt's tcx field.\n+    pub fn with_related_context<'a, 'gcx, 'tcx1, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx1>, f: F) -> R\n+        where F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R\n+    {\n+        with_context(|context| {\n+            unsafe {\n+                let gcx = tcx.gcx as *const _ as usize;\n+                assert!(context.tcx.gcx as *const _ as usize == gcx);\n+                let context: &ImplicitCtxt = mem::transmute(context);\n+                f(context)\n+            }\n+        })\n+    }\n+\n+    /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n+    /// interner and local interner as the tcx argument passed in. This means the closure\n+    /// is given an ImplicitCtxt with the same 'tcx and 'gcx lifetimes as the TyCtxt passed in.\n+    /// This will panic if you pass it a TyCtxt which has a different global interner or\n+    /// a different local interner from the current ImplicitCtxt's tcx field.\n+    pub fn with_fully_related_context<'a, 'gcx, 'tcx, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx>, f: F) -> R\n+        where F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R\n+    {\n+        with_context(|context| {\n+            unsafe {\n+                let gcx = tcx.gcx as *const _ as usize;\n+                let interners = tcx.interners as *const _ as usize;\n+                assert!(context.tcx.gcx as *const _ as usize == gcx);\n+                assert!(context.tcx.interners as *const _ as usize == interners);\n+                let context: &ImplicitCtxt = mem::transmute(context);\n+                f(context)\n+            }\n+        })\n+    }\n+\n+    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n+    /// Panics if there is no ImplicitCtxt available\n+    pub fn with<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        with_context(|context| f(context.tcx))\n+    }\n+\n+    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n+    /// The closure is passed None if there is no ImplicitCtxt available\n+    pub fn with_opt<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n+    {\n+        with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n+    }\n }\n \n macro_rules! sty_debug_print {\n@@ -2520,14 +2694,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.output_filenames.clone()\n     };\n-    providers.has_copy_closures = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.features().copy_closures\n-    };\n-    providers.has_clone_closures = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.features().clone_closures\n-    };\n     providers.features_query = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Lrc::new(tcx.sess.features_untracked().clone())"}, {"sha": "5f9c305d92f04ec32860e064606b3cb541e19f7d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -1517,10 +1517,21 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             let offset = st[i].fields.offset(field_index) + offset;\n                             let size = st[i].size;\n \n-                            let abi = if offset.bytes() == 0 && niche.value.size(dl) == size {\n-                                Abi::Scalar(niche.clone())\n-                            } else {\n-                                Abi::Aggregate { sized: true }\n+                            let abi = match st[i].abi {\n+                                Abi::Scalar(_) => Abi::Scalar(niche.clone()),\n+                                Abi::ScalarPair(ref first, ref second) => {\n+                                    // We need to use scalar_unit to reset the\n+                                    // valid range to the maximal one for that\n+                                    // primitive, because only the niche is\n+                                    // guaranteed to be initialised, not the\n+                                    // other primitive.\n+                                    if offset.bytes() == 0 {\n+                                        Abi::ScalarPair(niche.clone(), scalar_unit(second.value))\n+                                    } else {\n+                                        Abi::ScalarPair(scalar_unit(first.value), niche.clone())\n+                                    }\n+                                }\n+                                _ => Abi::Aggregate { sized: true },\n                             };\n \n                             return Ok(tcx.intern_layout(LayoutDetails {\n@@ -1544,11 +1555,17 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 let (mut min, mut max) = (i128::max_value(), i128::min_value());\n+                let discr_type = def.repr.discr_type();\n+                let bits = Integer::from_attr(tcx, discr_type).size().bits();\n                 for (i, discr) in def.discriminants(tcx).enumerate() {\n                     if variants[i].iter().any(|f| f.abi == Abi::Uninhabited) {\n                         continue;\n                     }\n-                    let x = discr.val as i128;\n+                    let mut x = discr.val as i128;\n+                    if discr_type.is_signed() {\n+                        // sign extend the raw representation to be an i128\n+                        x = (x << (128 - bits)) >> (128 - bits);\n+                    }\n                     if x < min { min = x; }\n                     if x > max { max = x; }\n                 }"}, {"sha": "a08cd57b1f7e24639d4e1128419f4240f6f9428e", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -430,6 +430,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::native_libraries<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::foreign_modules<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the foreign modules of a linked crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::plugin_registrar_fn<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the plugin registrar for a crate\")\n@@ -460,6 +466,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::original_crate_name<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::extra_filename<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the extra filename for a crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::implementations_of_trait<'tcx> {\n     fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n         format!(\"looking up implementations of a trait in a crate\")\n@@ -604,24 +616,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::has_clone_closures<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"seeing if the crate has enabled `Clone` closures\")\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n     fn describe(tcx: TyCtxt, key: ty::PolyTraitRef<'tcx> ) -> String {\n         format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id()))\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::has_copy_closures<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"seeing if the crate has enabled `Copy` closures\")\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up enabled feature gates\")\n@@ -678,6 +678,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx>\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::wasm_custom_sections<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"custom wasm sections for a crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::generics_of<'tcx> {\n     #[inline]\n     fn cache_on_disk(def_id: Self::Key) -> bool {\n@@ -699,6 +705,18 @@ impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::wasm_import_module_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"wasm import module map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::dllimport_foreign_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"wasm import module map\")\n+    }\n+}\n+\n macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {"}, {"sha": "7d756fb16a453d0b03b4e82d1f1e82b0cef9df7d", "filename": "src/librustc/ty/maps/job.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::sync::{Lock, Lrc};\n+use syntax_pos::Span;\n+use ty::tls;\n+use ty::maps::Query;\n+use ty::maps::plumbing::CycleError;\n+use ty::context::TyCtxt;\n+use errors::Diagnostic;\n+\n+/// Indicates the state of a query for a given key in a query map\n+pub(super) enum QueryResult<'tcx, T> {\n+    /// An already executing query. The query job can be used to await for its completion\n+    Started(Lrc<QueryJob<'tcx>>),\n+\n+    /// The query is complete and produced `T`\n+    Complete(T),\n+\n+    /// The query panicked. Queries trying to wait on this will raise a fatal error / silently panic\n+    Poisoned,\n+}\n+\n+/// A span and a query key\n+#[derive(Clone, Debug)]\n+pub struct QueryInfo<'tcx> {\n+    pub span: Span,\n+    pub query: Query<'tcx>,\n+}\n+\n+/// A object representing an active query job.\n+pub struct QueryJob<'tcx> {\n+    pub info: QueryInfo<'tcx>,\n+\n+    /// The parent query job which created this job and is implicitly waiting on it.\n+    pub parent: Option<Lrc<QueryJob<'tcx>>>,\n+\n+    /// Diagnostic messages which are emitted while the query executes\n+    pub diagnostics: Lock<Vec<Diagnostic>>,\n+}\n+\n+impl<'tcx> QueryJob<'tcx> {\n+    /// Creates a new query job\n+    pub fn new(info: QueryInfo<'tcx>, parent: Option<Lrc<QueryJob<'tcx>>>) -> Self {\n+        QueryJob {\n+            diagnostics: Lock::new(Vec::new()),\n+            info,\n+            parent,\n+        }\n+    }\n+\n+    /// Awaits for the query job to complete.\n+    ///\n+    /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n+    /// query that means that there is a query cycle, thus this always running a cycle error.\n+    pub(super) fn await<'lcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        span: Span,\n+    ) -> Result<(), CycleError<'tcx>> {\n+        // Get the current executing query (waiter) and find the waitee amongst its parents\n+        let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n+        let mut cycle = Vec::new();\n+\n+        while let Some(job) = current_job {\n+            cycle.insert(0, job.info.clone());\n+\n+            if &*job as *const _ == self as *const _ {\n+                break;\n+            }\n+\n+            current_job = job.parent.clone();\n+        }\n+\n+        Err(CycleError { span, cycle })\n+    }\n+\n+    /// Signals to waiters that the query is complete.\n+    ///\n+    /// This does nothing for single threaded rustc,\n+    /// as there are no concurrent jobs which could be waiting on us\n+    pub fn signal_complete(&self) {}\n+}"}, {"sha": "a992b8acb8b214e3eb426f8fddc6ecca1822c2a4", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -14,11 +14,11 @@ use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n use hir::svh::Svh;\n-use infer::canonical::{Canonical, QueryResult};\n+use infer::canonical::{self, Canonical};\n use lint;\n use middle::borrowck::BorrowCheckResult;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n-                     ExternBodyNestedBodies};\n+                     ExternBodyNestedBodies, ForeignModule};\n use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n use middle::privacy::AccessLevels;\n use middle::reachable::ReachableSet;\n@@ -66,6 +66,10 @@ mod plumbing;\n use self::plumbing::*;\n pub use self::plumbing::force_from_dep_node;\n \n+mod job;\n+pub use self::job::{QueryJob, QueryInfo};\n+use self::job::QueryResult;\n+\n mod keys;\n pub use self::keys::Key;\n \n@@ -299,6 +303,10 @@ define_maps! { <'tcx>\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n \n+    [] fn check_item_well_formed: CheckItemWellFormed(DefId) -> (),\n+    [] fn check_trait_item_well_formed: CheckTraitItemWellFormed(DefId) -> (),\n+    [] fn check_impl_item_well_formed: CheckImplItemWellFormed(DefId) -> (),\n+\n     // The DefIds of all non-generic functions and statics in the given crate\n     // that can be reached from outside the crate.\n     //\n@@ -316,17 +324,23 @@ define_maps! { <'tcx>\n \n \n     [] fn native_libraries: NativeLibraries(CrateNum) -> Lrc<Vec<NativeLibrary>>,\n+\n+    [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n+\n     [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n     [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n     [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n+    [] fn extra_filename: ExtraFileName(CrateNum) -> String,\n \n     [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n         -> Lrc<Vec<DefId>>,\n     [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n         -> Lrc<Vec<DefId>>,\n \n+    [] fn dllimport_foreign_items: DllimportForeignItems(CrateNum)\n+        -> Lrc<FxHashSet<DefId>>,\n     [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n     [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n     [] fn native_library_kind: NativeLibraryKind(DefId)\n@@ -378,9 +392,6 @@ define_maps! { <'tcx>\n     [] fn output_filenames: output_filenames_node(CrateNum)\n         -> Arc<OutputFilenames>,\n \n-    [] fn has_copy_closures: HasCopyClosures(CrateNum) -> bool,\n-    [] fn has_clone_closures: HasCloneClosures(CrateNum) -> bool,\n-\n     // Erases regions from `ty` to yield a new type.\n     // Normally you would just use `tcx.erase_regions(&value)`,\n     // however, which uses this query as a kind of cache.\n@@ -390,7 +401,7 @@ define_maps! { <'tcx>\n     [] fn normalize_projection_ty: NormalizeProjectionTy(\n         CanonicalProjectionGoal<'tcx>\n     ) -> Result<\n-        Lrc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n         NoSolution,\n     >,\n \n@@ -403,7 +414,7 @@ define_maps! { <'tcx>\n     [] fn dropck_outlives: DropckOutlives(\n         CanonicalTyGoal<'tcx>\n     ) -> Result<\n-        Lrc<Canonical<'tcx, QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n         NoSolution,\n     >,\n \n@@ -420,6 +431,10 @@ define_maps! { <'tcx>\n     [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n \n     [] fn program_clauses_for: ProgramClausesFor(DefId) -> Lrc<Vec<Clause<'tcx>>>,\n+\n+    [] fn wasm_custom_sections: WasmCustomSections(CrateNum) -> Lrc<Vec<DefId>>,\n+    [] fn wasm_import_module_map: WasmImportModuleMap(CrateNum)\n+        -> Lrc<FxHashMap<DefId, String>>,\n }\n \n //////////////////////////////////////////////////////////////////////"}, {"sha": "4d78703613e9442d6e6e2e6fb1b0431888fe791e", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -30,6 +30,7 @@ use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n+use ty::maps::job::QueryResult;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use ty::context::TyCtxt;\n \n@@ -239,6 +240,10 @@ impl<'sess> OnDiskCache<'sess> {\n                 for (key, entry) in const_eval::get_cache_internal(tcx).map.iter() {\n                     use ty::maps::config::QueryDescription;\n                     if const_eval::cache_on_disk(key.clone()) {\n+                        let entry = match *entry {\n+                            QueryResult::Complete(ref v) => v,\n+                            _ => panic!(\"incomplete query\"),\n+                        };\n                         if let Ok(ref value) = entry.value {\n                             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n@@ -820,7 +825,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<\n                 // of the metadata file, because that would end up making our indices\n                 // not special. It is essentially impossible for that to happen,\n                 // but let's make sure\n-                assert!(pos != interpret::ALLOC_DISCRIMINANT && pos != interpret::FN_DISCRIMINANT);\n+                assert!(pos >= interpret::SHORTHAND_START);\n                 entry.insert(pos);\n                 None\n             },\n@@ -1109,6 +1114,10 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     for (key, entry) in Q::get_cache_internal(tcx).map.iter() {\n         if Q::cache_on_disk(key.clone()) {\n+            let entry = match *entry {\n+                QueryResult::Complete(ref v) => v,\n+                _ => panic!(\"incomplete query\"),\n+            };\n             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n             // Record position of the cache entry"}, {"sha": "bc5a14c96f004a4c66cc671aa79aed8a71ea7df2", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 275, "deletions": 118, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -15,19 +15,18 @@\n use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::DiagnosticBuilder;\n use ty::{TyCtxt};\n-use ty::maps::Query; // NB: actually generated by the macros in this file\n use ty::maps::config::QueryDescription;\n+use ty::maps::job::{QueryResult, QueryInfo};\n use ty::item_path;\n \n use rustc_data_structures::fx::{FxHashMap};\n-use std::cell::{Ref, RefMut};\n+use rustc_data_structures::sync::LockGuard;\n use std::marker::PhantomData;\n-use std::mem;\n use syntax_pos::Span;\n \n pub(super) struct QueryMap<'tcx, D: QueryDescription<'tcx>> {\n     phantom: PhantomData<(D, &'tcx ())>,\n-    pub(super) map: FxHashMap<D::Key, QueryValue<D::Value>>,\n+    pub(super) map: FxHashMap<D::Key, QueryResult<'tcx, QueryValue<D::Value>>>,\n }\n \n pub(super) struct QueryValue<T> {\n@@ -57,23 +56,30 @@ impl<'tcx, M: QueryDescription<'tcx>> QueryMap<'tcx, M> {\n \n pub(super) trait GetCacheInternal<'tcx>: QueryDescription<'tcx> + Sized {\n     fn get_cache_internal<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                              -> Ref<'a, QueryMap<'tcx, Self>>;\n+                              -> LockGuard<'a, QueryMap<'tcx, Self>>;\n }\n \n-pub(super) struct CycleError<'a, 'tcx: 'a> {\n-    span: Span,\n-    cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n+#[derive(Clone)]\n+pub(super) struct CycleError<'tcx> {\n+    pub(super) span: Span,\n+    pub(super) cycle: Vec<QueryInfo<'tcx>>,\n+}\n+\n+/// The result of `try_get_lock`\n+pub(super) enum TryGetLock<'a, 'tcx: 'a, T, D: QueryDescription<'tcx> + 'a> {\n+    /// The query is not yet started. Contains a guard to the map eventually used to start it.\n+    NotYetStarted(LockGuard<'a, QueryMap<'tcx, D>>),\n+\n+    /// The query was already completed.\n+    /// Returns the result of the query and its dep node index\n+    /// if it succeeded or a cycle error if it failed\n+    JobCompleted(Result<(T, DepNodeIndex), CycleError<'tcx>>),\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub(super) fn report_cycle(self, CycleError { span, cycle }: CycleError)\n+    pub(super) fn report_cycle(self, CycleError { span, cycle: stack }: CycleError)\n         -> DiagnosticBuilder<'a>\n     {\n-        // Subtle: release the refcell lock before invoking `describe()`\n-        // below by dropping `cycle`.\n-        let stack = cycle.to_vec();\n-        mem::drop(cycle);\n-\n         assert!(!stack.is_empty());\n \n         // Disable naming impls with types in this path, since that\n@@ -87,44 +93,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  \"cyclic dependency detected\");\n             err.span_label(span, \"cyclic reference\");\n \n-            err.span_note(self.sess.codemap().def_span(stack[0].0),\n-                          &format!(\"the cycle begins when {}...\", stack[0].1.describe(self)));\n+            err.span_note(self.sess.codemap().def_span(stack[0].span),\n+                          &format!(\"the cycle begins when {}...\", stack[0].query.describe(self)));\n \n-            for &(span, ref query) in &stack[1..] {\n+            for &QueryInfo { span, ref query, .. } in &stack[1..] {\n                 err.span_note(self.sess.codemap().def_span(span),\n                               &format!(\"...which then requires {}...\", query.describe(self)));\n             }\n \n             err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n-                              stack[0].1.describe(self)));\n+                              stack[0].query.describe(self)));\n \n             return err\n         })\n     }\n \n-    pub(super) fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n-                                    -> Result<R, CycleError<'a, 'gcx>>\n-        where F: FnOnce() -> R\n-    {\n-        {\n-            let mut stack = self.maps.query_stack.borrow_mut();\n-            if let Some((i, _)) = stack.iter().enumerate().rev()\n-                                       .find(|&(_, &(_, ref q))| *q == query) {\n-                return Err(CycleError {\n-                    span,\n-                    cycle: RefMut::map(stack, |stack| &mut stack[i..])\n-                });\n-            }\n-            stack.push((span, query));\n-        }\n-\n-        let result = compute();\n-\n-        self.maps.query_stack.borrow_mut().pop();\n-\n-        Ok(result)\n-    }\n-\n     /// Try to read a node index for the node dep_node.\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n@@ -202,7 +185,11 @@ macro_rules! define_maps {\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n         use dep_graph::DepNodeIndex;\n-        use std::cell::RefCell;\n+        use std::mem;\n+        use errors::Diagnostic;\n+        use errors::FatalError;\n+        use rustc_data_structures::sync::{Lock, LockGuard};\n+        use rustc_data_structures::OnDrop;\n \n         define_map_struct! {\n             tcx: $tcx,\n@@ -214,8 +201,7 @@ macro_rules! define_maps {\n                        -> Self {\n                 Maps {\n                     providers,\n-                    query_stack: RefCell::new(vec![]),\n-                    $($name: RefCell::new(QueryMap::new())),*\n+                    $($name: Lock::new(QueryMap::new())),*\n                 }\n             }\n         }\n@@ -263,7 +249,7 @@ macro_rules! define_maps {\n \n         impl<$tcx> GetCacheInternal<$tcx> for queries::$name<$tcx> {\n             fn get_cache_internal<'a>(tcx: TyCtxt<'a, $tcx, $tcx>)\n-                                      -> ::std::cell::Ref<'a, QueryMap<$tcx, Self>> {\n+                                      -> LockGuard<'a, QueryMap<$tcx, Self>> {\n                 tcx.maps.$name.borrow()\n             }\n         }\n@@ -277,10 +263,54 @@ macro_rules! define_maps {\n                 DepNode::new(tcx, $node(*key))\n             }\n \n+            /// Either get the lock of the query map, allowing us to\n+            /// start executing the query, or it returns with the result of the query.\n+            /// If the query already executed and panicked, this will fatal error / silently panic\n+            fn try_get_lock(\n+                tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                mut span: Span,\n+                key: &$K\n+            ) -> TryGetLock<'a, $tcx, $V, Self>\n+            {\n+                loop {\n+                    let lock = tcx.maps.$name.borrow_mut();\n+                    let job = if let Some(value) = lock.map.get(key) {\n+                        match *value {\n+                            QueryResult::Started(ref job) => Some(job.clone()),\n+                            QueryResult::Complete(ref value) => {\n+                                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                                let result = Ok(((&value.value).clone(), value.index));\n+                                return TryGetLock::JobCompleted(result);\n+                            },\n+                            QueryResult::Poisoned => FatalError.raise(),\n+                        }\n+                    } else {\n+                        None\n+                    };\n+                    let job = if let Some(job) = job {\n+                        job\n+                    } else {\n+                        return TryGetLock::NotYetStarted(lock);\n+                    };\n+                    mem::drop(lock);\n+\n+                    // This just matches the behavior of `try_get_with` so the span when\n+                    // we await matches the span we would use when executing.\n+                    // See the FIXME there.\n+                    if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n+                        span = key.default_span(tcx);\n+                    }\n+\n+                    if let Err(cycle) = job.await(tcx, span) {\n+                        return TryGetLock::JobCompleted(Err(cycle));\n+                    }\n+                }\n+            }\n+\n             fn try_get_with(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                             mut span: Span,\n                             key: $K)\n-                            -> Result<$V, CycleError<'a, $tcx>>\n+                            -> Result<$V, CycleError<$tcx>>\n             {\n                 debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n                        stringify!($name),\n@@ -294,24 +324,41 @@ macro_rules! define_maps {\n                     )\n                 );\n \n-                if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n-                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                    tcx.dep_graph.read_index(value.index);\n-                    return Ok((&value.value).clone());\n+                /// Get the lock used to start the query or\n+                /// return the result of the completed query\n+                macro_rules! get_lock_or_return {\n+                    () => {{\n+                        match Self::try_get_lock(tcx, span, &key) {\n+                            TryGetLock::NotYetStarted(lock) => lock,\n+                            TryGetLock::JobCompleted(result) => {\n+                                return result.map(|(v, index)| {\n+                                    tcx.dep_graph.read_index(index);\n+                                    v\n+                                })\n+                            }\n+                        }\n+                    }}\n                 }\n \n+                let mut lock = get_lock_or_return!();\n+\n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n                 // default_span calls def_span query internally.\n                 if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n-                    span = key.default_span(tcx)\n+                    // This might deadlock if we hold the map lock since we might be\n+                    // waiting for the def_span query and switch to some other fiber\n+                    // So we drop the lock here and reacquire it\n+                    mem::drop(lock);\n+                    span = key.default_span(tcx);\n+                    lock = get_lock_or_return!();\n                 }\n \n                 // Fast path for when incr. comp. is off. `to_dep_node` is\n                 // expensive for some DepKinds.\n                 if !tcx.dep_graph.is_fully_enabled() {\n                     let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n-                    return Self::force(tcx, key, span, null_dep_node)\n+                    return Self::force_with_lock(tcx, key, span, lock, null_dep_node)\n                                 .map(|(v, _)| v);\n                 }\n \n@@ -320,34 +367,36 @@ macro_rules! define_maps {\n                 if dep_node.kind.is_anon() {\n                     profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n \n-                    let res = tcx.cycle_check(span, Query::$name(key), || {\n-                        tcx.sess.diagnostic().track_diagnostics(|| {\n-                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                                Self::compute_result(tcx.global_tcx(), key)\n-                            })\n+                    let res = Self::start_job(tcx, span, key, lock, |tcx| {\n+                        tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                            Self::compute_result(tcx.global_tcx(), key)\n                         })\n                     })?;\n \n                     profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                    let ((result, dep_node_index), diagnostics) = res;\n+                    let (((result, dep_node_index), diagnostics), job) = res;\n \n                     tcx.dep_graph.read_index(dep_node_index);\n \n                     tcx.on_disk_query_result_cache\n                        .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n \n-                    let value = QueryValue::new(result, dep_node_index);\n+                    let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n+\n+                    tcx.maps\n+                       .$name\n+                       .borrow_mut()\n+                       .map\n+                       .insert(key, QueryResult::Complete(value));\n \n-                    return Ok((&tcx.maps\n-                                    .$name\n-                                    .borrow_mut()\n-                                    .map\n-                                    .entry(key)\n-                                    .or_insert(value)\n-                                    .value).clone());\n+                    job.signal_complete();\n+\n+                    return Ok(result);\n                 }\n \n                 if !dep_node.kind.is_input() {\n+                    // try_mark_green_and_read may force queries. So we must drop our lock here\n+                    mem::drop(lock);\n                     if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n                         profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n@@ -356,9 +405,10 @@ macro_rules! define_maps {\n                                                                         dep_node_index,\n                                                                         &dep_node)\n                     }\n+                    lock = get_lock_or_return!();\n                 }\n \n-                match Self::force(tcx, key, span, dep_node) {\n+                match Self::force_with_lock(tcx, key, span, lock, dep_node) {\n                     Ok((result, dep_node_index)) => {\n                         tcx.dep_graph.read_index(dep_node_index);\n                         Ok(result)\n@@ -391,6 +441,73 @@ macro_rules! define_maps {\n                 }\n             }\n \n+            /// Creates a job for the query and updates the query map indicating that it started.\n+            /// Then it changes ImplicitCtxt to point to the new query job while it executes.\n+            /// If the query panics, this updates the query map to indicate so.\n+            fn start_job<F, R>(tcx: TyCtxt<'_, $tcx, 'lcx>,\n+                               span: Span,\n+                               key: $K,\n+                               mut map: LockGuard<'_, QueryMap<$tcx, Self>>,\n+                               compute: F)\n+                -> Result<((R, Vec<Diagnostic>), Lrc<QueryJob<$tcx>>), CycleError<$tcx>>\n+                where F: for<'b> FnOnce(TyCtxt<'b, $tcx, 'lcx>) -> R\n+            {\n+                let query = Query::$name(Clone::clone(&key));\n+\n+                let entry = QueryInfo {\n+                    span,\n+                    query,\n+                };\n+\n+                // The TyCtxt stored in TLS has the same global interner lifetime\n+                // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n+                // when accessing the ImplicitCtxt\n+                let (r, job) = ty::tls::with_related_context(tcx, move |icx| {\n+                    let job = Lrc::new(QueryJob::new(entry, icx.query.clone()));\n+\n+                    // Store the job in the query map and drop the lock to allow\n+                    // others to wait it\n+                    map.map.entry(key).or_insert(QueryResult::Started(job.clone()));\n+                    mem::drop(map);\n+\n+                    let r = {\n+                        let on_drop = OnDrop(|| {\n+                            // Poison the query so jobs waiting on it panic\n+                            tcx.maps\n+                            .$name\n+                            .borrow_mut()\n+                            .map\n+                            .insert(key, QueryResult::Poisoned);\n+                            // Also signal the completion of the job, so waiters\n+                            // will continue execution\n+                            job.signal_complete();\n+                        });\n+\n+                        // Update the ImplicitCtxt to point to our new query job\n+                        let icx = ty::tls::ImplicitCtxt {\n+                            tcx,\n+                            query: Some(job.clone()),\n+                        };\n+\n+                        // Use the ImplicitCtxt while we execute the query\n+                        let r = ty::tls::enter_context(&icx, |icx| {\n+                            compute(icx.tcx)\n+                        });\n+\n+                        mem::forget(on_drop);\n+\n+                        r\n+                    };\n+\n+                    (r, job)\n+                });\n+\n+                // Extract the diagnostic from the job\n+                let diagnostics: Vec<_> = mem::replace(&mut *job.diagnostics.lock(), Vec::new());\n+\n+                Ok(((r, diagnostics), job))\n+            }\n+\n             fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n                 let provider = tcx.maps.providers[key.map_crate()].$name;\n                 provider(tcx.global_tcx(), key)\n@@ -401,8 +518,11 @@ macro_rules! define_maps {\n                                                   span: Span,\n                                                   dep_node_index: DepNodeIndex,\n                                                   dep_node: &DepNode)\n-                                                  -> Result<$V, CycleError<'a, $tcx>>\n+                                                  -> Result<$V, CycleError<$tcx>>\n             {\n+                // Note this function can be called concurrently from the same query\n+                // We must ensure that this is handled correctly\n+\n                 debug_assert!(tcx.dep_graph.is_green(dep_node));\n \n                 // First we try to load the result from the on-disk cache\n@@ -425,24 +545,27 @@ macro_rules! define_maps {\n                     None\n                 };\n \n-                let result = if let Some(result) = result {\n-                    result\n+                let (result, job) = if let Some(result) = result {\n+                    (result, None)\n                 } else {\n                     // We could not load a result from the on-disk cache, so\n                     // recompute.\n-                    let (result, _ ) = tcx.cycle_check(span, Query::$name(key), || {\n-                        // The diagnostics for this query have already been\n-                        // promoted to the current session during\n-                        // try_mark_green(), so we can ignore them here.\n-                        tcx.sess.diagnostic().track_diagnostics(|| {\n-                            // The dep-graph for this computation is already in\n-                            // place\n-                            tcx.dep_graph.with_ignore(|| {\n-                                Self::compute_result(tcx, key)\n-                            })\n+\n+                    // The diagnostics for this query have already been\n+                    // promoted to the current session during\n+                    // try_mark_green(), so we can ignore them here.\n+                    let ((result, _), job) = Self::start_job(tcx,\n+                                                             span,\n+                                                             key,\n+                                                             tcx.maps.$name.borrow_mut(),\n+                                                             |tcx| {\n+                        // The dep-graph for this computation is already in\n+                        // place\n+                        tcx.dep_graph.with_ignore(|| {\n+                            Self::compute_result(tcx, key)\n                         })\n                     })?;\n-                    result\n+                    (result, Some(job))\n                 };\n \n                 // If -Zincremental-verify-ich is specified, re-hash results from\n@@ -475,43 +598,67 @@ macro_rules! define_maps {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n                 }\n \n-                let value = QueryValue::new(result, dep_node_index);\n+                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n+\n+                tcx.maps\n+                   .$name\n+                   .borrow_mut()\n+                   .map\n+                   .insert(key, QueryResult::Complete(value));\n+\n+                job.map(|j| j.signal_complete());\n \n-                Ok((&tcx.maps\n-                         .$name\n-                         .borrow_mut()\n-                         .map\n-                         .entry(key)\n-                         .or_insert(value)\n-                         .value).clone())\n+                Ok(result)\n             }\n \n+            #[allow(dead_code)]\n             fn force(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                      key: $K,\n                      span: Span,\n                      dep_node: DepNode)\n-                     -> Result<($V, DepNodeIndex), CycleError<'a, $tcx>> {\n+                     -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n+                // We may be concurrently trying both execute and force a query\n+                // Ensure that only one of them runs the query\n+                let lock = match Self::try_get_lock(tcx, span, &key) {\n+                    TryGetLock::NotYetStarted(lock) => lock,\n+                    TryGetLock::JobCompleted(result) => return result,\n+                };\n+                Self::force_with_lock(tcx,\n+                                      key,\n+                                      span,\n+                                      lock,\n+                                      dep_node)\n+            }\n+\n+            fn force_with_lock(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                               key: $K,\n+                               span: Span,\n+                               map: LockGuard<'_, QueryMap<$tcx, Self>>,\n+                               dep_node: DepNode)\n+                               -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n                 debug_assert!(!tcx.dep_graph.dep_node_exists(&dep_node));\n \n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-                let res = tcx.cycle_check(span, Query::$name(key), || {\n-                    tcx.sess.diagnostic().track_diagnostics(|| {\n-                        if dep_node.kind.is_eval_always() {\n-                            tcx.dep_graph.with_eval_always_task(dep_node,\n-                                                                tcx,\n-                                                                key,\n-                                                                Self::compute_result)\n-                        } else {\n-                            tcx.dep_graph.with_task(dep_node,\n-                                                    tcx,\n-                                                    key,\n-                                                    Self::compute_result)\n-                        }\n-                    })\n+                let res = Self::start_job(tcx,\n+                                          span,\n+                                          key,\n+                                          map,\n+                                          |tcx| {\n+                    if dep_node.kind.is_eval_always() {\n+                        tcx.dep_graph.with_eval_always_task(dep_node,\n+                                                            tcx,\n+                                                            key,\n+                                                            Self::compute_result)\n+                    } else {\n+                        tcx.dep_graph.with_task(dep_node,\n+                                                tcx,\n+                                                key,\n+                                                Self::compute_result)\n+                    }\n                 })?;\n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n \n-                let ((result, dep_node_index), diagnostics) = res;\n+                let (((result, dep_node_index), diagnostics), job) = res;\n \n                 if tcx.sess.opts.debugging_opts.query_dep_graph {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n@@ -522,16 +669,19 @@ macro_rules! define_maps {\n                        .store_diagnostics(dep_node_index, diagnostics);\n                 }\n \n-                let value = QueryValue::new(result, dep_node_index);\n+                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n+\n+                tcx.maps\n+                   .$name\n+                   .borrow_mut()\n+                   .map\n+                   .insert(key, QueryResult::Complete(value));\n \n-                Ok(((&tcx.maps\n-                         .$name\n-                         .borrow_mut()\n-                         .map\n-                         .entry(key)\n-                         .or_insert(value)\n-                         .value).clone(),\n-                   dep_node_index))\n+                let job: Lrc<QueryJob> = job;\n+\n+                job.signal_complete();\n+\n+                Ok((result, dep_node_index))\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n@@ -599,8 +749,7 @@ macro_rules! define_map_struct {\n      input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($(#[$attr])*  $name: RefCell<QueryMap<$tcx, queries::$name<$tcx>>>,)*\n+            $($(#[$attr])*  $name: Lock<QueryMap<$tcx, queries::$name<$tcx>>>,)*\n         }\n     };\n }\n@@ -871,18 +1020,25 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::GetPanicStrategy => { force!(panic_strategy, krate!()); }\n         DepKind::IsNoBuiltins => { force!(is_no_builtins, krate!()); }\n         DepKind::ImplDefaultness => { force!(impl_defaultness, def_id!()); }\n+        DepKind::CheckItemWellFormed => { force!(check_item_well_formed, def_id!()); }\n+        DepKind::CheckTraitItemWellFormed => { force!(check_trait_item_well_formed, def_id!()); }\n+        DepKind::CheckImplItemWellFormed => { force!(check_impl_item_well_formed, def_id!()); }\n         DepKind::ReachableNonGenerics => { force!(reachable_non_generics, krate!()); }\n         DepKind::NativeLibraries => { force!(native_libraries, krate!()); }\n         DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }\n         DepKind::DeriveRegistrarFn => { force!(derive_registrar_fn, krate!()); }\n         DepKind::CrateDisambiguator => { force!(crate_disambiguator, krate!()); }\n         DepKind::CrateHash => { force!(crate_hash, krate!()); }\n         DepKind::OriginalCrateName => { force!(original_crate_name, krate!()); }\n+        DepKind::ExtraFileName => { force!(extra_filename, krate!()); }\n \n         DepKind::AllTraitImplementations => {\n             force!(all_trait_implementations, krate!());\n         }\n \n+        DepKind::DllimportForeignItems => {\n+            force!(dllimport_foreign_items, krate!());\n+        }\n         DepKind::IsDllimportForeignItem => {\n             force!(is_dllimport_foreign_item, def_id!());\n         }\n@@ -914,8 +1070,6 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         }\n         DepKind::UsedCrateSource => { force!(used_crate_source, krate!()); }\n         DepKind::PostorderCnums => { force!(postorder_cnums, LOCAL_CRATE); }\n-        DepKind::HasCloneClosures => { force!(has_clone_closures, krate!()); }\n-        DepKind::HasCopyClosures => { force!(has_copy_closures, krate!()); }\n \n         DepKind::Freevars => { force!(freevars, def_id!()); }\n         DepKind::MaybeUnusedTraitImport => {\n@@ -937,6 +1091,9 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n \n         DepKind::ProgramClausesFor => { force!(program_clauses_for, def_id!()); }\n+        DepKind::WasmCustomSections => { force!(wasm_custom_sections, krate!()); }\n+        DepKind::WasmImportModuleMap => { force!(wasm_import_module_map, krate!()); }\n+        DepKind::ForeignModules => { force!(foreign_modules, krate!()); }\n     }\n \n     true"}, {"sha": "72ba199eb24122d38032e4f5717d6b9911a2b240", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 42, "deletions": 66, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -21,6 +21,7 @@ use hir::map::DefPathData;\n use hir::svh::Svh;\n use ich::Fingerprint;\n use ich::StableHashingContext;\n+use infer::canonical::{Canonical, Canonicalize};\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n@@ -34,6 +35,7 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n+use util::captures::Captures;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n@@ -67,7 +69,7 @@ pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};\n+pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n@@ -553,6 +555,17 @@ pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n impl<'tcx> serialize::UseSpecializedEncodable for Ty<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n \n+pub type CanonicalTy<'gcx> = Canonical<'gcx, Ty<'gcx>>;\n+\n+impl <'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for Ty<'tcx> {\n+    type Canonicalized = CanonicalTy<'gcx>;\n+\n+    fn intern(_gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+              value: Canonical<'gcx, Self::Lifted>) -> Self::Canonicalized {\n+        value\n+    }\n+}\n+\n /// A wrapper for slices with the additional invariant\n /// that the slice is interned and no other slice with\n /// the same contents can exist in the same context.\n@@ -1331,13 +1344,15 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// type name in a non-zero universe is a skolemized type -- an\n /// idealized representative of \"types in general\" that we use for\n /// checking generic functions.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct UniverseIndex(u32);\n \n impl UniverseIndex {\n     /// The root universe, where things that the user defined are\n     /// visible.\n-    pub const ROOT: UniverseIndex = UniverseIndex(0);\n+    pub fn root() -> UniverseIndex {\n+        UniverseIndex(0)\n+    }\n \n     /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n     /// So, for example, suppose we have this type in universe `U`:\n@@ -1351,26 +1366,7 @@ impl UniverseIndex {\n     /// region `'a`, but that region was not nameable from `U` because\n     /// it was not in scope there.\n     pub fn subuniverse(self) -> UniverseIndex {\n-        UniverseIndex(self.0.checked_add(1).unwrap())\n-    }\n-\n-    pub fn from(v: u32) -> UniverseIndex {\n-        UniverseIndex(v)\n-    }\n-\n-    pub fn as_u32(&self) -> u32 {\n-        self.0\n-    }\n-\n-    pub fn as_usize(&self) -> usize {\n-        self.0 as usize\n-    }\n-\n-    /// Gets the \"depth\" of this universe in the universe tree. This\n-    /// is not really useful except for e.g. the `HashStable`\n-    /// implementation\n-    pub fn depth(&self) -> u32 {\n-        self.0\n+        UniverseIndex(self.0 + 1)\n     }\n }\n \n@@ -1388,17 +1384,6 @@ pub struct ParamEnv<'tcx> {\n     /// want `Reveal::All` -- note that this is always paired with an\n     /// empty environment. To get that, use `ParamEnv::reveal()`.\n     pub reveal: traits::Reveal,\n-\n-    /// What is the innermost universe we have created? Starts out as\n-    /// `UniverseIndex::root()` but grows from there as we enter\n-    /// universal quantifiers.\n-    ///\n-    /// NB: At present, we exclude the universal quantifiers on the\n-    /// item we are type-checking, and just consider those names as\n-    /// part of the root universe. So this would only get incremented\n-    /// when we enter into a higher-ranked (`for<..>`) type or trait\n-    /// bound.\n-    pub universe: UniverseIndex,\n }\n \n impl<'tcx> ParamEnv<'tcx> {\n@@ -1407,7 +1392,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// Trait`) are left hidden, so this is suitable for ordinary\n     /// type-checking.\n     pub fn empty() -> Self {\n-        Self::new(ty::Slice::empty(), Reveal::UserFacing, ty::UniverseIndex::ROOT)\n+        Self::new(ty::Slice::empty(), Reveal::UserFacing)\n     }\n \n     /// Construct a trait environment with no where clauses in scope\n@@ -1418,15 +1403,14 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     pub fn reveal_all() -> Self {\n-        Self::new(ty::Slice::empty(), Reveal::All, ty::UniverseIndex::ROOT)\n+        Self::new(ty::Slice::empty(), Reveal::All)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n     pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>,\n-               reveal: Reveal,\n-               universe: ty::UniverseIndex)\n+               reveal: Reveal)\n                -> Self {\n-        ty::ParamEnv { caller_bounds, reveal, universe }\n+        ty::ParamEnv { caller_bounds, reveal }\n     }\n \n     /// Returns a new parameter environment with the same clauses, but\n@@ -1886,7 +1870,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     ) -> Option<Discr<'tcx>> {\n         let param_env = ParamEnv::empty();\n         let repr_type = self.repr.discr_type();\n-        let bit_size = layout::Integer::from_attr(tcx, repr_type).size().bits();\n         let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n         let instance = ty::Instance::new(expr_did, substs);\n         let cid = GlobalId {\n@@ -1896,25 +1879,13 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         match tcx.const_eval(param_env.and(cid)) {\n             Ok(&ty::Const {\n                 val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n-                ..\n+                ty,\n             }) => {\n                 trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                let ty = repr_type.to_ty(tcx);\n-                if repr_type.is_signed() {\n-                    let val = b as i128;\n-                    // sign extend to i128\n-                    let amt = 128 - bit_size;\n-                    let val = (val << amt) >> amt;\n-                    Some(Discr {\n-                        val: val as u128,\n-                        ty,\n-                    })\n-                } else {\n-                    Some(Discr {\n-                        val: b,\n-                        ty,\n-                    })\n-                }\n+                Some(Discr {\n+                    val: b,\n+                    ty,\n+                })\n             },\n             Ok(&ty::Const {\n                 val: ConstVal::Value(other),\n@@ -1942,8 +1913,10 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                         -> impl Iterator<Item=Discr<'tcx>> + 'a {\n+    pub fn discriminants(\n+        &'a self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> impl Iterator<Item=Discr<'tcx>> + Captures<'gcx> + 'a {\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<Discr<'tcx>>;\n@@ -2290,7 +2263,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns an iterator of the def-ids for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir.krate().body_ids.iter()`.\n-    pub fn body_owners(self) -> impl Iterator<Item = DefId> + 'a {\n+    pub fn body_owners(\n+        self,\n+    ) -> impl Iterator<Item = DefId> + Captures<'tcx> + Captures<'gcx> + 'a {\n         self.hir.krate()\n                 .body_ids\n                 .iter()\n@@ -2394,11 +2369,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-    pub fn associated_items(self, def_id: DefId)\n-                            -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+    pub fn associated_items(\n+        self,\n+        def_id: DefId,\n+    ) -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n         let def_ids = self.associated_item_def_ids(def_id);\n-        (0..def_ids.len()).map(move |i| self.associated_item(def_ids[i]))\n+        Box::new((0..def_ids.len()).map(move |i| self.associated_item(def_ids[i])))\n+            as Box<dyn Iterator<Item = ty::AssociatedItem> + 'a>\n     }\n \n     /// Returns true if the impls are the same polarity and are implementing\n@@ -2725,8 +2702,7 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // sure that this will succeed without errors anyway.\n \n     let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                             traits::Reveal::UserFacing,\n-                                             ty::UniverseIndex::ROOT);\n+                                             traits::Reveal::UserFacing);\n \n     let body_id = tcx.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n         tcx.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)"}, {"sha": "8cf662ccaea9254f9421c5ee4d37a504b828662f", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -18,6 +18,7 @@ use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::sync::Lrc;\n use mir::interpret;\n \n use std::rc::Rc;\n@@ -279,7 +280,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n         tcx.lift(&self.caller_bounds).map(|caller_bounds| {\n             ty::ParamEnv {\n                 reveal: self.reveal,\n-                universe: self.universe,\n                 caller_bounds,\n             }\n         })\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> Lift<'tcx> for ConstEvalErr<'a> {\n         tcx.lift(&*self.kind).map(|kind| {\n             ConstEvalErr {\n                 span: self.span,\n-                kind: Rc::new(kind),\n+                kind: Lrc::new(kind),\n             }\n         })\n     }\n@@ -737,29 +737,8 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ParamEnv {\n-            reveal: self.reveal,\n-            caller_bounds: self.caller_bounds.fold_with(folder),\n-            universe: self.universe.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        let &ty::ParamEnv { reveal: _, ref universe, ref caller_bounds } = self;\n-        universe.super_visit_with(visitor) || caller_bounds.super_visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::UniverseIndex {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> { reveal, caller_bounds }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {"}, {"sha": "ed04d41ba1457fbfddb518db98a4928884b7d4a9", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -18,6 +18,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n+use util::captures::Captures;\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -384,9 +385,11 @@ impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n     /// This returns the types of the MIR locals which had to be stored across suspension points.\n     /// It is calculated in rustc_mir::transform::generator::StateTransform.\n     /// All the types here must be in the tuple in GeneratorInterior.\n-    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'a\n-    {\n+    pub fn state_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a {\n         let state = tcx.generator_layout(def_id).fields.iter();\n         state.map(move |d| d.ty.subst(tcx, self.substs))\n     }\n@@ -403,7 +406,7 @@ impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n     /// This is the types of all the fields stored in a generator.\n     /// It includes the upvars, state types and the state discriminant which is u32.\n     pub fn field_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'a\n+        impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a\n     {\n         self.pre_transforms_tys(def_id, tcx).chain(self.state_tys(def_id, tcx))\n     }\n@@ -1025,7 +1028,7 @@ pub enum RegionKind {\n \n     /// A skolemized region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(ty::UniverseIndex, BoundRegion),\n+    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1079,6 +1082,11 @@ newtype_index!(RegionVid\n         DEBUG_FORMAT = custom,\n     });\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n+pub struct SkolemizedRegionVid {\n+    pub index: u32,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),\n@@ -1667,7 +1675,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n pub struct Const<'tcx> {\n     pub ty: Ty<'tcx>,\n \n-    // FIXME(eddyb) Replace this with a miri value.\n     pub val: ConstVal<'tcx>,\n }\n "}, {"sha": "e7b58ae1564aa1683a86a36d92c5ee81eae26a47", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -19,11 +19,11 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use core::intrinsics;\n-use core::nonzero::NonZero;\n use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n+use std::num::NonZeroUsize;\n \n /// An entity in the Rust typesystem, which can be one of\n /// several kinds (only types and lifetimes for now).\n@@ -32,7 +32,7 @@ use std::mem;\n /// indicate the type (`Ty` or `Region`) it points to.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n-    ptr: NonZero<usize>,\n+    ptr: NonZeroUsize,\n     marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>\n }\n \n@@ -63,7 +63,7 @@ impl<'tcx> UnpackedKind<'tcx> {\n \n         Kind {\n             ptr: unsafe {\n-                NonZero::new_unchecked(ptr | tag)\n+                NonZeroUsize::new_unchecked(ptr | tag)\n             },\n             marker: PhantomData\n         }"}, {"sha": "22f851a908b252b5f2046949b4f4fdb74a812876", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -39,16 +39,24 @@ use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug)]\n pub struct Discr<'tcx> {\n+    /// bit representation of the discriminant, so `-128i8` is `0xFF_u128`\n     pub val: u128,\n     pub ty: Ty<'tcx>\n }\n \n impl<'tcx> fmt::Display for Discr<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        if self.ty.is_signed() {\n-            write!(fmt, \"{}\", self.val as i128)\n-        } else {\n-            write!(fmt, \"{}\", self.val)\n+        match self.ty.sty {\n+            ty::TyInt(ity) => {\n+                let bits = ty::tls::with(|tcx| {\n+                    Integer::from_attr(tcx, SignedInt(ity)).size().bits()\n+                });\n+                let x = self.val as i128;\n+                // sign extend the raw representation to be an i128\n+                let x = (x << (128 - bits)) >> (128 - bits);\n+                write!(fmt, \"{}\", x)\n+            },\n+            _ => write!(fmt, \"{}\", self.val),\n         }\n     }\n }\n@@ -64,38 +72,38 @@ impl<'tcx> Discr<'tcx> {\n             TyUint(uty) => (Integer::from_attr(tcx, UnsignedInt(uty)), false),\n             _ => bug!(\"non integer discriminant\"),\n         };\n+\n+        let bit_size = int.size().bits();\n+        let amt = 128 - bit_size;\n         if signed {\n-            let (min, max) = match int {\n-                Integer::I8 => (i8::min_value() as i128, i8::max_value() as i128),\n-                Integer::I16 => (i16::min_value() as i128, i16::max_value() as i128),\n-                Integer::I32 => (i32::min_value() as i128, i32::max_value() as i128),\n-                Integer::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n-                Integer::I128 => (i128::min_value(), i128::max_value()),\n+            let sext = |u| {\n+                let i = u as i128;\n+                (i << amt) >> amt\n             };\n-            let val = self.val as i128;\n+            let min = sext(1_u128 << (bit_size - 1));\n+            let max = i128::max_value() >> amt;\n+            let val = sext(self.val);\n+            assert!(n < (i128::max_value() as u128));\n             let n = n as i128;\n             let oflo = val > max - n;\n             let val = if oflo {\n                 min + (n - (max - val) - 1)\n             } else {\n                 val + n\n             };\n+            // zero the upper bits\n+            let val = val as u128;\n+            let val = (val << amt) >> amt;\n             (Self {\n                 val: val as u128,\n                 ty: self.ty,\n             }, oflo)\n         } else {\n-            let (min, max) = match int {\n-                Integer::I8 => (u8::min_value() as u128, u8::max_value() as u128),\n-                Integer::I16 => (u16::min_value() as u128, u16::max_value() as u128),\n-                Integer::I32 => (u32::min_value() as u128, u32::max_value() as u128),\n-                Integer::I64 => (u64::min_value() as u128, u64::max_value() as u128),\n-                Integer::I128 => (u128::min_value(), u128::max_value()),\n-            };\n+            let max = u128::max_value() >> amt;\n             let val = self.val;\n             let oflo = val > max - n;\n             let val = if oflo {\n-                min + (n - (max - val) - 1)\n+                n - (max - val) - 1\n             } else {\n                 val + n\n             };\n@@ -189,7 +197,14 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt().enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n+                // These types used to have a builtin impl.\n+                // Now libcore provides that impl.\n+                ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n+                ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n+                ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => return Ok(()),\n+\n                 ty::TyAdt(adt, substs) => (adt, substs),\n+\n                 _ => return Err(CopyImplementationError::NotAnAdt),\n             };\n "}, {"sha": "b68cfd278fa9eb0b01f35b3124b94c1822874ce3", "filename": "src/librustc/util/captures.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Futil%2Fcaptures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Futil%2Fcaptures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcaptures.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// \"Signaling\" trait used in impl trait to tag lifetimes that you may\n+/// need to capture but don't really need for other reasons.\n+/// Basically a workaround; see [this comment] for details.\n+///\n+/// [this comment]: https://github.com/rust-lang/rust/issues/34511#issuecomment-373423999\n+pub trait Captures<'a> { }\n+\n+impl<'a, T: ?Sized> Captures<'a> for T { }"}, {"sha": "6b896a889e3003112b33eee21e6ad1ee32afb9c7", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -244,7 +244,8 @@ fn get_resident() -> Option<usize> {\n     use std::fs;\n \n     let field = 1;\n-    let contents = fs::read_string(\"/proc/self/statm\").ok()?;\n+    let contents = fs::read(\"/proc/self/statm\").ok()?;\n+    let contents = String::from_utf8(contents).ok()?;\n     let s = contents.split_whitespace().nth(field)?;\n     let npages = s.parse::<usize>().ok()?;\n     Some(npages * 4096)"}, {"sha": "d27cda4040e5646bf249eeb85e7564efe8c4a6f0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -793,7 +793,7 @@ define_print! {\n                 }\n \n                 ty::ReSkolemized(id, ref bound_region) => {\n-                    write!(f, \"ReSkolemized({:?}, {:?})\", id, bound_region)\n+                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n                 }\n \n                 ty::ReEmpty => write!(f, \"ReEmpty\"),\n@@ -1177,8 +1177,8 @@ define_print! {\n                         ConstVal::Value(Value::ByVal(PrimVal::Bytes(sz))) => {\n                             write!(f, \"{}\", sz)?;\n                         }\n-                        ConstVal::Unevaluated(_def_id, substs) => {\n-                            write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                        ConstVal::Unevaluated(_def_id, _substs) => {\n+                            write!(f, \"_\")?;\n                         }\n                         _ => {\n                             write!(f, \"{:?}\", sz)?;"}, {"sha": "ee38cca7828be0ef486d8f3555d0675ee6b26524", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -145,7 +145,7 @@ impl<'a> AllocFnFactory<'a> {\n         let result = self.call_allocator(method.name, args);\n         let (output_ty, output_expr) =\n             self.ret_ty(&method.output, &mut abi_args, mk, result);\n-        let kind = ItemKind::Fn(self.cx.fn_decl(abi_args, output_ty),\n+        let kind = ItemKind::Fn(self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n                                 Unsafety::Unsafe,\n                                 dummy_spanned(Constness::NotConst),\n                                 Abi::Rust,"}, {"sha": "6f08fcf702595eb49957fc70ff8c43516c6925c9", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -46,9 +46,9 @@\n #![deny(warnings)]\n #![forbid(unsafe_code)]\n \n-#![feature(i128_type)]\n #![cfg_attr(stage0, feature(slice_patterns))]\n-#![feature(try_from)]\n+#![cfg_attr(stage0, feature(i128_type))]\n+#![cfg_attr(stage0, feature(try_from))]\n \n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]"}, {"sha": "627d79724b28a463568723c97dedc96728eaa13d", "filename": "src/librustc_apfloat/tests/ieee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(i128_type)]\n+#![cfg_attr(stage0, feature(i128_type))]\n \n #[macro_use]\n extern crate rustc_apfloat;"}, {"sha": "507243a58a5f9506b62c282c7a7c6875e7f470bb", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "d54654c60868c26d586907659b1b6a3d3ec1ecff", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "2b0775e86952bbad78af7a1e0e5bf3ad1800ed5c", "filename": "src/librustc_const_eval/lib.rs", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446285e45c02f71392c7084328dc167d2e1ff58c/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=446285e45c02f71392c7084328dc167d2e1ff58c"}, {"sha": "7177e2818fbcc8029b98c4d0b95b0f40cb87c0d3", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "f50b8cadf15ab4f3b74d850ccfe1966a16d41bad", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "db1cfb5c767687cf92613bb333035f980cdb2592", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "28e3180063c170d83a497e4d0307e5d1bbd8c72d", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "e2b393071ff5c4ec0333aaf2f343ed31db734902", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "c9495587c4687aa6e5d6119b77550b5ec230b095", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "1fb63afc72fa758ae882ae0905f17aa2c0b27711", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "622fb423b51e4450b0b15ea1b36df5c4bde58d13", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "37512e4bcd57f334e971f44aff537f61475d2eba", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "184ef1369761cb181501960b2484197037a14d46", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "c6ebc99268057c4bbfd361291e6d35cd486408a9", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "b461431c7bbbd74b6eb6a8d66f6ccf88910ebd11", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 79, "deletions": 32, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "c5e7fdb30d36ade6dd716322037674395a9fe0d4", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "9efd8844977f905e7bf41fa15a25dee7e19b367a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "990ae2fc544ef2f79a2a5be0446b56d4287dc9ca", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "cad72ff778b55155e816b9d78950ad6b5c3e5f3a", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "44d6e532f79bb4aa67b52c4446ac18dc665d4aef", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "755a550b5bca31e4af3a120cd56d4b6ce22dd204", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "a5bc1106ba0b00fc24264b5378cd5711274e69ea", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "c0728cb2b6669da1579869acc939e0a1294fe2f0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 86, "deletions": 18, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "d024adad9d0305af87d052541c06f26fd7934a8e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "aa93b3098e046e8a0d8c0a433c28c50945e37a9c", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "e73c570ed82310e4ff6bb5c9ec332aac7ce52859", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "dba2e918f6f3a10a3fb44618bfcd55d6909de825", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "86f495c5fac3a2782e245ed06bc2364d0184f2ad", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "8765d9d8c2bed801be9dbc4aca1819aa06452f76", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "f63edf07fa8ba5b6615079f4c1739e7e18864378", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "e938d5c1a97fe4e9d1ff6e0ad4c44e9b448ddd0a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "0da6fc5b9eda19267d012e54052a123a9f0b7f57", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "c44d891b7f39a406d321f04f466347edaac30834", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "4af5ec9ae08ea0d023e23e1516d9f36b5899644b", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "f553c55ae56fad5cf5ef9f407c6111c56ee47e77", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "4bb6d8fb87cf5b490b2c3622ba6c1bedbf999a1b", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "a7ee0e7e9a961c7eb5b2eb461532d88dcbbf5588", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "305df37466d02a9aa724f8c722012e199dabb231", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "afaedecdf0abe307400847586aebaf1c0a98a838", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "4fcd3118f91081db6587ef0e63fd4dbb382c7e02", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "b0346abee5a5fbe83c67aee6fab39a668ecdb453", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "6c4c02a36a0d73c3e0205145bccf8f0be1820542", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "08391401cc696e45fc0252f5961ecf25a0778267", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 92, "deletions": 27, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "04c206b5c0c40b4d0f82891e6b7ce11672d5c04b", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "544cb5eefc8868a86ba3a2adf9e33d56d7647e7e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "39dc29ba18b645ae00339258f987b8f16b06f329", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "94702927d260067820931f1fc8d786c95b10f792", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "7eb52a3cdee93c7aec2b9d414a9a748b93d5b303", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "c50d84c10d86ea8c4568565067148a65ce6f1bc7", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "6f5fcc9e421cc115d780356092c1563455c30201", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "fb3042014df6af8e6098a4683a31d14f4fb9dc0d", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "287640439c0e8f9ab39216066e8e64eb38bc64d6", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "cbf4c822769c616f38f87784ec7566fe3688299c", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "9f6cf8c036e19a686e44febe3a783e252f8dd44c", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "4f36c3888b961fe75711a18696cc083645ee52b3", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "14aa307f0ae1f1a24652a4b6a60cb3cf44da2edc", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "5b3739084801f093e80d25013dfc1228ae36bac4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "fe82b8158f76dbed8188e15843443d9259b32bde", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "798d635318180937696cddae0546b3e8e2ef7461", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "57977b6201a61095e384f81ab1e758890651bdbf", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "cf3241fe9be662d6938e7d551020cbee98db5a4d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 52, "deletions": 58, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "dcf97f61545db2ca7a7ebd2d3a7fadc9c7bdbe8d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "456f5fd75db09772ea8949c7c887c71a1ad0cb54", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "a22572ec687c3cf05a90177aa0b41d96cb585143", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "84baa8c541781f8f21240aa2dd07071f51f51c7c", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "31af7c21857947853b7d7d8a0227c3572116c360", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "256b1fd66e9a749310c976e0ae3be482cf84220d", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "renamed", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd", "previous_filename": "src/librustc_mir/transform/clean_end_regions.rs"}, {"sha": "63ca35aa0e7b2ab3bf9b971d0b248a4bd035cbd6", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "aeefd5ab1d5aca903db44e5e8b20d7d2e4e3744b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "6d365012525f612833d4c47454071059d9fc1bfb", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "45e7a0d3f4c5ab9bd152d54498cda2075eaeebd2", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}, {"sha": "19f33ef5d45a83f6a6b4b964c613f6574bfa924b", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e94d5498d3a24418185a1783f2819cbb2280ddd/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=5e94d5498d3a24418185a1783f2819cbb2280ddd"}]}