{"sha": "d7560e8968b4381f012173f97c166c952f691a56", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NTYwZTg5NjhiNDM4MWYwMTIxNzNmOTdjMTY2Yzk1MmY2OTFhNTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-10T12:55:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-10T12:55:12Z"}, "message": "Auto merge of #79801 - eddyb:scalar-transmute, r=nagisa\n\nrustc_codegen_ssa: use bitcasts instead of type punning for scalar transmutes.\n\nThis specifically helps with `f32` <-> `u32` (`from_bits`, `to_bits`) in Rust-GPU (`rustc_codegen_spirv`), where (AFAIK) we don't yet have enough infrastructure to turn type punning memory accesses into SSA bitcasts.\n(There may be more instances, but the one I've seen myself is `f32::signum` from `num-traits` inspecting e.g. the sign bit)\n\nSadly I've had to make an exception for `transmute`s between pointers and non-pointers, as LLVM disallows using `bitcast` for them.\n\nr? `@nagisa` cc `@khyperia`", "tree": {"sha": "9b51739f4a73725481dc260d4b54269a0e67f6e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b51739f4a73725481dc260d4b54269a0e67f6e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7560e8968b4381f012173f97c166c952f691a56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7560e8968b4381f012173f97c166c952f691a56", "html_url": "https://github.com/rust-lang/rust/commit/d7560e8968b4381f012173f97c166c952f691a56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7560e8968b4381f012173f97c166c952f691a56/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39b841dfe36f90a7cd111e7f0c55f32594f6e578", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b841dfe36f90a7cd111e7f0c55f32594f6e578", "html_url": "https://github.com/rust-lang/rust/commit/39b841dfe36f90a7cd111e7f0c55f32594f6e578"}, {"sha": "718fba92b0f319a271265df53fd0221447897311", "url": "https://api.github.com/repos/rust-lang/rust/commits/718fba92b0f319a271265df53fd0221447897311", "html_url": "https://github.com/rust-lang/rust/commit/718fba92b0f319a271265df53fd0221447897311"}], "stats": {"total": 104, "additions": 104, "deletions": 0}, "files": [{"sha": "ce56f1635495e8082cdcab3be0e68e515d2217e9", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d7560e8968b4381f012173f97c166c952f691a56/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7560e8968b4381f012173f97c166c952f691a56/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=d7560e8968b4381f012173f97c166c952f691a56", "patch": "@@ -1395,6 +1395,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         dst: PlaceRef<'tcx, Bx::Value>,\n     ) {\n         let src = self.codegen_operand(bx, src);\n+\n+        // Special-case transmutes between scalars as simple bitcasts.\n+        match (&src.layout.abi, &dst.layout.abi) {\n+            (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n+                // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n+                if (src_scalar.value == abi::Pointer) == (dst_scalar.value == abi::Pointer) {\n+                    assert_eq!(src.layout.size, dst.layout.size);\n+\n+                    // NOTE(eddyb) the `from_immediate` and `to_immediate_scalar`\n+                    // conversions allow handling `bool`s the same as `u8`s.\n+                    let src = bx.from_immediate(src.immediate());\n+                    let src_as_dst = bx.bitcast(src, bx.backend_type(dst.layout));\n+                    Immediate(bx.to_immediate_scalar(src_as_dst, dst_scalar)).store(bx, dst);\n+                    return;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         let llty = bx.backend_type(src.layout);\n         let cast_ptr = bx.pointercast(dst.llval, bx.type_ptr_to(llty));\n         let align = src.layout.align.abi.min(dst.align);"}, {"sha": "78b4aa3fb885d80f8686a7195297428fdba3225c", "filename": "src/test/codegen/transmute-scalar.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d7560e8968b4381f012173f97c166c952f691a56/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7560e8968b4381f012173f97c166c952f691a56/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs?ref=d7560e8968b4381f012173f97c166c952f691a56", "patch": "@@ -0,0 +1,85 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+// FIXME(eddyb) all of these tests show memory stores and loads, even after a\n+// scalar `bitcast`, more special-casing is required to remove `alloca` usage.\n+\n+// CHECK: define i32 @f32_to_bits(float %x)\n+// CHECK: %2 = bitcast float %x to i32\n+// CHECK-NEXT: store i32 %2, i32* %0\n+// CHECK-NEXT: %3 = load i32, i32* %0\n+// CHECK: ret i32 %3\n+#[no_mangle]\n+pub fn f32_to_bits(x: f32) -> u32 {\n+    unsafe { std::mem::transmute(x) }\n+}\n+\n+// CHECK: define i8 @bool_to_byte(i1 zeroext %b)\n+// CHECK: %1 = zext i1 %b to i8\n+// CHECK-NEXT: store i8 %1, i8* %0\n+// CHECK-NEXT: %2 = load i8, i8* %0\n+// CHECK: ret i8 %2\n+#[no_mangle]\n+pub fn bool_to_byte(b: bool) -> u8 {\n+    unsafe { std::mem::transmute(b) }\n+}\n+\n+// CHECK: define zeroext i1 @byte_to_bool(i8 %byte)\n+// CHECK: %1 = trunc i8 %byte to i1\n+// CHECK-NEXT: %2 = zext i1 %1 to i8\n+// CHECK-NEXT: store i8 %2, i8* %0\n+// CHECK-NEXT: %3 = load i8, i8* %0\n+// CHECK-NEXT: %4 = trunc i8 %3 to i1\n+// CHECK: ret i1 %4\n+#[no_mangle]\n+pub unsafe fn byte_to_bool(byte: u8) -> bool {\n+    std::mem::transmute(byte)\n+}\n+\n+// CHECK: define i8* @ptr_to_ptr(i16* %p)\n+// CHECK: %2 = bitcast i16* %p to i8*\n+// CHECK-NEXT: store i8* %2, i8** %0\n+// CHECK-NEXT: %3 = load i8*, i8** %0\n+// CHECK: ret i8* %3\n+#[no_mangle]\n+pub fn ptr_to_ptr(p: *mut u16) -> *mut u8 {\n+    unsafe { std::mem::transmute(p) }\n+}\n+\n+// HACK(eddyb) scalar `transmute`s between pointers and non-pointers are\n+// currently not special-cased like other scalar `transmute`s, because\n+// LLVM requires specifically `ptrtoint`/`inttoptr` instead of `bitcast`.\n+//\n+// Tests below show the non-special-cased behavior (with the possible\n+// future special-cased instructions in the \"NOTE(eddyb)\" comments).\n+\n+// CHECK: define [[USIZE:i[0-9]+]] @ptr_to_int(i16* %p)\n+\n+// NOTE(eddyb) see above, the following two CHECK lines should ideally be this:\n+//        %2 = ptrtoint i16* %p to [[USIZE]]\n+//             store [[USIZE]] %2, [[USIZE]]* %0\n+// CHECK: %2 = bitcast [[USIZE]]* %0 to i16**\n+// CHECK-NEXT: store i16* %p, i16** %2\n+\n+// CHECK-NEXT: %3 = load [[USIZE]], [[USIZE]]* %0\n+// CHECK: ret [[USIZE]] %3\n+#[no_mangle]\n+pub fn ptr_to_int(p: *mut u16) -> usize {\n+    unsafe { std::mem::transmute(p) }\n+}\n+\n+// CHECK: define i16* @int_to_ptr([[USIZE]] %i)\n+\n+// NOTE(eddyb) see above, the following two CHECK lines should ideally be this:\n+//        %2 = inttoptr [[USIZE]] %i to i16*\n+//             store i16* %2, i16** %0\n+// CHECK: %2 = bitcast i16** %0 to [[USIZE]]*\n+// CHECK-NEXT: store [[USIZE]] %i, [[USIZE]]* %2\n+\n+// CHECK-NEXT: %3 = load i16*, i16** %0\n+// CHECK: ret i16* %3\n+#[no_mangle]\n+pub fn int_to_ptr(i: usize) -> *mut u16 {\n+    unsafe { std::mem::transmute(i) }\n+}"}]}