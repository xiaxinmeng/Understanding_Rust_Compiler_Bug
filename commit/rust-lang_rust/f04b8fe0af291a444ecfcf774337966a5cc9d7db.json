{"sha": "f04b8fe0af291a444ecfcf774337966a5cc9d7db", "node_id": "C_kwDOAAsO6NoAKGYwNGI4ZmUwYWYyOTFhNDQ0ZWNmY2Y3NzQzMzc5NjZhNWNjOWQ3ZGI", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-04-27T07:34:11Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-04-27T07:35:19Z"}, "message": "rename `needs_infer` to `has_infer`", "tree": {"sha": "3b983a3805c4275580f8ac059910de6429875bbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b983a3805c4275580f8ac059910de6429875bbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f04b8fe0af291a444ecfcf774337966a5cc9d7db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f04b8fe0af291a444ecfcf774337966a5cc9d7db", "html_url": "https://github.com/rust-lang/rust/commit/f04b8fe0af291a444ecfcf774337966a5cc9d7db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f04b8fe0af291a444ecfcf774337966a5cc9d7db/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3ccd4b9a51ded19bf1c3f6c647c96b6dd52eced", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ccd4b9a51ded19bf1c3f6c647c96b6dd52eced", "html_url": "https://github.com/rust-lang/rust/commit/e3ccd4b9a51ded19bf1c3f6c647c96b6dd52eced"}], "stats": {"total": 117, "additions": 59, "deletions": 58}, "files": [{"sha": "0b4d4ecf2e46dfc9b65af1a64a331924ffc3dbc1", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -70,7 +70,7 @@ pub(crate) fn get_function_sig<'tcx>(\n     default_call_conv: CallConv,\n     inst: Instance<'tcx>,\n ) -> Signature {\n-    assert!(!inst.substs.needs_infer());\n+    assert!(!inst.substs.has_infer());\n     clif_sig_from_fn_abi(\n         tcx,\n         default_call_conv,"}, {"sha": "c181c73e4be949a5a8d546fe7164464c5b616ed1", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -28,7 +28,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) -> CodegenedFunction {\n-    debug_assert!(!instance.substs.needs_infer());\n+    debug_assert!(!instance.substs.has_infer());\n \n     let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let _timer = tcx.prof.generic_activity_with_arg(\"codegen fn\", &*symbol_name);"}, {"sha": "433b2585f82a844730da8baf4eb28aecdd75d62b", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -17,7 +17,7 @@ use crate::context::CodegenCx;\n pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> Function<'gcc> {\n     let tcx = cx.tcx();\n \n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n     let sym = tcx.symbol_name(instance).name;"}, {"sha": "342b830cedb1206922c1b00ee70fc3f0f2891a42", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -31,7 +31,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n     fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n-        assert!(!instance.substs.needs_infer());\n+        assert!(!instance.substs.has_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));"}, {"sha": "30a0cf1d01914c8718b77b9ee9d7ceff6cdabac7", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -27,7 +27,7 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n \n     debug!(\"get_fn(instance={:?})\", instance);\n \n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n     if let Some(&llfn) = cx.instances.borrow().get(&instance) {"}, {"sha": "59bdc60830f80016fc76d58ab35fd7a9bd5edee5", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n         visibility: Visibility,\n         symbol_name: &str,\n     ) {\n-        assert!(!instance.substs.needs_infer());\n+        assert!(!instance.substs.has_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         let lldecl = self.declare_fn(symbol_name, fn_abi);"}, {"sha": "f6e937a740c2677069b2c3adc8c4be6a50b7b12a", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -152,7 +152,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     instance: Instance<'tcx>,\n ) {\n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n \n     let llfn = cx.get_fn(instance);\n "}, {"sha": "9ef4a0fb8f9526cc5dbcfc206ee8aba7be3e4f40", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -2318,7 +2318,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let infcx = match self.infcx() {\n             Some(infcx) => infcx,\n             None => {\n-                assert!(!self_ty.needs_infer());\n+                assert!(!self_ty.has_infer());\n                 infcx_ = tcx.infer_ctxt().ignoring_regions().build();\n                 &infcx_\n             }\n@@ -2489,7 +2489,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let infcx = if let Some(infcx) = self.infcx() {\n             infcx\n         } else {\n-            assert!(!qself_ty.needs_infer());\n+            assert!(!qself_ty.has_infer());\n             infcx_ = tcx.infer_ctxt().build();\n             &infcx_\n         };"}, {"sha": "b0d7e7fb83bec58c191d053770ee5c36e27b238a", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -1027,7 +1027,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n                 packed && {\n                     let ty = tcx.type_of(variant.fields.raw.last().unwrap().did).subst_identity();\n                     let ty = tcx.erase_regions(ty);\n-                    if ty.needs_infer() {\n+                    if ty.has_infer() {\n                         tcx.sess\n                             .delay_span_bug(item.span, &format!(\"inference variables in {:?}\", ty));\n                         // Just treat unresolved type expression as if it needs drop."}, {"sha": "c09457e1d65ecb5097dd2f8b02861a4238fdc00e", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -366,7 +366,7 @@ fn check_predicates<'tcx>(\n             wf::obligations(infcx, tcx.param_env(impl1_def_id), impl1_def_id, 0, arg, span)\n                 .unwrap();\n \n-        assert!(!obligations.needs_infer());\n+        assert!(!obligations.has_infer());\n         impl2_predicates\n             .extend(traits::elaborate(tcx, obligations).map(|obligation| obligation.predicate))\n     }"}, {"sha": "73a7bbebb6581b7f62e1836dcfdc953ee5528543", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ocx.normalize(&ObligationCause::dummy(), self.param_env, fn_sig);\n                     if ocx.select_all_or_error().is_empty() {\n                         let normalized_fn_sig = self.resolve_vars_if_possible(normalized_fn_sig);\n-                        if !normalized_fn_sig.needs_infer() {\n+                        if !normalized_fn_sig.has_infer() {\n                             return normalized_fn_sig;\n                         }\n                     }"}, {"sha": "5136d895f22686c06176b822177441c066ed05d6", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         // If the type being assigned needs dropped, then the mutation counts as a borrow\n         // since it is essentially doing `Drop::drop(&mut x); x = new_value;`.\n         let ty = self.tcx.erase_regions(assignee_place.place.base_ty);\n-        if ty.needs_infer() {\n+        if ty.has_infer() {\n             self.tcx.sess.delay_span_bug(\n                 self.tcx.hir().span(assignee_place.hir_id),\n                 &format!(\"inference variables in {ty}\"),"}, {"sha": "915280a5bea022db041a18aac4821d5f65fd43d9", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                 // Avoid ICEs in needs_drop.\n                 let ty = self.fcx.resolve_vars_if_possible(ty);\n                 let ty = self.fcx.tcx.erase_regions(ty);\n-                if ty.needs_infer() {\n+                if ty.has_infer() {\n                     self.fcx\n                         .tcx\n                         .sess"}, {"sha": "1a429142e01481eb593fb7848571861379c5fcc9", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -2032,7 +2032,7 @@ impl<'tcx> Candidate<'tcx> {\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n                     assert!(\n-                        !trait_ref.skip_binder().substs.needs_infer()\n+                        !trait_ref.skip_binder().substs.has_infer()\n                             && !trait_ref.skip_binder().substs.has_placeholders()\n                     );\n "}, {"sha": "817918257beb433ec9f4d7b3c43d63abe8f8a760", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -133,7 +133,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn write_ty_to_typeck_results(&mut self, hir_id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty_to_typeck_results({:?}, {:?})\", hir_id, ty);\n-        assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n+        assert!(!ty.has_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n         self.typeck_results.node_types_mut().insert(hir_id, ty);\n     }\n \n@@ -508,7 +508,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             fcx_typeck_results.user_provided_types().items().map(|(local_id, c_ty)| {\n                 let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n-                if cfg!(debug_assertions) && c_ty.needs_infer() {\n+                if cfg!(debug_assertions) && c_ty.has_infer() {\n                     span_bug!(\n                         hir_id.to_span(self.fcx.tcx),\n                         \"writeback: `{:?}` has inference variables\",\n@@ -527,7 +527,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n         self.typeck_results.user_provided_sigs.extend(\n             fcx_typeck_results.user_provided_sigs.items().map(|(&def_id, c_sig)| {\n-                if cfg!(debug_assertions) && c_sig.needs_infer() {\n+                if cfg!(debug_assertions) && c_sig.has_infer() {\n                     span_bug!(\n                         self.fcx.tcx.def_span(def_id),\n                         \"writeback: `{:?}` has inference variables\",\n@@ -618,7 +618,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         if let Some(substs) = self.fcx.typeck_results.borrow().node_substs_opt(hir_id) {\n             let substs = self.resolve(substs, &span);\n             debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n-            assert!(!substs.needs_infer() && !substs.has_placeholders());\n+            assert!(!substs.has_infer() && !substs.has_placeholders());\n             self.typeck_results.node_substs_mut().insert(hir_id, substs);\n         }\n     }\n@@ -693,7 +693,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n-            if cfg!(debug_assertions) && container.needs_infer() {\n+            if cfg!(debug_assertions) && container.has_infer() {\n                 span_bug!(\n                     hir_id.to_span(self.fcx.tcx),\n                     \"writeback: `{:?}` has inference variables\",\n@@ -711,7 +711,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     {\n         let mut resolver = Resolver::new(self.fcx, span, self.body);\n         let x = x.fold_with(&mut resolver);\n-        if cfg!(debug_assertions) && x.needs_infer() {\n+        if cfg!(debug_assertions) && x.has_infer() {\n             span_bug!(span.to_span(self.fcx.tcx), \"writeback: `{:?}` has inference variables\", x);\n         }\n "}, {"sha": "c29f652034fc071681beb3e54b33fc6ad92bf16d", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -564,12 +564,12 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let _inside_canonical_ctxt_guard = infcx.set_canonicalization_ctxt();\n \n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n-            TypeFlags::NEEDS_INFER |\n+            TypeFlags::HAS_INFER |\n             TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`\n             TypeFlags::HAS_TY_PLACEHOLDER |\n             TypeFlags::HAS_CT_PLACEHOLDER\n         } else {\n-            TypeFlags::NEEDS_INFER\n+            TypeFlags::HAS_INFER\n                 | TypeFlags::HAS_RE_PLACEHOLDER\n                 | TypeFlags::HAS_TY_PLACEHOLDER\n                 | TypeFlags::HAS_CT_PLACEHOLDER\n@@ -600,7 +600,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n         // anymore.\n-        debug_assert!(!out_value.needs_infer() && !out_value.has_placeholders());\n+        debug_assert!(!out_value.has_infer() && !out_value.has_placeholders());\n \n         let canonical_variables =\n             tcx.mk_canonical_var_infos(&canonicalizer.universe_canonicalized_variables());"}, {"sha": "0219167f6e58b53cda7fb27354a2f14f5ad5a752", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for TypeFreshener<'a, 'tcx> {\n \n     #[inline]\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_infer() && !t.has_erasable_regions() {\n+        if !t.has_infer() && !t.has_erasable_regions() {\n             t\n         } else {\n             match *t.kind() {"}, {"sha": "1cfdb791cd6ae44c244783e441b1d2422df48bfa", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -1327,7 +1327,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n-        if !value.needs_infer() {\n+        if !value.has_infer() {\n             return value; // Avoid duplicated subst-folding.\n         }\n         let mut r = InferenceLiteralEraser { tcx: self.tcx };\n@@ -1365,7 +1365,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     pub fn fully_resolve<T: TypeFoldable<TyCtxt<'tcx>>>(&self, value: T) -> FixupResult<'tcx, T> {\n         let value = resolve::fully_resolve(self, value);\n         assert!(\n-            value.as_ref().map_or(true, |value| !value.needs_infer()),\n+            value.as_ref().map_or(true, |value| !value.has_infer()),\n             \"`{value:?}` is not fully resolved\"\n         );\n         value"}, {"sha": "d3f7eeff9976cccaa429bdb37cfedf2b8ef99961", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -347,7 +347,7 @@ where\n         let is_opaque = alias_ty.kind(self.tcx) == ty::Opaque;\n         if approx_env_bounds.is_empty()\n             && trait_bounds.is_empty()\n-            && (alias_ty.needs_infer() || is_opaque)\n+            && (alias_ty.has_infer() || is_opaque)\n         {\n             debug!(\"no declared bounds\");\n             let opt_variances = is_opaque.then(|| self.tcx.variances_of(alias_ty.def_id));"}, {"sha": "3c41e8b37838a8e6f51c9782689d59cd6476c8b0", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        if !t.needs_infer() {\n+        if !t.has_infer() {\n             Ok(t) // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n-        if !c.needs_infer() {\n+        if !c.has_infer() {\n             Ok(c) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let c = self.infcx.shallow_resolve(c);"}, {"sha": "830231646c659d6123f8381882e821af888f825e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -215,7 +215,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     ) -> Fingerprint {\n         // It's impossible to hash inference variables (and will ICE), so we don't need to try to cache them.\n         // Without incremental, we rarely stable-hash types, so let's not do it proactively.\n-        if flags.flags.intersects(TypeFlags::NEEDS_INFER) || sess.opts.incremental.is_none() {\n+        if flags.flags.intersects(TypeFlags::HAS_INFER) || sess.opts.incremental.is_none() {\n             Fingerprint::ZERO\n         } else {\n             let mut hasher = StableHasher::new();"}, {"sha": "ad930d1e6b64ad95009cdb85810d27cbaedc736f", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -40,7 +40,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for RegionEraserVisitor<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n+        if ty.has_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n     }\n \n     fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>"}, {"sha": "c77985c6bd6350a35f6b20df90a86c3924843fc4", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -1151,7 +1151,7 @@ impl<'tcx> Ty<'tcx> {\n                 // context, or *something* like that, but for now just avoid passing inference\n                 // variables to queries that can't cope with them. Instead, conservatively\n                 // return \"true\" (may change drop order).\n-                if query_ty.needs_infer() {\n+                if query_ty.has_infer() {\n                     return true;\n                 }\n "}, {"sha": "9a8bb5052d4822110642f159a233ea3fa9bfca67", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -79,10 +79,10 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n     fn has_non_region_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_INFER - TypeFlags::HAS_RE_INFER)\n+        self.has_type_flags(TypeFlags::HAS_INFER - TypeFlags::HAS_RE_INFER)\n     }\n-    fn needs_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_INFER)\n+    fn has_infer(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_INFER)\n     }\n     fn has_placeholders(&self) -> bool {\n         self.has_type_flags("}, {"sha": "fcf86da08f4695dda16949bebe420634e58dde9b", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     fn type_is_copy_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n         let ty = self.resolve_vars_if_possible(ty);\n \n-        if !(param_env, ty).needs_infer() {\n+        if !(param_env, ty).has_infer() {\n             return ty.is_copy_modulo_regions(self.tcx, param_env);\n         }\n "}, {"sha": "ff4bff10cc8a39c8141bca9f08cbb151c9ad3beb", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> Canonicalizer<'a, 'tcx> {\n         };\n \n         let value = value.fold_with(&mut canonicalizer);\n-        assert!(!value.needs_infer());\n+        assert!(!value.has_infer());\n         assert!(!value.has_placeholders());\n \n         let (max_universe, variables) = canonicalizer.finalize();"}, {"sha": "b9310d3f839f758da76c4d546fad6f6d57175986", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -582,7 +582,7 @@ fn orphan_check_trait_ref<'tcx>(\n     trait_ref: ty::TraitRef<'tcx>,\n     in_crate: InCrate,\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n-    if trait_ref.needs_infer() && trait_ref.needs_subst() {\n+    if trait_ref.has_infer() && trait_ref.needs_subst() {\n         bug!(\n             \"can't orphan check a trait ref with both params and inference variables {:?}\",\n             trait_ref"}, {"sha": "0db802328912715a9d5ac24e3fa2814b80ca534c", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         // We may however encounter unconstrained lifetime variables in invalid\n         // code. See #110161 for context.\n         assert!(!ty.has_non_region_infer());\n-        if ty.needs_infer() {\n+        if ty.has_infer() {\n             self.tcx.sess.delay_span_bug(\n                 self.tcx.def_span(body_id),\n                 \"skipped implied_outlives_bounds due to unconstrained lifetimes\","}, {"sha": "a67fc8b592d8961c90c9766c9b7582ff7341c3dc", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -449,7 +449,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n \n-        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n+        let has_non_region_infer = stack.obligation.predicate.has_non_region_infer();\n \n         // If there are STILL multiple candidates, we can further\n         // reduce the list by dropping duplicates -- including\n@@ -461,7 +461,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     self.candidate_should_be_dropped_in_favor_of(\n                         &candidates[i],\n                         &candidates[j],\n-                        needs_infer,\n+                        has_non_region_infer,\n                     ) == DropVictim::Yes\n                 });\n                 if should_drop_i {\n@@ -1330,7 +1330,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if self.can_use_global_caches(param_env) {\n-            if !trait_pred.needs_infer() {\n+            if !trait_pred.has_infer() {\n                 debug!(?trait_pred, ?result, \"insert_evaluation_cache global\");\n                 // This may overwrite the cache with the same value\n                 // FIXME: Due to #50507 this overwrites the different values\n@@ -1516,7 +1516,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If there are any inference variables in the `ParamEnv`, then we\n         // always use a cache local to this particular scope. Otherwise, we\n         // switch to a global cache.\n-        if param_env.needs_infer() {\n+        if param_env.has_infer() {\n             return false;\n         }\n \n@@ -1587,7 +1587,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return false;\n         }\n         match result {\n-            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.needs_infer(),\n+            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.has_infer(),\n             _ => true,\n         }\n     }\n@@ -1613,8 +1613,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if self.can_use_global_caches(param_env) {\n             if let Err(Overflow(OverflowError::Canonical)) = candidate {\n                 // Don't cache overflow globally; we only produce this in certain modes.\n-            } else if !pred.needs_infer() {\n-                if !candidate.needs_infer() {\n+            } else if !pred.has_infer() {\n+                if !candidate.has_infer() {\n                     debug!(?pred, ?candidate, \"insert_candidate_cache global\");\n                     // This may overwrite the cache with the same value.\n                     tcx.selection_cache.insert((param_env, pred), dep_node, candidate);\n@@ -1724,7 +1724,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n                 // inference variables and placeholders escape.\n-                if !trait_bound.needs_infer() && !trait_bound.has_placeholders() {\n+                if !trait_bound.has_infer() && !trait_bound.has_placeholders() {\n                     Some(trait_bound)\n                 } else {\n                     None\n@@ -1840,7 +1840,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n         &mut self,\n         victim: &EvaluatedCandidate<'tcx>,\n         other: &EvaluatedCandidate<'tcx>,\n-        needs_infer: bool,\n+        has_non_region_infer: bool,\n     ) -> DropVictim {\n         if victim.candidate == other.candidate {\n             return DropVictim::Yes;\n@@ -1956,7 +1956,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                DropVictim::drop_if(i < j && !needs_infer)\n+                DropVictim::drop_if(i < j && !has_non_region_infer)\n             }\n             (ObjectCandidate(_), ProjectionCandidate(..))\n             | (ProjectionCandidate(..), ObjectCandidate(_)) => {\n@@ -2062,7 +2062,8 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                         // existence of multiple marker trait impls tells us nothing\n                         // about which one should actually apply.\n                         DropVictim::drop_if(\n-                            !needs_infer && other.evaluation.must_apply_considering_regions(),\n+                            !has_non_region_infer\n+                                && other.evaluation.must_apply_considering_regions(),\n                         )\n                     }\n                     None => DropVictim::No,"}, {"sha": "c56e7c7cadd81129a1fa02f02131becba4153f0f", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -353,8 +353,8 @@ pub(crate) fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n     ),\n ) -> Option<usize> {\n     let (source, target) = key;\n-    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n-    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n+    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.has_infer());\n+    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.has_infer());\n \n     // this has been typecked-before, so diagnostics is not really needed.\n     let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);"}, {"sha": "5da0f16c2bf05d18127fe1553e3489648cd32eec", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -47,7 +47,7 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<TyCtxt<'tcx>> + Par\n             // us a test case.\n             debug_assert_eq!(normalized_value, resolved_value);\n             let erased = infcx.tcx.erase_regions(resolved_value);\n-            debug_assert!(!erased.needs_infer(), \"{erased:?}\");\n+            debug_assert!(!erased.has_infer(), \"{erased:?}\");\n             Ok(erased)\n         }\n         Err(NoSolution) => Err(NoSolution),"}, {"sha": "64586a6782b18c2848c6d42b0196607fef0ec1ec", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -104,8 +104,8 @@ fn resolve_associated_item<'tcx>(\n                 \"resolving ImplSource::UserDefined: {:?}, {:?}, {:?}, {:?}\",\n                 param_env, trait_item_id, rcvr_substs, impl_data\n             );\n-            assert!(!rcvr_substs.needs_infer());\n-            assert!(!trait_ref.needs_infer());\n+            assert!(!rcvr_substs.has_infer());\n+            assert!(!trait_ref.has_infer());\n \n             let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n             let trait_def = tcx.trait_def(trait_def_id);"}, {"sha": "ddca57e1da25035069413a89ea5b3b366b805224", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -192,7 +192,7 @@ bitflags! {\n \n         /// Does this have inference variables? Used to determine whether\n         /// inference is required.\n-        const NEEDS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n+        const HAS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n                                           | TypeFlags::HAS_RE_INFER.bits\n                                           | TypeFlags::HAS_CT_INFER.bits;\n "}, {"sha": "a65720116440e3bdb5d49db508f5b1b9c1c64fba", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04b8fe0af291a444ecfcf774337966a5cc9d7db/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04b8fe0af291a444ecfcf774337966a5cc9d7db/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=f04b8fe0af291a444ecfcf774337966a5cc9d7db", "patch": "@@ -226,7 +226,7 @@ pub fn implements_trait_with_env<'tcx>(\n     ty_params: impl IntoIterator<Item = Option<GenericArg<'tcx>>>,\n ) -> bool {\n     // Clippy shouldn't have infer types\n-    assert!(!ty.needs_infer());\n+    assert!(!ty.has_infer());\n \n     let ty = tcx.erase_regions(ty);\n     if ty.has_escaping_bound_vars() {"}]}