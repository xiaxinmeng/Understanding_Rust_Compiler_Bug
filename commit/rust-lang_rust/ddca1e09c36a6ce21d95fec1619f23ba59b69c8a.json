{"sha": "ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkY2ExZTA5YzM2YTZjZTIxZDk1ZmVjMTYxOWYyM2JhNTliNjljOGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-11T05:31:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-11T05:31:28Z"}, "message": "Auto merge of #67202 - JohnTitor:rollup-0xjm5pz, r=JohnTitor\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #66377 (Update RELEASES.md for 1.40.0)\n - #67134 (Ensure that we get a hard error on generic ZST constants if their bod\u2026)\n - #67152 (Sort auto trait and blanket implementations display)\n - #67154 (Fix typos in src/libcore/alloc.rs docs)\n - #67168 (corrected comment in E0478)\n - #67178 (Move non clean impls items)\n - #67180 (doc: Use .copied() instead of .cloned() in Vec example)\n - #67181 (Update hashmap doc)\n - #67193 (In which we start tracking polonius in `-Z self-profile`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1d0ebc98f017b59a3a2a5b00ad2ef48cf894bc1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d0ebc98f017b59a3a2a5b00ad2ef48cf894bc1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "html_url": "https://github.com/rust-lang/rust/commit/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2333023594826dc5078ce7129fafb85471b7857", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2333023594826dc5078ce7129fafb85471b7857", "html_url": "https://github.com/rust-lang/rust/commit/a2333023594826dc5078ce7129fafb85471b7857"}, {"sha": "398ed7fe2e81ee6afe200c1d3faa22c6a51d8457", "url": "https://api.github.com/repos/rust-lang/rust/commits/398ed7fe2e81ee6afe200c1d3faa22c6a51d8457", "html_url": "https://github.com/rust-lang/rust/commit/398ed7fe2e81ee6afe200c1d3faa22c6a51d8457"}], "stats": {"total": 1528, "additions": 882, "deletions": 646}, "files": [{"sha": "5afc6f9bdc0cb9d9d24ce1698c34adcaa5e372b0", "filename": "RELEASES.md", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -1,3 +1,140 @@\n+Version 1.40.0 (2019-12-19)\n+===========================\n+\n+Language\n+--------\n+- [You can now use tuple `struct`s and tuple `enum` variant's constructors in\n+  `const` contexts.][65188] e.g.\n+\n+  ```rust\n+  pub struct Point(i32, i32);\n+\n+  const ORIGIN: Point = {\n+      let constructor = Point;\n+\n+      constructor(0, 0)\n+  };\n+  ```\n+\n+- [You can now mark `struct`s, `enum`s, and `enum` variants with the `#[non_exhaustive]` attribute to\n+  indicate that there may be variants or fields added in the future.][64639]\n+  For example this requires adding a wild-card branch (`_ => {}`) to any match\n+  statements on a non-exhaustive `enum`. [(RFC 2008)]\n+- [You can now use function-like procedural macros in `extern` blocks and in\n+  type positions.][63931] e.g. `type Generated = macro!();`\n+- [Function-like and attribute procedural macros can now emit\n+  `macro_rules!` items, so you can now have your macros generate macros.][64035]\n+- [The `meta` pattern matcher in `macro_rules!` now correctly matches the modern\n+  attribute syntax.][63674] For example `(#[$m:meta])` now matches `#[attr]`,\n+  `#[attr{tokens}]`, `#[attr[tokens]]`, and `#[attr(tokens)]`.\n+\n+Compiler\n+--------\n+- [Added tier 3 support\\* for the\n+  `thumbv7neon-unknown-linux-musleabihf` target.][66103]\n+- [Added tier 3 support for the\n+  `aarch64-unknown-none-softfloat` target.][64589]\n+- [Added tier 3 support for the `mips64-unknown-linux-muslabi64`, and\n+  `mips64el-unknown-linux-muslabi64` targets.][65843]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+  information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [The `is_power_of_two` method on unsigned numeric types is now a `const` function.][65092]\n+\n+Stabilized APIs\n+---------------\n+- [`BTreeMap::get_key_value`]\n+- [`HashMap::get_key_value`]\n+- [`Option::as_deref_mut`]\n+- [`Option::as_deref`]\n+- [`Option::flatten`]\n+- [`UdpSocket::peer_addr`]\n+- [`f32::to_be_bytes`]\n+- [`f32::to_le_bytes`]\n+- [`f32::to_ne_bytes`]\n+- [`f64::to_be_bytes`]\n+- [`f64::to_le_bytes`]\n+- [`f64::to_ne_bytes`]\n+- [`f32::from_be_bytes`]\n+- [`f32::from_le_bytes`]\n+- [`f32::from_ne_bytes`]\n+- [`f64::from_be_bytes`]\n+- [`f64::from_le_bytes`]\n+- [`f64::from_ne_bytes`]\n+- [`mem::take`]\n+- [`slice::repeat`]\n+- [`todo!`]\n+\n+Cargo\n+-----\n+- [Cargo will now always display warnings, rather than only on\n+  fresh builds.][cargo/7450]\n+- [Feature flags (except `--all-features`) passed to a virtual workspace will\n+  now produce an error.][cargo/7507] Previously these flags were ignored.\n+- [You can now publish `dev-dependencies` without including\n+  a `version`.][cargo/7333]\n+\n+Misc\n+----\n+- [You can now specify the `#[cfg(doctest)]` attribute to include an item only\n+  when running documentation tests with `rustdoc`.][63803]\n+\n+Compatibility Notes\n+-------------------\n+- [As previously announced, any previous NLL warnings in the 2015 edition are\n+  now hard errors.][64221]\n+- [The `include!` macro will now warn if it failed to include the\n+  entire file.][64284] The `include!` macro unintentionally only includes the\n+  first _expression_ in a file, and this can be unintuitive. This will become\n+  either a hard error in a future release, or the behavior may be fixed to include all expressions as expected.\n+- [Using `#[inline]` on function prototypes and consts now emits a warning under\n+  `unused_attribute` lint.][65294] Using `#[inline]` anywhere else inside traits\n+  or `extern` blocks now correctly emits a hard error.\n+  \n+[65294]: https://github.com/rust-lang/rust/pull/65294/\n+[66103]: https://github.com/rust-lang/rust/pull/66103/\n+[65843]: https://github.com/rust-lang/rust/pull/65843/\n+[65188]: https://github.com/rust-lang/rust/pull/65188/\n+[65092]: https://github.com/rust-lang/rust/pull/65092/\n+[64589]: https://github.com/rust-lang/rust/pull/64589/\n+[64639]: https://github.com/rust-lang/rust/pull/64639/\n+[64221]: https://github.com/rust-lang/rust/pull/64221/\n+[64284]: https://github.com/rust-lang/rust/pull/64284/\n+[63931]: https://github.com/rust-lang/rust/pull/63931/\n+[64035]: https://github.com/rust-lang/rust/pull/64035/\n+[63674]: https://github.com/rust-lang/rust/pull/63674/\n+[63803]: https://github.com/rust-lang/rust/pull/63803/\n+[cargo/7450]: https://github.com/rust-lang/cargo/pull/7450/\n+[cargo/7507]: https://github.com/rust-lang/cargo/pull/7507/\n+[cargo/7525]: https://github.com/rust-lang/cargo/pull/7525/\n+[cargo/7333]: https://github.com/rust-lang/cargo/pull/7333/\n+[(rfc 2008)]: https://rust-lang.github.io/rfcs/2008-non-exhaustive.html\n+[`f32::to_be_bytes`]: https://doc.rust-lang.org/std/primitive.f32.html#method.to_be_bytes\n+[`f32::to_le_bytes`]: https://doc.rust-lang.org/std/primitive.f32.html#method.to_le_bytes\n+[`f32::to_ne_bytes`]: https://doc.rust-lang.org/std/primitive.f32.html#method.to_ne_bytes\n+[`f64::to_be_bytes`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_be_bytes\n+[`f64::to_le_bytes`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_le_bytes\n+[`f64::to_ne_bytes`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_ne_bytes\n+[`f32::from_be_bytes`]: https://doc.rust-lang.org/std/primitive.f32.html#method.from_be_bytes\n+[`f32::from_le_bytes`]: https://doc.rust-lang.org/std/primitive.f32.html#method.from_le_bytes\n+[`f32::from_ne_bytes`]: https://doc.rust-lang.org/std/primitive.f32.html#method.from_ne_bytes\n+[`f64::from_be_bytes`]: https://doc.rust-lang.org/std/primitive.f64.html#method.from_be_bytes\n+[`f64::from_le_bytes`]: https://doc.rust-lang.org/std/primitive.f64.html#method.from_le_bytes\n+[`f64::from_ne_bytes`]: https://doc.rust-lang.org/std/primitive.f64.html#method.from_ne_bytes\n+[`option::flatten`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.flatten\n+[`option::as_deref`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref\n+[`option::as_deref_mut`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref_mut\n+[`hashmap::get_key_value`]: https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get_key_value\n+[`btreemap::get_key_value`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.get_key_value\n+[`slice::repeat`]: https://doc.rust-lang.org/std/primitive.slice.html#method.repeat\n+[`mem::take`]: https://doc.rust-lang.org/std/mem/fn.take.html\n+[`udpsocket::peer_addr`]: https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.peer_addr\n+[`todo!`]: https://doc.rust-lang.org/std/macro.todo.html\n+\n+\n Version 1.39.0 (2019-11-07)\n ===========================\n "}, {"sha": "6e165ccb91998a7eb37b64ead5f6961445332723", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -92,7 +92,7 @@ use crate::raw_vec::RawVec;\n /// vec[0] = 7;\n /// assert_eq!(vec[0], 7);\n ///\n-/// vec.extend([1, 2, 3].iter().cloned());\n+/// vec.extend([1, 2, 3].iter().copied());\n ///\n /// for x in &vec {\n ///     println!(\"{}\", x);"}, {"sha": "4cfd6527deb0a556cef9c7db657dc5bc5ac39a83", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -253,7 +253,7 @@ impl Layout {\n \n     /// Creates a layout describing the record for `self` followed by\n     /// `next`, including any necessary padding to ensure that `next`\n-    /// will be properly aligned. Note that the result layout will\n+    /// will be properly aligned. Note that the resulting layout will\n     /// satisfy the alignment properties of both `self` and `next`.\n     ///\n     /// The resulting layout will be the same as that of a C struct containing\n@@ -387,7 +387,7 @@ impl fmt::Display for CannotReallocInPlace {\n }\n \n /// A memory allocator that can be registered as the standard library\u2019s default\n-/// though the `#[global_allocator]` attributes.\n+/// through the `#[global_allocator]` attribute.\n ///\n /// Some of the methods require that a memory block be *currently\n /// allocated* via an allocator. This means that:\n@@ -458,7 +458,7 @@ pub unsafe trait GlobalAlloc {\n     /// # Errors\n     ///\n     /// Returning a null pointer indicates that either memory is exhausted\n-    /// or `layout` does not meet allocator's size or alignment constraints.\n+    /// or `layout` does not meet this allocator's size or alignment constraints.\n     ///\n     /// Implementations are encouraged to return null on memory\n     /// exhaustion rather than aborting, but this is not\n@@ -1045,7 +1045,7 @@ pub unsafe trait Alloc {\n     /// Captures a common usage pattern for allocators.\n     ///\n     /// The returned block is suitable for passing to the\n-    /// `alloc`/`realloc` methods of this allocator.\n+    /// `realloc`/`dealloc` methods of this allocator.\n     ///\n     /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n     /// must be considered \"currently allocated\" and must be\n@@ -1111,7 +1111,7 @@ pub unsafe trait Alloc {\n     /// Captures a common usage pattern for allocators.\n     ///\n     /// The returned block is suitable for passing to the\n-    /// `alloc`/`realloc` methods of this allocator.\n+    /// `realloc`/`dealloc` methods of this allocator.\n     ///\n     /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n     /// must be considered \"currently allocated\" and must be\n@@ -1158,7 +1158,7 @@ pub unsafe trait Alloc {\n     /// Captures a common usage pattern for allocators.\n     ///\n     /// The returned block is suitable for passing to the\n-    /// `alloc`/`realloc` methods of this allocator.\n+    /// `realloc`/`dealloc` methods of this allocator.\n     ///\n     /// # Safety\n     ///"}, {"sha": "fb8f504d04b10e118e8c1e7153e06aa6db4c824c", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -16,6 +16,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<OperandRef<'tcx, Bx::Value>, ErrorHandled> {\n         match constant.literal.val {\n+            // Special case unevaluated statics, because statics have an identity and thus should\n+            // use `get_static` to get at their id.\n+            // FIXME(oli-obk): can we unify this somehow, maybe by making const eval of statics\n+            // always produce `&STATIC`. This may also simplify how const eval works with statics.\n             ty::ConstKind::Unevaluated(def_id, substs)\n                 if self.cx.tcx().is_static(def_id) => {\n                     assert!(substs.is_empty(), \"we don't support generic statics yet\");\n@@ -46,7 +50,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     instance,\n                     promoted: None,\n                 };\n-                self.cx.tcx().const_eval(ty::ParamEnv::reveal_all().and(cid))\n+                self.cx.tcx().const_eval(ty::ParamEnv::reveal_all().and(cid)).map_err(|err| {\n+                    self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+                    err\n+                })\n             },\n             _ => Ok(self.monomorphize(&constant.literal)),\n         }"}, {"sha": "4bc5fde2e897e05ad709a3157dea2bfa5accedab", "filename": "src/librustc_error_codes/error_codes/E0478.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -21,8 +21,8 @@ this issue, you need to specify it:\n ```\n trait Wedding<'t>: 't { }\n \n-struct Prince<'kiss, 'SnowWhite: 'kiss> { // You say here that 'kiss must live\n-                                          // longer than 'SnowWhite.\n+struct Prince<'kiss, 'SnowWhite: 'kiss> { // You say here that 'SnowWhite\n+                                          // must live longer than 'kiss.\n     child: Box<Wedding<'kiss> + 'SnowWhite>, // And now it's all good!\n }\n ```"}, {"sha": "dbeccab966bbb15566f6ff694d456e27bc67ecd0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -97,6 +97,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n         location: Location,\n     ) {\n         if let Some(all_facts) = self.all_facts {\n+            let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n             all_facts.cfg_edge.push((\n                 self.location_table.start_index(location),\n                 self.location_table.mid_index(location),\n@@ -142,6 +143,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n         location: Location,\n     ) {\n         if let Some(all_facts) = self.all_facts {\n+            let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n             all_facts.cfg_edge.push((\n                 self.location_table.start_index(location),\n                 self.location_table.mid_index(location),\n@@ -205,6 +207,8 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n     /// as `killed`. For example, when assigning to a local, or on a call's return destination.\n     fn record_killed_borrows_for_place(&mut self, place: &Place<'tcx>, location: Location) {\n         if let Some(all_facts) = self.all_facts {\n+            let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n+\n             // Depending on the `Place` we're killing:\n             // - if it's a local, or a single deref of a local,\n             //   we kill all the borrows on the local."}, {"sha": "e442f9c9e322fed252a628c21b18328de61c964f", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -31,6 +31,7 @@ pub(super) fn generate_invalidates<'tcx>(\n     }\n \n     if let Some(all_facts) = all_facts {\n+        let _prof_timer = tcx.prof.generic_activity(\"polonius_fact_generation\");\n         let dominators = body.dominators();\n         let mut ig = InvalidationGenerator {\n             all_facts,"}, {"sha": "9ea3bd8899b9d59fdec568b50ab9b989a674c1a2", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -201,6 +201,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     );\n \n     if let Some(all_facts) = &mut all_facts {\n+        let _prof_timer = infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n@@ -302,6 +303,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n                 .unwrap_or_else(|_| String::from(\"Naive\"));\n             let algorithm = Algorithm::from_str(&algorithm).unwrap();\n             debug!(\"compute_regions: using polonius algorithm {:?}\", algorithm);\n+            let _prof_timer = infcx.tcx.prof.generic_activity(\"polonius_analysis\");\n             Some(Rc::new(Output::compute(\n                 &all_facts,\n                 algorithm,"}, {"sha": "0354b0d6b92c525b52d153a55ab41dd06275fdfd", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -5,20 +5,19 @@ use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::{Local, Location, Place, ReadOnlyBodyAndCache};\n use rustc::ty::subst::GenericArg;\n-use rustc::ty::Ty;\n \n use super::TypeChecker;\n \n-type VarPointRelations = Vec<(Local, LocationIndex)>;\n-type MovePathPointRelations = Vec<(MovePathIndex, LocationIndex)>;\n+type VarPointRelation = Vec<(Local, LocationIndex)>;\n+type PathPointRelation = Vec<(MovePathIndex, LocationIndex)>;\n \n struct UseFactsExtractor<'me> {\n-    var_defined: &'me mut VarPointRelations,\n-    var_used: &'me mut VarPointRelations,\n+    var_defined: &'me mut VarPointRelation,\n+    var_used: &'me mut VarPointRelation,\n     location_table: &'me LocationTable,\n     var_drop_used: &'me mut Vec<(Local, Location)>,\n     move_data: &'me MoveData<'me>,\n-    path_accessed_at: &'me mut MovePathPointRelations,\n+    path_accessed_at: &'me mut PathPointRelation,\n }\n \n // A Visitor to walk through the MIR and extract point-wise facts\n@@ -28,22 +27,22 @@ impl UseFactsExtractor<'_> {\n     }\n \n     fn insert_def(&mut self, local: Local, location: Location) {\n-        debug!(\"LivenessFactsExtractor::insert_def()\");\n+        debug!(\"UseFactsExtractor::insert_def()\");\n         self.var_defined.push((local, self.location_to_index(location)));\n     }\n \n     fn insert_use(&mut self, local: Local, location: Location) {\n-        debug!(\"LivenessFactsExtractor::insert_use()\");\n+        debug!(\"UseFactsExtractor::insert_use()\");\n         self.var_used.push((local, self.location_to_index(location)));\n     }\n \n     fn insert_drop_use(&mut self, local: Local, location: Location) {\n-        debug!(\"LivenessFactsExtractor::insert_drop_use()\");\n+        debug!(\"UseFactsExtractor::insert_drop_use()\");\n         self.var_drop_used.push((local, location));\n     }\n \n     fn insert_path_access(&mut self, path: MovePathIndex, location: Location) {\n-        debug!(\"LivenessFactsExtractor::insert_path_access({:?}, {:?})\", path, location);\n+        debug!(\"UseFactsExtractor::insert_path_access({:?}, {:?})\", path, location);\n         self.path_accessed_at.push((path, self.location_to_index(location)));\n     }\n \n@@ -84,44 +83,39 @@ impl Visitor<'tcx> for UseFactsExtractor<'_> {\n     }\n }\n \n-fn add_var_uses_regions(typeck: &mut TypeChecker<'_, 'tcx>, local: Local, ty: Ty<'tcx>) {\n-    debug!(\"add_regions(local={:?}, type={:?})\", local, ty);\n-    typeck.tcx().for_each_free_region(&ty, |region| {\n-        let region_vid = typeck.borrowck_context.universal_regions.to_region_vid(region);\n-        debug!(\"add_regions for region {:?}\", region_vid);\n-        if let Some(facts) = typeck.borrowck_context.all_facts {\n-            facts.var_uses_region.push((local, region_vid));\n-        }\n-    });\n-}\n-\n pub(super) fn populate_access_facts(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n     location_table: &LocationTable,\n     move_data: &MoveData<'_>,\n     drop_used: &mut Vec<(Local, Location)>,\n ) {\n-    debug!(\"populate_var_liveness_facts()\");\n+    debug!(\"populate_access_facts()\");\n \n     if let Some(facts) = typeck.borrowck_context.all_facts.as_mut() {\n-        UseFactsExtractor {\n+        let mut extractor = UseFactsExtractor {\n             var_defined: &mut facts.var_defined,\n             var_used: &mut facts.var_used,\n             var_drop_used: drop_used,\n             path_accessed_at: &mut facts.path_accessed_at,\n             location_table,\n             move_data,\n-        }\n-        .visit_body(body);\n+        };\n+        extractor.visit_body(body);\n \n         facts.var_drop_used.extend(drop_used.iter().map(|&(local, location)| {\n             (local, location_table.mid_index(location))\n         }));\n-    }\n \n-    for (local, local_decl) in body.local_decls.iter_enumerated() {\n-        add_var_uses_regions(typeck, local, local_decl.ty);\n+        for (local, local_decl) in body.local_decls.iter_enumerated() {\n+            debug!(\"add var_uses_regions facts - local={:?}, type={:?}\", local, local_decl.ty);\n+            let _prof_timer = typeck.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n+            let universal_regions = &typeck.borrowck_context.universal_regions;\n+            typeck.infcx.tcx.for_each_free_region(&local_decl.ty, |region| {\n+                let region_vid = universal_regions.to_region_vid(region);\n+                facts.var_uses_region.push((local, region_vid));\n+            });\n+        }\n     }\n }\n \n@@ -133,12 +127,12 @@ pub(super) fn add_var_drops_regions(\n     kind: &GenericArg<'tcx>,\n ) {\n     debug!(\"add_var_drops_region(local={:?}, kind={:?}\", local, kind);\n-    let tcx = typeck.tcx();\n-\n-    tcx.for_each_free_region(kind, |drop_live_region| {\n-        let region_vid = typeck.borrowck_context.universal_regions.to_region_vid(drop_live_region);\n-        if let Some(facts) = typeck.borrowck_context.all_facts.as_mut() {\n+    if let Some(facts) = typeck.borrowck_context.all_facts.as_mut() {\n+        let _prof_timer = typeck.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n+        let universal_regions = &typeck.borrowck_context.universal_regions;\n+        typeck.infcx.tcx.for_each_free_region(kind, |drop_live_region| {\n+            let region_vid = universal_regions.to_region_vid(drop_live_region);\n             facts.var_drops_region.push((local, region_vid));\n-        };\n-    });\n+        });\n+    }\n }"}, {"sha": "cddc3b4a271d4de64c76c73a0c02e551348eff3e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -182,7 +182,7 @@ pub(crate) fn type_check<'tcx>(\n                 move_data,\n                 location_table);\n \n-            translate_outlives_facts(cx.borrowck_context);\n+            translate_outlives_facts(&mut cx);\n         },\n     );\n \n@@ -228,8 +228,10 @@ fn type_check_internal<'a, 'tcx, R>(\n     extra(&mut checker)\n }\n \n-fn translate_outlives_facts(cx: &mut BorrowCheckContext<'_, '_>) {\n+fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n+    let cx = &mut typeck.borrowck_context;\n     if let Some(facts) = cx.all_facts {\n+        let _prof_timer = typeck.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n         let location_table = cx.location_table;\n         facts\n             .outlives\n@@ -2489,6 +2491,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // that occurs when we are borrowing an unsafe place, for\n         // example).\n         if let Some(all_facts) = all_facts {\n+            let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n             if let Some(borrow_index) = borrow_set.location_map.get(&location) {\n                 let region_vid = borrow_region.to_region_vid();\n                 all_facts.borrow_region.push(("}, {"sha": "628ac721adc59886ca8954b70940253680357cfb", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -29,7 +29,7 @@\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, Visitor, PlaceContext, MutatingUseContext};\n use std::borrow::Cow;\n@@ -367,9 +367,14 @@ impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n                 if let StatementKind::Assign(\n                     box (p, Rvalue::Use(Operand::Constant(c)))\n                 ) = &stmt.kind {\n-                    if !p.is_indirect() {\n-                        trace!(\"skipping store of const value {:?} to {:?}\", c, p);\n-                        return;\n+                    match c.literal.val {\n+                        // Keep assignments from unevaluated constants around, since the evaluation\n+                        // may report errors, even if the use of the constant is dead code.\n+                        ty::ConstKind::Unevaluated(..) => {}\n+                        _ => if !p.is_indirect() {\n+                            trace!(\"skipping store of const value {:?} to {:?}\", c, p);\n+                            return;\n+                        },\n                     }\n                 }\n             }"}, {"sha": "e198b008753ede7c0b0dabe8c9a9bb40e01173bb", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -1,10 +1,24 @@\n use rustc::hir;\n use rustc::traits::auto_trait::{self, AutoTraitResult};\n-use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::{self, Region, RegionVid, TypeFoldable};\n+use rustc::util::nodemap::FxHashSet;\n+\n use std::fmt::Debug;\n \n use super::*;\n \n+#[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n+enum RegionTarget<'tcx> {\n+    Region(Region<'tcx>),\n+    RegionVid(RegionVid)\n+}\n+\n+#[derive(Default, Debug, Clone)]\n+struct RegionDeps<'tcx> {\n+    larger: FxHashSet<RegionTarget<'tcx>>,\n+    smaller: FxHashSet<RegionTarget<'tcx>>\n+}\n+\n pub struct AutoTraitFinder<'a, 'tcx> {\n     pub cx: &'a core::DocContext<'tcx>,\n     pub f: auto_trait::AutoTraitFinder<'tcx>,"}, {"sha": "e5f684cbca87bffb3b7ab372417e2b430bdc8f4e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 587, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -1,10 +1,9 @@\n-// ignore-tidy-filelength\n-\n //! This module contains the \"cleaned\" pieces of the AST, and the functions\n //! that clean them.\n \n pub mod inline;\n pub mod cfg;\n+pub mod utils;\n mod auto_trait;\n mod blanket_impl;\n mod simplify;\n@@ -19,15 +18,15 @@ use rustc::middle::stability;\n use rustc::mir::interpret::GlobalId;\n use rustc::hir;\n use rustc::hir::def::{CtorKind, DefKind, Res};\n-use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc::hir::ptr::P;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef, GenericArgKind};\n-use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n+use rustc::ty::subst::InternalSubsts;\n+use rustc::ty::{self, TyCtxt, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax_pos::symbol::{Symbol, kw, sym};\n+use syntax_pos::symbol::{kw, sym};\n use syntax_pos::hygiene::MacroKind;\n use syntax_pos::{self, Pos};\n \n@@ -41,8 +40,9 @@ use std::u32;\n use crate::core::{self, DocContext, ImplTraitParam};\n use crate::doctree;\n \n-use self::auto_trait::AutoTraitFinder;\n-use self::blanket_impl::BlanketImplFinder;\n+use utils::*;\n+\n+pub use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n pub use self::types::*;\n pub use self::types::Type::*;\n@@ -54,15 +54,6 @@ pub use self::types::Visibility::{Public, Inherited};\n \n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n-// extract the stability index for a node from tcx, if possible\n-fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n-    cx.tcx.lookup_stability(def_id).clean(cx)\n-}\n-\n-fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n-    cx.tcx.lookup_deprecation(def_id).clean(cx)\n-}\n-\n pub trait Clean<T> {\n     fn clean(&self, cx: &DocContext<'_>) -> T;\n }\n@@ -109,91 +100,6 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n     }\n }\n \n-pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n-    use crate::visit_lib::LibEmbargoVisitor;\n-\n-    let krate = cx.tcx.hir().krate();\n-    let module = crate::visit_ast::RustdocVisitor::new(&mut cx).visit(krate);\n-\n-    let mut r = cx.renderinfo.get_mut();\n-    r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-    r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-    r.owned_box_did = cx.tcx.lang_items().owned_box();\n-\n-    let mut externs = Vec::new();\n-    for &cnum in cx.tcx.crates().iter() {\n-        externs.push((cnum, cnum.clean(cx)));\n-        // Analyze doc-reachability for extern items\n-        LibEmbargoVisitor::new(&mut cx).visit_lib(cnum);\n-    }\n-    externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n-\n-    // Clean the crate, translating the entire libsyntax AST to one that is\n-    // understood by rustdoc.\n-    let mut module = module.clean(cx);\n-    let mut masked_crates = FxHashSet::default();\n-\n-    match module.inner {\n-        ModuleItem(ref module) => {\n-            for it in &module.items {\n-                // `compiler_builtins` should be masked too, but we can't apply\n-                // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n-                if it.is_extern_crate()\n-                    && (it.attrs.has_doc_flag(sym::masked)\n-                        || cx.tcx.is_compiler_builtins(it.def_id.krate))\n-                {\n-                    masked_crates.insert(it.def_id.krate);\n-                }\n-            }\n-        }\n-        _ => unreachable!(),\n-    }\n-\n-    let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n-    {\n-        let m = match module.inner {\n-            ModuleItem(ref mut m) => m,\n-            _ => unreachable!(),\n-        };\n-        m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n-            Item {\n-                source: Span::empty(),\n-                name: Some(prim.to_url_str().to_string()),\n-                attrs: attrs.clone(),\n-                visibility: Public,\n-                stability: get_stability(cx, def_id),\n-                deprecation: get_deprecation(cx, def_id),\n-                def_id,\n-                inner: PrimitiveItem(prim),\n-            }\n-        }));\n-        m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n-            Item {\n-                source: Span::empty(),\n-                name: Some(kw.clone()),\n-                attrs,\n-                visibility: Public,\n-                stability: get_stability(cx, def_id),\n-                deprecation: get_deprecation(cx, def_id),\n-                def_id,\n-                inner: KeywordItem(kw),\n-            }\n-        }));\n-    }\n-\n-    Crate {\n-        name,\n-        version: None,\n-        src,\n-        module: Some(module),\n-        externs,\n-        primitives,\n-        external_traits: cx.external_traits.clone(),\n-        masked_crates,\n-        collapsed: false,\n-    }\n-}\n-\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n@@ -394,66 +300,6 @@ impl Clean<GenericBound> for hir::GenericBound {\n     }\n }\n \n-fn external_generic_args(\n-    cx: &DocContext<'_>,\n-    trait_did: Option<DefId>,\n-    has_self: bool,\n-    bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n-) -> GenericArgs {\n-    let mut skip_self = has_self;\n-    let mut ty_kind = None;\n-    let args: Vec<_> = substs.iter().filter_map(|kind| match kind.unpack() {\n-        GenericArgKind::Lifetime(lt) => {\n-            lt.clean(cx).and_then(|lt| Some(GenericArg::Lifetime(lt)))\n-        }\n-        GenericArgKind::Type(_) if skip_self => {\n-            skip_self = false;\n-            None\n-        }\n-        GenericArgKind::Type(ty) => {\n-            ty_kind = Some(&ty.kind);\n-            Some(GenericArg::Type(ty.clean(cx)))\n-        }\n-        GenericArgKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n-    }).collect();\n-\n-    match trait_did {\n-        // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n-            assert!(ty_kind.is_some());\n-            let inputs = match ty_kind {\n-                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n-                _ => return GenericArgs::AngleBracketed { args, bindings },\n-            };\n-            let output = None;\n-            // FIXME(#20299) return type comes from a projection now\n-            // match types[1].kind {\n-            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n-            //     _ => Some(types[1].clean(cx))\n-            // };\n-            GenericArgs::Parenthesized { inputs, output }\n-        },\n-        _ => {\n-            GenericArgs::AngleBracketed { args, bindings }\n-        }\n-    }\n-}\n-\n-// trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n-// from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext<'_>, name: Symbol, trait_did: Option<DefId>, has_self: bool,\n-                 bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> Path {\n-    Path {\n-        global: false,\n-        res: Res::Err,\n-        segments: vec![PathSegment {\n-            name: name.to_string(),\n-            args: external_generic_args(cx, trait_did, has_self, bindings, substs)\n-        }],\n-    }\n-}\n-\n impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         let (trait_ref, ref bounds) = *self;\n@@ -1036,118 +882,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n     }\n }\n \n-/// The point of this function is to replace bounds with types.\n-///\n-/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n-/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n-/// wrapped types in here).\n-fn get_real_types(\n-    generics: &Generics,\n-    arg: &Type,\n-    cx: &DocContext<'_>,\n-    recurse: i32,\n-) -> FxHashSet<Type> {\n-    let arg_s = arg.print().to_string();\n-    let mut res = FxHashSet::default();\n-    if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n-        return res;\n-    }\n-    if arg.is_full_generic() {\n-        if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n-            match g {\n-                &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n-                _ => false,\n-            }\n-        }) {\n-            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n-            for bound in bounds.iter() {\n-                match *bound {\n-                    GenericBound::TraitBound(ref poly_trait, _) => {\n-                        for x in poly_trait.generic_params.iter() {\n-                            if !x.is_type() {\n-                                continue\n-                            }\n-                            if let Some(ty) = x.get_type() {\n-                                let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                                if !adds.is_empty() {\n-                                    res.extend(adds);\n-                                } else if !ty.is_full_generic() {\n-                                    res.insert(ty);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        if let Some(bound) = generics.params.iter().find(|g| {\n-            g.is_type() && g.name == arg_s\n-        }) {\n-            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n-                if let Some(ty) = bound.get_trait_type() {\n-                    let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                    if !adds.is_empty() {\n-                        res.extend(adds);\n-                    } else if !ty.is_full_generic() {\n-                        res.insert(ty.clone());\n-                    }\n-                }\n-            }\n-        }\n-    } else {\n-        res.insert(arg.clone());\n-        if let Some(gens) = arg.generics() {\n-            for gen in gens.iter() {\n-                if gen.is_full_generic() {\n-                    let adds = get_real_types(generics, gen, cx, recurse + 1);\n-                    if !adds.is_empty() {\n-                        res.extend(adds);\n-                    }\n-                } else {\n-                    res.insert(gen.clone());\n-                }\n-            }\n-        }\n-    }\n-    res\n-}\n-\n-/// Return the full list of types when bounds have been resolved.\n-///\n-/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n-/// `[u32, Display, Option]`.\n-pub fn get_all_types(\n-    generics: &Generics,\n-    decl: &FnDecl,\n-    cx: &DocContext<'_>,\n-) -> (Vec<Type>, Vec<Type>) {\n-    let mut all_types = FxHashSet::default();\n-    for arg in decl.inputs.values.iter() {\n-        if arg.type_.is_self_type() {\n-            continue;\n-        }\n-        let args = get_real_types(generics, &arg.type_, cx, 0);\n-        if !args.is_empty() {\n-            all_types.extend(args);\n-        } else {\n-            all_types.insert(arg.type_.clone());\n-        }\n-    }\n-\n-    let ret_types = match decl.output {\n-        FunctionRetTy::Return(ref return_type) => {\n-            let mut ret = get_real_types(generics, &return_type, cx, 0);\n-            if ret.is_empty() {\n-                ret.insert(return_type.clone());\n-            }\n-            ret.into_iter().collect()\n-        }\n-        _ => Vec::new(),\n-    };\n-    (all_types.into_iter().collect(), ret_types)\n-}\n-\n impl<'a> Clean<Method> for (&'a hir::FnSig, &'a hir::Generics, hir::BodyId,\n                             Option<hir::Defaultness>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Method {\n@@ -2262,66 +1996,6 @@ impl Clean<PathSegment> for hir::PathSegment {\n     }\n }\n \n-fn strip_type(ty: Type) -> Type {\n-    match ty {\n-        Type::ResolvedPath { path, param_names, did, is_generic } => {\n-            Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n-        }\n-        Type::Tuple(inner_tys) => {\n-            Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n-        }\n-        Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n-        Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n-        Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n-        Type::BorrowedRef { lifetime, mutability, type_ } => {\n-            Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n-        }\n-        Type::QPath { name, self_type, trait_ } => {\n-            Type::QPath {\n-                name,\n-                self_type: Box::new(strip_type(*self_type)), trait_: Box::new(strip_type(*trait_))\n-            }\n-        }\n-        _ => ty\n-    }\n-}\n-\n-fn strip_path(path: &Path) -> Path {\n-    let segments = path.segments.iter().map(|s| {\n-        PathSegment {\n-            name: s.name.clone(),\n-            args: GenericArgs::AngleBracketed {\n-                args: vec![],\n-                bindings: vec![],\n-            }\n-        }\n-    }).collect();\n-\n-    Path {\n-        global: path.global,\n-        res: path.res.clone(),\n-        segments,\n-    }\n-}\n-\n-fn qpath_to_string(p: &hir::QPath) -> String {\n-    let segments = match *p {\n-        hir::QPath::Resolved(_, ref path) => &path.segments,\n-        hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n-    };\n-\n-    let mut s = String::new();\n-    for (i, seg) in segments.iter().enumerate() {\n-        if i > 0 {\n-            s.push_str(\"::\");\n-        }\n-        if seg.ident.name != kw::PathRoot {\n-            s.push_str(&seg.ident.as_str());\n-        }\n-    }\n-    s\n-}\n-\n impl Clean<String> for Ident {\n     #[inline]\n     fn clean(&self, cx: &DocContext<'_>) -> String {\n@@ -2444,15 +2118,6 @@ impl Clean<ImplPolarity> for ty::ImplPolarity {\n     }\n }\n \n-pub fn get_auto_trait_and_blanket_impls(\n-    cx: &DocContext<'tcx>,\n-    ty: Ty<'tcx>,\n-    param_env_def_id: DefId,\n-) -> impl Iterator<Item = Item> {\n-    AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id).into_iter()\n-        .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n-}\n-\n impl Clean<Vec<Item>> for doctree::Impl<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let mut ret = Vec::new();\n@@ -2497,63 +2162,6 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n     }\n }\n \n-fn build_deref_target_impls(cx: &DocContext<'_>,\n-                            items: &[Item],\n-                            ret: &mut Vec<Item>) {\n-    use self::PrimitiveType::*;\n-    let tcx = cx.tcx;\n-\n-    for item in items {\n-        let target = match item.inner {\n-            TypedefItem(ref t, true) => &t.type_,\n-            _ => continue,\n-        };\n-        let primitive = match *target {\n-            ResolvedPath { did, .. } if did.is_local() => continue,\n-            ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, did, None));\n-                continue\n-            }\n-            _ => match target.primitive_type() {\n-                Some(prim) => prim,\n-                None => continue,\n-            }\n-        };\n-        let did = match primitive {\n-            Isize => tcx.lang_items().isize_impl(),\n-            I8 => tcx.lang_items().i8_impl(),\n-            I16 => tcx.lang_items().i16_impl(),\n-            I32 => tcx.lang_items().i32_impl(),\n-            I64 => tcx.lang_items().i64_impl(),\n-            I128 => tcx.lang_items().i128_impl(),\n-            Usize => tcx.lang_items().usize_impl(),\n-            U8 => tcx.lang_items().u8_impl(),\n-            U16 => tcx.lang_items().u16_impl(),\n-            U32 => tcx.lang_items().u32_impl(),\n-            U64 => tcx.lang_items().u64_impl(),\n-            U128 => tcx.lang_items().u128_impl(),\n-            F32 => tcx.lang_items().f32_impl(),\n-            F64 => tcx.lang_items().f64_impl(),\n-            Char => tcx.lang_items().char_impl(),\n-            Bool => tcx.lang_items().bool_impl(),\n-            Str => tcx.lang_items().str_impl(),\n-            Slice => tcx.lang_items().slice_impl(),\n-            Array => tcx.lang_items().slice_impl(),\n-            Tuple => None,\n-            Unit => None,\n-            RawPointer => tcx.lang_items().const_ptr_impl(),\n-            Reference => None,\n-            Fn => None,\n-            Never => None,\n-        };\n-        if let Some(did) = did {\n-            if !did.is_local() {\n-                inline::build_impl(cx, did, None, ret);\n-            }\n-        }\n-    }\n-}\n-\n impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n@@ -2710,170 +2318,6 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n     }\n }\n \n-// Utilities\n-\n-pub trait ToSource {\n-    fn to_src(&self, cx: &DocContext<'_>) -> String;\n-}\n-\n-impl ToSource for syntax_pos::Span {\n-    fn to_src(&self, cx: &DocContext<'_>) -> String {\n-        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n-        let sn = match cx.sess().source_map().span_to_snippet(*self) {\n-            Ok(x) => x,\n-            Err(_) => String::new()\n-        };\n-        debug!(\"got snippet {}\", sn);\n-        sn\n-    }\n-}\n-\n-fn name_from_pat(p: &hir::Pat) -> String {\n-    use rustc::hir::*;\n-    debug!(\"trying to get a name from pattern: {:?}\", p);\n-\n-    match p.kind {\n-        PatKind::Wild => \"_\".to_string(),\n-        PatKind::Binding(_, _, ident, _) => ident.to_string(),\n-        PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n-        PatKind::Struct(ref name, ref fields, etc) => {\n-            format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n-                fields.iter().map(|fp| format!(\"{}: {}\", fp.ident, name_from_pat(&fp.pat)))\n-                             .collect::<Vec<String>>().join(\", \"),\n-                if etc { \", ..\" } else { \"\" }\n-            )\n-        }\n-        PatKind::Or(ref pats) => {\n-            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n-        }\n-        PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n-                                            .collect::<Vec<String>>().join(\", \")),\n-        PatKind::Box(ref p) => name_from_pat(&**p),\n-        PatKind::Ref(ref p, _) => name_from_pat(&**p),\n-        PatKind::Lit(..) => {\n-            warn!(\"tried to get argument name from PatKind::Lit, \\\n-                  which is silly in function arguments\");\n-            \"()\".to_string()\n-        },\n-        PatKind::Range(..) => panic!(\"tried to get argument name from PatKind::Range, \\\n-                              which is not allowed in function arguments\"),\n-        PatKind::Slice(ref begin, ref mid, ref end) => {\n-            let begin = begin.iter().map(|p| name_from_pat(&**p));\n-            let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n-            let end = end.iter().map(|p| name_from_pat(&**p));\n-            format!(\"[{}]\", begin.chain(mid).chain(end).collect::<Vec<_>>().join(\", \"))\n-        },\n-    }\n-}\n-\n-fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n-    match n.val {\n-        ty::ConstKind::Unevaluated(def_id, _) => {\n-            if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n-                print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n-            } else {\n-                inline::print_inlined_const(cx, def_id)\n-            }\n-        },\n-        _ => {\n-            let mut s = n.to_string();\n-            // array lengths are obviously usize\n-            if s.ends_with(\"usize\") {\n-                let n = s.len() - \"usize\".len();\n-                s.truncate(n);\n-                if s.ends_with(\": \") {\n-                    let n = s.len() - \": \".len();\n-                    s.truncate(n);\n-                }\n-            }\n-            s\n-        },\n-    }\n-}\n-\n-fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n-    cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n-}\n-\n-/// Given a type Path, resolve it to a Type using the TyCtxt\n-fn resolve_type(cx: &DocContext<'_>,\n-                path: Path,\n-                id: hir::HirId) -> Type {\n-    if id == hir::DUMMY_HIR_ID {\n-        debug!(\"resolve_type({:?})\", path);\n-    } else {\n-        debug!(\"resolve_type({:?},{:?})\", path, id);\n-    }\n-\n-    let is_generic = match path.res {\n-        Res::PrimTy(p) => match p {\n-            hir::Str => return Primitive(PrimitiveType::Str),\n-            hir::Bool => return Primitive(PrimitiveType::Bool),\n-            hir::Char => return Primitive(PrimitiveType::Char),\n-            hir::Int(int_ty) => return Primitive(int_ty.into()),\n-            hir::Uint(uint_ty) => return Primitive(uint_ty.into()),\n-            hir::Float(float_ty) => return Primitive(float_ty.into()),\n-        },\n-        Res::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(kw::SelfUpper.to_string());\n-        }\n-        Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(format!(\"{:#}\", path.print()));\n-        }\n-        Res::SelfTy(..)\n-        | Res::Def(DefKind::TyParam, _)\n-        | Res::Def(DefKind::AssocTy, _) => true,\n-        _ => false,\n-    };\n-    let did = register_res(&*cx, path.res);\n-    ResolvedPath { path, param_names: None, did, is_generic }\n-}\n-\n-pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n-    debug!(\"register_res({:?})\", res);\n-\n-    let (did, kind) = match res {\n-        Res::Def(DefKind::Fn, i) => (i, TypeKind::Function),\n-        Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n-        Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n-        Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n-        Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n-        Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n-        Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),\n-        Res::Def(DefKind::ForeignTy, i) => (i, TypeKind::Foreign),\n-        Res::Def(DefKind::Const, i) => (i, TypeKind::Const),\n-        Res::Def(DefKind::Static, i) => (i, TypeKind::Static),\n-        Res::Def(DefKind::Variant, i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n-                            TypeKind::Enum),\n-        Res::Def(DefKind::Macro(mac_kind), i) => match mac_kind {\n-            MacroKind::Bang => (i, TypeKind::Macro),\n-            MacroKind::Attr => (i, TypeKind::Attr),\n-            MacroKind::Derive => (i, TypeKind::Derive),\n-        },\n-        Res::Def(DefKind::TraitAlias, i) => (i, TypeKind::TraitAlias),\n-        Res::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n-        Res::SelfTy(_, Some(impl_def_id)) => return impl_def_id,\n-        _ => return res.def_id()\n-    };\n-    if did.is_local() { return did }\n-    inline::record_extern_fqn(cx, did, kind);\n-    if let TypeKind::Trait = kind {\n-        inline::record_extern_trait(cx, did);\n-    }\n-    did\n-}\n-\n-fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n-    ImportSource {\n-        did: if path.res.opt_def_id().is_none() {\n-            None\n-        } else {\n-            Some(register_res(cx, path.res))\n-        },\n-        path,\n-    }\n-}\n-\n impl Clean<Item> for doctree::Macro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = self.name.clean(cx);\n@@ -2981,29 +2425,6 @@ impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n     }\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n-where\n-    F: FnOnce() -> R,\n-{\n-    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.borrow_mut());\n-    let r = f();\n-    assert!(cx.impl_trait_bounds.borrow().is_empty());\n-    *cx.impl_trait_bounds.borrow_mut() = old_bounds;\n-    r\n-}\n-\n-#[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n-enum RegionTarget<'tcx> {\n-    Region(Region<'tcx>),\n-    RegionVid(RegionVid)\n-}\n-\n-#[derive(Default, Debug, Clone)]\n-struct RegionDeps<'tcx> {\n-    larger: FxHashSet<RegionTarget<'tcx>>,\n-    smaller: FxHashSet<RegionTarget<'tcx>>\n-}\n-\n enum SimpleBound {\n     TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier),\n     Outlives(Lifetime),"}, {"sha": "e46300a8a5713062478fe558ad73f938eac6f0ad", "filename": "src/librustdoc/clean/utils.rs", "status": "added", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -0,0 +1,585 @@\n+use crate::core::DocContext;\n+use crate::clean::{\n+    Clean, Crate, Deprecation, ExternalCrate, FnDecl, FunctionRetTy, Generic, GenericArg,\n+    GenericArgs, Generics, GenericBound, GetDefId, ImportSource, Item, ItemEnum, MacroKind, Path,\n+    PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Stability, Type, TypeBinding,\n+    TypeKind, Visibility, WherePredicate, inline,\n+};\n+use crate::clean::blanket_impl::BlanketImplFinder;\n+use crate::clean::auto_trait::AutoTraitFinder;\n+\n+use rustc::hir;\n+use rustc::hir::def::{DefKind, Res};\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::ty::{self, DefIdTree, Ty};\n+use rustc::ty::subst::{SubstsRef, GenericArgKind};\n+use rustc::util::nodemap::FxHashSet;\n+use syntax_pos;\n+use syntax_pos::symbol::{Symbol, kw, sym};\n+\n+use std::mem;\n+\n+pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n+    use crate::visit_lib::LibEmbargoVisitor;\n+\n+    let krate = cx.tcx.hir().krate();\n+    let module = crate::visit_ast::RustdocVisitor::new(&mut cx).visit(krate);\n+\n+    let mut r = cx.renderinfo.get_mut();\n+    r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n+    r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n+    r.owned_box_did = cx.tcx.lang_items().owned_box();\n+\n+    let mut externs = Vec::new();\n+    for &cnum in cx.tcx.crates().iter() {\n+        externs.push((cnum, cnum.clean(cx)));\n+        // Analyze doc-reachability for extern items\n+        LibEmbargoVisitor::new(&mut cx).visit_lib(cnum);\n+    }\n+    externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n+\n+    // Clean the crate, translating the entire libsyntax AST to one that is\n+    // understood by rustdoc.\n+    let mut module = module.clean(cx);\n+    let mut masked_crates = FxHashSet::default();\n+\n+    match module.inner {\n+        ItemEnum::ModuleItem(ref module) => {\n+            for it in &module.items {\n+                // `compiler_builtins` should be masked too, but we can't apply\n+                // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n+                if it.is_extern_crate()\n+                    && (it.attrs.has_doc_flag(sym::masked)\n+                        || cx.tcx.is_compiler_builtins(it.def_id.krate))\n+                {\n+                    masked_crates.insert(it.def_id.krate);\n+                }\n+            }\n+        }\n+        _ => unreachable!(),\n+    }\n+\n+    let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n+    {\n+        let m = match module.inner {\n+            ItemEnum::ModuleItem(ref mut m) => m,\n+            _ => unreachable!(),\n+        };\n+        m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n+            Item {\n+                source: Span::empty(),\n+                name: Some(prim.to_url_str().to_string()),\n+                attrs: attrs.clone(),\n+                visibility: Visibility::Public,\n+                stability: get_stability(cx, def_id),\n+                deprecation: get_deprecation(cx, def_id),\n+                def_id,\n+                inner: ItemEnum::PrimitiveItem(prim),\n+            }\n+        }));\n+        m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n+            Item {\n+                source: Span::empty(),\n+                name: Some(kw.clone()),\n+                attrs,\n+                visibility: Visibility::Public,\n+                stability: get_stability(cx, def_id),\n+                deprecation: get_deprecation(cx, def_id),\n+                def_id,\n+                inner: ItemEnum::KeywordItem(kw),\n+            }\n+        }));\n+    }\n+\n+    Crate {\n+        name,\n+        version: None,\n+        src,\n+        module: Some(module),\n+        externs,\n+        primitives,\n+        external_traits: cx.external_traits.clone(),\n+        masked_crates,\n+        collapsed: false,\n+    }\n+}\n+\n+// extract the stability index for a node from tcx, if possible\n+pub fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n+    cx.tcx.lookup_stability(def_id).clean(cx)\n+}\n+\n+pub fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n+    cx.tcx.lookup_deprecation(def_id).clean(cx)\n+}\n+\n+pub fn external_generic_args(\n+    cx: &DocContext<'_>,\n+    trait_did: Option<DefId>,\n+    has_self: bool,\n+    bindings: Vec<TypeBinding>,\n+    substs: SubstsRef<'_>,\n+) -> GenericArgs {\n+    let mut skip_self = has_self;\n+    let mut ty_kind = None;\n+    let args: Vec<_> = substs.iter().filter_map(|kind| match kind.unpack() {\n+        GenericArgKind::Lifetime(lt) => {\n+            lt.clean(cx).and_then(|lt| Some(GenericArg::Lifetime(lt)))\n+        }\n+        GenericArgKind::Type(_) if skip_self => {\n+            skip_self = false;\n+            None\n+        }\n+        GenericArgKind::Type(ty) => {\n+            ty_kind = Some(&ty.kind);\n+            Some(GenericArg::Type(ty.clean(cx)))\n+        }\n+        GenericArgKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+    }).collect();\n+\n+    match trait_did {\n+        // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n+        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n+            assert!(ty_kind.is_some());\n+            let inputs = match ty_kind {\n+                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n+                _ => return GenericArgs::AngleBracketed { args, bindings },\n+            };\n+            let output = None;\n+            // FIXME(#20299) return type comes from a projection now\n+            // match types[1].kind {\n+            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n+            //     _ => Some(types[1].clean(cx))\n+            // };\n+            GenericArgs::Parenthesized { inputs, output }\n+        },\n+        _ => {\n+            GenericArgs::AngleBracketed { args, bindings }\n+        }\n+    }\n+}\n+\n+// trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n+// from Fn<(A, B,), C> to Fn(A, B) -> C\n+pub fn external_path(cx: &DocContext<'_>, name: Symbol, trait_did: Option<DefId>, has_self: bool,\n+                     bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> Path {\n+    Path {\n+        global: false,\n+        res: Res::Err,\n+        segments: vec![PathSegment {\n+            name: name.to_string(),\n+            args: external_generic_args(cx, trait_did, has_self, bindings, substs)\n+        }],\n+    }\n+}\n+\n+/// The point of this function is to replace bounds with types.\n+///\n+/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n+/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n+/// wrapped types in here).\n+pub fn get_real_types(\n+    generics: &Generics,\n+    arg: &Type,\n+    cx: &DocContext<'_>,\n+    recurse: i32,\n+) -> FxHashSet<Type> {\n+    let arg_s = arg.print().to_string();\n+    let mut res = FxHashSet::default();\n+    if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n+        return res;\n+    }\n+    if arg.is_full_generic() {\n+        if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n+            match g {\n+                &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n+                _ => false,\n+            }\n+        }) {\n+            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n+            for bound in bounds.iter() {\n+                match *bound {\n+                    GenericBound::TraitBound(ref poly_trait, _) => {\n+                        for x in poly_trait.generic_params.iter() {\n+                            if !x.is_type() {\n+                                continue\n+                            }\n+                            if let Some(ty) = x.get_type() {\n+                                let adds = get_real_types(generics, &ty, cx, recurse + 1);\n+                                if !adds.is_empty() {\n+                                    res.extend(adds);\n+                                } else if !ty.is_full_generic() {\n+                                    res.insert(ty);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        if let Some(bound) = generics.params.iter().find(|g| {\n+            g.is_type() && g.name == arg_s\n+        }) {\n+            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n+                if let Some(ty) = bound.get_trait_type() {\n+                    let adds = get_real_types(generics, &ty, cx, recurse + 1);\n+                    if !adds.is_empty() {\n+                        res.extend(adds);\n+                    } else if !ty.is_full_generic() {\n+                        res.insert(ty.clone());\n+                    }\n+                }\n+            }\n+        }\n+    } else {\n+        res.insert(arg.clone());\n+        if let Some(gens) = arg.generics() {\n+            for gen in gens.iter() {\n+                if gen.is_full_generic() {\n+                    let adds = get_real_types(generics, gen, cx, recurse + 1);\n+                    if !adds.is_empty() {\n+                        res.extend(adds);\n+                    }\n+                } else {\n+                    res.insert(gen.clone());\n+                }\n+            }\n+        }\n+    }\n+    res\n+}\n+\n+/// Return the full list of types when bounds have been resolved.\n+///\n+/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n+/// `[u32, Display, Option]`.\n+pub fn get_all_types(\n+    generics: &Generics,\n+    decl: &FnDecl,\n+    cx: &DocContext<'_>,\n+) -> (Vec<Type>, Vec<Type>) {\n+    let mut all_types = FxHashSet::default();\n+    for arg in decl.inputs.values.iter() {\n+        if arg.type_.is_self_type() {\n+            continue;\n+        }\n+        let args = get_real_types(generics, &arg.type_, cx, 0);\n+        if !args.is_empty() {\n+            all_types.extend(args);\n+        } else {\n+            all_types.insert(arg.type_.clone());\n+        }\n+    }\n+\n+    let ret_types = match decl.output {\n+        FunctionRetTy::Return(ref return_type) => {\n+            let mut ret = get_real_types(generics, &return_type, cx, 0);\n+            if ret.is_empty() {\n+                ret.insert(return_type.clone());\n+            }\n+            ret.into_iter().collect()\n+        }\n+        _ => Vec::new(),\n+    };\n+    (all_types.into_iter().collect(), ret_types)\n+}\n+\n+pub fn strip_type(ty: Type) -> Type {\n+    match ty {\n+        Type::ResolvedPath { path, param_names, did, is_generic } => {\n+            Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n+        }\n+        Type::Tuple(inner_tys) => {\n+            Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n+        }\n+        Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n+        Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n+        Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n+        Type::BorrowedRef { lifetime, mutability, type_ } => {\n+            Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n+        }\n+        Type::QPath { name, self_type, trait_ } => {\n+            Type::QPath {\n+                name,\n+                self_type: Box::new(strip_type(*self_type)), trait_: Box::new(strip_type(*trait_))\n+            }\n+        }\n+        _ => ty\n+    }\n+}\n+\n+pub fn strip_path(path: &Path) -> Path {\n+    let segments = path.segments.iter().map(|s| {\n+        PathSegment {\n+            name: s.name.clone(),\n+            args: GenericArgs::AngleBracketed {\n+                args: vec![],\n+                bindings: vec![],\n+            }\n+        }\n+    }).collect();\n+\n+    Path {\n+        global: path.global,\n+        res: path.res.clone(),\n+        segments,\n+    }\n+}\n+\n+pub fn qpath_to_string(p: &hir::QPath) -> String {\n+    let segments = match *p {\n+        hir::QPath::Resolved(_, ref path) => &path.segments,\n+        hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n+    };\n+\n+    let mut s = String::new();\n+    for (i, seg) in segments.iter().enumerate() {\n+        if i > 0 {\n+            s.push_str(\"::\");\n+        }\n+        if seg.ident.name != kw::PathRoot {\n+            s.push_str(&seg.ident.as_str());\n+        }\n+    }\n+    s\n+}\n+\n+pub fn build_deref_target_impls(cx: &DocContext<'_>,\n+                                items: &[Item],\n+                                ret: &mut Vec<Item>) {\n+    use self::PrimitiveType::*;\n+    let tcx = cx.tcx;\n+\n+    for item in items {\n+        let target = match item.inner {\n+            ItemEnum::TypedefItem(ref t, true) => &t.type_,\n+            _ => continue,\n+        };\n+        let primitive = match *target {\n+            ResolvedPath { did, .. } if did.is_local() => continue,\n+            ResolvedPath { did, .. } => {\n+                ret.extend(inline::build_impls(cx, did, None));\n+                continue\n+            }\n+            _ => match target.primitive_type() {\n+                Some(prim) => prim,\n+                None => continue,\n+            }\n+        };\n+        let did = match primitive {\n+            Isize => tcx.lang_items().isize_impl(),\n+            I8 => tcx.lang_items().i8_impl(),\n+            I16 => tcx.lang_items().i16_impl(),\n+            I32 => tcx.lang_items().i32_impl(),\n+            I64 => tcx.lang_items().i64_impl(),\n+            I128 => tcx.lang_items().i128_impl(),\n+            Usize => tcx.lang_items().usize_impl(),\n+            U8 => tcx.lang_items().u8_impl(),\n+            U16 => tcx.lang_items().u16_impl(),\n+            U32 => tcx.lang_items().u32_impl(),\n+            U64 => tcx.lang_items().u64_impl(),\n+            U128 => tcx.lang_items().u128_impl(),\n+            F32 => tcx.lang_items().f32_impl(),\n+            F64 => tcx.lang_items().f64_impl(),\n+            Char => tcx.lang_items().char_impl(),\n+            Bool => tcx.lang_items().bool_impl(),\n+            Str => tcx.lang_items().str_impl(),\n+            Slice => tcx.lang_items().slice_impl(),\n+            Array => tcx.lang_items().slice_impl(),\n+            Tuple => None,\n+            Unit => None,\n+            RawPointer => tcx.lang_items().const_ptr_impl(),\n+            Reference => None,\n+            Fn => None,\n+            Never => None,\n+        };\n+        if let Some(did) = did {\n+            if !did.is_local() {\n+                inline::build_impl(cx, did, None, ret);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait ToSource {\n+    fn to_src(&self, cx: &DocContext<'_>) -> String;\n+}\n+\n+impl ToSource for syntax_pos::Span {\n+    fn to_src(&self, cx: &DocContext<'_>) -> String {\n+        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n+        let sn = match cx.sess().source_map().span_to_snippet(*self) {\n+            Ok(x) => x,\n+            Err(_) => String::new()\n+        };\n+        debug!(\"got snippet {}\", sn);\n+        sn\n+    }\n+}\n+\n+pub fn name_from_pat(p: &hir::Pat) -> String {\n+    use rustc::hir::*;\n+    debug!(\"trying to get a name from pattern: {:?}\", p);\n+\n+    match p.kind {\n+        PatKind::Wild => \"_\".to_string(),\n+        PatKind::Binding(_, _, ident, _) => ident.to_string(),\n+        PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n+        PatKind::Struct(ref name, ref fields, etc) => {\n+            format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n+                fields.iter().map(|fp| format!(\"{}: {}\", fp.ident, name_from_pat(&fp.pat)))\n+                             .collect::<Vec<String>>().join(\", \"),\n+                if etc { \", ..\" } else { \"\" }\n+            )\n+        }\n+        PatKind::Or(ref pats) => {\n+            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n+        }\n+        PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n+                                            .collect::<Vec<String>>().join(\", \")),\n+        PatKind::Box(ref p) => name_from_pat(&**p),\n+        PatKind::Ref(ref p, _) => name_from_pat(&**p),\n+        PatKind::Lit(..) => {\n+            warn!(\"tried to get argument name from PatKind::Lit, \\\n+                  which is silly in function arguments\");\n+            \"()\".to_string()\n+        },\n+        PatKind::Range(..) => panic!(\"tried to get argument name from PatKind::Range, \\\n+                              which is not allowed in function arguments\"),\n+        PatKind::Slice(ref begin, ref mid, ref end) => {\n+            let begin = begin.iter().map(|p| name_from_pat(&**p));\n+            let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n+            let end = end.iter().map(|p| name_from_pat(&**p));\n+            format!(\"[{}]\", begin.chain(mid).chain(end).collect::<Vec<_>>().join(\", \"))\n+        },\n+    }\n+}\n+\n+pub fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n+    match n.val {\n+        ty::ConstKind::Unevaluated(def_id, _) => {\n+            if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n+                print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n+            } else {\n+                inline::print_inlined_const(cx, def_id)\n+            }\n+        },\n+        _ => {\n+            let mut s = n.to_string();\n+            // array lengths are obviously usize\n+            if s.ends_with(\"usize\") {\n+                let n = s.len() - \"usize\".len();\n+                s.truncate(n);\n+                if s.ends_with(\": \") {\n+                    let n = s.len() - \": \".len();\n+                    s.truncate(n);\n+                }\n+            }\n+            s\n+        },\n+    }\n+}\n+\n+pub fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n+    cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n+}\n+\n+/// Given a type Path, resolve it to a Type using the TyCtxt\n+pub fn resolve_type(cx: &DocContext<'_>,\n+                    path: Path,\n+                    id: hir::HirId) -> Type {\n+    if id == hir::DUMMY_HIR_ID {\n+        debug!(\"resolve_type({:?})\", path);\n+    } else {\n+        debug!(\"resolve_type({:?},{:?})\", path, id);\n+    }\n+\n+    let is_generic = match path.res {\n+        Res::PrimTy(p) => match p {\n+            hir::Str => return Primitive(PrimitiveType::Str),\n+            hir::Bool => return Primitive(PrimitiveType::Bool),\n+            hir::Char => return Primitive(PrimitiveType::Char),\n+            hir::Int(int_ty) => return Primitive(int_ty.into()),\n+            hir::Uint(uint_ty) => return Primitive(uint_ty.into()),\n+            hir::Float(float_ty) => return Primitive(float_ty.into()),\n+        },\n+        Res::SelfTy(..) if path.segments.len() == 1 => {\n+            return Generic(kw::SelfUpper.to_string());\n+        }\n+        Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n+            return Generic(format!(\"{:#}\", path.print()));\n+        }\n+        Res::SelfTy(..)\n+        | Res::Def(DefKind::TyParam, _)\n+        | Res::Def(DefKind::AssocTy, _) => true,\n+        _ => false,\n+    };\n+    let did = register_res(&*cx, path.res);\n+    ResolvedPath { path, param_names: None, did, is_generic }\n+}\n+\n+pub fn get_auto_trait_and_blanket_impls(\n+    cx: &DocContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    param_env_def_id: DefId,\n+) -> impl Iterator<Item = Item> {\n+    AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id).into_iter()\n+        .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n+}\n+\n+pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n+    debug!(\"register_res({:?})\", res);\n+\n+    let (did, kind) = match res {\n+        Res::Def(DefKind::Fn, i) => (i, TypeKind::Function),\n+        Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n+        Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n+        Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n+        Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n+        Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n+        Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),\n+        Res::Def(DefKind::ForeignTy, i) => (i, TypeKind::Foreign),\n+        Res::Def(DefKind::Const, i) => (i, TypeKind::Const),\n+        Res::Def(DefKind::Static, i) => (i, TypeKind::Static),\n+        Res::Def(DefKind::Variant, i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n+                            TypeKind::Enum),\n+        Res::Def(DefKind::Macro(mac_kind), i) => match mac_kind {\n+            MacroKind::Bang => (i, TypeKind::Macro),\n+            MacroKind::Attr => (i, TypeKind::Attr),\n+            MacroKind::Derive => (i, TypeKind::Derive),\n+        },\n+        Res::Def(DefKind::TraitAlias, i) => (i, TypeKind::TraitAlias),\n+        Res::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n+        Res::SelfTy(_, Some(impl_def_id)) => return impl_def_id,\n+        _ => return res.def_id()\n+    };\n+    if did.is_local() { return did }\n+    inline::record_extern_fqn(cx, did, kind);\n+    if let TypeKind::Trait = kind {\n+        inline::record_extern_trait(cx, did);\n+    }\n+    did\n+}\n+\n+pub fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n+    ImportSource {\n+        did: if path.res.opt_def_id().is_none() {\n+            None\n+        } else {\n+            Some(register_res(cx, path.res))\n+        },\n+        path,\n+    }\n+}\n+\n+pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n+where\n+    F: FnOnce() -> R,\n+{\n+    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.borrow_mut());\n+    let r = f();\n+    assert!(cx.impl_trait_bounds.borrow().is_empty());\n+    *cx.impl_trait_bounds.borrow_mut() = old_bounds;\n+    r\n+}"}, {"sha": "fd620d467de48dd05a785dc17e6a46deb488c321", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -63,6 +63,13 @@ impl Buffer {\n         }\n     }\n \n+    crate fn new() -> Buffer {\n+        Buffer {\n+            for_html: false,\n+            buffer: String::new(),\n+        }\n+    }\n+\n     crate fn is_empty(&self) -> bool {\n         self.buffer.is_empty()\n     }\n@@ -106,6 +113,10 @@ impl Buffer {\n             write!(self, \"{:#}\", t);\n         }\n     }\n+\n+    crate fn is_for_html(&self) -> bool {\n+        self.for_html\n+    }\n }\n \n /// Wrapper struct for properly emitting a function or method declaration."}, {"sha": "86e5efbd7b3a4e98d14e7e1251374e435b03e246", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -2282,12 +2282,23 @@ fn render_implementor(cx: &Context, implementor: &Impl, w: &mut Buffer,\n fn render_impls(cx: &Context, w: &mut Buffer,\n                 traits: &[&&Impl],\n                 containing_item: &clean::Item) {\n-    for i in traits {\n-        let did = i.trait_did().unwrap();\n-        let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n-        render_impl(w, cx, i, assoc_link,\n-                    RenderMode::Normal, containing_item.stable_since(), true, None, false, true);\n-    }\n+    let mut impls = traits.iter()\n+        .map(|i| {\n+            let did = i.trait_did().unwrap();\n+            let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n+            let mut buffer = if w.is_for_html() {\n+                Buffer::html()\n+            } else {\n+                Buffer::new()\n+            };\n+            render_impl(&mut buffer, cx, i, assoc_link,\n+                        RenderMode::Normal, containing_item.stable_since(),\n+                        true, None, false, true);\n+            buffer.into_inner()\n+        })\n+        .collect::<Vec<_>>();\n+    impls.sort();\n+    w.write_str(&impls.join(\"\"));\n }\n \n fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool) -> String {"}, {"sha": "e8b9e9cb1f29ccff91323de2b5a7ac10a74cb621", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -433,7 +433,7 @@ mod hash;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod hash_map {\n-    //! A hash map implemented with linear probing and Robin Hood bucket stealing.\n+    //! A hash map implemented with quadratic probing and SIMD lookup.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::hash::map::*;\n }"}, {"sha": "62702a8ec5cb16feeba9f13e69a85d241d877f33", "filename": "src/test/ui/consts/assoc_const_generic_impl.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Ftest%2Fui%2Fconsts%2Fassoc_const_generic_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Ftest%2Fui%2Fconsts%2Fassoc_const_generic_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassoc_const_generic_impl.rs?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -0,0 +1,19 @@\n+#![warn(const_err)]\n+\n+trait ZeroSized: Sized {\n+    const I_AM_ZERO_SIZED: ();\n+    fn requires_zero_size(self);\n+}\n+\n+impl<T: Sized> ZeroSized for T {\n+    const I_AM_ZERO_SIZED: ()  = [()][std::mem::size_of::<Self>()]; //~ WARN any use of this value\n+    fn requires_zero_size(self) {\n+        let () = Self::I_AM_ZERO_SIZED; //~ ERROR erroneous constant encountered\n+        println!(\"requires_zero_size called\");\n+    }\n+}\n+\n+fn main() {\n+    ().requires_zero_size();\n+    42_u32.requires_zero_size();\n+}"}, {"sha": "a114d5c6ccd14b26caea7c9d615cdb2d8556ada3", "filename": "src/test/ui/consts/assoc_const_generic_impl.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Ftest%2Fui%2Fconsts%2Fassoc_const_generic_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddca1e09c36a6ce21d95fec1619f23ba59b69c8a/src%2Ftest%2Fui%2Fconsts%2Fassoc_const_generic_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassoc_const_generic_impl.stderr?ref=ddca1e09c36a6ce21d95fec1619f23ba59b69c8a", "patch": "@@ -0,0 +1,22 @@\n+warning: any use of this value will cause an error\n+  --> $DIR/assoc_const_generic_impl.rs:9:34\n+   |\n+LL |     const I_AM_ZERO_SIZED: ()  = [()][std::mem::size_of::<Self>()];\n+   |     -----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                  |\n+   |                                  index out of bounds: the len is 1 but the index is 4\n+   |\n+note: lint level defined here\n+  --> $DIR/assoc_const_generic_impl.rs:1:9\n+   |\n+LL | #![warn(const_err)]\n+   |         ^^^^^^^^^\n+\n+error: erroneous constant encountered\n+  --> $DIR/assoc_const_generic_impl.rs:11:18\n+   |\n+LL |         let () = Self::I_AM_ZERO_SIZED;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}