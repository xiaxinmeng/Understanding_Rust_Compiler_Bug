{"sha": "94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3", "node_id": "C_kwDOAAsO6NoAKDk0Y2I1ZTg2ZWE1MGVjODc4YjFhNWRlOWIwYjY0YmIzNWU4MDI3ZTM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-27T06:32:22Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-27T22:31:24Z"}, "message": "Small cleanups in unescaping code.\n\n- Rename `unescape_raw_str_or_raw_byte_str` as\n  `unescape_raw_str_or_byte_str`, which is more accurate.\n- Remove the unused `Mode::in_single_quotes` method.\n- Make some assertions more precise, and add a missing one to\n  `unescape_char_or_byte`.\n- Change all the assertions to `debug_assert!`, because this code is\n  reasonably hot, and the assertions aren't required for memory safety,\n  and any violations are likely to be sufficiently obvious that normal\n  tests will trigger them.", "tree": {"sha": "666016d3d218de3bff7a7ec52c2c8fe06b93bee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/666016d3d218de3bff7a7ec52c2c8fe06b93bee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3", "html_url": "https://github.com/rust-lang/rust/commit/94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c91c64708b1acf3c262a2a6d6551f4bc0acfa656", "url": "https://api.github.com/repos/rust-lang/rust/commits/c91c64708b1acf3c262a2a6d6551f4bc0acfa656", "html_url": "https://github.com/rust-lang/rust/commit/c91c64708b1acf3c262a2a6d6551f4bc0acfa656"}], "stats": {"total": 25, "additions": 11, "deletions": 14}, "files": [{"sha": "8f64b5f5158e4222ec74ec5acddc0095cf045b99", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3", "patch": "@@ -93,7 +93,7 @@ where\n         // NOTE: Raw strings do not perform any explicit character escaping, here we\n         // only translate CRLF to LF and produce errors on bare CR.\n         Mode::RawStr | Mode::RawByteStr => {\n-            unescape_raw_str_or_byte_str(literal_text, mode, callback)\n+            unescape_raw_str_or_raw_byte_str(literal_text, mode, callback)\n         }\n     }\n }\n@@ -105,7 +105,7 @@ pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F\n where\n     F: FnMut(Range<usize>, Result<u8, EscapeError>),\n {\n-    assert!(mode.is_bytes());\n+    debug_assert!(mode.is_bytes());\n     unescape_literal(literal_text, mode, &mut |range, result| {\n         callback(range, result.map(byte_from_char));\n     })\n@@ -129,7 +129,7 @@ pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n }\n \n /// What kind of literal do we parse.\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n pub enum Mode {\n     Char,\n     Str,\n@@ -140,17 +140,13 @@ pub enum Mode {\n }\n \n impl Mode {\n-    pub fn in_single_quotes(self) -> bool {\n+    pub fn in_double_quotes(self) -> bool {\n         match self {\n-            Mode::Char | Mode::Byte => true,\n-            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => false,\n+            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Byte => false,\n         }\n     }\n \n-    pub fn in_double_quotes(self) -> bool {\n-        !self.in_single_quotes()\n-    }\n-\n     pub fn is_bytes(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n@@ -263,6 +259,7 @@ fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n }\n \n fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    debug_assert!(mode == Mode::Char || mode == Mode::Byte);\n     let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n     let res = match first_char {\n         '\\\\' => scan_escape(chars, mode),\n@@ -282,7 +279,7 @@ fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    assert!(mode.in_double_quotes());\n+    debug_assert!(mode == Mode::Str || mode == Mode::ByteStr);\n     let initial_len = src.len();\n     let mut chars = src.chars();\n     while let Some(first_char) = chars.next() {\n@@ -344,11 +341,11 @@ where\n /// sequence of characters or errors.\n /// NOTE: Raw strings do not perform any explicit character escaping, here we\n /// only translate CRLF to LF and produce errors on bare CR.\n-fn unescape_raw_str_or_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+fn unescape_raw_str_or_raw_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    assert!(mode.in_double_quotes());\n+    debug_assert!(mode == Mode::RawStr || mode == Mode::RawByteStr);\n     let initial_len = literal_text.len();\n \n     let mut chars = literal_text.chars();\n@@ -368,7 +365,7 @@ where\n \n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n+    debug_assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8\n }\n "}]}