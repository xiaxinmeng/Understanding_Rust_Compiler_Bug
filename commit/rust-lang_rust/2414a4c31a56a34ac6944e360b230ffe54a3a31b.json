{"sha": "2414a4c31a56a34ac6944e360b230ffe54a3a31b", "node_id": "C_kwDOAAsO6NoAKDI0MTRhNGMzMWE1NmEzNGFjNjk0NGUzNjBiMjMwZmZlNTRhM2EzMWI", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-10-29T12:18:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-29T12:18:03Z"}, "message": "Rollup merge of #103625 - WaffleLapkin:no_tyctxt_dogs_allowed, r=compiler-errors\n\nAccept `TyCtxt` instead of `TyCtxtAt` in `Ty::is_*` functions\n\nFunctions in answer:\n\n- `Ty::is_freeze`\n- `Ty::is_sized`\n- `Ty::is_unpin`\n- `Ty::is_copy_modulo_regions`\n\nThis allows to remove a lot of useless `.at(DUMMY_SP)`, making the code a bit nicer :3\n\nr? `@compiler-errors`", "tree": {"sha": "a7249602aa30f9677116ed63b9551ece77446e66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7249602aa30f9677116ed63b9551ece77446e66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2414a4c31a56a34ac6944e360b230ffe54a3a31b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjXRn7CRBK7hj4Ov3rIwAArAMIAFqF4oAa8hilKuLCA7l6cRmX\nFban5XvhDpSc4jj1G5hjANlfFMGcQ0rFt+k33mSbqJooIafIg1PZDXAAt8BFC1dX\n+cGE4UnkBXhe0dA50094J5vL+boiOncwbaePrQVzqdPCdV7eJ1qKRNn4EYHdwMsD\nTPnoxwY8njIzeG02DTeFlJGRudiqDjgM0LY+6/Nm1Fm6r8MHQNGrgiybZ+X8pIqn\nIiHyZXH1YjVJb6S8GmcVa4TT+GIpw3sl5NTKtxaZxjPePvfs/L313RAo4HSke6ya\nzMKqtX4y/PwPWPyR9I27IjuUK+kqDJnjSO6MBWV2cOE3WpKvhn4mEb7hMRfc6j4=\n=MH2F\n-----END PGP SIGNATURE-----\n", "payload": "tree a7249602aa30f9677116ed63b9551ece77446e66\nparent 692a22e7355a44aef8e1d275803be0e497a5bc3a\nparent c8c49710732a8cf9a71b7eed75d340e5f99383b8\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1667045883 +0200\ncommitter GitHub <noreply@github.com> 1667045883 +0200\n\nRollup merge of #103625 - WaffleLapkin:no_tyctxt_dogs_allowed, r=compiler-errors\n\nAccept `TyCtxt` instead of `TyCtxtAt` in `Ty::is_*` functions\n\nFunctions in answer:\n\n- `Ty::is_freeze`\n- `Ty::is_sized`\n- `Ty::is_unpin`\n- `Ty::is_copy_modulo_regions`\n\nThis allows to remove a lot of useless `.at(DUMMY_SP)`, making the code a bit nicer :3\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2414a4c31a56a34ac6944e360b230ffe54a3a31b", "html_url": "https://github.com/rust-lang/rust/commit/2414a4c31a56a34ac6944e360b230ffe54a3a31b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2414a4c31a56a34ac6944e360b230ffe54a3a31b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "692a22e7355a44aef8e1d275803be0e497a5bc3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/692a22e7355a44aef8e1d275803be0e497a5bc3a", "html_url": "https://github.com/rust-lang/rust/commit/692a22e7355a44aef8e1d275803be0e497a5bc3a"}, {"sha": "c8c49710732a8cf9a71b7eed75d340e5f99383b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c49710732a8cf9a71b7eed75d340e5f99383b8", "html_url": "https://github.com/rust-lang/rust/commit/c8c49710732a8cf9a71b7eed75d340e5f99383b8"}], "stats": {"total": 363, "additions": 191, "deletions": 172}, "files": [{"sha": "3c1c3ab45ce7a6639a74211a35be77ce01ddb07c", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -1783,7 +1783,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n         let erased_ty = tcx.erase_regions(ty);\n-        if !erased_ty.is_sized(tcx.at(span), self.param_env) {\n+        if !erased_ty.is_sized(tcx, self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough"}, {"sha": "1db44502742e921b4bcbbdff9d76bce7e1e5e849", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -770,11 +770,7 @@ fn codegen_stmt<'tcx>(\n                     lval.write_cvalue(fx, CValue::by_val(operand, box_layout));\n                 }\n                 Rvalue::NullaryOp(null_op, ty) => {\n-                    assert!(\n-                        lval.layout()\n-                            .ty\n-                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n-                    );\n+                    assert!(lval.layout().ty.is_sized(fx.tcx, ParamEnv::reveal_all()));\n                     let layout = fx.layout_of(fx.monomorphize(ty));\n                     let val = match null_op {\n                         NullOp::SizeOf => layout.size.bytes(),"}, {"sha": "148b66d959e8a74126c5fdde83eb48f3a3de1290", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n-use rustc_span::DUMMY_SP;\n \n use cranelift_module::*;\n \n@@ -291,7 +290,7 @@ fn data_id_for_static(\n     let is_mutable = if tcx.is_mutable_static(def_id) {\n         true\n     } else {\n-        !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n+        !ty.is_freeze(tcx, ParamEnv::reveal_all())\n     };\n     let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n "}, {"sha": "bdc6a91cf6ab5f411cd61602e2920212dfb228eb", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -5,7 +5,6 @@ use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n use rustc_target::abi::{AddressSpace, Integer};\n \n@@ -75,16 +74,16 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+        ty.is_sized(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+        ty.is_freeze(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n         let param_env = ty::ParamEnv::reveal_all();\n-        if ty.is_sized(self.tcx().at(DUMMY_SP), param_env) {\n+        if ty.is_sized(self.tcx(), param_env) {\n             return false;\n         }\n "}, {"sha": "f4da11883957a73f0376d35c2202c659a2d1a8ab", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -212,7 +212,7 @@ fn create_pointee_place<'tcx>(\n ) -> MPlaceTy<'tcx> {\n     let tcx = ecx.tcx.tcx;\n \n-    if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) {\n+    if !ty.is_sized(*ecx.tcx, ty::ParamEnv::empty()) {\n         // We need to create `Allocation`s for custom DSTs\n \n         let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n@@ -398,7 +398,7 @@ fn valtree_into_mplace<'tcx>(\n \n                 let mut place_inner = match ty.kind() {\n                     ty::Str | ty::Slice(_) => ecx.mplace_index(&place, i as u64).unwrap(),\n-                    _ if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty())\n+                    _ if !ty.is_sized(*ecx.tcx, ty::ParamEnv::empty())\n                         && i == branches.len() - 1 =>\n                     {\n                         // Note: For custom DSTs we need to manually process the last unsized field."}, {"sha": "a9063ad31cfe65c8b9d631888538b076eeeb9cdd", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -468,7 +468,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, self.param_env)\n+        ty.is_freeze(*self.tcx, self.param_env)\n     }\n \n     pub fn load_mir("}, {"sha": "6809a42dc45364b78a5fecbc3bfa218f304daec9", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -114,7 +114,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx, ecx.param_env));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(*ecx.tcx, ecx.param_env));\n         // For statics, allocation mutability is the combination of place mutability and\n         // type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere."}, {"sha": "8aa56c275d91b93c51b1618c87687a9146ca57c7", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::mir::interpret::InterpError;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, WrappingRange};\n \n use std::hash::Hash;\n@@ -726,7 +725,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         // Special check preventing `UnsafeCell` inside unions in the inner part of constants.\n         if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. })) {\n-            if !op.layout.ty.is_freeze(self.ecx.tcx.at(DUMMY_SP), self.ecx.param_env) {\n+            if !op.layout.ty.is_freeze(*self.ecx.tcx, self.ecx.param_env) {\n                 throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n             }\n         }"}, {"sha": "335992342a64756e393398380fea985ca93cbf6b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -8,7 +8,6 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::{\n     self, ImplSource, Obligation, ObligationCause, SelectionContext,\n };\n@@ -92,7 +91,7 @@ impl Qualif for HasMutInterior {\n     }\n \n     fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n-        !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+        !ty.is_freeze(cx.tcx, cx.param_env)\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "805e6096b35c8577c2a033d3f999f26c462c5a55", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -8,7 +8,6 @@ use rustc_middle::mir::{self, BasicBlock, Local, Location, Statement, StatementK\n use rustc_mir_dataflow::fmt::DebugWithContext;\n use rustc_mir_dataflow::JoinSemiLattice;\n use rustc_mir_dataflow::{Analysis, AnalysisDomain, CallReturnPlaces};\n-use rustc_span::DUMMY_SP;\n \n use std::fmt;\n use std::marker::PhantomData;\n@@ -120,10 +119,7 @@ where\n     ///\n     /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n     fn shared_borrow_allows_mutation(&self, place: mir::Place<'tcx>) -> bool {\n-        !place\n-            .ty(self.ccx.body, self.ccx.tcx)\n-            .ty\n-            .is_freeze(self.ccx.tcx.at(DUMMY_SP), self.ccx.param_env)\n+        !place.ty(self.ccx.body, self.ccx.tcx).ty.is_freeze(self.ccx.tcx, self.ccx.param_env)\n     }\n }\n "}, {"sha": "81b82a21fa1a7276796672a3980784bad79869ed", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -235,9 +235,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             // `Operand::Copy` is only supposed to be used with `Copy` types.\n             if let Operand::Copy(place) = operand {\n                 let ty = place.ty(&self.body.local_decls, self.tcx).ty;\n-                let span = self.body.source_info(location).span;\n \n-                if !ty.is_copy_modulo_regions(self.tcx.at(span), self.param_env) {\n+                if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n                     self.fail(location, format!(\"`Operand::Copy` with non-`Copy` type {}\", ty));\n                 }\n             }"}, {"sha": "b70ac02058d3dd3d5dccdcd58d129bcb0c30bee1", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -114,7 +114,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n                 _ => {\n                     // Fallback case: allow `ManuallyDrop` and things that are `Copy`.\n                     ty.ty_adt_def().is_some_and(|adt_def| adt_def.is_manually_drop())\n-                        || ty.is_copy_modulo_regions(tcx.at(span), param_env)\n+                        || ty.is_copy_modulo_regions(tcx, param_env)\n                 }\n             }\n         }"}, {"sha": "17c4d0d482f2ab0b2a72e58c27aad8717f3decff", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n     fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n         // Type still may have region variables, but `Sized` does not depend\n         // on those, so just erase them before querying.\n-        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+        if ty.is_sized(self.tcx, self.param_env) {\n             return true;\n         }\n         if let ty::Foreign(..) = ty.kind() {\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n \n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n-        if !ty.is_copy_modulo_regions(self.tcx.at(expr.span), self.param_env) {\n+        if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(&format!(\"`{ty}` does not implement the Copy trait\"));"}, {"sha": "d425adf47f06c10064d872790233d63d983dc4d1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -752,7 +752,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             return;\n         }\n         let param_env = ty::ParamEnv::empty();\n-        if ty.is_copy_modulo_regions(cx.tcx.at(item.span), param_env) {\n+        if ty.is_copy_modulo_regions(cx.tcx, param_env) {\n             return;\n         }\n         if can_type_implement_copy("}, {"sha": "37caab2da0f5b0e61e6f618882b1ba40cfae6e86", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_span::{Span, Symbol};\n use rustc_target::abi::{Abi, WrappingRange};\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n@@ -931,7 +931,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         match *ty.kind() {\n             ty::Adt(def, substs) => {\n                 if def.is_box() && matches!(self.mode, CItemKind::Definition) {\n-                    if ty.boxed_ty().is_sized(tcx.at(DUMMY_SP), self.cx.param_env) {\n+                    if ty.boxed_ty().is_sized(tcx, self.cx.param_env) {\n                         return FfiSafe;\n                     } else {\n                         return FfiUnsafe {\n@@ -1082,7 +1082,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n                 if {\n                     matches!(self.mode, CItemKind::Definition)\n-                        && ty.is_sized(self.cx.tcx.at(DUMMY_SP), self.cx.param_env)\n+                        && ty.is_sized(self.cx.tcx, self.cx.param_env)\n                 } =>\n             {\n                 FfiSafe"}, {"sha": "3312f44c67b2a884319601a67df751396701b1f5", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -830,7 +830,7 @@ where\n                 } else {\n                     match mt {\n                         hir::Mutability::Not => {\n-                            if ty.is_freeze(tcx.at(DUMMY_SP), cx.param_env()) {\n+                            if ty.is_freeze(tcx, cx.param_env()) {\n                                 PointerKind::Frozen\n                             } else {\n                                 PointerKind::SharedMutable\n@@ -841,7 +841,7 @@ where\n                             // noalias, as another pointer to the structure can be obtained, that\n                             // is not based-on the original reference. We consider all !Unpin\n                             // types to be potentially self-referential here.\n-                            if ty.is_unpin(tcx.at(DUMMY_SP), cx.param_env()) {\n+                            if ty.is_unpin(tcx, cx.param_env()) {\n                                 PointerKind::UniqueBorrowed\n                             } else {\n                                 PointerKind::UniqueBorrowedPinned"}, {"sha": "f72e236eda1332cd4013315af28a120909cdfbfb", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -2,7 +2,6 @@\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::ty::layout::IntegerExt;\n-use crate::ty::query::TyCtxtAt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n     TypeVisitable,\n@@ -821,12 +820,8 @@ impl<'tcx> Ty<'tcx> {\n     /// does copies even when the type actually doesn't satisfy the\n     /// full requirements for the `Copy` trait (cc #29149) -- this\n     /// winds up being reported as an error during NLL borrow check.\n-    pub fn is_copy_modulo_regions(\n-        self,\n-        tcx_at: TyCtxtAt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        self.is_trivially_pure_clone_copy() || tcx_at.is_copy_raw(param_env.and(self))\n+    pub fn is_copy_modulo_regions(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_pure_clone_copy() || tcx.is_copy_raw(param_env.and(self))\n     }\n \n     /// Checks whether values of this type `T` have a size known at\n@@ -835,8 +830,8 @@ impl<'tcx> Ty<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_sized(tcx_at.tcx) || tcx_at.is_sized_raw(param_env.and(self))\n+    pub fn is_sized(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_sized(tcx) || tcx.is_sized_raw(param_env.and(self))\n     }\n \n     /// Checks whether values of this type `T` implement the `Freeze`\n@@ -846,8 +841,8 @@ impl<'tcx> Ty<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n-    pub fn is_freeze(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_freeze() || tcx_at.is_freeze_raw(param_env.and(self))\n+    pub fn is_freeze(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_freeze() || tcx.is_freeze_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Freeze`.\n@@ -886,8 +881,8 @@ impl<'tcx> Ty<'tcx> {\n     }\n \n     /// Checks whether values of this type `T` implement the `Unpin` trait.\n-    pub fn is_unpin(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_unpin() || tcx_at.is_unpin_raw(param_env.and(self))\n+    pub fn is_unpin(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_unpin() || tcx.is_unpin_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Unpin`."}, {"sha": "c8610af7038d7f2c2b089cfbf1658055bd2d8115", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -153,12 +153,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         if tcx.features().unsized_fn_params {\n             let ty = expr.ty;\n-            let span = expr.span;\n             let param_env = this.param_env;\n \n-            if !ty.is_sized(tcx.at(span), param_env) {\n+            if !ty.is_sized(tcx, param_env) {\n                 // !sized means !copy, so this is an unsized move\n-                assert!(!ty.is_copy_modulo_regions(tcx.at(span), param_env));\n+                assert!(!ty.is_copy_modulo_regions(tcx, param_env));\n \n                 // As described above, detect the case where we are passing a value of unsized\n                 // type, and that value is coming from the deref of a box."}, {"sha": "fb1ea9ed300ad4f8c87a02d6c32718c614ceca21", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                     };\n                     match borrow_kind {\n                         BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique => {\n-                            if !ty.is_freeze(self.tcx.at(pat.span), self.param_env) {\n+                            if !ty.is_freeze(self.tcx, self.param_env) {\n                                 self.requires_unsafe(pat.span, BorrowOfLayoutConstrainedField);\n                             }\n                         }\n@@ -457,9 +457,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 if visitor.found {\n                     match borrow_kind {\n                         BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique\n-                            if !self.thir[arg]\n-                                .ty\n-                                .is_freeze(self.tcx.at(self.thir[arg].span), self.param_env) =>\n+                            if !self.thir[arg].ty.is_freeze(self.tcx, self.param_env) =>\n                         {\n                             self.requires_unsafe(expr.span, BorrowOfLayoutConstrainedField)\n                         }"}, {"sha": "858129c742dc672037333af168c1743f19b6d537", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -1004,8 +1004,8 @@ fn maybe_point_at_variant<'a, 'p: 'a, 'tcx: 'a>(\n }\n \n /// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n-fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId, span: Span) -> bool {\n-    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n+fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId) -> bool {\n+    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx, cx.param_env)\n }\n \n /// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n@@ -1031,7 +1031,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n \n     // Get the binding move, extract the mutability if by-ref.\n     let mut_outer = match typeck_results.extract_binding_mode(sess, pat.hir_id, pat.span) {\n-        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id, pat.span) => {\n+        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id) => {\n             // We have `x @ pat` where `x` is by-move. Reject all borrows in `pat`.\n             let mut conflicts_ref = Vec::new();\n             sub.each_binding(|_, hir_id, span, _| {\n@@ -1070,7 +1070,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n                 (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push((span, name)), // 2x `ref mut`.\n                 _ => conflicts_mut_ref.push((span, name)), // `ref` + `ref mut` in either direction.\n             },\n-            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id, span) => {\n+            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id) => {\n                 conflicts_move.push((span, name)) // `ref mut?` + by-move conflict.\n             }\n             Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine."}, {"sha": "ad12e011621173c7ebd6866e494dec164d136126", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -506,7 +506,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // convert the dereferenced constant to a pattern that is the sub-pattern of the\n                 // deref pattern.\n                 _ => {\n-                    if !pointee_ty.is_sized(tcx.at(span), param_env) {\n+                    if !pointee_ty.is_sized(tcx, param_env) {\n                         // `tcx.deref_mir_constant()` below will ICE with an unsized type\n                         // (except slices, which are handled in a separate arm above).\n                         let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n@@ -534,7 +534,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n                 PatKind::Constant { value: cv }\n             }\n-            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx.at(span), param_env) => {\n+            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx, param_env) => {\n                 PatKind::Constant { value: cv }\n             }\n             // FIXME: these can have very surprising behaviour where optimization levels or other"}, {"sha": "f8f04214a2ca55a34255d458455c6ffa04b44479", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -312,7 +312,7 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n                             } else if !place\n                                 .ty(self.body, self.tcx)\n                                 .ty\n-                                .is_freeze(self.tcx.at(self.source_info.span), self.param_env)\n+                                .is_freeze(self.tcx, self.param_env)\n                             {\n                                 UnsafetyViolationDetails::BorrowOfLayoutConstrainedField\n                             } else {"}, {"sha": "4e4515888454b8a1038a583478ac845cbd868892", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -633,7 +633,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n         if !rvalue\n             .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n-            .is_sized(self.ecx.tcx, self.param_env)\n+            .is_sized(*self.ecx.tcx, self.param_env)\n         {\n             // the interpreter doesn't support unsized locals (only unsized arguments),\n             // but rustc does (in a kinda broken way), so we have to skip them here"}, {"sha": "479c4e577d4e3aad83e0098e3c18764cd654af67", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -500,7 +500,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n         if !rvalue\n             .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n-            .is_sized(self.ecx.tcx, self.param_env)\n+            .is_sized(*self.ecx.tcx, self.param_env)\n         {\n             // the interpreter doesn't support unsized locals (only unsized arguments),\n             // but rustc does (in a kinda broken way), so we have to skip them here"}, {"sha": "28b1c5a48099bc9d8c14d9b1456b263ea568f531", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -11,7 +11,6 @@ use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location, Operand, Terminator, TerminatorKind, RETURN_PLACE};\n use rustc_middle::ty::{self, DeducedParamAttrs, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n-use rustc_span::DUMMY_SP;\n \n /// A visitor that determines which arguments have been mutated. We can't use the mutability field\n /// on LocalDecl for this because it has no meaning post-optimization.\n@@ -232,7 +231,7 @@ pub fn deduced_param_attrs<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [Ded\n         body.local_decls.iter().skip(1).take(body.arg_count).enumerate().map(\n             |(arg_index, local_decl)| DeducedParamAttrs {\n                 read_only: !deduce_read_only.mutable_args.contains(arg_index)\n-                    && local_decl.ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all()),\n+                    && local_decl.ty.is_freeze(tcx, ParamEnv::reveal_all()),\n             },\n         ),\n     );"}, {"sha": "4e8798b7a55d2a58c9680fae5a8c4329e2289ba4", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -312,7 +312,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let param_env = tcx.param_env(def_id);\n \n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n-    let is_copy = self_ty.is_copy_modulo_regions(tcx.at(builder.span), param_env);\n+    let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env);\n \n     let dest = Place::return_place();\n     let src = tcx.mk_place_deref(Place::from(Local::new(1 + 0)));"}, {"sha": "a71218e6997576bbff139ecbac5716b2f017f570", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -1067,7 +1067,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let param_env = ty::ParamEnv::reveal_all();\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n-            if ty.is_sized(tcx.at(DUMMY_SP), param_env) {\n+            if ty.is_sized(tcx, param_env) {\n                 return false;\n             }\n             let tail = tcx.struct_tail_erasing_lifetimes(ty, param_env);"}, {"sha": "a335f8e06bc944b1258a42043ae036530ae40932", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -69,7 +69,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n \n         if !(param_env, ty).needs_infer() {\n-            return ty.is_copy_modulo_regions(self.tcx.at(span), param_env);\n+            return ty.is_copy_modulo_regions(self.tcx, param_env);\n         }\n \n         let copy_def_id = self.tcx.require_lang_item(LangItem::Copy, None);"}, {"sha": "6436713b3881154043bf4288158472c3a2d28df5", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -4,7 +4,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::traits::CodegenObligationError;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Instance, TyCtxt, TypeVisitable};\n-use rustc_span::{sym, DUMMY_SP};\n+use rustc_span::sym;\n use rustc_trait_selection::traits;\n use traits::{translate_substs, Reveal};\n \n@@ -236,7 +236,7 @@ fn resolve_associated_item<'tcx>(\n                 if name == sym::clone {\n                     let self_ty = trait_ref.self_ty();\n \n-                    let is_copy = self_ty.is_copy_modulo_regions(tcx.at(DUMMY_SP), param_env);\n+                    let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env);\n                     match self_ty.kind() {\n                         _ if is_copy => (),\n                         ty::Generator(..)"}, {"sha": "52ba0eee97cd5e4d526383e09bf240c0a6d298b2", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -399,7 +399,7 @@ fn layout_of_uncached<'tcx>(\n             }\n \n             let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n-            if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n+            if pointee.is_sized(tcx, param_env) {\n                 return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n             }\n \n@@ -755,8 +755,7 @@ fn layout_of_uncached<'tcx>(\n                 } else {\n                     let param_env = tcx.param_env(def.did());\n                     let last_field = def.variant(v).fields.last().unwrap();\n-                    let always_sized =\n-                        tcx.type_of(last_field.did).is_sized(tcx.at(DUMMY_SP), param_env);\n+                    let always_sized = tcx.type_of(last_field.did).is_sized(tcx, param_env);\n                     if !always_sized { StructKind::MaybeUnsized } else { StructKind::AlwaysSized }\n                 };\n "}, {"sha": "024dcd591bd77d68d321bb27a7016ee9b1b544e7", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -109,7 +109,7 @@ where\n \n             for component in components {\n                 match *component.kind() {\n-                    _ if component.is_copy_modulo_regions(tcx.at(DUMMY_SP), self.param_env) => (),\n+                    _ if component.is_copy_modulo_regions(tcx, self.param_env) => (),\n \n                     ty::Closure(_, substs) => {\n                         queue_type(self, substs.as_closure().tupled_upvars_ty());"}, {"sha": "764a6d3aa48cf4eb5d917a4ac46ad6386f143556", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -148,7 +148,7 @@ where\n             })\n             .collect();\n         // We are only interested in case the type *doesn't* implement the Sized trait.\n-        if !ty.is_sized(tcx.at(rustc_span::DUMMY_SP), param_env) {\n+        if !ty.is_sized(tcx, param_env) {\n             // In case `#![no_core]` is used, `sized_trait` returns nothing.\n             if let Some(item) = tcx.lang_items().sized_trait().and_then(|sized_trait_did| {\n                 self.generate_for_trait(ty, sized_trait_did, param_env, item_def_id, &f, true)"}, {"sha": "b9509ca656f7a170117e115cf0a6cd47023eee80", "filename": "src/tools/clippy/clippy_lints/src/casts/ptr_as_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: Option<RustcVer\n             (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n         // The `U` in `pointer::cast` have to be `Sized`\n         // as explained here: https://github.com/rust-lang/rust/issues/60602.\n-        if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n+        if to_pointee_ty.is_sized(cx.tcx, cx.param_env);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);"}, {"sha": "a37ee82d4c8ac16c22df9be5e589f5abcf396ac3", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -29,7 +29,7 @@ use rustc_middle::ty::{\n };\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n+use rustc_span::{symbol::sym, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n use std::collections::VecDeque;\n@@ -990,7 +990,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                                 cx.typeck_results().node_type(ty.ty.hir_id),\n                                 binder_args,\n                             ))\n-                            .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                            .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n                     )\n                 }\n             },\n@@ -1005,7 +1005,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                         cx.typeck_results().node_type(ty.ty.hir_id),\n                         binder_args,\n                     ))\n-                    .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                    .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n             ),\n             TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::TraitObject(..) | TyKind::Err => {\n                 Position::ReborrowStable(precedence)\n@@ -1297,7 +1297,7 @@ impl<'tcx> TyPosition<'tcx> {\n     fn position_for_result(self, cx: &LateContext<'tcx>) -> Position {\n         match (self.position, self.ty) {\n             (Position::ReborrowStable(precedence), Some(ty)) => {\n-                Position::DerefStable(precedence, ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env))\n+                Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env))\n             },\n             (position, _) => position,\n         }\n@@ -1348,7 +1348,7 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             | ty::Tuple(_)\n             | ty::Projection(_) => Position::DerefStable(\n                 precedence,\n-                ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n             )\n             .into(),\n         };"}, {"sha": "bff69f9151846d6bfa4831a75a8f2e175951b5fc", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -188,7 +188,7 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(adt, substs) => {\n-            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx, cx.param_env)\n                 || KNOWN_WRAPPER_TYS\n                     .iter()\n                     .any(|&sym| cx.tcx.is_diagnostic_item(sym, adt.did()))"}, {"sha": "db41bc67da1a7f34f1d57eef78db8d0c8f29b780", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     let span = stmt.span.to(if_.span);\n \n                     let has_interior_mutability = !cx.typeck_results().node_type(canonical_id).is_freeze(\n-                        cx.tcx.at(span),\n+                        cx.tcx,\n                         cx.param_env,\n                     );\n                     if has_interior_mutability { return; }"}, {"sha": "4b62dcdffe2fcf68a2481cac8bdc6af55b19c817", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -136,12 +136,14 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n /// [`Hash`] or [`Ord`].\n fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n     match *ty.kind() {\n-        Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span),\n+        Ref(_, inner_ty, mutbl) => {\n+            mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span)\n+        }\n         Slice(inner_ty) => is_interior_mutable_type(cx, inner_ty, span),\n         Array(inner_ty, size) => {\n             size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n                 && is_interior_mutable_type(cx, inner_ty, span)\n-        },\n+        }\n         Tuple(fields) => fields.iter().any(|ty| is_interior_mutable_type(cx, ty, span)),\n         Adt(def, substs) => {\n             // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n@@ -167,9 +169,9 @@ fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Sp\n             } else {\n                 !ty.has_escaping_bound_vars()\n                     && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                    && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                    && !ty.is_freeze(cx.tcx, cx.param_env)\n             }\n-        },\n+        }\n         _ => false,\n     }\n }"}, {"sha": "b2e9ce5c94d65db825d650b25e27505c93f48fc3", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, TypeVisitable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::kw;\n-use rustc_span::{sym, Span, DUMMY_SP};\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n@@ -184,7 +184,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !is_self(arg);\n                 if !ty.is_mutable_ptr();\n                 if !is_copy(cx, ty);\n-                if ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env);\n+                if ty.is_sized(cx.tcx, cx.param_env);\n                 if !allowed_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;"}, {"sha": "2a3bd4ee6ce65cadcedac6ac19558d43ac6b269a", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, InnerSpan, Span, DUMMY_SP};\n+use rustc_span::{sym, InnerSpan, Span};\n \n // FIXME: this is a correctness problem but there's no suitable\n // warn-by-default category.\n@@ -136,7 +136,7 @@ fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     // since it works when a pointer indirection involves (`Cell<*const T>`).\n     // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n     // but I'm not sure whether it's a decent way, if possible.\n-    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx, cx.param_env)\n }\n \n fn is_value_unfrozen_raw<'tcx>("}, {"sha": "bb86fb3b7d42f43858db4b853f7fe3cbcb6ca8f6", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -94,7 +94,7 @@ fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Ex\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let receiver_str = snippet_with_applicability(cx, caller.span, \"..\", &mut applicability);\n-            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx.at(caller.span), cx.param_env) &&\n+            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx, cx.param_env) &&\n                 !matches!(caller.kind, ExprKind::Call(..) | ExprKind::MethodCall(..));\n             let sugg = if let Some(else_inner) = r#else {\n                 if eq_expr_value(cx, caller, peel_blocks(else_inner)) {"}, {"sha": "3d4bbbf648c65bbfdc37ee89d0e8b4f412cb18e5", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 98, "deletions": 67, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -5,7 +5,6 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, IntTy, Ty, TypeAndMut, UintTy};\n-use rustc_span::DUMMY_SP;\n \n #[expect(clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n@@ -28,24 +27,32 @@ pub(super) fn check<'tcx>(\n \n             // `Repr(C)` <-> unordered type.\n             // If the first field of the `Repr(C)` type matches then the transmute is ok\n-            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::UnorderedFields(to_sub_ty))\n-            | (ReducedTy::UnorderedFields(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty))) => {\n+            (\n+                ReducedTy::OrderedFields(_, Some(from_sub_ty)),\n+                ReducedTy::UnorderedFields(to_sub_ty),\n+            )\n+            | (\n+                ReducedTy::UnorderedFields(from_sub_ty),\n+                ReducedTy::OrderedFields(_, Some(to_sub_ty)),\n+            ) => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n-            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty)) if reduced_tys.to_fat_ptr => {\n+            }\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty))\n+                if reduced_tys.to_fat_ptr =>\n+            {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n             (ReducedTy::Other(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty)))\n                 if reduced_tys.from_fat_ptr =>\n             {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n \n             // ptr <-> ptr\n             (ReducedTy::Other(from_sub_ty), ReducedTy::Other(to_sub_ty))\n@@ -55,19 +62,19 @@ pub(super) fn check<'tcx>(\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n \n             // fat ptr <-> (*size, *size)\n             (ReducedTy::Other(_), ReducedTy::UnorderedFields(to_ty))\n                 if reduced_tys.from_fat_ptr && is_size_pair(to_ty) =>\n             {\n                 return false;\n-            },\n+            }\n             (ReducedTy::UnorderedFields(from_ty), ReducedTy::Other(_))\n                 if reduced_tys.to_fat_ptr && is_size_pair(from_ty) =>\n             {\n                 return false;\n-            },\n+            }\n \n             // fat ptr -> some struct | some struct -> fat ptr\n             (ReducedTy::Other(_), _) if reduced_tys.from_fat_ptr => {\n@@ -78,12 +85,14 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty.peel_refs() {\n-                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{from_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (_, ReducedTy::Other(_)) if reduced_tys.to_fat_ptr => {\n                 span_lint_and_then(\n                     cx,\n@@ -92,14 +101,18 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute to `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty.peel_refs() {\n-                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{to_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n \n-            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n+            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty))\n+                if from_ty != to_ty =>\n+            {\n                 let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n                         = (from_ty.kind(), to_ty.kind())\n                         && from_def == to_def\n@@ -126,19 +139,25 @@ pub(super) fn check<'tcx>(\n                             ));\n                         } else {\n                             if from_ty_orig.peel_refs() != from_ty {\n-                                diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                                diag.note(&format!(\n+                                    \"the contained type `{from_ty}` has an undefined layout\"\n+                                ));\n                             }\n                             if to_ty_orig.peel_refs() != to_ty {\n-                                diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                                diag.note(&format!(\n+                                    \"the contained type `{to_ty}` has an undefined layout\"\n+                                ));\n                             }\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n                 ReducedTy::UnorderedFields(from_ty),\n-                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::Other(_)\n+                | ReducedTy::OrderedFields(..)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n             ) => {\n                 span_lint_and_then(\n                     cx,\n@@ -147,14 +166,18 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty {\n-                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{from_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n-                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::Other(_)\n+                | ReducedTy::OrderedFields(..)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n                 ReducedTy::UnorderedFields(to_ty),\n             ) => {\n                 span_lint_and_then(\n@@ -164,19 +187,25 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute into `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty {\n-                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{to_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n-                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n-                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..)\n+                | ReducedTy::Other(_)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..)\n+                | ReducedTy::Other(_)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n             )\n             | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => {\n                 break;\n-            },\n+            }\n         }\n     }\n \n@@ -194,42 +223,38 @@ struct ReducedTys<'tcx> {\n }\n \n /// Remove references so long as both types are references.\n-fn reduce_refs<'tcx>(cx: &LateContext<'tcx>, mut from_ty: Ty<'tcx>, mut to_ty: Ty<'tcx>) -> ReducedTys<'tcx> {\n+fn reduce_refs<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    mut from_ty: Ty<'tcx>,\n+    mut to_ty: Ty<'tcx>,\n+) -> ReducedTys<'tcx> {\n     let mut from_raw_ptr = false;\n     let mut to_raw_ptr = false;\n-    let (from_fat_ptr, to_fat_ptr) = loop {\n-        break match (from_ty.kind(), to_ty.kind()) {\n-            (\n-                &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n-                &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n-            ) => {\n-                from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n-                from_ty = from_sub_ty;\n-                to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n-                to_ty = to_sub_ty;\n-                continue;\n-            },\n-            (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n-                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n-            {\n-                (true, false)\n-            },\n-            (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n-                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n-            {\n-                (false, true)\n-            },\n-            _ => (false, false),\n+    let (from_fat_ptr, to_fat_ptr) =\n+        loop {\n+            break match (from_ty.kind(), to_ty.kind()) {\n+                (\n+                    &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n+                    &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n+                ) => {\n+                    from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n+                    from_ty = from_sub_ty;\n+                    to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                }\n+                (\n+                    &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })),\n+                    _,\n+                ) if !unsized_ty.is_sized(cx.tcx, cx.param_env) => (true, false),\n+                (\n+                    _,\n+                    &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })),\n+                ) if !unsized_ty.is_sized(cx.tcx, cx.param_env) => (false, true),\n+                _ => (false, false),\n+            };\n         };\n-    };\n-    ReducedTys {\n-        from_ty,\n-        to_ty,\n-        from_raw_ptr,\n-        to_raw_ptr,\n-        from_fat_ptr,\n-        to_fat_ptr,\n-    }\n+    ReducedTys { from_ty, to_ty, from_raw_ptr, to_raw_ptr, from_fat_ptr, to_fat_ptr }\n }\n \n enum ReducedTy<'tcx> {\n@@ -252,11 +277,11 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n         return match *ty.kind() {\n             ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => {\n                 ReducedTy::TypeErasure { raw_ptr_only: false }\n-            },\n+            }\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n                 ty = sub_ty;\n                 continue;\n-            },\n+            }\n             ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Tuple(args) => {\n                 let mut iter = args.iter();\n@@ -268,7 +293,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     continue;\n                 }\n                 ReducedTy::UnorderedFields(ty)\n-            },\n+            }\n             ty::Adt(def, substs) if def.is_struct() => {\n                 let mut iter = def\n                     .non_enum_variant()\n@@ -287,10 +312,12 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 } else {\n                     ReducedTy::UnorderedFields(ty)\n                 }\n-            },\n-            ty::Adt(def, _) if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) => {\n+            }\n+            ty::Adt(def, _)\n+                if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) =>\n+            {\n                 ReducedTy::TypeErasure { raw_ptr_only: false }\n-            },\n+            }\n             // TODO: Check if the conversion to or from at least one of a union's fields is valid.\n             ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Foreign(_) | ty::Param(_) => ReducedTy::TypeErasure { raw_ptr_only: false },\n@@ -329,7 +356,11 @@ fn same_except_params<'tcx>(subs1: SubstsRef<'tcx>, subs2: SubstsRef<'tcx>) -> b\n     for (ty1, ty2) in subs1.types().zip(subs2.types()).filter(|(ty1, ty2)| ty1 != ty2) {\n         match (ty1.kind(), ty2.kind()) {\n             (ty::Param(_), _) | (_, ty::Param(_)) => (),\n-            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2)) if adt1 == adt2 && same_except_params(subs1, subs2) => (),\n+            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2))\n+                if adt1 == adt2 && same_except_params(subs1, subs2) =>\n+            {\n+                ()\n+            }\n             _ => return false,\n         }\n     }"}, {"sha": "2b964b64a3305d702ea51f8684316d61fc758738", "filename": "src/tools/clippy/clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -9,7 +9,12 @@ use rustc_span::symbol::sym;\n \n use super::{utils, REDUNDANT_ALLOCATION};\n \n-pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    hir_ty: &hir::Ty<'_>,\n+    qpath: &QPath<'_>,\n+    def_id: DefId,\n+) -> bool {\n     let mut applicability = Applicability::MaybeIncorrect;\n     let outer_sym = if Some(def_id) == cx.tcx.lang_items().owned_box() {\n         \"Box\"\n@@ -29,7 +34,12 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             hir_ty.span,\n             &format!(\"usage of `{outer_sym}<{generic_snippet}>`\"),\n             |diag| {\n-                diag.span_suggestion(hir_ty.span, \"try\", format!(\"{generic_snippet}\"), applicability);\n+                diag.span_suggestion(\n+                    hir_ty.span,\n+                    \"try\",\n+                    format!(\"{generic_snippet}\"),\n+                    applicability,\n+                );\n                 diag.note(&format!(\n                     \"`{generic_snippet}` is already a pointer, `{outer_sym}<{generic_snippet}>` allocates a pointer on the heap\"\n                 ));\n@@ -55,11 +65,11 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             // Reallocation of a fat pointer causes it to become thin. `hir_ty_to_ty` is safe to use\n             // here because `mod.rs` guarantees this lint is only run on types outside of bodies and\n             // is not run on locals.\n-            if !hir_ty_to_ty(cx.tcx, ty).is_sized(cx.tcx.at(ty.span), cx.param_env) {\n+            if !hir_ty_to_ty(cx.tcx, ty).is_sized(cx.tcx, cx.param_env) {\n                 return false;\n             }\n             ty.span\n-        },\n+        }\n         None => return false,\n     };\n     if inner_sym == outer_sym {"}, {"sha": "9ad2cb853d39a474255c0256dd2e30e5ce778ecf", "filename": "src/tools/clippy/clippy_lints/src/types/vec_box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -40,7 +40,7 @@ pub(super) fn check(\n             });\n             let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n             if !ty_ty.has_escaping_bound_vars();\n-            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n+            if ty_ty.is_sized(cx.tcx, cx.param_env);\n             if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n             if ty_ty_size <= box_size_threshold;\n             then {"}, {"sha": "4e024ce4017932c2948c7095f510b4c594ee85cc", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::{\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::symbol::Ident;\n-use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n+use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::{Size, VariantIdx};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n@@ -28,7 +28,7 @@ use crate::{match_def_path, path_res, paths};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n+    ty.is_copy_modulo_regions(cx.tcx, cx.param_env)\n }\n \n /// This checks whether a given type is known to implement Debug."}, {"sha": "5ec787dd44113ae9618cf639ac7e7134cc8b984b", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2414a4c31a56a34ac6944e360b230ffe54a3a31b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=2414a4c31a56a34ac6944e360b230ffe54a3a31b", "patch": "@@ -16,7 +16,6 @@ use rustc_middle::ty::{\n     layout::{HasParamEnv, LayoutOf},\n     Ty,\n };\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::Abi;\n use rustc_target::abi::Size;\n use smallvec::SmallVec;\n@@ -714,12 +713,12 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 let mut kind_str = format!(\"{kind}\");\n                 match kind {\n                     RefKind::Unique { two_phase: false }\n-                        if !ty.is_unpin(this.tcx.at(DUMMY_SP), this.param_env()) =>\n+                        if !ty.is_unpin(*this.tcx, this.param_env()) =>\n                     {\n                         write!(kind_str, \" (!Unpin pointee type {ty})\").unwrap()\n                     },\n                     RefKind::Shared\n-                        if !ty.is_freeze(this.tcx.at(DUMMY_SP), this.param_env()) =>\n+                        if !ty.is_freeze(*this.tcx, this.param_env()) =>\n                     {\n                         write!(kind_str, \" (!Freeze pointee type {ty})\").unwrap()\n                     },\n@@ -834,7 +833,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n         let perm = match kind {\n             RefKind::Unique { two_phase: false }\n-                if place.layout.ty.is_unpin(this.tcx.at(DUMMY_SP), this.param_env()) =>\n+                if place.layout.ty.is_unpin(*this.tcx, this.param_env()) =>\n             {\n                 // Only if the type is unpin do we actually enforce uniqueness\n                 Permission::Unique"}]}