{"sha": "8c9a38f679a0dd70c65e094f3063318616eb8387", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjOWEzOGY2NzlhMGRkNzBjNjVlMDk0ZjMwNjMzMTg2MTZlYjgzODc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-13T22:23:24Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-15T21:29:42Z"}, "message": "Other `legacy` -> `macro_rules`", "tree": {"sha": "1bf47a7a1b005a49ca555cf5b1fb2f3c5d7b6b00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bf47a7a1b005a49ca555cf5b1fb2f3c5d7b6b00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c9a38f679a0dd70c65e094f3063318616eb8387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9a38f679a0dd70c65e094f3063318616eb8387", "html_url": "https://github.com/rust-lang/rust/commit/8c9a38f679a0dd70c65e094f3063318616eb8387", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c9a38f679a0dd70c65e094f3063318616eb8387/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fbb2549ce66e83583bb3bad83bbd15436b10d35", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fbb2549ce66e83583bb3bad83bbd15436b10d35", "html_url": "https://github.com/rust-lang/rust/commit/3fbb2549ce66e83583bb3bad83bbd15436b10d35"}], "stats": {"total": 66, "additions": 35, "deletions": 31}, "files": [{"sha": "99083cca6cb3443a6424aff1eec92335172bc74e", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=8c9a38f679a0dd70c65e094f3063318616eb8387", "patch": "@@ -1024,7 +1024,7 @@ pub enum TransparencyError {\n \n pub fn find_transparency(\n     attrs: &[Attribute],\n-    is_legacy: bool,\n+    macro_rules: bool,\n ) -> (Transparency, Option<TransparencyError>) {\n     let mut transparency = None;\n     let mut error = None;\n@@ -1049,7 +1049,7 @@ pub fn find_transparency(\n             }\n         }\n     }\n-    let fallback = if is_legacy { Transparency::SemiTransparent } else { Transparency::Opaque };\n+    let fallback = if macro_rules { Transparency::SemiTransparent } else { Transparency::Opaque };\n     (transparency.map_or(fallback, |t| t.0), error)\n }\n "}, {"sha": "8c6bfbec902775e8756ac8397c38577a387114d7", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=8c9a38f679a0dd70c65e094f3063318616eb8387", "patch": "@@ -419,10 +419,10 @@ fn check_nested_occurrences(\n             | (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n                 if del.delim == DelimToken::Brace =>\n             {\n-                let legacy = state == NestedMacroState::MacroRulesNotName;\n+                let macro_rules = state == NestedMacroState::MacroRulesNotName;\n                 state = NestedMacroState::Empty;\n                 let rest =\n-                    check_nested_macro(sess, node_id, legacy, &del.tts, &nested_macros, valid);\n+                    check_nested_macro(sess, node_id, macro_rules, &del.tts, &nested_macros, valid);\n                 // If we did not check the whole macro definition, then check the rest as if outside\n                 // the macro definition.\n                 check_nested_occurrences(\n@@ -493,21 +493,21 @@ fn check_nested_occurrences(\n /// Arguments:\n /// - `sess` is used to emit diagnostics and lints\n /// - `node_id` is used to emit lints\n-/// - `legacy` specifies whether the macro is legacy\n+/// - `macro_rules` specifies whether the macro is `macro_rules`\n /// - `tts` is checked as a list of (LHS) => {RHS}\n /// - `macros` is the stack of outer macros\n /// - `valid` is set in case of errors\n fn check_nested_macro(\n     sess: &ParseSess,\n     node_id: NodeId,\n-    legacy: bool,\n+    macro_rules: bool,\n     tts: &[TokenTree],\n     macros: &Stack<'_, MacroState<'_>>,\n     valid: &mut bool,\n ) -> usize {\n     let n = tts.len();\n     let mut i = 0;\n-    let separator = if legacy { TokenKind::Semi } else { TokenKind::Comma };\n+    let separator = if macro_rules { TokenKind::Semi } else { TokenKind::Comma };\n     loop {\n         // We expect 3 token trees: `(LHS) => {RHS}`. The separator is checked after.\n         if i + 2 >= n\n@@ -522,7 +522,7 @@ fn check_nested_macro(\n         let mut binders = Binders::default();\n         check_binders(sess, node_id, lhs, macros, &mut binders, &Stack::Empty, valid);\n         check_occurrences(sess, node_id, rhs, macros, &binders, &Stack::Empty, valid);\n-        // Since the last semicolon is optional for legacy macros and decl_macro are not terminated,\n+        // Since the last semicolon is optional for `macro_rules` macros and decl_macro are not terminated,\n         // we increment our checked position by how many token trees we already checked (the 3\n         // above) before checking for the separator.\n         i += 3;"}, {"sha": "e927bcd07e2cd2ed1a4465ff2207664cd910e32e", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=8c9a38f679a0dd70c65e094f3063318616eb8387", "patch": "@@ -1270,7 +1270,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(2, |t| t.is_ident())\n     }\n \n-    /// Parses a legacy `macro_rules! foo { ... }` declarative macro.\n+    /// Parses a `macro_rules! foo { ... }` declarative macro.\n     fn parse_item_macro_rules(&mut self, vis: &Visibility) -> PResult<'a, ItemInfo> {\n         self.expect_keyword(kw::MacroRules)?; // `macro_rules`\n         self.expect(&token::Not)?; // `!`"}, {"sha": "f7bbba28c070e8b11f4005116851dbe40a50dc2f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8c9a38f679a0dd70c65e094f3063318616eb8387", "patch": "@@ -624,7 +624,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                let used = self.process_legacy_macro_imports(item, module);\n+                let used = self.process_macro_use_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n                 let import = self.r.arenas.alloc_import(Import {\n@@ -913,7 +913,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn legacy_import_macro(\n+    fn add_macro_use_binding(\n         &mut self,\n         name: ast::Name,\n         binding: &'a NameBinding<'a>,\n@@ -929,7 +929,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Returns `true` if we should consider the underlying `extern crate` to be used.\n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>) -> bool {\n+    fn process_macro_use_imports(&mut self, item: &Item, module: Module<'a>) -> bool {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n@@ -1004,7 +1004,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             module.for_each_child(self, |this, ident, ns, binding| {\n                 if ns == MacroNS {\n                     let imported_binding = this.r.import(binding, import);\n-                    this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n+                    this.add_macro_use_binding(ident.name, imported_binding, span, allow_shadowing);\n                 }\n             });\n         } else {\n@@ -1021,7 +1021,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     let import = macro_use_import(self, ident.span);\n                     self.r.potentially_unused_imports.push(import);\n                     let imported_binding = self.r.import(binding, import);\n-                    self.legacy_import_macro(\n+                    self.add_macro_use_binding(\n                         ident.name,\n                         imported_binding,\n                         ident.span,"}, {"sha": "c4338710478366e80cf765b526248db884b11174", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8c9a38f679a0dd70c65e094f3063318616eb8387", "patch": "@@ -618,7 +618,7 @@ enum AmbiguityKind {\n     Import,\n     BuiltinAttr,\n     DeriveHelper,\n-    LegacyVsModern,\n+    MacroRulesVsModularized,\n     GlobVsOuter,\n     GlobVsGlob,\n     GlobVsExpanded,\n@@ -631,7 +631,9 @@ impl AmbiguityKind {\n             AmbiguityKind::Import => \"name vs any other name during import resolution\",\n             AmbiguityKind::BuiltinAttr => \"built-in attribute vs any other name\",\n             AmbiguityKind::DeriveHelper => \"derive helper attribute vs any other name\",\n-            AmbiguityKind::LegacyVsModern => \"`macro_rules` vs non-`macro_rules` from other module\",\n+            AmbiguityKind::MacroRulesVsModularized => {\n+                \"`macro_rules` vs non-`macro_rules` from other module\"\n+            }\n             AmbiguityKind::GlobVsOuter => {\n                 \"glob import vs any other name from outer scope during import/macro resolution\"\n             }\n@@ -1473,7 +1475,7 @@ impl<'a> Resolver<'a> {\n         //    derives (you need to resolve the derive first to add helpers into scope), but they\n         //    should be available before the derive is expanded for compatibility.\n         //    It's mess in general, so we are being conservative for now.\n-        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n+        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n         //    priority than prelude macros, but create ambiguities with macros in modules.\n         // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n         //    (open, not controlled). Have higher priority than prelude macros, but create\n@@ -1639,7 +1641,7 @@ impl<'a> Resolver<'a> {\n         for i in (0..ribs.len()).rev() {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n             // Use the rib kind to determine whether we are resolving parameters\n-            // (modern hygiene) or local variables (legacy hygiene).\n+            // (modern hygiene) or local variables (`macro_rules` hygiene).\n             let rib_ident = if ribs[i].kind.contains_params() { modern_ident } else { ident };\n             if let Some(res) = ribs[i].bindings.get(&rib_ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n@@ -1898,7 +1900,7 @@ impl<'a> Resolver<'a> {\n                     break;\n                 }\n             }\n-            // Then find the last legacy mark from the end if it exists.\n+            // Then find the last semi-transparent mark from the end if it exists.\n             for (mark, transparency) in iter {\n                 if transparency == Transparency::SemiTransparent {\n                     result = Some(mark);\n@@ -2423,21 +2425,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn disambiguate_legacy_vs_modern(\n+    fn disambiguate_macro_rules_vs_modularized(\n         &self,\n-        legacy: &'a NameBinding<'a>,\n-        modern: &'a NameBinding<'a>,\n+        macro_rules: &'a NameBinding<'a>,\n+        modularized: &'a NameBinding<'a>,\n     ) -> bool {\n         // Some non-controversial subset of ambiguities \"modern macro name\" vs \"macro_rules\"\n         // is disambiguated to mitigate regressions from macro modularization.\n         // Scoping for `macro_rules` behaves like scoping for `let` at module level, in general.\n         match (\n-            self.binding_parent_modules.get(&PtrKey(legacy)),\n-            self.binding_parent_modules.get(&PtrKey(modern)),\n+            self.binding_parent_modules.get(&PtrKey(macro_rules)),\n+            self.binding_parent_modules.get(&PtrKey(modularized)),\n         ) {\n-            (Some(legacy), Some(modern)) => {\n-                legacy.normal_ancestor_id == modern.normal_ancestor_id\n-                    && modern.is_ancestor_of(legacy)\n+            (Some(macro_rules), Some(modularized)) => {\n+                macro_rules.normal_ancestor_id == modularized.normal_ancestor_id\n+                    && modularized.is_ancestor_of(macro_rules)\n             }\n             _ => false,\n         }"}, {"sha": "f4dfa037dae4d551a2bd82b15186b19114d1b2fe", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9a38f679a0dd70c65e094f3063318616eb8387/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8c9a38f679a0dd70c65e094f3063318616eb8387", "patch": "@@ -761,16 +761,18 @@ impl<'a> Resolver<'a> {\n                                     Some(AmbiguityKind::DeriveHelper)\n                                 } else if innermost_flags.contains(Flags::MACRO_RULES)\n                                     && flags.contains(Flags::MODULE)\n-                                    && !this\n-                                        .disambiguate_legacy_vs_modern(innermost_binding, binding)\n+                                    && !this.disambiguate_macro_rules_vs_modularized(\n+                                        innermost_binding,\n+                                        binding,\n+                                    )\n                                     || flags.contains(Flags::MACRO_RULES)\n                                         && innermost_flags.contains(Flags::MODULE)\n-                                        && !this.disambiguate_legacy_vs_modern(\n+                                        && !this.disambiguate_macro_rules_vs_modularized(\n                                             binding,\n                                             innermost_binding,\n                                         )\n                                 {\n-                                    Some(AmbiguityKind::LegacyVsModern)\n+                                    Some(AmbiguityKind::MacroRulesVsModularized)\n                                 } else if innermost_binding.is_glob_import() {\n                                     Some(AmbiguityKind::GlobVsOuter)\n                                 } else if innermost_binding"}]}