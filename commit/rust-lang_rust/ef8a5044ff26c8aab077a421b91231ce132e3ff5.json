{"sha": "ef8a5044ff26c8aab077a421b91231ce132e3ff5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOGE1MDQ0ZmYyNmM4YWFiMDc3YTQyMWI5MTIzMWNlMTMyZTNmZjU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-14T00:54:14Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-22T00:17:50Z"}, "message": "rustc: More helpful error message when using a struct type like a function\n\nCloses #6702", "tree": {"sha": "b095189873434979fe08d344eb89828429a213d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b095189873434979fe08d344eb89828429a213d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef8a5044ff26c8aab077a421b91231ce132e3ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef8a5044ff26c8aab077a421b91231ce132e3ff5", "html_url": "https://github.com/rust-lang/rust/commit/ef8a5044ff26c8aab077a421b91231ce132e3ff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef8a5044ff26c8aab077a421b91231ce132e3ff5/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5622ce10fe6d0a06ac935214a729683bc2cc3d2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5622ce10fe6d0a06ac935214a729683bc2cc3d2c", "html_url": "https://github.com/rust-lang/rust/commit/5622ce10fe6d0a06ac935214a729683bc2cc3d2c"}], "stats": {"total": 113, "additions": 66, "deletions": 47}, "files": [{"sha": "2e8748e4ff8328552e80596b43b5a3b1e349d4cc", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 66, "deletions": 47, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ef8a5044ff26c8aab077a421b91231ce132e3ff5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef8a5044ff26c8aab077a421b91231ce132e3ff5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ef8a5044ff26c8aab077a421b91231ce132e3ff5", "patch": "@@ -831,6 +831,7 @@ pub fn Resolver(session: Session,\n         trait_map: HashMap::new(),\n         used_imports: HashSet::new(),\n \n+        emit_errors: true,\n         intr: session.intr()\n     };\n \n@@ -888,6 +889,11 @@ pub struct Resolver {\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n \n+    // Whether or not to print error messages. Can be set to true\n+    // when getting additional info for error message suggestions,\n+    // so as to avoid printing duplicate errors\n+    emit_errors: bool,\n+\n     used_imports: HashSet<NodeId>,\n }\n \n@@ -1072,7 +1078,7 @@ impl Resolver {\n                     // Return an error here by looking up the namespace that\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n-                    self.session.span_err(sp,\n+                    self.resolve_error(sp,\n                         fmt!(\"duplicate definition of %s `%s`\",\n                              namespace_error_to_str(duplicate_type),\n                              self.session.str_of(name)));\n@@ -2074,7 +2080,7 @@ impl Resolver {\n                                    self.import_path_to_str(\n                                        import_directive.module_path,\n                                        *import_directive.subclass));\n-                    self.session.span_err(import_directive.span, msg);\n+                    self.resolve_error(import_directive.span, msg);\n                 }\n                 Indeterminate => {\n                     // Bail out. We'll come around next time.\n@@ -2445,12 +2451,12 @@ impl Resolver {\n \n         let span = directive.span;\n         if resolve_fail {\n-            self.session.span_err(span, fmt!(\"unresolved import: there is no `%s` in `%s`\",\n+            self.resolve_error(span, fmt!(\"unresolved import: there is no `%s` in `%s`\",\n                                              self.session.str_of(source),\n                                              self.module_to_str(containing_module)));\n             return Failed;\n         } else if priv_fail {\n-            self.session.span_err(span, fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n+            self.resolve_error(span, fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n                                              private\", self.session.str_of(source),\n                                              self.module_to_str(containing_module)));\n             return Failed;\n@@ -2617,14 +2623,14 @@ impl Resolver {\n                             hi: span.lo + BytePos(segment_name.len()),\n                             expn_info: span.expn_info,\n                         };\n-                        self.session.span_err(span,\n+                        self.resolve_error(span,\n                                               fmt!(\"unresolved import. maybe \\\n                                                     a missing `extern mod \\\n                                                     %s`?\",\n                                                     segment_name));\n                         return Failed;\n                     }\n-                    self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` in \\\n+                    self.resolve_error(span, fmt!(\"unresolved import: could not find `%s` in \\\n                                                      `%s`.\", segment_name, module_name));\n                     return Failed;\n                 }\n@@ -2642,7 +2648,7 @@ impl Resolver {\n                             match type_def.module_def {\n                                 None => {\n                                     // Not a module.\n-                                    self.session.span_err(span,\n+                                    self.resolve_error(span,\n                                                           fmt!(\"not a \\\n                                                                 module `%s`\",\n                                                                self.session.\n@@ -2658,7 +2664,7 @@ impl Resolver {\n                                            module_def.kind) {\n                                         (ImportSearch, TraitModuleKind) |\n                                         (ImportSearch, ImplModuleKind) => {\n-                                            self.session.span_err(\n+                                            self.resolve_error(\n                                                 span,\n                                                 \"cannot import from a trait \\\n                                                  or type implementation\");\n@@ -2671,7 +2677,7 @@ impl Resolver {\n                         }\n                         None => {\n                             // There are no type bindings at all.\n-                            self.session.span_err(span,\n+                            self.resolve_error(span,\n                                                   fmt!(\"not a module `%s`\",\n                                                        self.session.str_of(\n                                                             name)));\n@@ -2723,7 +2729,7 @@ impl Resolver {\n                 let mpath = self.idents_to_str(module_path);\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n-                        self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` \\\n+                        self.resolve_error(span, fmt!(\"unresolved import: could not find `%s` \\\n                                                          in `%s`\",\n                                                          // idx +- 1 to account for the colons\n                                                          // on either side\n@@ -2759,8 +2765,7 @@ impl Resolver {\n                             module_path[0]);\n                         match result {\n                             Failed => {\n-                                self.session.span_err(span,\n-                                                      \"unresolved name\");\n+                                self.resolve_error(span, \"unresolved name\");\n                                 return Failed;\n                             }\n                             Indeterminate => {\n@@ -3140,11 +3145,11 @@ impl Resolver {\n         if index != import_count {\n             let sn = self.session.codemap.span_to_snippet(imports[index].span).unwrap();\n             if sn.contains(\"::\") {\n-                self.session.span_err(imports[index].span, \"unresolved import\");\n+                self.resolve_error(imports[index].span, \"unresolved import\");\n             } else {\n                 let err = fmt!(\"unresolved import (maybe you meant `%s::*`?)\",\n                                sn.slice(0, sn.len()));\n-                self.session.span_err(imports[index].span, err);\n+                self.resolve_error(imports[index].span, err);\n             }\n         }\n \n@@ -3409,15 +3414,15 @@ impl Resolver {\n                         // named function item. This is not allowed, so we\n                         // report an error.\n \n-                        self.session.span_err(\n+                        self.resolve_error(\n                             span,\n                             \"can't capture dynamic environment in a fn item; \\\n                             use the || { ... } closure form instead\");\n                     } else {\n                         // This was an attempt to use a type parameter outside\n                         // its scope.\n \n-                        self.session.span_err(span,\n+                        self.resolve_error(span,\n                                               \"attempt to use a type \\\n                                               argument out of scope\");\n                     }\n@@ -3432,15 +3437,15 @@ impl Resolver {\n                         // named function item. This is not allowed, so we\n                         // report an error.\n \n-                        self.session.span_err(\n+                        self.resolve_error(\n                             span,\n                             \"can't capture dynamic environment in a fn item; \\\n                             use the || { ... } closure form instead\");\n                     } else {\n                         // This was an attempt to use a type parameter outside\n                         // its scope.\n \n-                        self.session.span_err(span,\n+                        self.resolve_error(span,\n                                               \"attempt to use a type \\\n                                               argument out of scope\");\n                     }\n@@ -3449,7 +3454,7 @@ impl Resolver {\n                 }\n                 ConstantItemRibKind => {\n                     // Still doesn't deal with upvars\n-                    self.session.span_err(span,\n+                    self.resolve_error(span,\n                                           \"attempt to use a non-constant \\\n                                            value in a constant\");\n \n@@ -3846,7 +3851,7 @@ impl Resolver {\n                 };\n \n                 let msg = fmt!(\"attempt to %s a nonexistent trait `%s`\", usage_str, path_str);\n-                self.session.span_err(trait_reference.path.span, msg);\n+                self.resolve_error(trait_reference.path.span, msg);\n             }\n             Some(def) => {\n                 debug!(\"(resolving trait) found trait def: %?\", def);\n@@ -3867,7 +3872,7 @@ impl Resolver {\n                     match ident_map.find(&ident) {\n                         Some(&prev_field) => {\n                             let ident_str = self.session.str_of(ident);\n-                            self.session.span_err(field.span,\n+                            self.resolve_error(field.span,\n                                 fmt!(\"field `%s` is already declared\", ident_str));\n                             self.session.span_note(prev_field.span,\n                                 \"Previously declared here\");\n@@ -4052,15 +4057,15 @@ impl Resolver {\n             for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n                   None => {\n-                    self.session.span_err(\n+                    self.resolve_error(\n                         p.span,\n                         fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n                              self.session.str_of(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        self.session.span_err(\n+                        self.resolve_error(\n                             binding_i.span,\n                             fmt!(\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n@@ -4072,7 +4077,7 @@ impl Resolver {\n \n             for (&key, &binding) in map_i.iter() {\n                 if !map_0.contains_key(&key) {\n-                    self.session.span_err(\n+                    self.resolve_error(\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n@@ -4185,7 +4190,7 @@ impl Resolver {\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n-                        self.session.span_err\n+                        self.resolve_error\n                             (ty.span, fmt!(\"use of undeclared type name `%s`\",\n                                            self.idents_to_str(path.idents)));\n                     }\n@@ -4253,7 +4258,7 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         FoundStructOrEnumVariant(_) => {\n-                            self.session.span_err(pattern.span,\n+                            self.resolve_error(pattern.span,\n                                                   fmt!(\"declaration of `%s` \\\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n@@ -4273,7 +4278,7 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         FoundConst(_) => {\n-                            self.session.span_err(pattern.span,\n+                            self.resolve_error(pattern.span,\n                                                   \"only refutable patterns \\\n                                                    allowed here\");\n                         }\n@@ -4327,7 +4332,7 @@ impl Resolver {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n-                                     self.session.span_err(pattern.span,\n+                                     self.resolve_error(pattern.span,\n                                        fmt!(\"Identifier `%s` is bound more \\\n                                              than once in the same pattern\",\n                                             path_to_str(path, self.session\n@@ -4367,14 +4372,14 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n-                            self.session.span_err(\n+                            self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant or constant\",\n                                      self.session.str_of(\n                                          *path.idents.last())));\n                         }\n                         None => {\n-                            self.session.span_err(path.span,\n+                            self.resolve_error(path.span,\n                                                   \"unresolved enum variant\");\n                         }\n                     }\n@@ -4395,14 +4400,14 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n-                            self.session.span_err(\n+                            self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant, struct or const\",\n                                      self.session.str_of(\n                                          *path.idents.last())));\n                         }\n                         None => {\n-                            self.session.span_err(path.span,\n+                            self.resolve_error(path.span,\n                                                   \"unresolved enum variant, \\\n                                                    struct or const\");\n                         }\n@@ -4441,7 +4446,7 @@ impl Resolver {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: %?\", result);\n-                            self.session.span_err(\n+                            self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` does not name a structure\",\n                                      self.idents_to_str(path.idents)));\n@@ -4661,7 +4666,7 @@ impl Resolver {\n                                        path.span,\n                                        PathPublicOnlySearch) {\n             Failed => {\n-                self.session.span_err(path.span,\n+                self.resolve_error(path.span,\n                                       fmt!(\"use of undeclared module `%s`\",\n                                            self.idents_to_str(\n                                                module_path_idents)));\n@@ -4729,7 +4734,7 @@ impl Resolver {\n                                                  path.span,\n                                                  PathPublicOrPrivateSearch) {\n             Failed => {\n-                self.session.span_err(path.span,\n+                self.resolve_error(path.span,\n                                       fmt!(\"use of undeclared module `::%s`\",\n                                             self.idents_to_str(\n                                               module_path_idents)));\n@@ -4855,6 +4860,19 @@ impl Resolver {\n         }\n     }\n \n+    fn with_no_errors<T>(@mut self, f: &fn() -> T) -> T {\n+        self.emit_errors = false;\n+        let rs = f();\n+        self.emit_errors = true;\n+        rs\n+    }\n+\n+    fn resolve_error(@mut self, span: span, s: &str) {\n+        if self.emit_errors {\n+            self.session.span_err(span, s);\n+        }\n+    }\n+\n     pub fn find_best_match_for_name(@mut self,\n                                     name: &str,\n                                     max_distance: uint)\n@@ -4954,7 +4972,7 @@ impl Resolver {\n                         // out here.\n                         match def {\n                             def_method(*) => {\n-                                self.session.span_err(expr.span,\n+                                self.resolve_error(expr.span,\n                                                       \"first-class methods \\\n                                                        are not supported\");\n                                 self.session.span_note(expr.span,\n@@ -4971,7 +4989,7 @@ impl Resolver {\n                         let wrong_name = self.idents_to_str(\n                             path.idents);\n                         if self.name_exists_in_scope_struct(wrong_name) {\n-                            self.session.span_err(expr.span,\n+                            self.resolve_error(expr.span,\n                                         fmt!(\"unresolved name `%s`. \\\n                                             Did you mean `self.%s`?\",\n                                         wrong_name,\n@@ -4980,12 +4998,13 @@ impl Resolver {\n                         else {\n                             // Be helpful if the name refers to a struct\n                             // (The pattern matching def_tys where the id is in self.structs\n-                            // matches on regular structs while excluding tuple- and\n-                            // enum-like structs, which wouldn't result in this error.)\n-                            match self.resolve_path(expr.id, path, TypeNS, false, visitor) {\n+                            // matches on regular structs while excluding tuple- and enum-like\n+                            // structs, which wouldn't result in this error.)\n+                            match self.with_no_errors(||\n+                                self.resolve_path(expr.id, path, TypeNS, false, visitor)) {\n                                 Some(def_ty(struct_id))\n                                   if self.structs.contains(&struct_id) => {\n-                                    self.session.span_err(expr.span,\n+                                    self.resolve_error(expr.span,\n                                             fmt!(\"`%s` is a structure name, but this expression \\\n                                                 uses it like a function name\", wrong_name));\n \n@@ -4998,13 +5017,13 @@ impl Resolver {\n                                    // of stupid suggestions\n                                    match self.find_best_match_for_name(wrong_name, 5) {\n                                        Some(m) => {\n-                                           self.session.span_err(expr.span,\n+                                           self.resolve_error(expr.span,\n                                                fmt!(\"unresolved name `%s`. \\\n                                                    Did you mean `%s`?\",\n                                                    wrong_name, m));\n                                        }\n                                        None => {\n-                                           self.session.span_err(expr.span,\n+                                           self.resolve_error(expr.span,\n                                                 fmt!(\"unresolved name `%s`.\",\n                                                     wrong_name));\n                                        }\n@@ -5041,7 +5060,7 @@ impl Resolver {\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n                                 def: %?\", result);\n-                        self.session.span_err(\n+                        self.resolve_error(\n                             path.span,\n                             fmt!(\"`%s` does not name a structure\",\n                                  self.idents_to_str(path.idents)));\n@@ -5070,7 +5089,7 @@ impl Resolver {\n                 match self.search_ribs(self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n-                        self.session.span_err(expr.span,\n+                        self.resolve_error(expr.span,\n                                               fmt!(\"use of undeclared label \\\n                                                    `%s`\",\n                                                    self.session.str_of(\n@@ -5089,7 +5108,7 @@ impl Resolver {\n             expr_self => {\n                 match self.resolve_self_value_in_local_ribs(expr.span) {\n                     None => {\n-                        self.session.span_err(expr.span,\n+                        self.resolve_error(expr.span,\n                                               \"`self` is not allowed in \\\n                                                this context\")\n                     }\n@@ -5320,7 +5339,7 @@ impl Resolver {\n         match pat_binding_mode {\n             bind_infer => {}\n             bind_by_ref(*) => {\n-                self.session.span_err(\n+                self.resolve_error(\n                     pat.span,\n                     fmt!(\"cannot use `ref` binding mode with %s\",\n                          descr));"}]}