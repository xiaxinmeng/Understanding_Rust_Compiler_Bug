{"sha": "e75203ce82357f6d0f81d5644e77d3c2efe53fcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NTIwM2NlODIzNTdmNmQwZjgxZDU2NDRlNzdkM2MyZWZlNTNmY2I=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-04-29T02:54:41Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-04-29T02:54:41Z"}, "message": "Adds '--print-link-args' that outputs linker arguments that would be used", "tree": {"sha": "0a366c7913782b2d27c90f1a0222e1746ef6a05c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a366c7913782b2d27c90f1a0222e1746ef6a05c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e75203ce82357f6d0f81d5644e77d3c2efe53fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e75203ce82357f6d0f81d5644e77d3c2efe53fcb", "html_url": "https://github.com/rust-lang/rust/commit/e75203ce82357f6d0f81d5644e77d3c2efe53fcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e75203ce82357f6d0f81d5644e77d3c2efe53fcb/comments", "author": null, "committer": null, "parents": [{"sha": "00ede34fcb4d6de11e49360964565c8e487a678e", "url": "https://api.github.com/repos/rust-lang/rust/commits/00ede34fcb4d6de11e49360964565c8e487a678e", "html_url": "https://github.com/rust-lang/rust/commit/00ede34fcb4d6de11e49360964565c8e487a678e"}], "stats": {"total": 194, "additions": 114, "deletions": 80}, "files": [{"sha": "adaffe5873dabc1de9466e600364fdb0b6d68fc9", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 97, "deletions": 79, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/e75203ce82357f6d0f81d5644e77d3c2efe53fcb/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75203ce82357f6d0f81d5644e77d3c2efe53fcb/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e75203ce82357f6d0f81d5644e77d3c2efe53fcb", "patch": "@@ -747,6 +747,71 @@ pub fn link_binary(sess: Session,\n                    obj_filename: &Path,\n                    out_filename: &Path,\n                    lm: LinkMeta) {\n+    // In the future, FreeBSD will use clang as default compiler.\n+    // It would be flexible to use cc (system's default C compiler)\n+    // instead of hard-coded gcc.\n+    // For win32, there is no cc command,\n+    // so we add a condition to make it use gcc.\n+    let cc_prog: ~str = if sess.targ_cfg.os == session::os_android {\n+        match &sess.opts.android_cross_path {\n+            &Some(copy path) => {\n+                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n+            }\n+            &None => {\n+                sess.fatal(~\"need Android NDK path for linking \\\n+                             (--android-cross-path)\")\n+            }\n+        }\n+    } else if sess.targ_cfg.os == session::os_win32 { ~\"gcc\" }\n+    else { ~\"cc\" };\n+    // The invocations of cc share some flags across platforms\n+\n+\n+    let output = if *sess.building_library {\n+        let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n+        debug!(\"link_meta.name:  %s\", lm.name);\n+        debug!(\"long_libname: %s\", long_libname);\n+        debug!(\"out_filename: %s\", out_filename.to_str());\n+        debug!(\"dirname(out_filename): %s\", out_filename.dir_path().to_str());\n+\n+        out_filename.dir_path().push(long_libname)\n+    } else {\n+        /*bad*/copy *out_filename\n+    };\n+\n+    debug!(\"output: %s\", output.to_str());\n+    let mut cc_args = link_args(sess, obj_filename, out_filename, lm);\n+    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n+    // We run 'cc' here\n+    let prog = run::program_output(cc_prog, cc_args);\n+    if 0 != prog.status {\n+        sess.err(fmt!(\"linking with `%s` failed with code %d\",\n+                      cc_prog, prog.status));\n+        sess.note(fmt!(\"%s arguments: %s\",\n+                       cc_prog, str::connect(cc_args, ~\" \")));\n+        sess.note(prog.err + prog.out);\n+        sess.abort_if_errors();\n+    }\n+\n+    // Clean up on Darwin\n+    if sess.targ_cfg.os == session::os_macos {\n+        run::run_program(~\"dsymutil\", ~[output.to_str()]);\n+    }\n+\n+    // Remove the temporary object file if we aren't saving temps\n+    if !sess.opts.save_temps {\n+        if ! os::remove_file(obj_filename) {\n+            sess.warn(fmt!(\"failed to delete object file `%s`\",\n+                           obj_filename.to_str()));\n+        }\n+    }\n+}\n+\n+pub fn link_args(sess: Session,\n+                 obj_filename: &Path,\n+                 out_filename: &Path,\n+                 lm:LinkMeta) -> ~[~str] {\n+\n     // Converts a library file-stem into a cc -l argument\n     fn unlib(config: @session::config, stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n@@ -757,48 +822,23 @@ pub fn link_binary(sess: Session,\n         }\n     }\n \n+\n     let output = if *sess.building_library {\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n-        debug!(\"link_meta.name:  %s\", lm.name);\n-        debug!(\"long_libname: %s\", long_libname);\n-        debug!(\"out_filename: %s\", out_filename.to_str());\n-        debug!(\"dirname(out_filename): %s\", out_filename.dir_path().to_str());\n-\n         out_filename.dir_path().push(long_libname)\n     } else {\n         /*bad*/copy *out_filename\n     };\n \n-    debug!(\"output: %s\", output.to_str());\n-\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     let stage: ~str = ~\"-L\" + sess.filesearch.get_target_lib_path().to_str();\n \n-    // In the future, FreeBSD will use clang as default compiler.\n-    // It would be flexible to use cc (system's default C compiler)\n-    // instead of hard-coded gcc.\n-    // For win32, there is no cc command,\n-    // so we add a condition to make it use gcc.\n-    let cc_prog: ~str = if sess.targ_cfg.os == session::os_android {\n-        match &sess.opts.android_cross_path {\n-            &Some(copy path) => {\n-                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n-            }\n-            &None => {\n-                sess.fatal(~\"need Android NDK path for linking \\\n-                             (--android-cross-path)\")\n-            }\n-        }\n-    } else if sess.targ_cfg.os == session::os_win32 { ~\"gcc\" }\n-    else { ~\"cc\" };\n-    // The invocations of cc share some flags across platforms\n+    let mut args = vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n \n-    let mut cc_args =\n-        vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n-    cc_args.push(~\"-o\");\n-    cc_args.push(output.to_str());\n-    cc_args.push(obj_filename.to_str());\n+    args.push(~\"-o\");\n+    args.push(output.to_str());\n+    args.push(obj_filename.to_str());\n \n     let lib_cmd;\n     let os = sess.targ_cfg.os;\n@@ -813,23 +853,23 @@ pub fn link_binary(sess: Session,\n     let cstore = sess.cstore;\n     for cstore::get_used_crate_files(cstore).each |cratepath| {\n         if cratepath.filetype() == Some(~\".rlib\") {\n-            cc_args.push(cratepath.to_str());\n+            args.push(cratepath.to_str());\n             loop;\n         }\n         let dir = cratepath.dirname();\n-        if dir != ~\"\" { cc_args.push(~\"-L\" + dir); }\n+        if dir != ~\"\" { args.push(~\"-L\" + dir); }\n         let libarg = unlib(sess.targ_cfg, cratepath.filestem().get());\n-        cc_args.push(~\"-l\" + libarg);\n+        args.push(~\"-l\" + libarg);\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { cc_args.push(/*bad*/copy *arg); }\n+    for ula.each |arg| { args.push(/*bad*/copy *arg); }\n \n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n         let link_args = csearch::get_link_args_for_crate(cstore, crate_num);\n         do vec::consume(link_args) |_, link_arg| {\n-            cc_args.push(link_arg);\n+            args.push(link_arg);\n         }\n     }\n \n@@ -842,96 +882,74 @@ pub fn link_binary(sess: Session,\n     // forces to make sure that library can be found at runtime.\n \n     for sess.opts.addl_lib_search_paths.each |path| {\n-        cc_args.push(~\"-L\" + path.to_str());\n+        args.push(~\"-L\" + path.to_str());\n     }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each |l| { cc_args.push(~\"-l\" + *l); }\n+    for used_libs.each |l| { args.push(~\"-l\" + *l); }\n \n     if *sess.building_library {\n-        cc_args.push(lib_cmd);\n+        args.push(lib_cmd);\n \n         // On mac we need to tell the linker to let this library\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n-            cc_args.push(~\"-Wl,-install_name,@rpath/\"\n+            args.push(~\"-Wl,-install_name,@rpath/\"\n                       + output.filename().get());\n         }\n     }\n \n     // On linux librt and libdl are an indirect dependencies via rustrt,\n     // and binutils 2.22+ won't add them automatically\n     if sess.targ_cfg.os == session::os_linux {\n-        cc_args.push_all(~[~\"-lrt\", ~\"-ldl\"]);\n+        args.push_all(~[~\"-lrt\", ~\"-ldl\"]);\n \n         // LLVM implements the `frem` instruction as a call to `fmod`,\n         // which lives in libm. Similar to above, on some linuxes we\n         // have to be explicit about linking to it. See #2510\n-        cc_args.push(~\"-lm\");\n+        args.push(~\"-lm\");\n     }\n     else if sess.targ_cfg.os == session::os_android {\n-        cc_args.push_all(~[~\"-ldl\", ~\"-llog\",  ~\"-lsupc++\",\n+        args.push_all(~[~\"-ldl\", ~\"-llog\",  ~\"-lsupc++\",\n                            ~\"-lgnustl_shared\"]);\n-        cc_args.push(~\"-lm\");\n+        args.push(~\"-lm\");\n     }\n \n     if sess.targ_cfg.os == session::os_freebsd {\n-        cc_args.push_all(~[~\"-pthread\", ~\"-lrt\",\n-                                ~\"-L/usr/local/lib\", ~\"-lexecinfo\",\n-                                ~\"-L/usr/local/lib/gcc46\",\n-                                ~\"-L/usr/local/lib/gcc44\", ~\"-lstdc++\",\n-                                ~\"-Wl,-z,origin\",\n-                                ~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n-                                ~\"-Wl,-rpath,/usr/local/lib/gcc44\"]);\n+        args.push_all(~[~\"-pthread\", ~\"-lrt\",\n+                        ~\"-L/usr/local/lib\", ~\"-lexecinfo\",\n+                        ~\"-L/usr/local/lib/gcc46\",\n+                        ~\"-L/usr/local/lib/gcc44\", ~\"-lstdc++\",\n+                        ~\"-Wl,-z,origin\",\n+                        ~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n+                        ~\"-Wl,-rpath,/usr/local/lib/gcc44\"]);\n     }\n \n     // OS X 10.6 introduced 'compact unwind info', which is produced by the\n     // linker from the dwarf unwind info. Unfortunately, it does not seem to\n     // understand how to unwind our __morestack frame, so we have to turn it\n     // off. This has impacted some other projects like GHC.\n     if sess.targ_cfg.os == session::os_macos {\n-        cc_args.push(~\"-Wl,-no_compact_unwind\");\n+        args.push(~\"-Wl,-no_compact_unwind\");\n     }\n \n     // Stack growth requires statically linking a __morestack function\n-    cc_args.push(~\"-lmorestack\");\n+    args.push(~\"-lmorestack\");\n \n     // Always want the runtime linked in\n-    cc_args.push(~\"-lrustrt\");\n+    args.push(~\"-lrustrt\");\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // extern libraries might live, based on the addl_lib_search_paths\n-    cc_args.push_all(rpath::get_rpath_flags(sess, &output));\n+    args.push_all(rpath::get_rpath_flags(sess, &output));\n \n     // Finally add all the linker arguments provided on the command line\n-    cc_args.push_all(sess.opts.linker_args);\n-\n-    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n-    // We run 'cc' here\n-    let prog = run::program_output(cc_prog, cc_args);\n-    if 0 != prog.status {\n-        sess.err(fmt!(\"linking with `%s` failed with code %d\",\n-                      cc_prog, prog.status));\n-        sess.note(fmt!(\"%s arguments: %s\",\n-                       cc_prog, str::connect(cc_args, ~\" \")));\n-        sess.note(prog.err + prog.out);\n-        sess.abort_if_errors();\n-    }\n+    args.push_all(sess.opts.linker_args);\n \n-    // Clean up on Darwin\n-    if sess.targ_cfg.os == session::os_macos {\n-        run::run_program(~\"dsymutil\", ~[output.to_str()]);\n-    }\n-\n-    // Remove the temporary object file if we aren't saving temps\n-    if !sess.opts.save_temps {\n-        if ! os::remove_file(obj_filename) {\n-            sess.warn(fmt!(\"failed to delete object file `%s`\",\n-                           obj_filename.to_str()));\n-        }\n-    }\n+    return args;\n }\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "102b663161096fa31bd76cb6ba2dee3738c8d413", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e75203ce82357f6d0f81d5644e77d3c2efe53fcb/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75203ce82357f6d0f81d5644e77d3c2efe53fcb/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=e75203ce82357f6d0f81d5644e77d3c2efe53fcb", "patch": "@@ -234,7 +234,6 @@ pub fn compile_rest(sess: Session,\n     let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n         middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n-\n     let outputs = outputs.get();\n \n     let (llmod, link_meta) = {\n@@ -309,6 +308,11 @@ pub fn compile_rest(sess: Session,\n \n     };\n \n+    if (sess.opts.output_info & session::out_link_args) > 0 {\n+        io::println(str::connect(link::link_args(sess,\n+            &outputs.obj_filename, &outputs.out_filename, link_meta), \" \"));\n+    }\n+\n     // NB: Android hack\n     if sess.targ_cfg.arch == abi::Arm &&\n             (sess.opts.output_type == link::output_type_object ||\n@@ -659,6 +663,12 @@ pub fn build_session_options(binary: @~str,\n     let test = opt_present(matches, ~\"test\");\n     let android_cross_path = getopts::opt_maybe_str(\n         matches, ~\"android-cross-path\");\n+\n+    let mut output_info = 0;\n+    if opt_present(matches, \"print-link-args\") {\n+        output_info |= session::out_link_args;\n+    }\n+\n     let sopts = @session::options {\n         crate_type: crate_type,\n         is_static: static,\n@@ -681,6 +691,7 @@ pub fn build_session_options(binary: @~str,\n         parse_only: parse_only,\n         no_trans: no_trans,\n         debugging_opts: debugging_opts,\n+        output_info: output_info,\n         android_cross_path: android_cross_path\n     };\n     return sopts;"}, {"sha": "19b99f46b5ed55094c5c2ea310c32618e85e8c57", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e75203ce82357f6d0f81d5644e77d3c2efe53fcb/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75203ce82357f6d0f81d5644e77d3c2efe53fcb/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=e75203ce82357f6d0f81d5644e77d3c2efe53fcb", "patch": "@@ -100,6 +100,9 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ]\n }\n \n+// Information output flags\n+pub static out_link_args : uint = 1 << 0;\n+\n #[deriving(Eq)]\n pub enum OptLevel {\n     No, // -O0\n@@ -136,6 +139,7 @@ pub struct options {\n     parse_only: bool,\n     no_trans: bool,\n     debugging_opts: uint,\n+    output_info: uint,\n     android_cross_path: Option<~str>\n }\n \n@@ -310,6 +314,7 @@ pub fn basic_options() -> @options {\n         parse_only: false,\n         no_trans: false,\n         debugging_opts: 0u,\n+        output_info: 0u,\n         android_cross_path: None\n     }\n }"}]}