{"sha": "9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZjI3YmY3ZGM1MGE4YjUxNDM1NTc5YjRmMmU4NmY3ZWUzZjdhOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-12T10:32:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-12T10:32:55Z"}, "message": "Auto merge of #88771 - jackh726:wf_tys_set, r=nikomatsakis\n\nUse FxHashSet instead of Vec for well formed tys\n\nTrying to recover perf from #88312\n\nr? `@ghost`", "tree": {"sha": "f8644fe71c3127b66b5a7b4f9495a946563e93f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8644fe71c3127b66b5a7b4f9495a946563e93f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "html_url": "https://github.com/rust-lang/rust/commit/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0212c70b1df2aa542aef48d5fcde0af3734970c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0212c70b1df2aa542aef48d5fcde0af3734970c6", "html_url": "https://github.com/rust-lang/rust/commit/0212c70b1df2aa542aef48d5fcde0af3734970c6"}, {"sha": "8e7613f9e0366a012cd6d4765b5a2d568d108029", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7613f9e0366a012cd6d4765b5a2d568d108029", "html_url": "https://github.com/rust-lang/rust/commit/8e7613f9e0366a012cd6d4765b5a2d568d108029"}], "stats": {"total": 77, "additions": 40, "deletions": 37}, "files": [{"sha": "70c74940d6235e117b8400a96d8d6eba851f643a", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "patch": "@@ -259,7 +259,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                 // We add implied bounds from both the unnormalized and normalized ty\n                 // See issue #87748\n                 let constraints_implied_1 = self.add_implied_bounds(ty);\n-                let TypeOpOutput { output: ty, constraints: constraints1, .. } = self\n+                let TypeOpOutput { output: norm_ty, constraints: constraints1, .. } = self\n                     .param_env\n                     .and(type_op::normalize::Normalize::new(ty))\n                     .fully_perform(self.infcx)\n@@ -286,8 +286,9 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                 // }\n                 // ```\n                 // Both &Self::Bar and &() are WF\n-                let constraints_implied_2 = self.add_implied_bounds(ty);\n-                normalized_inputs_and_output.push(ty);\n+                let constraints_implied_2 =\n+                    if ty != norm_ty { self.add_implied_bounds(norm_ty) } else { None };\n+                normalized_inputs_and_output.push(norm_ty);\n                 constraints1.into_iter().chain(constraints_implied_1).chain(constraints_implied_2)\n             })\n             .collect();"}, {"sha": "42cbed600d5bf92229ca6f6ff55002ded9d53d2c", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "patch": "@@ -2,6 +2,7 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::outlives_bounds::InferCtxtExt as _;\n use crate::traits::{self, TraitEngine, TraitEngineExt};\n \n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -184,7 +185,7 @@ pub trait OutlivesEnvironmentExt<'tcx> {\n     fn add_implied_bounds(\n         &mut self,\n         infcx: &InferCtxt<'a, 'tcx>,\n-        fn_sig_tys: &[Ty<'tcx>],\n+        fn_sig_tys: FxHashSet<Ty<'tcx>>,\n         body_id: hir::HirId,\n         span: Span,\n     );\n@@ -210,13 +211,13 @@ impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironment<'tcx> {\n     fn add_implied_bounds(\n         &mut self,\n         infcx: &InferCtxt<'a, 'tcx>,\n-        fn_sig_tys: &[Ty<'tcx>],\n+        fn_sig_tys: FxHashSet<Ty<'tcx>>,\n         body_id: hir::HirId,\n         span: Span,\n     ) {\n         debug!(\"add_implied_bounds()\");\n \n-        for &ty in fn_sig_tys {\n+        for ty in fn_sig_tys {\n             let ty = infcx.resolve_vars_if_possible(ty);\n             debug!(\"add_implied_bounds: ty = {}\", ty);\n             let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);"}, {"sha": "1fd1253e5277d88a11a57dcf08887d3be94df09c", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "patch": "@@ -688,7 +688,7 @@ fn check_opaque_meets_bounds<'tcx>(\n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n         let fcx = FnCtxt::new(&inh, param_env, hir_id);\n-        fcx.regionck_item(hir_id, span, &[]);\n+        fcx.regionck_item(hir_id, span, FxHashSet::default());\n     });\n }\n "}, {"sha": "d5b631df058aef9c12428677dbfa52f7aec344d3", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "patch": "@@ -1,4 +1,5 @@\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -250,7 +251,7 @@ fn compare_predicate_entailment<'tcx>(\n         // Compute placeholder form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n-        let mut wf_tys = vec![];\n+        let mut wf_tys = FxHashSet::default();\n \n         let (impl_sig, _) = infcx.replace_bound_vars_with_fresh_vars(\n             impl_m_span,\n@@ -398,7 +399,7 @@ fn compare_predicate_entailment<'tcx>(\n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n         let fcx = FnCtxt::new(&inh, param_env, impl_m_hir_id);\n-        fcx.regionck_item(impl_m_hir_id, impl_m_span, &wf_tys);\n+        fcx.regionck_item(impl_m_hir_id, impl_m_span, wf_tys);\n \n         Ok(())\n     })\n@@ -1098,7 +1099,7 @@ crate fn compare_const_impl<'tcx>(\n         }\n \n         let fcx = FnCtxt::new(&inh, param_env, impl_c_hir_id);\n-        fcx.regionck_item(impl_c_hir_id, impl_c_span, &[]);\n+        fcx.regionck_item(impl_c_hir_id, impl_c_span, FxHashSet::default());\n     });\n }\n \n@@ -1216,7 +1217,7 @@ fn compare_type_predicate_entailment<'tcx>(\n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n         let fcx = FnCtxt::new(&inh, param_env, impl_ty_hir_id);\n-        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, &[]);\n+        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, FxHashSet::default());\n \n         Ok(())\n     })\n@@ -1436,10 +1437,10 @@ pub fn check_type_bounds<'tcx>(\n         // lifetime parameters.\n         let fcx = FnCtxt::new(&inh, param_env, impl_ty_hir_id);\n         let implied_bounds = match impl_ty.container {\n-            ty::TraitContainer(_) => vec![],\n+            ty::TraitContainer(_) => FxHashSet::default(),\n             ty::ImplContainer(def_id) => fcx.impl_implied_bounds(def_id, impl_ty_span),\n         };\n-        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, &implied_bounds);\n+        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, implied_bounds);\n \n         Ok(())\n     })"}, {"sha": "a10490a9a15c7b75a4db20790d62c4bad5e0f394", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "patch": "@@ -388,7 +388,7 @@ fn typeck_with_fallback<'tcx>(\n             // from normalization. We could just discard these, but to align with\n             // compare_method and elsewhere, we just add implied bounds for\n             // these types.\n-            let mut wf_tys = vec![];\n+            let mut wf_tys = FxHashSet::default();\n             // Compute the fty from point of view of inside the fn.\n             let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n             wf_tys.extend(fn_sig.inputs_and_output.iter());\n@@ -451,7 +451,7 @@ fn typeck_with_fallback<'tcx>(\n \n             fcx.write_ty(id, expected_type);\n \n-            (fcx, vec![])\n+            (fcx, FxHashSet::default())\n         };\n \n         let fallback_has_occurred = fcx.type_inference_fallback();\n@@ -475,7 +475,7 @@ fn typeck_with_fallback<'tcx>(\n         fcx.select_all_obligations_or_error();\n \n         if fn_sig.is_some() {\n-            fcx.regionck_fn(id, body, span, &wf_tys);\n+            fcx.regionck_fn(id, body, span, wf_tys);\n         } else {\n             fcx.regionck_expr(body);\n         }"}, {"sha": "134604a0e32b41ffea5e291c32ac60097f9011da", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "patch": "@@ -76,6 +76,7 @@ use crate::check::dropck;\n use crate::check::FnCtxt;\n use crate::mem_categorization as mc;\n use crate::middle::region;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -126,7 +127,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n     /// types from which we should derive implied bounds, if any.\n-    pub fn regionck_item(&self, item_id: hir::HirId, span: Span, wf_tys: &[Ty<'tcx>]) {\n+    pub fn regionck_item(&self, item_id: hir::HirId, span: Span, wf_tys: FxHashSet<Ty<'tcx>>) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n         let subject = self.tcx.hir().local_def_id(item_id);\n         let mut rcx = RegionCtxt::new(self, item_id, Subject(subject), self.param_env);\n@@ -149,7 +150,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fn_id: hir::HirId,\n         body: &'tcx hir::Body<'tcx>,\n         span: Span,\n-        wf_tys: &[Ty<'tcx>],\n+        wf_tys: FxHashSet<Ty<'tcx>>,\n     ) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n@@ -286,15 +287,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         // because it will have no effect.\n         //\n         // FIXME(#27579) return types should not be implied bounds\n-        let fn_sig_tys: Vec<_> =\n+        let fn_sig_tys: FxHashSet<_> =\n             fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n \n-        self.outlives_environment.add_implied_bounds(\n-            self.fcx,\n-            &fn_sig_tys[..],\n-            body_id.hir_id,\n-            span,\n-        );\n+        self.outlives_environment.add_implied_bounds(self.fcx, fn_sig_tys, body_id.hir_id, span);\n         self.outlives_environment.save_implied_bounds(body_id.hir_id);\n         self.link_fn_params(&body.params);\n         self.visit_body(body);"}, {"sha": "cb07fcf5fef5813fba8341be925567b9d55df4cc", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "patch": "@@ -44,7 +44,7 @@ struct CheckWfFcxBuilder<'tcx> {\n impl<'tcx> CheckWfFcxBuilder<'tcx> {\n     fn with_fcx<F>(&mut self, f: F)\n     where\n-        F: for<'b> FnOnce(&FnCtxt<'b, 'tcx>) -> Vec<Ty<'tcx>>,\n+        F: for<'b> FnOnce(&FnCtxt<'b, 'tcx>) -> FxHashSet<Ty<'tcx>>,\n     {\n         let id = self.id;\n         let span = self.span;\n@@ -59,7 +59,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n             }\n             let wf_tys = f(&fcx);\n             fcx.select_all_obligations_or_error();\n-            fcx.regionck_item(id, span, &wf_tys);\n+            fcx.regionck_item(id, span, wf_tys);\n         });\n     }\n }\n@@ -394,7 +394,7 @@ fn check_associated_item(\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n-            ty::TraitContainer(_) => (vec![], fcx.tcx.types.self_param),\n+            ty::TraitContainer(_) => (FxHashSet::default(), fcx.tcx.types.self_param),\n             ty::ImplContainer(def_id) => {\n                 (fcx.impl_implied_bounds(def_id, span), fcx.tcx.type_of(def_id))\n             }\n@@ -553,7 +553,7 @@ fn check_type_defn<'tcx, F>(\n         check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n \n         // No implied bounds in a struct definition.\n-        vec![]\n+        FxHashSet::default()\n     });\n }\n \n@@ -579,7 +579,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     for_item(tcx, item).with_fcx(|fcx| {\n         check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n \n-        vec![]\n+        FxHashSet::default()\n     });\n }\n \n@@ -620,7 +620,7 @@ fn check_item_fn(\n     for_id(tcx, item_id, span).with_fcx(|fcx| {\n         let def_id = tcx.hir().local_def_id(item_id);\n         let sig = tcx.fn_sig(def_id);\n-        let mut implied_bounds = vec![];\n+        let mut implied_bounds = FxHashSet::default();\n         check_fn_or_method(fcx, ident.span, sig, decl, def_id.to_def_id(), &mut implied_bounds);\n         implied_bounds\n     })\n@@ -659,7 +659,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n         }\n \n         // No implied bounds in a const, etc.\n-        vec![]\n+        FxHashSet::default()\n     });\n }\n \n@@ -918,14 +918,14 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     sig: ty::PolyFnSig<'tcx>,\n     hir_decl: &hir::FnDecl<'_>,\n     def_id: DefId,\n-    implied_bounds: &mut Vec<Ty<'tcx>>,\n+    implied_bounds: &mut FxHashSet<Ty<'tcx>>,\n ) {\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, sig);\n \n     // Unnormalized types in signature are WF too\n     implied_bounds.extend(sig.inputs());\n     // FIXME(#27579) return types should not be implied bounds\n-    implied_bounds.push(sig.output());\n+    implied_bounds.insert(sig.output());\n \n     // Normalize the input and output types one at a time, using a different\n     // `WellFormedLoc` for each. We cannot call `normalize_associated_types`\n@@ -977,7 +977,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     );\n \n     // FIXME(#27579) return types should not be implied bounds\n-    implied_bounds.push(sig.output());\n+    implied_bounds.insert(sig.output());\n \n     debug!(?implied_bounds);\n \n@@ -1513,7 +1513,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    pub(super) fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n+    pub(super) fn impl_implied_bounds(\n+        &self,\n+        impl_def_id: DefId,\n+        span: Span,\n+    ) -> FxHashSet<Ty<'tcx>> {\n         match self.tcx.impl_trait_ref(impl_def_id) {\n             Some(trait_ref) => {\n                 // Trait impl: take implied bounds from all types that\n@@ -1526,7 +1530,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Inherent impl: take implied bounds from the `self` type.\n                 let self_ty = self.tcx.type_of(impl_def_id);\n                 let self_ty = self.normalize_associated_types_in(span, self_ty);\n-                vec![self_ty]\n+                std::array::IntoIter::new([self_ty]).collect()\n             }\n         }\n     }"}]}