{"sha": "bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjOTVjY2I1MzY5NGE4YWQ5OTJlYTViZjU4ZTQxYTIyYzRlN2I3ZDY=", "commit": {"author": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2011-12-20T10:17:13Z"}, "committer": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2011-12-20T13:06:04Z"}, "message": "Separate driver rustc and librustc\n\nrustc is now a minimal wrapper of librustc.", "tree": {"sha": "86938ca392d2694a972d9b4decbcdb7e5aef5875", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86938ca392d2694a972d9b4decbcdb7e5aef5875"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "html_url": "https://github.com/rust-lang/rust/commit/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/comments", "author": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28b825d8469c5b6f92f367cb4aae2ea2607bc886", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b825d8469c5b6f92f367cb4aae2ea2607bc886", "html_url": "https://github.com/rust-lang/rust/commit/28b825d8469c5b6f92f367cb4aae2ea2607bc886"}], "stats": {"total": 1245, "additions": 634, "deletions": 611}, "files": [{"sha": "48e26e804c761adb888ed8339cfbfd94efea1fc1", "filename": "Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "patch": "@@ -209,8 +209,11 @@ STDLIB_INPUTS := $(wildcard $(addprefix $(S)src/libstd/,          \\\n ######################################################################\n \n COMPILER_CRATE := $(S)src/comp/rustc.rc\n-COMPILER_INPUTS := $(wildcard $(addprefix $(S)src/comp/, \\\n-                                rustc.rc *.rs */*.rs */*/*.rs))\n+COMPILER_INPUTS := $(filter-out $(S)src/comp/driver/rustc.rs,         \\\n+\t\t\t\t$(wildcard $(addprefix $(S)src/comp/, \\\n+                                rustc.rc *.rs */*.rs */*/*.rs)))\n+\n+RUSTC_INPUTS := $(S)src/comp/driver/rustc.rs\n \n ######################################################################\n # LLVM macros"}, {"sha": "a67cf453e2acf7b5e692681ad03008bd82618af6", "filename": "mk/perf.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/mk%2Fperf.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/mk%2Fperf.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fperf.mk?ref=bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "patch": "@@ -2,8 +2,9 @@\n ifdef CFG_PERF_TOOL\n rustc-perf$(X): $(CFG_HOST_TRIPLE)/stage2/bin/rustc$(X)\n \t@$(call E, perf compile: $@)\n-\t$(PERF_STAGE2_T_$(CFG_HOST_TRIPLE)_H_$(CFG_HOST_TRIPLE)) -o $@ $(COMPILER_CRATE) >rustc-perf.err 2>&1\n-\t$(Q)rm -f $@\n+\t$(PERF_STAGE2_T_$(CFG_HOST_TRIPLE)_H_$(CFG_HOST_TRIPLE)) --lib \\\n+\t\t -o $@ $(COMPILER_CRATE) >rustc-perf.err 2>&1\n+\t$(Q)rm -f $(LIBRUSTC_GLOB)\n else\n rustc-perf$(X): $(CFG_HOST_TRIPLE)/stage2/bin/rustc$(X)\n \t$(Q)touch $@"}, {"sha": "2ac8fe73ad30cd3252d08f7429b2ad77d23735e9", "filename": "mk/target.mk", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "patch": "@@ -46,17 +46,14 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUSTLLVM): \\\n \t$$(Q)cp $$< $$@\n \n $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X):\t\t\t\t\\\n-\t\t$$(COMPILER_CRATE) $$(COMPILER_INPUTS)\t\t\\\n-\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUSTLLVM)\t\\\n-\t\t$$(TCORELIB_DEFAULT$(1)_T_$(2)_H_$(3))      \\\n-\t\t$$(TSTDLIB_DEFAULT$(1)_T_$(2)_H_$(3))\n+\t\t$$(RUSTC_INPUTS)                                \\\n+\t\t$$(TLIBRUSTC_DEFAULT$(1)_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3))  -o $$@ $$<\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC):\t\t\\\n \t\t$$(COMPILER_CRATE) $$(COMPILER_INPUTS)\t\t\\\n-\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\t\t\t\t\t\\\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\t\t\t\\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUSTLLVM)\t\\\n \t\t$$(TCORELIB_DEFAULT$(1)_T_$(2)_H_$(3))      \\\n \t\t$$(TSTDLIB_DEFAULT$(1)_T_$(2)_H_$(3))"}, {"sha": "1958025b6cb90deef3a1f6178086723b1fee834c", "filename": "src/comp/driver/driver.rs", "status": "added", "additions": 615, "deletions": 0, "changes": 615, "blob_url": "https://github.com/rust-lang/rust/blob/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "patch": "@@ -0,0 +1,615 @@\n+\n+\n+// -*- rust -*-\n+import metadata::{creader, cstore};\n+import syntax::parse::{parser};\n+import syntax::{ast, codemap};\n+import front::attr;\n+import middle::{trans, resolve, freevars, kind, ty, typeck, fn_usage,\n+                last_use};\n+import syntax::print::{pp, pprust};\n+import util::{ppaux, filesearch};\n+import back::link;\n+import core::{option, str, int, result};\n+import result::{ok, err};\n+import std::{fs, io, getopts};\n+import option::{some, none};\n+import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n+import back::{x86, x86_64};\n+\n+tag pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n+\n+fn default_configuration(sess: session::session, argv0: str, input: str) ->\n+   ast::crate_cfg {\n+    let libc =\n+        alt sess.get_targ_cfg().os {\n+          session::os_win32. { \"msvcrt.dll\" }\n+          session::os_macos. { \"libc.dylib\" }\n+          session::os_linux. { \"libc.so.6\" }\n+          _ { \"libc.so\" }\n+        };\n+\n+    let mk = attr::mk_name_value_item_str;\n+\n+    let arch = alt sess.get_targ_cfg().arch {\n+      session::arch_x86. { \"x86\" }\n+      session::arch_x86_64. { \"x86_64\" }\n+      session::arch_arm. { \"arm\" }\n+    };\n+\n+    ret [ // Target bindings.\n+         mk(\"target_os\", std::os::target_os()),\n+         mk(\"target_arch\", arch),\n+         mk(\"target_libc\", libc),\n+         // Build bindings.\n+         mk(\"build_compiler\", argv0),\n+         mk(\"build_input\", input)];\n+}\n+\n+fn build_configuration(sess: session::session, argv0: str, input: str) ->\n+   ast::crate_cfg {\n+    // Combine the configuration requested by the session (command line) with\n+    // some default and generated configuration items\n+    let default_cfg = default_configuration(sess, argv0, input);\n+    let user_cfg = sess.get_opts().cfg;\n+    // If the user wants a test runner, then add the test cfg\n+    let gen_cfg =\n+        {\n+            if sess.get_opts().test && !attr::contains_name(user_cfg, \"test\")\n+               {\n+                [attr::mk_word_item(\"test\")]\n+            } else { [] }\n+        };\n+    ret user_cfg + gen_cfg + default_cfg;\n+}\n+\n+// Convert strings provided as --cfg [cfgspec] into a crate_cfg\n+fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n+    // FIXME: It would be nice to use the parser to parse all varieties of\n+    // meta_item here. At the moment we just support the meta_word variant.\n+    let words = [];\n+    for s: str in cfgspecs { words += [attr::mk_word_item(s)]; }\n+    ret words;\n+}\n+\n+fn input_is_stdin(filename: str) -> bool { filename == \"-\" }\n+\n+fn parse_input(sess: session::session, cfg: ast::crate_cfg, input: str) ->\n+   @ast::crate {\n+    if !input_is_stdin(input) {\n+        parser::parse_crate_from_file(input, cfg, sess.get_parse_sess())\n+    } else { parse_input_src(sess, cfg, input).crate }\n+}\n+\n+fn parse_input_src(sess: session::session, cfg: ast::crate_cfg, infile: str)\n+   -> {crate: @ast::crate, src: str} {\n+    let srcbytes = if infile != \"-\" {\n+        alt io::file_reader(infile) {\n+          result::ok(reader) { reader }\n+          result::err(e) {\n+            sess.fatal(e)\n+          }\n+        }\n+    } else {\n+        io::stdin()\n+    }.read_whole_stream();\n+    let src = str::unsafe_from_bytes(srcbytes);\n+    let crate =\n+        parser::parse_crate_from_source_str(infile, src, cfg,\n+                                            sess.get_parse_sess());\n+    ret {crate: crate, src: src};\n+}\n+\n+fn time<T>(do_it: bool, what: str, thunk: fn@() -> T) -> T {\n+    if !do_it { ret thunk(); }\n+    let start = std::time::precise_time_s();\n+    let rv = thunk();\n+    let end = std::time::precise_time_s();\n+    log_err #fmt[\"time: %s took %s s\", what,\n+                 float::to_str(end - start, 3u)];\n+    ret rv;\n+}\n+\n+fn inject_libcore_reference(sess: session::session,\n+                            crate: @ast::crate) -> @ast::crate {\n+\n+    fn spanned<copy T>(x: T) -> @ast::spanned<T> {\n+        ret @{node: x,\n+              span: {lo: 0u, hi: 0u,\n+                     expanded_from: codemap::os_none}};\n+    }\n+\n+    let n1 = sess.next_node_id();\n+    let n2 = sess.next_node_id();\n+\n+    let vi1 = spanned(ast::view_item_use(\"core\", [], n1));\n+    let vi2 = spanned(ast::view_item_import_glob(@[\"core\"], n2));\n+\n+    let vis = [vi1, vi2] + crate.node.module.view_items;\n+\n+    ret @{node: {module: { view_items: vis with crate.node.module }\n+                 with crate.node} with *crate }\n+}\n+\n+\n+fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n+                 outdir: option::t<str>, output: option::t<str>) {\n+\n+    let time_passes = sess.get_opts().time_passes;\n+    let crate =\n+        time(time_passes, \"parsing\", bind parse_input(sess, cfg, input));\n+    if sess.get_opts().parse_only { ret; }\n+\n+    sess.set_building_library(crate);\n+\n+    crate =\n+        time(time_passes, \"configuration\",\n+             bind front::config::strip_unconfigured_items(crate));\n+    if sess.get_opts().test {\n+        crate =\n+            time(time_passes, \"building test harness\",\n+                 bind front::test::modify_for_testing(sess, crate));\n+    }\n+    crate =\n+        time(time_passes, \"expansion\",\n+             bind syntax::ext::expand::expand_crate(sess, crate));\n+\n+    if sess.get_opts().libcore {\n+        crate = inject_libcore_reference(sess, crate);\n+    }\n+\n+    let ast_map =\n+        time(time_passes, \"ast indexing\",\n+             bind middle::ast_map::map_crate(*crate));\n+    time(time_passes, \"external crate/lib resolution\",\n+         bind creader::read_crates(sess, *crate));\n+    let {def_map, exp_map, impl_map} =\n+        time(time_passes, \"resolution\",\n+             bind resolve::resolve_crate(sess, ast_map, crate));\n+    let freevars =\n+        time(time_passes, \"freevar finding\",\n+             bind freevars::annotate_freevars(def_map, crate));\n+    time(time_passes, \"const checking\",\n+         bind middle::check_const::check_crate(sess, crate));\n+    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars);\n+    let method_map = time(time_passes, \"typechecking\",\n+                          bind typeck::check_crate(ty_cx, impl_map, crate));\n+    time(time_passes, \"block-use checking\",\n+         bind middle::block_use::check_crate(ty_cx, crate));\n+    time(time_passes, \"function usage\",\n+         bind fn_usage::check_crate_fn_usage(ty_cx, crate));\n+    time(time_passes, \"alt checking\",\n+         bind middle::check_alt::check_crate(ty_cx, crate));\n+    time(time_passes, \"typestate checking\",\n+         bind middle::tstate::ck::check_crate(ty_cx, crate));\n+    let mut_map =\n+        time(time_passes, \"mutability checking\",\n+             bind middle::mut::check_crate(ty_cx, crate));\n+    let (copy_map, ref_map) =\n+        time(time_passes, \"alias checking\",\n+             bind middle::alias::check_crate(ty_cx, crate));\n+    let last_uses = time(time_passes, \"last use finding\",\n+        bind last_use::find_last_uses(crate, def_map, ref_map, ty_cx));\n+    time(time_passes, \"kind checking\",\n+         bind kind::check_crate(ty_cx, method_map, last_uses, crate));\n+    if sess.get_opts().no_trans { ret; }\n+\n+    let outputs = build_output_filenames(input, outdir, output, sess);\n+\n+    let (llmod, link_meta) =\n+        time(time_passes, \"translation\",\n+             bind trans::trans_crate(sess, crate, ty_cx,\n+                                     outputs.obj_filename, exp_map, ast_map,\n+                                     mut_map, copy_map, last_uses,\n+                                     method_map));\n+    time(time_passes, \"LLVM passes\",\n+         bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n+\n+    let stop_after_codegen =\n+        sess.get_opts().output_type != link::output_type_exe ||\n+            sess.get_opts().static && sess.building_library();\n+\n+    if stop_after_codegen { ret; }\n+\n+    time(time_passes, \"Linking\",\n+         bind link::link_binary(sess, outputs.obj_filename,\n+                                outputs.out_filename, link_meta));\n+}\n+\n+fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n+                      ppm: pp_mode) {\n+    fn ann_paren_for_expr(node: pprust::ann_node) {\n+        alt node { pprust::node_expr(s, expr) { pprust::popen(s); } _ { } }\n+    }\n+    fn ann_typed_post(tcx: ty::ctxt, node: pprust::ann_node) {\n+        alt node {\n+          pprust::node_expr(s, expr) {\n+            pp::space(s.s);\n+            pp::word(s.s, \"as\");\n+            pp::space(s.s);\n+            pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+            pprust::pclose(s);\n+          }\n+          _ { }\n+        }\n+    }\n+    fn ann_identified_post(node: pprust::ann_node) {\n+        alt node {\n+          pprust::node_item(s, item) {\n+            pp::space(s.s);\n+            pprust::synth_comment(s, int::to_str(item.id, 10u));\n+          }\n+          pprust::node_block(s, blk) {\n+            pp::space(s.s);\n+            pprust::synth_comment(s,\n+                                  \"block \" + int::to_str(blk.node.id, 10u));\n+          }\n+          pprust::node_expr(s, expr) {\n+            pp::space(s.s);\n+            pprust::synth_comment(s, int::to_str(expr.id, 10u));\n+            pprust::pclose(s);\n+          }\n+          _ { }\n+        }\n+    }\n+\n+    // Because the pretty printer needs to make a pass over the source\n+    // to collect comments and literals, and we need to support reading\n+    // from stdin, we're going to just suck the source into a string\n+    // so both the parser and pretty-printer can use it.\n+    let crate_src = parse_input_src(sess, cfg, input);\n+    let crate = crate_src.crate;\n+    let src = crate_src.src;\n+\n+    let ann;\n+    alt ppm {\n+      ppm_expanded. {\n+        crate = syntax::ext::expand::expand_crate(sess, crate);\n+        ann = pprust::no_ann();\n+      }\n+      ppm_typed. {\n+        crate = syntax::ext::expand::expand_crate(sess, crate);\n+        let amap = middle::ast_map::map_crate(*crate);\n+        let {def_map, impl_map, _} =\n+            resolve::resolve_crate(sess, amap, crate);\n+        let freevars = freevars::annotate_freevars(def_map, crate);\n+        let ty_cx = ty::mk_ctxt(sess, def_map, amap, freevars);\n+        typeck::check_crate(ty_cx, impl_map, crate);\n+        ann = {pre: ann_paren_for_expr, post: bind ann_typed_post(ty_cx, _)};\n+      }\n+      ppm_identified. {\n+        ann = {pre: ann_paren_for_expr, post: ann_identified_post};\n+      }\n+      ppm_normal. { ann = pprust::no_ann(); }\n+    }\n+    pprust::print_crate(sess.get_codemap(), crate, input,\n+                        io::string_reader(src), io::stdout(), ann);\n+}\n+\n+fn get_os(triple: str) -> session::os {\n+    ret if str::find(triple, \"win32\") >= 0 ||\n+               str::find(triple, \"mingw32\") >= 0 {\n+            session::os_win32\n+        } else if str::find(triple, \"darwin\") >= 0 {\n+            session::os_macos\n+        } else if str::find(triple, \"linux\") >= 0 {\n+            session::os_linux\n+        } else { early_error(\"Unknown operating system!\") };\n+}\n+\n+fn get_arch(triple: str) -> session::arch {\n+    ret if str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0 ||\n+               str::find(triple, \"i586\") >= 0 ||\n+               str::find(triple, \"i686\") >= 0 ||\n+               str::find(triple, \"i786\") >= 0 {\n+            session::arch_x86\n+        } else if str::find(triple, \"x86_64\") >= 0 {\n+            session::arch_x86_64\n+        } else if str::find(triple, \"arm\") >= 0 ||\n+                      str::find(triple, \"xscale\") >= 0 {\n+            session::arch_arm\n+        } else { early_error(\"Unknown architecture! \" + triple) };\n+}\n+\n+fn build_target_config(sopts: @session::options) -> @session::config {\n+    let os = get_os(sopts.target_triple);\n+    let arch = get_arch(sopts.target_triple);\n+    let (int_type, uint_type, float_type) = alt arch {\n+      session::arch_x86. {(ast::ty_i32, ast::ty_u32, ast::ty_f64)}\n+      session::arch_x86_64. {(ast::ty_i64, ast::ty_u64, ast::ty_f64)}\n+      session::arch_arm. {(ast::ty_i32, ast::ty_u32, ast::ty_f64)}\n+    };\n+    let target_strs = alt arch {\n+      session::arch_x86. {x86::get_target_strs(os)}\n+      session::arch_x86_64. {x86_64::get_target_strs(os)}\n+      session::arch_arm. {x86::get_target_strs(os)}\n+    };\n+    let target_cfg: @session::config =\n+        @{os: os, arch: arch, target_strs: target_strs, int_type: int_type,\n+          uint_type: uint_type, float_type: float_type};\n+    ret target_cfg;\n+}\n+\n+fn host_triple() -> str {\n+    // Get the host triple out of the build environment. This ensures that our\n+    // idea of the host triple is the same as for the set of libraries we've\n+    // actually built.  We can't just take LLVM's host triple because they\n+    // normalize all ix86 architectures to i386.\n+    // FIXME: Instead of grabbing the host triple we really should be\n+    // grabbing (at compile time) the target triple that this rustc is\n+    // built with and calling that (at runtime) the host triple.\n+    let ht = #env(\"CFG_HOST_TRIPLE\");\n+    ret ht != \"\" ? ht : fail \"rustc built without CFG_HOST_TRIPLE\";\n+}\n+\n+fn build_session_options(match: getopts::match)\n+   -> @session::options {\n+    let crate_type = if opt_present(match, \"lib\") {\n+        session::lib_crate\n+    } else if opt_present(match, \"bin\") {\n+        session::bin_crate\n+    } else {\n+        session::unknown_crate\n+    };\n+    let static = opt_present(match, \"static\");\n+\n+    let parse_only = opt_present(match, \"parse-only\");\n+    let no_trans = opt_present(match, \"no-trans\");\n+\n+    let output_type =\n+        if parse_only || no_trans {\n+            link::output_type_none\n+        } else if opt_present(match, \"S\") && opt_present(match, \"emit-llvm\") {\n+            link::output_type_llvm_assembly\n+        } else if opt_present(match, \"S\") {\n+            link::output_type_assembly\n+        } else if opt_present(match, \"c\") {\n+            link::output_type_object\n+        } else if opt_present(match, \"emit-llvm\") {\n+            link::output_type_bitcode\n+        } else { link::output_type_exe };\n+    let libcore = !opt_present(match, \"no-core\");\n+    let verify = !opt_present(match, \"no-verify\");\n+    let save_temps = opt_present(match, \"save-temps\");\n+    let extra_debuginfo = opt_present(match, \"xg\");\n+    let debuginfo = opt_present(match, \"g\") || extra_debuginfo;\n+    let stats = opt_present(match, \"stats\");\n+    let time_passes = opt_present(match, \"time-passes\");\n+    let time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n+    let sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n+    let target_opt = getopts::opt_maybe_str(match, \"target\");\n+    let no_asm_comments = getopts::opt_present(match, \"no-asm-comments\");\n+    alt output_type {\n+      // unless we're emitting huamn-readable assembly, omit comments.\n+      link::output_type_llvm_assembly. | link::output_type_assembly. {}\n+      _ { no_asm_comments = true; }\n+    }\n+    let opt_level: uint =\n+        if opt_present(match, \"O\") {\n+            if opt_present(match, \"opt-level\") {\n+                early_error(\"-O and --opt-level both provided\");\n+            }\n+            2u\n+        } else if opt_present(match, \"opt-level\") {\n+            alt getopts::opt_str(match, \"opt-level\") {\n+              \"0\" { 0u }\n+              \"1\" { 1u }\n+              \"2\" { 2u }\n+              \"3\" { 3u }\n+              _ {\n+                early_error(\"optimization level needs \" +\n+                            \"to be between 0-3\")\n+              }\n+            }\n+        } else { 0u };\n+    let target =\n+        alt target_opt {\n+            none. { host_triple() }\n+            some(s) { s }\n+        };\n+\n+    let addl_lib_search_paths = getopts::opt_strs(match, \"L\");\n+    let cfg = parse_cfgspecs(getopts::opt_strs(match, \"cfg\"));\n+    let test = opt_present(match, \"test\");\n+    let do_gc = opt_present(match, \"gc\");\n+    let warn_unused_imports = opt_present(match, \"warn-unused-imports\");\n+    let sopts: @session::options =\n+        @{crate_type: crate_type,\n+          static: static,\n+          libcore: libcore,\n+          optimize: opt_level,\n+          debuginfo: debuginfo,\n+          extra_debuginfo: extra_debuginfo,\n+          verify: verify,\n+          save_temps: save_temps,\n+          stats: stats,\n+          time_passes: time_passes,\n+          time_llvm_passes: time_llvm_passes,\n+          output_type: output_type,\n+          addl_lib_search_paths: addl_lib_search_paths,\n+          maybe_sysroot: sysroot_opt,\n+          target_triple: target,\n+          cfg: cfg,\n+          test: test,\n+          parse_only: parse_only,\n+          no_trans: no_trans,\n+          do_gc: do_gc,\n+          no_asm_comments: no_asm_comments,\n+          warn_unused_imports: warn_unused_imports};\n+    ret sopts;\n+}\n+\n+fn build_session(sopts: @session::options, input: str) -> session::session {\n+    let target_cfg = build_target_config(sopts);\n+    let cstore = cstore::mk_cstore();\n+    let filesearch = filesearch::mk_filesearch(\n+        sopts.maybe_sysroot,\n+        sopts.target_triple,\n+        sopts.addl_lib_search_paths);\n+    ret session::session(target_cfg, sopts, cstore,\n+                         @{cm: codemap::new_codemap(), mutable next_id: 1},\n+                         none, 0u, filesearch, false, fs::dirname(input));\n+}\n+\n+fn parse_pretty(sess: session::session, &&name: str) -> pp_mode {\n+    if str::eq(name, \"normal\") {\n+        ret ppm_normal;\n+    } else if str::eq(name, \"expanded\") {\n+        ret ppm_expanded;\n+    } else if str::eq(name, \"typed\") {\n+        ret ppm_typed;\n+    } else if str::eq(name, \"identified\") { ret ppm_identified; }\n+    sess.fatal(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n+                   \"`identified`\");\n+}\n+\n+fn opts() -> [getopts::opt] {\n+    ret [optflag(\"h\"), optflag(\"help\"), optflag(\"v\"), optflag(\"version\"),\n+         optflag(\"emit-llvm\"), optflagopt(\"pretty\"),\n+         optflag(\"ls\"), optflag(\"parse-only\"), optflag(\"no-trans\"),\n+         optflag(\"O\"), optopt(\"opt-level\"), optmulti(\"L\"), optflag(\"S\"),\n+         optopt(\"o\"), optopt(\"out-dir\"), optflag(\"xg\"),\n+         optflag(\"c\"), optflag(\"g\"), optflag(\"save-temps\"),\n+         optopt(\"sysroot\"), optopt(\"target\"), optflag(\"stats\"),\n+         optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n+         optflag(\"no-verify\"),\n+         optmulti(\"cfg\"), optflag(\"test\"),\n+         optflag(\"no-core\"),\n+         optflag(\"lib\"), optflag(\"bin\"), optflag(\"static\"), optflag(\"gc\"),\n+         optflag(\"no-asm-comments\"),\n+         optflag(\"warn-unused-imports\")];\n+}\n+\n+fn build_output_filenames(ifile: str,\n+                          odir: option::t<str>,\n+                          ofile: option::t<str>,\n+                          sess: session::session)\n+        -> @{out_filename: str, obj_filename:str} {\n+    let obj_path = \"\";\n+    let out_path: str = \"\";\n+    let sopts = sess.get_opts();\n+    let stop_after_codegen =\n+        sopts.output_type != link::output_type_exe ||\n+            sopts.static && sess.building_library();\n+\n+\n+    let obj_suffix =\n+        alt sopts.output_type {\n+          link::output_type_none. { \"none\" }\n+          link::output_type_bitcode. { \"bc\" }\n+          link::output_type_assembly. { \"s\" }\n+          link::output_type_llvm_assembly. { \"ll\" }\n+          // Object and exe output both use the '.o' extension here\n+          link::output_type_object. | link::output_type_exe. {\n+            \"o\"\n+          }\n+        };\n+\n+    alt ofile {\n+      none. {\n+        // \"-\" as input file will cause the parser to read from stdin so we\n+        // have to make up a name\n+        // We want to toss everything after the final '.'\n+        let dirname = alt odir {\n+          some(d) { d }\n+          none. {\n+            if input_is_stdin(ifile) {\n+                std::os::getcwd()\n+            } else {\n+                fs::dirname(ifile)\n+            }\n+          }\n+        };\n+\n+        let (base_path, _) = if !input_is_stdin(ifile) {\n+            fs::splitext(ifile)\n+        } else {\n+            (fs::connect(dirname, \"rust_out\"), \"\")\n+        };\n+\n+\n+        if sess.building_library() {\n+            let basename = fs::basename(base_path);\n+            let dylibname = std::os::dylib_filename(basename);\n+            out_path = fs::connect(dirname, dylibname);\n+            obj_path = fs::connect(dirname, basename + \".\" + obj_path);\n+        } else {\n+            out_path = base_path;\n+            obj_path = base_path + \".\" + obj_suffix;\n+        }\n+      }\n+\n+      some(out_file) {\n+        out_path = out_file;\n+        obj_path = if stop_after_codegen {\n+            out_file\n+        } else {\n+            let (base, _) = fs::splitext(out_file);\n+            let modified = base + \".\" + obj_suffix;\n+            modified\n+        };\n+\n+        if sess.building_library() {\n+            // FIXME: We might want to warn here; we're actually not going to\n+            // respect the user's choice of library name when it comes time to\n+            // link, we'll be linking to lib<basename>-<hash>-<version>.so no\n+            // matter what.\n+        }\n+\n+        if odir != none {\n+            sess.warn(\"Ignoring --out-dir flag due to -o flag.\");\n+        }\n+      }\n+    }\n+    ret @{out_filename: out_path,\n+          obj_filename: obj_path};\n+}\n+\n+fn early_error(msg: str) -> ! {\n+    codemap::print_diagnostic(\"\", codemap::error, msg);\n+    fail;\n+}\n+\n+fn list_metadata(sess: session::session, path: str, out: io::writer) {\n+    metadata::creader::list_file_metadata(sess, path, out);\n+}\n+\n+#[cfg(test)]\n+mod test {\n+\n+    // When the user supplies --test we should implicitly supply --cfg test\n+    #[test]\n+    fn test_switch_implies_cfg_test() {\n+        let match =\n+            alt getopts::getopts([\"--test\"], opts()) {\n+              ok(m) { m }\n+            };\n+        let sessopts = build_session_options(match);\n+        let sess = build_session(sessopts, \"\");\n+        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n+        assert (attr::contains_name(cfg, \"test\"));\n+    }\n+\n+    // When the user supplies --test and --cfg test, don't implicitly add\n+    // another --cfg test\n+    #[test]\n+    fn test_switch_implies_cfg_test_unless_cfg_test() {\n+        let match =\n+            alt getopts::getopts([\"--test\", \"--cfg=test\"], opts()) {\n+              ok(m) { m }\n+            };\n+        let sessopts = build_session_options(match);\n+        let sess = build_session(sessopts, \"\");\n+        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n+        let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n+        assert (vec::len(test_items) == 1u);\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "aad129b6ac86a55690dc02b7b53e26b5558afab9", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 7, "deletions": 600, "changes": 607, "blob_url": "https://github.com/rust-lang/rust/blob/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "patch": "@@ -1,290 +1,13 @@\n-\n+use std;\n+use rustc;\n \n // -*- rust -*-\n-import metadata::{creader, cstore};\n-import syntax::parse::{parser};\n-import syntax::{ast, codemap};\n-import front::attr;\n-import middle::{trans, resolve, freevars, kind, ty, typeck, fn_usage,\n-                last_use};\n-import syntax::print::{pp, pprust};\n-import util::{ppaux, filesearch};\n-import back::link;\n-import core::{option, str, vec, int, result};\n+import core::{option, str, vec, result};\n import result::{ok, err};\n-import std::{fs, io, getopts};\n+import std::{io, getopts};\n import option::{some, none};\n-import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n-import back::{x86, x86_64};\n-\n-tag pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n-\n-fn default_configuration(sess: session::session, argv0: str, input: str) ->\n-   ast::crate_cfg {\n-    let libc =\n-        alt sess.get_targ_cfg().os {\n-          session::os_win32. { \"msvcrt.dll\" }\n-          session::os_macos. { \"libc.dylib\" }\n-          session::os_linux. { \"libc.so.6\" }\n-          _ { \"libc.so\" }\n-        };\n-\n-    let mk = attr::mk_name_value_item_str;\n-\n-    let arch = alt sess.get_targ_cfg().arch {\n-      session::arch_x86. { \"x86\" }\n-      session::arch_x86_64. { \"x86_64\" }\n-      session::arch_arm. { \"arm\" }\n-    };\n-\n-    ret [ // Target bindings.\n-         mk(\"target_os\", std::os::target_os()),\n-         mk(\"target_arch\", arch),\n-         mk(\"target_libc\", libc),\n-         // Build bindings.\n-         mk(\"build_compiler\", argv0),\n-         mk(\"build_input\", input)];\n-}\n-\n-fn build_configuration(sess: session::session, argv0: str, input: str) ->\n-   ast::crate_cfg {\n-    // Combine the configuration requested by the session (command line) with\n-    // some default and generated configuration items\n-    let default_cfg = default_configuration(sess, argv0, input);\n-    let user_cfg = sess.get_opts().cfg;\n-    // If the user wants a test runner, then add the test cfg\n-    let gen_cfg =\n-        {\n-            if sess.get_opts().test && !attr::contains_name(user_cfg, \"test\")\n-               {\n-                [attr::mk_word_item(\"test\")]\n-            } else { [] }\n-        };\n-    ret user_cfg + gen_cfg + default_cfg;\n-}\n-\n-// Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n-    // FIXME: It would be nice to use the parser to parse all varieties of\n-    // meta_item here. At the moment we just support the meta_word variant.\n-    let words = [];\n-    for s: str in cfgspecs { words += [attr::mk_word_item(s)]; }\n-    ret words;\n-}\n-\n-fn input_is_stdin(filename: str) -> bool { filename == \"-\" }\n-\n-fn parse_input(sess: session::session, cfg: ast::crate_cfg, input: str) ->\n-   @ast::crate {\n-    if !input_is_stdin(input) {\n-        parser::parse_crate_from_file(input, cfg, sess.get_parse_sess())\n-    } else { parse_input_src(sess, cfg, input).crate }\n-}\n-\n-fn parse_input_src(sess: session::session, cfg: ast::crate_cfg, infile: str)\n-   -> {crate: @ast::crate, src: str} {\n-    let srcbytes = if infile != \"-\" {\n-        alt io::file_reader(infile) {\n-          result::ok(reader) { reader }\n-          result::err(e) {\n-            sess.fatal(e)\n-          }\n-        }\n-    } else {\n-        io::stdin()\n-    }.read_whole_stream();\n-    let src = str::unsafe_from_bytes(srcbytes);\n-    let crate =\n-        parser::parse_crate_from_source_str(infile, src, cfg,\n-                                            sess.get_parse_sess());\n-    ret {crate: crate, src: src};\n-}\n-\n-fn time<T>(do_it: bool, what: str, thunk: fn@() -> T) -> T {\n-    if !do_it { ret thunk(); }\n-    let start = std::time::precise_time_s();\n-    let rv = thunk();\n-    let end = std::time::precise_time_s();\n-    log_err #fmt[\"time: %s took %s s\", what,\n-                 float::to_str(end - start, 3u)];\n-    ret rv;\n-}\n-\n-fn inject_libcore_reference(sess: session::session,\n-                            crate: @ast::crate) -> @ast::crate {\n-\n-    fn spanned<copy T>(x: T) -> @ast::spanned<T> {\n-        ret @{node: x,\n-              span: {lo: 0u, hi: 0u,\n-                     expanded_from: codemap::os_none}};\n-    }\n-\n-    let n1 = sess.next_node_id();\n-    let n2 = sess.next_node_id();\n-\n-    let vi1 = spanned(ast::view_item_use(\"core\", [], n1));\n-    let vi2 = spanned(ast::view_item_import_glob(@[\"core\"], n2));\n-\n-    let vis = [vi1, vi2] + crate.node.module.view_items;\n-\n-    ret @{node: {module: { view_items: vis with crate.node.module }\n-                 with crate.node} with *crate }\n-}\n-\n-\n-fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n-                 outdir: option::t<str>, output: option::t<str>) {\n-\n-    let time_passes = sess.get_opts().time_passes;\n-    let crate =\n-        time(time_passes, \"parsing\", bind parse_input(sess, cfg, input));\n-    if sess.get_opts().parse_only { ret; }\n-\n-    sess.set_building_library(crate);\n-\n-    crate =\n-        time(time_passes, \"configuration\",\n-             bind front::config::strip_unconfigured_items(crate));\n-    if sess.get_opts().test {\n-        crate =\n-            time(time_passes, \"building test harness\",\n-                 bind front::test::modify_for_testing(sess, crate));\n-    }\n-    crate =\n-        time(time_passes, \"expansion\",\n-             bind syntax::ext::expand::expand_crate(sess, crate));\n-\n-    if sess.get_opts().libcore {\n-        crate = inject_libcore_reference(sess, crate);\n-    }\n-\n-    let ast_map =\n-        time(time_passes, \"ast indexing\",\n-             bind middle::ast_map::map_crate(*crate));\n-    time(time_passes, \"external crate/lib resolution\",\n-         bind creader::read_crates(sess, *crate));\n-    let {def_map, exp_map, impl_map} =\n-        time(time_passes, \"resolution\",\n-             bind resolve::resolve_crate(sess, ast_map, crate));\n-    let freevars =\n-        time(time_passes, \"freevar finding\",\n-             bind freevars::annotate_freevars(def_map, crate));\n-    time(time_passes, \"const checking\",\n-         bind middle::check_const::check_crate(sess, crate));\n-    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars);\n-    let method_map = time(time_passes, \"typechecking\",\n-                          bind typeck::check_crate(ty_cx, impl_map, crate));\n-    time(time_passes, \"block-use checking\",\n-         bind middle::block_use::check_crate(ty_cx, crate));\n-    time(time_passes, \"function usage\",\n-         bind fn_usage::check_crate_fn_usage(ty_cx, crate));\n-    time(time_passes, \"alt checking\",\n-         bind middle::check_alt::check_crate(ty_cx, crate));\n-    time(time_passes, \"typestate checking\",\n-         bind middle::tstate::ck::check_crate(ty_cx, crate));\n-    let mut_map =\n-        time(time_passes, \"mutability checking\",\n-             bind middle::mut::check_crate(ty_cx, crate));\n-    let (copy_map, ref_map) =\n-        time(time_passes, \"alias checking\",\n-             bind middle::alias::check_crate(ty_cx, crate));\n-    let last_uses = time(time_passes, \"last use finding\",\n-        bind last_use::find_last_uses(crate, def_map, ref_map, ty_cx));\n-    time(time_passes, \"kind checking\",\n-         bind kind::check_crate(ty_cx, method_map, last_uses, crate));\n-    if sess.get_opts().no_trans { ret; }\n-\n-    let outputs = build_output_filenames(input, outdir, output, sess);\n-\n-    let (llmod, link_meta) =\n-        time(time_passes, \"translation\",\n-             bind trans::trans_crate(sess, crate, ty_cx,\n-                                     outputs.obj_filename, exp_map, ast_map,\n-                                     mut_map, copy_map, last_uses,\n-                                     method_map));\n-    time(time_passes, \"LLVM passes\",\n-         bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n-\n-    let stop_after_codegen =\n-        sess.get_opts().output_type != link::output_type_exe ||\n-            sess.get_opts().static && sess.building_library();\n-\n-    if stop_after_codegen { ret; }\n-\n-    time(time_passes, \"Linking\",\n-         bind link::link_binary(sess, outputs.obj_filename,\n-                                outputs.out_filename, link_meta));\n-}\n-\n-fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n-                      ppm: pp_mode) {\n-    fn ann_paren_for_expr(node: pprust::ann_node) {\n-        alt node { pprust::node_expr(s, expr) { pprust::popen(s); } _ { } }\n-    }\n-    fn ann_typed_post(tcx: ty::ctxt, node: pprust::ann_node) {\n-        alt node {\n-          pprust::node_expr(s, expr) {\n-            pp::space(s.s);\n-            pp::word(s.s, \"as\");\n-            pp::space(s.s);\n-            pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n-            pprust::pclose(s);\n-          }\n-          _ { }\n-        }\n-    }\n-    fn ann_identified_post(node: pprust::ann_node) {\n-        alt node {\n-          pprust::node_item(s, item) {\n-            pp::space(s.s);\n-            pprust::synth_comment(s, int::to_str(item.id, 10u));\n-          }\n-          pprust::node_block(s, blk) {\n-            pp::space(s.s);\n-            pprust::synth_comment(s,\n-                                  \"block \" + int::to_str(blk.node.id, 10u));\n-          }\n-          pprust::node_expr(s, expr) {\n-            pp::space(s.s);\n-            pprust::synth_comment(s, int::to_str(expr.id, 10u));\n-            pprust::pclose(s);\n-          }\n-          _ { }\n-        }\n-    }\n-\n-    // Because the pretty printer needs to make a pass over the source\n-    // to collect comments and literals, and we need to support reading\n-    // from stdin, we're going to just suck the source into a string\n-    // so both the parser and pretty-printer can use it.\n-    let crate_src = parse_input_src(sess, cfg, input);\n-    let crate = crate_src.crate;\n-    let src = crate_src.src;\n-\n-    let ann;\n-    alt ppm {\n-      ppm_expanded. {\n-        crate = syntax::ext::expand::expand_crate(sess, crate);\n-        ann = pprust::no_ann();\n-      }\n-      ppm_typed. {\n-        crate = syntax::ext::expand::expand_crate(sess, crate);\n-        let amap = middle::ast_map::map_crate(*crate);\n-        let {def_map, impl_map, _} =\n-            resolve::resolve_crate(sess, amap, crate);\n-        let freevars = freevars::annotate_freevars(def_map, crate);\n-        let ty_cx = ty::mk_ctxt(sess, def_map, amap, freevars);\n-        typeck::check_crate(ty_cx, impl_map, crate);\n-        ann = {pre: ann_paren_for_expr, post: bind ann_typed_post(ty_cx, _)};\n-      }\n-      ppm_identified. {\n-        ann = {pre: ann_paren_for_expr, post: ann_identified_post};\n-      }\n-      ppm_normal. { ann = pprust::no_ann(); }\n-    }\n-    pprust::print_crate(sess.get_codemap(), crate, input,\n-                        io::string_reader(src), io::stdout(), ann);\n-}\n+import getopts::{opt_present};\n+import rustc::driver::driver::*;\n \n fn version(argv0: str) {\n     let vers = \"unknown version\";\n@@ -336,290 +59,6 @@ options:\n \");\n }\n \n-fn get_os(triple: str) -> session::os {\n-    ret if str::find(triple, \"win32\") >= 0 ||\n-               str::find(triple, \"mingw32\") >= 0 {\n-            session::os_win32\n-        } else if str::find(triple, \"darwin\") >= 0 {\n-            session::os_macos\n-        } else if str::find(triple, \"linux\") >= 0 {\n-            session::os_linux\n-        } else { early_error(\"Unknown operating system!\") };\n-}\n-\n-fn get_arch(triple: str) -> session::arch {\n-    ret if str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0 ||\n-               str::find(triple, \"i586\") >= 0 ||\n-               str::find(triple, \"i686\") >= 0 ||\n-               str::find(triple, \"i786\") >= 0 {\n-            session::arch_x86\n-        } else if str::find(triple, \"x86_64\") >= 0 {\n-            session::arch_x86_64\n-        } else if str::find(triple, \"arm\") >= 0 ||\n-                      str::find(triple, \"xscale\") >= 0 {\n-            session::arch_arm\n-        } else { early_error(\"Unknown architecture! \" + triple) };\n-}\n-\n-fn build_target_config(sopts: @session::options) -> @session::config {\n-    let os = get_os(sopts.target_triple);\n-    let arch = get_arch(sopts.target_triple);\n-    let (int_type, uint_type, float_type) = alt arch {\n-      session::arch_x86. {(ast::ty_i32, ast::ty_u32, ast::ty_f64)}\n-      session::arch_x86_64. {(ast::ty_i64, ast::ty_u64, ast::ty_f64)}\n-      session::arch_arm. {(ast::ty_i32, ast::ty_u32, ast::ty_f64)}\n-    };\n-    let target_strs = alt arch {\n-      session::arch_x86. {x86::get_target_strs(os)}\n-      session::arch_x86_64. {x86_64::get_target_strs(os)}\n-      session::arch_arm. {x86::get_target_strs(os)}\n-    };\n-    let target_cfg: @session::config =\n-        @{os: os, arch: arch, target_strs: target_strs, int_type: int_type,\n-          uint_type: uint_type, float_type: float_type};\n-    ret target_cfg;\n-}\n-\n-fn host_triple() -> str {\n-    // Get the host triple out of the build environment. This ensures that our\n-    // idea of the host triple is the same as for the set of libraries we've\n-    // actually built.  We can't just take LLVM's host triple because they\n-    // normalize all ix86 architectures to i386.\n-    // FIXME: Instead of grabbing the host triple we really should be\n-    // grabbing (at compile time) the target triple that this rustc is\n-    // built with and calling that (at runtime) the host triple.\n-    let ht = #env(\"CFG_HOST_TRIPLE\");\n-    ret ht != \"\" ? ht : fail \"rustc built without CFG_HOST_TRIPLE\";\n-}\n-\n-fn build_session_options(match: getopts::match)\n-   -> @session::options {\n-    let crate_type = if opt_present(match, \"lib\") {\n-        session::lib_crate\n-    } else if opt_present(match, \"bin\") {\n-        session::bin_crate\n-    } else {\n-        session::unknown_crate\n-    };\n-    let static = opt_present(match, \"static\");\n-\n-    let parse_only = opt_present(match, \"parse-only\");\n-    let no_trans = opt_present(match, \"no-trans\");\n-\n-    let output_type =\n-        if parse_only || no_trans {\n-            link::output_type_none\n-        } else if opt_present(match, \"S\") && opt_present(match, \"emit-llvm\") {\n-            link::output_type_llvm_assembly\n-        } else if opt_present(match, \"S\") {\n-            link::output_type_assembly\n-        } else if opt_present(match, \"c\") {\n-            link::output_type_object\n-        } else if opt_present(match, \"emit-llvm\") {\n-            link::output_type_bitcode\n-        } else { link::output_type_exe };\n-    let libcore = !opt_present(match, \"no-core\");\n-    let verify = !opt_present(match, \"no-verify\");\n-    let save_temps = opt_present(match, \"save-temps\");\n-    let extra_debuginfo = opt_present(match, \"xg\");\n-    let debuginfo = opt_present(match, \"g\") || extra_debuginfo;\n-    let stats = opt_present(match, \"stats\");\n-    let time_passes = opt_present(match, \"time-passes\");\n-    let time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n-    let sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n-    let target_opt = getopts::opt_maybe_str(match, \"target\");\n-    let no_asm_comments = getopts::opt_present(match, \"no-asm-comments\");\n-    alt output_type {\n-      // unless we're emitting huamn-readable assembly, omit comments.\n-      link::output_type_llvm_assembly. | link::output_type_assembly. {}\n-      _ { no_asm_comments = true; }\n-    }\n-    let opt_level: uint =\n-        if opt_present(match, \"O\") {\n-            if opt_present(match, \"opt-level\") {\n-                early_error(\"-O and --opt-level both provided\");\n-            }\n-            2u\n-        } else if opt_present(match, \"opt-level\") {\n-            alt getopts::opt_str(match, \"opt-level\") {\n-              \"0\" { 0u }\n-              \"1\" { 1u }\n-              \"2\" { 2u }\n-              \"3\" { 3u }\n-              _ {\n-                early_error(\"optimization level needs \" +\n-                            \"to be between 0-3\")\n-              }\n-            }\n-        } else { 0u };\n-    let target =\n-        alt target_opt {\n-            none. { host_triple() }\n-            some(s) { s }\n-        };\n-\n-    let addl_lib_search_paths = getopts::opt_strs(match, \"L\");\n-    let cfg = parse_cfgspecs(getopts::opt_strs(match, \"cfg\"));\n-    let test = opt_present(match, \"test\");\n-    let do_gc = opt_present(match, \"gc\");\n-    let warn_unused_imports = opt_present(match, \"warn-unused-imports\");\n-    let sopts: @session::options =\n-        @{crate_type: crate_type,\n-          static: static,\n-          libcore: libcore,\n-          optimize: opt_level,\n-          debuginfo: debuginfo,\n-          extra_debuginfo: extra_debuginfo,\n-          verify: verify,\n-          save_temps: save_temps,\n-          stats: stats,\n-          time_passes: time_passes,\n-          time_llvm_passes: time_llvm_passes,\n-          output_type: output_type,\n-          addl_lib_search_paths: addl_lib_search_paths,\n-          maybe_sysroot: sysroot_opt,\n-          target_triple: target,\n-          cfg: cfg,\n-          test: test,\n-          parse_only: parse_only,\n-          no_trans: no_trans,\n-          do_gc: do_gc,\n-          no_asm_comments: no_asm_comments,\n-          warn_unused_imports: warn_unused_imports};\n-    ret sopts;\n-}\n-\n-fn build_session(sopts: @session::options, input: str) -> session::session {\n-    let target_cfg = build_target_config(sopts);\n-    let cstore = cstore::mk_cstore();\n-    let filesearch = filesearch::mk_filesearch(\n-        sopts.maybe_sysroot,\n-        sopts.target_triple,\n-        sopts.addl_lib_search_paths);\n-    ret session::session(target_cfg, sopts, cstore,\n-                         @{cm: codemap::new_codemap(), mutable next_id: 1},\n-                         none, 0u, filesearch, false, fs::dirname(input));\n-}\n-\n-fn parse_pretty(sess: session::session, &&name: str) -> pp_mode {\n-    if str::eq(name, \"normal\") {\n-        ret ppm_normal;\n-    } else if str::eq(name, \"expanded\") {\n-        ret ppm_expanded;\n-    } else if str::eq(name, \"typed\") {\n-        ret ppm_typed;\n-    } else if str::eq(name, \"identified\") { ret ppm_identified; }\n-    sess.fatal(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n-                   \"`identified`\");\n-}\n-\n-fn opts() -> [getopts::opt] {\n-    ret [optflag(\"h\"), optflag(\"help\"), optflag(\"v\"), optflag(\"version\"),\n-         optflag(\"emit-llvm\"), optflagopt(\"pretty\"),\n-         optflag(\"ls\"), optflag(\"parse-only\"), optflag(\"no-trans\"),\n-         optflag(\"O\"), optopt(\"opt-level\"), optmulti(\"L\"), optflag(\"S\"),\n-         optopt(\"o\"), optopt(\"out-dir\"), optflag(\"xg\"),\n-         optflag(\"c\"), optflag(\"g\"), optflag(\"save-temps\"),\n-         optopt(\"sysroot\"), optopt(\"target\"), optflag(\"stats\"),\n-         optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n-         optflag(\"no-verify\"),\n-         optmulti(\"cfg\"), optflag(\"test\"),\n-         optflag(\"no-core\"),\n-         optflag(\"lib\"), optflag(\"bin\"), optflag(\"static\"), optflag(\"gc\"),\n-         optflag(\"no-asm-comments\"),\n-         optflag(\"warn-unused-imports\")];\n-}\n-\n-fn build_output_filenames(ifile: str,\n-                          odir: option::t<str>,\n-                          ofile: option::t<str>,\n-                          sess: session::session)\n-        -> @{out_filename: str, obj_filename:str} {\n-    let obj_path = \"\";\n-    let out_path: str = \"\";\n-    let sopts = sess.get_opts();\n-    let stop_after_codegen =\n-        sopts.output_type != link::output_type_exe ||\n-            sopts.static && sess.building_library();\n-\n-\n-    let obj_suffix =\n-        alt sopts.output_type {\n-          link::output_type_none. { \"none\" }\n-          link::output_type_bitcode. { \"bc\" }\n-          link::output_type_assembly. { \"s\" }\n-          link::output_type_llvm_assembly. { \"ll\" }\n-          // Object and exe output both use the '.o' extension here\n-          link::output_type_object. | link::output_type_exe. {\n-            \"o\"\n-          }\n-        };\n-\n-    alt ofile {\n-      none. {\n-        // \"-\" as input file will cause the parser to read from stdin so we\n-        // have to make up a name\n-        // We want to toss everything after the final '.'\n-        let dirname = alt odir {\n-          some(d) { d }\n-          none. {\n-            if input_is_stdin(ifile) {\n-                std::os::getcwd()\n-            } else {\n-                fs::dirname(ifile)\n-            }\n-          }\n-        };\n-\n-        let (base_path, _) = if !input_is_stdin(ifile) {\n-            fs::splitext(ifile)\n-        } else {\n-            (fs::connect(dirname, \"rust_out\"), \"\")\n-        };\n-\n-\n-        if sess.building_library() {\n-            let basename = fs::basename(base_path);\n-            let dylibname = std::os::dylib_filename(basename);\n-            out_path = fs::connect(dirname, dylibname);\n-            obj_path = fs::connect(dirname, basename + \".\" + obj_path);\n-        } else {\n-            out_path = base_path;\n-            obj_path = base_path + \".\" + obj_suffix;\n-        }\n-      }\n-\n-      some(out_file) {\n-        out_path = out_file;\n-        obj_path = if stop_after_codegen {\n-            out_file\n-        } else {\n-            let (base, _) = fs::splitext(out_file);\n-            let modified = base + \".\" + obj_suffix;\n-            modified\n-        };\n-\n-        if sess.building_library() {\n-            // FIXME: We might want to warn here; we're actually not going to\n-            // respect the user's choice of library name when it comes time to\n-            // link, we'll be linking to lib<basename>-<hash>-<version>.so no\n-            // matter what.\n-        }\n-\n-        if odir != none {\n-            sess.warn(\"Ignoring --out-dir flag due to -o flag.\");\n-        }\n-      }\n-    }\n-    ret @{out_filename: out_path,\n-          obj_filename: obj_path};\n-}\n-\n-fn early_error(msg: str) -> ! {\n-    codemap::print_diagnostic(\"\", codemap::error, msg);\n-    fail;\n-}\n-\n fn main(args: [str]) {\n     let args = args, binary = vec::shift(args);\n     let match =\n@@ -658,45 +97,13 @@ fn main(args: [str]) {\n     }\n     let ls = opt_present(match, \"ls\");\n     if ls {\n-        metadata::creader::list_file_metadata(sess, ifile, io::stdout());\n+        list_metadata(sess, ifile, io::stdout());\n         ret;\n     }\n \n     compile_input(sess, cfg, ifile, odir, ofile);\n }\n \n-#[cfg(test)]\n-mod test {\n-\n-    // When the user supplies --test we should implicitly supply --cfg test\n-    #[test]\n-    fn test_switch_implies_cfg_test() {\n-        let match =\n-            alt getopts::getopts([\"--test\"], opts()) {\n-              ok(m) { m }\n-            };\n-        let sessopts = build_session_options(match);\n-        let sess = build_session(sessopts, \"\");\n-        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n-        assert (attr::contains_name(cfg, \"test\"));\n-    }\n-\n-    // When the user supplies --test and --cfg test, don't implicitly add\n-    // another --cfg test\n-    #[test]\n-    fn test_switch_implies_cfg_test_unless_cfg_test() {\n-        let match =\n-            alt getopts::getopts([\"--test\", \"--cfg=test\"], opts()) {\n-              ok(m) { m }\n-            };\n-        let sessopts = build_session_options(match);\n-        let sess = build_session(sessopts, \"\");\n-        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n-        let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n-        assert (vec::len(test_items) == 1u);\n-    }\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "883d8b6f046f29afcd0197df38ff999587c40e2a", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=bc95ccb53694a8ad992ea5bf58e41a22c4e7b7d6", "patch": "@@ -121,7 +121,7 @@ mod metadata {\n }\n \n mod driver {\n-    mod rustc;\n+    mod driver;\n     mod session;\n }\n "}]}