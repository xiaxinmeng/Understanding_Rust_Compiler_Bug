{"sha": "2efc90e7381721df57348b61518b15794b75d189", "node_id": "C_kwDOAAsO6NoAKDJlZmM5MGU3MzgxNzIxZGY1NzM0OGI2MTUxOGIxNTc5NGI3NWQxODk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-19T00:02:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-19T00:02:40Z"}, "message": "Auto merge of #102769 - nnethercote:rustdoc-startup, r=jyn514\n\nClean up rustdoc startup\n\nStartup is pretty hairy, in both rustdoc and rustc. The first commit here improves the rustdoc situation quite a bit. The remaining commits are smaller but also help.\n\nBest reviewed one commit at a time.\n\nr? `@jyn514`", "tree": {"sha": "87c8e48616e64f4fe1790b7178a5feddb9b101b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87c8e48616e64f4fe1790b7178a5feddb9b101b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2efc90e7381721df57348b61518b15794b75d189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2efc90e7381721df57348b61518b15794b75d189", "html_url": "https://github.com/rust-lang/rust/commit/2efc90e7381721df57348b61518b15794b75d189", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2efc90e7381721df57348b61518b15794b75d189/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a24a020e6d926dffe6b472fc647978f92269504e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a24a020e6d926dffe6b472fc647978f92269504e", "html_url": "https://github.com/rust-lang/rust/commit/a24a020e6d926dffe6b472fc647978f92269504e"}, {"sha": "ca2561a07b01841ceef6790d78e12aaa1d2e3aec", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2561a07b01841ceef6790d78e12aaa1d2e3aec", "html_url": "https://github.com/rust-lang/rust/commit/ca2561a07b01841ceef6790d78e12aaa1d2e3aec"}], "stats": {"total": 326, "additions": 161, "deletions": 165}, "files": [{"sha": "a3bf7cde9ff71d31193d83498c2fece1bf651992", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 47, "deletions": 53, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2efc90e7381721df57348b61518b15794b75d189/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2efc90e7381721df57348b61518b15794b75d189/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=2efc90e7381721df57348b61518b15794b75d189", "patch": "@@ -275,66 +275,60 @@ pub struct Config {\n     pub registry: Registry,\n }\n \n-pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R) -> R {\n-    crate::callbacks::setup_callbacks();\n-\n-    let registry = &config.registry;\n-    let (mut sess, codegen_backend) = util::create_session(\n-        config.opts,\n-        config.crate_cfg,\n-        config.crate_check_cfg,\n-        config.file_loader,\n-        config.input_path.clone(),\n-        config.lint_caps,\n-        config.make_codegen_backend,\n-        registry.clone(),\n-    );\n-\n-    if let Some(parse_sess_created) = config.parse_sess_created {\n-        parse_sess_created(\n-            &mut Lrc::get_mut(&mut sess)\n-                .expect(\"create_session() should never share the returned session\")\n-                .parse_sess,\n-        );\n-    }\n-\n-    let temps_dir = sess.opts.unstable_opts.temps_dir.as_ref().map(|o| PathBuf::from(&o));\n-\n-    let compiler = Compiler {\n-        sess,\n-        codegen_backend,\n-        input: config.input,\n-        input_path: config.input_path,\n-        output_dir: config.output_dir,\n-        output_file: config.output_file,\n-        temps_dir,\n-        register_lints: config.register_lints,\n-        override_queries: config.override_queries,\n-    };\n-\n-    rustc_span::with_source_map(compiler.sess.parse_sess.clone_source_map(), move || {\n-        let r = {\n-            let _sess_abort_error = OnDrop(|| {\n-                compiler.sess.finish_diagnostics(registry);\n-            });\n-\n-            f(&compiler)\n-        };\n-\n-        let prof = compiler.sess.prof.clone();\n-        prof.generic_activity(\"drop_compiler\").run(move || drop(compiler));\n-        r\n-    })\n-}\n-\n // JUSTIFICATION: before session exists, only config\n #[allow(rustc::bad_opt_access)]\n pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Send) -> R {\n     trace!(\"run_compiler\");\n     util::run_in_thread_pool_with_globals(\n         config.opts.edition,\n         config.opts.unstable_opts.threads,\n-        || create_compiler_and_run(config, f),\n+        || {\n+            crate::callbacks::setup_callbacks();\n+\n+            let registry = &config.registry;\n+            let (mut sess, codegen_backend) = util::create_session(\n+                config.opts,\n+                config.crate_cfg,\n+                config.crate_check_cfg,\n+                config.file_loader,\n+                config.input_path.clone(),\n+                config.lint_caps,\n+                config.make_codegen_backend,\n+                registry.clone(),\n+            );\n+\n+            if let Some(parse_sess_created) = config.parse_sess_created {\n+                parse_sess_created(&mut sess.parse_sess);\n+            }\n+\n+            let temps_dir = sess.opts.unstable_opts.temps_dir.as_ref().map(|o| PathBuf::from(&o));\n+\n+            let compiler = Compiler {\n+                sess: Lrc::new(sess),\n+                codegen_backend: Lrc::new(codegen_backend),\n+                input: config.input,\n+                input_path: config.input_path,\n+                output_dir: config.output_dir,\n+                output_file: config.output_file,\n+                temps_dir,\n+                register_lints: config.register_lints,\n+                override_queries: config.override_queries,\n+            };\n+\n+            rustc_span::with_source_map(compiler.sess.parse_sess.clone_source_map(), move || {\n+                let r = {\n+                    let _sess_abort_error = OnDrop(|| {\n+                        compiler.sess.finish_diagnostics(registry);\n+                    });\n+\n+                    f(&compiler)\n+                };\n+\n+                let prof = compiler.sess.prof.clone();\n+                prof.generic_activity(\"drop_compiler\").run(move || drop(compiler));\n+                r\n+            })\n+        },\n     )\n }\n "}, {"sha": "6d0fffc152c3c2fbe752034bc1d51cfa0e186399", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2efc90e7381721df57348b61518b15794b75d189/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2efc90e7381721df57348b61518b15794b75d189/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=2efc90e7381721df57348b61518b15794b75d189", "patch": "@@ -5,7 +5,6 @@ use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n #[cfg(parallel_compiler)]\n use rustc_data_structures::jobserver;\n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::registry::Registry;\n #[cfg(parallel_compiler)]\n use rustc_middle::ty::tls;\n@@ -72,7 +71,7 @@ pub fn create_session(\n         Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n     >,\n     descriptions: Registry,\n-) -> (Lrc<Session>, Lrc<Box<dyn CodegenBackend>>) {\n+) -> (Session, Box<dyn CodegenBackend>) {\n     let codegen_backend = if let Some(make_codegen_backend) = make_codegen_backend {\n         make_codegen_backend(&sopts)\n     } else {\n@@ -119,7 +118,7 @@ pub fn create_session(\n     sess.parse_sess.config = cfg;\n     sess.parse_sess.check_config = check_cfg;\n \n-    (Lrc::new(sess), Lrc::new(codegen_backend))\n+    (sess, codegen_backend)\n }\n \n const STACK_SIZE: usize = 8 * 1024 * 1024;\n@@ -130,33 +129,31 @@ fn get_stack_size() -> Option<usize> {\n     env::var_os(\"RUST_MIN_STACK\").is_none().then_some(STACK_SIZE)\n }\n \n-/// Like a `thread::Builder::spawn` followed by a `join()`, but avoids the need\n-/// for `'static` bounds.\n #[cfg(not(parallel_compiler))]\n-fn scoped_thread<F: FnOnce() -> R + Send, R: Send>(cfg: thread::Builder, f: F) -> R {\n-    // SAFETY: join() is called immediately, so any closure captures are still\n-    // alive.\n-    match unsafe { cfg.spawn_unchecked(f) }.unwrap().join() {\n-        Ok(v) => v,\n-        Err(e) => panic::resume_unwind(e),\n-    }\n-}\n-\n-#[cfg(not(parallel_compiler))]\n-pub fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n+pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     _threads: usize,\n     f: F,\n ) -> R {\n-    let mut cfg = thread::Builder::new().name(\"rustc\".to_string());\n-\n-    if let Some(size) = get_stack_size() {\n-        cfg = cfg.stack_size(size);\n-    }\n+    // The thread pool is a single thread in the non-parallel compiler.\n+    thread::scope(|s| {\n+        let mut builder = thread::Builder::new().name(\"rustc\".to_string());\n+        if let Some(size) = get_stack_size() {\n+            builder = builder.stack_size(size);\n+        }\n \n-    let main_handler = move || rustc_span::create_session_globals_then(edition, f);\n+        // `unwrap` is ok here because `spawn_scoped` only panics if the thread\n+        // name contains null bytes.\n+        let r = builder\n+            .spawn_scoped(s, move || rustc_span::create_session_globals_then(edition, f))\n+            .unwrap()\n+            .join();\n \n-    scoped_thread(cfg, main_handler)\n+        match r {\n+            Ok(v) => v,\n+            Err(e) => panic::resume_unwind(e),\n+        }\n+    })\n }\n \n /// Creates a new thread and forwards information in thread locals to it.\n@@ -175,7 +172,7 @@ unsafe fn handle_deadlock() {\n }\n \n #[cfg(parallel_compiler)]\n-pub fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n+pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     threads: usize,\n     f: F,"}, {"sha": "67ea39fb965798078c95b245c4e69d4255cc446b", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=2efc90e7381721df57348b61518b15794b75d189", "patch": "@@ -142,8 +142,6 @@ pub(crate) struct Options {\n     // Options that alter generated documentation pages\n     /// Crate version to note on the sidebar of generated docs.\n     pub(crate) crate_version: Option<String>,\n-    /// Collected options specific to outputting final pages.\n-    pub(crate) render_options: RenderOptions,\n     /// The format that we output when rendering.\n     ///\n     /// Currently used only for the `--show-coverage` option.\n@@ -159,6 +157,10 @@ pub(crate) struct Options {\n     /// Configuration for scraping examples from the current crate. If this option is Some(..) then\n     /// the compiler will scrape examples and not generate documentation.\n     pub(crate) scrape_examples_options: Option<ScrapeExamplesOptions>,\n+\n+    /// Note: this field is duplicated in `RenderOptions` because it's useful\n+    /// to have it in both places.\n+    pub(crate) unstable_features: rustc_feature::UnstableFeatures,\n }\n \n impl fmt::Debug for Options {\n@@ -194,14 +196,14 @@ impl fmt::Debug for Options {\n             .field(\"persist_doctests\", &self.persist_doctests)\n             .field(\"show_coverage\", &self.show_coverage)\n             .field(\"crate_version\", &self.crate_version)\n-            .field(\"render_options\", &self.render_options)\n             .field(\"runtool\", &self.runtool)\n             .field(\"runtool_args\", &self.runtool_args)\n             .field(\"enable-per-target-ignores\", &self.enable_per_target_ignores)\n             .field(\"run_check\", &self.run_check)\n             .field(\"no_run\", &self.no_run)\n             .field(\"nocapture\", &self.nocapture)\n             .field(\"scrape_examples_options\", &self.scrape_examples_options)\n+            .field(\"unstable_features\", &self.unstable_features)\n             .finish()\n     }\n }\n@@ -267,6 +269,8 @@ pub(crate) struct RenderOptions {\n     pub(crate) generate_redirect_map: bool,\n     /// Show the memory layout of types in the docs.\n     pub(crate) show_type_layout: bool,\n+    /// Note: this field is duplicated in `Options` because it's useful to have\n+    /// it in both places.\n     pub(crate) unstable_features: rustc_feature::UnstableFeatures,\n     pub(crate) emit: Vec<EmitType>,\n     /// If `true`, HTML source pages will generate links for items to their definition.\n@@ -316,7 +320,7 @@ impl Options {\n     pub(crate) fn from_matches(\n         matches: &getopts::Matches,\n         args: Vec<String>,\n-    ) -> Result<Options, i32> {\n+    ) -> Result<(Options, RenderOptions), i32> {\n         let args = &args[1..];\n         // Check for unstable options.\n         nightly_options::check_nightly_options(matches, &opts());\n@@ -710,7 +714,9 @@ impl Options {\n         let with_examples = matches.opt_strs(\"with-examples\");\n         let call_locations = crate::scrape_examples::load_call_locations(with_examples, &diag)?;\n \n-        Ok(Options {\n+        let unstable_features =\n+            rustc_feature::UnstableFeatures::from_environment(crate_name.as_deref());\n+        let options = Options {\n             input,\n             proc_macro_crate,\n             error_format,\n@@ -744,42 +750,42 @@ impl Options {\n             run_check,\n             no_run,\n             nocapture,\n-            render_options: RenderOptions {\n-                output,\n-                external_html,\n-                id_map,\n-                playground_url,\n-                module_sorting,\n-                themes,\n-                extension_css,\n-                extern_html_root_urls,\n-                extern_html_root_takes_precedence,\n-                default_settings,\n-                resource_suffix,\n-                enable_minification,\n-                enable_index_page,\n-                index_page,\n-                static_root_path,\n-                markdown_no_toc,\n-                markdown_css,\n-                markdown_playground_url,\n-                document_private,\n-                document_hidden,\n-                generate_redirect_map,\n-                show_type_layout,\n-                unstable_features: rustc_feature::UnstableFeatures::from_environment(\n-                    crate_name.as_deref(),\n-                ),\n-                emit,\n-                generate_link_to_definition,\n-                call_locations,\n-                no_emit_shared: false,\n-            },\n             crate_name,\n             output_format,\n             json_unused_externs,\n             scrape_examples_options,\n-        })\n+            unstable_features,\n+        };\n+        let render_options = RenderOptions {\n+            output,\n+            external_html,\n+            id_map,\n+            playground_url,\n+            module_sorting,\n+            themes,\n+            extension_css,\n+            extern_html_root_urls,\n+            extern_html_root_takes_precedence,\n+            default_settings,\n+            resource_suffix,\n+            enable_minification,\n+            enable_index_page,\n+            index_page,\n+            static_root_path,\n+            markdown_no_toc,\n+            markdown_css,\n+            markdown_playground_url,\n+            document_private,\n+            document_hidden,\n+            generate_redirect_map,\n+            show_type_layout,\n+            unstable_features,\n+            emit,\n+            generate_link_to_definition,\n+            call_locations,\n+            no_emit_shared: false,\n+        };\n+        Ok((options, render_options))\n     }\n \n     /// Returns `true` if the file given as `self.input` is a Markdown file."}, {"sha": "cb216970c7c354f2d61c40a54b2b5407b842d1f4", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=2efc90e7381721df57348b61518b15794b75d189", "patch": "@@ -18,7 +18,6 @@ use rustc_session::{lint, Session};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::sym;\n-use rustc_span::Symbol;\n use rustc_span::{BytePos, FileName, Pos, Span, DUMMY_SP};\n use rustc_target::spec::TargetTriple;\n use tempfile::Builder as TempFileBuilder;\n@@ -80,7 +79,7 @@ pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n         lint_cap: Some(options.lint_cap.unwrap_or(lint::Forbid)),\n         cg: options.codegen_options.clone(),\n         externs: options.externs.clone(),\n-        unstable_features: options.render_options.unstable_features,\n+        unstable_features: options.unstable_features,\n         actually_rustdoc: true,\n         edition: options.edition,\n         target_triple: options.target.clone(),\n@@ -124,7 +123,7 @@ pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n                     let opts = scrape_test_config(crate_attrs);\n                     let enable_per_target_ignores = options.enable_per_target_ignores;\n                     let mut collector = Collector::new(\n-                        tcx.crate_name(LOCAL_CRATE),\n+                        tcx.crate_name(LOCAL_CRATE).to_string(),\n                         options,\n                         false,\n                         opts,\n@@ -908,7 +907,7 @@ pub(crate) struct Collector {\n     rustdoc_options: RustdocOptions,\n     use_headers: bool,\n     enable_per_target_ignores: bool,\n-    crate_name: Symbol,\n+    crate_name: String,\n     opts: GlobalTestOptions,\n     position: Span,\n     source_map: Option<Lrc<SourceMap>>,\n@@ -920,7 +919,7 @@ pub(crate) struct Collector {\n \n impl Collector {\n     pub(crate) fn new(\n-        crate_name: Symbol,\n+        crate_name: String,\n         rustdoc_options: RustdocOptions,\n         use_headers: bool,\n         opts: GlobalTestOptions,\n@@ -983,7 +982,7 @@ impl Tester for Collector {\n     fn add_test(&mut self, test: String, config: LangString, line: usize) {\n         let filename = self.get_filename();\n         let name = self.generate_name(line, &filename);\n-        let crate_name = self.crate_name.to_string();\n+        let crate_name = self.crate_name.clone();\n         let opts = self.opts.clone();\n         let edition = config.edition.unwrap_or(self.rustdoc_options.edition);\n         let rustdoc_options = self.rustdoc_options.clone();"}, {"sha": "5733d1f9c79d662aa3417d5f1dc0a1185b6d29b1", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=2efc90e7381721df57348b61518b15794b75d189", "patch": "@@ -430,7 +430,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             extension_css,\n             resource_suffix,\n             static_root_path,\n-            unstable_features,\n             generate_redirect_map,\n             show_type_layout,\n             generate_link_to_definition,\n@@ -511,7 +510,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             resource_suffix,\n             static_root_path,\n             fs: DocFS::new(sender),\n-            codes: ErrorCodes::from(unstable_features.is_nightly_build()),\n+            codes: ErrorCodes::from(options.unstable_features.is_nightly_build()),\n             playground,\n             all: RefCell::new(AllTypes::new()),\n             errors: receiver,"}, {"sha": "793061a9f7a06160595511cf9a94f59e776ff801", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=2efc90e7381721df57348b61518b15794b75d189", "patch": "@@ -674,39 +674,6 @@ fn usage(argv0: &str) {\n /// A result type used by several functions under `main()`.\n type MainResult = Result<(), ErrorGuaranteed>;\n \n-fn main_args(at_args: &[String]) -> MainResult {\n-    let args = rustc_driver::args::arg_expand_all(at_args);\n-\n-    let mut options = getopts::Options::new();\n-    for option in opts() {\n-        (option.apply)(&mut options);\n-    }\n-    let matches = match options.parse(&args[1..]) {\n-        Ok(m) => m,\n-        Err(err) => {\n-            early_error(ErrorOutputType::default(), &err.to_string());\n-        }\n-    };\n-\n-    // Note that we discard any distinction between different non-zero exit\n-    // codes from `from_matches` here.\n-    let options = match config::Options::from_matches(&matches, args) {\n-        Ok(opts) => opts,\n-        Err(code) => {\n-            return if code == 0 {\n-                Ok(())\n-            } else {\n-                Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n-            };\n-        }\n-    };\n-    rustc_interface::util::run_in_thread_pool_with_globals(\n-        options.edition,\n-        1, // this runs single-threaded, even in a parallel compiler\n-        move || main_options(options),\n-    )\n-}\n-\n fn wrap_return(diag: &rustc_errors::Handler, res: Result<(), String>) -> MainResult {\n     match res {\n         Ok(()) => Ok(()),\n@@ -737,7 +704,33 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n     }\n }\n \n-fn main_options(options: config::Options) -> MainResult {\n+fn main_args(at_args: &[String]) -> MainResult {\n+    let args = rustc_driver::args::arg_expand_all(at_args);\n+\n+    let mut options = getopts::Options::new();\n+    for option in opts() {\n+        (option.apply)(&mut options);\n+    }\n+    let matches = match options.parse(&args[1..]) {\n+        Ok(m) => m,\n+        Err(err) => {\n+            early_error(ErrorOutputType::default(), &err.to_string());\n+        }\n+    };\n+\n+    // Note that we discard any distinction between different non-zero exit\n+    // codes from `from_matches` here.\n+    let (options, render_options) = match config::Options::from_matches(&matches, args) {\n+        Ok(opts) => opts,\n+        Err(code) => {\n+            return if code == 0 {\n+                Ok(())\n+            } else {\n+                Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+            };\n+        }\n+    };\n+\n     let diag = core::new_handler(\n         options.error_format,\n         None,\n@@ -749,9 +742,18 @@ fn main_options(options: config::Options) -> MainResult {\n         (true, true) => return wrap_return(&diag, markdown::test(options)),\n         (true, false) => return doctest::run(options),\n         (false, true) => {\n+            let input = options.input.clone();\n+            let edition = options.edition;\n+            let config = core::create_config(options);\n+\n+            // `markdown::render` can invoke `doctest::make_test`, which\n+            // requires session globals and a thread pool, so we use\n+            // `run_compiler`.\n             return wrap_return(\n                 &diag,\n-                markdown::render(&options.input, options.render_options, options.edition),\n+                interface::run_compiler(config, |_compiler| {\n+                    markdown::render(&input, render_options, edition)\n+                }),\n             );\n         }\n         (false, false) => {}\n@@ -772,14 +774,12 @@ fn main_options(options: config::Options) -> MainResult {\n     let crate_version = options.crate_version.clone();\n \n     let output_format = options.output_format;\n-    // FIXME: fix this clone (especially render_options)\n     let externs = options.externs.clone();\n-    let render_options = options.render_options.clone();\n     let scrape_examples_options = options.scrape_examples_options.clone();\n-    let document_private = options.render_options.document_private;\n+\n     let config = core::create_config(options);\n \n-    interface::create_compiler_and_run(config, |compiler| {\n+    interface::run_compiler(config, |compiler| {\n         let sess = compiler.session();\n \n         if sess.opts.describe_lints {\n@@ -811,7 +811,7 @@ fn main_options(options: config::Options) -> MainResult {\n                         sess,\n                         krate,\n                         externs,\n-                        document_private,\n+                        render_options.document_private,\n                     )\n                 });\n                 (resolver.clone(), resolver_caches)"}, {"sha": "044e051440c52bb9117416d75ca0a3fa52885b86", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2efc90e7381721df57348b61518b15794b75d189/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=2efc90e7381721df57348b61518b15794b75d189", "patch": "@@ -5,7 +5,6 @@ use std::path::Path;\n \n use rustc_span::edition::Edition;\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_span::Symbol;\n \n use crate::config::{Options, RenderOptions};\n use crate::doctest::{Collector, GlobalTestOptions};\n@@ -36,6 +35,8 @@ fn extract_leading_metadata(s: &str) -> (Vec<&str>, &str) {\n \n /// Render `input` (e.g., \"foo.md\") into an HTML file in `output`\n /// (e.g., output = \"bar\" => \"bar/foo.html\").\n+///\n+/// Requires session globals to be available, for symbol interning.\n pub(crate) fn render<P: AsRef<Path>>(\n     input: P,\n     options: RenderOptions,\n@@ -133,7 +134,7 @@ pub(crate) fn test(options: Options) -> Result<(), String> {\n     let mut opts = GlobalTestOptions::default();\n     opts.no_crate_inject = true;\n     let mut collector = Collector::new(\n-        Symbol::intern(&options.input.display().to_string()),\n+        options.input.display().to_string(),\n         options.clone(),\n         true,\n         opts,\n@@ -142,7 +143,7 @@ pub(crate) fn test(options: Options) -> Result<(), String> {\n         options.enable_per_target_ignores,\n     );\n     collector.set_position(DUMMY_SP);\n-    let codes = ErrorCodes::from(options.render_options.unstable_features.is_nightly_build());\n+    let codes = ErrorCodes::from(options.unstable_features.is_nightly_build());\n \n     find_testable_code(&input_str, &mut collector, codes, options.enable_per_target_ignores, None);\n "}]}