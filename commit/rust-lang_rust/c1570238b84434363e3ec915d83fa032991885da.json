{"sha": "c1570238b84434363e3ec915d83fa032991885da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNTcwMjM4Yjg0NDM0MzYzZTNlYzkxNWQ4M2ZhMDMyOTkxODg1ZGE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-17T13:50:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-17T17:13:42Z"}, "message": "rustc_metadata: Move `CrateMetadata` into `decoder.rs`\n\nIt allows to make most of its fields private", "tree": {"sha": "75eab0a1681364fbc41a37f87ca0eeb40fe6f0e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75eab0a1681364fbc41a37f87ca0eeb40fe6f0e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1570238b84434363e3ec915d83fa032991885da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1570238b84434363e3ec915d83fa032991885da", "html_url": "https://github.com/rust-lang/rust/commit/c1570238b84434363e3ec915d83fa032991885da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1570238b84434363e3ec915d83fa032991885da/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41ee980f9f4f313359e1e8e6b4a3a16f0b493ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/41ee980f9f4f313359e1e8e6b4a3a16f0b493ef2", "html_url": "https://github.com/rust-lang/rust/commit/41ee980f9f4f313359e1e8e6b4a3a16f0b493ef2"}], "stats": {"total": 277, "additions": 135, "deletions": 142}, "files": [{"sha": "0511d83e33d99466e79c7d9f379dfdca5a573d4f", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=c1570238b84434363e3ec915d83fa032991885da", "patch": "@@ -1,8 +1,8 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::cstore::{self, CStore};\n+use crate::cstore::CStore;\n use crate::locator::{CrateLocator, CratePaths};\n-use crate::rmeta::{CrateRoot, CrateDep, MetadataBlob};\n+use crate::rmeta::{CrateMetadata, CrateNumMap, CrateRoot, CrateDep, MetadataBlob};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n@@ -46,9 +46,9 @@ pub struct CrateLoader<'a> {\n \n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n-    cstore.iter_crate_data(|_, data| {\n+    cstore.iter_crate_data(|cnum, data| {\n         info!(\"  name: {}\", data.root.name);\n-        info!(\"  cnum: {}\", data.cnum);\n+        info!(\"  cnum: {}\", cnum);\n         info!(\"  hash: {}\", data.root.hash);\n         info!(\"  reqd: {:?}\", *data.dep_kind.lock());\n         let CrateSource { dylib, rlib, rmeta } = data.source.clone();\n@@ -224,7 +224,7 @@ impl<'a> CrateLoader<'a> {\n             self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span)\n         });\n \n-        self.cstore.set_crate_data(cnum, cstore::CrateMetadata::new(\n+        self.cstore.set_crate_data(cnum, CrateMetadata::new(\n             self.sess,\n             metadata,\n             crate_root,\n@@ -439,10 +439,10 @@ impl<'a> CrateLoader<'a> {\n                           krate: CrateNum,\n                           span: Span,\n                           dep_kind: DepKind)\n-                          -> cstore::CrateNumMap {\n+                          -> CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         if crate_root.proc_macro_data.is_some() {\n-            return cstore::CrateNumMap::new();\n+            return CrateNumMap::new();\n         }\n \n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n@@ -792,7 +792,7 @@ impl<'a> CrateLoader<'a> {\n     fn inject_dependency_if(&self,\n                             krate: CrateNum,\n                             what: &str,\n-                            needs_dep: &dyn Fn(&cstore::CrateMetadata) -> bool) {\n+                            needs_dep: &dyn Fn(&CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n         // those errors may indicate a circular dependency which could cause\n         // this to stack overflow."}, {"sha": "48cf0b982f2902192775ab755f8aff95d852c59c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 121, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=c1570238b84434363e3ec915d83fa032991885da", "patch": "@@ -1,92 +1,18 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use crate::rmeta::{CrateRoot, ImportedSourceFile, Lazy, MetadataBlob};\n-use rustc::dep_graph::DepNodeIndex;\n-use rustc::hir::def_id::{CrateNum, DefIndex};\n-use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate};\n-use rustc::mir::interpret::AllocDecodingState;\n-use rustc::session::Session;\n+use crate::rmeta::CrateMetadata;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n-use rustc::util::common::record_time;\n-use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::sync::{Lrc, Lock, Once, AtomicCell};\n-use rustc_data_structures::svh::Svh;\n+use rustc::hir::def_id::CrateNum;\n use syntax::ast;\n use syntax::edition::Edition;\n-use syntax_expand::base::SyntaxExtension;\n use syntax::expand::allocator::AllocatorKind;\n-use proc_macro::bridge::client::ProcMacro;\n+use syntax_expand::base::SyntaxExtension;\n \n pub use crate::rmeta::{provide, provide_extern};\n \n-// A map from external crate numbers (as decoded from some crate file) to\n-// local crate numbers (as generated during this session). Each external\n-// crate may refer to types in other external crates, and each has their\n-// own crate numbers.\n-crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n-\n-crate struct CrateMetadata {\n-    /// The primary crate data - binary metadata blob.\n-    crate blob: MetadataBlob,\n-\n-    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n-\n-    /// Properties of the whole crate.\n-    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    /// lifetime is only used behind `Lazy`, and therefore acts like an\n-    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n-    /// is being used to decode those values.\n-    crate root: CrateRoot<'static>,\n-    /// For each definition in this crate, we encode a key. When the\n-    /// crate is loaded, we read all the keys and put them in this\n-    /// hashmap, which gives the reverse mapping. This allows us to\n-    /// quickly retrace a `DefPath`, which is needed for incremental\n-    /// compilation support.\n-    crate def_path_table: DefPathTable,\n-    /// Trait impl data.\n-    /// FIXME: Used only from queries and can use query cache,\n-    /// so pre-decoding can probably be avoided.\n-    crate trait_impls: FxHashMap<(u32, DefIndex), Lazy<[DefIndex]>>,\n-    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n-    crate raw_proc_macros: Option<&'static [ProcMacro]>,\n-    /// Source maps for code from the crate.\n-    crate source_map_import_info: Once<Vec<ImportedSourceFile>>,\n-    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n-    crate alloc_decoding_state: AllocDecodingState,\n-    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n-    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n-    /// Do not access the value directly, as it might not have been initialized yet.\n-    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n-    crate dep_node_index: AtomicCell<DepNodeIndex>,\n-\n-    // --- Other significant crate properties ---\n-\n-    /// ID of this crate, from the current compilation session's point of view.\n-    crate cnum: CrateNum,\n-    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n-    /// IDs as they are seen from the current compilation session.\n-    crate cnum_map: CrateNumMap,\n-    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n-    crate dependencies: Lock<Vec<CrateNum>>,\n-    /// How to link (or not link) this crate to the currently compiled crate.\n-    crate dep_kind: Lock<DepKind>,\n-    /// Filesystem location of this crate.\n-    crate source: CrateSource,\n-    /// Whether or not this crate should be consider a private dependency\n-    /// for purposes of the 'exported_private_dependencies' lint\n-    crate private_dep: bool,\n-    /// The hash for the host proc macro. Used to support `-Z dual-proc-macro`.\n-    crate host_hash: Option<Svh>,\n-\n-    // --- Data used only for improving diagnostics ---\n-\n-    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n-    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n-    crate extern_crate: Lock<Option<ExternCrate>>,\n-}\n-\n #[derive(Clone)]\n pub struct CStore {\n     metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n@@ -99,48 +25,6 @@ pub enum LoadedMacro {\n     ProcMacro(SyntaxExtension),\n }\n \n-impl CrateMetadata {\n-    crate fn new(\n-        sess: &Session,\n-        blob: MetadataBlob,\n-        root: CrateRoot<'static>,\n-        raw_proc_macros: Option<&'static [ProcMacro]>,\n-        cnum: CrateNum,\n-        cnum_map: CrateNumMap,\n-        dep_kind: DepKind,\n-        source: CrateSource,\n-        private_dep: bool,\n-        host_hash: Option<Svh>,\n-    ) -> CrateMetadata {\n-        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n-            root.def_path_table.decode((&blob, sess))\n-        });\n-        let trait_impls = root.impls.decode((&blob, sess))\n-            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls)).collect();\n-        let alloc_decoding_state =\n-            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n-        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n-        CrateMetadata {\n-            blob,\n-            root,\n-            def_path_table,\n-            trait_impls,\n-            raw_proc_macros,\n-            source_map_import_info: Once::new(),\n-            alloc_decoding_state,\n-            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-            cnum,\n-            cnum_map,\n-            dependencies,\n-            dep_kind: Lock::new(dep_kind),\n-            source,\n-            private_dep,\n-            host_hash,\n-            extern_crate: Lock::new(None),\n-        }\n-    }\n-}\n-\n impl Default for CStore {\n     fn default() -> Self {\n         CStore {"}, {"sha": "30b60b6ed67333f18fda2cb1a8ebca5e49247f8d", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 115, "deletions": 6, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=c1570238b84434363e3ec915d83fa032991885da", "patch": "@@ -1,27 +1,30 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::CrateMetadata;\n use crate::rmeta::*;\n use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Lock, Once, AtomicCell};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir;\n+use rustc::middle::cstore::{CrateSource, ExternCrate};\n use rustc::middle::cstore::{LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc::dep_graph::{DepNodeIndex, DepKind};\n+use rustc_data_structures::svh::Svh;\n+use rustc::dep_graph::{self, DepNodeIndex};\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n-use rustc::mir::interpret::AllocDecodingSession;\n+use rustc::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n use rustc::mir::{Body, Promoted};\n+use rustc::util::common::record_time;\n use rustc::util::captures::Captures;\n \n use std::io;\n@@ -46,9 +49,75 @@ mod cstore_impl;\n \n crate struct MetadataBlob(MetadataRef);\n \n+// A map from external crate numbers (as decoded from some crate file) to\n+// local crate numbers (as generated during this session). Each external\n+// crate may refer to types in other external crates, and each has their\n+// own crate numbers.\n+crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n+\n+crate struct CrateMetadata {\n+    /// The primary crate data - binary metadata blob.\n+    blob: MetadataBlob,\n+\n+    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n+\n+    /// Properties of the whole crate.\n+    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n+    /// lifetime is only used behind `Lazy`, and therefore acts like an\n+    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    /// is being used to decode those values.\n+    crate root: CrateRoot<'static>,\n+    /// For each definition in this crate, we encode a key. When the\n+    /// crate is loaded, we read all the keys and put them in this\n+    /// hashmap, which gives the reverse mapping. This allows us to\n+    /// quickly retrace a `DefPath`, which is needed for incremental\n+    /// compilation support.\n+    def_path_table: DefPathTable,\n+    /// Trait impl data.\n+    /// FIXME: Used only from queries and can use query cache,\n+    /// so pre-decoding can probably be avoided.\n+    trait_impls: FxHashMap<(u32, DefIndex), Lazy<[DefIndex]>>,\n+    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n+    raw_proc_macros: Option<&'static [ProcMacro]>,\n+    /// Source maps for code from the crate.\n+    source_map_import_info: Once<Vec<ImportedSourceFile>>,\n+    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n+    alloc_decoding_state: AllocDecodingState,\n+    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n+    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n+    /// Do not access the value directly, as it might not have been initialized yet.\n+    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n+    dep_node_index: AtomicCell<DepNodeIndex>,\n+\n+    // --- Other significant crate properties ---\n+\n+    /// ID of this crate, from the current compilation session's point of view.\n+    cnum: CrateNum,\n+    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n+    /// IDs as they are seen from the current compilation session.\n+    cnum_map: CrateNumMap,\n+    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n+    crate dependencies: Lock<Vec<CrateNum>>,\n+    /// How to link (or not link) this crate to the currently compiled crate.\n+    crate dep_kind: Lock<DepKind>,\n+    /// Filesystem location of this crate.\n+    crate source: CrateSource,\n+    /// Whether or not this crate should be consider a private dependency\n+    /// for purposes of the 'exported_private_dependencies' lint\n+    private_dep: bool,\n+    /// The hash for the host proc macro. Used to support `-Z dual-proc-macro`.\n+    host_hash: Option<Svh>,\n+\n+    // --- Data used only for improving diagnostics ---\n+\n+    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n+    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n+    crate extern_crate: Lock<Option<ExternCrate>>,\n+}\n+\n /// Holds information about a syntax_pos::SourceFile imported from another crate.\n /// See `imported_source_files()` for more information.\n-crate struct ImportedSourceFile {\n+struct ImportedSourceFile {\n     /// This SourceFile's byte-offset within the source_map of its original crate\n     original_start_pos: syntax_pos::BytePos,\n     /// The end of this SourceFile within the source_map of its original crate\n@@ -485,6 +554,46 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n+    crate fn new(\n+        sess: &Session,\n+        blob: MetadataBlob,\n+        root: CrateRoot<'static>,\n+        raw_proc_macros: Option<&'static [ProcMacro]>,\n+        cnum: CrateNum,\n+        cnum_map: CrateNumMap,\n+        dep_kind: DepKind,\n+        source: CrateSource,\n+        private_dep: bool,\n+        host_hash: Option<Svh>,\n+    ) -> CrateMetadata {\n+        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n+            root.def_path_table.decode((&blob, sess))\n+        });\n+        let trait_impls = root.impls.decode((&blob, sess))\n+            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls)).collect();\n+        let alloc_decoding_state =\n+            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n+        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+        CrateMetadata {\n+            blob,\n+            root,\n+            def_path_table,\n+            trait_impls,\n+            raw_proc_macros,\n+            source_map_import_info: Once::new(),\n+            alloc_decoding_state,\n+            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n+            cnum,\n+            cnum_map,\n+            dependencies,\n+            dep_kind: Lock::new(dep_kind),\n+            source,\n+            private_dep,\n+            host_hash,\n+            extern_crate: Lock::new(None),\n+        }\n+    }\n+\n     fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n@@ -1391,7 +1500,7 @@ impl<'a, 'tcx> CrateMetadata {\n             // would always write the same value.\n \n             let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n-            let dep_node = def_path_hash.to_dep_node(DepKind::CrateMetadata);\n+            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n \n             dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n             assert!(dep_node_index != DepNodeIndex::INVALID);"}, {"sha": "aa1dc843654f033c8ade182ecb999a98bdec4e85", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=c1570238b84434363e3ec915d83fa032991885da", "patch": "@@ -52,7 +52,7 @@ macro_rules! provide {\n                 assert!(!$def_id.is_local());\n \n                 let $cdata = $tcx.crate_data_as_any($def_id.krate);\n-                let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n+                let $cdata = $cdata.downcast_ref::<rmeta::CrateMetadata>()\n                     .expect(\"CrateStore created data is not a CrateMetadata\");\n \n                 if $tcx.dep_graph.is_fully_enabled() {"}, {"sha": "1dba07ccc628cfa4c1a9cb63858efb4b958c478c", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1570238b84434363e3ec915d83fa032991885da/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=c1570238b84434363e3ec915d83fa032991885da", "patch": "@@ -25,7 +25,7 @@ use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n pub use decoder::{provide, provide_extern};\n-crate use decoder::{ImportedSourceFile, MetadataBlob};\n+crate use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n \n mod decoder;\n mod encoder;\n@@ -197,10 +197,10 @@ crate struct CrateRoot<'tcx> {\n     native_libraries: Lazy<[NativeLibrary]>,\n     foreign_modules: Lazy<[ForeignModule]>,\n     source_map: Lazy<[syntax_pos::SourceFile]>,\n-    pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: Lazy<[TraitImpls]>,\n+    def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n+    impls: Lazy<[TraitImpls]>,\n     exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n-    pub interpret_alloc_index: Lazy<[u32]>,\n+    interpret_alloc_index: Lazy<[u32]>,\n \n     per_def: LazyPerDefTables<'tcx>,\n \n@@ -229,8 +229,8 @@ crate struct CrateDep {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct TraitImpls {\n-    pub trait_id: (u32, DefIndex),\n-    pub impls: Lazy<[DefIndex]>,\n+    trait_id: (u32, DefIndex),\n+    impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}]}