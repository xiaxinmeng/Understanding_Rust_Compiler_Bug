{"sha": "f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZDgzMGI0ZGVjYWVmNWE2YWUwZjI3YmFhYzE0ZGZiNDhiYWE0YzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-09T04:01:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-09T04:01:28Z"}, "message": "Auto merge of #68376 - Centril:move-ref-patterns, r=matthewjasper\n\nInitial implementation of `#![feature(move_ref_pattern)]`\n\nFollowing up on #45600, under the gate `#![feature(move_ref_pattern)]`, `(ref x, mut y)` is allowed subject to restrictions necessary for soundness. The match checking implementation and tests for `#![feature(bindings_after_at)]` is also adjusted as necessary.\n\nCloses #45600.\nTracking issue: #68354.\n\nr? @matthewjasper", "tree": {"sha": "a5e7a6a7f68e12dbd174c1313b4d0ab0e742dbdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5e7a6a7f68e12dbd174c1313b4d0ab0e742dbdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "html_url": "https://github.com/rust-lang/rust/commit/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "html_url": "https://github.com/rust-lang/rust/commit/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a"}, {"sha": "d2b88b7050b0e21b136022c4cfe8d352c1425588", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b88b7050b0e21b136022c4cfe8d352c1425588", "html_url": "https://github.com/rust-lang/rust/commit/d2b88b7050b0e21b136022c4cfe8d352c1425588"}], "stats": {"total": 3682, "additions": 2833, "deletions": 849}, "files": [{"sha": "aaabba0434993e6dda9c58e82d3c2d00468f4a21", "filename": "src/librustc_error_codes/error_codes/E0009.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,3 +1,5 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n In a pattern, all values that don't implement the `Copy` trait have to be bound\n the same way. The goal here is to avoid binding simultaneously by-move and\n by-ref.\n@@ -6,7 +8,9 @@ This limitation may be removed in a future version of Rust.\n \n Erroneous code example:\n \n-```compile_fail,E0009\n+```\n+#![feature(move_ref_pattern)]\n+\n struct X { x: (), }\n \n let x = Some((X { x: () }, X { x: () }));"}, {"sha": "82bbae18a9c0b53c5dc5df7e93ba42a8375bb1e6", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -186,11 +186,25 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// all, and you just supplied a `Span` to create the diagnostic,\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n-    pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n+    pub fn span_label(&mut self, span: Span, label: impl Into<String>) -> &mut Self {\n         self.0.diagnostic.span_label(span, label);\n         self\n     }\n \n+    /// Labels all the given spans with the provided label.\n+    /// See `span_label` for more information.\n+    pub fn span_labels(\n+        &mut self,\n+        spans: impl IntoIterator<Item = Span>,\n+        label: impl AsRef<str>,\n+    ) -> &mut Self {\n+        let label = label.as_ref();\n+        for span in spans {\n+            self.0.diagnostic.span_label(span, label);\n+        }\n+        self\n+    }\n+\n     forward!(pub fn note_expected_found(\n         &mut self,\n         expected_label: &dyn fmt::Display,"}, {"sha": "135500c0a8d9ffb0b7643b7775a949e0109360fd", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -535,6 +535,10 @@ declare_features! (\n     /// For example, you can write `x @ Some(y)`.\n     (active, bindings_after_at, \"1.41.0\", Some(65490), None),\n \n+    /// Allows patterns with concurrent by-move and by-ref bindings.\n+    /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n+    (active, move_ref_pattern, \"1.42.0\", Some(68354), None),\n+\n     /// Allows `impl const Trait for T` syntax.\n     (active, const_trait_impl, \"1.42.0\", Some(67792), None),\n "}, {"sha": "b77bd4ecb8e1f5c63b1c54ece4a2c46a71ba433d", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 113, "deletions": 71, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -16,8 +16,7 @@ use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n-use rustc_span::symbol::sym;\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::{sym, Span};\n use syntax::ast::Mutability;\n \n use std::slice;\n@@ -114,8 +113,10 @@ impl PatCtxt<'_, '_> {\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_patterns(&mut self, has_guard: bool, pat: &Pat<'_>) {\n-        check_legality_of_move_bindings(self, has_guard, pat);\n-        check_borrow_conflicts_in_at_patterns(self, pat);\n+        if !self.tcx.features().move_ref_pattern {\n+            check_legality_of_move_bindings(self, has_guard, pat);\n+        }\n+        pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n         }\n@@ -559,6 +560,11 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n     covered\n }\n \n+/// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n+fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> bool {\n+    !cx.tables.node_type(hir_id).is_copy_modulo_regions(cx.tcx, cx.param_env, span)\n+}\n+\n /// Check the legality of legality of by-move bindings.\n fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat<'_>) {\n     let sess = cx.tcx.sess;\n@@ -589,8 +595,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     pat.walk_always(|p| {\n         if let hir::PatKind::Binding(.., sub) = &p.kind {\n             if let Some(ty::BindByValue(_)) = tables.extract_binding_mode(sess, p.hir_id, p.span) {\n-                let pat_ty = tables.node_type(p.hir_id);\n-                if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n+                if is_binding_by_move(cx, p.hir_id, p.span) {\n                     check_move(p, sub.as_deref());\n                 }\n             }\n@@ -599,11 +604,11 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n \n     // Found some bad by-move spans, error!\n     if !by_move_spans.is_empty() {\n-        let mut err = struct_span_err!(\n-            sess,\n-            MultiSpan::from_spans(by_move_spans.clone()),\n-            E0009,\n-            \"cannot bind by-move and by-ref in the same pattern\",\n+        let mut err = feature_err(\n+            &sess.parse_sess,\n+            sym::move_ref_pattern,\n+            by_move_spans.clone(),\n+            \"binding by-move and by-ref in the same pattern is unstable\",\n         );\n         for span in by_ref_spans.iter() {\n             err.span_label(*span, \"by-ref pattern here\");\n@@ -615,81 +620,118 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     }\n }\n \n-/// Check that there are no borrow conflicts in `binding @ subpat` patterns.\n+/// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n ///\n /// For example, this would reject:\n /// - `ref x @ Some(ref mut y)`,\n-/// - `ref mut x @ Some(ref y)`\n-/// - `ref mut x @ Some(ref mut y)`.\n+/// - `ref mut x @ Some(ref y)`,\n+/// - `ref mut x @ Some(ref mut y)`,\n+/// - `ref mut? x @ Some(y)`, and\n+/// - `x @ Some(ref mut? y)`.\n ///\n /// This analysis is *not* subsumed by NLL.\n fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n-    let tab = cx.tables;\n-    let sess = cx.tcx.sess;\n-    // Get the mutability of `p` if it's by-ref.\n-    let extract_binding_mut = |hir_id, span| match tab.extract_binding_mode(sess, hir_id, span)? {\n-        ty::BindByValue(_) => None,\n-        ty::BindByReference(m) => Some(m),\n+    // Extract `sub` in `binding @ sub`.\n+    let (name, sub) = match &pat.kind {\n+        hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),\n+        _ => return,\n     };\n-    pat.walk_always(|pat| {\n-        // Extract `sub` in `binding @ sub`.\n-        let (name, sub) = match &pat.kind {\n-            hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),\n-            _ => return,\n-        };\n+    let binding_span = pat.span.with_hi(name.span.hi());\n \n-        // Extract the mutability.\n-        let mut_outer = match extract_binding_mut(pat.hir_id, pat.span) {\n-            None => return,\n-            Some(m) => m,\n-        };\n+    let tables = cx.tables;\n+    let sess = cx.tcx.sess;\n \n-        // We now have `ref $mut_outer binding @ sub` (semantically).\n-        // Recurse into each binding in `sub` and find mutability conflicts.\n-        let mut conflicts_mut_mut = Vec::new();\n-        let mut conflicts_mut_ref = Vec::new();\n-        sub.each_binding(|_, hir_id, span, _| {\n-            if let Some(mut_inner) = extract_binding_mut(hir_id, span) {\n-                match (mut_outer, mut_inner) {\n-                    (Mutability::Not, Mutability::Not) => {}\n-                    (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push(span),\n-                    _ => conflicts_mut_ref.push(span),\n+    // Get the binding move, extract the mutability if by-ref.\n+    let mut_outer = match tables.extract_binding_mode(sess, pat.hir_id, pat.span) {\n+        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id, pat.span) => {\n+            // We have `x @ pat` where `x` is by-move. Reject all borrows in `pat`.\n+            let mut conflicts_ref = Vec::new();\n+            sub.each_binding(|_, hir_id, span, _| {\n+                match tables.extract_binding_mode(sess, hir_id, span) {\n+                    Some(ty::BindByValue(_)) | None => {}\n+                    Some(ty::BindByReference(_)) => conflicts_ref.push(span),\n                 }\n+            });\n+            if !conflicts_ref.is_empty() {\n+                let occurs_because = format!(\n+                    \"move occurs because `{}` has type `{}` which does implement the `Copy` trait\",\n+                    name,\n+                    tables.node_type(pat.hir_id),\n+                );\n+                sess.struct_span_err(pat.span, \"borrow of moved value\")\n+                    .span_label(binding_span, format!(\"value moved into `{}` here\", name))\n+                    .span_label(binding_span, occurs_because)\n+                    .span_labels(conflicts_ref, \"value borrowed here after move\")\n+                    .emit();\n             }\n-        });\n+            return;\n+        }\n+        Some(ty::BindByValue(_)) | None => return,\n+        Some(ty::BindByReference(m)) => m,\n+    };\n \n-        // Report errors if any.\n-        let binding_span = pat.span.with_hi(name.span.hi());\n-        if !conflicts_mut_mut.is_empty() {\n-            // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n-            let msg = &format!(\"cannot borrow `{}` as mutable more than once at a time\", name);\n-            let mut err = sess.struct_span_err(pat.span, msg);\n-            err.span_label(binding_span, \"first mutable borrow occurs here\");\n-            for sp in conflicts_mut_mut {\n-                err.span_label(sp, \"another mutable borrow occurs here\");\n-            }\n-            for sp in conflicts_mut_ref {\n-                err.span_label(sp, \"also borrowed as immutable here\");\n-            }\n-            err.emit();\n-        } else if !conflicts_mut_ref.is_empty() {\n-            // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n-            let (primary, also) = match mut_outer {\n-                Mutability::Mut => (\"mutable\", \"immutable\"),\n-                Mutability::Not => (\"immutable\", \"mutable\"),\n-            };\n-            let msg = &format!(\n-                \"cannot borrow `{}` as {} because it is also borrowed as {}\",\n-                name, also, primary,\n-            );\n-            let mut err = sess.struct_span_err(pat.span, msg);\n-            err.span_label(binding_span, &format!(\"{} borrow occurs here\", primary));\n-            for sp in conflicts_mut_ref {\n-                err.span_label(sp, &format!(\"{} borrow occurs here\", also));\n+    // We now have `ref $mut_outer binding @ sub` (semantically).\n+    // Recurse into each binding in `sub` and find mutability or move conflicts.\n+    let mut conflicts_move = Vec::new();\n+    let mut conflicts_mut_mut = Vec::new();\n+    let mut conflicts_mut_ref = Vec::new();\n+    sub.each_binding(|_, hir_id, span, name| {\n+        match tables.extract_binding_mode(sess, hir_id, span) {\n+            Some(ty::BindByReference(mut_inner)) => match (mut_outer, mut_inner) {\n+                (Mutability::Not, Mutability::Not) => {} // Both sides are `ref`.\n+                (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push((span, name)), // 2x `ref mut`.\n+                _ => conflicts_mut_ref.push((span, name)), // `ref` + `ref mut` in either direction.\n+            },\n+            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id, span) => {\n+                conflicts_move.push((span, name)) // `ref mut?` + by-move conflict.\n             }\n-            err.emit();\n+            Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine.\n         }\n     });\n+\n+    // Report errors if any.\n+    if !conflicts_mut_mut.is_empty() {\n+        // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n+        let mut err = sess\n+            .struct_span_err(pat.span, \"cannot borrow value as mutable more than once at a time\");\n+        err.span_label(binding_span, format!(\"first mutable borrow, by `{}`, occurs here\", name));\n+        for (span, name) in conflicts_mut_mut {\n+            err.span_label(span, format!(\"another mutable borrow, by `{}`, occurs here\", name));\n+        }\n+        for (span, name) in conflicts_mut_ref {\n+            err.span_label(span, format!(\"also borrowed as immutable, by `{}`, here\", name));\n+        }\n+        for (span, name) in conflicts_move {\n+            err.span_label(span, format!(\"also moved into `{}` here\", name));\n+        }\n+        err.emit();\n+    } else if !conflicts_mut_ref.is_empty() {\n+        // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n+        let (primary, also) = match mut_outer {\n+            Mutability::Mut => (\"mutable\", \"immutable\"),\n+            Mutability::Not => (\"immutable\", \"mutable\"),\n+        };\n+        let msg =\n+            format!(\"cannot borrow value as {} because it is also borrowed as {}\", also, primary);\n+        let mut err = sess.struct_span_err(pat.span, &msg);\n+        err.span_label(binding_span, format!(\"{} borrow, by `{}`, occurs here\", primary, name));\n+        for (span, name) in conflicts_mut_ref {\n+            err.span_label(span, format!(\"{} borrow, by `{}`, occurs here\", also, name));\n+        }\n+        for (span, name) in conflicts_move {\n+            err.span_label(span, format!(\"also moved into `{}` here\", name));\n+        }\n+        err.emit();\n+    } else if !conflicts_move.is_empty() {\n+        // Report by-ref and by-move conflicts, e.g. `ref x @ y`.\n+        let mut err =\n+            sess.struct_span_err(pat.span, \"cannot move out of value because it is borrowed\");\n+        err.span_label(binding_span, format!(\"value borrowed, by `{}`, here\", name));\n+        for (span, name) in conflicts_move {\n+            err.span_label(span, format!(\"value moved into `{}` here\", name));\n+        }\n+        err.emit();\n+    }\n }\n \n /// Forbids bindings in `@` patterns. This used to be is necessary for memory safety,"}, {"sha": "49582e064ea0c13ccd0f524d7d1c90e05e980493", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -457,6 +457,7 @@ symbols! {\n         module,\n         module_path,\n         more_struct_aliases,\n+        move_ref_pattern,\n         move_val_init,\n         movbe_target_feature,\n         mul_with_overflow,"}, {"sha": "238f2d958c6253b8308e24106629c4577cdfc091", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-2.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,15 +0,0 @@\n-struct X { x: (), }\n-\n-impl Drop for X {\n-    fn drop(&mut self) {\n-        println!(\"destructor runs\");\n-    }\n-}\n-\n-fn main() {\n-    let x = Some((X { x: () }, X { x: () }));\n-    match x {\n-        Some((ref _y, _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => panic!()\n-    }\n-}"}, {"sha": "ff00aa8caa8d3bcfa7692c899b6e32d43c829eb0", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-2.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.stderr?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,11 +0,0 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-2.rs:12:23\n-   |\n-LL |         Some((ref _y, _z)) => { },\n-   |               ------  ^^ by-move pattern here\n-   |               |\n-   |               by-ref pattern here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0009`."}, {"sha": "e8357e917881964935dcb879735b3a412adb3caf", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-3.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,18 +0,0 @@\n-struct X { x: (), }\n-\n-impl Drop for X {\n-    fn drop(&mut self) {\n-        println!(\"destructor runs\");\n-    }\n-}\n-\n-enum DoubleOption<T,U> { Some2(T,U), None2 }\n-\n-fn main() {\n-    let x = DoubleOption::Some2(X { x: () }, X { x: () });\n-    match x {\n-        DoubleOption::Some2(ref _y, _z) => { },\n-        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n-        DoubleOption::None2 => panic!()\n-    }\n-}"}, {"sha": "3e8358da3507da058d783590bd2a91a44639a37c", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-3.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.stderr?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,11 +0,0 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-3.rs:14:37\n-   |\n-LL |         DoubleOption::Some2(ref _y, _z) => { },\n-   |                             ------  ^^ by-move pattern here\n-   |                             |\n-   |                             by-ref pattern here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0009`."}, {"sha": "41dafd2b5bf72fe05c8235ae0664ed25a03caa11", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-4.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,15 +0,0 @@\n-struct X { x: (), }\n-\n-impl Drop for X {\n-    fn drop(&mut self) {\n-        println!(\"destructor runs\");\n-    }\n-}\n-\n-fn main() {\n-    let x = Some((X { x: () }, X { x: () }));\n-    match x {\n-        Some((_y, ref _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => panic!()\n-    }\n-}"}, {"sha": "00e0c70d6494b6d658ba149f64337498cd950aa1", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-4.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.stderr?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,11 +0,0 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-4.rs:12:15\n-   |\n-LL |         Some((_y, ref _z)) => { },\n-   |               ^^  ------ by-ref pattern here\n-   |               |\n-   |               by-move pattern here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0009`."}, {"sha": "88d36ab6aa66469c59dd3b2e86868642ba52a97d", "filename": "src/test/ui/drop/dynamic-drop-async.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -7,6 +7,8 @@\n // edition:2018\n // ignore-wasm32-bare compiled with panic=abort by default\n \n+#![feature(move_ref_pattern)]\n+\n #![allow(unused)]\n \n use std::{\n@@ -227,6 +229,12 @@ async fn subslice_pattern_reassign(a: Rc<Allocator>) {\n     a.alloc().await;\n }\n \n+async fn move_ref_pattern(a: Rc<Allocator>) {\n+    let mut tup = (a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await);\n+    let (ref _a, ref mut _b, _c, mut _d) = tup;\n+    a.alloc().await;\n+}\n+\n fn run_test<F, G>(cx: &mut Context<'_>, ref f: F)\n where\n     F: Fn(Rc<Allocator>) -> G,\n@@ -322,4 +330,6 @@ fn main() {\n     run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n     run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n     run_test(context, |a| subslice_pattern_reassign(a));\n+\n+    run_test(context, |a| move_ref_pattern(a));\n }"}, {"sha": "451686d9ae21ccf3d218dd582e2ae0b7319be58d", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -2,6 +2,7 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![feature(generators, generator_trait, untagged_unions)]\n+#![feature(move_ref_pattern)]\n \n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n@@ -290,6 +291,11 @@ fn subslice_mixed_min_lengths(a: &Allocator, c: i32) {\n     }\n }\n \n+fn move_ref_pattern(a: &Allocator) {\n+    let mut tup = (a.alloc(), a.alloc(), a.alloc(), a.alloc());\n+    let (ref _a, ref mut _b, _c, mut _d) = tup;\n+}\n+\n fn panic_after_return(a: &Allocator) -> Ptr<'_> {\n     // Panic in the drop of `p` or `q` can leak\n     let exceptions = vec![8, 9];\n@@ -453,6 +459,8 @@ fn main() {\n     run_test(|a| subslice_mixed_min_lengths(a, 6));\n     run_test(|a| subslice_mixed_min_lengths(a, 7));\n \n+    run_test(|a| move_ref_pattern(a));\n+\n     run_test(|a| {\n         panic_after_return(a);\n     });"}, {"sha": "0610d03cfe96d0cef8c54a60d797f526f86879b1", "filename": "src/test/ui/error-codes/E0009.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Ferror-codes%2FE0009.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Ferror-codes%2FE0009.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0009.rs?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,9 +0,0 @@\n-fn main() {\n-    struct X { x: (), }\n-    let x = Some((X { x: () }, X { x: () }));\n-    match x {\n-        Some((y, ref z)) => {},\n-        //~^ ERROR E0009\n-        None => panic!()\n-    }\n-}"}, {"sha": "446a436d6477952c8b15cd7e1029fb14e653abe8", "filename": "src/test/ui/error-codes/E0009.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Ferror-codes%2FE0009.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Ferror-codes%2FE0009.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0009.stderr?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,11 +0,0 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/E0009.rs:5:15\n-   |\n-LL |         Some((y, ref z)) => {},\n-   |               ^  ----- by-ref pattern here\n-   |               |\n-   |               by-move pattern here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0009`."}, {"sha": "9cb034e7592daa90ce5697d09d001ba869f1b1d8", "filename": "src/test/ui/issues/issue-53840.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fissues%2Fissue-53840.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a/src%2Ftest%2Fui%2Fissues%2Fissue-53840.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-53840.stderr?ref=a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "patch": "@@ -1,20 +0,0 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/issue-53840.rs:13:16\n-   |\n-LL |         E::Foo(a, b, ref c) => {}\n-   |                ^  ^  ----- by-ref pattern here\n-   |                |  |\n-   |                |  by-move pattern here\n-   |                by-move pattern here\n-\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/issue-53840.rs:17:14\n-   |\n-LL |         Bar {a, ref b} => {}\n-   |              ^  ----- by-ref pattern here\n-   |              |\n-   |              by-move pattern here\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0009`."}, {"sha": "5c1a61eb375a43a98a80910c26b38a0493f2079c", "filename": "src/test/ui/moves/move-out-of-slice-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,4 +1,4 @@\n-#![feature(slice_patterns, unsized_locals)]\n+#![feature(unsized_locals)]\n \n struct A;\n #[derive(Clone, Copy)]"}, {"sha": "c00296c34c4e521fd38e6abc838a456776423134", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -3,33 +3,38 @@\n // where one side is by-ref and the other is by-move.\n \n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n \n-struct X { x: () }\n+struct X {\n+    x: (),\n+}\n \n fn main() {\n     let x = Some(X { x: () });\n     match x {\n-        Some(ref _y @ _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => panic!()\n+        Some(ref _y @ _z) => {} //~ ERROR cannot move out of value because it is borrowed\n+        None => panic!(),\n     }\n \n     let x = Some(X { x: () });\n     match x {\n-        Some(_z @ ref _y) => { }, //~ ERROR cannot bind by-move with sub-bindings\n+        Some(_z @ ref _y) => {}\n         //~^ ERROR borrow of moved value\n-        None => panic!()\n+        //~| ERROR borrow of moved value\n+        None => panic!(),\n     }\n \n     let mut x = Some(X { x: () });\n     match x {\n-        Some(ref mut _y @ _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => panic!()\n+        Some(ref mut _y @ _z) => {} //~ ERROR cannot move out of value because it is borrowed\n+        None => panic!(),\n     }\n \n     let mut x = Some(X { x: () });\n     match x {\n-        Some(_z @ ref mut _y) => { }, //~ ERROR cannot bind by-move with sub-bindings\n+        Some(_z @ ref mut _y) => {}\n         //~^ ERROR borrow of moved value\n-        None => panic!()\n+        //~| ERROR borrow of moved value\n+        None => panic!(),\n     }\n }"}, {"sha": "026747c212a2c767b96ab88d4312fd1b1aa1002e", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.stderr", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,37 +1,45 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:12:23\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:15:14\n    |\n-LL |         Some(ref _y @ _z) => { },\n-   |              ---------^^\n+LL |         Some(ref _y @ _z) => {}\n+   |              ------^^^--\n    |              |        |\n-   |              |        by-move pattern here\n-   |              by-ref pattern here\n+   |              |        value moved into `_z` here\n+   |              value borrowed, by `_y`, here\n \n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:18:14\n+error: borrow of moved value\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:21:14\n    |\n-LL |         Some(_z @ ref _y) => { },\n-   |              ^^^^^^^^^^^ binds an already bound by-move value by moving it\n+LL |         Some(_z @ ref _y) => {}\n+   |              --^^^------\n+   |              |    |\n+   |              |    value borrowed here after move\n+   |              value moved into `_z` here\n+   |              move occurs because `_z` has type `X` which does implement the `Copy` trait\n \n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:25:27\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:29:14\n    |\n-LL |         Some(ref mut _y @ _z) => { },\n-   |              -------------^^\n+LL |         Some(ref mut _y @ _z) => {}\n+   |              ----------^^^--\n    |              |            |\n-   |              |            by-move pattern here\n-   |              by-ref pattern here\n+   |              |            value moved into `_z` here\n+   |              value borrowed, by `_y`, here\n \n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:31:14\n+error: borrow of moved value\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:35:14\n    |\n-LL |         Some(_z @ ref mut _y) => { },\n-   |              ^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+LL |         Some(_z @ ref mut _y) => {}\n+   |              --^^^----------\n+   |              |    |\n+   |              |    value borrowed here after move\n+   |              value moved into `_z` here\n+   |              move occurs because `_z` has type `X` which does implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:18:19\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:21:19\n    |\n-LL |         Some(_z @ ref _y) => { },\n+LL |         Some(_z @ ref _y) => {}\n    |              -----^^^^^^\n    |              |    |\n    |              |    value borrowed here after move\n@@ -40,9 +48,9 @@ LL |         Some(_z @ ref _y) => { },\n    = note: move occurs because value has type `X`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:31:19\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:35:19\n    |\n-LL |         Some(_z @ ref mut _y) => { },\n+LL |         Some(_z @ ref mut _y) => {}\n    |              -----^^^^^^^^^^\n    |              |    |\n    |              |    value borrowed here after move\n@@ -52,5 +60,4 @@ LL |         Some(_z @ ref mut _y) => { },\n \n error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0007, E0009, E0382.\n-For more information about an error, try `rustc --explain E0007`.\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "7a2e5128b85377452e9edb08bd6c2ecb0a5aad1f", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-no-subbindings-fun-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,14 +1,14 @@\n // See issue #12534.\n \n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n \n fn main() {}\n \n struct A(Box<u8>);\n \n fn f(a @ A(u): A) -> Box<u8> {\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    //~^ ERROR use of moved value\n     drop(a);\n     u\n }"}, {"sha": "cfd978e13270987ce60896fc14f7b524f977715b", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-no-subbindings-fun-param.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,11 +1,5 @@\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/bind-by-move-no-subbindings-fun-param.rs:9:6\n-   |\n-LL | fn f(a @ A(u): A) -> Box<u8> {\n-   |      ^^^^^^^^ binds an already bound by-move value by moving it\n-\n error[E0382]: use of moved value\n-  --> $DIR/bind-by-move-no-subbindings-fun-param.rs:9:12\n+  --> $DIR/bind-by-move-no-subbindings-fun-param.rs:10:12\n    |\n LL | fn f(a @ A(u): A) -> Box<u8> {\n    |      ------^-\n@@ -14,7 +8,6 @@ LL | fn f(a @ A(u): A) -> Box<u8> {\n    |      value moved here\n    |      move occurs because value has type `A`, which does not implement the `Copy` trait\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0007, E0382.\n-For more information about an error, try `rustc --explain E0007`.\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "10865b92393b6ceb45cce0d0ac94c69203e12dc8", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,46 +1,34 @@\n // Test that moving on both sides of an `@` pattern is not allowed.\n \n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n \n fn main() {\n     struct U; // Not copy!\n \n     // Prevent promotion:\n-    fn u() -> U { U }\n+    fn u() -> U {\n+        U\n+    }\n \n-    let a @ b = U;\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    let a @ b = U; //~ ERROR use of moved value\n \n-    let a @ (b, c) = (U, U);\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    let a @ (b, c) = (U, U); //~ ERROR use of moved value\n \n-    let a @ (b, c) = (u(), u());\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    let a @ (b, c) = (u(), u()); //~ ERROR use of moved value\n \n     match Ok(U) {\n-        a @ Ok(b) | a @ Err(b) => {}\n-        //~^ ERROR cannot bind by-move with sub-bindings\n-        //~| ERROR use of moved value\n-        //~| ERROR cannot bind by-move with sub-bindings\n-        //~| ERROR use of moved value\n+        a @ Ok(b) | a @ Err(b) => {} //~ ERROR use of moved value\n+                                     //~^ ERROR use of moved value\n     }\n \n-    fn fun(a @ b: U) {}\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    fn fun(a @ b: U) {} //~ ERROR use of moved value\n \n     match [u(), u(), u(), u()] {\n-        xs @ [a, .., b] => {}\n-        //~^ ERROR cannot bind by-move with sub-bindings\n-        //~| ERROR use of moved value\n+        xs @ [a, .., b] => {} //~ ERROR use of moved value\n     }\n \n     match [u(), u(), u(), u()] {\n-        xs @ [_, ys @ .., _] => {}\n-        //~^ ERROR cannot bind by-move with sub-bindings\n-        //~| ERROR use of moved value\n+        xs @ [_, ys @ .., _] => {} //~ ERROR use of moved value\n     }\n }"}, {"sha": "56613ee7618b467cfb3c8d5d7241554d52d73333", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.stderr", "status": "modified", "additions": 10, "deletions": 59, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,53 +1,5 @@\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-move-and-move.rs:11:9\n-   |\n-LL |     let a @ b = U;\n-   |         ^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-move-and-move.rs:15:9\n-   |\n-LL |     let a @ (b, c) = (U, U);\n-   |         ^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-move-and-move.rs:19:9\n-   |\n-LL |     let a @ (b, c) = (u(), u());\n-   |         ^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-move-and-move.rs:24:9\n-   |\n-LL |         a @ Ok(b) | a @ Err(b) => {}\n-   |         ^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-move-and-move.rs:24:21\n-   |\n-LL |         a @ Ok(b) | a @ Err(b) => {}\n-   |                     ^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-move-and-move.rs:36:9\n-   |\n-LL |         xs @ [a, .., b] => {}\n-   |         ^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-move-and-move.rs:42:9\n-   |\n-LL |         xs @ [_, ys @ .., _] => {}\n-   |         ^^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-move-and-move.rs:31:12\n-   |\n-LL |     fn fun(a @ b: U) {}\n-   |            ^^^^^ binds an already bound by-move value by moving it\n-\n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:11:13\n+  --> $DIR/borrowck-move-and-move.rs:14:13\n    |\n LL |     let a @ b = U;\n    |         ----^   - move occurs because value has type `main::U`, which does not implement the `Copy` trait\n@@ -56,7 +8,7 @@ LL |     let a @ b = U;\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:15:17\n+  --> $DIR/borrowck-move-and-move.rs:16:17\n    |\n LL |     let a @ (b, c) = (U, U);\n    |         --------^-   ------ move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n@@ -65,7 +17,7 @@ LL |     let a @ (b, c) = (U, U);\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:19:17\n+  --> $DIR/borrowck-move-and-move.rs:18:17\n    |\n LL |     let a @ (b, c) = (u(), u());\n    |         --------^-   ---------- move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n@@ -74,7 +26,7 @@ LL |     let a @ (b, c) = (u(), u());\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:24:16\n+  --> $DIR/borrowck-move-and-move.rs:21:16\n    |\n LL |     match Ok(U) {\n    |           ----- move occurs because value has type `std::result::Result<main::U, main::U>`, which does not implement the `Copy` trait\n@@ -85,7 +37,7 @@ LL |         a @ Ok(b) | a @ Err(b) => {}\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:24:29\n+  --> $DIR/borrowck-move-and-move.rs:21:29\n    |\n LL |     match Ok(U) {\n    |           ----- move occurs because value has type `std::result::Result<main::U, main::U>`, which does not implement the `Copy` trait\n@@ -96,7 +48,7 @@ LL |         a @ Ok(b) | a @ Err(b) => {}\n    |                     value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:36:22\n+  --> $DIR/borrowck-move-and-move.rs:28:22\n    |\n LL |     match [u(), u(), u(), u()] {\n    |           -------------------- move occurs because value has type `[main::U; 4]`, which does not implement the `Copy` trait\n@@ -107,7 +59,7 @@ LL |         xs @ [a, .., b] => {}\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:42:18\n+  --> $DIR/borrowck-move-and-move.rs:32:18\n    |\n LL |     match [u(), u(), u(), u()] {\n    |           -------------------- move occurs because value has type `[main::U; 4]`, which does not implement the `Copy` trait\n@@ -118,7 +70,7 @@ LL |         xs @ [_, ys @ .., _] => {}\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:31:16\n+  --> $DIR/borrowck-move-and-move.rs:25:16\n    |\n LL |     fn fun(a @ b: U) {}\n    |            ----^\n@@ -127,7 +79,6 @@ LL |     fn fun(a @ b: U) {}\n    |            value moved here\n    |            move occurs because value has type `main::U`, which does not implement the `Copy` trait\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 8 previous errors\n \n-Some errors have detailed explanations: E0007, E0382.\n-For more information about an error, try `rustc --explain E0007`.\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "271f4bca0fcb8f46a0527213d74c8332043f8ffe", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box-pass.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -3,6 +3,7 @@\n // Test `@` patterns combined with `box` patterns.\n \n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n #![feature(box_patterns)]\n \n #[derive(Copy, Clone)]\n@@ -72,4 +73,14 @@ fn main() {\n         }\n         _ => {}\n     }\n+\n+    match Box::new([Ok(c()), Err(nc()), Ok(c())]) {\n+        box [Ok(a), ref xs @ .., Err(b)] => {}\n+        _ => {}\n+    }\n+\n+    match [Ok(Box::new(c())), Err(Box::new(nc())), Ok(Box::new(c())), Ok(Box::new(c()))] {\n+        [Ok(box ref a), ref xs @ .., Err(box b), Err(box ref mut c)] => {}\n+        _ => {}\n+    }\n }"}, {"sha": "32c638bcbcca366f085397f4d5c409748c1ec534", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,84 +1,73 @@\n // Test `@` patterns combined with `box` patterns.\n \n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n #![feature(box_patterns)]\n \n #[derive(Copy, Clone)]\n struct C;\n \n-fn c() -> C { C }\n+fn c() -> C {\n+    C\n+}\n \n struct NC;\n \n-fn nc() -> NC { NC }\n+fn nc() -> NC {\n+    NC\n+}\n \n fn main() {\n     let a @ box &b = Box::new(&C);\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    //~^ ERROR use of moved value\n \n     let a @ box b = Box::new(C);\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    //~^ ERROR use of moved value\n \n     fn f1(a @ box &b: Box<&C>) {}\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    //~^ ERROR use of moved value\n \n     fn f2(a @ box b: Box<C>) {}\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    //~^ ERROR use of moved value\n \n-    match Box::new(C) { a @ box b => {} }\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    match Box::new(C) {\n+        a @ box b => {} //~ ERROR use of moved value\n+    }\n \n-    let ref a @ box b = Box::new(NC); //~ ERROR cannot bind by-move and by-ref in the same pattern\n+    let ref a @ box b = Box::new(NC); //~ ERROR cannot move out of value because it is borrowed\n \n     let ref a @ box ref mut b = Box::new(nc());\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     let ref a @ box ref mut b = Box::new(NC);\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     let ref a @ box ref mut b = Box::new(NC);\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = NC;\n     let ref a @ box ref mut b = Box::new(NC);\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n     *b = NC;\n     drop(a);\n \n     let ref mut a @ box ref b = Box::new(NC);\n-    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n     *a = Box::new(NC);\n     drop(b);\n \n     fn f5(ref mut a @ box ref b: Box<NC>) {\n-        //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+        //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n         //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n         *a = Box::new(NC);\n         drop(b);\n     }\n \n     match Box::new(nc()) {\n         ref mut a @ box ref b => {\n-            //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+            //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n             //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n             *a = Box::new(NC);\n             drop(b);\n         }\n     }\n-\n-    match Box::new([Ok(c()), Err(nc()), Ok(c())]) {\n-        box [Ok(a), ref xs @ .., Err(b)] => {}\n-        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n-        _ => {}\n-    }\n-\n-    match [Ok(Box::new(c())), Err(Box::new(nc())), Ok(Box::new(c())), Ok(Box::new(c()))] {\n-        [Ok(box ref a), ref xs @ .., Err(box b), Err(box ref mut c)] => {}\n-        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n-        _ => {}\n-    }\n }"}, {"sha": "5534d0a75e63dabc0741efb0d02a64bfc8e75520", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "modified", "additions": 52, "deletions": 99, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,125 +1,77 @@\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-at-and-box.rs:16:9\n-   |\n-LL |     let a @ box &b = Box::new(&C);\n-   |         ^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-at-and-box.rs:20:9\n-   |\n-LL |     let a @ box b = Box::new(C);\n-   |         ^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-at-and-box.rs:32:25\n-   |\n-LL |     match Box::new(C) { a @ box b => {} }\n-   |                         ^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/borrowck-pat-at-and-box.rs:36:21\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-at-and-box.rs:37:9\n    |\n LL |     let ref a @ box b = Box::new(NC);\n-   |         ------------^\n+   |         -----^^^^^^^-\n    |         |           |\n-   |         |           by-move pattern here\n-   |         by-ref pattern here\n+   |         |           value moved into `b` here\n+   |         value borrowed, by `a`, here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:38:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:39:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(nc());\n    |         -----^^^^^^^---------\n    |         |           |\n-   |         |           mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |           mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:40:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:41:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n    |         |           |\n-   |         |           mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |           mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:42:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:43:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n    |         |           |\n-   |         |           mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |           mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:45:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:46:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n    |         |           |\n-   |         |           mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |           mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:51:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:52:9\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n    |         ---------^^^^^^^-----\n    |         |               |\n-   |         |               immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |               immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:65:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:66:9\n    |\n LL |         ref mut a @ box ref b => {\n    |         ---------^^^^^^^-----\n    |         |               |\n-   |         |               immutable borrow occurs here\n-   |         mutable borrow occurs here\n-\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/borrowck-pat-at-and-box.rs:74:38\n-   |\n-LL |         box [Ok(a), ref xs @ .., Err(b)] => {}\n-   |                     -----------      ^ by-move pattern here\n-   |                     |\n-   |                     by-ref pattern here\n-\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/borrowck-pat-at-and-box.rs:80:46\n-   |\n-LL |         [Ok(box ref a), ref xs @ .., Err(box b), Err(box ref mut c)] => {}\n-   |                 -----   -----------          ^           --------- by-ref pattern here\n-   |                 |       |                    |\n-   |                 |       |                    by-move pattern here\n-   |                 |       by-ref pattern here\n-   |                 by-ref pattern here\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-at-and-box.rs:24:11\n-   |\n-LL |     fn f1(a @ box &b: Box<&C>) {}\n-   |           ^^^^^^^^^^ binds an already bound by-move value by moving it\n+   |         |               immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-at-and-box.rs:28:11\n-   |\n-LL |     fn f2(a @ box b: Box<C>) {}\n-   |           ^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:57:11\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:58:11\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n    |           ---------^^^^^^^-----\n    |           |               |\n-   |           |               immutable borrow occurs here\n-   |           mutable borrow occurs here\n+   |           |               immutable borrow, by `b`, occurs here\n+   |           mutable borrow, by `a`, occurs here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:16:18\n+  --> $DIR/borrowck-pat-at-and-box.rs:21:18\n    |\n LL |     let a @ box &b = Box::new(&C);\n    |         ---------^   ------------ move occurs because value has type `std::boxed::Box<&C>`, which does not implement the `Copy` trait\n@@ -128,7 +80,7 @@ LL |     let a @ box &b = Box::new(&C);\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:20:17\n+  --> $DIR/borrowck-pat-at-and-box.rs:24:17\n    |\n LL |     let a @ box b = Box::new(C);\n    |         --------^   ----------- move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n@@ -137,17 +89,18 @@ LL |     let a @ box b = Box::new(C);\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:32:33\n+  --> $DIR/borrowck-pat-at-and-box.rs:34:17\n    |\n-LL |     match Box::new(C) { a @ box b => {} }\n-   |           -----------   --------^\n-   |           |             |       |\n-   |           |             |       value used here after move\n-   |           |             value moved here\n-   |           move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n+LL |     match Box::new(C) {\n+   |           ----------- move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n+LL |         a @ box b => {}\n+   |         --------^\n+   |         |       |\n+   |         |       value used here after move\n+   |         value moved here\n \n error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:45:21\n+  --> $DIR/borrowck-pat-at-and-box.rs:46:21\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         ------------^^^^^^^^^\n@@ -159,7 +112,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:51:25\n+  --> $DIR/borrowck-pat-at-and-box.rs:52:25\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n    |         ----------------^^^^^\n@@ -171,7 +124,7 @@ LL |     *a = Box::new(NC);\n    |     -- mutable borrow later used here\n \n error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:65:25\n+  --> $DIR/borrowck-pat-at-and-box.rs:66:25\n    |\n LL |         ref mut a @ box ref b => {\n    |         ----------------^^^^^\n@@ -183,7 +136,7 @@ LL |             *a = Box::new(NC);\n    |             -- mutable borrow later used here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:24:20\n+  --> $DIR/borrowck-pat-at-and-box.rs:27:20\n    |\n LL |     fn f1(a @ box &b: Box<&C>) {}\n    |           ---------^\n@@ -193,7 +146,7 @@ LL |     fn f1(a @ box &b: Box<&C>) {}\n    |           move occurs because value has type `std::boxed::Box<&C>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:28:19\n+  --> $DIR/borrowck-pat-at-and-box.rs:30:19\n    |\n LL |     fn f2(a @ box b: Box<C>) {}\n    |           --------^\n@@ -203,7 +156,7 @@ LL |     fn f2(a @ box b: Box<C>) {}\n    |           move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n \n error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:57:27\n+  --> $DIR/borrowck-pat-at-and-box.rs:58:27\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n    |           ----------------^^^^^\n@@ -214,7 +167,7 @@ LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n LL |         *a = Box::new(NC);\n    |         -- mutable borrow later used here\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 17 previous errors\n \n-Some errors have detailed explanations: E0007, E0009, E0382, E0502.\n-For more information about an error, try `rustc --explain E0007`.\n+Some errors have detailed explanations: E0382, E0502.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "147979171931319fbc6e639ada4f8e7183ff12c5", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse-promotion.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,10 @@\n+// Test that `by_move_binding @ pat_with_by_ref_bindings` is prevented even with promotion.\n+// Currently this logic exists in HAIR match checking as opposed to borrowck.\n+\n+#![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n+\n+fn main() {\n+    struct U;\n+    let a @ ref b = U; //~ ERROR borrow of moved value\n+}"}, {"sha": "91fdfd4f2abcc094cf87659d87679aba40da2f3e", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse-promotion.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,12 @@\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse-promotion.rs:9:9\n+   |\n+LL |     let a @ ref b = U;\n+   |         -^^^-----\n+   |         |   |\n+   |         |   value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `main::U` which does implement the `Copy` trait\n+\n+error: aborting due to previous error\n+"}, {"sha": "7d9618c8df78de6735dd3370b9a4b61895399183", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,98 @@\n+// Test that `by_move_binding @ pat_with_by_ref_bindings` is prevented.\n+\n+#![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n+\n+fn main() {\n+    struct U;\n+\n+    // Prevent promotion.\n+    fn u() -> U {\n+        U\n+    }\n+\n+    fn f1(a @ ref b: U) {}\n+    //~^ ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+\n+    fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n+    //~^ ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR use of moved value\n+    fn f3(a @ [ref mut b, ref c]: [U; 2]) {}\n+    //~^ ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+\n+    let a @ ref b = U;\n+    //~^ ERROR borrow of moved value\n+    let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n+    //~^ ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR use of moved value\n+    let a @ [ref mut b, ref c] = [U, U];\n+    //~^ ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    let a @ ref b = u();\n+    //~^ ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n+    //~^ ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+    //~| ERROR use of moved value\n+    let a @ [ref mut b, ref c] = [u(), u()];\n+    //~^ ERROR borrow of moved value\n+    //~| ERROR borrow of moved value\n+\n+    match Some(U) {\n+        a @ Some(ref b) => {}\n+        //~^ ERROR borrow of moved value\n+        None => {}\n+    }\n+    match Some((U, U)) {\n+        a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+        //~^ ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        //~| ERROR use of moved value\n+        None => {}\n+    }\n+    match Some([U, U]) {\n+        mut a @ Some([ref b, ref mut c]) => {}\n+        //~^ ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        None => {}\n+    }\n+    match Some(u()) {\n+        a @ Some(ref b) => {}\n+        //~^ ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        None => {}\n+    }\n+    match Some((u(), u())) {\n+        a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+        //~^ ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        //~| ERROR use of moved value\n+        None => {}\n+    }\n+    match Some([u(), u()]) {\n+        mut a @ Some([ref b, ref mut c]) => {}\n+        //~^ ERROR borrow of moved value\n+        //~| ERROR borrow of moved value\n+        None => {}\n+    }\n+}"}, {"sha": "ec86692dc6962c287542da93ede6f2b7e6606f17", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse.stderr", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,503 @@\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:29:9\n+   |\n+LL |     let a @ ref b = U;\n+   |         -^^^-----\n+   |         |   |\n+   |         |   value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:9\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n+   |         -^^^^^^^^^^^^---------^^^^^^-----^\n+   |         |            |              |\n+   |         |            |              value borrowed here after move\n+   |         |            value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `(main::U, main::U)` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:14\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n+   |              -----^^^---------\n+   |              |       |\n+   |              |       value borrowed here after move\n+   |              value moved into `b` here\n+   |              move occurs because `b` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:33\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n+   |                                 -^^^-----\n+   |                                 |   |\n+   |                                 |   value borrowed here after move\n+   |                                 value moved into `d` here\n+   |                                 move occurs because `d` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:38:9\n+   |\n+LL |     let a @ [ref mut b, ref c] = [U, U];\n+   |         -^^^^---------^^-----^\n+   |         |    |          |\n+   |         |    |          value borrowed here after move\n+   |         |    value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `[main::U; 2]` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:41:9\n+   |\n+LL |     let a @ ref b = u();\n+   |         -^^^-----\n+   |         |   |\n+   |         |   value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:9\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n+   |         -^^^^^^^^^^^^---------^^^^^^-----^\n+   |         |            |              |\n+   |         |            |              value borrowed here after move\n+   |         |            value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `(main::U, main::U)` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:14\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n+   |              -----^^^---------\n+   |              |       |\n+   |              |       value borrowed here after move\n+   |              value moved into `b` here\n+   |              move occurs because `b` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:33\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n+   |                                 -^^^-----\n+   |                                 |   |\n+   |                                 |   value borrowed here after move\n+   |                                 value moved into `d` here\n+   |                                 move occurs because `d` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:51:9\n+   |\n+LL |     let a @ [ref mut b, ref c] = [u(), u()];\n+   |         -^^^^---------^^-----^\n+   |         |    |          |\n+   |         |    |          value borrowed here after move\n+   |         |    value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `[main::U; 2]` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:56:9\n+   |\n+LL |         a @ Some(ref b) => {}\n+   |         -^^^^^^^^-----^\n+   |         |        |\n+   |         |        value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `std::option::Option<main::U>` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:9\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |         -^^^^^^^^^^^^^^^^^---------^^^^^^-----^^\n+   |         |                 |              |\n+   |         |                 |              value borrowed here after move\n+   |         |                 value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `std::option::Option<(main::U, main::U)>` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:19\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |                   -----^^^---------\n+   |                   |       |\n+   |                   |       value borrowed here after move\n+   |                   value moved into `b` here\n+   |                   move occurs because `b` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:38\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |                                      -^^^-----\n+   |                                      |   |\n+   |                                      |   value borrowed here after move\n+   |                                      value moved into `d` here\n+   |                                      move occurs because `d` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:71:9\n+   |\n+LL |         mut a @ Some([ref b, ref mut c]) => {}\n+   |         -----^^^^^^^^^-----^^---------^^\n+   |         |             |      |\n+   |         |             |      value borrowed here after move\n+   |         |             value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `std::option::Option<[main::U; 2]>` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:77:9\n+   |\n+LL |         a @ Some(ref b) => {}\n+   |         -^^^^^^^^-----^\n+   |         |        |\n+   |         |        value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `std::option::Option<main::U>` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:9\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |         -^^^^^^^^^^^^^^^^^---------^^^^^^-----^^\n+   |         |                 |              |\n+   |         |                 |              value borrowed here after move\n+   |         |                 value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `std::option::Option<(main::U, main::U)>` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:19\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |                   -----^^^---------\n+   |                   |       |\n+   |                   |       value borrowed here after move\n+   |                   value moved into `b` here\n+   |                   move occurs because `b` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:38\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |                                      -^^^-----\n+   |                                      |   |\n+   |                                      |   value borrowed here after move\n+   |                                      value moved into `d` here\n+   |                                      move occurs because `d` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:93:9\n+   |\n+LL |         mut a @ Some([ref b, ref mut c]) => {}\n+   |         -----^^^^^^^^^-----^^---------^^\n+   |         |             |      |\n+   |         |             |      value borrowed here after move\n+   |         |             value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `std::option::Option<[main::U; 2]>` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:11\n+   |\n+LL |     fn f1(a @ ref b: U) {}\n+   |           -^^^-----\n+   |           |   |\n+   |           |   value borrowed here after move\n+   |           value moved into `a` here\n+   |           move occurs because `a` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:11\n+   |\n+LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n+   |           -----^^^^^^^^-----^^^^^^^^^^-----^\n+   |           |            |              |\n+   |           |            |              value borrowed here after move\n+   |           |            value borrowed here after move\n+   |           value moved into `a` here\n+   |           move occurs because `a` has type `(main::U, main::U)` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:20\n+   |\n+LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n+   |                    -^^^-----\n+   |                    |   |\n+   |                    |   value borrowed here after move\n+   |                    value moved into `b` here\n+   |                    move occurs because `b` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:31\n+   |\n+LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n+   |                               -----^^^-----\n+   |                               |       |\n+   |                               |       value borrowed here after move\n+   |                               value moved into `d` here\n+   |                               move occurs because `d` has type `main::U` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:25:11\n+   |\n+LL |     fn f3(a @ [ref mut b, ref c]: [U; 2]) {}\n+   |           -^^^^---------^^-----^\n+   |           |    |          |\n+   |           |    |          value borrowed here after move\n+   |           |    value borrowed here after move\n+   |           value moved into `a` here\n+   |           move occurs because `a` has type `[main::U; 2]` which does implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:22\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n+   |              --------^^^^^^^^^\n+   |              |       |\n+   |              |       value borrowed here after move\n+   |              value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:33\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n+   |         ------------------------^^^^^^^^^-   ------ move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n+   |         |                       |\n+   |         |                       value used here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:37\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n+   |                                 ----^^^^^\n+   |                                 |   |\n+   |                                 |   value borrowed here after move\n+   |                                 value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:38:25\n+   |\n+LL |     let a @ [ref mut b, ref c] = [U, U];\n+   |         ----------------^^^^^-   ------ move occurs because value has type `[main::U; 2]`, which does not implement the `Copy` trait\n+   |         |               |\n+   |         |               value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:41:13\n+   |\n+LL |     let a @ ref b = u();\n+   |         ----^^^^^   --- move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+   |         |   |\n+   |         |   value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:22\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n+   |              --------^^^^^^^^^\n+   |              |       |\n+   |              |       value borrowed here after move\n+   |              value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:33\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n+   |         ------------------------^^^^^^^^^-   ---------- move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n+   |         |                       |\n+   |         |                       value used here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:37\n+   |\n+LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n+   |                                 ----^^^^^\n+   |                                 |   |\n+   |                                 |   value borrowed here after move\n+   |                                 value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:51:25\n+   |\n+LL |     let a @ [ref mut b, ref c] = [u(), u()];\n+   |         ----------------^^^^^-   ---------- move occurs because value has type `[main::U; 2]`, which does not implement the `Copy` trait\n+   |         |               |\n+   |         |               value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:27\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |                   --------^^^^^^^^^\n+   |                   |       |\n+   |                   |       value borrowed here after move\n+   |                   value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:38\n+   |\n+LL |     match Some((U, U)) {\n+   |           ------------ move occurs because value has type `std::option::Option<(main::U, main::U)>`, which does not implement the `Copy` trait\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |         -----------------------------^^^^^^^^^--\n+   |         |                            |\n+   |         |                            value used here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:42\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |                                      ----^^^^^\n+   |                                      |   |\n+   |                                      |   value borrowed here after move\n+   |                                      value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:71:30\n+   |\n+LL |     match Some([U, U]) {\n+   |           ------------ move occurs because value has type `std::option::Option<[main::U; 2]>`, which does not implement the `Copy` trait\n+LL |         mut a @ Some([ref b, ref mut c]) => {}\n+   |         ---------------------^^^^^^^^^--\n+   |         |                    |\n+   |         |                    value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:77:18\n+   |\n+LL |     match Some(u()) {\n+   |           --------- move occurs because value has type `std::option::Option<main::U>`, which does not implement the `Copy` trait\n+LL |         a @ Some(ref b) => {}\n+   |         ---------^^^^^-\n+   |         |        |\n+   |         |        value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:27\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |                   --------^^^^^^^^^\n+   |                   |       |\n+   |                   |       value borrowed here after move\n+   |                   value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:38\n+   |\n+LL |     match Some((u(), u())) {\n+   |           ---------------- move occurs because value has type `std::option::Option<(main::U, main::U)>`, which does not implement the `Copy` trait\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |         -----------------------------^^^^^^^^^--\n+   |         |                            |\n+   |         |                            value used here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:42\n+   |\n+LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n+   |                                      ----^^^^^\n+   |                                      |   |\n+   |                                      |   value borrowed here after move\n+   |                                      value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:93:30\n+   |\n+LL |     match Some([u(), u()]) {\n+   |           ---------------- move occurs because value has type `std::option::Option<[main::U; 2]>`, which does not implement the `Copy` trait\n+LL |         mut a @ Some([ref b, ref mut c]) => {}\n+   |         ---------------------^^^^^^^^^--\n+   |         |                    |\n+   |         |                    value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:15\n+   |\n+LL |     fn f1(a @ ref b: U) {}\n+   |           ----^^^^^\n+   |           |   |\n+   |           |   value borrowed here after move\n+   |           value moved here\n+   |           move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:24\n+   |\n+LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n+   |                    ----^^^^^\n+   |                    |   |\n+   |                    |   value borrowed here after move\n+   |                    value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:31\n+   |\n+LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n+   |           --------------------^^^^^^^^^^^^^-\n+   |           |                   |\n+   |           |                   value used here after move\n+   |           value moved here\n+   |           move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:39\n+   |\n+LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n+   |                               --------^^^^^\n+   |                               |       |\n+   |                               |       value borrowed here after move\n+   |                               value moved here\n+   |\n+   = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:25:27\n+   |\n+LL |     fn f3(a @ [ref mut b, ref c]: [U; 2]) {}\n+   |           ----------------^^^^^-\n+   |           |               |\n+   |           |               value borrowed here after move\n+   |           value moved here\n+   |           move occurs because value has type `[main::U; 2]`, which does not implement the `Copy` trait\n+\n+error: aborting due to 48 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "b7c8c8766c00a150dfe66bde101c153862893069", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,9 +1,74 @@\n+// Test that `ref mut? @ pat_with_by_move_bindings` is prevented.\n+\n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n \n fn main() {\n-    match Some(\"hi\".to_string()) {\n-        ref op_string_ref @ Some(s) => {},\n-        //~^ ERROR cannot bind by-move and by-ref in the same pattern [E0009]\n-        None => {},\n+    struct U;\n+\n+    // Prevent promotion.\n+    fn u() -> U {\n+        U\n+    }\n+\n+    fn f1(ref a @ b: U) {}\n+    //~^ ERROR cannot move out of value because it is borrowed\n+    fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n+    //~^ ERROR cannot move out of value because it is borrowed\n+    //~| ERROR cannot move out of value because it is borrowed\n+    //~| ERROR cannot move out of value because it is borrowed\n+    fn f3(ref mut a @ [b, mut c]: [U; 2]) {}\n+    //~^ ERROR cannot move out of value because it is borrowed\n+\n+    let ref a @ b = U;\n+    //~^ ERROR cannot move out of value because it is borrowed\n+    let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n+    //~^ ERROR cannot move out of value because it is borrowed\n+    //~| ERROR cannot move out of value because it is borrowed\n+    //~| ERROR cannot move out of value because it is borrowed\n+    let ref mut a @ [b, mut c] = [U, U];\n+    //~^ ERROR cannot move out of value because it is borrowed\n+    let ref a @ b = u();\n+    //~^ ERROR cannot move out of value because it is borrowed\n+    let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n+    //~^ ERROR cannot move out of value because it is borrowed\n+    //~| ERROR cannot move out of value because it is borrowed\n+    //~| ERROR cannot move out of value because it is borrowed\n+    let ref mut a @ [b, mut c] = [u(), u()];\n+    //~^ ERROR cannot move out of value because it is borrowed\n+\n+    match Some(U) {\n+        ref a @ Some(b) => {}\n+        //~^ ERROR cannot move out of value because it is borrowed\n+        None => {}\n+    }\n+    match Some((U, U)) {\n+        ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n+        //~^ ERROR cannot move out of value because it is borrowed\n+        //~| ERROR cannot move out of value because it is borrowed\n+        //~| ERROR cannot move out of value because it is borrowed\n+        None => {}\n+    }\n+    match Some([U, U]) {\n+        ref mut a @ Some([b, mut c]) => {}\n+        //~^ ERROR cannot move out of value because it is borrowed\n+        None => {}\n+    }\n+    match Some(u()) {\n+        ref a @ Some(b) => {}\n+        //~^ ERROR cannot move out of value because it is borrowed\n+        None => {}\n+    }\n+    match Some((u(), u())) {\n+        ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n+        //~^ ERROR cannot move out of value because it is borrowed\n+        //~| ERROR cannot move out of value because it is borrowed\n+        //~| ERROR cannot move out of value because it is borrowed\n+        None => {}\n+    }\n+    match Some([u(), u()]) {\n+        ref mut a @ Some([b, mut c]) => {}\n+        //~^ ERROR cannot move out of value because it is borrowed\n+        None => {}\n     }\n }"}, {"sha": "e5419efa00b362551afe436dfe95353a5059dd69", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.stderr", "status": "modified", "additions": 234, "deletions": 9, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,12 +1,237 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:5:34\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:23:9\n    |\n-LL |         ref op_string_ref @ Some(s) => {},\n-   |         -------------------------^-\n-   |         |                        |\n-   |         |                        by-move pattern here\n-   |         by-ref pattern here\n+LL |     let ref a @ b = U;\n+   |         -----^^^-\n+   |         |       |\n+   |         |       value moved into `b` here\n+   |         value borrowed, by `a`, here\n \n-error: aborting due to previous error\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:25:9\n+   |\n+LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n+   |         -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n+   |         |                |              |\n+   |         |                |              value moved into `e` here\n+   |         |                value moved into `c` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:25:18\n+   |\n+LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n+   |                  -----^^^-----\n+   |                  |       |\n+   |                  |       value moved into `c` here\n+   |                  value borrowed, by `b`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:25:33\n+   |\n+LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n+   |                                 -----^^^-\n+   |                                 |       |\n+   |                                 |       value moved into `e` here\n+   |                                 value borrowed, by `d`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:29:9\n+   |\n+LL |     let ref mut a @ [b, mut c] = [U, U];\n+   |         ---------^^^^-^^-----^\n+   |         |            |  |\n+   |         |            |  value moved into `c` here\n+   |         |            value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:31:9\n+   |\n+LL |     let ref a @ b = u();\n+   |         -----^^^-\n+   |         |       |\n+   |         |       value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:33:9\n+   |\n+LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n+   |         -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n+   |         |                |              |\n+   |         |                |              value moved into `e` here\n+   |         |                value moved into `c` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:33:18\n+   |\n+LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n+   |                  -----^^^-----\n+   |                  |       |\n+   |                  |       value moved into `c` here\n+   |                  value borrowed, by `b`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:33:33\n+   |\n+LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n+   |                                 -----^^^-\n+   |                                 |       |\n+   |                                 |       value moved into `e` here\n+   |                                 value borrowed, by `d`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:37:9\n+   |\n+LL |     let ref mut a @ [b, mut c] = [u(), u()];\n+   |         ---------^^^^-^^-----^\n+   |         |            |  |\n+   |         |            |  value moved into `c` here\n+   |         |            value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:41:9\n+   |\n+LL |         ref a @ Some(b) => {}\n+   |         -----^^^^^^^^-^\n+   |         |            |\n+   |         |            value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:46:9\n+   |\n+LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n+   |         -----^^^^^^^^^^^^^^^^^-----^^^^^^^^^^-^^\n+   |         |                     |              |\n+   |         |                     |              value moved into `e` here\n+   |         |                     value moved into `c` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:46:23\n+   |\n+LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n+   |                       -----^^^-----\n+   |                       |       |\n+   |                       |       value moved into `c` here\n+   |                       value borrowed, by `b`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:46:38\n+   |\n+LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n+   |                                      -----^^^-\n+   |                                      |       |\n+   |                                      |       value moved into `e` here\n+   |                                      value borrowed, by `d`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:53:9\n+   |\n+LL |         ref mut a @ Some([b, mut c]) => {}\n+   |         ---------^^^^^^^^^-^^-----^^\n+   |         |                 |  |\n+   |         |                 |  value moved into `c` here\n+   |         |                 value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:58:9\n+   |\n+LL |         ref a @ Some(b) => {}\n+   |         -----^^^^^^^^-^\n+   |         |            |\n+   |         |            value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:63:9\n+   |\n+LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n+   |         -----^^^^^^^^^^^^^^^^^-----^^^^^^^^^^-^^\n+   |         |                     |              |\n+   |         |                     |              value moved into `e` here\n+   |         |                     value moved into `c` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:63:23\n+   |\n+LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n+   |                       -----^^^-----\n+   |                       |       |\n+   |                       |       value moved into `c` here\n+   |                       value borrowed, by `b`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:63:38\n+   |\n+LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n+   |                                      -----^^^-\n+   |                                      |       |\n+   |                                      |       value moved into `e` here\n+   |                                      value borrowed, by `d`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:70:9\n+   |\n+LL |         ref mut a @ Some([b, mut c]) => {}\n+   |         ---------^^^^^^^^^-^^-----^^\n+   |         |                 |  |\n+   |         |                 |  value moved into `c` here\n+   |         |                 value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:14:11\n+   |\n+LL |     fn f1(ref a @ b: U) {}\n+   |           -----^^^-\n+   |           |       |\n+   |           |       value moved into `b` here\n+   |           value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:16:11\n+   |\n+LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n+   |           -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n+   |           |                |              |\n+   |           |                |              value moved into `e` here\n+   |           |                value moved into `c` here\n+   |           value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:16:20\n+   |\n+LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n+   |                    -----^^^-----\n+   |                    |       |\n+   |                    |       value moved into `c` here\n+   |                    value borrowed, by `b`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:16:35\n+   |\n+LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n+   |                                   -----^^^-\n+   |                                   |       |\n+   |                                   |       value moved into `e` here\n+   |                                   value borrowed, by `d`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:20:11\n+   |\n+LL |     fn f3(ref mut a @ [b, mut c]: [U; 2]) {}\n+   |           ---------^^^^-^^-----^\n+   |           |            |  |\n+   |           |            |  value moved into `c` here\n+   |           |            value moved into `b` here\n+   |           value borrowed, by `a`, here\n+\n+error: aborting due to 25 previous errors\n \n-For more information about this error, try `rustc --explain E0009`."}, {"sha": "58d4a9b018cee407c8cbba56a9912035112e836f", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,4 +1,5 @@\n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n \n enum Option<T> {\n     None,\n@@ -8,7 +9,7 @@ enum Option<T> {\n fn main() {\n     match &mut Some(1) {\n         ref mut z @ &mut Some(ref a) => {\n-        //~^ ERROR cannot borrow `z` as immutable because it is also borrowed as mutable\n+        //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n         //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n             **z = None;\n             println!(\"{}\", *a);\n@@ -22,58 +23,61 @@ fn main() {\n     fn u() -> U { U }\n \n     fn f1(ref a @ ref mut b: U) {}\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     fn f2(ref mut a @ ref b: U) {}\n-    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     fn f3(ref a @ [ref b, ref mut mid @ .., ref c]: [U; 4]) {}\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+    fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot move out of value because it is borrowed\n \n     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n-    //~| ERROR cannot borrow `b` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n \n     let ref a @ ref mut b = U;\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     let ref mut a @ ref b = U;\n-    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     let ref a @ (ref mut b, ref mut c) = (U, U);\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     let ref mut a @ (ref b, ref c) = (U, U);\n-    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n \n     let ref mut a @ ref b = u();\n-    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n     *a = u();\n     drop(b);\n     let ref a @ ref mut b = u();\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n     *b = u();\n     drop(a);\n \n     let ref mut a @ ref b = U;\n-    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     *a = U;\n     drop(b);\n     let ref a @ ref mut b = U;\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = U;\n     drop(a);\n \n     match Ok(U) {\n         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n-            //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n-            //~| ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+            //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n+            //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n             *a = Err(U);\n             drop(b);\n         }\n     }\n \n     match Ok(U) {\n         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n-            //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n-            //~| ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+            //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+            //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n             //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n             //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n             *b = U;\n@@ -83,52 +87,52 @@ fn main() {\n \n     match Ok(U) {\n         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n-        //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n-        //~| ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+        //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+        //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n         //~| ERROR cannot assign to `*b`, as it is immutable for the pattern guard\n         _ => {}\n     }\n     match Ok(U) {\n         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n-        //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n-        //~| ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+        //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n         //~| ERROR cannot assign to `*a`, as it is immutable for the pattern guard\n         _ => {}\n     }\n     match Ok(U) {\n         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n-        //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n-        //~| ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+        //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+        //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n         //~| ERROR cannot move out of `b` in pattern guard\n         //~| ERROR cannot move out of `b` in pattern guard\n         _ => {}\n     }\n     match Ok(U) {\n         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n-        //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n-        //~| ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+        //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n         //~| ERROR cannot move out of `a` in pattern guard\n         //~| ERROR cannot move out of `a` in pattern guard\n         _ => {}\n     }\n \n     let ref a @ (ref mut b, ref mut c) = (U, U);\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = U;\n     *c = U;\n \n     let ref a @ (ref mut b, ref mut c) = (U, U);\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n     //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n     *b = U;\n     drop(a);\n \n     let ref a @ (ref mut b, ref mut c) = (U, U);\n-    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = U; //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n     *c = U; //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n     drop(a);\n     let ref mut a @ (ref b, ref c) = (U, U);\n-    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n }"}, {"sha": "8c6ca888e0762588dfaa28e5ea9ddeeda61fc141", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.stderr", "status": "modified", "additions": 162, "deletions": 143, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,282 +1,301 @@\n-error: cannot borrow `z` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:10:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:11:9\n    |\n LL |         ref mut z @ &mut Some(ref a) => {\n    |         ---------^^^^^^^^^^^^^-----^\n    |         |                     |\n-   |         |                     immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |                     immutable borrow, by `a`, occurs here\n+   |         mutable borrow, by `z`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:31:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:35:9\n    |\n LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n    |         ---------^^^^-----------------^\n    |         |            |       |\n-   |         |            |       another mutable borrow occurs here\n-   |         |            also borrowed as immutable here\n-   |         first mutable borrow occurs here\n+   |         |            |       another mutable borrow, by `c`, occurs here\n+   |         |            also borrowed as immutable, by `b`, here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `b` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:31:22\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:35:22\n    |\n LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n    |                      -----^^^---------\n    |                      |       |\n-   |                      |       mutable borrow occurs here\n-   |                      immutable borrow occurs here\n+   |                      |       mutable borrow, by `c`, occurs here\n+   |                      immutable borrow, by `b`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:35:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:39:9\n    |\n LL |     let ref a @ ref mut b = U;\n    |         -----^^^---------\n    |         |       |\n-   |         |       mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |       mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:37:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:41:9\n    |\n LL |     let ref mut a @ ref b = U;\n    |         ---------^^^-----\n    |         |           |\n-   |         |           immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |           immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:39:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:43:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n    |         |        |          |\n-   |         |        |          mutable borrow occurs here\n-   |         |        mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |        |          mutable borrow, by `c`, occurs here\n+   |         |        mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:41:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:45:9\n    |\n LL |     let ref mut a @ (ref b, ref c) = (U, U);\n    |         ---------^^^^-----^^-----^\n    |         |            |      |\n-   |         |            |      immutable borrow occurs here\n-   |         |            immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |            |      immutable borrow, by `c`, occurs here\n+   |         |            immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:44:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:48:9\n    |\n LL |     let ref mut a @ ref b = u();\n    |         ---------^^^-----\n    |         |           |\n-   |         |           immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |           immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:49:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:53:9\n    |\n LL |     let ref a @ ref mut b = u();\n    |         -----^^^---------\n    |         |       |\n-   |         |       mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |       mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:55:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:59:9\n    |\n LL |     let ref mut a @ ref b = U;\n    |         ---------^^^-----\n    |         |           |\n-   |         |           immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |           immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:59:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:63:9\n    |\n LL |     let ref a @ ref mut b = U;\n    |         -----^^^---------\n    |         |       |\n-   |         |       mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |       mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:65:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:69:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n    |         ---------^^^^^^-----^\n    |         |              |\n-   |         |              immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |              immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:65:33\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:69:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n    |                                 ---------^^^^^^^-----^\n    |                                 |               |\n-   |                                 |               immutable borrow occurs here\n-   |                                 mutable borrow occurs here\n+   |                                 |               immutable borrow, by `b`, occurs here\n+   |                                 mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:74:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |         -----^^^^^^---------^\n    |         |          |\n-   |         |          mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |          mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:74:33\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |                                 -----^^^^^^^---------^\n    |                                 |           |\n-   |                                 |           mutable borrow occurs here\n-   |                                 immutable borrow occurs here\n+   |                                 |           mutable borrow, by `b`, occurs here\n+   |                                 immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:85:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:89:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n    |         -----^^^^^^---------^\n    |         |          |\n-   |         |          mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |          mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:85:33\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:89:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n    |                                 -----^^^^^^^---------^\n    |                                 |           |\n-   |                                 |           mutable borrow occurs here\n-   |                                 immutable borrow occurs here\n+   |                                 |           mutable borrow, by `b`, occurs here\n+   |                                 immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:92:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:96:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n    |         ---------^^^^^^-----^\n    |         |              |\n-   |         |              immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |              immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:92:33\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:96:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n    |                                 ---------^^^^^^^-----^\n    |                                 |               |\n-   |                                 |               immutable borrow occurs here\n-   |                                 mutable borrow occurs here\n+   |                                 |               immutable borrow, by `b`, occurs here\n+   |                                 mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:99:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:103:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |         -----^^^^^^---------^\n    |         |          |\n-   |         |          mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |          mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:99:33\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:103:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |                                 -----^^^^^^^---------^\n    |                                 |           |\n-   |                                 |           mutable borrow occurs here\n-   |                                 immutable borrow occurs here\n+   |                                 |           mutable borrow, by `b`, occurs here\n+   |                                 immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:107:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:111:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |         ---------^^^^^^-----^\n    |         |              |\n-   |         |              immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |              immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:107:33\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:111:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |                                 ---------^^^^^^^-----^\n    |                                 |               |\n-   |                                 |               immutable borrow occurs here\n-   |                                 mutable borrow occurs here\n+   |                                 |               immutable borrow, by `b`, occurs here\n+   |                                 mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:115:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:119:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n    |         |        |          |\n-   |         |        |          mutable borrow occurs here\n-   |         |        mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |        |          mutable borrow, by `c`, occurs here\n+   |         |        mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:120:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n    |         |        |          |\n-   |         |        |          mutable borrow occurs here\n-   |         |        mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |        |          mutable borrow, by `c`, occurs here\n+   |         |        mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:127:9\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n    |         |        |          |\n-   |         |        |          mutable borrow occurs here\n-   |         |        mutable borrow occurs here\n-   |         immutable borrow occurs here\n+   |         |        |          mutable borrow, by `c`, occurs here\n+   |         |        mutable borrow, by `b`, occurs here\n+   |         immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:132:9\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:136:9\n    |\n LL |     let ref mut a @ (ref b, ref c) = (U, U);\n    |         ---------^^^^-----^^-----^\n    |         |            |      |\n-   |         |            |      immutable borrow occurs here\n-   |         |            immutable borrow occurs here\n-   |         mutable borrow occurs here\n+   |         |            |      immutable borrow, by `c`, occurs here\n+   |         |            immutable borrow, by `b`, occurs here\n+   |         mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:24:11\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:25:11\n    |\n LL |     fn f1(ref a @ ref mut b: U) {}\n    |           -----^^^---------\n    |           |       |\n-   |           |       mutable borrow occurs here\n-   |           immutable borrow occurs here\n+   |           |       mutable borrow, by `b`, occurs here\n+   |           immutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:26:11\n+error: cannot borrow value as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:27:11\n    |\n LL |     fn f2(ref mut a @ ref b: U) {}\n    |           ---------^^^-----\n    |           |           |\n-   |           |           immutable borrow occurs here\n-   |           mutable borrow occurs here\n+   |           |           immutable borrow, by `b`, occurs here\n+   |           mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:28:11\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:29:11\n    |\n LL |     fn f3(ref a @ [ref b, ref mut mid @ .., ref c]: [U; 4]) {}\n    |           -----^^^^^^^^^^^----------------^^^^^^^^\n    |           |               |\n-   |           |               mutable borrow occurs here\n-   |           immutable borrow occurs here\n+   |           |               mutable borrow, by `mid`, occurs here\n+   |           immutable borrow, by `a`, occurs here\n+\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:31:22\n+   |\n+LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n+   |                      -----^^^-------------\n+   |                      |       |           |\n+   |                      |       |           also moved into `c` here\n+   |                      |       mutable borrow, by `b`, occurs here\n+   |                      immutable borrow, by `a`, occurs here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:31:30\n+   |\n+LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n+   |                              ---------^^^-\n+   |                              |           |\n+   |                              |           value moved into `c` here\n+   |                              value borrowed, by `b`, here\n \n error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:10:31\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:11:31\n    |\n LL |         ref mut z @ &mut Some(ref a) => {\n    |         ----------------------^^^^^-\n@@ -288,7 +307,7 @@ LL |             **z = None;\n    |             ---------- mutable borrow later used here\n \n error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:44:21\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:48:21\n    |\n LL |     let ref mut a @ ref b = u();\n    |         ------------^^^^^\n@@ -300,7 +319,7 @@ LL |     *a = u();\n    |     -------- mutable borrow later used here\n \n error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:49:17\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:53:17\n    |\n LL |     let ref a @ ref mut b = u();\n    |         --------^^^^^^^^^\n@@ -312,7 +331,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:74:20\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:20\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |         -----------^^^^^^^^^-\n@@ -324,7 +343,7 @@ LL |             drop(a);\n    |                  - immutable borrow later used here\n \n error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:74:45\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:45\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |                                 ------------^^^^^^^^^-\n@@ -336,55 +355,55 @@ LL |             drop(a);\n    |                  - immutable borrow later used here\n \n error[E0594]: cannot assign to `*b`, as it is immutable for the pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:85:61\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:89:61\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n    |                                                             ^^^^^^ cannot assign\n    |\n    = note: variables bound in patterns are immutable until the end of the pattern guard\n \n error[E0594]: cannot assign to `*a`, as it is immutable for the pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:92:61\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:96:61\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n    |                                                             ^^^^^^^^^^^ cannot assign\n    |\n    = note: variables bound in patterns are immutable until the end of the pattern guard\n \n error[E0507]: cannot move out of `b` in pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:99:66\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:103:66\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |                                                                  ^ move occurs because `b` has type `&mut main::U`, which does not implement the `Copy` trait\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n error[E0507]: cannot move out of `b` in pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:99:66\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:103:66\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |                                                                  ^ move occurs because `b` has type `&mut main::U`, which does not implement the `Copy` trait\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n error[E0507]: cannot move out of `a` in pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:107:66\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:111:66\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |                                                                  ^ move occurs because `a` has type `&mut std::result::Result<main::U, main::U>`, which does not implement the `Copy` trait\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n error[E0507]: cannot move out of `a` in pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:107:66\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:111:66\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |                                                                  ^ move occurs because `a` has type `&mut std::result::Result<main::U, main::U>`, which does not implement the `Copy` trait\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:120:18\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:18\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         ---------^^^^^^^^^------------\n@@ -396,7 +415,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:120:29\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:29\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         --------------------^^^^^^^^^-\n@@ -408,7 +427,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:127:18\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:18\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         ---------^^^^^^^^^------------\n@@ -420,7 +439,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:127:29\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:29\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         --------------------^^^^^^^^^-\n@@ -431,7 +450,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error: aborting due to 45 previous errors\n+error: aborting due to 47 previous errors\n \n Some errors have detailed explanations: E0502, E0507, E0594.\n For more information about an error, try `rustc --explain E0502`."}, {"sha": "f5c39a7ac527662ed061a2fc4cdad569913e0d45", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,46 +1,50 @@\n // Test that `ref mut x @ ref mut y` and varieties of that are not allowed.\n \n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n \n fn main() {\n     struct U;\n \n     fn u() -> U { U }\n \n     fn f1(ref mut a @ ref mut b: U) {}\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n     fn f2(ref mut a @ ref mut b: U) {}\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n     fn f3(\n         ref mut a @ [\n-        //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+        //~^ ERROR cannot borrow value as mutable more than once at a time\n             [ref b @ .., _],\n             [_, ref mut mid @ ..],\n             ..,\n             [..],\n         ] : [[U; 4]; 5]\n     ) {}\n+    fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n+    //~| ERROR cannot move out of value because it is borrowed\n \n     let ref mut a @ ref mut b = U;\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n     //~| ERROR cannot borrow `_` as mutable more than once at a time\n     drop(a);\n     let ref mut a @ ref mut b = U;\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n     drop(b);\n     let ref mut a @ ref mut b = U;\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n \n     let ref mut a @ ref mut b = U;\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n     //~| ERROR cannot borrow `_` as mutable more than once at a time\n     *a = U;\n     let ref mut a @ ref mut b = U;\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n     *b = U;\n \n     let ref mut a @ (\n-    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~^ ERROR cannot borrow value as mutable more than once at a time\n         ref mut b,\n         [\n             ref mut c,\n@@ -50,7 +54,7 @@ fn main() {\n     ) = (U, [U, U, U]);\n \n     let ref mut a @ (\n-        //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+        //~^ ERROR cannot borrow value as mutable more than once at a time\n             ref mut b,\n             [\n                 ref mut c,\n@@ -60,37 +64,37 @@ fn main() {\n         ) = (u(), [u(), u(), u()]);\n \n     let a @ (ref mut b, ref mut c) = (U, U);\n-    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~^ ERROR borrow of moved value\n     //~| ERROR borrow of moved value\n     let mut val = (U, [U, U]);\n     let a @ (b, [c, d]) = &mut val; // Same as ^--\n-    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~^ ERROR borrow of moved value\n     //~| ERROR borrow of moved value\n \n     let a @ &mut ref mut b = &mut U;\n-    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~^ ERROR borrow of moved value\n     //~| ERROR borrow of moved value\n     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n-    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~^ ERROR borrow of moved value\n     //~| ERROR borrow of moved value\n \n     match Ok(U) {\n         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-            //~^ ERROR cannot borrow `a` as mutable more than once at a time\n-            //~| ERROR cannot borrow `a` as mutable more than once at a time\n+            //~^ ERROR cannot borrow value as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n         }\n     }\n     match Ok(U) {\n         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-            //~^ ERROR cannot borrow `a` as mutable more than once at a time\n-            //~| ERROR cannot borrow `a` as mutable more than once at a time\n+            //~^ ERROR cannot borrow value as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n             *b = U;\n         }\n     }\n     match Ok(U) {\n         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-            //~^ ERROR cannot borrow `a` as mutable more than once at a time\n-            //~| ERROR cannot borrow `a` as mutable more than once at a time\n+            //~^ ERROR cannot borrow value as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n             //~| ERROR cannot borrow `_` as mutable more than once at a time\n             //~| ERROR cannot borrow `_` as mutable more than once at a time\n             *a = Err(U);\n@@ -101,8 +105,8 @@ fn main() {\n     }\n     match Ok(U) {\n         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-            //~^ ERROR cannot borrow `a` as mutable more than once at a time\n-            //~| ERROR cannot borrow `a` as mutable more than once at a time\n+            //~^ ERROR cannot borrow value as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n             //~| ERROR cannot borrow `_` as mutable more than once at a time\n             //~| ERROR cannot borrow `_` as mutable more than once at a time\n             drop(a);"}, {"sha": "4e96c6e1669c78369004dfdea9787415b4f3e483", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "modified", "additions": 144, "deletions": 105, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,226 +1,265 @@\n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:24:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:28:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |           another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:28:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:32:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |           another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:31:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:35:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |           another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:34:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:38:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |           another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:38:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:42:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |           another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:42:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:46:9\n    |\n LL |       let ref mut a @ (\n    |           ^--------\n    |           |\n-   |  _________first mutable borrow occurs here\n+   |  _________first mutable borrow, by `a`, occurs here\n    | |\n LL | |\n LL | |         ref mut b,\n-   | |         --------- another mutable borrow occurs here\n+   | |         --------- another mutable borrow, by `b`, occurs here\n LL | |         [\n LL | |             ref mut c,\n-   | |             --------- another mutable borrow occurs here\n+   | |             --------- another mutable borrow, by `c`, occurs here\n LL | |             ref mut d,\n-   | |             --------- another mutable borrow occurs here\n+   | |             --------- another mutable borrow, by `d`, occurs here\n LL | |             ref e,\n-   | |             ----- also borrowed as immutable here\n+   | |             ----- also borrowed as immutable, by `e`, here\n LL | |         ]\n LL | |     ) = (U, [U, U, U]);\n    | |_____^\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:52:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:56:9\n    |\n LL |       let ref mut a @ (\n    |           ^--------\n    |           |\n-   |  _________first mutable borrow occurs here\n+   |  _________first mutable borrow, by `a`, occurs here\n    | |\n LL | |\n LL | |             ref mut b,\n-   | |             --------- another mutable borrow occurs here\n+   | |             --------- another mutable borrow, by `b`, occurs here\n LL | |             [\n LL | |                 ref mut c,\n-   | |                 --------- another mutable borrow occurs here\n+   | |                 --------- another mutable borrow, by `c`, occurs here\n LL | |                 ref mut d,\n-   | |                 --------- another mutable borrow occurs here\n+   | |                 --------- another mutable borrow, by `d`, occurs here\n LL | |                 ref e,\n-   | |                 ----- also borrowed as immutable here\n+   | |                 ----- also borrowed as immutable, by `e`, here\n LL | |             ]\n LL | |         ) = (u(), [u(), u(), u()]);\n    | |_________^\n \n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:62:9\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:66:9\n    |\n LL |     let a @ (ref mut b, ref mut c) = (U, U);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:66:9\n+   |         -^^^^---------^^---------^\n+   |         |    |          |\n+   |         |    |          value borrowed here after move\n+   |         |    value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `(main::U, main::U)` which does implement the `Copy` trait\n+\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:70:9\n    |\n LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n-   |         ^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+   |         -^^^^-^^^-^^-^^\n+   |         |    |   |  |\n+   |         |    |   |  value borrowed here after move\n+   |         |    |   value borrowed here after move\n+   |         |    value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `&mut (main::U, [main::U; 2])` which does implement the `Copy` trait\n \n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:70:9\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:74:9\n    |\n LL |     let a @ &mut ref mut b = &mut U;\n-   |         ^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+   |         -^^^^^^^^---------\n+   |         |        |\n+   |         |        value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `&mut main::U` which does implement the `Copy` trait\n \n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:73:9\n+error: borrow of moved value\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:77:9\n    |\n LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+   |         -^^^^^^^^^---------^^---------^\n+   |         |         |          |\n+   |         |         |          value borrowed here after move\n+   |         |         value borrowed here after move\n+   |         value moved into `a` here\n+   |         move occurs because `a` has type `&mut (main::U, main::U)` which does implement the `Copy` trait\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:78:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:82:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n    |         |              |\n-   |         |              another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |              another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:78:37\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:82:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n    |                                     |               |\n-   |                                     |               another mutable borrow occurs here\n-   |                                     first mutable borrow occurs here\n+   |                                     |               another mutable borrow, by `b`, occurs here\n+   |                                     first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:84:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:88:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n    |         |              |\n-   |         |              another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |              another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:84:37\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:88:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n    |                                     |               |\n-   |                                     |               another mutable borrow occurs here\n-   |                                     first mutable borrow occurs here\n+   |                                     |               another mutable borrow, by `b`, occurs here\n+   |                                     first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:91:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:95:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n    |         |              |\n-   |         |              another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |              another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:91:37\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:95:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n    |                                     |               |\n-   |                                     |               another mutable borrow occurs here\n-   |                                     first mutable borrow occurs here\n+   |                                     |               another mutable borrow, by `b`, occurs here\n+   |                                     first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:103:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:107:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n    |         |              |\n-   |         |              another mutable borrow occurs here\n-   |         first mutable borrow occurs here\n+   |         |              another mutable borrow, by `b`, occurs here\n+   |         first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:103:37\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:107:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n    |                                     |               |\n-   |                                     |               another mutable borrow occurs here\n-   |                                     first mutable borrow occurs here\n+   |                                     |               another mutable borrow, by `b`, occurs here\n+   |                                     first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:10:11\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:11:11\n    |\n LL |     fn f1(ref mut a @ ref mut b: U) {}\n    |           ---------^^^---------\n    |           |           |\n-   |           |           another mutable borrow occurs here\n-   |           first mutable borrow occurs here\n+   |           |           another mutable borrow, by `b`, occurs here\n+   |           first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:12:11\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:13:11\n    |\n LL |     fn f2(ref mut a @ ref mut b: U) {}\n    |           ---------^^^---------\n    |           |           |\n-   |           |           another mutable borrow occurs here\n-   |           first mutable borrow occurs here\n+   |           |           another mutable borrow, by `b`, occurs here\n+   |           first mutable borrow, by `a`, occurs here\n \n-error: cannot borrow `a` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:15:9\n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:16:9\n    |\n LL |           ref mut a @ [\n    |           ^--------\n    |           |\n-   |  _________first mutable borrow occurs here\n+   |  _________first mutable borrow, by `a`, occurs here\n    | |\n LL | |\n LL | |             [ref b @ .., _],\n-   | |              ---------- also borrowed as immutable here\n+   | |              ---------- also borrowed as immutable, by `b`, here\n LL | |             [_, ref mut mid @ ..],\n-   | |                 ---------------- another mutable borrow occurs here\n+   | |                 ---------------- another mutable borrow, by `mid`, occurs here\n LL | |             ..,\n LL | |             [..],\n LL | |         ] : [[U; 4]; 5]\n    | |_________^\n \n+error: cannot borrow value as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:24:22\n+   |\n+LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n+   |                      ---------^^^-------------\n+   |                      |           |           |\n+   |                      |           |           also moved into `c` here\n+   |                      |           another mutable borrow, by `b`, occurs here\n+   |                      first mutable borrow, by `a`, occurs here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:24:34\n+   |\n+LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n+   |                                  ---------^^^-\n+   |                                  |           |\n+   |                                  |           value moved into `c` here\n+   |                                  value borrowed, by `b`, here\n+\n error[E0499]: cannot borrow `_` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:24:21\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:28:21\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ------------^^^^^^^^^\n@@ -232,7 +271,7 @@ LL |     drop(a);\n    |          - first borrow later used here\n \n error[E0499]: cannot borrow `_` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:34:21\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:38:21\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ------------^^^^^^^^^\n@@ -244,7 +283,7 @@ LL |     *a = U;\n    |     ------ first borrow later used here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:62:25\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:66:25\n    |\n LL |     let a @ (ref mut b, ref mut c) = (U, U);\n    |         ----------------^^^^^^^^^-   ------ move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n@@ -253,7 +292,7 @@ LL |     let a @ (ref mut b, ref mut c) = (U, U);\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:66:21\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:70:21\n    |\n LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n    |         ------------^--   -------- move occurs because value has type `&mut (main::U, [main::U; 2])`, which does not implement the `Copy` trait\n@@ -262,7 +301,7 @@ LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:70:18\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:74:18\n    |\n LL |     let a @ &mut ref mut b = &mut U;\n    |         ---------^^^^^^^^^   ------ move occurs because value has type `&mut main::U`, which does not implement the `Copy` trait\n@@ -271,7 +310,7 @@ LL |     let a @ &mut ref mut b = &mut U;\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:73:30\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:77:30\n    |\n LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         ---------------------^^^^^^^^^-   ----------- move occurs because value has type `&mut (main::U, main::U)`, which does not implement the `Copy` trait\n@@ -280,7 +319,7 @@ LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         value moved here\n \n error[E0499]: cannot borrow `_` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:91:24\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:95:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------------^^^^^^^^^-\n@@ -292,7 +331,7 @@ LL |             *a = Err(U);\n    |             ----------- first borrow later used here\n \n error[E0499]: cannot borrow `_` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:91:53\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:95:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ----------------^^^^^^^^^-\n@@ -304,7 +343,7 @@ LL |             *a = Err(U);\n    |             ----------- first borrow later used here\n \n error[E0499]: cannot borrow `_` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:103:24\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:107:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------------^^^^^^^^^-\n@@ -316,7 +355,7 @@ LL |             drop(a);\n    |                  - first borrow later used here\n \n error[E0499]: cannot borrow `_` as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:103:53\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:107:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ----------------^^^^^^^^^-\n@@ -327,7 +366,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n LL |             drop(a);\n    |                  - first borrow later used here\n \n-error: aborting due to 32 previous errors\n+error: aborting due to 34 previous errors\n \n-Some errors have detailed explanations: E0007, E0382, E0499.\n-For more information about an error, try `rustc --explain E0007`.\n+Some errors have detailed explanations: E0382, E0499.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "821d4b42962bf4cabce11ec47c50851a18423330", "filename": "src/test/ui/pattern/bindings-after-at/copy-and-move-mixed.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,6 +1,7 @@\n // Test that mixing `Copy` and non-`Copy` types in `@` patterns is forbidden.\n \n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n \n #[derive(Copy, Clone)]\n struct C;\n@@ -9,12 +10,9 @@ struct NC<A, B>(A, B);\n \n fn main() {\n     let a @ NC(b, c) = NC(C, C);\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n+    //~^ ERROR use of moved value\n \n     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n-    //~^ ERROR cannot bind by-move with sub-bindings\n-    //~| ERROR use of moved value\n-    //~| ERROR cannot bind by-move with sub-bindings\n+    //~^ ERROR use of moved value\n     //~| ERROR use of moved value\n }"}, {"sha": "7e89008a604969ed1b6d7d1d0b2b9675c2d6cbe5", "filename": "src/test/ui/pattern/bindings-after-at/copy-and-move-mixed.stderr", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,23 +1,5 @@\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/copy-and-move-mixed.rs:11:9\n-   |\n-LL |     let a @ NC(b, c) = NC(C, C);\n-   |         ^^^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/copy-and-move-mixed.rs:15:9\n-   |\n-LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/copy-and-move-mixed.rs:15:19\n-   |\n-LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n-   |                   ^^^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n error[E0382]: use of moved value\n-  --> $DIR/copy-and-move-mixed.rs:11:19\n+  --> $DIR/copy-and-move-mixed.rs:12:19\n    |\n LL |     let a @ NC(b, c) = NC(C, C);\n    |         ----------^-   -------- move occurs because value has type `NC<C, C>`, which does not implement the `Copy` trait\n@@ -45,7 +27,6 @@ LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n    |\n    = note: move occurs because value has type `NC<C, C>`, which does not implement the `Copy` trait\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0007, E0382.\n-For more information about an error, try `rustc --explain E0007`.\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "b40c3e3358aa317abf1e75a863a7f218d8999c1b", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -8,6 +8,7 @@\n // this would create problems for the generalization aforementioned.\n \n #![feature(bindings_after_at)]\n+#![feature(move_ref_pattern)]\n \n fn main() {\n     struct NotCopy;\n@@ -24,14 +25,26 @@ fn main() {\n     let ref a @ b = &NotCopy; // OK\n     let _: &&NotCopy = a;\n \n-    let ref a @ b = NotCopy; //~ ERROR cannot bind by-move and by-ref in the same pattern\n-    let ref mut a @ b = NotCopy; //~ ERROR cannot bind by-move and by-ref in the same pattern\n+    let ref a @ b = NotCopy; //~ ERROR cannot move out of value because it is borrowed\n+    let _a: &NotCopy = a;\n+    let _b: NotCopy = b;\n+    let ref mut a @ b = NotCopy; //~ ERROR cannot move out of value because it is borrowed\n+    //~^ ERROR cannot move out of `_` because it is borrowed\n+    let _a: &NotCopy = a;\n+    let _b: NotCopy = b;\n     match Ok(NotCopy) {\n-        Ok(ref a @ b) | Err(ref a @ b) => {}\n-        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n+        Ok(ref a @ b) | Err(b @ ref a) => {\n+            //~^ ERROR cannot move out of value because it is borrowed\n+            //~| ERROR borrow of moved value\n+            let _a: &NotCopy = a;\n+            let _b: NotCopy = b;\n+        }\n     }\n     match NotCopy {\n-        ref a @ b => {}\n-        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n+        ref a @ b => {\n+            //~^ ERROR cannot move out of value because it is borrowed\n+            let _a: &NotCopy = a;\n+            let _b: NotCopy = b;\n+        }\n     }\n }"}, {"sha": "697a8b96e6318a63134f4b9980773d5a7bacf1e7", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,41 +1,61 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:27:17\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:28:9\n    |\n LL |     let ref a @ b = NotCopy;\n-   |         --------^\n+   |         -----^^^-\n    |         |       |\n-   |         |       by-move pattern here\n-   |         by-ref pattern here\n+   |         |       value moved into `b` here\n+   |         value borrowed, by `a`, here\n \n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:28:21\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:31:9\n    |\n LL |     let ref mut a @ b = NotCopy;\n-   |         ------------^\n+   |         ---------^^^-\n    |         |           |\n-   |         |           by-move pattern here\n-   |         by-ref pattern here\n+   |         |           value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:36:12\n+   |\n+LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n+   |            -----^^^-\n+   |            |       |\n+   |            |       value moved into `b` here\n+   |            value borrowed, by `a`, here\n \n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:30:20\n+error: borrow of moved value\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:36:29\n    |\n-LL |         Ok(ref a @ b) | Err(ref a @ b) => {}\n-   |            --------^        --------^\n-   |            |       |        |       |\n-   |            |       |        |       by-move pattern here\n-   |            |       |        by-ref pattern here\n-   |            |       by-move pattern here\n-   |            by-ref pattern here\n+LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n+   |                             -^^^-----\n+   |                             |   |\n+   |                             |   value borrowed here after move\n+   |                             value moved into `b` here\n+   |                             move occurs because `b` has type `main::NotCopy` which does implement the `Copy` trait\n \n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:34:17\n+error: cannot move out of value because it is borrowed\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:44:9\n    |\n-LL |         ref a @ b => {}\n-   |         --------^\n+LL |         ref a @ b => {\n+   |         -----^^^-\n    |         |       |\n-   |         |       by-move pattern here\n-   |         by-ref pattern here\n+   |         |       value moved into `b` here\n+   |         value borrowed, by `a`, here\n+\n+error[E0505]: cannot move out of `_` because it is borrowed\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:31:21\n+   |\n+LL |     let ref mut a @ b = NotCopy;\n+   |         ------------^\n+   |         |           |\n+   |         |           move out of value occurs here\n+   |         borrow of value occurs here\n+LL |\n+LL |     let _a: &NotCopy = a;\n+   |                        - borrow later used here\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0009`.\n+For more information about this error, try `rustc --explain E0505`."}, {"sha": "d2d4e61e049b2c92a41adf120911ab45af55bde6", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern-pass.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern-pass.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+\n+#![feature(move_ref_pattern)]\n+\n+fn main() {}\n+\n+struct U;\n+\n+fn slice() {\n+    let mut arr = [U, U, U, U, U, U, U, U];\n+    let [ref _x0, _x1, _, mut _x3, .., ref _x6, _x7] = arr;\n+    _x3 = U;\n+    let [ref mut _x0, _, ref _x2, _, _x4, ref mut _x5, _x6, _] = arr;\n+    *_x5 = U;\n+    let [_, _, _x2, _, _, _x5, _, _] = arr;\n+    *_x0 = U;\n+    let [ref _x0, ..] = arr;\n+    let [_x0, ..] = arr;\n+}\n+\n+fn tuple() {\n+    let mut tup = (U, U, U, U, U);\n+    let (ref _x0, mut _x1, ref _x2, ..) = tup;\n+    _x1 = U;\n+    let (ref mut _x0, _, _, ref _x3, _x4) = tup;\n+    let (_, _, _, _x3, _) = tup;\n+    *_x0 = U;\n+    drop(_x2);\n+    drop(tup.2);\n+    let (_x0, _, _, ..) = tup;\n+}"}, {"sha": "3ee008fd84f094062cdfd7ec0122e5e81d2b46c6", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,50 @@\n+#![feature(move_ref_pattern)]\n+\n+fn main() {}\n+\n+struct U;\n+\n+fn slice() {\n+    let mut arr = [U, U, U, U, U];\n+    let hold_all = &arr;\n+    let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr; //~ ERROR cannot move out of `arr[..]`\n+    _x1 = U; //~ ERROR cannot assign twice to immutable variable `_x1`\n+    drop(hold_all);\n+    let [_x0, ..] = arr; //~ ERROR cannot move out of `arr[..]`\n+    drop(_x0_hold);\n+    let [_, _, ref mut _x2, _x3, mut _x4] = arr;\n+    //~^ ERROR cannot borrow `arr[..]` as mutable\n+    //~| ERROR cannot move out of `arr[..]` because it is borrowed\n+    //~| ERROR cannot move out of `arr[..]` because it is borrowed\n+    drop(xs_hold);\n+}\n+\n+fn tuple() {\n+    let mut tup = (U, U, U, U);\n+    let (ref _x0, _x1, ref _x2, ..) = tup;\n+    _x1 = U; //~ ERROR cannot assign twice to immutable variable\n+    let _x0_hold = &mut tup.0; //~ ERROR cannot borrow `tup.0` as mutable because it is also\n+    let (ref mut _x0_hold, ..) = tup; //~ ERROR cannot borrow `tup.0` as mutable because it is also\n+    *_x0 = U; //~ ERROR cannot assign to `*_x0` which is behind a `&` reference\n+    *_x2 = U; //~ ERROR cannot assign to `*_x2` which is behind a `&` reference\n+    drop(tup.1); //~ ERROR use of moved value: `tup.1`\n+    let _x1_hold = &tup.1; //~ ERROR borrow of moved value: `tup.1`\n+    let (.., ref mut _x3) = tup;\n+    let _x3_hold = &tup.3; //~ ERROR cannot borrow `tup.3` as immutable\n+    let _x3_hold = &mut tup.3; //~ ERROR cannot borrow `tup.3` as mutable more\n+    let (.., ref mut _x4_hold) = tup; //~ ERROR cannot borrow `tup.3` as mutable more\n+    let (.., ref _x4_hold) = tup; //~ ERROR cannot borrow `tup.3` as immutable\n+    drop(_x3);\n+}\n+\n+fn closure() {\n+    let mut tup = (U, U, U);\n+    let c1 = || {\n+        let (ref _x0, _x1, _) = tup;\n+    };\n+    let c2 = || {\n+        //~^ ERROR use of moved value\n+        let (ref mut _x0, _, _x2) = tup;\n+    };\n+    drop(c1);\n+}"}, {"sha": "d718ee29cf9b5241050b0061537bcf8dbb7c4575", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.stderr", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,208 @@\n+error[E0505]: cannot move out of `arr[..]` because it is borrowed\n+  --> $DIR/borrowck-move-ref-pattern.rs:10:24\n+   |\n+LL |     let hold_all = &arr;\n+   |                    ---- borrow of `arr` occurs here\n+LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n+   |                        ^^^ move out of `arr[..]` occurs here\n+LL |     _x1 = U;\n+LL |     drop(hold_all);\n+   |          -------- borrow later used here\n+\n+error[E0384]: cannot assign twice to immutable variable `_x1`\n+  --> $DIR/borrowck-move-ref-pattern.rs:11:5\n+   |\n+LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n+   |                        ---\n+   |                        |\n+   |                        first assignment to `_x1`\n+   |                        help: make this binding mutable: `mut _x1`\n+LL |     _x1 = U;\n+   |     ^^^^^^^ cannot assign twice to immutable variable\n+\n+error[E0505]: cannot move out of `arr[..]` because it is borrowed\n+  --> $DIR/borrowck-move-ref-pattern.rs:13:10\n+   |\n+LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n+   |          ------------ borrow of `arr[..]` occurs here\n+...\n+LL |     let [_x0, ..] = arr;\n+   |          ^^^ move out of `arr[..]` occurs here\n+LL |     drop(_x0_hold);\n+   |          -------- borrow later used here\n+\n+error[E0502]: cannot borrow `arr[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-move-ref-pattern.rs:15:16\n+   |\n+LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n+   |                             ---------------- immutable borrow occurs here\n+...\n+LL |     let [_, _, ref mut _x2, _x3, mut _x4] = arr;\n+   |                ^^^^^^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(xs_hold);\n+   |          ------- immutable borrow later used here\n+\n+error[E0505]: cannot move out of `arr[..]` because it is borrowed\n+  --> $DIR/borrowck-move-ref-pattern.rs:15:29\n+   |\n+LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n+   |                             ---------------- borrow of `arr[..]` occurs here\n+...\n+LL |     let [_, _, ref mut _x2, _x3, mut _x4] = arr;\n+   |                             ^^^ move out of `arr[..]` occurs here\n+...\n+LL |     drop(xs_hold);\n+   |          ------- borrow later used here\n+\n+error[E0505]: cannot move out of `arr[..]` because it is borrowed\n+  --> $DIR/borrowck-move-ref-pattern.rs:15:34\n+   |\n+LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n+   |                             ---------------- borrow of `arr[..]` occurs here\n+...\n+LL |     let [_, _, ref mut _x2, _x3, mut _x4] = arr;\n+   |                                  ^^^^^^^ move out of `arr[..]` occurs here\n+...\n+LL |     drop(xs_hold);\n+   |          ------- borrow later used here\n+\n+error[E0384]: cannot assign twice to immutable variable `_x1`\n+  --> $DIR/borrowck-move-ref-pattern.rs:25:5\n+   |\n+LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n+   |                   ---\n+   |                   |\n+   |                   first assignment to `_x1`\n+   |                   help: make this binding mutable: `mut _x1`\n+LL |     _x1 = U;\n+   |     ^^^^^^^ cannot assign twice to immutable variable\n+\n+error[E0502]: cannot borrow `tup.0` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-move-ref-pattern.rs:26:20\n+   |\n+LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n+   |          ------- immutable borrow occurs here\n+LL |     _x1 = U;\n+LL |     let _x0_hold = &mut tup.0;\n+   |                    ^^^^^^^^^^ mutable borrow occurs here\n+LL |     let (ref mut _x0_hold, ..) = tup;\n+LL |     *_x0 = U;\n+   |     -------- immutable borrow later used here\n+\n+error[E0502]: cannot borrow `tup.0` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-move-ref-pattern.rs:27:10\n+   |\n+LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n+   |          ------- immutable borrow occurs here\n+...\n+LL |     let (ref mut _x0_hold, ..) = tup;\n+   |          ^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     *_x0 = U;\n+   |     -------- immutable borrow later used here\n+\n+error[E0594]: cannot assign to `*_x0` which is behind a `&` reference\n+  --> $DIR/borrowck-move-ref-pattern.rs:28:5\n+   |\n+LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n+   |          ------- help: consider changing this to be a mutable reference: `ref mut _x0`\n+...\n+LL |     *_x0 = U;\n+   |     ^^^^^^^^ `_x0` is a `&` reference, so the data it refers to cannot be written\n+\n+error[E0594]: cannot assign to `*_x2` which is behind a `&` reference\n+  --> $DIR/borrowck-move-ref-pattern.rs:29:5\n+   |\n+LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n+   |                        ------- help: consider changing this to be a mutable reference: `ref mut _x2`\n+...\n+LL |     *_x2 = U;\n+   |     ^^^^^^^^ `_x2` is a `&` reference, so the data it refers to cannot be written\n+\n+error[E0382]: use of moved value: `tup.1`\n+  --> $DIR/borrowck-move-ref-pattern.rs:30:10\n+   |\n+LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n+   |                   --- value moved here\n+...\n+LL |     drop(tup.1);\n+   |          ^^^^^ value used here after move\n+   |\n+   = note: move occurs because `tup.1` has type `U`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `tup.1`\n+  --> $DIR/borrowck-move-ref-pattern.rs:31:20\n+   |\n+LL |     drop(tup.1);\n+   |          ----- value moved here\n+LL |     let _x1_hold = &tup.1;\n+   |                    ^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `tup.1` has type `U`, which does not implement the `Copy` trait\n+\n+error[E0502]: cannot borrow `tup.3` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-move-ref-pattern.rs:33:20\n+   |\n+LL |     let (.., ref mut _x3) = tup;\n+   |              ----------- mutable borrow occurs here\n+LL |     let _x3_hold = &tup.3;\n+   |                    ^^^^^^ immutable borrow occurs here\n+...\n+LL |     drop(_x3);\n+   |          --- mutable borrow later used here\n+\n+error[E0499]: cannot borrow `tup.3` as mutable more than once at a time\n+  --> $DIR/borrowck-move-ref-pattern.rs:34:20\n+   |\n+LL |     let (.., ref mut _x3) = tup;\n+   |              ----------- first mutable borrow occurs here\n+LL |     let _x3_hold = &tup.3;\n+LL |     let _x3_hold = &mut tup.3;\n+   |                    ^^^^^^^^^^ second mutable borrow occurs here\n+...\n+LL |     drop(_x3);\n+   |          --- first borrow later used here\n+\n+error[E0499]: cannot borrow `tup.3` as mutable more than once at a time\n+  --> $DIR/borrowck-move-ref-pattern.rs:35:14\n+   |\n+LL |     let (.., ref mut _x3) = tup;\n+   |              ----------- first mutable borrow occurs here\n+...\n+LL |     let (.., ref mut _x4_hold) = tup;\n+   |              ^^^^^^^^^^^^^^^^ second mutable borrow occurs here\n+LL |     let (.., ref _x4_hold) = tup;\n+LL |     drop(_x3);\n+   |          --- first borrow later used here\n+\n+error[E0502]: cannot borrow `tup.3` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-move-ref-pattern.rs:36:14\n+   |\n+LL |     let (.., ref mut _x3) = tup;\n+   |              ----------- mutable borrow occurs here\n+...\n+LL |     let (.., ref _x4_hold) = tup;\n+   |              ^^^^^^^^^^^^ immutable borrow occurs here\n+LL |     drop(_x3);\n+   |          --- mutable borrow later used here\n+\n+error[E0382]: use of moved value: `tup`\n+  --> $DIR/borrowck-move-ref-pattern.rs:45:14\n+   |\n+LL |     let mut tup = (U, U, U);\n+   |         ------- move occurs because `tup` has type `(U, U, U)`, which does not implement the `Copy` trait\n+LL |     let c1 = || {\n+   |              -- value moved into closure here\n+LL |         let (ref _x0, _x1, _) = tup;\n+   |                                 --- variable moved due to use in closure\n+LL |     };\n+LL |     let c2 = || {\n+   |              ^^ value used here after move\n+LL |\n+LL |         let (ref mut _x0, _, _x2) = tup;\n+   |                                     --- use occurs due to use in closure\n+\n+error: aborting due to 18 previous errors\n+\n+Some errors have detailed explanations: E0382, E0384, E0499, E0502, E0505, E0594.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "08fb5cd2e16883e28f2dccd7ebe6fdfbe6d48394", "filename": "src/test/ui/pattern/move-ref-patterns/by-move-sub-pat-unreachable.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fby-move-sub-pat-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fby-move-sub-pat-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fby-move-sub-pat-unreachable.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,15 @@\n+// When conflicts between by-move bindings in `by_move_1 @ has_by_move` patterns\n+// happen and that code is unreachable according to borrowck, we accept this code.\n+// In particular, we want to ensure here that an ICE does not happen, which it did originally.\n+\n+// check-pass\n+\n+#![feature(move_ref_pattern)]\n+#![feature(bindings_after_at)]\n+\n+fn main() {\n+    return;\n+\n+    struct S;\n+    let a @ (b, c) = (S, S);\n+}"}, {"sha": "fb92eb1ba32e0e74be8face458034dc4804ba961", "filename": "src/test/ui/pattern/move-ref-patterns/feature-gate-move_ref_pattern.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,23 @@\n+fn main() {\n+    #[derive(Clone)]\n+    struct X {\n+        x: (),\n+    }\n+    let mut tup = (X { x: () }, X { x: () });\n+    match Some(tup.clone()) {\n+        Some((y, ref z)) => {}\n+        //~^ ERROR binding by-move and by-ref in the same pattern is unstable\n+        None => panic!(),\n+    }\n+\n+    let (ref a, b) = tup.clone();\n+    //~^ ERROR binding by-move and by-ref in the same pattern is unstable\n+\n+    let (a, mut b) = &tup;\n+    //~^ ERROR binding by-move and by-ref in the same pattern is unstable\n+    //~| ERROR cannot move out of a shared reference\n+\n+    let (mut a, b) = &mut tup;\n+    //~^ ERROR binding by-move and by-ref in the same pattern is unstable\n+    //~| ERROR cannot move out of a mutable reference\n+}"}, {"sha": "8aef220c375191d12f2f5605de1d302412e92280", "filename": "src/test/ui/pattern/move-ref-patterns/feature-gate-move_ref_pattern.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,66 @@\n+error[E0658]: binding by-move and by-ref in the same pattern is unstable\n+  --> $DIR/feature-gate-move_ref_pattern.rs:8:15\n+   |\n+LL |         Some((y, ref z)) => {}\n+   |               ^  ----- by-ref pattern here\n+   |               |\n+   |               by-move pattern here\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/68354\n+   = help: add `#![feature(move_ref_pattern)]` to the crate attributes to enable\n+\n+error[E0658]: binding by-move and by-ref in the same pattern is unstable\n+  --> $DIR/feature-gate-move_ref_pattern.rs:13:17\n+   |\n+LL |     let (ref a, b) = tup.clone();\n+   |          -----  ^ by-move pattern here\n+   |          |\n+   |          by-ref pattern here\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/68354\n+   = help: add `#![feature(move_ref_pattern)]` to the crate attributes to enable\n+\n+error[E0658]: binding by-move and by-ref in the same pattern is unstable\n+  --> $DIR/feature-gate-move_ref_pattern.rs:16:13\n+   |\n+LL |     let (a, mut b) = &tup;\n+   |          -  ^^^^^ by-move pattern here\n+   |          |\n+   |          by-ref pattern here\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/68354\n+   = help: add `#![feature(move_ref_pattern)]` to the crate attributes to enable\n+\n+error[E0658]: binding by-move and by-ref in the same pattern is unstable\n+  --> $DIR/feature-gate-move_ref_pattern.rs:20:10\n+   |\n+LL |     let (mut a, b) = &mut tup;\n+   |          ^^^^^  - by-ref pattern here\n+   |          |\n+   |          by-move pattern here\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/68354\n+   = help: add `#![feature(move_ref_pattern)]` to the crate attributes to enable\n+\n+error[E0507]: cannot move out of a shared reference\n+  --> $DIR/feature-gate-move_ref_pattern.rs:16:22\n+   |\n+LL |     let (a, mut b) = &tup;\n+   |             -----    ^^^^\n+   |             |\n+   |             data moved here\n+   |             move occurs because `b` has type `main::X`, which does not implement the `Copy` trait\n+\n+error[E0507]: cannot move out of a mutable reference\n+  --> $DIR/feature-gate-move_ref_pattern.rs:20:22\n+   |\n+LL |     let (mut a, b) = &mut tup;\n+   |          -----       ^^^^^^^^\n+   |          |\n+   |          data moved here\n+   |          move occurs because `a` has type `main::X`, which does not implement the `Copy` trait\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0507, E0658.\n+For more information about an error, try `rustc --explain E0507`."}, {"sha": "ab7d10d9f837d716addeab828090898e5526e0bc", "filename": "src/test/ui/pattern/move-ref-patterns/issue-53840.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fissue-53840.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fissue-53840.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fissue-53840.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,3 +1,7 @@\n+// check-pass\n+\n+#![feature(move_ref_pattern)]\n+\n enum E {\n     Foo(String, String, String),\n }\n@@ -11,10 +15,8 @@ fn main() {\n     let bar = Bar { a: \"1\".to_string(), b: \"2\".to_string() };\n     match E::Foo(\"\".into(), \"\".into(), \"\".into()) {\n         E::Foo(a, b, ref c) => {}\n-//~^ ERROR cannot bind by-move and by-ref in the same pattern\n     }\n     match bar {\n-        Bar {a, ref b} => {}\n-//~^ ERROR cannot bind by-move and by-ref in the same pattern\n+        Bar { a, ref b } => {}\n     }\n }", "previous_filename": "src/test/ui/issues/issue-53840.rs"}, {"sha": "4c3ca62e1658697ce12de9942b897d9f27cf7dc9", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures-inside.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,122 @@\n+#![feature(move_ref_pattern)]\n+\n+fn main() {\n+    struct S; // Not `Copy`.\n+\n+    let mut tup0 = (S, S);\n+    let mut tup1 = (S, S, S);\n+    let tup2 = (S, S);\n+    let tup3 = (S, S, S);\n+    let tup4 = (S, S);\n+    let mut arr0 = [S, S, S];\n+    let mut arr1 = [S, S, S, S, S];\n+    let arr2 = [S, S, S];\n+    let arr3 = [S, S, S, S, S];\n+\n+    // The `mov` bindings require that we capture the scrutinees by-move.\n+    let mut closure = || {\n+        // Tuples...\n+        let (ref mut borrow, mov) = tup0;\n+        let (mov, _, ref mut borrow) = tup1;\n+        let (ref borrow, mov) = tup2;\n+        let (mov, _, ref borrow) = tup3;\n+        let (ref borrow, mov) = tup4;\n+        // Arrays...\n+        let [mov @ .., ref borrow] = arr0;\n+        let [_, ref mut borrow @ .., _, mov] = arr1;\n+        let [mov @ .., ref borrow] = arr2;\n+        let [_, ref borrow @ .., _, mov] = arr3;\n+    };\n+\n+    // Now we try to borrow and move the captures, which should result in errors...\n+    // ...for tuples:\n+    drop(&tup0); //~ ERROR borrow of moved value: `tup0`\n+    drop(&tup1); //~ ERROR borrow of moved value: `tup1`\n+    drop(&tup2); //~ ERROR borrow of moved value: `tup2`\n+    drop(&tup3); //~ ERROR borrow of moved value: `tup3`\n+    // Ostensibly this should compile.\n+    // However, because closures don't capture individual fields, which is changed in RFC 2229,\n+    // this won't compile because the entire product is moved into the closure.\n+    // The same applies to the array patterns below.\n+    drop(&tup4.0); //~ ERROR borrow of moved value: `tup4`\n+    // ...for arrays:\n+    drop(&arr0); //~ ERROR borrow of moved value: `arr0`\n+    let [_, mov1, mov2, mov3, _] = &arr1; //~ ERROR borrow of moved value: `arr1`\n+    drop(&arr2); //~ ERROR borrow of moved value: `arr2`\n+    let [_, mov1, mov2, mov3, _] = &arr3; //~ ERROR borrow of moved value: `arr3`\n+\n+    // Let's redo ^--- with a `match` + sum type:\n+    macro_rules! m {\n+        ($p:pat = $s:expr) => {\n+            match $s {\n+                Some($p) => {}\n+                _ => {}\n+            }\n+        };\n+    }\n+    let mut tup0: Option<(S, S)> = None;\n+    let mut tup1: Option<(S, S, S)> = None;\n+    let tup2: Option<(S, S)> = None;\n+    let tup3: Option<(S, S, S)> = None;\n+    let tup4: Option<(S, S)> = None;\n+    let mut arr0: Option<[S; 3]> = None;\n+    let mut arr1: Option<[S; 5]> = None;\n+    let arr2: Option<[S; 3]> = None;\n+    let arr3: Option<[S; 5]> = None;\n+    let mut closure = || {\n+        m!((ref mut borrow, mov) = tup0);\n+        m!((mov, _, ref mut borrow) = tup1);\n+        m!((ref borrow, mov) = tup2);\n+        m!((mov, _, ref borrow) = tup3);\n+        m!((ref borrow, mov) = tup4);\n+        m!([mov @ .., ref borrow] = arr0);\n+        m!([_, ref mut borrow @ .., _, mov] = arr1);\n+        m!([mov @ .., ref borrow] = arr2);\n+        m!([_, ref borrow @ .., _, mov] = arr3);\n+    };\n+    drop(&tup0); //~ ERROR borrow of moved value: `tup0`\n+    drop(&tup1); //~ ERROR borrow of moved value: `tup1`\n+    drop(&tup2); //~ ERROR borrow of moved value: `tup2`\n+    drop(&tup3); //~ ERROR borrow of moved value: `tup3`\n+    m!((ref x, _) = &tup4); //~ ERROR borrow of moved value: `tup4`\n+    drop(&arr0); //~ ERROR borrow of moved value: `arr0`\n+    m!([_, mov1, mov2, mov3, _] = &arr1); //~ ERROR borrow of moved value: `arr1`\n+    drop(&arr2); //~ ERROR borrow of moved value: `arr2`\n+    m!([_, mov1, mov2, mov3, _] = &arr3); //~ ERROR borrow of moved value: `arr3`\n+\n+    // Let's redo ^--- with `if let` (which may diverge from `match` in the future):\n+    macro_rules! m {\n+        ($p:pat = $s:expr) => {\n+            if let Some($p) = $s {}\n+        };\n+    }\n+    let mut tup0: Option<(S, S)> = None;\n+    let mut tup1: Option<(S, S, S)> = None;\n+    let tup2: Option<(S, S)> = None;\n+    let tup3: Option<(S, S, S)> = None;\n+    let tup4: Option<(S, S)> = None;\n+    let mut arr0: Option<[S; 3]> = None;\n+    let mut arr1: Option<[S; 5]> = None;\n+    let arr2: Option<[S; 3]> = None;\n+    let arr3: Option<[S; 5]> = None;\n+    let mut closure = || {\n+        m!((ref mut borrow, mov) = tup0);\n+        m!((mov, _, ref mut borrow) = tup1);\n+        m!((ref borrow, mov) = tup2);\n+        m!((mov, _, ref borrow) = tup3);\n+        m!((ref borrow, mov) = tup4);\n+        m!([mov @ .., ref borrow] = arr0);\n+        m!([_, ref mut borrow @ .., _, mov] = arr1);\n+        m!([mov @ .., ref borrow] = arr2);\n+        m!([_, ref borrow @ .., _, mov] = arr3);\n+    };\n+    drop(&tup0); //~ ERROR borrow of moved value: `tup0`\n+    drop(&tup1); //~ ERROR borrow of moved value: `tup1`\n+    drop(&tup2); //~ ERROR borrow of moved value: `tup2`\n+    drop(&tup3); //~ ERROR borrow of moved value: `tup3`\n+    m!((ref x, _) = &tup4); //~ ERROR borrow of moved value: `tup4`\n+    drop(&arr0); //~ ERROR borrow of moved value: `arr0`\n+    m!([_, mov1, mov2, mov3, _] = &arr1); //~ ERROR borrow of moved value: `arr1`\n+    drop(&arr2); //~ ERROR borrow of moved value: `arr2`\n+    m!([_, mov1, mov2, mov3, _] = &arr3); //~ ERROR borrow of moved value: `arr3`\n+}"}, {"sha": "9159e3e221349a58c22a527dd6af7cf38e5ddce8", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures-inside.stderr", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,404 @@\n+error[E0382]: borrow of moved value: `tup0`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:33:10\n+   |\n+LL |     let mut tup0 = (S, S);\n+   |         -------- move occurs because `tup0` has type `(main::S, main::S)`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+LL |         // Tuples...\n+LL |         let (ref mut borrow, mov) = tup0;\n+   |                                     ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup0);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup1`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:34:10\n+   |\n+LL |     let mut tup1 = (S, S, S);\n+   |         -------- move occurs because `tup1` has type `(main::S, main::S, main::S)`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         let (mov, _, ref mut borrow) = tup1;\n+   |                                        ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup1);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup2`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:35:10\n+   |\n+LL |     let tup2 = (S, S);\n+   |         ---- move occurs because `tup2` has type `(main::S, main::S)`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         let (ref borrow, mov) = tup2;\n+   |                                 ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup2);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup3`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:36:10\n+   |\n+LL |     let tup3 = (S, S, S);\n+   |         ---- move occurs because `tup3` has type `(main::S, main::S, main::S)`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         let (mov, _, ref borrow) = tup3;\n+   |                                    ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup3);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup4`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:41:10\n+   |\n+LL |     let tup4 = (S, S);\n+   |         ---- move occurs because `tup4` has type `(main::S, main::S)`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         let (ref borrow, mov) = tup4;\n+   |                                 ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup4.0);\n+   |          ^^^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr0`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:43:10\n+   |\n+LL |     let mut arr0 = [S, S, S];\n+   |         -------- move occurs because `arr0` has type `[main::S; 3]`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         let [mov @ .., ref borrow] = arr0;\n+   |                                      ---- variable moved due to use in closure\n+...\n+LL |     drop(&arr0);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr1`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:44:36\n+   |\n+LL |     let mut arr1 = [S, S, S, S, S];\n+   |         -------- move occurs because `arr1` has type `[main::S; 5]`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         let [_, ref mut borrow @ .., _, mov] = arr1;\n+   |                                                ---- variable moved due to use in closure\n+...\n+LL |     let [_, mov1, mov2, mov3, _] = &arr1;\n+   |                                    ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr2`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:45:10\n+   |\n+LL |     let arr2 = [S, S, S];\n+   |         ---- move occurs because `arr2` has type `[main::S; 3]`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         let [mov @ .., ref borrow] = arr2;\n+   |                                      ---- variable moved due to use in closure\n+...\n+LL |     drop(&arr2);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr3`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:46:36\n+   |\n+LL |     let arr3 = [S, S, S, S, S];\n+   |         ---- move occurs because `arr3` has type `[main::S; 5]`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         let [_, ref borrow @ .., _, mov] = arr3;\n+   |                                            ---- variable moved due to use in closure\n+...\n+LL |     let [_, mov1, mov2, mov3, _] = &arr3;\n+   |                                    ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup0`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:77:10\n+   |\n+LL |     let mut tup0: Option<(S, S)> = None;\n+   |         -------- move occurs because `tup0` has type `std::option::Option<(main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+LL |         m!((ref mut borrow, mov) = tup0);\n+   |                                    ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup0);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup1`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:78:10\n+   |\n+LL |     let mut tup1: Option<(S, S, S)> = None;\n+   |         -------- move occurs because `tup1` has type `std::option::Option<(main::S, main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+LL |         m!((ref mut borrow, mov) = tup0);\n+LL |         m!((mov, _, ref mut borrow) = tup1);\n+   |                                       ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup1);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup2`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:79:10\n+   |\n+LL |     let tup2: Option<(S, S)> = None;\n+   |         ---- move occurs because `tup2` has type `std::option::Option<(main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!((ref borrow, mov) = tup2);\n+   |                                ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup2);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup3`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:80:10\n+   |\n+LL |     let tup3: Option<(S, S, S)> = None;\n+   |         ---- move occurs because `tup3` has type `std::option::Option<(main::S, main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!((mov, _, ref borrow) = tup3);\n+   |                                   ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup3);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup4`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:81:21\n+   |\n+LL |     let tup4: Option<(S, S)> = None;\n+   |         ---- move occurs because `tup4` has type `std::option::Option<(main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!((ref borrow, mov) = tup4);\n+   |                                ---- variable moved due to use in closure\n+...\n+LL |     m!((ref x, _) = &tup4);\n+   |                     ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr0`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:82:10\n+   |\n+LL |     let mut arr0: Option<[S; 3]> = None;\n+   |         -------- move occurs because `arr0` has type `std::option::Option<[main::S; 3]>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!([mov @ .., ref borrow] = arr0);\n+   |                                     ---- variable moved due to use in closure\n+...\n+LL |     drop(&arr0);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr1`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:83:35\n+   |\n+LL |     let mut arr1: Option<[S; 5]> = None;\n+   |         -------- move occurs because `arr1` has type `std::option::Option<[main::S; 5]>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!([_, ref mut borrow @ .., _, mov] = arr1);\n+   |                                               ---- variable moved due to use in closure\n+...\n+LL |     m!([_, mov1, mov2, mov3, _] = &arr1);\n+   |                                   ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr2`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:84:10\n+   |\n+LL |     let arr2: Option<[S; 3]> = None;\n+   |         ---- move occurs because `arr2` has type `std::option::Option<[main::S; 3]>`, which does not implement the `Copy` trait\n+LL |     let arr3: Option<[S; 5]> = None;\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!([mov @ .., ref borrow] = arr2);\n+   |                                     ---- variable moved due to use in closure\n+...\n+LL |     drop(&arr2);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr3`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:85:35\n+   |\n+LL |     let arr3: Option<[S; 5]> = None;\n+   |         ---- move occurs because `arr3` has type `std::option::Option<[main::S; 5]>`, which does not implement the `Copy` trait\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!([_, ref borrow @ .., _, mov] = arr3);\n+   |                                           ---- variable moved due to use in closure\n+...\n+LL |     m!([_, mov1, mov2, mov3, _] = &arr3);\n+   |                                   ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup0`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:113:10\n+   |\n+LL |     let mut tup0: Option<(S, S)> = None;\n+   |         -------- move occurs because `tup0` has type `std::option::Option<(main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+LL |         m!((ref mut borrow, mov) = tup0);\n+   |                                    ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup0);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup1`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:114:10\n+   |\n+LL |     let mut tup1: Option<(S, S, S)> = None;\n+   |         -------- move occurs because `tup1` has type `std::option::Option<(main::S, main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+LL |         m!((ref mut borrow, mov) = tup0);\n+LL |         m!((mov, _, ref mut borrow) = tup1);\n+   |                                       ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup1);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup2`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:115:10\n+   |\n+LL |     let tup2: Option<(S, S)> = None;\n+   |         ---- move occurs because `tup2` has type `std::option::Option<(main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!((ref borrow, mov) = tup2);\n+   |                                ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup2);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup3`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:116:10\n+   |\n+LL |     let tup3: Option<(S, S, S)> = None;\n+   |         ---- move occurs because `tup3` has type `std::option::Option<(main::S, main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!((mov, _, ref borrow) = tup3);\n+   |                                   ---- variable moved due to use in closure\n+...\n+LL |     drop(&tup3);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `tup4`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:117:21\n+   |\n+LL |     let tup4: Option<(S, S)> = None;\n+   |         ---- move occurs because `tup4` has type `std::option::Option<(main::S, main::S)>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!((ref borrow, mov) = tup4);\n+   |                                ---- variable moved due to use in closure\n+...\n+LL |     m!((ref x, _) = &tup4);\n+   |                     ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr0`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:118:10\n+   |\n+LL |     let mut arr0: Option<[S; 3]> = None;\n+   |         -------- move occurs because `arr0` has type `std::option::Option<[main::S; 3]>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!([mov @ .., ref borrow] = arr0);\n+   |                                     ---- variable moved due to use in closure\n+...\n+LL |     drop(&arr0);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr1`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:119:35\n+   |\n+LL |     let mut arr1: Option<[S; 5]> = None;\n+   |         -------- move occurs because `arr1` has type `std::option::Option<[main::S; 5]>`, which does not implement the `Copy` trait\n+...\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!([_, ref mut borrow @ .., _, mov] = arr1);\n+   |                                               ---- variable moved due to use in closure\n+...\n+LL |     m!([_, mov1, mov2, mov3, _] = &arr1);\n+   |                                   ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr2`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:120:10\n+   |\n+LL |     let arr2: Option<[S; 3]> = None;\n+   |         ---- move occurs because `arr2` has type `std::option::Option<[main::S; 3]>`, which does not implement the `Copy` trait\n+LL |     let arr3: Option<[S; 5]> = None;\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!([mov @ .., ref borrow] = arr2);\n+   |                                     ---- variable moved due to use in closure\n+...\n+LL |     drop(&arr2);\n+   |          ^^^^^ value borrowed here after move\n+\n+error[E0382]: borrow of moved value: `arr3`\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:121:35\n+   |\n+LL |     let arr3: Option<[S; 5]> = None;\n+   |         ---- move occurs because `arr3` has type `std::option::Option<[main::S; 5]>`, which does not implement the `Copy` trait\n+LL |     let mut closure = || {\n+   |                       -- value moved into closure here\n+...\n+LL |         m!([_, ref borrow @ .., _, mov] = arr3);\n+   |                                           ---- variable moved due to use in closure\n+...\n+LL |     m!([_, mov1, mov2, mov3, _] = &arr3);\n+   |                                   ^^^^^ value borrowed here after move\n+\n+error: aborting due to 27 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "e1844d36e4aa47c431e5704f187e175986ac4f06", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures-pass.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-pass.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+\n+#![feature(move_ref_pattern)]\n+\n+fn main() {\n+    struct U;\n+    fn accept_fn_once(_: impl FnOnce()) {}\n+    fn accept_fn_mut(_: impl FnMut()) {}\n+    fn accept_fn(_: impl Fn()) {}\n+\n+    let mut tup = (U, U, U);\n+    let (ref _x0, _x1, ref mut _x2) = tup;\n+    let c1 = || {\n+        drop::<&U>(_x0);\n+        drop::<U>(_x1);\n+        drop::<&mut U>(_x2);\n+    };\n+    accept_fn_once(c1);\n+\n+    let c2 = || {\n+        drop::<&U>(_x0);\n+        drop::<&mut U>(_x2);\n+    };\n+    accept_fn_mut(c2);\n+\n+    let c3 = || {\n+        drop::<&U>(_x0);\n+    };\n+    accept_fn(c3);\n+}"}, {"sha": "7f1c02c05cb0d287084d143455ba9046c43daada", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,34 @@\n+#![feature(move_ref_pattern)]\n+\n+fn main() {\n+    struct U;\n+    fn accept_fn_once(_: &impl FnOnce()) {}\n+    fn accept_fn_mut(_: &impl FnMut()) {}\n+    fn accept_fn(_: &impl Fn()) {}\n+\n+    let mut tup = (U, U, U);\n+    let (ref _x0, _x1, ref mut _x2) = tup;\n+    let c1 = || {\n+        //~^ ERROR expected a closure that implements the `FnMut`\n+        //~| ERROR expected a closure that implements the `Fn`\n+        drop::<&U>(_x0);\n+        drop::<U>(_x1);\n+        drop::<&mut U>(_x2);\n+    };\n+    accept_fn_once(&c1);\n+    accept_fn_mut(&c1);\n+    accept_fn(&c1);\n+\n+    let c2 = || {\n+        //~^ ERROR expected a closure that implements the `Fn`\n+        drop::<&U>(_x0);\n+        drop::<&mut U>(_x2);\n+    };\n+    accept_fn_mut(&c2);\n+    accept_fn(&c2);\n+\n+    let c3 = || {\n+        drop::<&U>(_x0);\n+    };\n+    accept_fn(&c3);\n+}"}, {"sha": "ca82353c1c9ab9d42724e31febfbb8abde4af5ee", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,39 @@\n+error[E0525]: expected a closure that implements the `FnMut` trait, but this closure only implements `FnOnce`\n+  --> $DIR/move-ref-patterns-closure-captures.rs:11:14\n+   |\n+LL |     let c1 = || {\n+   |              ^^ this closure implements `FnOnce`, not `FnMut`\n+...\n+LL |         drop::<U>(_x1);\n+   |                   --- closure is `FnOnce` because it moves the variable `_x1` out of its environment\n+...\n+LL |     accept_fn_mut(&c1);\n+   |     ------------- the requirement to implement `FnMut` derives from here\n+\n+error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnOnce`\n+  --> $DIR/move-ref-patterns-closure-captures.rs:11:14\n+   |\n+LL |     let c1 = || {\n+   |              ^^ this closure implements `FnOnce`, not `Fn`\n+...\n+LL |         drop::<U>(_x1);\n+   |                   --- closure is `FnOnce` because it moves the variable `_x1` out of its environment\n+...\n+LL |     accept_fn(&c1);\n+   |     --------- the requirement to implement `Fn` derives from here\n+\n+error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnMut`\n+  --> $DIR/move-ref-patterns-closure-captures.rs:22:14\n+   |\n+LL |     let c2 = || {\n+   |              ^^ this closure implements `FnMut`, not `Fn`\n+...\n+LL |         drop::<&mut U>(_x2);\n+   |                        --- closure is `FnMut` because it mutates the variable `_x2` here\n+...\n+LL |     accept_fn(&c2);\n+   |     --------- the requirement to implement `Fn` derives from here\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0525`."}, {"sha": "5c51c47d9798a1514e9eb27c21783595ac91b4a8", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,16 @@\n+#![feature(move_ref_pattern)]\n+\n+fn main() {\n+    struct U;\n+\n+    // A tuple is a \"non-reference pattern\".\n+    // A `mut` binding pattern resets the binding mode to by-value.\n+\n+    let p = (U, U);\n+    let (a, mut b) = &p;\n+    //~^ ERROR cannot move out of a shared reference\n+\n+    let mut p = (U, U);\n+    let (a, mut b) = &mut p;\n+    //~^ ERROR cannot move out of a mutable reference\n+}"}, {"sha": "fe7f71e6c46cdfb825b02a765d11c3d93e0df630", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,21 @@\n+error[E0507]: cannot move out of a shared reference\n+  --> $DIR/move-ref-patterns-default-binding-modes.rs:10:22\n+   |\n+LL |     let (a, mut b) = &p;\n+   |             -----    ^^\n+   |             |\n+   |             data moved here\n+   |             move occurs because `b` has type `main::U`, which does not implement the `Copy` trait\n+\n+error[E0507]: cannot move out of a mutable reference\n+  --> $DIR/move-ref-patterns-default-binding-modes.rs:14:22\n+   |\n+LL |     let (a, mut b) = &mut p;\n+   |             -----    ^^^^^^\n+   |             |\n+   |             data moved here\n+   |             move occurs because `b` has type `main::U`, which does not implement the `Copy` trait\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0507`."}, {"sha": "c78695390b59828bdb9deb4c3e8ffc6e3a74cbda", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-dynamic-semantics.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-dynamic-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-dynamic-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-dynamic-semantics.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -0,0 +1,81 @@\n+// run-pass\n+\n+// This test checks the dynamic semantics and drop order of pattern matching\n+// where a product pattern has both a by-move and by-ref binding.\n+\n+#![feature(move_ref_pattern)]\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+struct X {\n+    x: Box<usize>,\n+    d: DropOrderListPtr,\n+}\n+\n+type DropOrderListPtr = Rc<RefCell<Vec<usize>>>;\n+\n+impl Drop for X {\n+    fn drop(&mut self) {\n+        self.d.borrow_mut().push(*self.x);\n+    }\n+}\n+\n+enum DoubleOption<T, U> {\n+    Some2(T, U),\n+    _None2,\n+}\n+\n+fn main() {\n+    let d: DropOrderListPtr = <_>::default();\n+    {\n+        let mk = |v| X { x: Box::new(v), d: d.clone() };\n+        let check = |a1: &X, a2, b1: &X, b2| {\n+            assert_eq!(*a1.x, a2);\n+            assert_eq!(*b1.x, b2);\n+        };\n+\n+        let x = DoubleOption::Some2(mk(1), mk(2));\n+        match x {\n+            DoubleOption::Some2(ref a, b) => check(a, 1, &b, 2),\n+            DoubleOption::_None2 => panic!(),\n+        }\n+        let x = DoubleOption::Some2(mk(3), mk(4));\n+        match x {\n+            DoubleOption::Some2(a, ref b) => check(&a, 3, b, 4),\n+            DoubleOption::_None2 => panic!(),\n+        }\n+        match DoubleOption::Some2(mk(5), mk(6)) {\n+            DoubleOption::Some2(ref a, b) => check(a, 5, &b, 6),\n+            DoubleOption::_None2 => panic!(),\n+        }\n+        match DoubleOption::Some2(mk(7), mk(8)) {\n+            DoubleOption::Some2(a, ref b) => check(&a, 7, b, 8),\n+            DoubleOption::_None2 => panic!(),\n+        }\n+        {\n+            let (a, ref b) = (mk(9), mk(10));\n+            let (ref c, d) = (mk(11), mk(12));\n+            check(&a, 9, b, 10);\n+            check(c, 11, &d, 12);\n+        }\n+        fn fun([a, ref mut b, ref xs @ .., ref c, d]: [X; 6]) {\n+            assert_eq!(*a.x, 13);\n+            assert_eq!(*b.x, 14);\n+            assert_eq!(&[*xs[0].x, *xs[1].x], &[15, 16]);\n+            assert_eq!(*c.x, 17);\n+            assert_eq!(*d.x, 18);\n+        }\n+        fun([mk(13), mk(14), mk(15), mk(16), mk(17), mk(18)]);\n+\n+        let lam = |(a, ref b, c, ref mut d): (X, X, X, X)| {\n+            assert_eq!(*a.x, 19);\n+            assert_eq!(*b.x, 20);\n+            assert_eq!(*c.x, 21);\n+            assert_eq!(*d.x, 22);\n+        };\n+        lam((mk(19), mk(20), mk(21), mk(22)));\n+    }\n+    let expected = [2, 3, 6, 5, 7, 8, 12, 11, 9, 10, 18, 13, 14, 15, 16, 17, 21, 19, 20, 22, 4, 1];\n+    assert_eq!(&*d.borrow(), &expected);\n+}"}, {"sha": "84552f2e7331580a306292e947c733dadbf775b9", "filename": "src/test/ui/pattern/rest-pat-semantic-disallowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -2,7 +2,7 @@\n // outside of slice (+ ident patterns witin those), tuple,\n // and tuple struct patterns and that duplicates are caught in these contexts.\n \n-#![feature(slice_patterns, box_patterns)]\n+#![feature(box_patterns)]\n \n fn main() {}\n "}, {"sha": "aa42c7bb9c2f1368dffeb1bb1f0ea8fe9965190e", "filename": "src/test/ui/rfc-2005-default-binding-mode/for.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,10 +1,11 @@\n+#![feature(move_ref_pattern)]\n+\n struct Foo {}\n \n pub fn main() {\n-    let mut tups = vec![(Foo{}, Foo{})];\n+    let mut tups = vec![(Foo {}, Foo {})];\n     // The below desugars to &(ref n, mut m).\n     for (n, mut m) in &tups {\n-        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n-        //~| ERROR cannot move out of a shared reference\n+        //~^ ERROR cannot move out of a shared reference\n     }\n }"}, {"sha": "ef62431388081f478924fd19afe9427f28c235ba", "filename": "src/test/ui/rfc-2005-default-binding-mode/for.stderr", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d830b4decaef5a6ae0f27baac14dfb48baa4c5/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr?ref=f8d830b4decaef5a6ae0f27baac14dfb48baa4c5", "patch": "@@ -1,21 +1,12 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/for.rs:6:13\n-   |\n-LL |     for (n, mut m) in &tups {\n-   |          -  ^^^^^ by-move pattern here\n-   |          |\n-   |          by-ref pattern here\n-\n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/for.rs:6:23\n+  --> $DIR/for.rs:8:23\n    |\n LL |     for (n, mut m) in &tups {\n    |             -----     ^^^^^\n    |             |\n    |             data moved here\n    |             move occurs because `m` has type `Foo`, which does not implement the `Copy` trait\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0009, E0507.\n-For more information about an error, try `rustc --explain E0009`.\n+For more information about this error, try `rustc --explain E0507`."}]}