{"sha": "25b152397d66144230c2d8374e17150fc79a24f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YjE1MjM5N2Q2NjE0NDIzMGMyZDgzNzRlMTcxNTBmYzc5YTI0Zjc=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-10T01:03:37Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-10T22:12:12Z"}, "message": "Clean up the tydesc handling code in trans.", "tree": {"sha": "45cf01e08fcaf260ebd3a4fd9965ae1c2e64c167", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45cf01e08fcaf260ebd3a4fd9965ae1c2e64c167"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25b152397d66144230c2d8374e17150fc79a24f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25b152397d66144230c2d8374e17150fc79a24f7", "html_url": "https://github.com/rust-lang/rust/commit/25b152397d66144230c2d8374e17150fc79a24f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25b152397d66144230c2d8374e17150fc79a24f7/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccee8cb4f9a3efd9aaf30e8bf7151676dfd60d34", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccee8cb4f9a3efd9aaf30e8bf7151676dfd60d34", "html_url": "https://github.com/rust-lang/rust/commit/ccee8cb4f9a3efd9aaf30e8bf7151676dfd60d34"}], "stats": {"total": 199, "additions": 80, "deletions": 119}, "files": [{"sha": "b8e3c08b7a162a93da921d7070094620dafeaf83", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 70, "deletions": 88, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/25b152397d66144230c2d8374e17150fc79a24f7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25b152397d66144230c2d8374e17150fc79a24f7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=25b152397d66144230c2d8374e17150fc79a24f7", "patch": "@@ -367,12 +367,11 @@ fn malloc_raw_dyn(bcx: block, t: ty::t, heap: heap,\n     let llty = type_of(ccx, box_ptr_ty);\n \n     // Get the tydesc for the body:\n-    let mut static_ti = none;\n-    let lltydesc = get_tydesc(ccx, t, static_ti);\n-    lazily_emit_all_tydesc_glue(ccx, copy static_ti);\n+    let static_ti = get_tydesc(ccx, t);\n+    lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n     // Allocate space:\n-    let rval = Call(bcx, upcall, ~[lltydesc, size]);\n+    let rval = Call(bcx, upcall, ~[static_ti.tydesc, size]);\n     ret PointerCast(bcx, rval, llty);\n }\n \n@@ -409,20 +408,10 @@ fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n // Type descriptor and type glue stuff\n \n fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n-    let mut ti = none;\n-    get_tydesc(ccx, t, ti)\n+    get_tydesc(ccx, t).tydesc\n }\n \n-fn get_tydesc(ccx: @crate_ctxt, t: ty::t,\n-              &static_ti: option<@tydesc_info>) -> ValueRef {\n-    assert !ty::type_has_params(t);\n-    // Otherwise, generate a tydesc if necessary, and return it.\n-    let inf = get_static_tydesc(ccx, t);\n-    static_ti = some(inf);\n-    inf.tydesc\n-}\n-\n-fn get_static_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n+fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     alt ccx.tydescs.find(t) {\n       some(inf) { inf }\n       _ {\n@@ -1090,96 +1079,90 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n }\n \n fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n-                               static_ti: option<@tydesc_info>) {\n+                               static_ti: @tydesc_info) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_visit_glue, static_ti);\n }\n \n fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n-                           static_ti: option<@tydesc_info>) {\n+                           ti: @tydesc_info) {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n-    alt static_ti {\n-      none { }\n-      some(ti) {\n-        if field == abi::tydesc_field_take_glue {\n-            alt ti.take_glue {\n-              some(_) { }\n-              none {\n-                #debug(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n-                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n-                let glue_fn = declare_generic_glue\n-                    (ccx, ti.ty, T_glue_fn(ccx), \"take\");\n-                ti.take_glue = some(glue_fn);\n-                make_generic_glue(ccx, ti.ty, glue_fn,\n-                                  make_take_glue, \"take\");\n-                #debug(\"--- lazily_emit_tydesc_glue TAKE %s\",\n-                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n-              }\n-            }\n-        } else if field == abi::tydesc_field_drop_glue {\n-            alt ti.drop_glue {\n-              some(_) { }\n-              none {\n-                #debug(\"+++ lazily_emit_tydesc_glue DROP %s\",\n-                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n-                let glue_fn =\n-                    declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"drop\");\n-                ti.drop_glue = some(glue_fn);\n-                make_generic_glue(ccx, ti.ty, glue_fn,\n-                                  make_drop_glue, \"drop\");\n-                #debug(\"--- lazily_emit_tydesc_glue DROP %s\",\n-                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n-              }\n-            }\n-        } else if field == abi::tydesc_field_free_glue {\n-            alt ti.free_glue {\n-              some(_) { }\n-              none {\n-                #debug(\"+++ lazily_emit_tydesc_glue FREE %s\",\n-                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n-                let glue_fn =\n-                    declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"free\");\n-                ti.free_glue = some(glue_fn);\n-                make_generic_glue(ccx, ti.ty, glue_fn,\n-                                  make_free_glue, \"free\");\n-                #debug(\"--- lazily_emit_tydesc_glue FREE %s\",\n-                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n-              }\n-            }\n-        } else if field == abi::tydesc_field_visit_glue {\n-            alt ti.visit_glue {\n-              some(_) { }\n-              none {\n-                #debug(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n-                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n-                let glue_fn =\n-                    declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"visit\");\n-                ti.visit_glue = some(glue_fn);\n-                make_generic_glue(ccx, ti.ty, glue_fn,\n-                                  make_visit_glue, \"visit\");\n-                #debug(\"--- lazily_emit_tydesc_glue VISIT %s\",\n-                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n-              }\n-            }\n+    if field == abi::tydesc_field_take_glue {\n+        alt ti.take_glue {\n+          some(_) { }\n+          none {\n+            #debug(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            let glue_fn = declare_generic_glue\n+                (ccx, ti.ty, T_glue_fn(ccx), \"take\");\n+            ti.take_glue = some(glue_fn);\n+            make_generic_glue(ccx, ti.ty, glue_fn,\n+                              make_take_glue, \"take\");\n+            #debug(\"--- lazily_emit_tydesc_glue TAKE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+          }\n+        }\n+    } else if field == abi::tydesc_field_drop_glue {\n+        alt ti.drop_glue {\n+          some(_) { }\n+          none {\n+            #debug(\"+++ lazily_emit_tydesc_glue DROP %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            let glue_fn =\n+                declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"drop\");\n+            ti.drop_glue = some(glue_fn);\n+            make_generic_glue(ccx, ti.ty, glue_fn,\n+                              make_drop_glue, \"drop\");\n+            #debug(\"--- lazily_emit_tydesc_glue DROP %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+          }\n+        }\n+    } else if field == abi::tydesc_field_free_glue {\n+        alt ti.free_glue {\n+          some(_) { }\n+          none {\n+            #debug(\"+++ lazily_emit_tydesc_glue FREE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            let glue_fn =\n+                declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"free\");\n+            ti.free_glue = some(glue_fn);\n+            make_generic_glue(ccx, ti.ty, glue_fn,\n+                              make_free_glue, \"free\");\n+            #debug(\"--- lazily_emit_tydesc_glue FREE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+          }\n+        }\n+    } else if field == abi::tydesc_field_visit_glue {\n+        alt ti.visit_glue {\n+          some(_) { }\n+          none {\n+            #debug(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            let glue_fn =\n+                declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"visit\");\n+            ti.visit_glue = some(glue_fn);\n+            make_generic_glue(ccx, ti.ty, glue_fn,\n+                              make_visit_glue, \"visit\");\n+            #debug(\"--- lazily_emit_tydesc_glue VISIT %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+          }\n         }\n-\n-      }\n     }\n }\n \n // See [Note-arg-mode]\n fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n                          field: uint, static_ti: option<@tydesc_info>) {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue_full\");\n-    lazily_emit_tydesc_glue(cx.ccx(), field, static_ti);\n-    if cx.unreachable { ret; }\n+        if cx.unreachable { ret; }\n \n     let mut static_glue_fn = none;\n     alt static_ti {\n       none {/* no-op */ }\n       some(sti) {\n+        lazily_emit_tydesc_glue(cx.ccx(), field, sti);\n         if field == abi::tydesc_field_take_glue {\n             static_glue_fn = sti.take_glue;\n         } else if field == abi::tydesc_field_drop_glue {\n@@ -1213,9 +1196,8 @@ fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n-    let mut ti = none;\n-    let td = get_tydesc(cx.ccx(), t, ti);\n-    call_tydesc_glue_full(cx, v, td, field, ti);\n+    let ti = get_tydesc(cx.ccx(), t);\n+    call_tydesc_glue_full(cx, v, ti.tydesc, field, some(ti));\n     ret cx;\n }\n "}, {"sha": "dcc2fc8c2ff2f79828bacfb53fe28b6caff56b67", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/25b152397d66144230c2d8374e17150fc79a24f7/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25b152397d66144230c2d8374e17150fc79a24f7/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=25b152397d66144230c2d8374e17150fc79a24f7", "patch": "@@ -146,7 +146,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n fn allocate_cbox(bcx: block,\n                  ck: ty::closure_kind,\n                  cdata_ty: ty::t)\n-    -> (block, ValueRef, ~[ValueRef]) {\n+    -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -160,42 +160,23 @@ fn allocate_cbox(bcx: block,\n         Store(bcx, rc, ref_cnt);\n     }\n \n-    fn store_tydesc(bcx: block,\n-                    cdata_ty: ty::t,\n-                    llbox: ValueRef,\n-                    &ti: option<@tydesc_info>) -> block {\n-        let bound_tydesc = GEPi(bcx, llbox, ~[0u, abi::box_field_tydesc]);\n-        let td = base::get_tydesc(bcx.ccx(), cdata_ty, ti);\n-        Store(bcx, td, bound_tydesc);\n-        bcx\n-    }\n-\n     // Allocate and initialize the box:\n-    let mut ti = none;\n-    let mut temp_cleanups = ~[];\n-    let (bcx, llbox) = alt ck {\n+    let llbox = alt ck {\n       ty::ck_box {\n-        get_tydesc(ccx, cdata_ty, ti);\n-        let llbox = malloc_raw(bcx, cdata_ty, heap_shared);\n-        (bcx, llbox)\n+        malloc_raw(bcx, cdata_ty, heap_shared)\n       }\n       ty::ck_uniq {\n-        let llbox = malloc_raw(bcx, cdata_ty, heap_exchange);\n-        (bcx, llbox)\n+        malloc_raw(bcx, cdata_ty, heap_exchange)\n       }\n       ty::ck_block {\n         let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n         let llbox = base::alloc_ty(bcx, cbox_ty);\n         nuke_ref_count(bcx, llbox);\n-        (bcx, llbox)\n+        llbox\n       }\n     };\n \n-    base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, ti);\n-    base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, ti);\n-    base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, ti);\n-\n-    ret (bcx, llbox, temp_cleanups);\n+    ret llbox;\n }\n \n type closure_result = {\n@@ -219,8 +200,8 @@ fn store_environment(bcx: block,\n         mk_closure_tys(tcx, bound_values);\n \n     // allocate closure in the heap\n-    let mut (bcx, llbox, temp_cleanups) =\n-        allocate_cbox(bcx, ck, cdata_ty);\n+    let llbox = allocate_cbox(bcx, ck, cdata_ty);\n+    let mut temp_cleanups = ~[];\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -567,10 +548,9 @@ fn make_opaque_cbox_take_glue(\n         let bcx = take_ty(bcx, tydesc_out, ty::mk_type(tcx));\n \n         // Take the data in the tuple\n-        let ti = none;\n         let cdata_out = GEPi(bcx, cbox_out, ~[0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, cdata_out, tydesc,\n-                              abi::tydesc_field_take_glue, ti);\n+                              abi::tydesc_field_take_glue, none);\n         bcx\n     }\n }\n@@ -615,10 +595,9 @@ fn make_opaque_cbox_free_glue(\n         let tydesc = PointerCast(bcx, tydesc, lltydescty);\n \n         // Drop the tuple data then free the descriptor\n-        let ti = none;\n         let cdata = GEPi(bcx, cbox, ~[0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, cdata, tydesc,\n-                              abi::tydesc_field_drop_glue, ti);\n+                              abi::tydesc_field_drop_glue, none);\n \n         // Free the ty descr (if necc) and the box itself\n         alt ck {"}]}