{"sha": "e02937848b9316d393577171ede62a3423132583", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMjkzNzg0OGI5MzE2ZDM5MzU3NzE3MWVkZTYyYTM0MjMxMzI1ODM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-24T20:20:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-31T16:41:38Z"}, "message": "extend liveness to distinguish \"drop\" and \"non-drop\" uses", "tree": {"sha": "ae124257ad059b0dbe20edb9fedf887974a93cf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae124257ad059b0dbe20edb9fedf887974a93cf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e02937848b9316d393577171ede62a3423132583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e02937848b9316d393577171ede62a3423132583", "html_url": "https://github.com/rust-lang/rust/commit/e02937848b9316d393577171ede62a3423132583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e02937848b9316d393577171ede62a3423132583/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d", "html_url": "https://github.com/rust-lang/rust/commit/cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d"}], "stats": {"total": 446, "additions": 307, "deletions": 139}, "files": [{"sha": "52a50333f4577d0d9d6ad1cf663b16f676a7bc96", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -68,7 +68,7 @@ use rustc::mir::visit::{LvalueContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n use rustc::ty::subst::{Kind, Substs};\n use util::dump_mir;\n-use util::liveness;\n+use util::liveness::{self, LivenessMode};\n use rustc_const_math::ConstInt;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -348,7 +348,10 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ignored.visit_mir(mir);\n \n     let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n-    let liveness = liveness::liveness_of_locals(mir);\n+    let liveness = liveness::liveness_of_locals(mir, LivenessMode {\n+        include_regular_use: true,\n+        include_drops: true,\n+    });\n     liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &liveness);\n \n     let mut storage_liveness_map = HashMap::new();"}, {"sha": "518e140b5dd1b0530a8ddcb2cd5d0f4119d6a2ae", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -10,24 +10,30 @@\n \n use rustc::mir::Mir;\n use rustc::infer::InferCtxt;\n-use util::liveness::LivenessResult;\n \n+use super::LivenessResults;\n use super::ToRegionIndex;\n use super::region_infer::RegionInferenceContext;\n \n-pub fn generate_constraints<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                            regioncx: &mut RegionInferenceContext,\n-                                            mir: &Mir<'tcx>,\n-                                            liveness: &LivenessResult)\n-{\n-    ConstraintGeneration { infcx, regioncx, mir, liveness }.add_constraints();\n+pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    regioncx: &mut RegionInferenceContext,\n+    mir: &Mir<'tcx>,\n+    liveness: &LivenessResults,\n+) {\n+    ConstraintGeneration {\n+        infcx,\n+        regioncx,\n+        mir,\n+        liveness,\n+    }.add_constraints();\n }\n \n struct ConstraintGeneration<'constrain, 'gcx: 'tcx, 'tcx: 'constrain> {\n     infcx: &'constrain InferCtxt<'constrain, 'gcx, 'tcx>,\n     regioncx: &'constrain mut RegionInferenceContext,\n     mir: &'constrain Mir<'tcx>,\n-    liveness: &'constrain LivenessResult,\n+    liveness: &'constrain LivenessResults,\n }\n \n impl<'constrain, 'gcx, 'tcx> ConstraintGeneration<'constrain, 'gcx, 'tcx> {\n@@ -47,18 +53,23 @@ impl<'constrain, 'gcx, 'tcx> ConstraintGeneration<'constrain, 'gcx, 'tcx> {\n         for bb in self.mir.basic_blocks().indices() {\n             debug!(\"add_liveness_constraints: bb={:?}\", bb);\n \n-            self.liveness.simulate_block(self.mir, bb, |location, live_locals| {\n-                debug!(\"add_liveness_constraints: location={:?} live_locals={:?}\",\n-                       location, live_locals);\n+            self.liveness\n+                .regular\n+                .simulate_block(self.mir, bb, |location, live_locals| {\n+                    debug!(\n+                        \"add_liveness_constraints: location={:?} live_locals={:?}\",\n+                        location,\n+                        live_locals\n+                    );\n \n-                for live_local in live_locals.iter() {\n-                    let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    tcx.for_each_free_region(&live_local_ty, |live_region| {\n-                        let vid = live_region.to_region_index();\n-                        self.regioncx.add_live_point(vid, location);\n-                    })\n-                }\n-            });\n+                    for live_local in live_locals.iter() {\n+                        let live_local_ty = self.mir.local_decls[live_local].ty;\n+                        tcx.for_each_free_region(&live_local_ty, |live_region| {\n+                            let vid = live_region.to_region_index();\n+                            self.regioncx.add_live_point(vid, location);\n+                        })\n+                    }\n+                });\n         }\n     }\n }"}, {"sha": "131f088d91c7534c44e01363b4c0cc1d0716e2d2", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -16,7 +16,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::collections::BTreeSet;\n use std::fmt;\n-use util::liveness::{self, LivenessResult};\n+use util::liveness::{self, LivenessResult, LivenessMode};\n \n use util as mir_util;\n use self::mir_util::PassWhere;\n@@ -50,7 +50,17 @@ impl MirPass for NLL {\n             let num_region_variables = renumber::renumber_mir(infcx, mir);\n \n             // Compute what is live where.\n-            let liveness = &liveness::liveness_of_locals(mir);\n+            let liveness = &LivenessResults {\n+                regular: liveness::liveness_of_locals(mir, LivenessMode {\n+                    include_regular_use: true,\n+                    include_drops: false,\n+                }),\n+\n+                drop: liveness::liveness_of_locals(mir, LivenessMode {\n+                    include_regular_use: false,\n+                    include_drops: true,\n+                })\n+            };\n \n             // Create the region inference context, generate the constraints,\n             // and then solve them.\n@@ -64,9 +74,14 @@ impl MirPass for NLL {\n     }\n }\n \n+struct LivenessResults {\n+    regular: LivenessResult,\n+    drop: LivenessResult,\n+}\n+\n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    liveness: &LivenessResult,\n+    liveness: &LivenessResults,\n     source: MirSource,\n     regioncx: &RegionInferenceContext,\n     mir: &Mir<'tcx>,\n@@ -75,11 +90,22 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let liveness_per_location: FxHashMap<_, _> = mir.basic_blocks()\n+    let regular_liveness_per_location: FxHashMap<_, _> = mir.basic_blocks()\n+        .indices()\n+        .flat_map(|bb| {\n+            let mut results = vec![];\n+            liveness.regular.simulate_block(&mir, bb, |location, local_set| {\n+                results.push((location, local_set.clone()));\n+            });\n+            results\n+        })\n+        .collect();\n+\n+    let drop_liveness_per_location: FxHashMap<_, _> = mir.basic_blocks()\n         .indices()\n         .flat_map(|bb| {\n             let mut results = vec![];\n-            liveness.simulate_block(&mir, bb, |location, local_set| {\n+            liveness.drop.simulate_block(&mir, bb, |location, local_set| {\n                 results.push((location, local_set.clone()));\n             });\n             results\n@@ -96,16 +122,17 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n             // Before each basic block, dump out the values\n             // that are live on entry to the basic block.\n             PassWhere::BeforeBlock(bb) => {\n-                let local_set = &liveness.ins[bb];\n-                writeln!(out, \"    | Variables live on entry to the block {:?}:\", bb)?;\n-                for local in local_set.iter() {\n-                    writeln!(out, \"    | - {:?}\", local)?;\n-                }\n+                writeln!(out, \"    | Variables regular-live on entry to the block {:?}: {:?}\",\n+                         bb, liveness.regular.ins[bb])?;\n+                writeln!(out, \"    | Variables drop-live on entry to the block {:?}: {:?}\",\n+                         bb, liveness.drop.ins[bb])?;\n             }\n \n             PassWhere::InCFG(location) => {\n-                let local_set = &liveness_per_location[&location];\n-                writeln!(out, \"        | Live variables here: {:?}\", local_set)?;\n+                let local_set = &regular_liveness_per_location[&location];\n+                writeln!(out, \"        | Regular-Live variables here: {:?}\", local_set)?;\n+                let local_set = &drop_liveness_per_location[&location];\n+                writeln!(out, \"        | Drop-Live variables here: {:?}\", local_set)?;\n             }\n \n             PassWhere::AfterCFG => {}"}, {"sha": "7658e49ea5ebd26666019a557de03ddb0c67acd8", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 139, "deletions": 81, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -35,29 +35,60 @@\n \n use rustc::mir::*;\n use rustc::mir::visit::{LvalueContext, Visitor};\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n-use util::pretty::{write_basic_block, dump_enabled, write_mir_intro};\n+use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n use rustc::mir::transform::MirSource;\n use rustc::ty::item_path;\n-use std::path::{PathBuf, Path};\n+use std::path::{Path, PathBuf};\n use std::fs;\n use rustc::ty::TyCtxt;\n use std::io::{self, Write};\n \n pub type LocalSet = IdxSetBuf<Local>;\n \n-// This gives the result of the liveness analysis at the boundary of basic blocks\n+/// This gives the result of the liveness analysis at the boundary of\n+/// basic blocks. You can use `simulate_block` to obtain the\n+/// intra-block results.\n pub struct LivenessResult {\n+    /// Liveness mode in use when these results were computed.\n+    pub mode: LivenessMode,\n+\n+    /// Live variables on entry to each basic block.\n     pub ins: IndexVec<BasicBlock, LocalSet>,\n+\n+    /// Live variables on exit to each basic block. This is equal to\n+    /// the union of the `ins` for each successor.\n     pub outs: IndexVec<BasicBlock, LocalSet>,\n }\n \n-pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>) -> LivenessResult {\n+#[derive(Copy, Clone, Debug)]\n+pub struct LivenessMode {\n+    /// If true, then we will consider \"regular uses\" of a variable to be live.\n+    /// For example, if the user writes `foo(x)`, then this is a regular use of\n+    /// the variable `x`.\n+    pub include_regular_use: bool,\n+\n+    /// If true, then we will consider (implicit) drops of a variable\n+    /// to be live.  For example, if the user writes `{ let x =\n+    /// vec![...]; .. }`, then the drop at the end of the block is an\n+    /// implicit drop.\n+    ///\n+    /// NB. Despite its name, a call like `::std::mem::drop(x)` is\n+    /// **not** considered a drop for this purposes, but rather a\n+    /// regular use.\n+    pub include_drops: bool,\n+}\n+\n+/// Compute which local variables are live within the given function\n+/// `mir`. The liveness mode `mode` determines what sorts of uses are\n+/// considered to make a variable live (e.g., do drops count?).\n+pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>, mode: LivenessMode) -> LivenessResult {\n     let locals = mir.local_decls.len();\n-    let def_use: IndexVec<_, _> = mir.basic_blocks().iter().map(|b| {\n-        block(b, locals)\n-    }).collect();\n+    let def_use: IndexVec<_, _> = mir.basic_blocks()\n+        .iter()\n+        .map(|b| block(mode, b, locals))\n+        .collect();\n \n     let mut ins: IndexVec<_, _> = mir.basic_blocks()\n         .indices()\n@@ -89,22 +120,17 @@ pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>) -> LivenessResult {\n         }\n     }\n \n-    LivenessResult {\n-        ins,\n-        outs,\n-    }\n+    LivenessResult { mode, ins, outs }\n }\n \n impl LivenessResult {\n     /// Walks backwards through the statements/terminator in the given\n     /// basic block `block`.  At each point within `block`, invokes\n     /// the callback `op` with the current location and the set of\n     /// variables that are live on entry to that location.\n-    pub fn simulate_block<'tcx, OP>(&self,\n-                                    mir: &Mir<'tcx>,\n-                                    block: BasicBlock,\n-                                    mut callback: OP)\n-        where OP: FnMut(Location, &LocalSet)\n+    pub fn simulate_block<'tcx, OP>(&self, mir: &Mir<'tcx>, block: BasicBlock, mut callback: OP)\n+    where\n+        OP: FnMut(Location, &LocalSet),\n     {\n         let data = &mir[block];\n \n@@ -116,15 +142,21 @@ impl LivenessResult {\n         let mut statement_index = data.statements.len();\n \n         // Compute liveness right before terminator and invoke callback.\n-        let terminator_location = Location { block, statement_index };\n+        let terminator_location = Location {\n+            block,\n+            statement_index,\n+        };\n         let terminator_defs_uses = self.defs_uses(mir, terminator_location, &data.terminator);\n         terminator_defs_uses.apply(&mut bits);\n         callback(terminator_location, &bits);\n \n         // Compute liveness before each statement (in rev order) and invoke callback.\n         for statement in data.statements.iter().rev() {\n             statement_index -= 1;\n-            let statement_location = Location { block, statement_index };\n+            let statement_location = Location {\n+                block,\n+                statement_index,\n+            };\n             let statement_defs_uses = self.defs_uses(mir, statement_location, statement);\n             statement_defs_uses.apply(&mut bits);\n             callback(statement_location, &bits);\n@@ -133,27 +165,32 @@ impl LivenessResult {\n         assert_eq!(bits, self.ins[block]);\n     }\n \n-    fn defs_uses<'tcx, V>(&self,\n-                          mir: &Mir<'tcx>,\n-                          location: Location,\n-                          thing: &V)\n-                          -> DefsUses\n-        where V: MirVisitable<'tcx>,\n+    fn defs_uses<'tcx, V>(&self, mir: &Mir<'tcx>, location: Location, thing: &V) -> DefsUses\n+    where\n+        V: MirVisitable<'tcx>,\n     {\n         let locals = mir.local_decls.len();\n-        let mut visitor = DefsUses {\n-            defs: LocalSet::new_empty(locals),\n-            uses: LocalSet::new_empty(locals),\n+        let mut visitor = DefsUsesVisitor {\n+            mode: self.mode,\n+            defs_uses: DefsUses {\n+                defs: LocalSet::new_empty(locals),\n+                uses: LocalSet::new_empty(locals),\n+            },\n         };\n \n         // Visit the various parts of the basic block in reverse. If we go\n         // forward, the logic in `add_def` and `add_use` would be wrong.\n         thing.apply(location, &mut visitor);\n \n-        visitor\n+        visitor.defs_uses\n     }\n }\n \n+struct DefsUsesVisitor {\n+    mode: LivenessMode,\n+    defs_uses: DefsUses,\n+}\n+\n #[derive(Eq, PartialEq, Clone)]\n struct DefsUses {\n     defs: LocalSet,\n@@ -195,18 +232,15 @@ impl DefsUses {\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for DefsUses {\n-    fn visit_local(&mut self,\n-                   &local: &Local,\n-                   context: LvalueContext<'tcx>,\n-                   _: Location) {\n+impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n+    fn visit_local(&mut self, &local: &Local, context: LvalueContext<'tcx>, _: Location) {\n         match context {\n             ///////////////////////////////////////////////////////////////////////////\n             // DEFS\n \n             LvalueContext::Store |\n \n-            // We let Call defined the result in both the success and\n+            // We let Call define the result in both the success and\n             // unwind cases. This is not really correct, however it\n             // does not seem to be observable due to the way that we\n             // generate MIR. See the test case\n@@ -220,11 +254,15 @@ impl<'tcx> Visitor<'tcx> for DefsUses {\n             // values that come before them.\n             LvalueContext::StorageLive |\n             LvalueContext::StorageDead => {\n-                self.add_def(local);\n+                self.defs_uses.add_def(local);\n             }\n \n             ///////////////////////////////////////////////////////////////////////////\n-            // USES\n+            // REGULAR USES\n+            //\n+            // These are uses that occur *outside* of a drop. For the\n+            // purposes of NLL, these are special in that **all** the\n+            // lifetimes appearing in the variable must be live for each regular use.\n \n             LvalueContext::Projection(..) |\n \n@@ -236,25 +274,42 @@ impl<'tcx> Visitor<'tcx> for DefsUses {\n \n             LvalueContext::Inspect |\n             LvalueContext::Consume |\n-            LvalueContext::Validate |\n+            LvalueContext::Validate => {\n+                if self.mode.include_regular_use {\n+                    self.defs_uses.add_use(local);\n+                }\n+            }\n+\n+            ///////////////////////////////////////////////////////////////////////////\n+            // DROP USES\n+            //\n+            // These are uses that occur in a DROP (a MIR drop, not a\n+            // call to `std::mem::drop()`). For the purposes of NLL,\n+            // uses in drop are special because `#[may_dangle]`\n+            // attributes can affect whether lifetimes must be live.\n \n-            // We consider drops to always be uses of locals.\n-            // Drop eloboration should be run before this analysis otherwise\n-            // the results might be too pessimistic.\n             LvalueContext::Drop => {\n-                self.add_use(local);\n+                if self.mode.include_drops {\n+                    self.defs_uses.add_use(local);\n+                }\n             }\n         }\n     }\n }\n \n-fn block<'tcx>(b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses {\n-    let mut visitor = DefsUses {\n-        defs: LocalSet::new_empty(locals),\n-        uses: LocalSet::new_empty(locals),\n+fn block<'tcx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses {\n+    let mut visitor = DefsUsesVisitor {\n+        mode,\n+        defs_uses: DefsUses {\n+            defs: LocalSet::new_empty(locals),\n+            uses: LocalSet::new_empty(locals),\n+        },\n     };\n \n-    let dummy_location = Location { block: BasicBlock::new(0), statement_index: 0 };\n+    let dummy_location = Location {\n+        block: BasicBlock::new(0),\n+        statement_index: 0,\n+    };\n \n     // Visit the various parts of the basic block in reverse. If we go\n     // forward, the logic in `add_def` and `add_use` would be wrong.\n@@ -263,62 +318,64 @@ fn block<'tcx>(b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses {\n         visitor.visit_statement(BasicBlock::new(0), statement, dummy_location);\n     }\n \n-    visitor\n+    visitor.defs_uses\n }\n \n trait MirVisitable<'tcx> {\n     fn apply<V>(&self, location: Location, visitor: &mut V)\n-        where V: Visitor<'tcx>;\n+    where\n+        V: Visitor<'tcx>;\n }\n \n impl<'tcx> MirVisitable<'tcx> for Statement<'tcx> {\n     fn apply<V>(&self, location: Location, visitor: &mut V)\n-        where V: Visitor<'tcx>\n+    where\n+        V: Visitor<'tcx>,\n     {\n-        visitor.visit_statement(location.block,\n-                                self,\n-                                location)\n+        visitor.visit_statement(location.block, self, location)\n     }\n }\n \n impl<'tcx> MirVisitable<'tcx> for Option<Terminator<'tcx>> {\n     fn apply<V>(&self, location: Location, visitor: &mut V)\n-        where V: Visitor<'tcx>\n+    where\n+        V: Visitor<'tcx>,\n     {\n-        visitor.visit_terminator(location.block,\n-                                 self.as_ref().unwrap(),\n-                                 location)\n+        visitor.visit_terminator(location.block, self.as_ref().unwrap(), location)\n     }\n }\n \n-pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          pass_name: &str,\n-                          source: MirSource,\n-                          mir: &Mir<'tcx>,\n-                          result: &LivenessResult) {\n+pub fn dump_mir<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pass_name: &str,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    result: &LivenessResult,\n+) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n-    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+    let node_path = item_path::with_forced_impl_filename_line(|| {\n+        // see notes on #41697 below\n         tcx.item_path_str(tcx.hir.local_def_id(source.item_id()))\n     });\n-    dump_matched_mir_node(tcx, pass_name, &node_path,\n-                          source, mir, result);\n+    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   pass_name: &str,\n-                                   node_path: &str,\n-                                   source: MirSource,\n-                                   mir: &Mir<'tcx>,\n-                                   result: &LivenessResult) {\n+fn dump_matched_mir_node<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pass_name: &str,\n+    node_path: &str,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    result: &LivenessResult,\n+) {\n     let mut file_path = PathBuf::new();\n     if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n         let p = Path::new(file_dir);\n         file_path.push(p);\n     };\n-    let file_name = format!(\"rustc.node{}{}-liveness.mir\",\n-                            source.item_id(), pass_name);\n+    let file_name = format!(\"rustc.node{}{}-liveness.mir\", source.item_id(), pass_name);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|mut file| {\n         writeln!(file, \"// MIR local liveness analysis for `{}`\", node_path)?;\n@@ -330,16 +387,18 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              src: MirSource,\n-                              mir: &Mir<'tcx>,\n-                              w: &mut Write,\n-                              result: &LivenessResult)\n-                              -> io::Result<()> {\n+pub fn write_mir_fn<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    src: MirSource,\n+    mir: &Mir<'tcx>,\n+    w: &mut Write,\n+    result: &LivenessResult,\n+) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n         let print = |w: &mut Write, prefix, result: &IndexVec<BasicBlock, LocalSet>| {\n-            let live: Vec<String> = mir.local_decls.indices()\n+            let live: Vec<String> = mir.local_decls\n+                .indices()\n                 .filter(|i| result[block].contains(i))\n                 .map(|i| format!(\"{:?}\", i))\n                 .collect();\n@@ -356,4 +415,3 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     writeln!(w, \"}}\")?;\n     Ok(())\n }\n-"}, {"sha": "e9af37a1f64c8338276fc9b0c05f44b0319e8aba", "filename": "src/test/mir-opt/nll/liveness-call-subtlety.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -26,21 +26,26 @@ fn main() {\n //\n // END RUST SOURCE\n // START rustc.node12.nll.0.mir\n-//    | Variables live on entry to the block bb0:\n+//    | Variables regular-live on entry to the block bb0: []\n+//    | Variables drop-live on entry to the block bb0: []\n //    bb0: {\n-//        | Live variables here: []\n+//        | Regular-Live variables here: []\n+//        | Drop-Live variables here: []\n //        StorageLive(_1);\n-//        | Live variables here: []\n+//        | Regular-Live variables here: []\n+//        | Drop-Live variables here: []\n //        _1 = const <std::boxed::Box<T>>::new(const 22usize) -> bb1;\n //    }\n // END rustc.node12.nll.0.mir\n // START rustc.node12.nll.0.mir\n-//    | Variables live on entry to the block bb1:\n-//    | - _1\n+//    | Variables regular-live on entry to the block bb1: []\n+//    | Variables drop-live on entry to the block bb1: [_1]\n //    bb1: {\n-//        | Live variables here: [_1]\n+//        | Regular-Live variables here: []\n+//        | Drop-Live variables here: [_1]\n //        StorageLive(_2);\n-//        | Live variables here: [_1]\n+//        | Regular-Live variables here: []\n+//        | Drop-Live variables here: [_1]\n //        _2 = const can_panic() -> [return: bb2, unwind: bb4];\n //    }\n // END rustc.node12.nll.0.mir"}, {"sha": "957a57428e3b3cfff4238ed71331990b8bf504c4", "filename": "src/test/mir-opt/nll/liveness-drop-intra-block.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -25,17 +25,23 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.node12.nll.0.mir\n-//    | Variables live on entry to the block bb1:\n+//    | Variables regular-live on entry to the block bb1: []\n+//    | Variables drop-live on entry to the block bb1: []\n //    bb1: {\n-//        | Live variables here: []\n+//        | Regular-Live variables here: []\n+//        | Drop-Live variables here: []\n //        _1 = const 55usize;\n-//        | Live variables here: [_1]\n+//        | Regular-Live variables here: [_1]\n+//        | Drop-Live variables here: []\n //        StorageLive(_3);\n-//        | Live variables here: [_1]\n+//        | Regular-Live variables here: [_1]\n+//        | Drop-Live variables here: []\n //        StorageLive(_4);\n-//        | Live variables here: [_1]\n+//        | Regular-Live variables here: [_1]\n+//        | Drop-Live variables here: []\n //        _4 = _1;\n-//        | Live variables here: [_4]\n+//        | Regular-Live variables here: [_4]\n+//        | Drop-Live variables here: []\n //        _3 = const use_x(_4) -> bb2;\n //    }\n // END rustc.node12.nll.0.mir"}, {"sha": "f5a2a25a9b0c1e69a97309a6d17b3d98570326b6", "filename": "src/test/mir-opt/nll/liveness-interblock.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -29,21 +29,26 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.node18.nll.0.mir\n-//     | Variables live on entry to the block bb2:\n-//     | - _1\n+//    | Variables regular-live on entry to the block bb2: [_1]\n+//    | Variables drop-live on entry to the block bb2: []\n //     bb2: {\n-//         | Live variables here: [_1]\n+//         | Regular-Live variables here: [_1]\n+//         | Drop-Live variables here: []\n //         StorageLive(_4);\n-//         | Live variables here: [_1]\n+//         | Regular-Live variables here: [_1]\n+//         | Drop-Live variables here: []\n //         _4 = _1;\n-//         | Live variables here: [_4]\n+//         | Regular-Live variables here: [_4]\n+//         | Drop-Live variables here: []\n //         _3 = const make_live(_4) -> bb4;\n //     }\n // END rustc.node18.nll.0.mir\n // START rustc.node18.nll.0.mir\n-//     | Variables live on entry to the block bb3:\n+//     | Variables regular-live on entry to the block bb3: []\n+//     | Variables drop-live on entry to the block bb3: []\n //     bb3: {\n-//         | Live variables here: []\n+//         | Regular-Live variables here: []\n+//         | Drop-Live variables here: []\n //         _5 = const make_dead() -> bb5;\n //     }\n // END rustc.node18.nll.0.mir"}, {"sha": "67e16c2fe6fc3bda13a6e6681efc1796f1c0d238", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -37,19 +37,24 @@ fn main() {\n // END rustc.node12.nll.0.mir\n // START rustc.node12.nll.0.mir\n //    bb1: {\n-//        | Live variables here: [_1, _3]\n+//        | Regular-Live variables here: [_1, _3]\n+//        | Drop-Live variables here: []\n //        _2 = &'_#0r _1[_3];\n-//        | Live variables here: [_2]\n+//        | Regular-Live variables here: [_2]\n+//        | Drop-Live variables here: []\n //        switchInt(const true) -> [0u8: bb3, otherwise: bb2];\n //    }\n // END rustc.node12.nll.0.mir\n // START rustc.node12.nll.0.mir\n //    bb2: {\n-//        | Live variables here: [_2]\n+//        | Regular-Live variables here: [_2]\n+//        | Drop-Live variables here: []\n //        StorageLive(_7);\n-//        | Live variables here: [_2]\n+//        | Regular-Live variables here: [_2]\n+//        | Drop-Live variables here: []\n //        _7 = (*_2);\n-//        | Live variables here: [_7]\n+//        | Regular-Live variables here: [_7]\n+//        | Drop-Live variables here: []\n //        _6 = const use_x(_7) -> bb4;\n //    }\n // END rustc.node12.nll.0.mir"}, {"sha": "7482288e9117fc4b7e67a8a40205a64f38ecc3f2", "filename": "src/test/mir-opt/nll/region-liveness-drop-may-dangle.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02937848b9316d393577171ede62a3423132583/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs?ref=e02937848b9316d393577171ede62a3423132583", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+#![feature(dropck_eyepatch)]\n+#![feature(generic_param_attrs)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let p: Wrap<& /* R4 */ usize> = Wrap { value: &v[0] };\n+    if true {\n+        use_x(*p.value);\n+    } else {\n+        use_x(22);\n+    }\n+\n+    // `p` will get dropped here. However, because of the\n+    // `#[may_dangle]` attribute, we do not need to consider R4 live.\n+}\n+\n+struct Wrap<T> {\n+    value: T\n+}\n+\n+unsafe impl<#[may_dangle] T> Drop for Wrap<T> {\n+    fn drop(&mut self) { }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+// | R4: {bb1[3], bb1[4], bb1[5], bb2[0], bb2[1]}\n+// END rustc.node12.nll.0.mir"}]}