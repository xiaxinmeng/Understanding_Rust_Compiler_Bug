{"sha": "ce16189d46c607483fd892cbf9353e3c9f2d8047", "node_id": "C_kwDOAAsO6NoAKGNlMTYxODlkNDZjNjA3NDgzZmQ4OTJjYmY5MzUzZTNjOWYyZDgwNDc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-12T22:55:53Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-15T17:17:09Z"}, "message": "add some more comments to GAT where clause check", "tree": {"sha": "1b17bb29b1040f0a76d7f0bff04a9b410cf3385d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b17bb29b1040f0a76d7f0bff04a9b410cf3385d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce16189d46c607483fd892cbf9353e3c9f2d8047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce16189d46c607483fd892cbf9353e3c9f2d8047", "html_url": "https://github.com/rust-lang/rust/commit/ce16189d46c607483fd892cbf9353e3c9f2d8047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce16189d46c607483fd892cbf9353e3c9f2d8047/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8b49f028213e8cfccb1738a628b694f3cfe4076", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b49f028213e8cfccb1738a628b694f3cfe4076", "html_url": "https://github.com/rust-lang/rust/commit/d8b49f028213e8cfccb1738a628b694f3cfe4076"}], "stats": {"total": 81, "additions": 62, "deletions": 19}, "files": [{"sha": "d18682f5b62b207e1725035f9f42c5c46db8c250", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 62, "deletions": 19, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ce16189d46c607483fd892cbf9353e3c9f2d8047/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce16189d46c607483fd892cbf9353e3c9f2d8047/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=ce16189d46c607483fd892cbf9353e3c9f2d8047", "patch": "@@ -263,9 +263,24 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n /// Require that the user writes where clauses on GATs for the implicit\n /// outlives bounds involving trait parameters in trait functions and\n /// lifetimes passed as GAT substs. See `self-outlives-lint` test.\n+///\n+/// We use the following trait as an example throughout this function:\n+/// ```rust,ignore (this code fails due to this lint)\n+/// trait IntoIter {\n+///     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n+///     type Item<'a>;\n+///     fn into_iter<'a>(&'a self) -> Self::Iter<'a>;\n+/// }\n /// ```\n fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRef]) {\n+    // Associates every GAT's def_id to a list of possibly missing bounds detected by this lint.\n     let mut required_bounds_by_item = FxHashMap::default();\n+\n+    // Loop over all GATs together, because if this lint suggests adding a where-clause bound\n+    // to one GAT, it might then require us to an additional bound on another GAT.\n+    // In our `IntoIter` example, we discover a missing `Self: 'a` bound on `Iter<'a>`, which\n+    // then in a second loop adds a `Self: 'a` bound to `Item` due to the relationship between\n+    // those GATs.\n     loop {\n         let mut should_continue = false;\n         for gat_item in associated_items {\n@@ -276,14 +291,18 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                 continue;\n             }\n             let gat_generics = tcx.generics_of(gat_def_id);\n+            // FIXME(jackh726): we can also warn in the more general case\n             if gat_generics.params.is_empty() {\n                 continue;\n             }\n \n+            // Gather the bounds with which all other items inside of this trait constrain the GAT.\n+            // This is calculated by taking the intersection of the bounds that each item\n+            // constrains the GAT with individually.\n             let mut new_required_bounds: Option<FxHashSet<ty::Predicate<'_>>> = None;\n             for item in associated_items {\n                 let item_def_id = item.id.def_id;\n-                // Skip our own GAT, since it would blow away the required bounds\n+                // Skip our own GAT, since it does not constrain itself at all.\n                 if item_def_id == gat_def_id {\n                     continue;\n                 }\n@@ -292,7 +311,11 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                 let param_env = tcx.param_env(item_def_id);\n \n                 let item_required_bounds = match item.kind {\n+                    // In our example, this corresponds to `into_iter` method\n                     hir::AssocItemKind::Fn { .. } => {\n+                        // For methods, we check the function signature's return type for any GATs\n+                        // to constrain. In the `into_iter` case, we see that the return type\n+                        // `Self::Iter<'a>` is a GAT we want to gather any potential missing bounds from.\n                         let sig: ty::FnSig<'_> = tcx.liberate_late_bound_regions(\n                             item_def_id.to_def_id(),\n                             tcx.fn_sig(item_def_id),\n@@ -302,11 +325,14 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                             param_env,\n                             item_hir_id,\n                             sig.output(),\n+                            // We also assume that all of the function signature's parameter types\n+                            // are well formed.\n                             &sig.inputs().iter().copied().collect(),\n                             gat_def_id,\n                             gat_generics,\n                         )\n                     }\n+                    // In our example, this corresponds to the `Iter` and `Item` associated types\n                     hir::AssocItemKind::Type => {\n                         // If our associated item is a GAT with missing bounds, add them to\n                         // the param-env here. This allows this GAT to propagate missing bounds\n@@ -316,6 +342,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                             param_env,\n                             required_bounds_by_item.get(&item_def_id),\n                         );\n+                        // FIXME(compiler-errors): Do we want to add a assoc ty default to the wf_tys?\n                         gather_gat_bounds(\n                             tcx,\n                             param_env,\n@@ -333,9 +360,11 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                 };\n \n                 if let Some(item_required_bounds) = item_required_bounds {\n-                    // Take the intersection of the new_required_bounds and the item_required_bounds\n-                    // for this item. This is why we use an Option<_>, since we need to distinguish\n-                    // the empty set of bounds from the uninitialized set of bounds.\n+                    // Take the intersection of the required bounds for this GAT, and\n+                    // the item_required_bounds which are the ones implied by just\n+                    // this item alone.\n+                    // This is why we use an Option<_>, since we need to distinguish\n+                    // the empty set of bounds from the _uninitialized_ set of bounds.\n                     if let Some(new_required_bounds) = &mut new_required_bounds {\n                         new_required_bounds.retain(|b| item_required_bounds.contains(b));\n                     } else {\n@@ -346,14 +375,17 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n \n             if let Some(new_required_bounds) = new_required_bounds {\n                 let required_bounds = required_bounds_by_item.entry(gat_def_id).or_default();\n-                if new_required_bounds != *required_bounds {\n-                    *required_bounds = new_required_bounds;\n+                if new_required_bounds.into_iter().any(|p| required_bounds.insert(p)) {\n                     // Iterate until our required_bounds no longer change\n                     // Since they changed here, we should continue the loop\n                     should_continue = true;\n                 }\n             }\n         }\n+        // We know that this loop will eventually halt, since we only set `should_continue` if the\n+        // `required_bounds` for this item grows. Since we are not creating any new region or type\n+        // variables, the set of all region and type bounds that we could ever insert are limited\n+        // by the number of unique types and regions we observe in a given item.\n         if !should_continue {\n             break;\n         }\n@@ -422,8 +454,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n     }\n }\n \n-/// Add a new set of predicates to the caller_bounds of an existing param_env,\n-/// and normalize the param_env afterwards\n+/// Add a new set of predicates to the caller_bounds of an existing param_env.\n fn augment_param_env<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -444,6 +475,16 @@ fn augment_param_env<'tcx>(\n     ty::ParamEnv::new(bounds, param_env.reveal(), param_env.constness())\n }\n \n+/// We use the following trait as an example throughout this function.\n+/// Specifically, let's assume that `to_check` here is the return type\n+/// of `into_iter`, and the GAT we are checking this for is `Iter`.\n+/// ```rust,ignore (this code fails due to this lint)\n+/// trait IntoIter {\n+///     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n+///     type Item<'a>;\n+///     fn into_iter<'a>(&'a self) -> Self::Iter<'a>;\n+/// }\n+/// ```\n fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -453,13 +494,13 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n     gat_def_id: LocalDefId,\n     gat_generics: &'tcx ty::Generics,\n ) -> Option<FxHashSet<ty::Predicate<'tcx>>> {\n-    // The bounds we that we would require from this function\n+    // The bounds we that we would require from `to_check`\n     let mut bounds = FxHashSet::default();\n \n     let (regions, types) = GATSubstCollector::visit(tcx, gat_def_id.to_def_id(), to_check);\n \n     // If both regions and types are empty, then this GAT isn't in the\n-    // return type, and we shouldn't try to do clause analysis\n+    // set of types we are checking, and we shouldn't try to do clause analysis\n     // (particularly, doing so would end up with an empty set of clauses,\n     // since the current method would require none, and we take the\n     // intersection of requirements of all methods)\n@@ -474,18 +515,18 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n         if let ty::ReStatic = **region_a {\n             continue;\n         }\n-        // For each region argument (e.g., 'a in our example), check for a\n-        // relationship to the type arguments (e.g., Self). If there is an\n+        // For each region argument (e.g., `'a` in our example), check for a\n+        // relationship to the type arguments (e.g., `Self`). If there is an\n         // outlives relationship (`Self: 'a`), then we want to ensure that is\n         // reflected in a where clause on the GAT itself.\n         for (ty, ty_idx) in &types {\n-            // In our example, requires that Self: 'a\n+            // In our example, requires that `Self: 'a`\n             if ty_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *ty, *region_a) {\n                 debug!(?ty_idx, ?region_a_idx);\n                 debug!(\"required clause: {} must outlive {}\", ty, region_a);\n                 // Translate into the generic parameters of the GAT. In\n-                // our example, the type was Self, which will also be\n-                // Self in the GAT.\n+                // our example, the type was `Self`, which will also be\n+                // `Self` in the GAT.\n                 let ty_param = gat_generics.param_at(*ty_idx, tcx);\n                 let ty_param = tcx\n                     .mk_ty(ty::Param(ty::ParamTy { index: ty_param.index, name: ty_param.name }));\n@@ -507,11 +548,13 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n             }\n         }\n \n-        // For each region argument (e.g., 'a in our example), also check for a\n-        // relationship to the other region arguments. If there is an\n-        // outlives relationship, then we want to ensure that is\n-        // reflected in a where clause on the GAT itself.\n+        // For each region argument (e.g., `'a` in our example), also check for a\n+        // relationship to the other region arguments. If there is an outlives\n+        // relationship, then we want to ensure that is reflected in the where clause\n+        // on the GAT itself.\n         for (region_b, region_b_idx) in &regions {\n+            // Again, skip `'static` because it outlives everything. Also, we trivially\n+            // know that a region outlives itself.\n             if ty::ReStatic == **region_b || region_a == region_b {\n                 continue;\n             }"}]}