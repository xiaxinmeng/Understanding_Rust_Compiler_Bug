{"sha": "e4d8f0e3493d65f8d8d4121dd868402a1365d951", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZDhmMGUzNDkzZDY1ZjhkOGQ0MTIxZGQ4Njg0MDJhMTM2NWQ5NTE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2021-07-24T16:51:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-24T16:51:56Z"}, "message": "Rollup merge of #87348 - SkiFire13:fix-87261, r=oli-obk\n\nFix span when suggesting to add an associated type bound\n\nFixes #87261\n\nNote that this fix is not perfect, it ~~will still give incorrect~~ won't give suggestions in some situations:\n- If the associated type is defined on a supertrait of those contained in the opaque type, it will fallback to the previous behaviour, e.g. if `AssocTy` is defined on the trait `Foo`, `Bar` has `Foo` as supertrait and the opaque type is a `impl Bar + Baz`.\n- If the the associated type is defined on a generic trait and the opaque type includes two versions of that generic trait, e.g. the opaque type is `impl Foo<A> + Foo<B>`", "tree": {"sha": "562e1aad089ca0d69b757af6665f2a1e003d0500", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/562e1aad089ca0d69b757af6665f2a1e003d0500"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4d8f0e3493d65f8d8d4121dd868402a1365d951", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg/EUsCRBK7hj4Ov3rIwAA92sIAIFHrLIxFuT0AkePeHwCmes8\nBBZ7CPBgviPJvLJUDfwVM0FKpY7qYXgvZ/xIWWazIQyQZOswoTS0rzbjJjgYxKcT\n3YNXyvtsJOZ9hjSoqJY2hjm53jdeCB6YT/K6qCuCfNY6U0qIwMDmdTOyrtihasEo\nAB9luXyj6j0ufGjF3MhOUPO6oRCMIJfm5hWpJxlTPiXFXg1k3lXbwZbHWx7Qdyer\no1TfCdWSu/rvUVuQfQRSRMWgV82o8roh1XOj09qlUytSsN3Z8U9aYXmG/amdAVlO\nb6Lq/3IIKVVTvqFlRJTcEh4EjpAjJcRGhfz1+o+Rd5gzs5FbQRVZcTenC5NntWA=\n=uAS9\n-----END PGP SIGNATURE-----\n", "payload": "tree 562e1aad089ca0d69b757af6665f2a1e003d0500\nparent 18840b0719aa766a1bc49ea2eb5dc2e4cde7da3f\nparent d1bc9413858b334b6cdaf345bd6b50cb9aa4cec2\nauthor Manish Goregaokar <manishsmail@gmail.com> 1627145516 -0700\ncommitter GitHub <noreply@github.com> 1627145516 -0700\n\nRollup merge of #87348 - SkiFire13:fix-87261, r=oli-obk\n\nFix span when suggesting to add an associated type bound\n\nFixes #87261\n\nNote that this fix is not perfect, it ~~will still give incorrect~~ won't give suggestions in some situations:\n- If the associated type is defined on a supertrait of those contained in the opaque type, it will fallback to the previous behaviour, e.g. if `AssocTy` is defined on the trait `Foo`, `Bar` has `Foo` as supertrait and the opaque type is a `impl Bar + Baz`.\n- If the the associated type is defined on a generic trait and the opaque type includes two versions of that generic trait, e.g. the opaque type is `impl Foo<A> + Foo<B>`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d8f0e3493d65f8d8d4121dd868402a1365d951", "html_url": "https://github.com/rust-lang/rust/commit/e4d8f0e3493d65f8d8d4121dd868402a1365d951", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4d8f0e3493d65f8d8d4121dd868402a1365d951/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18840b0719aa766a1bc49ea2eb5dc2e4cde7da3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/18840b0719aa766a1bc49ea2eb5dc2e4cde7da3f", "html_url": "https://github.com/rust-lang/rust/commit/18840b0719aa766a1bc49ea2eb5dc2e4cde7da3f"}, {"sha": "d1bc9413858b334b6cdaf345bd6b50cb9aa4cec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1bc9413858b334b6cdaf345bd6b50cb9aa4cec2", "html_url": "https://github.com/rust-lang/rust/commit/d1bc9413858b334b6cdaf345bd6b50cb9aa4cec2"}], "stats": {"total": 402, "additions": 382, "deletions": 20}, "files": [{"sha": "f1c7c1ea852a285e08c3f12dbbf24aedcc47e0e9", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e4d8f0e3493d65f8d8d4121dd868402a1365d951/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d8f0e3493d65f8d8d4121dd868402a1365d951/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=e4d8f0e3493d65f8d8d4121dd868402a1365d951", "patch": "@@ -628,6 +628,7 @@ impl<T> Trait<T> for X {\n                             assoc_substs,\n                             ty,\n                             msg,\n+                            false,\n                         ) {\n                             return true;\n                         }\n@@ -646,6 +647,7 @@ impl<T> Trait<T> for X {\n                             assoc_substs,\n                             ty,\n                             msg,\n+                            false,\n                         );\n                     }\n                 }\n@@ -771,13 +773,24 @@ fn foo(&self) -> Self::T { String::new() }\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.item_def_id);\n         if let ty::Opaque(def_id, _) = *proj_ty.self_ty().kind() {\n-            self.constrain_associated_type_structured_suggestion(\n+            let opaque_local_def_id = def_id.expect_local();\n+            let opaque_hir_id = self.hir().local_def_id_to_hir_id(opaque_local_def_id);\n+            let opaque_hir_ty = match &self.hir().expect_item(opaque_hir_id).kind {\n+                hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n+                _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n+            };\n+\n+            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n+\n+            self.constrain_generic_bound_associated_type_structured_suggestion(\n                 db,\n-                self.def_span(def_id),\n-                &assoc,\n-                proj_ty.trait_ref_and_own_substs(self).1,\n+                &trait_ref,\n+                opaque_hir_ty.bounds,\n+                assoc,\n+                assoc_substs,\n                 ty,\n-                &msg,\n+                msg,\n+                true,\n             )\n         } else {\n             false\n@@ -899,6 +912,11 @@ fn foo(&self) -> Self::T { String::new() }\n \n     /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n     /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n+    ///\n+    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n+    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n+    /// trait bound as the one we're looking for. This can help in cases where the associated\n+    /// type is defined on a supertrait of the one present in the bounds.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n         self,\n         db: &mut DiagnosticBuilder<'_>,\n@@ -908,23 +926,30 @@ fn foo(&self) -> Self::T { String::new() }\n         assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n+        is_bound_surely_present: bool,\n     ) -> bool {\n         // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n-        bounds.iter().any(|bound| match bound {\n-            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => {\n-                // Relate the type param against `T` in `<A as T>::Foo`.\n-                ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id)\n-                    && self.constrain_associated_type_structured_suggestion(\n-                        db,\n-                        ptr.span,\n-                        assoc,\n-                        assoc_substs,\n-                        ty,\n-                        msg,\n-                    )\n-            }\n-            _ => false,\n-        })\n+\n+        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n+            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n+            _ => None,\n+        });\n+\n+        let matching_trait_bounds = trait_bounds\n+            .clone()\n+            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n+            .collect::<Vec<_>>();\n+\n+        let span = match &matching_trait_bounds[..] {\n+            &[ptr] => ptr.span,\n+            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n+                &[ptr] => ptr.span,\n+                _ => return false,\n+            },\n+            _ => return false,\n+        };\n+\n+        self.constrain_associated_type_structured_suggestion(db, span, assoc, assoc_substs, ty, msg)\n     }\n \n     /// Given a span corresponding to a bound, provide a structured suggestion to set an"}, {"sha": "a70f771e4826f14c33b4900ecbb8a76765e0df21", "filename": "src/test/ui/associated-types/issue-87261.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e4d8f0e3493d65f8d8d4121dd868402a1365d951/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d8f0e3493d65f8d8d4121dd868402a1365d951/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs?ref=e4d8f0e3493d65f8d8d4121dd868402a1365d951", "patch": "@@ -0,0 +1,99 @@\n+trait Foo {}\n+\n+trait Trait {\n+    type Associated;\n+}\n+trait DerivedTrait: Trait {}\n+trait GenericTrait<A> {\n+    type Associated;\n+}\n+\n+struct Impl;\n+impl Foo for Impl {}\n+impl Trait for Impl {\n+    type Associated = ();\n+}\n+impl DerivedTrait for Impl {}\n+impl<A> GenericTrait<A> for Impl {\n+    type Associated = ();\n+}\n+\n+fn returns_opaque() -> impl Trait + 'static {\n+    Impl\n+}\n+fn returns_opaque_derived() -> impl DerivedTrait + 'static {\n+    Impl\n+}\n+fn returns_opaque_foo() -> impl Trait + Foo {\n+    Impl\n+}\n+fn returns_opaque_derived_foo() -> impl DerivedTrait + Foo {\n+    Impl\n+}\n+fn returns_opaque_generic() -> impl GenericTrait<()> + 'static {\n+    Impl\n+}\n+fn returns_opaque_generic_foo() -> impl GenericTrait<()> + Foo {\n+    Impl\n+}\n+fn returns_opaque_generic_duplicate() -> impl GenericTrait<()> + GenericTrait<u8> {\n+    Impl\n+}\n+\n+fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+\n+fn check_generics<A, B, C, D, E, F, G>(a: A, b: B, c: C, d: D, e: E, f: F, g: G)\n+where\n+    A: Trait + 'static,\n+    B: DerivedTrait + 'static,\n+    C: Trait + Foo,\n+    D: DerivedTrait + Foo,\n+    E: GenericTrait<()> + 'static,\n+    F: GenericTrait<()> + Foo,\n+    G: GenericTrait<()> + GenericTrait<u8>,\n+{\n+    accepts_trait(a);\n+    //~^ ERROR type mismatch resolving `<A as Trait>::Associated == ()`\n+\n+    accepts_trait(b);\n+    //~^ ERROR type mismatch resolving `<B as Trait>::Associated == ()`\n+\n+    accepts_trait(c);\n+    //~^ ERROR type mismatch resolving `<C as Trait>::Associated == ()`\n+\n+    accepts_trait(d);\n+    //~^ ERROR type mismatch resolving `<D as Trait>::Associated == ()`\n+\n+    accepts_generic_trait(e);\n+    //~^ ERROR type mismatch resolving `<E as GenericTrait<()>>::Associated == ()`\n+\n+    accepts_generic_trait(f);\n+    //~^ ERROR type mismatch resolving `<F as GenericTrait<()>>::Associated == ()`\n+\n+    accepts_generic_trait(g);\n+    //~^ ERROR type mismatch resolving `<G as GenericTrait<()>>::Associated == ()`\n+}\n+\n+fn main() {\n+    accepts_trait(returns_opaque());\n+    //~^ ERROR type mismatch resolving `<impl Trait as Trait>::Associated == ()`\n+\n+    accepts_trait(returns_opaque_derived());\n+    //~^ ERROR type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n+\n+    accepts_trait(returns_opaque_foo());\n+    //~^ ERROR type mismatch resolving `<impl Trait+Foo as Trait>::Associated == ()`\n+\n+    accepts_trait(returns_opaque_derived_foo());\n+    //~^ ERROR type mismatch resolving `<impl DerivedTrait+Foo as Trait>::Associated == ()`\n+\n+    accepts_generic_trait(returns_opaque_generic());\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+\n+    accepts_generic_trait(returns_opaque_generic_foo());\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated == ()`\n+\n+    accepts_generic_trait(returns_opaque_generic_duplicate());\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n+}"}, {"sha": "0725acfe537dbb5022373d594bca2e4c91eff7af", "filename": "src/test/ui/associated-types/issue-87261.stderr", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/e4d8f0e3493d65f8d8d4121dd868402a1365d951/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4d8f0e3493d65f8d8d4121dd868402a1365d951/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr?ref=e4d8f0e3493d65f8d8d4121dd868402a1365d951", "patch": "@@ -0,0 +1,238 @@\n+error[E0271]: type mismatch resolving `<A as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:56:5\n+   |\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(a);\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<A as Trait>::Associated`\n+help: consider constraining the associated type `<A as Trait>::Associated` to `()`\n+   |\n+LL |     A: Trait<Associated = ()> + 'static,\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<B as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:59:5\n+   |\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(b);\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<B as Trait>::Associated`\n+   = help: consider constraining the associated type `<B as Trait>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error[E0271]: type mismatch resolving `<C as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:62:5\n+   |\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(c);\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<C as Trait>::Associated`\n+help: consider constraining the associated type `<C as Trait>::Associated` to `()`\n+   |\n+LL |     C: Trait<Associated = ()> + Foo,\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<D as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:65:5\n+   |\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(d);\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<D as Trait>::Associated`\n+   = help: consider constraining the associated type `<D as Trait>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error[E0271]: type mismatch resolving `<E as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:68:5\n+   |\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(e);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<E as GenericTrait<()>>::Associated`\n+help: consider constraining the associated type `<E as GenericTrait<()>>::Associated` to `()`\n+   |\n+LL |     E: GenericTrait<(), Associated = ()> + 'static,\n+   |                       ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<F as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:71:5\n+   |\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(f);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<F as GenericTrait<()>>::Associated`\n+help: consider constraining the associated type `<F as GenericTrait<()>>::Associated` to `()`\n+   |\n+LL |     F: GenericTrait<(), Associated = ()> + Foo,\n+   |                       ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<G as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:74:5\n+   |\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(g);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<G as GenericTrait<()>>::Associated`\n+   = help: consider constraining the associated type `<G as GenericTrait<()>>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error[E0271]: type mismatch resolving `<impl Trait as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:79:5\n+   |\n+LL | fn returns_opaque() -> impl Trait + 'static {\n+   |                        -------------------- the found opaque type\n+...\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(returns_opaque());\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl Trait as Trait>::Associated`\n+help: consider constraining the associated type `<impl Trait as Trait>::Associated` to `()`\n+   |\n+LL | fn returns_opaque() -> impl Trait<Associated = ()> + 'static {\n+   |                                  ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:82:5\n+   |\n+LL | fn returns_opaque_derived() -> impl DerivedTrait + 'static {\n+   |                                --------------------------- the found opaque type\n+...\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(returns_opaque_derived());\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl DerivedTrait as Trait>::Associated`\n+help: consider constraining the associated type `<impl DerivedTrait as Trait>::Associated` to `()`\n+   |\n+LL | fn returns_opaque_derived() -> impl DerivedTrait<Associated = ()> + 'static {\n+   |                                                 ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl Trait+Foo as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:85:5\n+   |\n+LL | fn returns_opaque_foo() -> impl Trait + Foo {\n+   |                            ---------------- the found opaque type\n+...\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(returns_opaque_foo());\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl Trait+Foo as Trait>::Associated`\n+help: consider constraining the associated type `<impl Trait+Foo as Trait>::Associated` to `()`\n+   |\n+LL | fn returns_opaque_foo() -> impl Trait<Associated = ()> + Foo {\n+   |                                      ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl DerivedTrait+Foo as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:88:5\n+   |\n+LL | fn returns_opaque_derived_foo() -> impl DerivedTrait + Foo {\n+   |                                    ----------------------- the found opaque type\n+...\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(returns_opaque_derived_foo());\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl DerivedTrait+Foo as Trait>::Associated`\n+   = help: consider constraining the associated type `<impl DerivedTrait+Foo as Trait>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:91:5\n+   |\n+LL | fn returns_opaque_generic() -> impl GenericTrait<()> + 'static {\n+   |                                ------------------------------- the found opaque type\n+...\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(returns_opaque_generic());\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl GenericTrait<()> as GenericTrait<()>>::Associated`\n+help: consider constraining the associated type `<impl GenericTrait<()> as GenericTrait<()>>::Associated` to `()`\n+   |\n+LL | fn returns_opaque_generic() -> impl GenericTrait<(), Associated = ()> + 'static {\n+   |                                                    ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:94:5\n+   |\n+LL | fn returns_opaque_generic_foo() -> impl GenericTrait<()> + Foo {\n+   |                                    --------------------------- the found opaque type\n+...\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(returns_opaque_generic_foo());\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated`\n+help: consider constraining the associated type `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated` to `()`\n+   |\n+LL | fn returns_opaque_generic_foo() -> impl GenericTrait<(), Associated = ()> + Foo {\n+   |                                                        ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:97:5\n+   |\n+LL | fn returns_opaque_generic_duplicate() -> impl GenericTrait<()> + GenericTrait<u8> {\n+   |                                          ---------------------------------------- the found opaque type\n+...\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(returns_opaque_generic_duplicate());\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated`\n+   = help: consider constraining the associated type `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error: aborting due to 14 previous errors\n+\n+For more information about this error, try `rustc --explain E0271`."}]}