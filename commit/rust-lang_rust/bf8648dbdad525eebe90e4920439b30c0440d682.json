{"sha": "bf8648dbdad525eebe90e4920439b30c0440d682", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmODY0OGRiZGFkNTI1ZWViZTkwZTQ5MjA0MzliMzBjMDQ0MGQ2ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-18T08:16:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-18T08:16:27Z"}, "message": "auto merge of #14121 : luqmana/rust/option-ffi, r=alexcrichton\n\nThis slightly adjusts the NullablePointer representation for some enums in the case where the non-nullable variant has a single field (the ptr field) to be just that, the pointer. This is in contrast to the current behaviour where we'd wrap that single pointer in a LLVM struct.\r\n\r\nFixes #11040 & #11303.", "tree": {"sha": "86411931738908873892232ef291eeddbba8f288", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86411931738908873892232ef291eeddbba8f288"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf8648dbdad525eebe90e4920439b30c0440d682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf8648dbdad525eebe90e4920439b30c0440d682", "html_url": "https://github.com/rust-lang/rust/commit/bf8648dbdad525eebe90e4920439b30c0440d682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf8648dbdad525eebe90e4920439b30c0440d682/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a62395f01ca4f2db1b9004aa4f54422956950304", "url": "https://api.github.com/repos/rust-lang/rust/commits/a62395f01ca4f2db1b9004aa4f54422956950304", "html_url": "https://github.com/rust-lang/rust/commit/a62395f01ca4f2db1b9004aa4f54422956950304"}, {"sha": "be79edba71ed5f6021ba20f55a03f5d7474ef86b", "url": "https://api.github.com/repos/rust-lang/rust/commits/be79edba71ed5f6021ba20f55a03f5d7474ef86b", "html_url": "https://github.com/rust-lang/rust/commit/be79edba71ed5f6021ba20f55a03f5d7474ef86b"}], "stats": {"total": 217, "additions": 158, "deletions": 59}, "files": [{"sha": "9cea6d0249cc4374d8ea550ca31388a310e5acaa", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 103, "deletions": 44, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=bf8648dbdad525eebe90e4920439b30c0440d682", "patch": "@@ -85,6 +85,18 @@ pub enum Repr {\n      * all start with a field for the discriminant.\n      */\n     General(IntType, Vec<Struct>),\n+    /**\n+     * Two cases distinguished by a nullable pointer: the case with discriminant\n+     * `nndiscr` must have single field which is known to be nonnull due to its type.\n+     * The other case is known to be zero sized. Hence we represent the enum\n+     * as simply a nullable pointer: if not null it indicates the `nndiscr` variant,\n+     * otherwise it indicates the other case.\n+     */\n+    RawNullablePointer {\n+        pub nndiscr: Disr,\n+        pub nnty: ty::t,\n+        pub nullfields: Vec<ty::t>\n+    },\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n@@ -96,7 +108,7 @@ pub enum Repr {\n      * is represented such that `None` is a null pointer and `Some` is the\n      * identity function.\n      */\n-    NullablePointer {\n+    StructWrappedNullablePointer {\n         pub nonnull: Struct,\n         pub nndiscr: Disr,\n         pub ptrfield: uint,\n@@ -200,17 +212,23 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                     if cases.get(1 - discr).is_zerolen(cx) {\n                         match cases.get(discr).find_ptr() {\n                             Some(ptrfield) => {\n-                                return NullablePointer {\n-                                    nndiscr: discr as u64,\n-                                    nonnull: mk_struct(cx,\n-                                                       cases.get(discr)\n-                                                            .tys\n-                                                            .as_slice(),\n-                                                       false),\n-                                    ptrfield: ptrfield,\n-                                    nullfields: cases.get(1 - discr).tys\n-                                                                    .clone()\n-                                }\n+                                let st = mk_struct(cx, cases.get(discr).tys.as_slice(),\n+                                                   false);\n+\n+                                return if st.fields.len() == 1 {\n+                                    RawNullablePointer {\n+                                        nndiscr: discr as Disr,\n+                                        nnty: *st.fields.get(0),\n+                                        nullfields: cases.get(1 - discr).tys.clone()\n+                                    }\n+                                } else {\n+                                    StructWrappedNullablePointer {\n+                                        nndiscr: discr as Disr,\n+                                        nonnull: st,\n+                                        ptrfield: ptrfield,\n+                                        nullfields: cases.get(1 - discr).tys.clone()\n+                                    }\n+                                };\n                             }\n                             None => { }\n                         }\n@@ -413,8 +431,8 @@ pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n }\n pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n-        CEnum(..) | General(..) => { }\n-        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } =>\n+        CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n+        Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n             llty.set_struct_body(struct_llfields(cx, st, false).as_slice(),\n                                  st.packed)\n     }\n@@ -423,7 +441,8 @@ pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n-        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n+        RawNullablePointer { nnty, .. } => type_of::sizing_type_of(cx, nnty),\n+        Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n                     Type::struct_(cx, struct_llfields(cx, st, sizing).as_slice(),\n@@ -495,12 +514,10 @@ fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> Vec<Type> {\n pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n-        CEnum(..) | General(..) => {\n+        CEnum(..) | General(..) |\n+        RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n             (_match::switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n-            (_match::switch, Some(nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee)))\n-        }\n         Univariant(..) => {\n             (_match::single, None)\n         }\n@@ -528,8 +545,14 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n             val = C_u8(bcx.ccx(), 0);\n             signed = false;\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n-            val = nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n+        RawNullablePointer { nndiscr, nnty, .. } =>  {\n+            let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n+            let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n+            val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty));\n+            signed = false;\n+        }\n+        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n+            val = struct_wrapped_nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n             signed = false;\n         }\n     }\n@@ -539,10 +562,10 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n     }\n }\n \n-fn nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n-                     scrutinee: ValueRef) -> ValueRef {\n-    let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n+fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n+                                    scrutinee: ValueRef) -> ValueRef {\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n+    let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptrty = type_of::type_of(bcx.ccx(), *nonnull.fields.get(ptrfield));\n     ICmp(bcx, cmp, llptr, C_null(llptrty))\n }\n@@ -590,7 +613,8 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n         Univariant(..) => {\n             bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n         }\n-        NullablePointer{ .. } => {\n+        RawNullablePointer { .. } |\n+        StructWrappedNullablePointer { .. } => {\n             assert!(discr == 0 || discr == 1);\n             _match::single_result(Result::new(bcx, C_i1(bcx.ccx(), discr != 0)))\n         }\n@@ -621,7 +645,13 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         Univariant(..) => {\n             assert_eq!(discr, 0);\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n+        RawNullablePointer { nndiscr, nnty, ..} => {\n+            if discr != nndiscr {\n+                let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n+                Store(bcx, C_null(llptrty), val)\n+            }\n+        }\n+        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             if discr != nndiscr {\n                 let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n                 let llptrty = type_of::type_of(bcx.ccx(),\n@@ -651,8 +681,11 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(_, ref cases) => cases.get(discr as uint).fields.len() - 1,\n-        NullablePointer{ nonnull: ref nonnull, nndiscr,\n-                         nullfields: ref nullfields, .. } => {\n+        RawNullablePointer { nndiscr, ref nullfields, .. } => {\n+            if discr == nndiscr { 1 } else { nullfields.len() }\n+        }\n+        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr,\n+                                       nullfields: ref nullfields, .. } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n         }\n     }\n@@ -675,19 +708,25 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n         General(_, ref cases) => {\n             struct_field_ptr(bcx, cases.get(discr as uint), val, ix + 1, true)\n         }\n-        NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields,\n-                         nndiscr, .. } => {\n-            if discr == nndiscr {\n-                struct_field_ptr(bcx, nonnull, val, ix, false)\n-            } else {\n-                // The unit-like case might have a nonzero number of unit-like fields.\n-                // (e.g., Result or Either with () as one side.)\n-                let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n-                assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n-                // The contents of memory at this pointer can't matter, but use\n-                // the value that's \"reasonable\" in case of pointer comparison.\n-                PointerCast(bcx, val, ty.ptr_to())\n-            }\n+        RawNullablePointer { nndiscr, ref nullfields, .. } |\n+        StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n+            // The unit-like case might have a nonzero number of unit-like fields.\n+            // (e.d., Result of Either with (), as one side.)\n+            let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n+            assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n+            // The contents of memory at this pointer can't matter, but use\n+            // the value that's \"reasonable\" in case of pointer comparision.\n+            PointerCast(bcx, val, ty.ptr_to())\n+        }\n+        RawNullablePointer { nndiscr, nnty, .. } => {\n+            assert_eq!(ix, 0);\n+            assert_eq!(discr, nndiscr);\n+            let ty = type_of::type_of(bcx.ccx(), nnty);\n+            PointerCast(bcx, val, ty.ptr_to())\n+        }\n+        StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+            assert_eq!(discr, nndiscr);\n+            struct_field_ptr(bcx, nonnull, val, ix, false)\n         }\n     }\n }\n@@ -759,7 +798,15 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             let contents = build_const_struct(ccx, st, vals);\n             C_struct(ccx, contents.as_slice(), st.packed)\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, .. } => {\n+        RawNullablePointer { nndiscr, nnty, .. } => {\n+            if discr == nndiscr {\n+                assert_eq!(vals.len(), 1);\n+                vals[0]\n+            } else {\n+                C_null(type_of::sizing_type_of(ccx, nnty))\n+            }\n+        }\n+        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n@@ -867,7 +914,15 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n             }\n         }\n         Univariant(..) => 0,\n-        NullablePointer{ nndiscr, ptrfield, .. } => {\n+        RawNullablePointer { nndiscr, .. } => {\n+            if is_null(val) {\n+                /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n+                (1 - nndiscr) as Disr\n+            } else {\n+                nndiscr\n+            }\n+        }\n+        StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n             if is_null(const_struct_field(ccx, val, ptrfield)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n                 (1 - nndiscr) as Disr\n@@ -891,7 +946,11 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(ccx, val, ix),\n         General(..) => const_struct_field(ccx, val, ix + 1),\n-        NullablePointer{ .. } => const_struct_field(ccx, val, ix)\n+        RawNullablePointer { .. } => {\n+            assert_eq!(ix, 0);\n+            val\n+        }\n+        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix)\n     }\n }\n "}, {"sha": "ff43e4f9abb4c181bfea5ccbd942d6a9c2ed95de", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=bf8648dbdad525eebe90e4920439b30c0440d682", "patch": "@@ -1675,7 +1675,10 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 }),\n             }\n         }\n-        adt::NullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n+        adt::RawNullablePointer { nnty, .. } => {\n+            FinalMetadata(type_metadata(cx, nnty, span))\n+        }\n+        adt::StructWrappedNullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n             let (metadata_stub,\n                  variant_llvm_type,\n                  member_description_factory) ="}, {"sha": "803d0aed593a3d8439e2cb379ecfb9c16b7371b6", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=bf8648dbdad525eebe90e4920439b30c0440d682", "patch": "@@ -16,10 +16,10 @@\n // gdb-command:finish\n \n // gdb-command:print some\n-// gdb-check:$1 = {0x12345678}\n+// gdb-check:$1 = (u32 *) 0x12345678\n \n // gdb-command:print none\n-// gdb-check:$2 = {0x0}\n+// gdb-check:$2 = (u32 *) 0x0\n \n // gdb-command:print full\n // gdb-check:$3 = {454545, 0x87654321, 9988}\n@@ -41,6 +41,8 @@\n // contains a non-nullable pointer, then this value is used as the discriminator.\n // The test cases in this file make sure that something readable is generated for\n // this kind of types.\n+// If the non-empty variant contains a single non-nullable pointer than the whole\n+// item is represented as just a pointer and not wrapped in a struct.\n // Unfortunately (for these test cases) the content of the non-discriminant fields\n // in the null-case is not defined. So we just read the discriminator field in\n // this case (by casting the value to a memory-equivalent struct)."}, {"sha": "aa13072eb5316606935026b6d77aa9ca5ef61478", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=bf8648dbdad525eebe90e4920439b30c0440d682", "patch": "@@ -20,53 +20,53 @@\n \n // gdb-command:print stack_unique.value\n // gdb-check:$1 = 0\n-// gdb-command:print stack_unique.next.val->value\n+// gdb-command:print stack_unique.next->value\n // gdb-check:$2 = 1\n \n // gdb-command:print unique_unique->value\n // gdb-check:$3 = 2\n-// gdb-command:print unique_unique->next.val->value\n+// gdb-command:print unique_unique->next->value\n // gdb-check:$4 = 3\n \n // gdb-command:print box_unique->val.value\n // gdb-check:$5 = 4\n-// gdb-command:print box_unique->val.next.val->value\n+// gdb-command:print box_unique->val.next->value\n // gdb-check:$6 = 5\n \n // gdb-command:print vec_unique[0].value\n // gdb-check:$7 = 6.5\n-// gdb-command:print vec_unique[0].next.val->value\n+// gdb-command:print vec_unique[0].next->value\n // gdb-check:$8 = 7.5\n \n // gdb-command:print borrowed_unique->value\n // gdb-check:$9 = 8.5\n-// gdb-command:print borrowed_unique->next.val->value\n+// gdb-command:print borrowed_unique->next->value\n // gdb-check:$10 = 9.5\n \n // MANAGED\n // gdb-command:print stack_managed.value\n // gdb-check:$11 = 10\n-// gdb-command:print stack_managed.next.val->val.value\n+// gdb-command:print stack_managed.next.val->value\n // gdb-check:$12 = 11\n \n // gdb-command:print unique_managed->value\n // gdb-check:$13 = 12\n-// gdb-command:print unique_managed->next.val->val.value\n+// gdb-command:print unique_managed->next.val->value\n // gdb-check:$14 = 13\n \n-// gdb-command:print box_managed->val.value\n+// gdb-command:print box_managed.val->value\n // gdb-check:$15 = 14\n-// gdb-command:print box_managed->val.next.val->val.value\n+// gdb-command:print box_managed->val->next.val->value\n // gdb-check:$16 = 15\n \n // gdb-command:print vec_managed[0].value\n // gdb-check:$17 = 16.5\n-// gdb-command:print vec_managed[0].next.val->val.value\n+// gdb-command:print vec_managed[0].next.val->value\n // gdb-check:$18 = 17.5\n \n // gdb-command:print borrowed_managed->value\n // gdb-check:$19 = 18.5\n-// gdb-command:print borrowed_managed->next.val->val.value\n+// gdb-command:print borrowed_managed->next.val->value\n // gdb-check:$20 = 19.5\n \n // LONG CYCLE\n@@ -97,7 +97,7 @@\n // gdb-command:print (*****long_cycle_w_anonymous_types).value\n // gdb-check:$31 = 30\n \n-// gdb-command:print (*****((*****long_cycle_w_anonymous_types).next.val)).value\n+// gdb-command:print (*****((*****long_cycle_w_anonymous_types).next)).value\n // gdb-check:$32 = 31\n \n // gdb-command:continue"}, {"sha": "548a16bd1205bf14b4164d6446ae1cb064081de1", "filename": "src/test/run-pass/nullable-pointer-ffi-compat.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8648dbdad525eebe90e4920439b30c0440d682/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs?ref=bf8648dbdad525eebe90e4920439b30c0440d682", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// #11303, #11040:\n+// This would previously crash on i686 linux due to abi differences\n+// between returning an Option<T> and T, where T is a non nullable\n+// pointer.\n+// If we have an enum with two variants such that one is zero sized\n+// and the other contains a nonnullable pointer, we don't use a\n+// separate discriminant. Instead we use that pointer field to differentiate\n+// between the 2 cases.\n+// Also, if the variant with the nonnullable pointer has no other fields\n+// then we simply express the enum as just a pointer and not wrap it\n+// in a struct.\n+\n+use std::mem;\n+\n+#[inline(never)]\n+extern \"C\" fn foo<'a>(x: &'a int) -> Option<&'a int> { Some(x) }\n+\n+static FOO: int = 0xDEADBEE;\n+\n+pub fn main() {\n+    unsafe {\n+        let f: extern \"C\" fn<'a>(&'a int) -> &'a int = mem::transmute(foo);\n+        assert_eq!(*f(&FOO), FOO);\n+    }\n+}"}]}