{"sha": "d891e70b6421e2ef48a64badf3e432059a5c4b96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4OTFlNzBiNjQyMWUyZWY0OGE2NGJhZGYzZTQzMjA1OWE1YzRiOTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T01:52:09Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:15:11Z"}, "message": "typeck/pat.rs: extract `check_pat_lit`.", "tree": {"sha": "6b9c523c2b7b1ba409376ef4bee44ae35dbb3bd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b9c523c2b7b1ba409376ef4bee44ae35dbb3bd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d891e70b6421e2ef48a64badf3e432059a5c4b96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d891e70b6421e2ef48a64badf3e432059a5c4b96", "html_url": "https://github.com/rust-lang/rust/commit/d891e70b6421e2ef48a64badf3e432059a5c4b96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d891e70b6421e2ef48a64badf3e432059a5c4b96/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23dc37d21d392b7f796a495f8616e32ca558d578", "url": "https://api.github.com/repos/rust-lang/rust/commits/23dc37d21d392b7f796a495f8616e32ca558d578", "html_url": "https://github.com/rust-lang/rust/commit/23dc37d21d392b7f796a495f8616e32ca558d578"}], "stats": {"total": 98, "additions": 55, "deletions": 43}, "files": [{"sha": "95013f60cd6de0e694b9756eb15561c47c296573", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 55, "deletions": 43, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d891e70b6421e2ef48a64badf3e432059a5c4b96/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d891e70b6421e2ef48a64badf3e432059a5c4b96/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=d891e70b6421e2ef48a64badf3e432059a5c4b96", "patch": "@@ -68,49 +68,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected\n             }\n             PatKind::Lit(ref lt) => {\n-                // We've already computed the type above (when checking for a non-ref pat), so\n-                // avoid computing it again.\n-                let ty = self.node_ty(lt.hir_id);\n-\n-                // Byte string patterns behave the same way as array patterns\n-                // They can denote both statically and dynamically-sized byte arrays.\n-                let mut pat_ty = ty;\n-                if let hir::ExprKind::Lit(ref lt) = lt.node {\n-                    if let ast::LitKind::ByteStr(_) = lt.node {\n-                        let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                        if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n-                            if let ty::Slice(_) = r_ty.sty {\n-                                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static,\n-                                                        tcx.mk_slice(tcx.types.u8))\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Somewhat surprising: in this case, the subtyping\n-                // relation goes the opposite way as the other\n-                // cases. Actually what we really want is not a subtyping\n-                // relation at all but rather that there exists a LUB (so\n-                // that they can be compared). However, in practice,\n-                // constants are always scalars or strings.  For scalars\n-                // subtyping is irrelevant, and for strings `ty` is\n-                // type is `&'static str`, so if we say that\n-                //\n-                //     &'static str <: expected\n-                //\n-                // then that's equivalent to there existing a LUB.\n-                if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n-                    err.emit_unless(discrim_span\n-                        .filter(|&s| {\n-                            // In the case of `if`- and `while`-expressions we've already checked\n-                            // that `scrutinee: bool`. We know that the pattern is `true`,\n-                            // so an error here would be a duplicate and from the wrong POV.\n-                            s.is_desugaring(DesugaringKind::CondTemporary)\n-                        })\n-                        .is_some());\n-                }\n-\n-                pat_ty\n+                self.check_pat_lit(pat.span, lt, expected, discrim_span)\n             }\n             PatKind::Range(ref begin, ref end, _) => {\n                 let lhs_ty = self.check_expr(begin);\n@@ -586,6 +544,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, def_bm)\n     }\n \n+    fn check_pat_lit(\n+        &self,\n+        span: Span,\n+        lt: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // We've already computed the type above (when checking for a non-ref pat),\n+        // so avoid computing it again.\n+        let ty = self.node_ty(lt.hir_id);\n+\n+        // Byte string patterns behave the same way as array patterns\n+        // They can denote both statically and dynamically-sized byte arrays.\n+        let mut pat_ty = ty;\n+        if let hir::ExprKind::Lit(ref lt) = lt.node {\n+            if let ast::LitKind::ByteStr(_) = lt.node {\n+                let expected_ty = self.structurally_resolved_type(span, expected);\n+                if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n+                    if let ty::Slice(_) = r_ty.sty {\n+                        let tcx = self.tcx;\n+                        pat_ty = tcx.mk_imm_ref(\n+                            tcx.lifetimes.re_static,\n+                            tcx.mk_slice(tcx.types.u8),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Somewhat surprising: in this case, the subtyping relation goes the\n+        // opposite way as the other cases. Actually what we really want is not\n+        // a subtyping relation at all but rather that there exists a LUB\n+        // (so that they can be compared). However, in practice, constants are\n+        // always scalars or strings. For scalars subtyping is irrelevant,\n+        // and for strings `ty` is type is `&'static str`, so if we say that\n+        //\n+        //     &'static str <: expected\n+        //\n+        // then that's equivalent to there existing a LUB.\n+        if let Some(mut err) = self.demand_suptype_diag(span, expected, pat_ty) {\n+            err.emit_unless(discrim_span\n+                .filter(|&s| {\n+                    // In the case of `if`- and `while`-expressions we've already checked\n+                    // that `scrutinee: bool`. We know that the pattern is `true`,\n+                    // so an error here would be a duplicate and from the wrong POV.\n+                    s.is_desugaring(DesugaringKind::CondTemporary)\n+                })\n+                .is_some());\n+        }\n+\n+        pat_ty\n+    }\n+\n+\n     fn borrow_pat_suggestion(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}]}