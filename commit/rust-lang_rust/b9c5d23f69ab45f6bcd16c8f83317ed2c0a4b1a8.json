{"sha": "b9c5d23f69ab45f6bcd16c8f83317ed2c0a4b1a8", "node_id": "C_kwDOAAsO6NoAKGI5YzVkMjNmNjlhYjQ1ZjZiY2QxNmM4ZjgzMzE3ZWQyYzBhNGIxYTg", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-02-07T17:17:28Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-02-07T17:17:28Z"}, "message": "Simplify a bit", "tree": {"sha": "9a863bcdfefcad3cec892ec2333b33fbc873ea90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a863bcdfefcad3cec892ec2333b33fbc873ea90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9c5d23f69ab45f6bcd16c8f83317ed2c0a4b1a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c5d23f69ab45f6bcd16c8f83317ed2c0a4b1a8", "html_url": "https://github.com/rust-lang/rust/commit/b9c5d23f69ab45f6bcd16c8f83317ed2c0a4b1a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9c5d23f69ab45f6bcd16c8f83317ed2c0a4b1a8/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cff209f1520e8ac0270a71814f993bda74668203", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff209f1520e8ac0270a71814f993bda74668203", "html_url": "https://github.com/rust-lang/rust/commit/cff209f1520e8ac0270a71814f993bda74668203"}], "stats": {"total": 28, "additions": 13, "deletions": 15}, "files": [{"sha": "d5639cadc4d326ce965a03e130d8783597be9724", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b9c5d23f69ab45f6bcd16c8f83317ed2c0a4b1a8/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c5d23f69ab45f6bcd16c8f83317ed2c0a4b1a8/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=b9c5d23f69ab45f6bcd16c8f83317ed2c0a4b1a8", "patch": "@@ -484,12 +484,12 @@ impl Convertor {\n     fn new(\n         node: &SyntaxNode,\n         global_offset: TextSize,\n-        replace: FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n-        append: FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n+        mut replace: FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n+        mut append: FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n     ) -> Convertor {\n         let range = node.text_range();\n         let mut preorder = node.preorder_with_tokens();\n-        let (first, synthetic) = Self::next_token(&mut preorder, &replace, &append);\n+        let (first, synthetic) = Self::next_token(&mut preorder, &mut replace, &mut append);\n         Convertor {\n             id_alloc: { TokenIdAlloc { map: TokenMap::default(), global_offset, next_id: 0 } },\n             current: first,\n@@ -504,19 +504,18 @@ impl Convertor {\n \n     fn next_token(\n         preorder: &mut PreorderWithTokens,\n-        replace: &FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n-        append: &FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n+        replace: &mut FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n+        append: &mut FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n     ) -> (Option<SyntaxToken>, Vec<SyntheticToken>) {\n         while let Some(ev) = preorder.next() {\n             let ele = match ev {\n                 WalkEvent::Enter(ele) => ele,\n                 WalkEvent::Leave(SyntaxElement::Node(node)) => {\n-                    if let Some(v) = append.get(&node) {\n+                    if let Some(mut v) = append.remove(&node) {\n                         eprintln!(\"after {:?}, appending {:?}\", node, v);\n                         if !v.is_empty() {\n-                            let mut reversed = v.clone();\n-                            reversed.reverse();\n-                            return (None, reversed);\n+                            v.reverse();\n+                            return (None, v);\n                         }\n                     }\n                     continue;\n@@ -526,13 +525,12 @@ impl Convertor {\n             match ele {\n                 SyntaxElement::Token(t) => return (Some(t), Vec::new()),\n                 SyntaxElement::Node(node) => {\n-                    if let Some(v) = replace.get(&node) {\n+                    if let Some(mut v) = replace.remove(&node) {\n                         preorder.skip_subtree();\n                         eprintln!(\"replacing {:?} by {:?}\", node, v);\n                         if !v.is_empty() {\n-                            let mut reversed = v.clone();\n-                            reversed.reverse();\n-                            return (None, reversed);\n+                            v.reverse();\n+                            return (None, v);\n                         }\n                     }\n                 }\n@@ -603,7 +601,7 @@ impl TokenConvertor for Convertor {\n         if let Some(synth_token) = self.current_synthetic.pop() {\n             if self.current_synthetic.is_empty() {\n                 let (new_current, new_synth) =\n-                    Self::next_token(&mut self.preorder, &self.replace, &self.append);\n+                    Self::next_token(&mut self.preorder, &mut self.replace, &mut self.append);\n                 self.current = new_current;\n                 self.current_synthetic = new_synth;\n             }\n@@ -616,7 +614,7 @@ impl TokenConvertor for Convertor {\n             return None;\n         }\n         let (new_current, new_synth) =\n-            Self::next_token(&mut self.preorder, &self.replace, &self.append);\n+            Self::next_token(&mut self.preorder, &mut self.replace, &mut self.append);\n         self.current = new_current;\n         self.current_synthetic = new_synth;\n         let token = if curr.kind().is_punct() {"}]}