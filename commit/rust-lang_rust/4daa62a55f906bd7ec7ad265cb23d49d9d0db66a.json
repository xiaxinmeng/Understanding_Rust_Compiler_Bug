{"sha": "4daa62a55f906bd7ec7ad265cb23d49d9d0db66a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYWE2MmE1NWY5MDZiZDdlYzdhZDI2NWNiMjNkNDlkOWQwZGI2NmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-18T19:54:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-18T19:54:24Z"}, "message": "Auto merge of #25230 - rayglover:patch-bitset, r=Gankro\n\nSome modest running-time improvements to `std::collections::BitSet` on bit-sets of varying set-membership densities. This is work originally from [here](https://github.com/rayglover/alt_collections). (Benchmarks copied below)\r\n```\r\nstd::collections::BitSet / alt_collections::BitSet\r\n\r\ncopy_dense         ... 3.08x\r\ncopy_sparse        ... 4.22x\r\ncount_dense        ... 11.01x\r\ncount_sparse       ... 8.11x\r\nfrom_bytes         ... 1.47x\r\nintersect_dense    ... 6.54x\r\nintersect_sparse   ... 4.37x\r\nunion_dense        ... 5.53x\r\nunion_sparse       ... 5.60x\r\n```\r\n\r\nThe exception is `from_bytes`, which I've left unaltered since the optimization is rather obscure.\r\n\r\nCompiling with the cpu feature `popcnt` gave a further ~10% improvement on my machine, but this wasn't factored in to the benchmarks above.\r\n\r\nSimilar improvements could be made to `BitVec`, although that would probably require more substantial changes.\r\n\r\ncriticism welcome!", "tree": {"sha": "151e41c763c3f5344f91fd5e8683858c91b6bc93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/151e41c763c3f5344f91fd5e8683858c91b6bc93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4daa62a55f906bd7ec7ad265cb23d49d9d0db66a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4daa62a55f906bd7ec7ad265cb23d49d9d0db66a", "html_url": "https://github.com/rust-lang/rust/commit/4daa62a55f906bd7ec7ad265cb23d49d9d0db66a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4daa62a55f906bd7ec7ad265cb23d49d9d0db66a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a", "html_url": "https://github.com/rust-lang/rust/commit/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a"}, {"sha": "307fab1aa7540adf8856670c5a1cf44ff508ae2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/307fab1aa7540adf8856670c5a1cf44ff508ae2f", "html_url": "https://github.com/rust-lang/rust/commit/307fab1aa7540adf8856670c5a1cf44ff508ae2f"}], "stats": {"total": 157, "additions": 83, "deletions": 74}, "files": [{"sha": "c06cbdb4179d5a799d254fdcdef41e5f46611c30", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 83, "deletions": 74, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/4daa62a55f906bd7ec7ad265cb23d49d9d0db66a/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4daa62a55f906bd7ec7ad265cb23d49d9d0db66a/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=4daa62a55f906bd7ec7ad265cb23d49d9d0db66a", "patch": "@@ -1555,7 +1555,7 @@ impl BitSet {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> bit_set::Iter {\n-        SetIter {set: self, next_idx: 0}\n+        SetIter(BlockIter::from_blocks(self.bit_vec.blocks()))\n     }\n \n     /// Iterator over each usize stored in `self` union `other`.\n@@ -1580,13 +1580,11 @@ impl BitSet {\n     pub fn union<'a>(&'a self, other: &'a BitSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n-        Union(TwoBitPositions {\n-            set: self,\n-            other: other,\n+        Union(BlockIter::from_blocks(TwoBitPositions {\n+            set: self.bit_vec.blocks(),\n+            other: other.bit_vec.blocks(),\n             merge: or,\n-            current_word: 0,\n-            next_idx: 0\n-        })\n+        }))\n     }\n \n     /// Iterator over each usize stored in `self` intersect `other`.\n@@ -1611,13 +1609,12 @@ impl BitSet {\n     pub fn intersection<'a>(&'a self, other: &'a BitSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n         let min = cmp::min(self.bit_vec.len(), other.bit_vec.len());\n-        Intersection(TwoBitPositions {\n-            set: self,\n-            other: other,\n+\n+        Intersection(BlockIter::from_blocks(TwoBitPositions {\n+            set: self.bit_vec.blocks(),\n+            other: other.bit_vec.blocks(),\n             merge: bitand,\n-            current_word: 0,\n-            next_idx: 0\n-        }.take(min))\n+        }).take(min))\n     }\n \n     /// Iterator over each usize stored in the `self` setminus `other`.\n@@ -1649,13 +1646,11 @@ impl BitSet {\n     pub fn difference<'a>(&'a self, other: &'a BitSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n-        Difference(TwoBitPositions {\n-            set: self,\n-            other: other,\n+        Difference(BlockIter::from_blocks(TwoBitPositions {\n+            set: self.bit_vec.blocks(),\n+            other: other.bit_vec.blocks(),\n             merge: diff,\n-            current_word: 0,\n-            next_idx: 0\n-        })\n+        }))\n     }\n \n     /// Iterator over each usize stored in the symmetric difference of `self` and `other`.\n@@ -1681,13 +1676,11 @@ impl BitSet {\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n-        SymmetricDifference(TwoBitPositions {\n-            set: self,\n-            other: other,\n+        SymmetricDifference(BlockIter::from_blocks(TwoBitPositions {\n+            set: self.bit_vec.blocks(),\n+            other: other.bit_vec.blocks(),\n             merge: bitxor,\n-            current_word: 0,\n-            next_idx: 0\n-        })\n+        }))\n     }\n \n     /// Unions in-place with the specified other bit vector.\n@@ -1994,98 +1987,114 @@ impl hash::Hash for BitSet {\n     }\n }\n \n-/// An iterator for `BitSet`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SetIter<'a> {\n-    set: &'a BitSet,\n-    next_idx: usize\n+struct BlockIter<T> where T: Iterator<Item=u32> {\n+    head: u32,\n+    head_offset: usize,\n+    tail: T,\n+}\n+\n+impl<'a, T> BlockIter<T> where T: Iterator<Item=u32> {\n+    fn from_blocks(mut blocks: T) -> BlockIter<T> {\n+        let h = blocks.next().unwrap_or(0);\n+        BlockIter {tail: blocks, head: h, head_offset: 0}\n+    }\n }\n \n /// An iterator combining two `BitSet` iterators.\n #[derive(Clone)]\n struct TwoBitPositions<'a> {\n-    set: &'a BitSet,\n-    other: &'a BitSet,\n+    set: Blocks<'a>,\n+    other: Blocks<'a>,\n     merge: fn(u32, u32) -> u32,\n-    current_word: u32,\n-    next_idx: usize\n }\n \n+/// An iterator for `BitSet`.\n+#[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SetIter<'a>(BlockIter<Blocks<'a>>);\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a>(TwoBitPositions<'a>);\n+pub struct Union<'a>(BlockIter<TwoBitPositions<'a>>);\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);\n+pub struct Intersection<'a>(Take<BlockIter<TwoBitPositions<'a>>>);\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Difference<'a>(TwoBitPositions<'a>);\n+pub struct Difference<'a>(BlockIter<TwoBitPositions<'a>>);\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n+pub struct SymmetricDifference<'a>(BlockIter<TwoBitPositions<'a>>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for SetIter<'a> {\n+impl<'a, T> Iterator for BlockIter<T> where T: Iterator<Item=u32> {\n     type Item = usize;\n \n     fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bit_vec.len() {\n-            let idx = self.next_idx;\n-            self.next_idx += 1;\n-\n-            if self.set.contains(&idx) {\n-                return Some(idx);\n+        while self.head == 0 {\n+            match self.tail.next() {\n+                Some(w) => self.head = w,\n+                None => return None\n             }\n+            self.head_offset += u32::BITS;\n         }\n \n-        return None;\n+        // from the current block, isolate the\n+        // LSB and subtract 1, producing k:\n+        // a block with a number of set bits\n+        // equal to the index of the LSB\n+        let k = (self.head & (!self.head + 1)) - 1;\n+        // update block, removing the LSB\n+        self.head &= self.head - 1;\n+        // return offset + (index of LSB)\n+        Some(self.head_offset + (u32::count_ones(k) as usize))\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.set.bit_vec.len() - self.next_idx))\n+        match self.tail.size_hint() {\n+            (_, Some(h)) => (0, Some(1 + h * (u32::BITS as usize))),\n+            _ => (0, None)\n+        }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for TwoBitPositions<'a> {\n-    type Item = usize;\n-\n-    fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bit_vec.len() ||\n-              self.next_idx < self.other.bit_vec.len() {\n-            let bit_idx = self.next_idx % u32::BITS;\n-            if bit_idx == 0 {\n-                let s_bit_vec = &self.set.bit_vec;\n-                let o_bit_vec = &self.other.bit_vec;\n-                // Merging the two words is a bit of an awkward dance since\n-                // one BitVec might be longer than the other\n-                let word_idx = self.next_idx / u32::BITS;\n-                let w1 = if word_idx < s_bit_vec.storage.len() {\n-                             s_bit_vec.storage[word_idx]\n-                         } else { 0 };\n-                let w2 = if word_idx < o_bit_vec.storage.len() {\n-                             o_bit_vec.storage[word_idx]\n-                         } else { 0 };\n-                self.current_word = (self.merge)(w1, w2);\n-            }\n-\n-            self.next_idx += 1;\n-            if self.current_word & (1 << bit_idx) != 0 {\n-                return Some(self.next_idx - 1);\n-            }\n+    type Item = u32;\n+\n+    fn next(&mut self) -> Option<u32> {\n+        match (self.set.next(), self.other.next()) {\n+            (Some(a), Some(b)) => Some((self.merge)(a, b)),\n+            (Some(a), None) => Some((self.merge)(a, 0)),\n+            (None, Some(b)) => Some((self.merge)(0, b)),\n+            _ => return None\n         }\n-        return None;\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let cap = cmp::max(self.set.bit_vec.len(), self.other.bit_vec.len());\n-        (0, Some(cap - self.next_idx))\n+        let (a, au) = self.set.size_hint();\n+        let (b, bu) = self.other.size_hint();\n+\n+        let upper = match (au, bu) {\n+            (Some(au), Some(bu)) => Some(cmp::max(au, bu)),\n+            _ => None\n+        };\n+\n+        (cmp::max(a, b), upper)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for SetIter<'a> {\n+    type Item = usize;\n+\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Union<'a> {\n     type Item = usize;"}]}