{"sha": "42e545ffa73836525d10e1c658b622ddb12b7f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZTU0NWZmYTczODM2NTI1ZDEwZTFjNjU4YjYyMmRkYjEyYjdmOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-04T18:49:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-04T18:49:28Z"}, "message": "Auto merge of #26694 - eddyb:method-nan, r=arielb1\n\n`MethodCallee` now has no information about the method, other than its `DefId`.\r\nThe previous bits of information can be recovered as follows:\r\n```rust\r\nlet method_item = tcx.impl_or_trait_item(callee.def_id);\r\nlet container = method_item.container();\r\n```\r\nThe method is inherent if `container` is a `ty::ImplContainer`:\r\n* the `impl` the method comes from is `container.id()`\r\n\r\nThe method is a trait method if `container` is a `ty::TraitContainer:\r\n* the `trait` the method is part of is `container.id()`\r\n* a `ty::TraitRef` can be constructed by putting together:\r\n * `container.id()` as the `trait` ID\r\n * `callee.substs.clone().method_to_trait()` as the `trait` substs (including `Self`)\r\n* the above `trait_ref` is a valid `T: Trait<A, B, C>` predicate\r\n* selecting `trait_ref` could result in one of the following:\r\n * `traits::VtableImpl(data)`: static dispatch to `data.impl_def_id`\r\n * `traits::VtableObject(data)`: dynamic dispatch, with the vtable index:\r\n`traits::get_vtable_index_of_object_method(tcx, data, callee.def_id)`\r\n * other variants of `traits::Vtable`: various other `impl` sources", "tree": {"sha": "5073694b309554caddbd9e84303978768d5699ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5073694b309554caddbd9e84303978768d5699ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42e545ffa73836525d10e1c658b622ddb12b7f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42e545ffa73836525d10e1c658b622ddb12b7f93", "html_url": "https://github.com/rust-lang/rust/commit/42e545ffa73836525d10e1c658b622ddb12b7f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42e545ffa73836525d10e1c658b622ddb12b7f93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b381449dfffef27e8b28a6f0867a8c238eef7188", "url": "https://api.github.com/repos/rust-lang/rust/commits/b381449dfffef27e8b28a6f0867a8c238eef7188", "html_url": "https://github.com/rust-lang/rust/commit/b381449dfffef27e8b28a6f0867a8c238eef7188"}, {"sha": "d256eb1c5ddd6740140b6538a018a0171f45fdae", "url": "https://api.github.com/repos/rust-lang/rust/commits/d256eb1c5ddd6740140b6538a018a0171f45fdae", "html_url": "https://github.com/rust-lang/rust/commit/d256eb1c5ddd6740140b6538a018a0171f45fdae"}], "stats": {"total": 1769, "additions": 591, "deletions": 1178}, "files": [{"sha": "7c76f4fe289dfd583fa710957e2ddcc6dbde3f15", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 15, "deletions": 170, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -29,7 +29,7 @@ use middle::check_const::ConstQualif;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n+use middle::ty::{self, Ty};\n \n use syntax::{ast, ast_util, codemap, fold};\n use syntax::codemap::Span;\n@@ -600,21 +600,21 @@ impl tr for ty::UpvarCapture {\n \n trait read_method_callee_helper<'tcx> {\n     fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                  -> (u32, MethodCallee<'tcx>);\n+                                  -> (u32, ty::MethodCallee<'tcx>);\n }\n \n fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n                                   rbml_w: &mut Encoder,\n                                   autoderef: u32,\n-                                  method: &MethodCallee<'tcx>) {\n+                                  method: &ty::MethodCallee<'tcx>) {\n     use serialize::Encoder;\n \n     rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n         rbml_w.emit_struct_field(\"autoderef\", 0, |rbml_w| {\n             autoderef.encode(rbml_w)\n         });\n-        rbml_w.emit_struct_field(\"origin\", 1, |rbml_w| {\n-            Ok(rbml_w.emit_method_origin(ecx, &method.origin))\n+        rbml_w.emit_struct_field(\"def_id\", 1, |rbml_w| {\n+            Ok(rbml_w.emit_def_id(method.def_id))\n         });\n         rbml_w.emit_struct_field(\"ty\", 2, |rbml_w| {\n             Ok(rbml_w.emit_ty(ecx, method.ty))\n@@ -627,21 +627,20 @@ fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n \n impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n     fn read_method_callee<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                  -> (u32, MethodCallee<'tcx>) {\n+                                  -> (u32, ty::MethodCallee<'tcx>) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n-                Decodable::decode(this)\n-            }).unwrap();\n-            Ok((autoderef, MethodCallee {\n-                origin: this.read_struct_field(\"origin\", 1, |this| {\n-                    Ok(this.read_method_origin(dcx))\n+            let autoderef = this.read_struct_field(\"autoderef\", 0,\n+                                                   Decodable::decode).unwrap();\n+            Ok((autoderef, ty::MethodCallee {\n+                def_id: this.read_struct_field(\"def_id\", 1, |this| {\n+                    Ok(this.read_def_id(dcx))\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 2, |this| {\n                     Ok(this.read_ty(dcx))\n                 }).unwrap(),\n                 substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(this.read_substs(dcx))\n+                    Ok(dcx.tcx.mk_substs(this.read_substs(dcx)))\n                 }).unwrap()\n             }))\n         }).unwrap()\n@@ -707,9 +706,6 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n trait rbml_writer_helpers<'tcx> {\n     fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                              closure_type: &ty::ClosureTy<'tcx>);\n-    fn emit_method_origin<'a>(&mut self,\n-                              ecx: &e::EncodeContext<'a, 'tcx>,\n-                              method_origin: &ty::MethodOrigin<'tcx>);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n     fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n@@ -741,73 +737,6 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_method_origin<'b>(&mut self,\n-                              ecx: &e::EncodeContext<'b, 'tcx>,\n-                              method_origin: &ty::MethodOrigin<'tcx>)\n-    {\n-        use serialize::Encoder;\n-\n-        self.emit_enum(\"MethodOrigin\", |this| {\n-            match *method_origin {\n-                ty::MethodStatic(def_id) => {\n-                    this.emit_enum_variant(\"MethodStatic\", 0, 1, |this| {\n-                        Ok(this.emit_def_id(def_id))\n-                    })\n-                }\n-\n-                ty::MethodStaticClosure(def_id) => {\n-                    this.emit_enum_variant(\"MethodStaticClosure\", 1, 1, |this| {\n-                        Ok(this.emit_def_id(def_id))\n-                    })\n-                }\n-\n-                ty::MethodTypeParam(ref p) => {\n-                    this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n-                        this.emit_struct(\"MethodParam\", 2, |this| {\n-                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &p.trait_ref))\n-                            }));\n-                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n-                                this.emit_uint(p.method_num)\n-                            }));\n-                            try!(this.emit_struct_field(\"impl_def_id\", 0, |this| {\n-                                this.emit_option(|this| {\n-                                    match p.impl_def_id {\n-                                        None => this.emit_option_none(),\n-                                        Some(did) => this.emit_option_some(|this| {\n-                                            Ok(this.emit_def_id(did))\n-                                        })\n-                                    }\n-                                })\n-                            }));\n-                            Ok(())\n-                        })\n-                    })\n-                }\n-\n-                ty::MethodTraitObject(ref o) => {\n-                    this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n-                        this.emit_struct(\"MethodObject\", 2, |this| {\n-                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &o.trait_ref))\n-                            }));\n-                            try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n-                                Ok(this.emit_def_id(o.object_trait_id))\n-                            }));\n-                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n-                                this.emit_uint(o.method_num)\n-                            }));\n-                            try!(this.emit_struct_field(\"vtable_index\", 0, |this| {\n-                                this.emit_uint(o.vtable_index)\n-                            }));\n-                            Ok(())\n-                        })\n-                    })\n-                }\n-            }\n-        });\n-    }\n-\n     fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n@@ -1077,7 +1006,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    let method_call = MethodCall::expr(id);\n+    let method_call = ty::MethodCall::expr(id);\n     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n@@ -1089,7 +1018,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         match *adjustment {\n             ty::AdjustDerefRef(ref adj) => {\n                 for autoderef in 0..adj.autoderefs {\n-                    let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                    let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n                     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n@@ -1150,8 +1079,6 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n }\n \n trait rbml_decoder_decoder_helpers<'tcx> {\n-    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                  -> ty::MethodOrigin<'tcx>;\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1235,88 +1162,6 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_method_origin<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                  -> ty::MethodOrigin<'tcx>\n-    {\n-        self.read_enum(\"MethodOrigin\", |this| {\n-            let variants = &[\"MethodStatic\", \"MethodStaticClosure\",\n-                             \"MethodTypeParam\", \"MethodTraitObject\"];\n-            this.read_enum_variant(variants, |this, i| {\n-                Ok(match i {\n-                    0 => {\n-                        let def_id = this.read_def_id(dcx);\n-                        ty::MethodStatic(def_id)\n-                    }\n-\n-                    1 => {\n-                        let def_id = this.read_def_id(dcx);\n-                        ty::MethodStaticClosure(def_id)\n-                    }\n-\n-                    2 => {\n-                        this.read_struct(\"MethodTypeParam\", 2, |this| {\n-                            Ok(ty::MethodTypeParam(\n-                                ty::MethodParam {\n-                                    trait_ref: {\n-                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_trait_ref(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    method_num: {\n-                                        this.read_struct_field(\"method_num\", 1, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                    impl_def_id: {\n-                                        this.read_struct_field(\"impl_def_id\", 2, |this| {\n-                                            this.read_option(|this, b| {\n-                                                if b {\n-                                                    Ok(Some(this.read_def_id(dcx)))\n-                                                } else {\n-                                                    Ok(None)\n-                                                }\n-                                            })\n-                                        }).unwrap()\n-                                    }\n-                                }))\n-                        }).unwrap()\n-                    }\n-\n-                    3 => {\n-                        this.read_struct(\"MethodTraitObject\", 2, |this| {\n-                            Ok(ty::MethodTraitObject(\n-                                ty::MethodObject {\n-                                    trait_ref: {\n-                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_trait_ref(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    object_trait_id: {\n-                                        this.read_struct_field(\"object_trait_id\", 1, |this| {\n-                                            Ok(this.read_def_id(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    method_num: {\n-                                        this.read_struct_field(\"method_num\", 2, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                    vtable_index: {\n-                                        this.read_struct_field(\"vtable_index\", 3, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                }))\n-                        }).unwrap()\n-                    }\n-\n-                    _ => panic!(\"..\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-\n-\n     fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n@@ -1663,7 +1508,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_method_map => {\n                         let (autoderef, method) = val_dsr.read_method_callee(dcx);\n-                        let method_call = MethodCall {\n+                        let method_call = ty::MethodCall {\n                             expr_id: id,\n                             autoderef: autoderef\n                         };"}, {"sha": "b5c78340d022d19aa9de7adae205244cfa343c27", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -696,13 +696,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            let method_did = match v.tcx.tables.borrow().method_map[&method_call].origin {\n-                ty::MethodStatic(did) => Some(did),\n-                _ => None\n-            };\n-            let is_const = match method_did {\n-                Some(did) => v.handle_const_fn_call(e, did, node_ty),\n-                None => false\n+            let method = v.tcx.tables.borrow().method_map[&method_call];\n+            let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n+                ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n+                ty::TraitContainer(_) => false\n             };\n             if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);"}, {"sha": "8d2d6889b5efa529d384ae73f521e5e548875064", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -93,40 +93,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         });\n     }\n \n-    fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n-                                span: codemap::Span) {\n+    fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n         let method_call = ty::MethodCall::expr(id);\n-        match self.tcx.tables.borrow().method_map.get(&method_call) {\n-            Some(method) => {\n-                match method.origin {\n-                    ty::MethodStatic(def_id) => {\n-                        match self.tcx.provided_source(def_id) {\n-                            Some(p_did) => self.check_def_id(p_did),\n-                            None => self.check_def_id(def_id)\n-                        }\n-                    }\n-                    ty::MethodStaticClosure(_) => {}\n-                    ty::MethodTypeParam(ty::MethodParam {\n-                        ref trait_ref,\n-                        method_num: index,\n-                        ..\n-                    }) |\n-                    ty::MethodTraitObject(ty::MethodObject {\n-                        ref trait_ref,\n-                        method_num: index,\n-                        ..\n-                    }) => {\n-                        let trait_item = self.tcx.trait_item(trait_ref.def_id, index);\n-                        self.check_def_id(trait_item.def_id());\n-                    }\n-                }\n-            }\n-            None => {\n-                self.tcx.sess.span_bug(span,\n-                                       \"method call expression not \\\n-                                        in method map?!\")\n-            }\n-        }\n+        let method = self.tcx.tables.borrow().method_map[&method_call];\n+        self.check_def_id(method.def_id);\n     }\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n@@ -262,7 +232,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprMethodCall(..) => {\n-                self.lookup_and_handle_method(expr.id, expr.span);\n+                self.lookup_and_handle_method(expr.id);\n             }\n             ast::ExprField(ref lhs, ref ident) => {\n                 self.handle_field_access(&**lhs, ident.node.name);"}, {"sha": "b2a064bf86c6a08e3bd6b3a18a14db1f935d4559", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.tables.borrow().method_map.get(&method_call).unwrap().ty;\n+                let base_type = self.tcx.tables.borrow().method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "0d204a823af04d89c60c1b1e98f0d51d914cf488", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 60, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -23,10 +23,7 @@ use self::OverloadedCallType::*;\n use middle::{def, region, pat_util};\n use middle::infer;\n use middle::mem_categorization as mc;\n-use middle::ty::{self};\n-use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n-use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n-use middle::ty::{MethodStatic, MethodStaticClosure};\n+use middle::ty;\n \n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -229,57 +226,8 @@ impl OverloadedCallType {\n \n     fn from_method_id(tcx: &ty::ctxt, method_id: ast::DefId)\n                       -> OverloadedCallType {\n-        let method_descriptor = match tcx.impl_or_trait_item(method_id) {\n-            ty::MethodTraitItem(ref method_descriptor) => {\n-                (*method_descriptor).clone()\n-            }\n-            _ => {\n-                tcx.sess.bug(\"overloaded call method wasn't in method map\")\n-            }\n-        };\n-        let impl_id = match method_descriptor.container {\n-            ty::TraitContainer(_) => {\n-                tcx.sess.bug(\"statically resolved overloaded call method \\\n-                              belonged to a trait?!\")\n-            }\n-            ty::ImplContainer(impl_id) => impl_id,\n-        };\n-        let trait_ref = match tcx.impl_trait_ref(impl_id) {\n-            None => {\n-                tcx.sess.bug(\"statically resolved overloaded call impl \\\n-                              didn't implement a trait?!\")\n-            }\n-            Some(ref trait_ref) => (*trait_ref).clone(),\n-        };\n-        OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n-    }\n-\n-    fn from_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n-                    -> OverloadedCallType {\n-        let trait_did =\n-            tcx.tables\n-               .borrow()\n-               .closure_kinds\n-               .get(&closure_did)\n-               .expect(\"OverloadedCallType::from_closure: didn't find closure id\")\n-               .trait_did(tcx);\n-        OverloadedCallType::from_trait_id(tcx, trait_did)\n-    }\n-\n-    fn from_method_origin(tcx: &ty::ctxt, origin: &MethodOrigin)\n-                          -> OverloadedCallType {\n-        match *origin {\n-            MethodStatic(def_id) => {\n-                OverloadedCallType::from_method_id(tcx, def_id)\n-            }\n-            MethodStaticClosure(def_id) => {\n-                OverloadedCallType::from_closure(tcx, def_id)\n-            }\n-            MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n-            MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n-            }\n-        }\n+        let method = tcx.impl_or_trait_item(method_id);\n+        OverloadedCallType::from_trait_id(tcx, method.container().id())\n     }\n }\n \n@@ -629,11 +577,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             ty::TyError => { }\n             _ => {\n                 let overloaded_call_type =\n-                    match self.typer.node_method_origin(MethodCall::expr(call.id)) {\n-                        Some(method_origin) => {\n-                            OverloadedCallType::from_method_origin(\n-                                self.tcx(),\n-                                &method_origin)\n+                    match self.typer.node_method_id(ty::MethodCall::expr(call.id)) {\n+                        Some(method_id) => {\n+                            OverloadedCallType::from_method_id(self.tcx(), method_id)\n                         }\n                         None => {\n                             self.tcx().sess.span_bug("}, {"sha": "63f31921ec2ecb1fba74cd79b91c052797e61a5b", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -1327,7 +1327,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn node_method_ty(&self, method_call: ty::MethodCall)\n-                      -> Option<Ty<'tcx>> {\n+                          -> Option<Ty<'tcx>> {\n         self.tables\n             .borrow()\n             .method_map\n@@ -1336,14 +1336,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .map(|ty| self.resolve_type_vars_if_possible(&ty))\n     }\n \n-    pub fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>\n-    {\n+    pub fn node_method_id(&self, method_call: ty::MethodCall)\n+                          -> Option<ast::DefId> {\n         self.tables\n             .borrow()\n             .method_map\n             .get(&method_call)\n-            .map(|method| method.origin.clone())\n+            .map(|method| method.def_id)\n     }\n \n     pub fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {"}, {"sha": "37460531dbdbf6c8213dcef585b279c477ee6f1e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -1148,7 +1148,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.tables.borrow().method_map.get(&method_call).unwrap().ty;\n+            let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n             let succ = if method_ty.fn_ret().diverges() {\n                 self.s.exit_ln\n             } else {"}, {"sha": "d588f7c6070ce25bd4e1c5ae2682e9a9bd4c2cd5", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -128,16 +128,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                match self.tcx.tables.borrow().method_map.get(&method_call).unwrap().origin {\n-                    ty::MethodStatic(def_id) => {\n+                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                match self.tcx.impl_or_trait_item(def_id).container() {\n+                    ty::ImplContainer(_) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {\n                                 self.worklist.push(def_id.node)\n                             }\n                             self.reachable_symbols.insert(def_id.node);\n                         }\n                     }\n-                    _ => {}\n+                    ty::TraitContainer(_) => {}\n                 }\n             }\n             _ => {}"}, {"sha": "46be4b752266efadbab0ac8cb9e073b99746fb4e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -406,31 +406,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprMethodCall(i, _, _) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n-            match tcx.tables.borrow().method_map.get(&method_call) {\n-                Some(method) => {\n-                    match method.origin {\n-                        ty::MethodStatic(def_id) => {\n-                            def_id\n-                        }\n-                        ty::MethodStaticClosure(def_id) => {\n-                            def_id\n-                        }\n-                        ty::MethodTypeParam(ty::MethodParam {\n-                            ref trait_ref,\n-                            method_num: index,\n-                            ..\n-                        }) |\n-                        ty::MethodTraitObject(ty::MethodObject {\n-                            ref trait_ref,\n-                            method_num: index,\n-                            ..\n-                        }) => {\n-                            tcx.trait_item(trait_ref.def_id, index).def_id()\n-                        }\n-                    }\n-                }\n-                None => return\n-            }\n+            tcx.tables.borrow().method_map[&method_call].def_id\n         }\n         ast::ExprField(ref base_e, ref field) => {\n             span = field.span;"}, {"sha": "4e98ef2753105c4a0d73238feb2ea2f94d6e8a06", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -141,19 +141,25 @@ impl<'tcx> Substs<'tcx> {\n     {\n         let Substs { types, regions } = self;\n         let types = types.with_vec(FnSpace, m_types);\n-        let regions = regions.map(m_regions,\n-                                  |r, m_regions| r.with_vec(FnSpace, m_regions));\n+        let regions = regions.map(|r| r.with_vec(FnSpace, m_regions));\n+        Substs { types: types, regions: regions }\n+    }\n+\n+    pub fn method_to_trait(self) -> Substs<'tcx> {\n+        let Substs { mut types, regions } = self;\n+        types.truncate(FnSpace, 0);\n+        let regions = regions.map(|mut r| { r.truncate(FnSpace, 0); r });\n         Substs { types: types, regions: regions }\n     }\n }\n \n impl RegionSubsts {\n-    fn map<A, F>(self, a: A, op: F) -> RegionSubsts where\n-        F: FnOnce(VecPerParamSpace<ty::Region>, A) -> VecPerParamSpace<ty::Region>,\n+    fn map<F>(self, op: F) -> RegionSubsts where\n+        F: FnOnce(VecPerParamSpace<ty::Region>) -> VecPerParamSpace<ty::Region>,\n     {\n         match self {\n             ErasedRegions => ErasedRegions,\n-            NonerasedRegions(r) => NonerasedRegions(op(r, a))\n+            NonerasedRegions(r) => NonerasedRegions(op(r))\n         }\n     }\n "}, {"sha": "b5f01ada7e1789d4467eb62ee88c06564c5c9d3d", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -291,11 +291,13 @@ pub struct VtableBuiltinData<N> {\n /// for the object type `Foo`.\n #[derive(PartialEq,Eq,Clone)]\n pub struct VtableObjectData<'tcx> {\n-    /// the object type `Foo`.\n-    pub object_ty: Ty<'tcx>,\n-\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The vtable is formed by concatenating together the method lists of\n+    /// the base object trait and all supertraits; this is the start of\n+    /// `upcast_trait_ref`'s methods in that vtable.\n+    pub vtable_base: usize\n }\n \n /// Creates predicate obligations from the generic bounds."}, {"sha": "e29d9646509f9eac17bbe26a44620d8628e6143b", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -629,9 +629,10 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-    object_ty: Ty<'tcx>)\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n+    let self_ty = obligation_trait_ref.self_ty();\n+    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     debug!(\"assemble_candidates_from_object_type(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n@@ -684,10 +685,9 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Impl(data));\n         }\n-        super::VtableObject(data) => {\n+        super::VtableObject(_) => {\n             assemble_candidates_from_object_type(\n-                selcx, obligation, obligation_trait_ref, candidate_set,\n-                data.object_ty);\n+                selcx, obligation, obligation_trait_ref, candidate_set);\n         }\n         super::VtableClosure(data) => {\n             candidate_set.vec.push("}, {"sha": "ad91f664af2db6ac7289cb2336be3eab7cefbb9f", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 32, "deletions": 41, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -1362,12 +1362,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\",\n                    poly_trait_ref);\n \n-            // see whether the object trait can be upcast to the trait we are looking for\n-            let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n-            if upcast_trait_refs.len() > 1 {\n+            // Count only those upcast versions that match the trait-ref\n+            // we are looking for. Specifically, do not only check for the\n+            // correct trait, but also the correct type parameters.\n+            // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n+            // but `Foo` is declared as `trait Foo : Bar<u32>`.\n+            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n+                .filter(|upcast_trait_ref| self.infcx.probe(|_| {\n+                    let upcast_trait_ref = upcast_trait_ref.clone();\n+                    self.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n+                })).count();\n+\n+            if upcast_trait_refs > 1 {\n                 // can be upcast in many ways; need more type information\n                 candidates.ambiguous = true;\n-            } else if upcast_trait_refs.len() == 1 {\n+            } else if upcast_trait_refs == 1 {\n                 candidates.vec.push(ObjectCandidate);\n             }\n \n@@ -2305,20 +2314,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // be exactly one applicable trait-reference; if this were not\n         // the case, we would have reported an ambiguity error rather\n         // than successfully selecting one of the candidates.\n-        let upcast_trait_refs = self.upcast(poly_trait_ref.clone(), obligation);\n-        assert_eq!(upcast_trait_refs.len(), 1);\n-        let upcast_trait_ref = upcast_trait_refs.into_iter().next().unwrap();\n+        let mut upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n+            .map(|upcast_trait_ref| {\n+                (upcast_trait_ref.clone(), self.infcx.probe(|_| {\n+                    self.match_poly_trait_ref(obligation, upcast_trait_ref)\n+                }).is_ok())\n+            });\n+        let mut upcast_trait_ref = None;\n+        let mut vtable_base = 0;\n \n-        match self.match_poly_trait_ref(obligation, upcast_trait_ref.clone()) {\n-            Ok(()) => { }\n-            Err(()) => {\n-                self.tcx().sess.span_bug(obligation.cause.span,\n-                                         \"failed to match trait refs\");\n+        while let Some((supertrait, matches)) = upcast_trait_refs.next() {\n+            if matches {\n+                upcast_trait_ref = Some(supertrait);\n+                break;\n             }\n+            vtable_base += util::count_own_vtable_entries(self.tcx(), supertrait);\n         }\n+        assert!(upcast_trait_refs.all(|(_, matches)| !matches));\n \n-        VtableObjectData { object_ty: self_ty,\n-                           upcast_trait_ref: upcast_trait_ref }\n+        VtableObjectData {\n+            upcast_trait_ref: upcast_trait_ref.unwrap(),\n+            vtable_base: vtable_base\n+        }\n     }\n \n     fn confirm_fn_pointer_candidate(&mut self,\n@@ -2719,7 +2736,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n-    fn match_poly_trait_ref(&mut self,\n+    fn match_poly_trait_ref(&self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> Result<(),()>\n@@ -2930,32 +2947,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation.cause.clone()\n         }\n     }\n-\n-    /// Upcasts an object trait-reference into those that match the obligation.\n-    fn upcast(&mut self, obj_trait_ref: ty::PolyTraitRef<'tcx>, obligation: &TraitObligation<'tcx>)\n-              -> Vec<ty::PolyTraitRef<'tcx>>\n-    {\n-        debug!(\"upcast(obj_trait_ref={:?}, obligation={:?})\",\n-               obj_trait_ref,\n-               obligation);\n-\n-        let obligation_def_id = obligation.predicate.def_id();\n-        let mut upcast_trait_refs = util::upcast(self.tcx(), obj_trait_ref, obligation_def_id);\n-\n-        // Retain only those upcast versions that match the trait-ref\n-        // we are looking for.  In particular, we know that all of\n-        // `upcast_trait_refs` apply to the correct trait, but\n-        // possibly with incorrect type parameters. For example, we\n-        // may be trying to upcast `Foo` to `Bar<i32>`, but `Foo` is\n-        // declared as `trait Foo : Bar<u32>`.\n-        upcast_trait_refs.retain(|upcast_trait_ref| {\n-            let upcast_trait_ref = upcast_trait_ref.clone();\n-            self.infcx.probe(|_| self.match_poly_trait_ref(obligation, upcast_trait_ref)).is_ok()\n-        });\n-\n-        debug!(\"upcast: upcast_trait_refs={:?}\", upcast_trait_refs);\n-        upcast_trait_refs\n-    }\n }\n \n impl<'tcx> SelectionCache<'tcx> {"}, {"sha": "af9d5e5157d28e8567b3ecf2a72602e208184cbb", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -396,52 +396,50 @@ pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .collect()\n }\n \n-/// Given an object of type `object_trait_ref`, returns the index of\n-/// the method `n_method` found in the trait `trait_def_id` (which\n-/// should be a supertrait of `object_trait_ref`) within the vtable\n-/// for `object_trait_ref`.\n-pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                               object_trait_ref: ty::PolyTraitRef<'tcx>,\n-                                               trait_def_id: ast::DefId,\n-                                               method_offset_in_trait: usize) -> usize {\n-    // We need to figure the \"real index\" of the method in a\n-    // listing of all the methods of an object. We do this by\n-    // iterating down the supertraits of the object's trait until\n-    // we find the trait the method came from, counting up the\n-    // methods from them.\n-    let mut method_count = 0;\n-\n-    for bound_ref in transitive_bounds(tcx, &[object_trait_ref]) {\n-        if bound_ref.def_id() == trait_def_id {\n-            break;\n-        }\n-\n-        let trait_items = tcx.trait_items(bound_ref.def_id());\n-        for trait_item in trait_items.iter() {\n-            match *trait_item {\n-                ty::MethodTraitItem(_) => method_count += 1,\n-                _ => {}\n-            }\n+/// Given an trait `trait_ref`, returns the number of vtable entries\n+/// that come from `trait_ref`, excluding its supertraits. Used in\n+/// computing the vtable base for an upcast trait of a trait object.\n+pub fn count_own_vtable_entries<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      trait_ref: ty::PolyTraitRef<'tcx>)\n+                                      -> usize {\n+    let mut entries = 0;\n+    // Count number of methods and add them to the total offset.\n+    // Skip over associated types and constants.\n+    for trait_item in &tcx.trait_items(trait_ref.def_id())[..] {\n+        if let ty::MethodTraitItem(_) = *trait_item {\n+            entries += 1;\n         }\n     }\n+    entries\n+}\n \n-    // count number of methods preceding the one we are selecting and\n-    // add them to the total offset; skip over associated types.\n-    let trait_items = tcx.trait_items(trait_def_id);\n-    for trait_item in trait_items.iter().take(method_offset_in_trait) {\n-        match *trait_item {\n-            ty::MethodTraitItem(_) => method_count += 1,\n-            _ => {}\n+/// Given an upcast trait object described by `object`, returns the\n+/// index of the method `method_def_id` (which should be part of\n+/// `object.upcast_trait_ref`) within the vtable for `object`.\n+pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                               object: &super::VtableObjectData<'tcx>,\n+                                               method_def_id: ast::DefId) -> usize {\n+    // Count number of methods preceding the one we are selecting and\n+    // add them to the total offset.\n+    // Skip over associated types and constants.\n+    let mut entries = object.vtable_base;\n+    for trait_item in &tcx.trait_items(object.upcast_trait_ref.def_id())[..] {\n+        if trait_item.def_id() == method_def_id {\n+            // The item with the ID we were given really ought to be a method.\n+            assert!(match *trait_item {\n+                ty::MethodTraitItem(_) => true,\n+                _ => false\n+            });\n+\n+            return entries;\n+        }\n+        if let ty::MethodTraitItem(_) = *trait_item {\n+            entries += 1;\n         }\n     }\n \n-    // the item at the offset we were given really ought to be a method\n-    assert!(match trait_items[method_offset_in_trait] {\n-        ty::MethodTraitItem(_) => true,\n-        _ => false\n-    });\n-\n-    method_count\n+    tcx.sess.bug(&format!(\"get_vtable_index_of_object_method: {:?} was not found\",\n+                          method_def_id));\n }\n \n pub enum TupleArgumentsFlag { Yes, No }\n@@ -490,7 +488,7 @@ impl<'tcx, N:fmt::Debug> fmt::Debug for super::Vtable<'tcx, N> {\n                 write!(f, \"VtableFnPointer({:?})\", d),\n \n             super::VtableObject(ref d) =>\n-                write!(f, \"VtableObject({:?})\", d),\n+                write!(f, \"{:?}\", d),\n \n             super::VtableParam(ref n) =>\n                 write!(f, \"VtableParam({:?})\", n),\n@@ -535,7 +533,9 @@ impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableDefaultImplData<N> {\n \n impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(object_ty={:?})\", self.object_ty)\n+        write!(f, \"VtableObject(upcast={:?}, vtable_base={})\",\n+               self.upcast_trait_ref,\n+               self.vtable_base)\n     }\n }\n "}, {"sha": "715072a12ebd041da5a5f64d05a8320d71bcf5ad", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 71, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -30,7 +30,6 @@ pub use self::ImplOrTraitItem::*;\n pub use self::BoundRegion::*;\n pub use self::TypeVariants::*;\n pub use self::IntVarValue::*;\n-pub use self::MethodOrigin::*;\n pub use self::CopyImplementationError::*;\n \n pub use self::BuiltinBound::Send as BoundSend;\n@@ -330,7 +329,7 @@ impl IntTypeExt for attr::IntType {\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum ImplOrTraitItemContainer {\n     TraitContainer(ast::DefId),\n     ImplContainer(ast::DefId),\n@@ -626,68 +625,12 @@ pub enum CustomCoerceUnsized {\n     Struct(usize)\n }\n \n-#[derive(Clone)]\n-pub enum MethodOrigin<'tcx> {\n-    // fully statically resolved method\n-    MethodStatic(ast::DefId),\n-\n-    // fully statically resolved closure invocation\n-    MethodStaticClosure(ast::DefId),\n-\n-    // method invoked on a type parameter with a bounded trait\n-    MethodTypeParam(MethodParam<'tcx>),\n-\n-    // method invoked on a trait instance\n-    MethodTraitObject(MethodObject<'tcx>),\n-\n-}\n-\n-// details for a method invoked with a receiver whose type is a type parameter\n-// with a bounded trait.\n-#[derive(Clone)]\n-pub struct MethodParam<'tcx> {\n-    // the precise trait reference that occurs as a bound -- this may\n-    // be a supertrait of what the user actually typed. Note that it\n-    // never contains bound regions; those regions should have been\n-    // instantiated with fresh variables at this point.\n-    pub trait_ref: ty::TraitRef<'tcx>,\n-\n-    // index of usize in the list of trait items. Note that this is NOT\n-    // the index into the vtable, because the list of trait items\n-    // includes associated types.\n-    pub method_num: usize,\n-\n-    /// The impl for the trait from which the method comes. This\n-    /// should only be used for certain linting/heuristic purposes\n-    /// since there is no guarantee that this is Some in every\n-    /// situation that it could/should be.\n-    pub impl_def_id: Option<ast::DefId>,\n-}\n-\n-// details for a method invoked with a receiver whose type is an object\n-#[derive(Clone)]\n-pub struct MethodObject<'tcx> {\n-    // the (super)trait containing the method to be invoked\n-    pub trait_ref: TraitRef<'tcx>,\n-\n-    // the actual base trait id of the object\n-    pub object_trait_id: ast::DefId,\n-\n-    // index of the method to be invoked amongst the trait's items\n-    pub method_num: usize,\n-\n-    // index into the actual runtime vtable.\n-    // the vtable is formed by concatenating together the method lists of\n-    // the base object trait and all supertraits; this is the index into\n-    // that vtable\n-    pub vtable_index: usize,\n-}\n-\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub struct MethodCallee<'tcx> {\n-    pub origin: MethodOrigin<'tcx>,\n+    /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n+    pub def_id: ast::DefId,\n     pub ty: Ty<'tcx>,\n-    pub substs: subst::Substs<'tcx>\n+    pub substs: &'tcx subst::Substs<'tcx>\n }\n \n /// With method calls, we store some extra information in\n@@ -5595,11 +5538,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_item(&self, trait_did: ast::DefId, idx: usize) -> ImplOrTraitItem<'tcx> {\n-        let method_def_id = self.trait_item_def_ids(trait_did)[idx].def_id();\n-        self.impl_or_trait_item(method_def_id)\n-    }\n-\n     pub fn trait_items(&self, trait_did: ast::DefId) -> Rc<Vec<ImplOrTraitItem<'tcx>>> {\n         let mut trait_items = self.trait_items_cache.borrow_mut();\n         match trait_items.get(&trait_did).cloned() {\n@@ -6443,10 +6381,9 @@ impl<'tcx> ctxt<'tcx> {\n         let name = impl_item.name();\n         match self.trait_of_item(def_id) {\n             Some(trait_did) => {\n-                let trait_items = self.trait_items(trait_did);\n-                trait_items.iter()\n-                    .position(|m| m.name() == name)\n-                    .map(|idx| self.trait_item(trait_did, idx).id())\n+                self.trait_items(trait_did).iter()\n+                    .find(|item| item.name() == name)\n+                    .map(|item| item.id())\n             }\n             None => None\n         }"}, {"sha": "7016c1484659b7165da31aa66a5a778434824852", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -310,34 +310,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::AutoRef<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::MethodOrigin<'tcx> {\n-        match *self {\n-            ty::MethodStatic(def_id) => {\n-                ty::MethodStatic(def_id)\n-            }\n-            ty::MethodStaticClosure(def_id) => {\n-                ty::MethodStaticClosure(def_id)\n-            }\n-            ty::MethodTypeParam(ref param) => {\n-                ty::MethodTypeParam(ty::MethodParam {\n-                    trait_ref: param.trait_ref.fold_with(folder),\n-                    method_num: param.method_num,\n-                    impl_def_id: param.impl_def_id,\n-                })\n-            }\n-            ty::MethodTraitObject(ref object) => {\n-                ty::MethodTraitObject(ty::MethodObject {\n-                    trait_ref: object.trait_ref.fold_with(folder),\n-                    object_trait_id: object.object_trait_id,\n-                    method_num: object.method_num,\n-                    vtable_index: object.vtable_index,\n-                })\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n         *self\n@@ -520,8 +492,8 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n         traits::VtableObjectData {\n-            object_ty: self.object_ty.fold_with(folder),\n             upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n+            vtable_base: self.vtable_base\n         }\n     }\n }"}, {"sha": "9d82b0c2aa8a0ef8ab08baa1b4d3c6b4ba2372a0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -494,38 +494,6 @@ impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::MethodOrigin<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::MethodStatic(def_id) => {\n-                write!(f, \"MethodStatic({:?})\", def_id)\n-            }\n-            ty::MethodStaticClosure(def_id) => {\n-                write!(f, \"MethodStaticClosure({:?})\", def_id)\n-            }\n-            ty::MethodTypeParam(ref p) => write!(f, \"{:?}\", p),\n-            ty::MethodTraitObject(ref p) => write!(f, \"{:?}\", p)\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::MethodParam<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"MethodParam({:?},{})\",\n-               self.trait_ref,\n-               self.method_num)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::MethodObject<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"MethodObject({:?},{},{})\",\n-               self.trait_ref,\n-               self.method_num,\n-               self.vtable_index)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ExistentialBounds<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut empty = true;"}, {"sha": "fa86c0dde991d0e4cf7f00c95b15e914b5c29611", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 78, "deletions": 71, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -33,8 +33,10 @@\n \n use metadata::{csearch, decoder};\n use middle::def::*;\n+use middle::infer;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n+use middle::traits;\n use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::cfg;\n@@ -1863,24 +1865,18 @@ impl LintPass for UnconditionalRecursion {\n \n     fn check_fn(&mut self, cx: &Context, fn_kind: visit::FnKind, _: &ast::FnDecl,\n                 blk: &ast::Block, sp: Span, id: ast::NodeId) {\n-        // FIXME(#23542) Replace with type ascription.\n-        #![allow(trivial_casts)]\n-\n         type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n                               ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n \n-        let (name, checker) = match fn_kind {\n-            visit::FkItemFn(name, _, _, _, _, _) => (name, id_refers_to_this_fn as F),\n-            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n+        let method = match fn_kind {\n+            visit::FkItemFn(..) => None,\n+            visit::FkMethod(..) => {\n+                cx.tcx.impl_or_trait_item(local_def(id)).as_opt_method()\n+            }\n             // closures can't recur, so they don't matter.\n             visit::FkFnBlock => return\n         };\n \n-        let impl_def_id = cx.tcx.impl_of_method(local_def(id))\n-            .unwrap_or(local_def(ast::DUMMY_NODE_ID));\n-        assert!(ast_util::is_local(impl_def_id));\n-        let impl_node_id = impl_def_id.node;\n-\n         // Walk through this function (say `f`) looking to see if\n         // every possible path references itself, i.e. the function is\n         // called recursively unconditionally. This is done by trying\n@@ -1931,7 +1927,17 @@ impl LintPass for UnconditionalRecursion {\n             let node_id = cfg.graph.node_data(idx).id();\n \n             // is this a recursive call?\n-            if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {\n+            let self_recursive = if node_id != ast::DUMMY_NODE_ID {\n+                match method {\n+                    Some(ref method) => {\n+                        expr_refers_to_this_method(cx.tcx, method, node_id)\n+                    }\n+                    None => expr_refers_to_this_fn(cx.tcx, id, node_id)\n+                }\n+            } else {\n+                false\n+            };\n+            if self_recursive {\n                 self_call_spans.push(cx.tcx.map.span(node_id));\n                 // this is a self call, so we shouldn't explore past\n                 // this node in the CFG.\n@@ -1970,15 +1976,12 @@ impl LintPass for UnconditionalRecursion {\n         // all done\n         return;\n \n-        // Functions for identifying if the given NodeId `id`\n-        // represents a call to the function `fn_id`/method\n-        // `method_id`.\n+        // Functions for identifying if the given Expr NodeId `id`\n+        // represents a call to the function `fn_id`/method `method`.\n \n-        fn id_refers_to_this_fn<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      _: ast::NodeId,\n-                                      fn_id: ast::NodeId,\n-                                      _: ast::Ident,\n-                                      id: ast::NodeId) -> bool {\n+        fn expr_refers_to_this_fn(tcx: &ty::ctxt,\n+                                  fn_id: ast::NodeId,\n+                                  id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 ast_map::NodeExpr(&ast::Expr { node: ast::ExprCall(ref callee, _), .. }) => {\n                     tcx.def_map.borrow().get(&callee.id)\n@@ -1988,64 +1991,68 @@ impl LintPass for UnconditionalRecursion {\n             }\n         }\n \n-        // check if the method call `id` refers to method `method_id`\n-        // (with name `method_name` contained in impl `impl_id`).\n-        fn id_refers_to_this_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                          impl_id: ast::NodeId,\n-                                          method_id: ast::NodeId,\n-                                          method_name: ast::Ident,\n-                                          id: ast::NodeId) -> bool {\n-            let did = match tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)) {\n-                None => return false,\n-                Some(m) => match m.origin {\n-                    // There's no way to know if a method call via a\n-                    // vtable is recursion, so we assume it's not.\n-                    ty::MethodTraitObject(_) => return false,\n-\n-                    // This `did` refers directly to the method definition.\n-                    ty::MethodStatic(did) | ty::MethodStaticClosure(did) => did,\n-\n-                    // MethodTypeParam are methods from traits:\n-\n-                    // The `impl ... for ...` of this method call\n-                    // isn't known, e.g. it might be a default method\n-                    // in a trait, so we get the def-id of the trait\n-                    // method instead.\n-                    ty::MethodTypeParam(\n-                        ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n-\n-                        let on_self = m.substs.self_ty().map_or(false, |t| t.is_self());\n-                        if !on_self {\n-                            // we can only be recurring in a default\n+        // Check if the method call `id` refers to method `method`.\n+        fn expr_refers_to_this_method(tcx: &ty::ctxt,\n+                                      method: &ty::Method,\n+                                      id: ast::NodeId) -> bool {\n+            let method_call = ty::MethodCall::expr(id);\n+            let callee = match tcx.tables.borrow().method_map.get(&method_call) {\n+                Some(&m) => m,\n+                None => return false\n+            };\n+            let callee_item = tcx.impl_or_trait_item(callee.def_id);\n+\n+            match callee_item.container() {\n+                // This is an inherent method, so the `def_id` refers\n+                // directly to the method definition.\n+                ty::ImplContainer(_) => {\n+                    callee.def_id == method.def_id\n+                }\n+\n+                // A trait method, from any number of possible sources.\n+                // Attempt to select a concrete impl before checking.\n+                ty::TraitContainer(trait_def_id) => {\n+                    let trait_substs = callee.substs.clone().method_to_trait();\n+                    let trait_substs = tcx.mk_substs(trait_substs);\n+                    let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n+                    let trait_ref = ty::Binder(trait_ref);\n+                    let span = tcx.map.span(id);\n+                    let obligation =\n+                        traits::Obligation::new(traits::ObligationCause::misc(span, id),\n+                                                trait_ref.to_poly_trait_predicate());\n+\n+                    let param_env = ty::ParameterEnvironment::for_item(tcx, method.def_id.node);\n+                    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env), false);\n+                    let mut selcx = traits::SelectionContext::new(&infcx);\n+                    match selcx.select(&obligation) {\n+                        // The method comes from a `T: Trait` bound.\n+                        // If `T` is `Self`, then this call is inside\n+                        // a default method definition.\n+                        Ok(Some(traits::VtableParam(_))) => {\n+                            let self_ty = callee.substs.self_ty();\n+                            let on_self = self_ty.map_or(false, |t| t.is_self());\n+                            // We can only be recurring in a default\n                             // method if we're being called literally\n                             // on the `Self` type.\n-                            return false\n+                            on_self && callee.def_id == method.def_id\n                         }\n \n-                        tcx.trait_item(trait_ref.def_id, method_num).def_id()\n-                    }\n-\n-                    // The `impl` is known, so we check that with a\n-                    // special case:\n-                    ty::MethodTypeParam(\n-                        ty::MethodParam { impl_def_id: Some(impl_def_id), .. }) => {\n+                        // The `impl` is known, so we check that with a\n+                        // special case:\n+                        Ok(Some(traits::VtableImpl(vtable_impl))) => {\n+                            let container = ty::ImplContainer(vtable_impl.impl_def_id);\n+                            // It matches if it comes from the same impl,\n+                            // and has the same method name.\n+                            container == method.container\n+                                && callee_item.name() == method.name\n+                        }\n \n-                        let name = match tcx.map.expect_expr(id).node {\n-                            ast::ExprMethodCall(ref sp_ident, _, _) => sp_ident.node,\n-                            _ => tcx.sess.span_bug(\n-                                tcx.map.span(id),\n-                                \"non-method call expr behaving like a method call?\")\n-                        };\n-                        // It matches if it comes from the same impl,\n-                        // and has the same method name.\n-                        return ast_util::is_local(impl_def_id)\n-                            && impl_def_id.node == impl_id\n-                            && method_name.name == name.name\n+                        // There's no way to know if this call is\n+                        // recursive, so we assume it's not.\n+                        _ => return false\n                     }\n                 }\n-            };\n-\n-            ast_util::is_local(did) && did.node == method_id\n+            }\n         }\n     }\n }"}, {"sha": "d90e5a033a187bb90de3360811dc61e3d7450f99", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -40,10 +40,6 @@ use rustc::middle::privacy::ImportUse::*;\n use rustc::middle::privacy::LastPrivate::*;\n use rustc::middle::privacy::PrivateDep::*;\n use rustc::middle::privacy::{ExternalExports, ExportedItems, PublicItems};\n-use rustc::middle::ty::{MethodTypeParam, MethodStatic};\n-use rustc::middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n-use rustc::middle::ty::{MethodStaticClosure, MethodObject};\n-use rustc::middle::ty::MethodTraitObject;\n use rustc::middle::ty::{self, Ty};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n \n@@ -53,7 +49,7 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit::{self, Visitor};\n \n-type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a def::ExportMap);\n+type Context<'a, 'tcx> = (&'a ty::MethodMap<'tcx>, &'a def::ExportMap);\n \n /// Result of a checking operation - None => no errors were found. Some => an\n /// error and contains the span and message for reporting that error and\n@@ -848,18 +844,16 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, origin: &MethodOrigin,\n+    fn check_method(&mut self, span: Span, method_def_id: ast::DefId,\n                     name: ast::Name) {\n-        match *origin {\n-            MethodStatic(method_id) => {\n-                self.check_static_method(span, method_id, name)\n+        match self.tcx.impl_or_trait_item(method_def_id).container() {\n+            ty::ImplContainer(_) => {\n+                self.check_static_method(span, method_def_id, name)\n             }\n-            MethodStaticClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n-            MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_ref.def_id,\n+            ty::TraitContainer(trait_def_id) => {\n+                self.report_error(self.ensure_public(span, trait_def_id,\n                                                      None, \"source trait\"));\n             }\n         }\n@@ -903,18 +897,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n-                let method_call = MethodCall::expr(expr.id);\n-                match self.tcx.tables.borrow().method_map.get(&method_call) {\n-                    None => {\n-                        self.tcx.sess.span_bug(expr.span,\n-                                                \"method call not in \\\n-                                                method map\");\n-                    }\n-                    Some(method) => {\n-                        debug!(\"(privacy checking) checking impl method\");\n-                        self.check_method(expr.span, &method.origin, ident.node.name);\n-                    }\n-                }\n+                let method_call = ty::MethodCall::expr(expr.id);\n+                let method = self.tcx.tables.borrow().method_map[&method_call];\n+                debug!(\"(privacy checking) checking impl method\");\n+                self.check_method(expr.span, method.def_id, ident.node.name);\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n                 match self.tcx.expr_ty(expr).sty {"}, {"sha": "e88b3980737ab075eccb761660b7475502c37cba", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -886,43 +886,11 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n-        let method_map = &self.tcx.tables.borrow().method_map;\n-        let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n-        let (def_id, decl_id) = match method_callee.origin {\n-            ty::MethodStatic(def_id) |\n-            ty::MethodStaticClosure(def_id) => {\n-                // method invoked on an object with a concrete type (not a static method)\n-                let decl_id =\n-                    match self.tcx.trait_item_of_item(def_id) {\n-                        None => None,\n-                        Some(decl_id) => Some(decl_id.def_id()),\n-                    };\n-\n-                // This incantation is required if the method referenced is a\n-                // trait's default implementation.\n-                let def_id = match self.tcx.impl_or_trait_item(def_id) {\n-                    ty::MethodTraitItem(method) => {\n-                        method.provided_source.unwrap_or(def_id)\n-                    }\n-                    _ => self.sess\n-                             .span_bug(ex.span,\n-                                       \"save::process_method_call: non-method \\\n-                                        DefId in MethodStatic or MethodStaticClosure\"),\n-                };\n-                (Some(def_id), decl_id)\n-            }\n-            ty::MethodTypeParam(ref mp) => {\n-                // method invoked on a type parameter\n-                let trait_item = self.tcx.trait_item(mp.trait_ref.def_id,\n-                                                     mp.method_num);\n-                (None, Some(trait_item.def_id()))\n-            }\n-            ty::MethodTraitObject(ref mo) => {\n-                // method invoked on a trait instance\n-                let trait_item = self.tcx.trait_item(mo.trait_ref.def_id,\n-                                                     mo.method_num);\n-                (None, Some(trait_item.def_id()))\n-            }\n+        let method_call = ty::MethodCall::expr(ex.id);\n+        let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+        let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n+            ty::ImplContainer(_) => (Some(method_id), None),\n+            ty::TraitContainer(_) => (None, Some(method_id))\n         };\n         let sub_span = self.span.sub_span_for_meth_name(ex.span);\n         self.fmt.meth_call_str(ex.span,"}, {"sha": "debc8dd59c04c0187547627a39f288646b93e124", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 64, "deletions": 103, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -22,7 +22,6 @@ use arena::TypedArena;\n use back::link;\n use session;\n use llvm::{self, ValueRef, get_params};\n-use metadata::csearch;\n use middle::def;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n@@ -66,7 +65,7 @@ pub struct MethodData {\n pub enum CalleeData<'tcx> {\n     // Constructor for enum variant/tuple-like-struct\n     // i.e. Some, Ok\n-    NamedTupleConstructor(subst::Substs<'tcx>, ty::Disr),\n+    NamedTupleConstructor(ty::Disr),\n \n     // Represents a (possibly monomorphized) top-level fn item or method\n     // item. Note that this is just the fn-ptr and is not a Rust closure\n@@ -81,6 +80,7 @@ pub enum CalleeData<'tcx> {\n pub struct Callee<'blk, 'tcx: 'blk> {\n     pub bcx: Block<'blk, 'tcx>,\n     pub data: CalleeData<'tcx>,\n+    pub ty: Ty<'tcx>\n }\n \n fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n@@ -104,11 +104,11 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n         let DatumBlock { bcx, datum, .. } = expr::trans(bcx, expr);\n         match datum.ty.sty {\n             ty::TyBareFn(..) => {\n-                let llval = datum.to_llscalarish(bcx);\n-                return Callee {\n+                Callee {\n                     bcx: bcx,\n-                    data: Fn(llval),\n-                };\n+                    ty: datum.ty,\n+                    data: Fn(datum.to_llscalarish(bcx))\n+                }\n             }\n             _ => {\n                 bcx.tcx().sess.span_bug(\n@@ -119,12 +119,13 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n         }\n     }\n \n-    fn fn_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, llfn: ValueRef)\n+    fn fn_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, datum: Datum<'tcx, Rvalue>)\n                              -> Callee<'blk, 'tcx> {\n-        return Callee {\n+        Callee {\n             bcx: bcx,\n-            data: Fn(llfn),\n-        };\n+            data: Fn(datum.val),\n+            ty: datum.ty\n+        }\n     }\n \n     fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -143,12 +144,10 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     _ => false\n                 }\n             } => {\n-                let substs = common::node_id_substs(bcx.ccx(),\n-                                                    ExprId(ref_expr.id),\n-                                                    bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(substs, 0)\n+                    data: NamedTupleConstructor(0),\n+                    ty: expr_ty\n                 }\n             }\n             def::DefFn(did, _) if match expr_ty.sty {\n@@ -159,40 +158,36 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                                     ExprId(ref_expr.id),\n                                                     bcx.fcx.param_substs);\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                Callee { bcx: bcx, data: Intrinsic(def_id.node, substs) }\n+                Callee { bcx: bcx, data: Intrinsic(def_id.node, substs), ty: expr_ty }\n             }\n             def::DefFn(did, _) | def::DefMethod(did, def::FromImpl(_)) => {\n                 fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs).val)\n+                                            bcx.fcx.param_substs))\n             }\n             def::DefMethod(meth_did, def::FromTrait(trait_did)) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx.ccx(),\n                                                                 meth_did,\n                                                                 trait_did,\n                                                                 ref_expr.id,\n-                                                                bcx.fcx.param_substs).val)\n+                                                                bcx.fcx.param_substs))\n             }\n             def::DefVariant(tid, vid, _) => {\n                 let vinfo = bcx.tcx().enum_variant_with_id(tid, vid);\n-                let substs = common::node_id_substs(bcx.ccx(),\n-                                                    ExprId(ref_expr.id),\n-                                                    bcx.fcx.param_substs);\n \n                 // Nullary variants are not callable\n                 assert!(!vinfo.args.is_empty());\n \n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(substs, vinfo.disr_val)\n+                    data: NamedTupleConstructor(vinfo.disr_val),\n+                    ty: expr_ty\n                 }\n             }\n             def::DefStruct(_) => {\n-                let substs = common::node_id_substs(bcx.ccx(),\n-                                                    ExprId(ref_expr.id),\n-                                                    bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(substs, 0)\n+                    data: NamedTupleConstructor(0),\n+                    ty: expr_ty\n                 }\n             }\n             def::DefStatic(..) |\n@@ -232,21 +227,6 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     trans_fn_ref_with_substs(ccx, def_id, node, param_substs, substs)\n }\n \n-fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                  def_id: ast::DefId,\n-                                                  ref_id: ast::NodeId,\n-                                                  substs: subst::Substs<'tcx>)\n-                                                  -> Callee<'blk, 'tcx> {\n-    Callee {\n-        bcx: bcx,\n-        data: Fn(trans_fn_ref_with_substs(bcx.ccx(),\n-                                          def_id,\n-                                          ExprId(ref_id),\n-                                          bcx.fcx.param_substs,\n-                                          substs).val),\n-    }\n-}\n-\n /// Translates an adapter that implements the `Fn` trait for a fn\n /// pointer. This is basically the equivalent of something like:\n ///\n@@ -356,12 +336,13 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n     );\n \n-    bcx = trans_call_inner(bcx,\n-                           DebugLoc::None,\n-                           bare_fn_ty,\n-                           |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(&llargs[(self_idx + 1)..]),\n-                           dest).bcx;\n+    bcx = trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n+        Callee {\n+            bcx: bcx,\n+            data: Fn(llfnpointer),\n+            ty: bare_fn_ty\n+        }\n+    }, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n@@ -518,7 +499,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             let ref_ty = match node {\n                 ExprId(id) => tcx.node_id_to_type(id),\n                 MethodCallKey(method_call) => {\n-                    tcx.tables.borrow().method_map.get(&method_call).unwrap().ty\n+                    tcx.tables.borrow().method_map[&method_call].ty\n                 }\n             };\n             let ref_ty = monomorphize::apply_param_substs(tcx,\n@@ -586,17 +567,16 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call<'a, 'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n+pub fn trans_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   call_expr: &ast::Expr,\n                                   f: &ast::Expr,\n                                   args: CallArgs<'a, 'tcx>,\n                                   dest: expr::Dest)\n                                   -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_call\");\n-    trans_call_inner(in_cx,\n+    trans_call_inner(bcx,\n                      call_expr.debug_loc(),\n-                     common::expr_ty_adjusted(in_cx, f),\n-                     |cx, _| trans(cx, f),\n+                     |bcx, _| trans(bcx, f),\n                      args,\n                      Some(dest)).bcx\n }\n@@ -610,22 +590,9 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_expr={:?})\", call_expr);\n     let method_call = MethodCall::expr(call_expr.id);\n-    let method_ty = match bcx.tcx().tables.borrow().method_map.get(&method_call) {\n-        Some(method) => match method.origin {\n-            ty::MethodTraitObject(_) => match method.ty.sty {\n-                ty::TyBareFn(_, ref fty) => {\n-                    bcx.tcx().mk_fn(None, meth::opaque_method_ty(bcx.tcx(), fty))\n-                }\n-                _ => method.ty\n-            },\n-            _ => method.ty\n-        },\n-        None => panic!(\"method not found in trans_method_call\")\n-    };\n     trans_call_inner(\n         bcx,\n         call_expr.debug_loc(),\n-        common::monomorphize_type(bcx, method_ty),\n         |cx, arg_cleanup_scope| {\n             meth::trans_method_callee(cx, method_call, Some(rcvr), arg_cleanup_scope)\n         },\n@@ -639,22 +606,18 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    dest: Option<expr::Dest>,\n                                    debug_loc: DebugLoc)\n                                    -> Result<'blk, 'tcx> {\n-    let fty = if did.krate == ast::LOCAL_CRATE {\n-        bcx.tcx().node_id_to_type(did.node)\n-    } else {\n-        csearch::get_type(bcx.tcx(), did).ty\n-    };\n-    callee::trans_call_inner(bcx,\n-                             debug_loc,\n-                             fty,\n-                             |bcx, _| {\n-                                trans_fn_ref_with_substs_to_callee(bcx,\n-                                                                   did,\n-                                                                   0,\n-                                                                   subst::Substs::trans_empty())\n-                             },\n-                             ArgVals(args),\n-                             dest)\n+    callee::trans_call_inner(bcx, debug_loc, |bcx, _| {\n+        let datum = trans_fn_ref_with_substs(bcx.ccx(),\n+                                             did,\n+                                             ExprId(0),\n+                                             bcx.fcx.param_substs,\n+                                             subst::Substs::trans_empty());\n+        Callee {\n+            bcx: bcx,\n+            data: Fn(datum.val),\n+            ty: datum.ty\n+        }\n+    }, ArgVals(args), dest)\n }\n \n /// This behemoth of a function translates function calls. Unfortunately, in order to generate more\n@@ -669,7 +632,6 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// somewhere. Nonetheless we return the actual return value of the function.\n pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                            debug_loc: DebugLoc,\n-                                           callee_ty: Ty<'tcx>,\n                                            get_callee: F,\n                                            args: CallArgs<'a, 'tcx>,\n                                            dest: Option<expr::Dest>)\n@@ -690,20 +652,20 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let callee = get_callee(bcx, cleanup::CustomScope(arg_cleanup_scope));\n     let mut bcx = callee.bcx;\n \n-    let (abi, ret_ty) = match callee_ty.sty {\n+    let (abi, ret_ty) = match callee.ty.sty {\n         ty::TyBareFn(_, ref f) => {\n             let output = bcx.tcx().erase_late_bound_regions(&f.sig.output());\n             (f.abi, output)\n         }\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n \n-    let (llfn, llenv, llself) = match callee.data {\n+    let (llfn, llself) = match callee.data {\n         Fn(llfn) => {\n-            (llfn, None, None)\n+            (llfn, None)\n         }\n         TraitItem(d) => {\n-            (d.llfn, None, Some(d.llself))\n+            (d.llfn, Some(d.llself))\n         }\n         Intrinsic(node, substs) => {\n             assert!(abi == synabi::RustIntrinsic);\n@@ -716,18 +678,17 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n-            return intrinsic::trans_intrinsic_call(bcx, node, callee_ty,\n+            return intrinsic::trans_intrinsic_call(bcx, node, callee.ty,\n                                                    arg_cleanup_scope, args,\n                                                    dest.unwrap(), substs,\n                                                    call_info);\n         }\n-        NamedTupleConstructor(substs, disr) => {\n+        NamedTupleConstructor(disr) => {\n             assert!(dest.is_some());\n             fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n-            let ctor_ty = callee_ty.subst(bcx.tcx(), &substs);\n             return base::trans_named_tuple_constructor(bcx,\n-                                                       ctor_ty,\n+                                                       callee.ty,\n                                                        disr,\n                                                        args,\n                                                        dest.unwrap(),\n@@ -794,17 +755,15 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n \n-        // Push the environment (or a trait object's self).\n-        match (llenv, llself) {\n-            (Some(llenv), None) => llargs.push(llenv),\n-            (None, Some(llself)) => llargs.push(llself),\n-            _ => {}\n+        // Push a trait object's self.\n+        if let Some(llself) = llself {\n+            llargs.push(llself);\n         }\n \n         // Push the arguments.\n         bcx = trans_args(bcx,\n                          args,\n-                         callee_ty,\n+                         callee.ty,\n                          &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n                          llself.is_some(),\n@@ -816,7 +775,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n                                       &llargs[..],\n-                                      callee_ty,\n+                                      callee.ty,\n                                       debug_loc);\n         bcx = b;\n         llresult = llret;\n@@ -845,15 +804,15 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         };\n         bcx = trans_args(bcx,\n                          args,\n-                         callee_ty,\n+                         callee.ty,\n                          &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n                          false,\n                          abi);\n         fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n         bcx = foreign::trans_native_call(bcx,\n-                                         callee_ty,\n+                                         callee.ty,\n                                          llfn,\n                                          opt_llretslot.unwrap(),\n                                          &llargs[..],\n@@ -894,11 +853,11 @@ pub enum CallArgs<'a, 'tcx> {\n     // value.\n     ArgVals(&'a [ValueRef]),\n \n-    // For overloaded operators: `(lhs, Vec(rhs, rhs_id), autoref)`. `lhs`\n+    // For overloaded operators: `(lhs, Option(rhs, rhs_id), autoref)`. `lhs`\n     // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n-    // the right-hand-side arguments (if any). `autoref` indicates whether the `rhs`\n+    // the right-hand-side argument (if any). `autoref` indicates whether the `rhs`\n     // arguments should be auto-referenced\n-    ArgOverloadedOp(Datum<'tcx, Expr>, Vec<(Datum<'tcx, Expr>, ast::NodeId)>, bool),\n+    ArgOverloadedOp(Datum<'tcx, Expr>, Option<(Datum<'tcx, Expr>, ast::NodeId)>, bool),\n \n     // Supply value of arguments as a list of expressions that must be\n     // translated, for overloaded call operators.\n@@ -1077,12 +1036,14 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                   DontAutorefArg,\n                                   llargs);\n \n-            assert_eq!(arg_tys.len(), 1 + rhs.len());\n-            for (rhs, rhs_id) in rhs {\n+            if let Some((rhs, rhs_id)) = rhs {\n+                assert_eq!(arg_tys.len(), 2);\n                 bcx = trans_arg_datum(bcx, arg_tys[1], rhs,\n                                       arg_cleanup_scope,\n                                       if autoref { DoAutorefArg(rhs_id) } else { DontAutorefArg },\n                                       llargs);\n+            } else {\n+                assert_eq!(arg_tys.len(), 1);\n             }\n         }\n         ArgVals(vs) => {"}, {"sha": "d813e9dbf40fab9ca75b4c9d21f04697c9817557", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -429,12 +429,13 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let callee_data = TraitItem(MethodData { llfn: llreffn,\n                                              llself: env_datum.val });\n \n-    bcx = callee::trans_call_inner(bcx,\n-                                   DebugLoc::None,\n-                                   llref_fn_ty,\n-                                   |bcx, _| Callee { bcx: bcx, data: callee_data },\n-                                   ArgVals(&llargs[(self_idx + 1)..]),\n-                                   dest).bcx;\n+    bcx = callee::trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n+        Callee {\n+            bcx: bcx,\n+            data: callee_data,\n+            ty: llref_fn_ty\n+        }\n+    }, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n \n     fcx.pop_custom_cleanup_scope(self_scope);\n "}, {"sha": "e1c1ac9a772eb512794607dfd0ec3e9f1cce00b3", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -874,7 +874,6 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n            trait_ref, trait_ref.def_id());\n \n-    tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n@@ -1026,7 +1025,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             tcx.node_id_item_substs(id).substs\n         }\n         MethodCallKey(method_call) => {\n-            tcx.tables.borrow().method_map.get(&method_call).unwrap().substs.clone()\n+            tcx.tables.borrow().method_map[&method_call].substs.clone()\n         }\n     };\n "}, {"sha": "e7e2793fc7e9d28e2b8a1c35c8542df33658ccc7", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -894,10 +894,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprMethodCall(_, _, ref args) => {\n               let arg_vals = map_list(args);\n               let method_call = ty::MethodCall::expr(e.id);\n-              let method_did = match cx.tcx().tables.borrow().method_map[&method_call].origin {\n-                  ty::MethodStatic(did) => did,\n-                  _ => cx.sess().span_bug(e.span, \"expected a const method def\")\n-              };\n+              let method_did = cx.tcx().tables.borrow().method_map[&method_call].def_id;\n               const_fn_call(cx, MethodCallKey(method_call),\n                             method_did, &arg_vals, param_substs)\n           }"}, {"sha": "7722cb322c9e6e59f9b6829fa780c1b007063f33", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -805,7 +805,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                index_expr,\n                                                method_call,\n                                                base_datum,\n-                                               vec![(ix_datum, idx.id)],\n+                                               Some((ix_datum, idx.id)),\n                                                Some(SaveIn(scratch.val)),\n                                                false));\n             let datum = scratch.to_expr_datum();\n@@ -1175,21 +1175,21 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let lhs = unpack_datum!(bcx, trans(bcx, &**lhs));\n             let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n-                                vec![(rhs_datum, rhs.id)], Some(dest),\n+                                Some((rhs_datum, rhs.id)), Some(dest),\n                                 !ast_util::is_by_value_binop(op.node)).bcx\n         }\n         ast::ExprUnary(op, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let arg = unpack_datum!(bcx, trans(bcx, &**subexpr));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n-                                arg, Vec::new(), Some(dest), !ast_util::is_by_value_unop(op)).bcx\n+                                arg, None, Some(dest), !ast_util::is_by_value_unop(op)).bcx\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let base = unpack_datum!(bcx, trans(bcx, &**base));\n             let idx_datum = unpack_datum!(bcx, trans(bcx, &**idx));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n-                                vec![(idx_datum, idx.id)], Some(dest), true).bcx\n+                                Some((idx_datum, idx.id)), Some(dest), true).bcx\n         }\n         ast::ExprCast(..) => {\n             // Trait casts used to come this way, now they should be coercions.\n@@ -1943,19 +1943,12 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &ast::Expr,\n                                    method_call: MethodCall,\n                                    lhs: Datum<'tcx, Expr>,\n-                                   rhs: Vec<(Datum<'tcx, Expr>, ast::NodeId)>,\n+                                   rhs: Option<(Datum<'tcx, Expr>, ast::NodeId)>,\n                                    dest: Option<Dest>,\n                                    autoref: bool)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = bcx.tcx()\n-                       .tables\n-                       .borrow()\n-                       .method_map\n-                       .get(&method_call).unwrap().ty;\n-\n     callee::trans_call_inner(bcx,\n                              expr.debug_loc(),\n-                             monomorphize_type(bcx, method_ty),\n                              |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n                                                           method_call,\n@@ -1974,20 +1967,11 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                          -> Block<'blk, 'tcx> {\n     debug!(\"trans_overloaded_call {}\", expr.id);\n     let method_call = MethodCall::expr(expr.id);\n-    let method_type = bcx.tcx()\n-                         .tables\n-                         .borrow()\n-                         .method_map\n-                         .get(&method_call)\n-                         .unwrap()\n-                         .ty;\n     let mut all_args = vec!(callee);\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,\n                    callee::trans_call_inner(bcx,\n                                             expr.debug_loc(),\n-                                            monomorphize_type(bcx,\n-                                                              method_type),\n                                             |bcx, arg_cleanup_scope| {\n                                                 meth::trans_method_callee(\n                                                     bcx,\n@@ -2259,7 +2243,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n-                                                    datum, Vec::new(), Some(SaveIn(scratch.val)),\n+                                                    datum, None, Some(SaveIn(scratch.val)),\n                                                     false));\n             scratch.to_expr_datum()\n         }"}, {"sha": "1fa996f76b9a28809a2778a3ee2ac2342089abdd", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 85, "deletions": 129, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -39,7 +39,6 @@ use trans::type_of::*;\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::MethodCall;\n \n-use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, attr, visit};\n use syntax::codemap::DUMMY_SP;\n@@ -107,34 +106,28 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n-    let (origin, method_ty) =\n-        bcx.tcx()\n-           .tables\n-           .borrow()\n-           .method_map\n-           .get(&method_call)\n-           .map(|method| (method.origin.clone(), method.ty))\n-           .unwrap();\n-\n-    match origin {\n-        ty::MethodStatic(did) |\n-        ty::MethodStaticClosure(did) => {\n-            debug!(\"trans_method_callee: static, {:?}\", did);\n+    let method = bcx.tcx().tables.borrow().method_map[&method_call];\n+\n+    match bcx.tcx().impl_or_trait_item(method.def_id).container() {\n+        ty::ImplContainer(_) => {\n+            debug!(\"trans_method_callee: static, {:?}\", method.def_id);\n+            let datum = callee::trans_fn_ref(bcx.ccx(),\n+                                             method.def_id,\n+                                             MethodCallKey(method_call),\n+                                             bcx.fcx.param_substs);\n             Callee {\n                 bcx: bcx,\n-                data: Fn(callee::trans_fn_ref(bcx.ccx(),\n-                                              did,\n-                                              MethodCallKey(method_call),\n-                                              bcx.fcx.param_substs).val),\n+                data: Fn(datum.val),\n+                ty: datum.ty\n             }\n         }\n \n-        ty::MethodTypeParam(ty::MethodParam {\n-            ref trait_ref,\n-            method_num,\n-            impl_def_id: _\n-        }) => {\n-            let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n+        ty::TraitContainer(trait_def_id) => {\n+            let trait_substs = method.substs.clone().method_to_trait();\n+            let trait_substs = bcx.tcx().mk_substs(trait_substs);\n+            let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n+\n+            let trait_ref = ty::Binder(bcx.monomorphize(&trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n             debug!(\"method_call={:?} trait_ref={:?} trait_ref id={:?} substs={:?}\",\n                    method_call,\n@@ -147,25 +140,12 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debug!(\"origin = {:?}\", origin);\n             trans_monomorphized_callee(bcx,\n                                        method_call,\n-                                       trait_ref.def_id(),\n-                                       method_num,\n-                                       origin)\n-        }\n-\n-        ty::MethodTraitObject(ref mt) => {\n-            let self_expr = match self_expr {\n-                Some(self_expr) => self_expr,\n-                None => {\n-                    bcx.sess().span_bug(bcx.tcx().map.span(method_call.expr_id),\n-                                        \"self expr wasn't provided for trait object \\\n-                                         callee (trying to call overloaded op?)\")\n-                }\n-            };\n-            trans_trait_callee(bcx,\n-                               monomorphize_type(bcx, method_ty),\n-                               mt.vtable_index,\n-                               self_expr,\n-                               arg_cleanup_scope)\n+                                       self_expr,\n+                                       trait_def_id,\n+                                       method.def_id,\n+                                       method.ty,\n+                                       origin,\n+                                       arg_cleanup_scope)\n         }\n     }\n }\n@@ -235,8 +215,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n     debug!(\"trait_substs={:?}\", trait_substs);\n-    let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n-                                              substs: trait_substs });\n+    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, trait_substs));\n     let vtbl = fulfill_obligation(ccx,\n                                   DUMMY_SP,\n                                   trait_ref);\n@@ -282,18 +261,11 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      callee_substs)\n         }\n         traits::VtableObject(ref data) => {\n-            let trait_item_def_ids =\n-                ccx.tcx().trait_item_def_ids(trait_id);\n-            let method_offset_in_trait =\n-                trait_item_def_ids.iter()\n-                                  .position(|item| item.def_id() == method_id)\n-                                  .unwrap();\n-            let (llfn, ty) =\n-                trans_object_shim(ccx,\n-                                  data.object_ty,\n-                                  data.upcast_trait_ref.clone(),\n-                                  method_offset_in_trait);\n-            immediate_rvalue(llfn, ty)\n+            let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n+            trans_object_shim(ccx,\n+                              data.upcast_trait_ref.clone(),\n+                              method_id,\n+                              idx)\n         }\n         _ => {\n             tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\",\n@@ -326,16 +298,19 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n \n fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n+                                          self_expr: Option<&ast::Expr>,\n                                           trait_id: ast::DefId,\n-                                          n_method: usize,\n-                                          vtable: traits::Vtable<'tcx, ()>)\n+                                          method_id: ast::DefId,\n+                                          method_ty: Ty<'tcx>,\n+                                          vtable: traits::Vtable<'tcx, ()>,\n+                                          arg_cleanup_scope: cleanup::ScopeId)\n                                           -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtable {\n         traits::VtableImpl(vtable_impl) => {\n             let ccx = bcx.ccx();\n             let impl_did = vtable_impl.impl_def_id;\n-            let mname = match ccx.tcx().trait_item(trait_id, n_method) {\n+            let mname = match ccx.tcx().impl_or_trait_item(method_id) {\n                 ty::MethodTraitItem(method) => method.name,\n                 _ => {\n                     bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n@@ -351,13 +326,13 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     bcx, MethodCallKey(method_call), vtable_impl.substs);\n \n             // translate the function\n-            let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n-                                                mth_id,\n-                                                MethodCallKey(method_call),\n-                                                bcx.fcx.param_substs,\n-                                                callee_substs).val;\n+            let datum = trans_fn_ref_with_substs(bcx.ccx(),\n+                                                 mth_id,\n+                                                 MethodCallKey(method_call),\n+                                                 bcx.fcx.param_substs,\n+                                                 callee_substs);\n \n-            Callee { bcx: bcx, data: Fn(llfn) }\n+            Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n         }\n         traits::VtableClosure(vtable_closure) => {\n             // The substitutions should have no type parameters remaining\n@@ -372,19 +347,31 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Callee {\n                 bcx: bcx,\n                 data: Fn(llfn),\n+                ty: monomorphize_type(bcx, method_ty)\n             }\n         }\n         traits::VtableFnPointer(fn_ty) => {\n             let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n             let llfn = trans_fn_pointer_shim(bcx.ccx(), trait_closure_kind, fn_ty);\n-            Callee { bcx: bcx, data: Fn(llfn) }\n+            Callee {\n+                bcx: bcx,\n+                data: Fn(llfn),\n+                ty: monomorphize_type(bcx, method_ty)\n+            }\n         }\n         traits::VtableObject(ref data) => {\n-            let (llfn, _) = trans_object_shim(bcx.ccx(),\n-                                              data.object_ty,\n-                                              data.upcast_trait_ref.clone(),\n-                                              n_method);\n-            Callee { bcx: bcx, data: Fn(llfn) }\n+            let idx = traits::get_vtable_index_of_object_method(bcx.tcx(), data, method_id);\n+            if let Some(self_expr) = self_expr {\n+                if let ty::TyBareFn(_, ref fty) = monomorphize_type(bcx, method_ty).sty {\n+                    let ty = bcx.tcx().mk_fn(None, opaque_method_ty(bcx.tcx(), fty));\n+                    return trans_trait_callee(bcx, ty, idx, self_expr, arg_cleanup_scope);\n+                }\n+            }\n+            let datum = trans_object_shim(bcx.ccx(),\n+                                          data.upcast_trait_ref.clone(),\n+                                          method_id,\n+                                          idx);\n+            Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n         }\n         traits::VtableBuiltin(..) |\n         traits::VtableDefaultImpl(..) |\n@@ -438,7 +425,7 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// object. Objects are represented as a pair, so we first evaluate the self expression and then\n /// extract the self data and vtable out of the pair.\n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  method_ty: Ty<'tcx>,\n+                                  opaque_fn_ty: Ty<'tcx>,\n                                   vtable_index: usize,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n@@ -471,51 +458,39 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llself = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_ADDR]));\n     let llvtable = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_EXTRA]));\n-    trans_trait_callee_from_llval(bcx, method_ty, vtable_index, llself, llvtable)\n+    trans_trait_callee_from_llval(bcx, opaque_fn_ty, vtable_index, llself, llvtable)\n }\n \n /// Same as `trans_trait_callee()` above, except that it is given a by-ref pointer to the object\n /// pair.\n-pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                 callee_ty: Ty<'tcx>,\n-                                                 vtable_index: usize,\n-                                                 llself: ValueRef,\n-                                                 llvtable: ValueRef)\n-                                                 -> Callee<'blk, 'tcx> {\n+fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                             opaque_fn_ty: Ty<'tcx>,\n+                                             vtable_index: usize,\n+                                             llself: ValueRef,\n+                                             llvtable: ValueRef)\n+                                             -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n     debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llself={}, llvtable={})\",\n-           callee_ty,\n+           opaque_fn_ty,\n            vtable_index,\n            bcx.val_to_string(llself),\n            bcx.val_to_string(llvtable));\n \n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-    let llcallee_ty = match callee_ty.sty {\n-        ty::TyBareFn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n-            let fake_sig =\n-                ty::Binder(ty::FnSig {\n-                    inputs: f.sig.0.inputs[1..].to_vec(),\n-                    output: f.sig.0.output,\n-                    variadic: f.sig.0.variadic,\n-                });\n-            type_of_rust_fn(ccx, Some(Type::i8p(ccx)), &fake_sig, f.abi)\n-        }\n-        _ => {\n-            ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n-        }\n-    };\n     let mptr = Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]));\n+    let llcallee_ty = type_of_fn_from_ty(ccx, opaque_fn_ty);\n \n-    return Callee {\n+    Callee {\n         bcx: bcx,\n         data: TraitItem(MethodData {\n             llfn: PointerCast(bcx, mptr, llcallee_ty.ptr_to()),\n             llself: PointerCast(bcx, llself, Type::i8p(ccx)),\n-        })\n-    };\n+        }),\n+        ty: opaque_fn_ty\n+    }\n }\n \n /// Generate a shim function that allows an object type like `SomeTrait` to\n@@ -540,40 +515,27 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// In fact, all virtual calls can be thought of as normal trait calls\n /// that go through this shim function.\n-pub fn trans_object_shim<'a, 'tcx>(\n+fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n-    object_ty: Ty<'tcx>,\n     upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-    method_offset_in_trait: usize)\n-    -> (ValueRef, Ty<'tcx>)\n+    method_id: ast::DefId,\n+    vtable_index: usize)\n+    -> Datum<'tcx, Rvalue>\n {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n-    let trait_id = upcast_trait_ref.def_id();\n \n-    debug!(\"trans_object_shim(object_ty={:?}, upcast_trait_ref={:?}, method_offset_in_trait={})\",\n-           object_ty,\n+    debug!(\"trans_object_shim(upcast_trait_ref={:?}, method_id={:?})\",\n            upcast_trait_ref,\n-           method_offset_in_trait);\n-\n-    let object_trait_ref =\n-        match object_ty.sty {\n-            ty::TyTrait(ref data) => {\n-                data.principal_trait_ref_with_self_ty(tcx, object_ty)\n-            }\n-            _ => {\n-                tcx.sess.bug(&format!(\"trans_object_shim() called on non-object: {:?}\",\n-                                      object_ty));\n-            }\n-        };\n+           method_id);\n \n     // Upcast to the trait in question and extract out the substitutions.\n     let upcast_trait_ref = tcx.erase_late_bound_regions(&upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n     debug!(\"trans_object_shim: object_substs={:?}\", object_substs);\n \n     // Lookup the type of this method as declared in the trait and apply substitutions.\n-    let method_ty = match tcx.trait_item(trait_id, method_offset_in_trait) {\n+    let method_ty = match tcx.impl_or_trait_item(method_id) {\n         ty::MethodTraitItem(method) => method,\n         _ => {\n             tcx.sess.bug(\"can't create a method shim for a non-method item\")\n@@ -622,27 +584,21 @@ pub fn trans_object_shim<'a, 'tcx>(\n         fcx.llretslotptr.get().map(\n             |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n \n-    let method_offset_in_vtable =\n-        traits::get_vtable_index_of_object_method(bcx.tcx(),\n-                                                  object_trait_ref.clone(),\n-                                                  trait_id,\n-                                                  method_offset_in_trait);\n     debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n-           method_offset_in_vtable);\n+           vtable_index);\n \n     bcx = trans_call_inner(bcx,\n                            DebugLoc::None,\n-                           method_bare_fn_ty,\n                            |bcx, _| trans_trait_callee_from_llval(bcx,\n                                                                   method_bare_fn_ty,\n-                                                                  method_offset_in_vtable,\n+                                                                  vtable_index,\n                                                                   llself, llvtable),\n                            ArgVals(&llargs[(self_idx + 2)..]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n-    (llfn, method_bare_fn_ty)\n+    immediate_rvalue(llfn, shim_fn_ty)\n }\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n@@ -825,8 +781,8 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n /// Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-pub fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n-        -> &'tcx ty::BareFnTy<'tcx> {\n+fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n+                          -> &'tcx ty::BareFnTy<'tcx> {\n     let mut inputs = method_ty.sig.0.inputs.clone();\n     inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::TyI8));\n "}, {"sha": "98fe57ec31446f6cfac18a613707bd4f7d6e1fd0", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -59,7 +59,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let item_ty = ccx.tcx().lookup_item_type(fn_id).ty;\n \n     debug!(\"monomorphic_fn about to subst into {:?}\", item_ty);\n-    let mono_ty = item_ty.subst(ccx.tcx(), psubsts);\n+    let mono_ty = apply_param_substs(ccx.tcx(), psubsts, &item_ty);\n+    debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n \n     match ccx.monomorphized().borrow().get(&hash_id) {\n         Some(&val) => {\n@@ -96,11 +97,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n-\n-    let mono_ty = normalize_associated_type(ccx.tcx(), &mono_ty);\n-    debug!(\"mono_ty = {:?} (post-normalization)\", mono_ty);\n-\n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n     let depth;"}, {"sha": "8db5b5e7c508c171659f73f744a8a6818e98788e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 25, "deletions": 49, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -15,8 +15,6 @@ use check::UnresolvedTypeAction;\n use middle::subst::{self};\n use middle::traits;\n use middle::ty::{self, Ty};\n-use middle::ty::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n-                 MethodParam, MethodStatic, MethodTraitObject, MethodTypeParam};\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -52,7 +50,7 @@ pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          unadjusted_self_ty: Ty<'tcx>,\n                          pick: probe::Pick<'tcx>,\n                          supplied_method_types: Vec<Ty<'tcx>>)\n-                         -> MethodCallee<'tcx>\n+                         -> ty::MethodCallee<'tcx>\n {\n     debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n            unadjusted_self_ty,\n@@ -77,7 +75,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n                supplied_method_types: Vec<Ty<'tcx>>)\n-               -> MethodCallee<'tcx>\n+               -> ty::MethodCallee<'tcx>\n     {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n@@ -86,8 +84,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.enforce_illegal_method_limitations(&pick);\n \n         // Create substitutions for the method's type parameters.\n-        let (rcvr_substs, method_origin) =\n-            self.fresh_receiver_substs(self_ty, &pick);\n+        let rcvr_substs = self.fresh_receiver_substs(self_ty, &pick);\n         let (method_types, method_regions) =\n             self.instantiate_method_substs(&pick, supplied_method_types);\n         let all_substs = rcvr_substs.with_method(method_types, method_regions);\n@@ -112,10 +109,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),\n         }));\n-        let callee = MethodCallee {\n-            origin: method_origin,\n+        let callee = ty::MethodCallee {\n+            def_id: pick.item.def_id(),\n             ty: fty,\n-            substs: all_substs\n+            substs: self.tcx().mk_substs(all_substs)\n         };\n \n         // If this is an `&mut self` method, bias the receiver\n@@ -194,18 +191,18 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn fresh_receiver_substs(&mut self,\n                              self_ty: Ty<'tcx>,\n                              pick: &probe::Pick<'tcx>)\n-                             -> (subst::Substs<'tcx>, MethodOrigin<'tcx>)\n+                             -> subst::Substs<'tcx>\n     {\n         match pick.kind {\n-            probe::InherentImplPick(impl_def_id) => {\n+            probe::InherentImplPick => {\n+                let impl_def_id = pick.item.container().id();\n                 assert!(self.tcx().impl_trait_ref(impl_def_id).is_none(),\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n-                let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n-\n-                (impl_polytype.substs, MethodStatic(pick.item.def_id()))\n+                check::impl_self_ty(self.fcx, self.span, impl_def_id).substs\n             }\n \n-            probe::ObjectPick(trait_def_id, method_num, vtable_index) => {\n+            probe::ObjectPick => {\n+                let trait_def_id = pick.item.container().id();\n                 self.extract_trait_ref(self_ty, |this, object_ty, data| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n@@ -227,18 +224,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                            original_poly_trait_ref,\n                            upcast_trait_ref,\n                            trait_def_id);\n-                    let substs = upcast_trait_ref.substs.clone();\n-                    let origin = MethodTraitObject(MethodObject {\n-                        trait_ref: upcast_trait_ref,\n-                        object_trait_id: trait_def_id,\n-                        method_num: method_num,\n-                        vtable_index: vtable_index,\n-                    });\n-                    (substs, origin)\n+                    upcast_trait_ref.substs.clone()\n                 })\n             }\n \n-            probe::ExtensionImplPick(impl_def_id, method_num) => {\n+            probe::ExtensionImplPick(impl_def_id) => {\n                 // The method being invoked is the method as defined on the trait,\n                 // so return the substitutions from the trait. Consider:\n                 //\n@@ -254,41 +244,27 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         self.span,\n                         &impl_polytype.substs,\n                         &self.tcx().impl_trait_ref(impl_def_id).unwrap());\n-                let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n-                                                           method_num: method_num,\n-                                                           impl_def_id: Some(impl_def_id) });\n-                (impl_trait_ref.substs.clone(), origin)\n+                impl_trait_ref.substs.clone()\n             }\n \n-            probe::TraitPick(trait_def_id, method_num) => {\n+            probe::TraitPick => {\n+                let trait_def_id = pick.item.container().id();\n                 let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n                 // consisting entirely of type variables. Later on in\n                 // the process we will unify the transformed-self-type\n                 // of the method with the actual type in order to\n                 // unify some of these variables.\n-                let substs = self.infcx().fresh_substs_for_trait(self.span,\n-                                                                 &trait_def.generics,\n-                                                                 self.infcx().next_ty_var());\n-\n-                let trait_ref =\n-                    ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone()));\n-                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n-                                                           method_num: method_num,\n-                                                           impl_def_id: None });\n-                (substs, origin)\n+                self.infcx().fresh_substs_for_trait(self.span,\n+                                                    &trait_def.generics,\n+                                                    self.infcx().next_ty_var())\n             }\n \n-            probe::WhereClausePick(ref poly_trait_ref, method_num) => {\n+            probe::WhereClausePick(ref poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                let trait_ref = self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref);\n-                let substs = trait_ref.substs.clone();\n-                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n-                                                           method_num: method_num,\n-                                                           impl_def_id: None });\n-                (substs, origin)\n+                self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref).substs.clone()\n             }\n         }\n     }\n@@ -450,7 +426,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n     /// respectively.\n     fn fixup_derefs_on_method_receiver_if_necessary(&self,\n-                                                    method_callee: &MethodCallee) {\n+                                                    method_callee: &ty::MethodCallee) {\n         let sig = match method_callee.ty.sty {\n             ty::TyBareFn(_, ref f) => f.sig.clone(),\n             _ => return,\n@@ -570,7 +546,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n                         let result = check::try_index_step(\n                             self.fcx,\n-                            MethodCall::expr(expr.id),\n+                            ty::MethodCall::expr(expr.id),\n                             expr,\n                             &**base_expr,\n                             adjusted_base_ty,\n@@ -589,7 +565,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n                         // if this is an overloaded deref, then re-evaluate with\n                         // a preference for mut\n-                        let method_call = MethodCall::expr(expr.id);\n+                        let method_call = ty::MethodCall::expr(expr.id);\n                         if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n                             check::try_overloaded_deref(\n                                 self.fcx,"}, {"sha": "2117cba108730797d483d770c59025bc421dc651", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -74,8 +74,6 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ ast::DefId),\n }\n \n-type ItemIndex = usize; // just for doc purposes\n-\n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         span: Span,\n@@ -204,14 +202,13 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Trait must have a method named `m_name` and it should not have\n     // type parameters or early-bound regions.\n     let tcx = fcx.tcx();\n-    let (method_num, method_ty) = trait_item(tcx, trait_def_id, m_name)\n-            .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n-            .unwrap();\n+    let method_item = trait_item(tcx, trait_def_id, m_name).unwrap();\n+    let method_ty = method_item.as_opt_method().unwrap();\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n-    debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={:?}\",\n-           method_num, method_ty);\n+    debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n+           method_item, method_ty);\n \n     // Instantiate late-bound regions and substitute the trait\n     // parameters into the method type to get the actual method type.\n@@ -309,11 +306,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     let callee = ty::MethodCallee {\n-        origin: ty::MethodTypeParam(ty::MethodParam{trait_ref: trait_ref.clone(),\n-                                                    method_num: method_num,\n-                                                    impl_def_id: None}),\n+        def_id: method_item.def_id(),\n         ty: fty,\n-        substs: trait_ref.substs.clone()\n+        substs: trait_ref.substs\n     };\n \n     debug!(\"callee = {:?}\", callee);\n@@ -332,14 +327,15 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n     let def_id = pick.item.def_id();\n     let mut lp = LastMod(AllPublic);\n+    let container_def_id = pick.item.container().id();\n     let provenance = match pick.kind {\n-        probe::InherentImplPick(impl_def_id) => {\n+        probe::InherentImplPick => {\n             if pick.item.vis() != ast::Public {\n                 lp = LastMod(DependsOn(def_id));\n             }\n-            def::FromImpl(impl_def_id)\n+            def::FromImpl(container_def_id)\n         }\n-        _ => def::FromTrait(pick.item.container().id())\n+        _ => def::FromTrait(container_def_id)\n     };\n     let def_result = match pick.item {\n         ty::ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n@@ -352,19 +348,17 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n \n-/// Find item with name `item_name` defined in `trait_def_id` and return it, along with its\n-/// index (or `None`, if no such item).\n+/// Find item with name `item_name` defined in `trait_def_id`\n+/// and return it, or `None`, if no such item.\n fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     trait_def_id: ast::DefId,\n                     item_name: ast::Name)\n-                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n+                    -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let trait_items = tcx.trait_items(trait_def_id);\n-    trait_items\n-        .iter()\n-        .enumerate()\n-        .find(|&(_, ref item)| item.name() == item_name)\n-        .map(|(num, item)| (num, (*item).clone()))\n+    trait_items.iter()\n+               .find(|item| item.name() == item_name)\n+               .cloned()\n }\n \n fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "c43046ba0e71641d61252788fff7e8a48de0a953", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 103, "deletions": 165, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -10,7 +10,6 @@\n \n use super::MethodError;\n use super::NoMatchData;\n-use super::ItemIndex;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n@@ -70,15 +69,13 @@ struct Candidate<'tcx> {\n \n #[derive(Debug)]\n enum CandidateKind<'tcx> {\n-    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>,\n+    InherentImplCandidate(subst::Substs<'tcx>,\n                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n-    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, ty::TraitRef<'tcx>,\n-                           subst::Substs<'tcx>, ItemIndex,\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>,\n                            /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n-    ClosureCandidate(/* Trait */ ast::DefId, ItemIndex),\n-    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, ItemIndex),\n-    ProjectionCandidate(ast::DefId, ItemIndex),\n+    ObjectCandidate,\n+    TraitCandidate,\n+    WhereClauseCandidate(/* Trait */ ty::PolyTraitRef<'tcx>),\n }\n \n #[derive(Debug)]\n@@ -106,11 +103,11 @@ pub struct Pick<'tcx> {\n \n #[derive(Clone,Debug)]\n pub enum PickKind<'tcx> {\n-    InherentImplPick(/* Impl */ ast::DefId),\n-    ObjectPick(/* Trait */ ast::DefId, /* method_num */ usize, /* real_index */ usize),\n-    ExtensionImplPick(/* Impl */ ast::DefId, ItemIndex),\n-    TraitPick(/* Trait */ ast::DefId, ItemIndex),\n-    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, ItemIndex),\n+    InherentImplPick,\n+    ExtensionImplPick(/* Impl */ ast::DefId),\n+    ObjectPick,\n+    TraitPick,\n+    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError<'tcx>>;\n@@ -430,7 +427,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n             item: item,\n-            kind: InherentImplCandidate(impl_def_id, impl_substs, obligations)\n+            kind: InherentImplCandidate(impl_substs, obligations)\n         });\n     }\n \n@@ -440,8 +437,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n                self_ty);\n \n-        let tcx = self.tcx();\n-\n         // It is illegal to invoke a method on a trait instance that\n         // refers to the `Self` type. An error will be reported by\n         // `enforce_object_limitations()` if the method refers to the\n@@ -450,23 +445,17 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n-        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, item, item_num| {\n+        self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n-            let vtable_index =\n-                traits::get_vtable_index_of_object_method(tcx,\n-                                                          trait_ref.clone(),\n-                                                          new_trait_ref.def_id,\n-                                                          item_num);\n-\n             let xform_self_ty = this.xform_self_ty(&item,\n                                                    new_trait_ref.self_ty(),\n                                                    new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n-                kind: ObjectCandidate(new_trait_ref.def_id, item_num, vtable_index)\n+                kind: ObjectCandidate\n             });\n         });\n     }\n@@ -499,7 +488,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(&bounds, |this, poly_trait_ref, item, item_num| {\n+        self.elaborate_bounds(&bounds, |this, poly_trait_ref, item| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n@@ -533,7 +522,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n-                kind: WhereClauseCandidate(poly_trait_ref, item_num)\n+                kind: WhereClauseCandidate(poly_trait_ref)\n             });\n         });\n     }\n@@ -549,24 +538,23 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             &mut ProbeContext<'b, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n             ty::ImplOrTraitItem<'tcx>,\n-            usize,\n         ),\n     {\n         debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let (pos, item) = match trait_item(tcx,\n-                                               bound_trait_ref.def_id(),\n-                                               self.item_name) {\n+            let item = match trait_item(tcx,\n+                                        bound_trait_ref.def_id(),\n+                                        self.item_name) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n \n             if !self.has_applicable_self(&item) {\n                 self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n             } else {\n-                mk_cand(self, bound_trait_ref, item, pos);\n+                mk_cand(self, bound_trait_ref, item);\n             }\n         }\n     }\n@@ -607,14 +595,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // Check whether `trait_def_id` defines a method with suitable name:\n         let trait_items =\n             self.tcx().trait_items(trait_def_id);\n-        let matching_index =\n+        let maybe_item =\n             trait_items.iter()\n-                       .position(|item| item.name() == self.item_name);\n-        let matching_index = match matching_index {\n+                       .find(|item| item.name() == self.item_name);\n+        let item = match maybe_item {\n             Some(i) => i,\n             None => { return Ok(()); }\n         };\n-        let ref item = (&*trait_items)[matching_index];\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         if !self.has_applicable_self(item) {\n@@ -623,29 +610,20 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return Ok(());\n         }\n \n-        self.assemble_extension_candidates_for_trait_impls(trait_def_id,\n-                                                           item.clone(),\n-                                                           matching_index);\n+        self.assemble_extension_candidates_for_trait_impls(trait_def_id, item.clone());\n \n-        try!(self.assemble_closure_candidates(trait_def_id,\n-                                              item.clone(),\n-                                              matching_index));\n+        try!(self.assemble_closure_candidates(trait_def_id, item.clone()));\n \n-        self.assemble_projection_candidates(trait_def_id,\n-                                            item.clone(),\n-                                            matching_index);\n+        self.assemble_projection_candidates(trait_def_id, item.clone());\n \n-        self.assemble_where_clause_candidates(trait_def_id,\n-                                              item.clone(),\n-                                              matching_index);\n+        self.assemble_where_clause_candidates(trait_def_id, item.clone());\n \n         Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n-                                                     item: ty::ImplOrTraitItem<'tcx>,\n-                                                     item_index: usize)\n+                                                     item: ty::ImplOrTraitItem<'tcx>)\n     {\n         let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n@@ -690,11 +668,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id,\n-                                             impl_trait_ref,\n-                                             impl_substs,\n-                                             item_index,\n-                                             obligations)\n+                kind: ExtensionImplCandidate(impl_def_id, impl_substs, obligations)\n             });\n         });\n     }\n@@ -717,8 +691,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: ast::DefId,\n-                                   item: ty::ImplOrTraitItem<'tcx>,\n-                                   item_index: usize)\n+                                   item: ty::ImplOrTraitItem<'tcx>)\n                                    -> Result<(), MethodError<'tcx>>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -770,7 +743,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: ClosureCandidate(trait_def_id, item_index)\n+                kind: TraitCandidate\n             });\n         }\n \n@@ -779,16 +752,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: ast::DefId,\n-                                      item: ty::ImplOrTraitItem<'tcx>,\n-                                      item_index: usize)\n+                                      item: ty::ImplOrTraitItem<'tcx>)\n     {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={:?}, \\\n-               item={:?}, \\\n-               item_index={})\",\n+               item={:?})\",\n                trait_def_id,\n-               item,\n-               item_index);\n+               item);\n \n         for step in self.steps.iter() {\n             debug!(\"assemble_projection_candidates: step={:?}\",\n@@ -830,7 +800,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n                         item: item.clone(),\n-                        kind: ProjectionCandidate(trait_def_id, item_index)\n+                        kind: TraitCandidate\n                     });\n                 }\n             }\n@@ -839,8 +809,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n-                                        item: ty::ImplOrTraitItem<'tcx>,\n-                                        item_index: usize)\n+                                        item: ty::ImplOrTraitItem<'tcx>)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n@@ -862,7 +831,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: WhereClauseCandidate(poly_bound, item_index)\n+                kind: WhereClauseCandidate(poly_bound)\n             });\n         }\n     }\n@@ -1048,8 +1017,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         applicable_candidates.pop().map(|probe| {\n-            let pick = probe.to_unadjusted_pick();\n-            Ok(pick)\n+            Ok(probe.to_unadjusted_pick())\n         })\n     }\n \n@@ -1073,48 +1041,52 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // clauses) that must be considered. Make sure that those\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n-            match probe.kind {\n-                InherentImplCandidate(impl_def_id, ref substs, ref ref_obligations) |\n-                ExtensionImplCandidate(impl_def_id, _, ref substs, _, ref ref_obligations) => {\n-                    let selcx = &mut traits::SelectionContext::new(self.infcx());\n-                    let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-\n-                    // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_bounds = self.tcx().lookup_predicates(impl_def_id);\n-                    let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n-                    let traits::Normalized { value: impl_bounds,\n-                                             obligations: norm_obligations } =\n-                        traits::normalize(selcx, cause.clone(), &impl_bounds);\n-\n-                    // Convert the bounds into obligations.\n-                    let obligations =\n-                        traits::predicates_for_generics(cause.clone(),\n-                                                        &impl_bounds);\n-                    debug!(\"impl_obligations={:?}\", obligations);\n-\n-                    // Evaluate those obligations to see if they might possibly hold.\n-                    let mut all_true = true;\n-                    for o in obligations.iter()\n-                        .chain(norm_obligations.iter())\n-                        .chain(ref_obligations.iter()) {\n-                        if !selcx.evaluate_obligation(o) {\n-                            all_true = false;\n-                            if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n-                                possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n-                            }\n-                        }\n-                    }\n-                    all_true\n+            let (impl_def_id, substs, ref_obligations) = match probe.kind {\n+                InherentImplCandidate(ref substs, ref ref_obligations) => {\n+                    (probe.item.container().id(), substs, ref_obligations)\n+                }\n+\n+                ExtensionImplCandidate(impl_def_id, ref substs, ref ref_obligations) => {\n+                    (impl_def_id, substs, ref_obligations)\n                 }\n \n-                ProjectionCandidate(..) |\n                 ObjectCandidate(..) |\n-                ClosureCandidate(..) |\n+                TraitCandidate |\n                 WhereClauseCandidate(..) => {\n                     // These have no additional conditions to check.\n-                    true\n+                    return true;\n+                }\n+            };\n+\n+            let selcx = &mut traits::SelectionContext::new(self.infcx());\n+            let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+\n+            // Check whether the impl imposes obligations we have to worry about.\n+            let impl_bounds = self.tcx().lookup_predicates(impl_def_id);\n+            let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n+            let traits::Normalized { value: impl_bounds,\n+                                        obligations: norm_obligations } =\n+                traits::normalize(selcx, cause.clone(), &impl_bounds);\n+\n+            // Convert the bounds into obligations.\n+            let obligations =\n+                traits::predicates_for_generics(cause.clone(),\n+                                                &impl_bounds);\n+            debug!(\"impl_obligations={:?}\", obligations);\n+\n+            // Evaluate those obligations to see if they might possibly hold.\n+            let mut all_true = true;\n+            for o in obligations.iter()\n+                .chain(norm_obligations.iter())\n+                .chain(ref_obligations.iter()) {\n+                if !selcx.evaluate_obligation(o) {\n+                    all_true = false;\n+                    if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n+                        possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n+                    }\n                 }\n             }\n+            all_true\n         })\n     }\n \n@@ -1139,20 +1111,19 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                          probes: &[&Candidate<'tcx>])\n                                          -> Option<Pick<'tcx>> {\n         // Do all probes correspond to the same trait?\n-        let trait_data = match probes[0].to_trait_data() {\n-            Some(data) => data,\n-            None => return None,\n-        };\n-        if probes[1..].iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n+        let container = probes[0].item.container();\n+        match container {\n+            ty::TraitContainer(_) => {}\n+            ty::ImplContainer(_) => return None\n+        }\n+        if probes[1..].iter().any(|p| p.item.container() != container) {\n             return None;\n         }\n \n         // If so, just use this trait and call it a day.\n-        let (trait_def_id, item_num) = trait_data;\n-        let item = probes[0].item.clone();\n         Some(Pick {\n-            item: item,\n-            kind: TraitPick(trait_def_id, item_num),\n+            item: probes[0].item.clone(),\n+            kind: TraitPick,\n             autoderefs: 0,\n             autoref: None,\n             unsize: None\n@@ -1317,51 +1288,40 @@ fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .find(|item| item.name() == item_name)\n }\n \n-/// Find item with name `item_name` defined in `trait_def_id` and return it,\n-/// along with its index (or `None`, if no such item).\n+/// Find item with name `item_name` defined in `trait_def_id`\n+/// and return it, or `None`, if no such item.\n fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     trait_def_id: ast::DefId,\n                     item_name: ast::Name)\n-                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n+                    -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let trait_items = tcx.trait_items(trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n-    trait_items\n-        .iter()\n-        .enumerate()\n-        .find(|&(_, ref item)| item.name() == item_name)\n-        .map(|(num, ref item)| (num, (*item).clone()))\n+    trait_items.iter()\n+               .find(|item| item.name() == item_name)\n+               .cloned()\n }\n \n impl<'tcx> Candidate<'tcx> {\n     fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {\n             item: self.item.clone(),\n             kind: match self.kind {\n-                InherentImplCandidate(def_id, _, _) => {\n-                    InherentImplPick(def_id)\n-                }\n-                ObjectCandidate(def_id, item_num, real_index) => {\n-                    ObjectPick(def_id, item_num, real_index)\n-                }\n-                ExtensionImplCandidate(def_id, _, _, index, _) => {\n-                    ExtensionImplPick(def_id, index)\n+                InherentImplCandidate(_, _) => InherentImplPick,\n+                ExtensionImplCandidate(def_id, _, _) => {\n+                    ExtensionImplPick(def_id)\n                 }\n-                ClosureCandidate(trait_def_id, index) => {\n-                    TraitPick(trait_def_id, index)\n-                }\n-                WhereClauseCandidate(ref trait_ref, index) => {\n+                ObjectCandidate => ObjectPick,\n+                TraitCandidate => TraitPick,\n+                WhereClauseCandidate(ref trait_ref) => {\n                     // Only trait derived from where-clauses should\n                     // appear here, so they should not contain any\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n                     assert!(!trait_ref.substs().types.needs_infer());\n \n-                    WhereClausePick((*trait_ref).clone(), index)\n-                }\n-                ProjectionCandidate(def_id, index) => {\n-                    TraitPick(def_id, index)\n+                    WhereClausePick(trait_ref.clone())\n                 }\n             },\n             autoderefs: 0,\n@@ -1372,35 +1332,13 @@ impl<'tcx> Candidate<'tcx> {\n \n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n-            InherentImplCandidate(def_id, _, _) => ImplSource(def_id),\n-            ObjectCandidate(def_id, _, _) => TraitSource(def_id),\n-            ExtensionImplCandidate(def_id, _, _, _, _) => ImplSource(def_id),\n-            ClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n-            WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n-            ProjectionCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n-        }\n-    }\n-\n-    fn to_trait_data(&self) -> Option<(ast::DefId, ItemIndex)> {\n-        match self.kind {\n-            InherentImplCandidate(..) => {\n-                None\n-            }\n-            ObjectCandidate(trait_def_id, item_num, _) => {\n-                Some((trait_def_id, item_num))\n-            }\n-            ClosureCandidate(trait_def_id, item_num) => {\n-                Some((trait_def_id, item_num))\n-            }\n-            ExtensionImplCandidate(_, ref trait_ref, _, item_num, _) => {\n-                Some((trait_ref.def_id, item_num))\n-            }\n-            WhereClauseCandidate(ref trait_ref, item_num) => {\n-                Some((trait_ref.def_id(), item_num))\n-            }\n-            ProjectionCandidate(trait_def_id, item_num) => {\n-                Some((trait_def_id, item_num))\n+            InherentImplCandidate(_, _) => {\n+                ImplSource(self.item.container().id())\n             }\n+            ExtensionImplCandidate(def_id, _, _) => ImplSource(def_id),\n+            ObjectCandidate |\n+            TraitCandidate |\n+            WhereClauseCandidate(_) => TraitSource(self.item.container().id()),\n         }\n     }\n }"}, {"sha": "4d86a4f7c70ff159fe7425cbb23d5bcd0d4e971c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -203,7 +203,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                impl_ty);\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n-                    let (_, item) = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n+                    let item = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n                     let item_span = fcx.tcx().map.def_id_span(item.def_id(), span);\n                     span_note!(fcx.sess(), item_span,\n                                \"candidate #{} is defined in the trait `{}`\","}, {"sha": "419fa9e160a47d34a2ef150d7fc9f4c2ff8d5195", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -302,9 +302,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                        method_call,\n                        method);\n                 let new_method = MethodCallee {\n-                    origin: self.resolve(&method.origin, reason),\n+                    def_id: method.def_id,\n                     ty: self.resolve(&method.ty, reason),\n-                    substs: self.resolve(&method.substs, reason),\n+                    substs: self.tcx().mk_substs(self.resolve(method.substs, reason)),\n                 };\n \n                 Some(new_method)"}, {"sha": "f2cf1779d6241bd43ce98acdde2b85e7998b11cb", "filename": "src/test/run-pass/traits-issue-26339.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Ftest%2Frun-pass%2Ftraits-issue-26339.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e545ffa73836525d10e1c658b622ddb12b7f93/src%2Ftest%2Frun-pass%2Ftraits-issue-26339.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-issue-26339.rs?ref=42e545ffa73836525d10e1c658b622ddb12b7f93", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the right implementation is called through a trait\n+// object when supertraits include multiple references to the\n+// same trait, with different type parameters.\n+\n+trait A: PartialEq<Foo> + PartialEq<Bar> { }\n+\n+struct Foo;\n+struct Bar;\n+\n+struct Aimpl;\n+\n+impl PartialEq<Foo> for Aimpl {\n+    fn eq(&self, _rhs: &Foo) -> bool {\n+        true\n+    }\n+}\n+\n+impl PartialEq<Bar> for Aimpl {\n+    fn eq(&self, _rhs: &Bar) -> bool {\n+        false\n+    }\n+}\n+\n+impl A for Aimpl { }\n+\n+fn main() {\n+    let a = &Aimpl as &A;\n+\n+    assert!(*a == Foo);\n+}"}]}