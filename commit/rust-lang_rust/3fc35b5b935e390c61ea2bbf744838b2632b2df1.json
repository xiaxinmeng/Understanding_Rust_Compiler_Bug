{"sha": "3fc35b5b935e390c61ea2bbf744838b2632b2df1", "node_id": "C_kwDOAAsO6NoAKDNmYzM1YjViOTM1ZTM5MGM2MWVhMmJiZjc0NDgzOGIyNjMyYjJkZjE", "commit": {"author": {"name": "BlackHoleFox", "email": "blackholefoxdev@gmail.com", "date": "2022-08-25T20:43:59Z"}, "committer": {"name": "BlackHoleFox", "email": "blackholefoxdev@gmail.com", "date": "2022-08-25T20:55:04Z"}, "message": "Use getentropy when possible on all Apple platforms", "tree": {"sha": "c29bbda872079c8cb5c65085fa2bc9eab99df5cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c29bbda872079c8cb5c65085fa2bc9eab99df5cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fc35b5b935e390c61ea2bbf744838b2632b2df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fc35b5b935e390c61ea2bbf744838b2632b2df1", "html_url": "https://github.com/rust-lang/rust/commit/3fc35b5b935e390c61ea2bbf744838b2632b2df1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fc35b5b935e390c61ea2bbf744838b2632b2df1/comments", "author": {"login": "BlackHoleFox", "id": 20936452, "node_id": "MDQ6VXNlcjIwOTM2NDUy", "avatar_url": "https://avatars.githubusercontent.com/u/20936452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BlackHoleFox", "html_url": "https://github.com/BlackHoleFox", "followers_url": "https://api.github.com/users/BlackHoleFox/followers", "following_url": "https://api.github.com/users/BlackHoleFox/following{/other_user}", "gists_url": "https://api.github.com/users/BlackHoleFox/gists{/gist_id}", "starred_url": "https://api.github.com/users/BlackHoleFox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BlackHoleFox/subscriptions", "organizations_url": "https://api.github.com/users/BlackHoleFox/orgs", "repos_url": "https://api.github.com/users/BlackHoleFox/repos", "events_url": "https://api.github.com/users/BlackHoleFox/events{/privacy}", "received_events_url": "https://api.github.com/users/BlackHoleFox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BlackHoleFox", "id": 20936452, "node_id": "MDQ6VXNlcjIwOTM2NDUy", "avatar_url": "https://avatars.githubusercontent.com/u/20936452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BlackHoleFox", "html_url": "https://github.com/BlackHoleFox", "followers_url": "https://api.github.com/users/BlackHoleFox/followers", "following_url": "https://api.github.com/users/BlackHoleFox/following{/other_user}", "gists_url": "https://api.github.com/users/BlackHoleFox/gists{/gist_id}", "starred_url": "https://api.github.com/users/BlackHoleFox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BlackHoleFox/subscriptions", "organizations_url": "https://api.github.com/users/BlackHoleFox/orgs", "repos_url": "https://api.github.com/users/BlackHoleFox/repos", "events_url": "https://api.github.com/users/BlackHoleFox/events{/privacy}", "received_events_url": "https://api.github.com/users/BlackHoleFox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c943bad02626dddc5e5135b23c77429b6e4a063", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c943bad02626dddc5e5135b23c77429b6e4a063", "html_url": "https://github.com/rust-lang/rust/commit/6c943bad02626dddc5e5135b23c77429b6e4a063"}], "stats": {"total": 94, "additions": 56, "deletions": 38}, "files": [{"sha": "40885417308b80a2007591f17af0984a44215831", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 56, "deletions": 38, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3fc35b5b935e390c61ea2bbf744838b2632b2df1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc35b5b935e390c61ea2bbf744838b2632b2df1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=3fc35b5b935e390c61ea2bbf744838b2632b2df1", "patch": "@@ -137,11 +137,9 @@ mod imp {\n     }\n }\n \n-#[cfg(target_os = \"macos\")]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n mod imp {\n-    use crate::fs::File;\n-    use crate::io::Read;\n-    use crate::sys::os::errno;\n+    use crate::io;\n     use crate::sys::weak::weak;\n     use libc::{c_int, c_void, size_t};\n \n@@ -155,22 +153,72 @@ mod imp {\n                 for s in v.chunks_mut(256) {\n                     let ret = unsafe { f(s.as_mut_ptr() as *mut c_void, s.len()) };\n                     if ret == -1 {\n-                        panic!(\"unexpected getentropy error: {}\", errno());\n+                        panic!(\"unexpected getentropy error: {}\", io::Error::last_os_error());\n                     }\n                 }\n                 true\n             })\n             .unwrap_or(false)\n     }\n \n+    #[cfg(target_os = \"macos\")]\n+    fn fallback_fill_bytes(v: &mut [u8]) {\n+        use crate::fs::File;\n+        use crate::io::Read;\n+\n+        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n+        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n+    }\n+\n+    // On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n+    // `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n+    // from `/dev/random` and which runs on its own thread accessed via GCD.\n+    //\n+    // This is very heavyweight compared to the alternatives, but they may not be usable:\n+    // - `getentropy` was added in iOS 10, but we support a minimum of iOS 7\n+    // - `/dev/urandom` is not accessible inside the iOS app sandbox.\n+    //\n+    // Therefore `SecRandomCopyBytes` is only used on older iOS versions where no\n+    // better options are present.\n+    #[cfg(target_os = \"ios\")]\n+    fn fallback_fill_bytes(v: &mut [u8]) {\n+        use crate::ptr;\n+\n+        enum SecRandom {}\n+\n+        #[allow(non_upper_case_globals)]\n+        const kSecRandomDefault: *const SecRandom = ptr::null();\n+\n+        extern \"C\" {\n+            fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n+        }\n+\n+        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n+        if ret == -1 {\n+            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n+        }\n+    }\n+\n+    // All supported versions of watchOS (>= 5) have support for `getentropy`.\n+    #[cfg(target_os = \"watchos\")]\n+    #[cold]\n+    fn fallback_fill_bytes(_: &mut [u8]) {\n+        unreachable!()\n+    }\n+\n     pub fn fill_bytes(v: &mut [u8]) {\n         if getentropy_fill_bytes(v) {\n             return;\n         }\n \n-        // for older macos which doesn't support getentropy\n-        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n-        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n+        // Older macOS versions (< 10.12) don't support `getentropy`. Fallback to\n+        // reading from `/dev/urandom` on these systems.\n+        //\n+        // Older iOS versions (< 10) don't support it either. Fallback to\n+        // `SecRandomCopyBytes` on these systems. On watchOS, this is unreachable\n+        // because the minimum supported version is 5 while `getentropy` became accessible\n+        // in 3.\n+        fallback_fill_bytes(v)\n     }\n }\n \n@@ -189,36 +237,6 @@ mod imp {\n     }\n }\n \n-// On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n-// `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n-// from `/dev/random` and which runs on its own thread accessed via GCD.\n-// This seems needlessly heavyweight for the purposes of generating two u64s\n-// once per thread in `hashmap_random_keys`. Therefore `SecRandomCopyBytes` is\n-// only used on iOS where direct access to `/dev/urandom` is blocked by the\n-// sandbox.\n-#[cfg(any(target_os = \"ios\", target_os = \"watchos\"))]\n-mod imp {\n-    use crate::io;\n-    use crate::ptr;\n-    use libc::{c_int, size_t};\n-\n-    enum SecRandom {}\n-\n-    #[allow(non_upper_case_globals)]\n-    const kSecRandomDefault: *const SecRandom = ptr::null();\n-\n-    extern \"C\" {\n-        fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n-    }\n-\n-    pub fn fill_bytes(v: &mut [u8]) {\n-        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n-        if ret == -1 {\n-            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n-        }\n-    }\n-}\n-\n #[cfg(any(target_os = \"freebsd\", target_os = \"netbsd\"))]\n mod imp {\n     use crate::ptr;"}]}