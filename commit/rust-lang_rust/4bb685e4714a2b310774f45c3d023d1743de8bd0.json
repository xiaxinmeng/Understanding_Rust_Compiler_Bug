{"sha": "4bb685e4714a2b310774f45c3d023d1743de8bd0", "node_id": "C_kwDOAAsO6NoAKDRiYjY4NWU0NzE0YTJiMzEwNzc0ZjQ1YzNkMDIzZDE3NDNkZThiZDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-09T04:53:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-09T04:53:34Z"}, "message": "Auto merge of #95835 - Dylan-DPC:rollup-l5mf2ad, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #90066 (Add new ThinBox type for 1 stack pointer wide heap allocated trait objects)\n - #95374 (assert_uninit_valid: ensure we detect at least arrays of uninhabited types)\n - #95599 (Strict provenance lints)\n - #95751 (Don't report numeric inference ambiguity when we have previous errors)\n - #95764 ([macro_metavar_expr] Add tests to ensure the feature requirement)\n - #95787 (reword panic vs result section to remove recoverable vs unrecoverable framing)\n - #95797 (Remove explicit delimiter token trees from `Delimited`.)\n - #95804 (rustdoc: Fix empty doc comment with backline ICE)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8e669c3a8433808f5c161e1bb9cea4ac29e7b994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e669c3a8433808f5c161e1bb9cea4ac29e7b994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bb685e4714a2b310774f45c3d023d1743de8bd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb685e4714a2b310774f45c3d023d1743de8bd0", "html_url": "https://github.com/rust-lang/rust/commit/4bb685e4714a2b310774f45c3d023d1743de8bd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bb685e4714a2b310774f45c3d023d1743de8bd0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e980c6295582792e4a7c2d67e33cece60c170115", "url": "https://api.github.com/repos/rust-lang/rust/commits/e980c6295582792e4a7c2d67e33cece60c170115", "html_url": "https://github.com/rust-lang/rust/commit/e980c6295582792e4a7c2d67e33cece60c170115"}, {"sha": "8f4680e37caefc856fe3bb31d18c69f1e2b8cc16", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f4680e37caefc856fe3bb31d18c69f1e2b8cc16", "html_url": "https://github.com/rust-lang/rust/commit/8f4680e37caefc856fe3bb31d18c69f1e2b8cc16"}], "stats": {"total": 1180, "additions": 1029, "deletions": 151}, "files": [{"sha": "8730aeb0f3bffdf182cef918a75c06a4a44bd391", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -52,7 +52,10 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         // when we try to compute the \"horizontal trim\".\n         let lines = if kind == CommentKind::Block {\n             // Whatever happens, we skip the first line.\n-            let mut i = if lines[0].trim_start().starts_with('*') { 0 } else { 1 };\n+            let mut i = lines\n+                .get(0)\n+                .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n+                .unwrap_or(0);\n             let mut j = lines.len();\n \n             while i < j && lines[i].trim().is_empty() {"}, {"sha": "c1f1b4e505c3685c56333c625844900be2ab0dcb", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -17,48 +17,24 @@ use rustc_data_structures::sync::Lrc;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-/// Contains the sub-token-trees of a \"delimited\" token tree such as `(a b c)`. The delimiter itself\n-/// might be `NoDelim`.\n+/// Contains the sub-token-trees of a \"delimited\" token tree such as `(a b c)`. The delimiters\n+/// might be `NoDelim`, but they are not represented explicitly.\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n struct Delimited {\n     delim: token::DelimToken,\n-    /// Note: This contains the opening and closing delimiters tokens (e.g. `(` and `)`). Note that\n-    /// these could be `NoDelim`. These token kinds must match `delim`, and the methods below\n-    /// debug_assert this.\n-    all_tts: Vec<TokenTree>,\n+    /// FIXME: #67062 has details about why this is sub-optimal.\n+    tts: Vec<TokenTree>,\n }\n \n impl Delimited {\n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter. Panics if\n-    /// the delimiter is `NoDelim`.\n-    fn open_tt(&self) -> &TokenTree {\n-        let tt = self.all_tts.first().unwrap();\n-        debug_assert!(matches!(\n-            tt,\n-            &TokenTree::Token(token::Token { kind: token::OpenDelim(d), .. }) if d == self.delim\n-        ));\n-        tt\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n+    fn open_tt(&self, span: DelimSpan) -> TokenTree {\n+        TokenTree::token(token::OpenDelim(self.delim), span.open)\n     }\n \n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter. Panics if\n-    /// the delimiter is `NoDelim`.\n-    fn close_tt(&self) -> &TokenTree {\n-        let tt = self.all_tts.last().unwrap();\n-        debug_assert!(matches!(\n-            tt,\n-            &TokenTree::Token(token::Token { kind: token::CloseDelim(d), .. }) if d == self.delim\n-        ));\n-        tt\n-    }\n-\n-    /// Returns the tts excluding the outer delimiters.\n-    ///\n-    /// FIXME: #67062 has details about why this is sub-optimal.\n-    fn inner_tts(&self) -> &[TokenTree] {\n-        // These functions are called for the assertions within them.\n-        let _open_tt = self.open_tt();\n-        let _close_tt = self.close_tt();\n-        &self.all_tts[1..self.all_tts.len() - 1]\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n+    fn close_tt(&self, span: DelimSpan) -> TokenTree {\n+        TokenTree::token(token::CloseDelim(self.delim), span.close)\n     }\n }\n "}, {"sha": "fbacebf99c050032d01d6b65137f5399d147ee81", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -282,7 +282,7 @@ fn check_binders(\n         // `MetaVarExpr` can not appear in the LHS of a macro arm\n         TokenTree::MetaVarExpr(..) => {}\n         TokenTree::Delimited(_, ref del) => {\n-            for tt in del.inner_tts() {\n+            for tt in &del.tts {\n                 check_binders(sess, node_id, tt, macros, binders, ops, valid);\n             }\n         }\n@@ -345,7 +345,7 @@ fn check_occurrences(\n             check_ops_is_prefix(sess, node_id, macros, binders, ops, dl.entire(), name);\n         }\n         TokenTree::Delimited(_, ref del) => {\n-            check_nested_occurrences(sess, node_id, del.inner_tts(), macros, binders, ops, valid);\n+            check_nested_occurrences(sess, node_id, &del.tts, macros, binders, ops, valid);\n         }\n         TokenTree::Sequence(_, ref seq) => {\n             let ops = ops.push(seq.kleene);\n@@ -432,20 +432,14 @@ fn check_nested_occurrences(\n             {\n                 let macro_rules = state == NestedMacroState::MacroRulesNotName;\n                 state = NestedMacroState::Empty;\n-                let rest = check_nested_macro(\n-                    sess,\n-                    node_id,\n-                    macro_rules,\n-                    del.inner_tts(),\n-                    &nested_macros,\n-                    valid,\n-                );\n+                let rest =\n+                    check_nested_macro(sess, node_id, macro_rules, &del.tts, &nested_macros, valid);\n                 // If we did not check the whole macro definition, then check the rest as if outside\n                 // the macro definition.\n                 check_nested_occurrences(\n                     sess,\n                     node_id,\n-                    &del.inner_tts()[rest..],\n+                    &del.tts[rest..],\n                     macros,\n                     binders,\n                     ops,"}, {"sha": "a137e0c92e8a290eda99096d951f9cd234a4cdaf", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -151,9 +151,11 @@ pub(super) fn compute_locs(sess: &ParseSess, matcher: &[TokenTree]) -> Vec<Match\n                 TokenTree::Token(token) => {\n                     locs.push(MatcherLoc::Token { token: token.clone() });\n                 }\n-                TokenTree::Delimited(_, delimited) => {\n+                TokenTree::Delimited(span, delimited) => {\n                     locs.push(MatcherLoc::Delimited);\n-                    inner(sess, &delimited.all_tts, locs, next_metavar, seq_depth);\n+                    inner(sess, &[delimited.open_tt(*span)], locs, next_metavar, seq_depth);\n+                    inner(sess, &delimited.tts, locs, next_metavar, seq_depth);\n+                    inner(sess, &[delimited.close_tt(*span)], locs, next_metavar, seq_depth);\n                 }\n                 TokenTree::Sequence(_, seq) => {\n                     // We can't determine `idx_first_after` and construct the final\n@@ -293,7 +295,7 @@ pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n         .map(|tt| match tt {\n             TokenTree::MetaVarDecl(..) => 1,\n             TokenTree::Sequence(_, seq) => seq.num_captures,\n-            TokenTree::Delimited(_, delim) => count_metavar_decls(delim.inner_tts()),\n+            TokenTree::Delimited(_, delim) => count_metavar_decls(&delim.tts),\n             TokenTree::Token(..) => 0,\n             TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n         })"}, {"sha": "31dae6a2fb437b6b531b31e0a3135ea4f74bcb5c", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -263,9 +263,7 @@ fn generic_extension<'cx, 'tt>(\n \n                 // Ignore the delimiters on the RHS.\n                 let rhs = match &rhses[i] {\n-                    mbe::TokenTree::Delimited(_, delimited) => {\n-                        delimited.inner_tts().to_vec().clone()\n-                    }\n+                    mbe::TokenTree::Delimited(_, delimited) => delimited.tts.to_vec(),\n                     _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 let arm_span = rhses[i].span();\n@@ -470,17 +468,16 @@ pub fn compile_declarative_macro(\n             .iter()\n             .map(|m| {\n                 if let MatchedTokenTree(ref tt) = *m {\n-                    let mut tts = vec![];\n-                    mbe::quoted::parse(\n+                    let tt = mbe::quoted::parse(\n                         tt.clone().into(),\n                         true,\n                         &sess.parse_sess,\n                         def.id,\n                         features,\n                         edition,\n-                        &mut tts,\n-                    );\n-                    let tt = tts.pop().unwrap();\n+                    )\n+                    .pop()\n+                    .unwrap();\n                     valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def, &tt);\n                     return tt;\n                 }\n@@ -495,17 +492,16 @@ pub fn compile_declarative_macro(\n             .iter()\n             .map(|m| {\n                 if let MatchedTokenTree(ref tt) = *m {\n-                    let mut tts = vec![];\n-                    mbe::quoted::parse(\n+                    return mbe::quoted::parse(\n                         tt.clone().into(),\n                         false,\n                         &sess.parse_sess,\n                         def.id,\n                         features,\n                         edition,\n-                        &mut tts,\n-                    );\n-                    return tts.pop().unwrap();\n+                    )\n+                    .pop()\n+                    .unwrap();\n                 }\n                 sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             })\n@@ -544,7 +540,7 @@ pub fn compile_declarative_macro(\n                 // Ignore the delimiters around the matcher.\n                 match lhs {\n                     mbe::TokenTree::Delimited(_, delimited) => {\n-                        mbe::macro_parser::compute_locs(&sess.parse_sess, delimited.inner_tts())\n+                        mbe::macro_parser::compute_locs(&sess.parse_sess, &delimited.tts)\n                     }\n                     _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"malformed macro lhs\"),\n                 }\n@@ -576,7 +572,7 @@ fn check_lhs_nt_follows(\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     if let mbe::TokenTree::Delimited(_, delimited) = lhs {\n-        check_matcher(sess, features, def, delimited.inner_tts())\n+        check_matcher(sess, features, def, &delimited.tts)\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n         sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -597,7 +593,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             | TokenTree::MetaVarDecl(..)\n             | TokenTree::MetaVarExpr(..) => (),\n             TokenTree::Delimited(_, ref del) => {\n-                if !check_lhs_no_empty_seq(sess, del.inner_tts()) {\n+                if !check_lhs_no_empty_seq(sess, &del.tts) {\n                     return false;\n                 }\n             }\n@@ -692,9 +688,9 @@ impl FirstSets {\n                     | TokenTree::MetaVarExpr(..) => {\n                         first.replace_with(tt.clone());\n                     }\n-                    TokenTree::Delimited(_span, ref delimited) => {\n-                        build_recur(sets, delimited.inner_tts());\n-                        first.replace_with(delimited.open_tt().clone());\n+                    TokenTree::Delimited(span, ref delimited) => {\n+                        build_recur(sets, &delimited.tts);\n+                        first.replace_with(delimited.open_tt(span));\n                     }\n                     TokenTree::Sequence(sp, ref seq_rep) => {\n                         let subfirst = build_recur(sets, &seq_rep.tts);\n@@ -758,8 +754,8 @@ impl FirstSets {\n                     first.add_one(tt.clone());\n                     return first;\n                 }\n-                TokenTree::Delimited(_span, ref delimited) => {\n-                    first.add_one(delimited.open_tt().clone());\n+                TokenTree::Delimited(span, ref delimited) => {\n+                    first.add_one(delimited.open_tt(span));\n                     return first;\n                 }\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n@@ -945,9 +941,9 @@ fn check_matcher_core(\n                     suffix_first = build_suffix_first();\n                 }\n             }\n-            TokenTree::Delimited(_span, ref d) => {\n-                let my_suffix = TokenSet::singleton(d.close_tt().clone());\n-                check_matcher_core(sess, features, def, first_sets, d.inner_tts(), &my_suffix);\n+            TokenTree::Delimited(span, ref d) => {\n+                let my_suffix = TokenSet::singleton(d.close_tt(span));\n+                check_matcher_core(sess, features, def, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n "}, {"sha": "a99a18aae119a4c49c12ceea5f3a1e854c5d77dd", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -45,8 +45,10 @@ pub(super) fn parse(\n     node_id: NodeId,\n     features: &Features,\n     edition: Edition,\n-    result: &mut Vec<TokenTree>,\n-) {\n+) -> Vec<TokenTree> {\n+    // Will contain the final collection of `self::TokenTree`\n+    let mut result = Vec::new();\n+\n     // For each token tree in `input`, parse the token into a `self::TokenTree`, consuming\n     // additional trees if need be.\n     let mut trees = input.trees();\n@@ -113,6 +115,7 @@ pub(super) fn parse(\n             _ => result.push(tree),\n         }\n     }\n+    result\n }\n \n /// Asks for the `macro_metavar_expr` feature if it is not already declared\n@@ -205,8 +208,7 @@ fn parse_tree(\n                     // If we didn't find a metavar expression above, then we must have a\n                     // repetition sequence in the macro (e.g. `$(pat)*`).  Parse the\n                     // contents of the sequence itself\n-                    let mut sequence = vec![];\n-                    parse(tts, parsing_patterns, sess, node_id, features, edition, &mut sequence);\n+                    let sequence = parse(tts, parsing_patterns, sess, node_id, features, edition);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n                         parse_sep_and_kleene_op(&mut trees, delim_span.entire(), sess);\n@@ -269,15 +271,13 @@ fn parse_tree(\n \n         // `tree` is the beginning of a delimited set of tokens (e.g., `(` or `{`). We need to\n         // descend into the delimited set and further parse it.\n-        tokenstream::TokenTree::Delimited(span, delim, tts) => {\n-            let mut all_tts = vec![];\n-            // Add the explicit open and close delimiters, which\n-            // `tokenstream::TokenTree::Delimited` lacks.\n-            all_tts.push(TokenTree::token(token::OpenDelim(delim), span.open));\n-            parse(tts, parsing_patterns, sess, node_id, features, edition, &mut all_tts);\n-            all_tts.push(TokenTree::token(token::CloseDelim(delim), span.close));\n-            TokenTree::Delimited(span, Lrc::new(Delimited { delim, all_tts }))\n-        }\n+        tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n+            span,\n+            Lrc::new(Delimited {\n+                delim,\n+                tts: parse(tts, parsing_patterns, sess, node_id, features, edition),\n+            }),\n+        ),\n     }\n }\n "}, {"sha": "b1ab2cc45781a2874165687d675da77ef8f67872", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -10,7 +10,7 @@ use rustc_errors::{pluralize, PResult};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_span::hygiene::{LocalExpnId, Transparency};\n use rustc_span::symbol::{sym, Ident, MacroRulesNormalizedIdent};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n use std::mem;\n@@ -34,14 +34,8 @@ enum Frame {\n \n impl Frame {\n     /// Construct a new frame around the delimited set of tokens.\n-    fn new(mut tts: Vec<mbe::TokenTree>) -> Frame {\n-        // Need to add empty delimiters.\n-        let open_tt = mbe::TokenTree::token(token::OpenDelim(token::NoDelim), DUMMY_SP);\n-        let close_tt = mbe::TokenTree::token(token::CloseDelim(token::NoDelim), DUMMY_SP);\n-        tts.insert(0, open_tt);\n-        tts.push(close_tt);\n-\n-        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, all_tts: tts });\n+    fn new(tts: Vec<mbe::TokenTree>) -> Frame {\n+        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, tts });\n         Frame::Delimited { forest, idx: 0, span: DelimSpan::dummy() }\n     }\n }\n@@ -52,7 +46,7 @@ impl Iterator for Frame {\n     fn next(&mut self) -> Option<mbe::TokenTree> {\n         match *self {\n             Frame::Delimited { ref forest, ref mut idx, .. } => {\n-                let res = forest.inner_tts().get(*idx).cloned();\n+                let res = forest.tts.get(*idx).cloned();\n                 *idx += 1;\n                 res\n             }\n@@ -388,7 +382,7 @@ fn lockstep_iter_size(\n     use mbe::TokenTree;\n     match *tree {\n         TokenTree::Delimited(_, ref delimited) => {\n-            delimited.inner_tts().iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n+            delimited.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }"}, {"sha": "8340a0b360ef7f08549580373253d327ba5ba640", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -505,6 +505,8 @@ declare_features! (\n     (active, static_nobundle, \"1.16.0\", Some(37403), None),\n     /// Allows attributes on expressions and non-item statements.\n     (active, stmt_expr_attributes, \"1.6.0\", Some(15701), None),\n+    /// Allows lints part of the strict provenance effort.\n+    (active, strict_provenance, \"1.61.0\", Some(95228), None),\n     /// Allows the use of `#[target_feature]` on safe functions.\n     (active, target_feature_11, \"1.45.0\", Some(69098), None),\n     /// Allows using `#[thread_local]` on `static` items."}, {"sha": "89ce307d12cd707f0bc6bc550bf64baf0aea5add", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -2648,6 +2648,96 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `fuzzy_provenance_casts` lint detects an `as` cast between an integer\n+    /// and a pointer.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(strict_provenance)]\n+    /// #![warn(fuzzy_provenance_casts)]\n+    ///\n+    /// fn main() {\n+    ///     let _dangling = 16_usize as *const u8;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is part of the strict provenance effort, see [issue #95228].\n+    /// Casting an integer to a pointer is considered bad style, as a pointer\n+    /// contains, besides the *address* also a *provenance*, indicating what\n+    /// memory the pointer is allowed to read/write. Casting an integer, which\n+    /// doesn't have provenance, to a pointer requires the compiler to assign\n+    /// (guess) provenance. The compiler assigns \"all exposed valid\" (see the\n+    /// docs of [`ptr::from_exposed_addr`] for more information about this\n+    /// \"exposing\"). This penalizes the optimiser and is not well suited for\n+    /// dynamic analysis/dynamic program verification (e.g. Miri or CHERI\n+    /// platforms).\n+    ///\n+    /// It is much better to use [`ptr::with_addr`] instead to specify the\n+    /// provenance you want. If using this function is not possible because the\n+    /// code relies on exposed provenance then there is as an escape hatch\n+    /// [`ptr::from_exposed_addr`].\n+    ///\n+    /// [issue #95228]: https://github.com/rust-lang/rust/issues/95228\n+    /// [`ptr::with_addr`]: https://doc.rust-lang.org/core/ptr/fn.with_addr\n+    /// [`ptr::from_exposed_addr`]: https://doc.rust-lang.org/core/ptr/fn.from_exposed_addr\n+    pub FUZZY_PROVENANCE_CASTS,\n+    Allow,\n+    \"a fuzzy integer to pointer cast is used\",\n+    @feature_gate = sym::strict_provenance;\n+}\n+\n+declare_lint! {\n+    /// The `lossy_provenance_casts` lint detects an `as` cast between a pointer\n+    /// and an integer.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(strict_provenance)]\n+    /// #![warn(lossy_provenance_casts)]\n+    ///\n+    /// fn main() {\n+    ///     let x: u8 = 37;\n+    ///     let _addr: usize = &x as *const u8 as usize;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is part of the strict provenance effort, see [issue #95228].\n+    /// Casting a pointer to an integer is a lossy operation, because beyond\n+    /// just an *address* a pointer may be associated with a particular\n+    /// *provenance*. This information is used by the optimiser and for dynamic\n+    /// analysis/dynamic program verification (e.g. Miri or CHERI platforms).\n+    ///\n+    /// Since this cast is lossy, it is considered good style to use the\n+    /// [`ptr::addr`] method instead, which has a similar effect, but doesn't\n+    /// \"expose\" the pointer provenance. This improves optimisation potential.\n+    /// See the docs of [`ptr::addr`] and [`ptr::expose_addr`] for more information\n+    /// about exposing pointer provenance.\n+    ///\n+    /// If your code can't comply with strict provenance and needs to expose\n+    /// the provenance, then there is [`ptr::expose_addr`] as an escape hatch,\n+    /// which preserves the behaviour of `as usize` casts while being explicit\n+    /// about the semantics.\n+    ///\n+    /// [issue #95228]: https://github.com/rust-lang/rust/issues/95228\n+    /// [`ptr::addr`]: https://doc.rust-lang.org/core/ptr/fn.addr\n+    /// [`ptr::expose_addr`]: https://doc.rust-lang.org/core/ptr/fn.expose_addr\n+    pub LOSSY_PROVENANCE_CASTS,\n+    Allow,\n+    \"a lossy pointer to integer cast is used\",\n+    @feature_gate = sym::strict_provenance;\n+}\n+\n declare_lint! {\n     /// The `const_evaluatable_unchecked` lint detects a generic constant used\n     /// in a type.\n@@ -3101,6 +3191,8 @@ declare_lint_pass! {\n         UNSAFE_OP_IN_UNSAFE_FN,\n         INCOMPLETE_INCLUDE,\n         CENUM_IMPL_DROP_CAST,\n+        FUZZY_PROVENANCE_CASTS,\n+        LOSSY_PROVENANCE_CASTS,\n         CONST_EVALUATABLE_UNCHECKED,\n         INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n         MUST_NOT_SUSPEND,"}, {"sha": "dc4d10f699c7517b7e8a900d26c8c6051d369367", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -1348,6 +1348,7 @@ symbols! {\n         str_trim,\n         str_trim_end,\n         str_trim_start,\n+        strict_provenance,\n         stringify,\n         stringify_macro,\n         struct_field_attributes,"}, {"sha": "ac98dd5801e404d0f48ea9ada7a6a889ccf756b9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -36,6 +36,7 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n use std::iter;\n+use std::ops::ControlFlow;\n \n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n@@ -2226,9 +2227,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         post.dedup();\n \n         if self.is_tainted_by_errors()\n-            && crate_names.len() == 1\n-            && [\"`core`\", \"`alloc`\", \"`std`\"].contains(&crate_names[0].as_str())\n-            && spans.len() == 0\n+            && (crate_names.len() == 1\n+                && spans.len() == 0\n+                && [\"`core`\", \"`alloc`\", \"`std`\"].contains(&crate_names[0].as_str())\n+                || predicate.visit_with(&mut HasNumericInferVisitor).is_break())\n         {\n             // Avoid complaining about other inference issues for expressions like\n             // `42 >> 1`, where the types are still `{integer}`, but we want to\n@@ -2666,3 +2668,17 @@ impl ArgKind {\n         }\n     }\n }\n+\n+struct HasNumericInferVisitor;\n+\n+impl<'tcx> ty::TypeVisitor<'tcx> for HasNumericInferVisitor {\n+    type BreakTy = ();\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if matches!(ty.kind(), ty::Infer(ty::FloatVar(_) | ty::IntVar(_))) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+}"}, {"sha": "6091b8fee00b679f8ad0d57da0146a1696976aff", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -807,11 +807,22 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n             // ptr -> *\n             (Ptr(m_e), Ptr(m_c)) => self.check_ptr_ptr_cast(fcx, m_e, m_c), // ptr-ptr-cast\n-            (Ptr(m_expr), Int(_)) => self.check_ptr_addr_cast(fcx, m_expr), // ptr-addr-cast\n-            (FnPtr, Int(_)) => Ok(CastKind::FnPtrAddrCast),\n \n-            // * -> ptr\n-            (Int(_), Ptr(mt)) => self.check_addr_ptr_cast(fcx, mt), // addr-ptr-cast\n+            // ptr-addr-cast\n+            (Ptr(m_expr), Int(t_c)) => {\n+                self.lossy_provenance_ptr2int_lint(fcx, t_c);\n+                self.check_ptr_addr_cast(fcx, m_expr)\n+            }\n+            (FnPtr, Int(_)) => {\n+                // FIXME(#95489): there should eventually be a lint for these casts\n+                Ok(CastKind::FnPtrAddrCast)\n+            }\n+            // addr-ptr-cast\n+            (Int(_), Ptr(mt)) => {\n+                self.fuzzy_provenance_int2ptr_lint(fcx);\n+                self.check_addr_ptr_cast(fcx, mt)\n+            }\n+            // fn-ptr-cast\n             (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n \n             // prim -> prim\n@@ -973,6 +984,74 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             }\n         }\n     }\n+\n+    fn lossy_provenance_ptr2int_lint(&self, fcx: &FnCtxt<'a, 'tcx>, t_c: ty::cast::IntTy) {\n+        fcx.tcx.struct_span_lint_hir(\n+            lint::builtin::LOSSY_PROVENANCE_CASTS,\n+            self.expr.hir_id,\n+            self.span,\n+            |err| {\n+                let mut err = err.build(&format!(\n+                    \"under strict provenance it is considered bad style to cast pointer `{}` to integer `{}`\",\n+                    self.expr_ty, self.cast_ty\n+                ));\n+\n+                let msg = \"use `.addr()` to obtain the address of a pointer\";\n+                if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n+                    let scalar_cast = match t_c {\n+                        ty::cast::IntTy::U(ty::UintTy::Usize) => String::new(),\n+                        _ => format!(\" as {}\", self.cast_ty),\n+                    };\n+                    err.span_suggestion(\n+                        self.span,\n+                        msg,\n+                        format!(\"({}).addr(){}\", snippet, scalar_cast),\n+                        Applicability::MaybeIncorrect\n+                    );\n+                } else {\n+                    err.help(msg);\n+                }\n+                err.help(\n+                    \"if you can't comply with strict provenance and need to expose the pointer\\\n+                    provenance you can use `.expose_addr()` instead\"\n+                );\n+\n+                err.emit();\n+            },\n+        );\n+    }\n+\n+    fn fuzzy_provenance_int2ptr_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n+        fcx.tcx.struct_span_lint_hir(\n+            lint::builtin::FUZZY_PROVENANCE_CASTS,\n+            self.expr.hir_id,\n+            self.span,\n+            |err| {\n+\n+                let mut err = err.build(&format!(\n+                    \"strict provenance disallows casting integer `{}` to pointer `{}`\",\n+                    self.expr_ty, self.cast_ty\n+                ));\n+                let msg = \"use `.with_addr()` to adjust a valid pointer in the same allocation, to this address\";\n+                if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n+                    err.span_suggestion(\n+                        self.span,\n+                        msg,\n+                        format!(\"(...).with_addr({})\", snippet),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                } else {\n+                    err.help(msg);\n+                }\n+                err.help(\n+                    \"if you can't comply with strict provenance and don't have a pointer with \\\n+                    the correct provenance you can use `std::ptr::from_exposed_addr()` instead\"\n+                 );\n+\n+                err.emit();\n+            },\n+        );\n+    }\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {"}, {"sha": "e6faf1df3a8105fc219a37604165c654476e2321", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -163,6 +163,11 @@ use crate::str::from_boxed_utf8_unchecked;\n #[cfg(not(no_global_oom_handling))]\n use crate::vec::Vec;\n \n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+pub use thin::ThinBox;\n+\n+mod thin;\n+\n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more."}, {"sha": "390030fa2b21cbd82db95c7d721a539df5818fd4", "filename": "library/alloc/src/boxed/thin.rs", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,215 @@\n+// Based on\n+// https://github.com/matthieu-m/rfc2580/blob/b58d1d3cba0d4b5e859d3617ea2d0943aaa31329/examples/thin.rs\n+// by matthieu-m\n+use crate::alloc::{self, Layout, LayoutError};\n+use core::fmt::{self, Debug, Display, Formatter};\n+use core::marker::{PhantomData, Unsize};\n+use core::mem;\n+use core::ops::{Deref, DerefMut};\n+use core::ptr::Pointee;\n+use core::ptr::{self, NonNull};\n+\n+/// ThinBox.\n+///\n+/// A thin pointer for heap allocation, regardless of T.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(thin_box)]\n+/// use std::boxed::ThinBox;\n+///\n+/// let five = ThinBox::new(5);\n+/// let thin_slice = ThinBox::<[i32]>::new_unsize([1, 2, 3, 4]);\n+///\n+/// use std::mem::{size_of, size_of_val};\n+/// let size_of_ptr = size_of::<*const ()>();\n+/// assert_eq!(size_of_ptr, size_of_val(&five));\n+/// assert_eq!(size_of_ptr, size_of_val(&thin_slice));\n+/// ```\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+pub struct ThinBox<T: ?Sized> {\n+    ptr: WithHeader<<T as Pointee>::Metadata>,\n+    _marker: PhantomData<T>,\n+}\n+\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<T> ThinBox<T> {\n+    /// Moves a type to the heap with its `Metadata` stored in the heap allocation instead of on\n+    /// the stack.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(thin_box)]\n+    /// use std::boxed::ThinBox;\n+    ///\n+    /// let five = ThinBox::new(5);\n+    /// ```\n+    #[cfg(not(no_global_oom_handling))]\n+    pub fn new(value: T) -> Self {\n+        let meta = ptr::metadata(&value);\n+        let ptr = WithHeader::new(meta, value);\n+        ThinBox { ptr, _marker: PhantomData }\n+    }\n+}\n+\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<Dyn: ?Sized> ThinBox<Dyn> {\n+    /// Moves a type to the heap with its `Metadata` stored in the heap allocation instead of on\n+    /// the stack.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(thin_box)]\n+    /// use std::boxed::ThinBox;\n+    ///\n+    /// let thin_slice = ThinBox::<[i32]>::new_unsize([1, 2, 3, 4]);\n+    /// ```\n+    #[cfg(not(no_global_oom_handling))]\n+    pub fn new_unsize<T>(value: T) -> Self\n+    where\n+        T: Unsize<Dyn>,\n+    {\n+        let meta = ptr::metadata(&value as &Dyn);\n+        let ptr = WithHeader::new(meta, value);\n+        ThinBox { ptr, _marker: PhantomData }\n+    }\n+}\n+\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<T: ?Sized + Debug> Debug for ThinBox<T> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        Debug::fmt(self.deref(), f)\n+    }\n+}\n+\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<T: ?Sized + Display> Display for ThinBox<T> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        Display::fmt(self.deref(), f)\n+    }\n+}\n+\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<T: ?Sized> Deref for ThinBox<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        let value = self.data();\n+        let metadata = self.meta();\n+        let pointer = ptr::from_raw_parts(value as *const (), metadata);\n+        unsafe { &*pointer }\n+    }\n+}\n+\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<T: ?Sized> DerefMut for ThinBox<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        let value = self.data();\n+        let metadata = self.meta();\n+        let pointer = ptr::from_raw_parts_mut::<T>(value as *mut (), metadata);\n+        unsafe { &mut *pointer }\n+    }\n+}\n+\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<T: ?Sized> Drop for ThinBox<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let value = self.deref_mut();\n+            let value = value as *mut T;\n+            self.ptr.drop::<T>(value);\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<T: ?Sized> ThinBox<T> {\n+    fn meta(&self) -> <T as Pointee>::Metadata {\n+        //  Safety:\n+        //  -   NonNull and valid.\n+        unsafe { *self.ptr.header() }\n+    }\n+\n+    fn data(&self) -> *mut u8 {\n+        self.ptr.value()\n+    }\n+}\n+\n+/// A pointer to type-erased data, guaranteed to have a header `H` before the pointed-to location.\n+struct WithHeader<H>(NonNull<u8>, PhantomData<H>);\n+\n+impl<H> WithHeader<H> {\n+    #[cfg(not(no_global_oom_handling))]\n+    fn new<T>(header: H, value: T) -> WithHeader<H> {\n+        let value_layout = Layout::new::<T>();\n+        let Ok((layout, value_offset)) = Self::alloc_layout(value_layout) else {\n+            // We pass an empty layout here because we do not know which layout caused the\n+            // arithmetic overflow in `Layout::extend` and `handle_alloc_error` takes `Layout` as\n+            // its argument rather than `Result<Layout, LayoutError>`, also this function has been\n+            // stable since 1.28 ._.\n+            //\n+            // On the other hand, look at this gorgeous turbofish!\n+            alloc::handle_alloc_error(Layout::new::<()>());\n+        };\n+\n+        unsafe {\n+            let ptr = alloc::alloc(layout);\n+\n+            if ptr.is_null() {\n+                alloc::handle_alloc_error(layout);\n+            }\n+            //  Safety:\n+            //  -   The size is at least `aligned_header_size`.\n+            let ptr = ptr.add(value_offset) as *mut _;\n+\n+            let ptr = NonNull::new_unchecked(ptr);\n+\n+            let result = WithHeader(ptr, PhantomData);\n+            ptr::write(result.header(), header);\n+            ptr::write(result.value().cast(), value);\n+\n+            result\n+        }\n+    }\n+\n+    //  Safety:\n+    //  -   Assumes that `value` can be dereferenced.\n+    unsafe fn drop<T: ?Sized>(&self, value: *mut T) {\n+        unsafe {\n+            // SAFETY: Layout must have been computable if we're in drop\n+            let (layout, value_offset) =\n+                Self::alloc_layout(Layout::for_value_raw(value)).unwrap_unchecked();\n+\n+            ptr::drop_in_place::<T>(value);\n+            // We only drop the value because the Pointee trait requires that the metadata is copy\n+            // aka trivially droppable\n+            alloc::dealloc(self.0.as_ptr().sub(value_offset), layout);\n+        }\n+    }\n+\n+    fn header(&self) -> *mut H {\n+        //  Safety:\n+        //  - At least `size_of::<H>()` bytes are allocated ahead of the pointer.\n+        //  - We know that H will be aligned because the middle pointer is aligned to the greater\n+        //    of the alignment of the header and the data and the header size includes the padding\n+        //    needed to align the header. Subtracting the header size from the aligned data pointer\n+        //    will always result in an aligned header pointer, it just may not point to the\n+        //    beginning of the allocation.\n+        unsafe { self.0.as_ptr().sub(Self::header_size()) as *mut H }\n+    }\n+\n+    fn value(&self) -> *mut u8 {\n+        self.0.as_ptr()\n+    }\n+\n+    const fn header_size() -> usize {\n+        mem::size_of::<H>()\n+    }\n+\n+    fn alloc_layout(value_layout: Layout) -> Result<(Layout, usize), LayoutError> {\n+        Layout::new::<H>().extend(value_layout)\n+    }\n+}"}, {"sha": "c54001dceea49b8a29fb2fab63337e4d684cda36", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -120,6 +120,7 @@\n #![feature(nonnull_slice_from_raw_parts)]\n #![feature(pattern)]\n #![feature(ptr_internals)]\n+#![feature(ptr_metadata)]\n #![feature(receiver_trait)]\n #![feature(set_ptr_value)]\n #![feature(slice_group_by)]\n@@ -152,6 +153,7 @@\n #![feature(fundamental)]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![feature(lang_items)]\n+#![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(negative_impls)]\n #![feature(never_type)]"}, {"sha": "16d3b36859570e27c3505d45dd51163837fa4ca9", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -39,6 +39,7 @@\n #![feature(nonnull_slice_from_raw_parts)]\n #![feature(panic_update_hook)]\n #![feature(slice_flatten)]\n+#![feature(thin_box)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};\n@@ -57,6 +58,7 @@ mod rc;\n mod slice;\n mod str;\n mod string;\n+mod thin_box;\n mod vec;\n mod vec_deque;\n "}, {"sha": "0fe6aaa4d004855f52c2b07a6ac439b07eeded3c", "filename": "library/alloc/tests/thin_box.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Ftests%2Fthin_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Falloc%2Ftests%2Fthin_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fthin_box.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,26 @@\n+use alloc::boxed::ThinBox;\n+use core::mem::size_of;\n+\n+#[test]\n+fn want_niche_optimization() {\n+    fn uses_niche<T: ?Sized>() -> bool {\n+        size_of::<*const ()>() == size_of::<Option<ThinBox<T>>>()\n+    }\n+\n+    trait Tr {}\n+    assert!(uses_niche::<dyn Tr>());\n+    assert!(uses_niche::<[i32]>());\n+    assert!(uses_niche::<i32>());\n+}\n+\n+#[test]\n+fn want_thin() {\n+    fn is_thin<T: ?Sized>() -> bool {\n+        size_of::<*const ()>() == size_of::<ThinBox<T>>()\n+    }\n+\n+    trait Tr {}\n+    assert!(is_thin::<dyn Tr>());\n+    assert!(is_thin::<[i32]>());\n+    assert!(is_thin::<i32>());\n+}"}, {"sha": "98fb7e9e41d7a0c2837be360d0fd00d0cbff27c1", "filename": "library/core/src/macros/panic.md", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Fcore%2Fsrc%2Fmacros%2Fpanic.md", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Fcore%2Fsrc%2Fmacros%2Fpanic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fpanic.md?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -24,20 +24,30 @@ See also the macro [`compile_error!`], for raising errors during compilation.\n \n # When to use `panic!` vs `Result`\n \n-The Rust model of error handling groups errors into two major categories:\n-recoverable and unrecoverable errors. For a recoverable error, such as a file\n-not found error, it\u2019s reasonable to report the problem to the user and retry\n-the operation. Unrecoverable errors are always symptoms of bugs, like trying to\n-access a location beyond the end of an array.\n+The Rust language provides two complementary systems for constructing /\n+representing, reporting, propagating, reacting to, and discarding errors. These\n+responsibilities are collectively known as \"error handling.\" `panic!` and\n+`Result` are similar in that they are each the primary interface of their\n+respective error handling systems; however, the meaning these interfaces attach\n+to their errors and the responsibilities they fulfill within their respective\n+error handling systems differ.\n \n-The Rust language and standard library provides `Result` and `panic!` as parts\n-of two complementary systems for representing, reporting, propagating, reacting\n-to, and discarding errors for in these two categories.\n+The `panic!` macro is used to construct errors that represent a bug that has\n+been detected in your program. With `panic!` you provide a message that\n+describes the bug and the language then constructs an error with that message,\n+reports it, and propagates it for you.\n \n-The `panic!` macro is provided to represent unrecoverable errors, whereas the\n-`Result` enum is provided to represent recoverable errors. For more detailed\n-information about error handling check out the [book] or the [`std::result`]\n-module docs.\n+`Result` on the other hand is used to wrap other types that represent either\n+the successful result of some computation, `Ok(T)`, or error types that\n+represent an anticipated runtime failure mode of that computation, `Err(E)`.\n+`Result` is used alongside user defined types which represent the various\n+anticipated runtime failure modes that the associated computation could\n+encounter. `Result` must be propagated manually, often with the the help of the\n+`?` operator and `Try` trait, and they must be reported manually, often with\n+the help of the `Error` trait.\n+\n+For more detailed information about error handling check out the [book] or the\n+[`std::result`] module docs.\n \n [ounwrap]: Option::unwrap\n [runwrap]: Result::unwrap"}, {"sha": "4fb94908c80fd4ed3c2fe5088e9f23aeabcd0f19", "filename": "library/std/src/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -516,6 +516,14 @@ impl<T: Error> Error for Box<T> {\n     }\n }\n \n+#[unstable(feature = \"thin_box\", issue = \"92791\")]\n+impl<T: ?Sized + crate::error::Error> crate::error::Error for crate::boxed::ThinBox<T> {\n+    fn source(&self) -> Option<&(dyn crate::error::Error + 'static)> {\n+        use core::ops::Deref;\n+        self.deref().source()\n+    }\n+}\n+\n #[stable(feature = \"error_by_ref\", since = \"1.51.0\")]\n impl<'a, T: Error + ?Sized> Error for &'a T {\n     #[allow(deprecated, deprecated_in_future)]"}, {"sha": "60e7c2af8e4a5a36507c7a3f5a3f9ce7338bde09", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -290,6 +290,7 @@\n #![feature(get_mut_unchecked)]\n #![feature(map_try_insert)]\n #![feature(new_uninit)]\n+#![feature(thin_box)]\n #![feature(toowned_clone_into)]\n #![feature(try_reserve_kind)]\n #![feature(vec_into_raw_parts)]"}, {"sha": "dc60f3f375d3c5b3bfad30fbd210e827380d33dc", "filename": "src/doc/unstable-book/src/language-features/strict-provenance.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstrict-provenance.md", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstrict-provenance.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fstrict-provenance.md?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,22 @@\n+# `strict_provenance`\n+\n+The tracking issue for this feature is: [#95228]\n+\n+[#95228]: https://github.com/rust-lang/rust/issues/95228\n+-----\n+\n+The `strict_provenance` feature allows to enable the `fuzzy_provenance_casts` and `lossy_provenance_casts` lints.\n+These lint on casts between integers and pointers, that are recommended against or invalid in the strict provenance model.\n+The same feature gate is also used for the experimental strict provenance API in `std` (actually `core`).\n+\n+## Example\n+\n+```rust\n+#![feature(strict_provenance)]\n+#![warn(fuzzy_provenance_casts)]\n+\n+fn main() {\n+    let _dangling = 16_usize as *const u8;\n+    //~^ WARNING: strict provenance disallows casting integer `usize` to pointer `*const u8`\n+}\n+```"}, {"sha": "b1dae930e066b6c4bcefc1797d3a87fefb323572", "filename": "src/test/rustdoc/empty-doc-comment.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Frustdoc%2Fempty-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Frustdoc%2Fempty-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fempty-doc-comment.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,22 @@\n+// Ensure that empty doc comments don't panic.\n+\n+/*!\n+*/\n+\n+///\n+///\n+pub struct Foo;\n+\n+#[doc = \"\n+\"]\n+pub mod Mod {\n+   //!\n+   //!\n+}\n+\n+/**\n+*/\n+pub mod Another {\n+   #![doc = \"\n+\"]\n+}"}, {"sha": "3c61d0090e42bb8698644fdafe4eec924535f2b8", "filename": "src/test/ui/box/thin_align.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fbox%2Fthin_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fbox%2Fthin_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fthin_align.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,26 @@\n+#![feature(thin_box)]\n+// run-pass\n+use std::boxed::ThinBox;\n+use std::error::Error;\n+use std::ops::Deref;\n+use std::fmt;\n+\n+fn main() {\n+    let expected = \"Foo error!\";\n+    let a: ThinBox<dyn Error> = ThinBox::new_unsize(Foo(expected));\n+    let a = a.deref();\n+    let msg = a.to_string();\n+    assert_eq!(expected, msg);\n+}\n+\n+#[derive(Debug)]\n+#[repr(align(1024))]\n+struct Foo(&'static str);\n+\n+impl fmt::Display for Foo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n+impl Error for Foo {}"}, {"sha": "965613c114e3a06b6cff068a92a3bd8f1103e2f2", "filename": "src/test/ui/box/thin_drop.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fbox%2Fthin_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fbox%2Fthin_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fthin_drop.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,37 @@\n+#![feature(thin_box)]\n+// run-pass\n+use std::boxed::ThinBox;\n+use std::error::Error;\n+use std::ops::Deref;\n+use std::fmt;\n+\n+fn main() {\n+    let expected = \"Foo error!\";\n+    let mut dropped = false;\n+    {\n+        let foo = Foo(expected, &mut dropped);\n+        let a: ThinBox<dyn Error> = ThinBox::new_unsize(foo);\n+        let a = a.deref();\n+        let msg = a.to_string();\n+        assert_eq!(expected, msg);\n+    }\n+    assert!(dropped);\n+}\n+\n+#[derive(Debug)]\n+#[repr(align(1024))]\n+struct Foo<'a>(&'static str, &'a mut bool);\n+\n+impl Drop for Foo<'_> {\n+    fn drop(&mut self) {\n+        *self.1 = true;\n+    }\n+}\n+\n+impl fmt::Display for Foo<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n+impl Error for Foo<'_> {}"}, {"sha": "53f46478be403d319884a29dcd0be2dd8129fbae", "filename": "src/test/ui/box/thin_new.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fbox%2Fthin_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fbox%2Fthin_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fthin_new.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,30 @@\n+#![feature(thin_box)]\n+// run-pass\n+use std::boxed::ThinBox;\n+use std::error::Error;\n+use std::{fmt, mem};\n+\n+fn main() {\n+    let thin_error: ThinBox<dyn Error> = ThinBox::new_unsize(Foo);\n+    assert_eq!(mem::size_of::<*const i32>(), mem::size_of_val(&thin_error));\n+    println!(\"{:?}\", thin_error);\n+\n+    let thin = ThinBox::new(42i32);\n+    assert_eq!(mem::size_of::<*const i32>(), mem::size_of_val(&thin));\n+    println!(\"{:?}\", thin);\n+\n+    let thin_slice = ThinBox::<[i32]>::new_unsize([1, 2, 3, 4]);\n+    assert_eq!(mem::size_of::<*const i32>(), mem::size_of_val(&thin_slice));\n+    println!(\"{:?}\", thin_slice);\n+}\n+\n+#[derive(Debug)]\n+struct Foo;\n+\n+impl fmt::Display for Foo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"boooo!\")\n+    }\n+}\n+\n+impl Error for Foo {}"}, {"sha": "77c400d17bbe5768471e507aec46337a2018d3d7", "filename": "src/test/ui/box/thin_zst.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fbox%2Fthin_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fbox%2Fthin_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fthin_zst.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,34 @@\n+#![feature(thin_box)]\n+// run-pass\n+use std::boxed::ThinBox;\n+use std::error::Error;\n+use std::{fmt, mem};\n+use std::ops::DerefMut;\n+\n+const EXPECTED: &str = \"boooo!\";\n+\n+fn main() {\n+    let thin_error: ThinBox<dyn Error> = ThinBox::new_unsize(Foo);\n+    assert_eq!(mem::size_of::<*const i32>(), mem::size_of_val(&thin_error));\n+    let msg = thin_error.to_string();\n+    assert_eq!(EXPECTED, msg);\n+\n+    let mut thin_concrete_error: ThinBox<Foo> = ThinBox::new(Foo);\n+    assert_eq!(mem::size_of::<*const i32>(), mem::size_of_val(&thin_concrete_error));\n+    let msg = thin_concrete_error.to_string();\n+    assert_eq!(EXPECTED, msg);\n+    let inner = thin_concrete_error.deref_mut();\n+    let msg = inner.to_string();\n+    assert_eq!(EXPECTED, msg);\n+}\n+\n+#[derive(Debug)]\n+struct Foo;\n+\n+impl fmt::Display for Foo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", EXPECTED)\n+    }\n+}\n+\n+impl Error for Foo {}"}, {"sha": "1b1ce67cb0c1fd20e716ef156775cfea4f3b95c7", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.nofallback.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -13,7 +13,7 @@ LL |     /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x\n              BorrowError\n              BorrowMutError\n              Box<T>\n-           and 42 others\n+           and 43 others\n    = note: required for the cast to the object type `dyn std::error::Error`\n \n error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n@@ -31,7 +31,7 @@ LL |     /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n              BorrowError\n              BorrowMutError\n              Box<T>\n-           and 42 others\n+           and 43 others\n    = note: required for the cast to the object type `(dyn std::error::Error + 'static)`\n \n error: aborting due to 2 previous errors"}, {"sha": "75d0ee5700d075af3f05920c77163935ae01a10c", "filename": "src/test/ui/feature-gates/feature-gate-strict_provenance.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-strict_provenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-strict_provenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-strict_provenance.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+#![deny(fuzzy_provenance_casts)]\n+//~^ WARNING unknown lint: `fuzzy_provenance_casts`\n+//~| WARNING unknown lint: `fuzzy_provenance_casts`\n+//~| WARNING unknown lint: `fuzzy_provenance_casts`\n+#![deny(lossy_provenance_casts)]\n+//~^ WARNING unknown lint: `lossy_provenance_casts`\n+//~| WARNING unknown lint: `lossy_provenance_casts`\n+//~| WARNING unknown lint: `lossy_provenance_casts`\n+\n+fn main() {\n+    // no warnings emitted since the lints are not activated\n+\n+    let _dangling = 16_usize as *const u8;\n+\n+    let x: u8 = 37;\n+    let _addr: usize = &x as *const u8 as usize;\n+}"}, {"sha": "34bd240c304a744edc68c084d678286d79fa8193", "filename": "src/test/ui/feature-gates/feature-gate-strict_provenance.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-strict_provenance.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-strict_provenance.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-strict_provenance.stderr?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,63 @@\n+warning: unknown lint: `fuzzy_provenance_casts`\n+  --> $DIR/feature-gate-strict_provenance.rs:3:1\n+   |\n+LL | #![deny(fuzzy_provenance_casts)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(unknown_lints)]` on by default\n+   = note: the `fuzzy_provenance_casts` lint is unstable\n+   = note: see issue #95228 <https://github.com/rust-lang/rust/issues/95228> for more information\n+   = help: add `#![feature(strict_provenance)]` to the crate attributes to enable\n+\n+warning: unknown lint: `lossy_provenance_casts`\n+  --> $DIR/feature-gate-strict_provenance.rs:7:1\n+   |\n+LL | #![deny(lossy_provenance_casts)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `lossy_provenance_casts` lint is unstable\n+   = note: see issue #95228 <https://github.com/rust-lang/rust/issues/95228> for more information\n+   = help: add `#![feature(strict_provenance)]` to the crate attributes to enable\n+\n+warning: unknown lint: `fuzzy_provenance_casts`\n+  --> $DIR/feature-gate-strict_provenance.rs:3:1\n+   |\n+LL | #![deny(fuzzy_provenance_casts)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `fuzzy_provenance_casts` lint is unstable\n+   = note: see issue #95228 <https://github.com/rust-lang/rust/issues/95228> for more information\n+   = help: add `#![feature(strict_provenance)]` to the crate attributes to enable\n+\n+warning: unknown lint: `lossy_provenance_casts`\n+  --> $DIR/feature-gate-strict_provenance.rs:7:1\n+   |\n+LL | #![deny(lossy_provenance_casts)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `lossy_provenance_casts` lint is unstable\n+   = note: see issue #95228 <https://github.com/rust-lang/rust/issues/95228> for more information\n+   = help: add `#![feature(strict_provenance)]` to the crate attributes to enable\n+\n+warning: unknown lint: `fuzzy_provenance_casts`\n+  --> $DIR/feature-gate-strict_provenance.rs:3:1\n+   |\n+LL | #![deny(fuzzy_provenance_casts)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `fuzzy_provenance_casts` lint is unstable\n+   = note: see issue #95228 <https://github.com/rust-lang/rust/issues/95228> for more information\n+   = help: add `#![feature(strict_provenance)]` to the crate attributes to enable\n+\n+warning: unknown lint: `lossy_provenance_casts`\n+  --> $DIR/feature-gate-strict_provenance.rs:7:1\n+   |\n+LL | #![deny(lossy_provenance_casts)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `lossy_provenance_casts` lint is unstable\n+   = note: see issue #95228 <https://github.com/rust-lang/rust/issues/95228> for more information\n+   = help: add `#![feature(strict_provenance)]` to the crate attributes to enable\n+\n+warning: 6 warnings emitted\n+"}, {"sha": "98fd13553c00959701f71f2e93177d91f2228945", "filename": "src/test/ui/intrinsics/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -104,6 +104,32 @@ fn main() {\n             \"attempted to instantiate uninhabited type `Bar`\"\n         );\n \n+        test_panic_msg(\n+            || mem::uninitialized::<[Foo; 2]>(),\n+            \"attempted to instantiate uninhabited type `[Foo; 2]`\"\n+        );\n+        test_panic_msg(\n+            || mem::zeroed::<[Foo; 2]>(),\n+            \"attempted to instantiate uninhabited type `[Foo; 2]`\"\n+        );\n+        test_panic_msg(\n+            || MaybeUninit::<[Foo; 2]>::uninit().assume_init(),\n+            \"attempted to instantiate uninhabited type `[Foo; 2]`\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::uninitialized::<[Bar; 2]>(),\n+            \"attempted to instantiate uninhabited type `[Bar; 2]`\"\n+        );\n+        test_panic_msg(\n+            || mem::zeroed::<[Bar; 2]>(),\n+            \"attempted to instantiate uninhabited type `[Bar; 2]`\"\n+        );\n+        test_panic_msg(\n+            || MaybeUninit::<[Bar; 2]>::uninit().assume_init(),\n+            \"attempted to instantiate uninhabited type `[Bar; 2]`\"\n+        );\n+\n         // Types that do not like zero-initialziation\n         test_panic_msg(\n             || mem::uninitialized::<fn()>(),\n@@ -199,7 +225,9 @@ fn main() {\n         let _val = mem::zeroed::<OneVariant>();\n         let _val = mem::zeroed::<Option<&'static i32>>();\n         let _val = mem::zeroed::<MaybeUninit<NonNull<u32>>>();\n+        let _val = mem::zeroed::<[!; 0]>();\n         let _val = mem::uninitialized::<MaybeUninit<bool>>();\n+        let _val = mem::uninitialized::<[!; 0]>();\n \n         // These are UB because they have not been officially blessed, but we await the resolution\n         // of <https://github.com/rust-lang/unsafe-code-guidelines/issues/71> before doing"}, {"sha": "d2d72a68f139676a3d9f20a988348a3b4c1ac7e9", "filename": "src/test/ui/lint/lint-strict-provenance-fuzzy-casts.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-fuzzy-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-fuzzy-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-fuzzy-casts.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,7 @@\n+#![feature(strict_provenance)]\n+#![deny(fuzzy_provenance_casts)]\n+\n+fn main() {\n+    let dangling = 16_usize as *const u8;\n+    //~^ ERROR strict provenance disallows casting integer `usize` to pointer `*const u8`\n+}"}, {"sha": "e50d243b6ad6db566de4cae586a49cb47d3261e2", "filename": "src/test/ui/lint/lint-strict-provenance-fuzzy-casts.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-fuzzy-casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-fuzzy-casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-fuzzy-casts.stderr?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,19 @@\n+error: strict provenance disallows casting integer `usize` to pointer `*const u8`\n+  --> $DIR/lint-strict-provenance-fuzzy-casts.rs:5:20\n+   |\n+LL |     let dangling = 16_usize as *const u8;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-strict-provenance-fuzzy-casts.rs:2:9\n+   |\n+LL | #![deny(fuzzy_provenance_casts)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = help: if you can't comply with strict provenance and don't have a pointer with the correct provenance you can use `std::ptr::from_exposed_addr()` instead\n+help: use `.with_addr()` to adjust a valid pointer in the same allocation, to this address\n+   |\n+LL |     let dangling = (...).with_addr(16_usize);\n+   |                    ~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "3690fbc904d9933927825de609ffba6f6c8b74ee", "filename": "src/test/ui/lint/lint-strict-provenance-lossy-casts.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,11 @@\n+#![feature(strict_provenance)]\n+#![deny(lossy_provenance_casts)]\n+\n+fn main() {\n+    let x: u8 = 37;\n+    let addr: usize = &x as *const u8 as usize;\n+    //~^ ERROR under strict provenance it is considered bad style to cast pointer `*const u8` to integer `usize`\n+\n+    let addr_32bit = &x as *const u8 as u32;\n+    //~^ ERROR under strict provenance it is considered bad style to cast pointer `*const u8` to integer `u32`\n+}"}, {"sha": "489cb03ddd316352b922a8420619a4f7cc7cf607", "filename": "src/test/ui/lint/lint-strict-provenance-lossy-casts.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-strict-provenance-lossy-casts.stderr?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,23 @@\n+error: under strict provenance it is considered bad style to cast pointer `*const u8` to integer `usize`\n+  --> $DIR/lint-strict-provenance-lossy-casts.rs:6:23\n+   |\n+LL |     let addr: usize = &x as *const u8 as usize;\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.addr()` to obtain the address of a pointer: `(&x as *const u8).addr()`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-strict-provenance-lossy-casts.rs:2:9\n+   |\n+LL | #![deny(lossy_provenance_casts)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = help: if you can't comply with strict provenance and need to expose the pointerprovenance you can use `.expose_addr()` instead\n+\n+error: under strict provenance it is considered bad style to cast pointer `*const u8` to integer `u32`\n+  --> $DIR/lint-strict-provenance-lossy-casts.rs:9:22\n+   |\n+LL |     let addr_32bit = &x as *const u8 as u32;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^ help: use `.addr()` to obtain the address of a pointer: `(&x as *const u8).addr() as u32`\n+   |\n+   = help: if you can't comply with strict provenance and need to expose the pointerprovenance you can use `.expose_addr()` instead\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b4fef11f1e29a0546d5f71a062de9d5998c79a69", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/required-feature.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -5,5 +5,40 @@ macro_rules! count {\n     };\n }\n \n+macro_rules! dollar_dollar {\n+    () => {\n+        macro_rules! bar {\n+            ( $$( $$any:tt )* ) => { $$( $$any )* };\n+            //~^ ERROR meta-variable expressions are unstable\n+            //~| ERROR meta-variable expressions are unstable\n+            //~| ERROR meta-variable expressions are unstable\n+            //~| ERROR meta-variable expressions are unstable\n+        }\n+    };\n+}\n+\n+macro_rules! index {\n+    ( $( $e:stmt ),* ) => {\n+        $( ${ignore(e)} ${index()} )*\n+        //~^ ERROR meta-variable expressions are unstable\n+        //~| ERROR meta-variable expressions are unstable\n+    };\n+}\n+\n+macro_rules! ignore {\n+    ( $( $i:stmt ),* ) => {{\n+        0 $( + 1 ${ignore(i)} )*\n+        //~^ ERROR meta-variable expressions are unstable\n+    }};\n+}\n+\n+macro_rules! length {\n+    ( $( $e:stmt ),* ) => {\n+        $( ${ignore(e)} ${length()} )*\n+        //~^ ERROR meta-variable expressions are unstable\n+        //~| ERROR meta-variable expressions are unstable\n+    };\n+}\n+\n fn main() {\n }"}, {"sha": "ecf598b104d058240ac7990f15e16725e1952ab8", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/required-feature.stderr", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.stderr?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -7,6 +7,87 @@ LL |         ${ count(e) }\n    = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n    = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:11:16\n+   |\n+LL |             ( $$( $$any:tt )* ) => { $$( $$any )* };\n+   |                ^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:11:20\n+   |\n+LL |             ( $$( $$any:tt )* ) => { $$( $$any )* };\n+   |                    ^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:11:39\n+   |\n+LL |             ( $$( $$any:tt )* ) => { $$( $$any )* };\n+   |                                       ^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:11:43\n+   |\n+LL |             ( $$( $$any:tt )* ) => { $$( $$any )* };\n+   |                                           ^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:22:13\n+   |\n+LL |         $( ${ignore(e)} ${index()} )*\n+   |             ^^^^^^^^^^^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:22:26\n+   |\n+LL |         $( ${ignore(e)} ${index()} )*\n+   |                          ^^^^^^^^^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:30:19\n+   |\n+LL |         0 $( + 1 ${ignore(i)} )*\n+   |                   ^^^^^^^^^^^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:37:13\n+   |\n+LL |         $( ${ignore(e)} ${length()} )*\n+   |             ^^^^^^^^^^^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:37:26\n+   |\n+LL |         $( ${ignore(e)} ${length()} )*\n+   |                          ^^^^^^^^^^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "7ed3796f08b764c755eccd9e61f33058aac5ec55", "filename": "src/test/ui/traits/no-fallback-multiple-impls.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ftraits%2Fno-fallback-multiple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ftraits%2Fno-fallback-multiple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fno-fallback-multiple-impls.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,16 @@\n+trait Fallback {\n+    fn foo(&self) {}\n+}\n+\n+impl Fallback for i32 {}\n+\n+impl Fallback for u64 {}\n+\n+impl Fallback for usize {}\n+\n+fn main() {\n+    missing();\n+    //~^ ERROR cannot find function `missing` in this scope\n+    0.foo();\n+    // But then we shouldn't report an inference ambiguity here...\n+}"}, {"sha": "61c9e5aaabdb458a77c90296000d4cffdd9cf30b", "filename": "src/test/ui/traits/no-fallback-multiple-impls.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ftraits%2Fno-fallback-multiple-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ftraits%2Fno-fallback-multiple-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fno-fallback-multiple-impls.stderr?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find function `missing` in this scope\n+  --> $DIR/no-fallback-multiple-impls.rs:12:5\n+   |\n+LL |     missing();\n+   |     ^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "342928e882a556e0e9a8958041284e945a14ee6a", "filename": "src/test/ui/traits/test-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ftraits%2Ftest-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ftraits%2Ftest-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftest-2.rs?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -6,9 +6,9 @@ impl bar for i32 { fn dup(&self) -> i32 { *self } fn blah<X>(&self) {} }\n impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n \n fn main() {\n-    10.dup::<i32>(); //~ ERROR type annotations needed\n+    10.dup::<i32>();\n     //~^ ERROR this associated function takes 0 generic arguments but 1\n-    10.blah::<i32, i32>(); //~ ERROR type annotations needed\n+    10.blah::<i32, i32>();\n     //~^ ERROR this associated function takes 1 generic argument but 2\n     (Box::new(10) as Box<dyn bar>).dup();\n     //~^ ERROR E0038"}, {"sha": "77ea4e4e974ebf06c36175f8cd48d50821840f0c", "filename": "src/test/ui/traits/test-2.stderr", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ftraits%2Ftest-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bb685e4714a2b310774f45c3d023d1743de8bd0/src%2Ftest%2Fui%2Ftraits%2Ftest-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftest-2.stderr?ref=4bb685e4714a2b310774f45c3d023d1743de8bd0", "patch": "@@ -79,35 +79,7 @@ LL | trait bar { fn dup(&self) -> Self; fn blah<X>(&self); }\n    = note: required because of the requirements on the impl of `CoerceUnsized<Box<dyn bar>>` for `Box<{integer}>`\n    = note: required by cast to type `Box<dyn bar>`\n \n-error[E0283]: type annotations needed\n-  --> $DIR/test-2.rs:9:8\n-   |\n-LL |     10.dup::<i32>();\n-   |        ^^^ cannot infer type for type `{integer}`\n-   |\n-note: multiple `impl`s satisfying `{integer}: bar` found\n-  --> $DIR/test-2.rs:5:1\n-   |\n-LL | impl bar for i32 { fn dup(&self) -> i32 { *self } fn blah<X>(&self) {} }\n-   | ^^^^^^^^^^^^^^^^\n-LL | impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n-   | ^^^^^^^^^^^^^^^^\n-\n-error[E0283]: type annotations needed\n-  --> $DIR/test-2.rs:11:8\n-   |\n-LL |     10.blah::<i32, i32>();\n-   |        ^^^^ cannot infer type for type `{integer}`\n-   |\n-note: multiple `impl`s satisfying `{integer}: bar` found\n-  --> $DIR/test-2.rs:5:1\n-   |\n-LL | impl bar for i32 { fn dup(&self) -> i32 { *self } fn blah<X>(&self) {} }\n-   | ^^^^^^^^^^^^^^^^\n-LL | impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n-   | ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0038, E0107, E0283.\n+Some errors have detailed explanations: E0038, E0107.\n For more information about an error, try `rustc --explain E0038`."}]}