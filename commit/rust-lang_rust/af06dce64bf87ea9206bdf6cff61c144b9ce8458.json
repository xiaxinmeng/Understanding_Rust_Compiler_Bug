{"sha": "af06dce64bf87ea9206bdf6cff61c144b9ce8458", "node_id": "C_kwDOAAsO6NoAKGFmMDZkY2U2NGJmODdlYTkyMDZiZGY2Y2ZmNjFjMTQ0YjljZTg0NTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-08T19:47:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-08T19:47:22Z"}, "message": "Auto merge of #106281 - JulianKnodt:transmute_const_generics, r=b-naber\n\nAdd ability to transmute (somewhat) with generic consts in arrays\n\nPreviously if the expression contained generic consts and did not have a directly equivalent type, transmuting the type in this way was forbidden, despite the two sizes being identical. Instead, we should be able to lazily tell if the two consts are identical, and if so allow them to be transmuted.\n\nThis is done by normalizing the forms of expressions into sorted order of multiplied terms, which is not generic over all expressions, but should handle most cases.\n\nThis allows for some _basic_ transmutations between types that are equivalent in size without requiring additional stack space at runtime.\n\nI only see one other location at which `SizeSkeleton` is being used, and it checks for equality so this shouldn't affect anywhere else that I can tell.\n\nSee [this Stackoverflow post](https://stackoverflow.com/questions/73085012/transmute-nested-const-generic-array-rust) for what was previously necessary to convert between types. This PR makes converting nested `T -> [T; 1]` transmutes possible, and `[uB*2; N] -> [uB; N * 2]` possible as well.\n\nI'm not sure whether this is something that would be wanted, and if it is it definitely should not be insta-stable, so I'd add a feature gate.", "tree": {"sha": "9a53a15bbe96897d7ca1bf62c6bd76386ee755d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a53a15bbe96897d7ca1bf62c6bd76386ee755d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af06dce64bf87ea9206bdf6cff61c144b9ce8458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af06dce64bf87ea9206bdf6cff61c144b9ce8458", "html_url": "https://github.com/rust-lang/rust/commit/af06dce64bf87ea9206bdf6cff61c144b9ce8458", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af06dce64bf87ea9206bdf6cff61c144b9ce8458/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd2b19539ea4d62a150cf13d45942e58b6b44e54", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd2b19539ea4d62a150cf13d45942e58b6b44e54", "html_url": "https://github.com/rust-lang/rust/commit/dd2b19539ea4d62a150cf13d45942e58b6b44e54"}, {"sha": "b76dd8c807c5ad32d2dac603937d6661b4685f59", "url": "https://api.github.com/repos/rust-lang/rust/commits/b76dd8c807c5ad32d2dac603937d6661b4685f59", "html_url": "https://github.com/rust-lang/rust/commit/b76dd8c807c5ad32d2dac603937d6661b4685f59"}], "stats": {"total": 450, "additions": 450, "deletions": 0}, "files": [{"sha": "426c6727adca56ed318735abb604054e2045306e", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -518,6 +518,8 @@ declare_features! (\n     /// Allows dyn upcasting trait objects via supertraits.\n     /// Dyn upcasting is casting, e.g., `dyn Foo -> dyn Bar` where `Foo: Bar`.\n     (active, trait_upcasting, \"1.56.0\", Some(65991), None),\n+    /// Allows for transmuting between arrays with sizes that contain generic consts.\n+    (active, transmute_generic_consts, \"CURRENT_RUSTC_VERSION\", Some(109929), None),\n     /// Allows #[repr(transparent)] on unions (RFC 2645).\n     (active, transparent_unions, \"1.37.0\", Some(60405), None),\n     /// Allows inconsistent bounds in where clauses."}, {"sha": "106f5bcd7558700d22667213cf8f78613b9197d2", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -84,6 +84,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let skeleton_string = |ty: Ty<'tcx>, sk| match sk {\n             Ok(SizeSkeleton::Known(size)) => format!(\"{} bits\", size.bits()),\n             Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{tail}`\"),\n+            Ok(SizeSkeleton::Generic(size)) => {\n+                if let Some(size) = size.try_eval_target_usize(tcx, self.param_env) {\n+                    format!(\"{size} bytes\")\n+                } else {\n+                    format!(\"generic size {size}\")\n+                }\n+            }\n             Err(LayoutError::Unknown(bad)) => {\n                 if bad == ty {\n                     \"this type does not have a fixed size\".to_owned()"}, {"sha": "2328a1324fc3c462446f15ecf9d4b90f092d58d8", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -281,6 +281,12 @@ pub enum SizeSkeleton<'tcx> {\n     /// Any statically computable Layout.\n     Known(Size),\n \n+    /// This is a generic const expression (i.e. N * 2), which may contain some parameters.\n+    /// It must be of type usize, and represents the size of a type in bytes.\n+    /// It is not required to be evaluatable to a concrete value, but can be used to check\n+    /// that another SizeSkeleton is of equal size.\n+    Generic(ty::Const<'tcx>),\n+\n     /// A potentially-fat pointer.\n     Pointer {\n         /// If true, this pointer is never null.\n@@ -326,6 +332,37 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                     ),\n                 }\n             }\n+            ty::Array(inner, len)\n+                if len.ty() == tcx.types.usize && tcx.features().transmute_generic_consts =>\n+            {\n+                match SizeSkeleton::compute(inner, tcx, param_env)? {\n+                    // This may succeed because the multiplication of two types may overflow\n+                    // but a single size of a nested array will not.\n+                    SizeSkeleton::Known(s) => {\n+                        if let Some(c) = len.try_eval_target_usize(tcx, param_env) {\n+                            let size = s\n+                                .bytes()\n+                                .checked_mul(c)\n+                                .ok_or_else(|| LayoutError::SizeOverflow(ty))?;\n+                            return Ok(SizeSkeleton::Known(Size::from_bytes(size)));\n+                        }\n+                        let len = tcx.expand_abstract_consts(len);\n+                        let prev = ty::Const::from_target_usize(tcx, s.bytes());\n+                        let Some(gen_size) = mul_sorted_consts(tcx, param_env, len, prev) else {\n+                            return Err(LayoutError::SizeOverflow(ty));\n+                        };\n+                        Ok(SizeSkeleton::Generic(gen_size))\n+                    }\n+                    SizeSkeleton::Pointer { .. } => Err(err),\n+                    SizeSkeleton::Generic(g) => {\n+                        let len = tcx.expand_abstract_consts(len);\n+                        let Some(gen_size) = mul_sorted_consts(tcx, param_env, len, g) else {\n+                            return Err(LayoutError::SizeOverflow(ty));\n+                        };\n+                        Ok(SizeSkeleton::Generic(gen_size))\n+                    }\n+                }\n+            }\n \n             ty::Adt(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n@@ -355,6 +392,9 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                                 }\n                                 ptr = Some(field);\n                             }\n+                            SizeSkeleton::Generic(_) => {\n+                                return Err(err);\n+                            }\n                         }\n                     }\n                     Ok(ptr)\n@@ -410,11 +450,66 @@ impl<'tcx> SizeSkeleton<'tcx> {\n             (SizeSkeleton::Pointer { tail: a, .. }, SizeSkeleton::Pointer { tail: b, .. }) => {\n                 a == b\n             }\n+            // constants are always pre-normalized into a canonical form so this\n+            // only needs to check if their pointers are identical.\n+            (SizeSkeleton::Generic(a), SizeSkeleton::Generic(b)) => a == b,\n             _ => false,\n         }\n     }\n }\n \n+/// When creating the layout for types with abstract conts in their size (i.e. [usize; 4 * N]),\n+/// to ensure that they have a canonical order and can be compared directly we combine all\n+/// constants, and sort the other terms. This allows comparison of expressions of sizes,\n+/// allowing for things like transmutating between types that depend on generic consts.\n+/// This returns `None` if multiplication of constants overflows.\n+fn mul_sorted_consts<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    a: ty::Const<'tcx>,\n+    b: ty::Const<'tcx>,\n+) -> Option<ty::Const<'tcx>> {\n+    use crate::mir::BinOp::Mul;\n+    use ty::ConstKind::Expr;\n+    use ty::Expr::Binop;\n+\n+    let mut work = vec![a, b];\n+    let mut done = vec![];\n+    while let Some(n) = work.pop() {\n+        if let Expr(Binop(Mul, l, r)) = n.kind() {\n+            work.push(l);\n+            work.push(r)\n+        } else {\n+            done.push(n);\n+        }\n+    }\n+    let mut k = 1;\n+    let mut overflow = false;\n+    done.retain(|c| {\n+        let Some(c) = c.try_eval_target_usize(tcx, param_env) else {\n+            return true;\n+        };\n+        let Some(next) = c.checked_mul(k) else {\n+            overflow = true;\n+            return false;\n+        };\n+        k = next;\n+        false\n+    });\n+    if overflow {\n+        return None;\n+    }\n+    if k != 1 {\n+        done.push(ty::Const::from_target_usize(tcx, k));\n+    } else if k == 0 {\n+        return Some(ty::Const::from_target_usize(tcx, 0));\n+    }\n+    done.sort_unstable();\n+\n+    // create a single tree from the buffer\n+    done.into_iter().reduce(|acc, n| tcx.mk_const(Expr(Binop(Mul, n, acc)), n.ty()))\n+}\n+\n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n }"}, {"sha": "7affad9aa0171fd85d4557205c9420b867d34275", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -1496,6 +1496,7 @@ symbols! {\n         trait_alias,\n         trait_upcasting,\n         transmute,\n+        transmute_generic_consts,\n         transmute_opts,\n         transmute_trait,\n         transparent,"}, {"sha": "d7bf1b47fb5a70686d4544744f1249e6e28a1801", "filename": "tests/ui/const-generics/transmute-fail.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute-fail.rs?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -0,0 +1,35 @@\n+#![feature(transmute_generic_consts)]\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn foo<const W: usize, const H: usize>(v: [[u32;H+1]; W]) -> [[u32; W+1]; H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn bar<const W: bool, const H: usize>(v: [[u32; H]; W]) -> [[u32; W]; H] {\n+  //~^ ERROR mismatched types\n+  //~| ERROR mismatched types\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute between types\n+  }\n+}\n+\n+fn baz<const W: usize, const H: usize>(v: [[u32; H]; W]) -> [u32; W * H * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn overflow(v: [[[u32; 8888888]; 9999999]; 777777777]) -> [[[u32; 9999999]; 777777777]; 8888888] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn main() {}"}, {"sha": "41b098135e81e0c2bb9f47b1b9c08e54e9366661", "filename": "tests/ui/const-generics/transmute-fail.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute-fail.stderr?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -0,0 +1,52 @@\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-fail.rs:7:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; H+1]; W]` (generic size [const expr])\n+   = note: target type: `[[u32; W+1]; H]` (generic size [const expr])\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-fail.rs:16:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; H]; W]` (this type does not have a fixed size)\n+   = note: target type: `[[u32; W]; H]` (size can vary because of [u32; W])\n+\n+error[E0308]: mismatched types\n+  --> $DIR/transmute-fail.rs:12:53\n+   |\n+LL | fn bar<const W: bool, const H: usize>(v: [[u32; H]; W]) -> [[u32; W]; H] {\n+   |                                                     ^ expected `usize`, found `bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/transmute-fail.rs:12:67\n+   |\n+LL | fn bar<const W: bool, const H: usize>(v: [[u32; H]; W]) -> [[u32; W]; H] {\n+   |                                                                   ^ expected `usize`, found `bool`\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-fail.rs:23:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; H]; W]` (generic size [const expr])\n+   = note: target type: `[u32; W * H * H]` (generic size [const expr])\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-fail.rs:30:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[[u32; 8888888]; 9999999]; 777777777]` (values of the type `[[[u32; 8888888]; 9999999]; 777777777]` are too big for the current architecture)\n+   = note: target type: `[[[u32; 9999999]; 777777777]; 8888888]` (values of the type `[[[u32; 9999999]; 777777777]; 8888888]` are too big for the current architecture)\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0308, E0512.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "30560a95b5e1638524c27fff19eb68920b4539eb", "filename": "tests/ui/const-generics/transmute.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute.rs?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -0,0 +1,83 @@\n+// run-pass\n+#![feature(generic_const_exprs)]\n+#![feature(transmute_generic_consts)]\n+#![allow(incomplete_features)]\n+\n+fn transpose<const W: usize, const H: usize>(v: [[u32;H]; W]) -> [[u32; W]; H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn ident<const W: usize, const H: usize>(v: [[u32; H]; W]) -> [[u32; H]; W] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn flatten<const W: usize, const H: usize>(v: [[u32; H]; W]) -> [u32; W * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn coagulate<const W: usize, const H: usize>(v: [u32; H*W]) -> [[u32; W];H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn flatten_3d<const W: usize, const H: usize, const D: usize>(\n+  v: [[[u32; D]; H]; W]\n+) -> [u32; D * W * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn flatten_somewhat<const W: usize, const H: usize, const D: usize>(\n+  v: [[[u32; D]; H]; W]\n+) -> [[u32; D * W]; H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn known_size<const L: usize>(v: [u16; L]) -> [u8; L * 2] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn condense_bytes<const L: usize>(v: [u8; L * 2]) -> [u16; L] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn singleton_each<const L: usize>(v: [u8; L]) -> [[u8;1]; L] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn transpose_with_const<const W: usize, const H: usize>(\n+  v: [[u32; 2 * H]; W + W]\n+) -> [[u32; W + W]; 2 * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn main() {\n+  let _ = transpose([[0; 8]; 16]);\n+  let _ = transpose_with_const::<8,4>([[0; 8]; 16]);\n+  let _ = ident([[0; 8]; 16]);\n+  let _ = flatten([[0; 13]; 5]);\n+  let _: [[_; 5]; 13] = coagulate([0; 65]);\n+  let _ = flatten_3d([[[0; 3]; 13]; 5]);\n+  let _ = flatten_somewhat([[[0; 3]; 13]; 5]);\n+  let _ = known_size([16; 13]);\n+  let _: [u16; 5] = condense_bytes([16u8; 10]);\n+  let _ = singleton_each([16; 10]);\n+}"}, {"sha": "e1ac44390a5f84532984d6ddbe7d16cc6d1f0d5e", "filename": "tests/ui/const-generics/transmute_no_gate.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute_no_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute_no_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute_no_gate.rs?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -0,0 +1,91 @@\n+// gate-test-transmute_generic_consts\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn transpose<const W: usize, const H: usize>(v: [[u32;H]; W]) -> [[u32; W]; H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn ident<const W: usize, const H: usize>(v: [[u32; H]; W]) -> [[u32; H]; W] {\n+  unsafe {\n+    std::mem::transmute(v)\n+  }\n+}\n+\n+fn flatten<const W: usize, const H: usize>(v: [[u32; H]; W]) -> [u32; W * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn coagulate<const W: usize, const H: usize>(v: [u32; H*W]) -> [[u32; W];H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn flatten_3d<const W: usize, const H: usize, const D: usize>(\n+  v: [[[u32; D]; H]; W]\n+) -> [u32; D * W * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn flatten_somewhat<const W: usize, const H: usize, const D: usize>(\n+  v: [[[u32; D]; H]; W]\n+) -> [[u32; D * W]; H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn known_size<const L: usize>(v: [u16; L]) -> [u8; L * 2] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn condense_bytes<const L: usize>(v: [u8; L * 2]) -> [u16; L] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn singleton_each<const L: usize>(v: [u8; L]) -> [[u8;1]; L] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn transpose_with_const<const W: usize, const H: usize>(\n+  v: [[u32; 2 * H]; W + W]\n+) -> [[u32; W + W]; 2 * H] {\n+  unsafe {\n+    std::mem::transmute(v)\n+    //~^ ERROR cannot transmute\n+  }\n+}\n+\n+fn main() {\n+  let _ = transpose([[0; 8]; 16]);\n+  let _ = transpose_with_const::<8,4>([[0; 8]; 16]);\n+  let _ = ident([[0; 8]; 16]);\n+  let _ = flatten([[0; 13]; 5]);\n+  let _: [[_; 5]; 13] = coagulate([0; 65]);\n+  let _ = flatten_3d([[[0; 3]; 13]; 5]);\n+  let _ = flatten_somewhat([[[0; 3]; 13]; 5]);\n+  let _ = known_size([16; 13]);\n+  let _: [u16; 5] = condense_bytes([16u8; 10]);\n+  let _ = singleton_each([16; 10]);\n+}"}, {"sha": "9c271b34849c0adf2287edeea4bbcef9cefa8657", "filename": "tests/ui/const-generics/transmute_no_gate.stderr", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute_no_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af06dce64bf87ea9206bdf6cff61c144b9ce8458/tests%2Fui%2Fconst-generics%2Ftransmute_no_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftransmute_no_gate.stderr?ref=af06dce64bf87ea9206bdf6cff61c144b9ce8458", "patch": "@@ -0,0 +1,84 @@\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:7:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; H]; W]` (this type does not have a fixed size)\n+   = note: target type: `[[u32; W]; H]` (this type does not have a fixed size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:20:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; H]; W]` (this type does not have a fixed size)\n+   = note: target type: `[u32; W * H]` (this type does not have a fixed size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:27:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[u32; H*W]` (this type does not have a fixed size)\n+   = note: target type: `[[u32; W]; H]` (this type does not have a fixed size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:36:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[[u32; D]; H]; W]` (this type does not have a fixed size)\n+   = note: target type: `[u32; D * W * H]` (this type does not have a fixed size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:45:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[[u32; D]; H]; W]` (this type does not have a fixed size)\n+   = note: target type: `[[u32; D * W]; H]` (this type does not have a fixed size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:52:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[u16; L]` (this type does not have a fixed size)\n+   = note: target type: `[u8; L * 2]` (this type does not have a fixed size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:59:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[u8; L * 2]` (this type does not have a fixed size)\n+   = note: target type: `[u16; L]` (this type does not have a fixed size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:66:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[u8; L]` (this type does not have a fixed size)\n+   = note: target type: `[[u8; 1]; L]` (this type does not have a fixed size)\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute_no_gate.rs:75:5\n+   |\n+LL |     std::mem::transmute(v)\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `[[u32; 2 * H]; W + W]` (this type does not have a fixed size)\n+   = note: target type: `[[u32; W + W]; 2 * H]` (this type does not have a fixed size)\n+\n+error: aborting due to 9 previous errors\n+\n+For more information about this error, try `rustc --explain E0512`."}]}