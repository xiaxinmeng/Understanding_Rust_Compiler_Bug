{"sha": "aa760a522588a15b7167f51296df8e1f87bbae50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNzYwYTUyMjU4OGExNWI3MTY3ZjUxMjk2ZGY4ZTFmODdiYmFlNTA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-16T09:38:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T07:06:28Z"}, "message": "finally remove all traces of signs from memory", "tree": {"sha": "cd75c09602e7bdd107efe234de6bfcb051ab9817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd75c09602e7bdd107efe234de6bfcb051ab9817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa760a522588a15b7167f51296df8e1f87bbae50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa760a522588a15b7167f51296df8e1f87bbae50", "html_url": "https://github.com/rust-lang/rust/commit/aa760a522588a15b7167f51296df8e1f87bbae50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa760a522588a15b7167f51296df8e1f87bbae50/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1df2ae82e6a2190ab2bfa330cb37e43ab0a727b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1df2ae82e6a2190ab2bfa330cb37e43ab0a727b", "html_url": "https://github.com/rust-lang/rust/commit/b1df2ae82e6a2190ab2bfa330cb37e43ab0a727b"}], "stats": {"total": 181, "additions": 93, "deletions": 88}, "files": [{"sha": "ca664c6e18b4d40095227fec643d61568b60e69e", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -567,25 +567,33 @@ pub fn write_target_uint(\n     }\n }\n \n-pub fn write_target_int(\n-    endianness: layout::Endian,\n-    mut target: &mut [u8],\n-    data: i128,\n-) -> Result<(), io::Error> {\n-    let len = target.len();\n-    match endianness {\n-        layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n-        layout::Endian::Big => target.write_int128::<BigEndian>(data, len),\n-    }\n-}\n-\n pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n     match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Methods to faciliate working with signed integers stored in a u128\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub fn sign_extend(value: u128, size: Size) -> u128 {\n+    let size = size.bits();\n+    // sign extend\n+    let shift = 128 - size;\n+    // shift the unsigned value to the left\n+    // and back to the right as signed (essentially fills with FF on the left)\n+    (((value << shift) as i128) >> shift) as u128\n+}\n+\n+pub fn truncate(value: u128, size: Size) -> u128 {\n+    let size = size.bits();\n+    let shift = 128 - size;\n+    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+    (value << shift) >> shift\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "e661da8792a9ec396df19a72f6e4a67ac36a4709", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -191,7 +191,7 @@ pub enum Scalar {\n     /// The raw bytes of a simple value.\n     Bits {\n         /// The first `size` bytes are the value.\n-        /// Do not try to read less or more bytes that that\n+        /// Do not try to read less or more bytes that that. The remaining bytes must be 0.\n         size: u8,\n         bits: u128,\n     },"}, {"sha": "16d6a08981abc9a562854510eb5877def5829262", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -16,10 +16,10 @@ mod check_match;\n pub use self::check_match::check_crate;\n pub(crate) use self::check_match::check_match;\n \n-use interpret::{const_field, const_variant_index, self};\n+use interpret::{const_field, const_variant_index};\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{Scalar, GlobalId, ConstValue};\n+use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -1086,8 +1086,8 @@ pub fn compare_const_vals<'a, 'tcx>(\n             ty::TyInt(_) => {\n                 let layout = tcx.layout_of(ty).ok()?;\n                 assert!(layout.abi.is_signed());\n-                let a = interpret::sign_extend(a, layout.size);\n-                let b = interpret::sign_extend(b, layout.size);\n+                let a = sign_extend(a, layout.size);\n+                let b = sign_extend(b, layout.size);\n                 Some((a as i128).cmp(&(b as i128)))\n             },\n             _ => Some(a.cmp(&b)),"}, {"sha": "b4d36afa0f80d7524566574083d913d8bbf4132a", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -1,9 +1,12 @@\n use rustc::ty::{self, Ty, TypeAndMut};\n-use rustc::ty::layout::{self, TyLayout};\n+use rustc::ty::layout::{self, TyLayout, Size};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n-use rustc::mir::interpret::{Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind};\n+use rustc::mir::interpret::{\n+    Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind,\n+    truncate, sign_extend\n+};\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n \n@@ -144,11 +147,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match val {\n             Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n             Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, src_layout.size.bytes());\n-                match src_layout.ty.sty {\n-                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_layout.ty),\n-                    _ => self.cast_from_int(bits, src_layout, dest_layout),\n+                debug_assert_eq!(size as u64, src_layout.size.bytes());\n+                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                    \"Unexpected value of size {} before casting\", size);\n+\n+                let res = match src_layout.ty.sty {\n+                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_layout.ty)?,\n+                    _ => self.cast_from_int(bits, src_layout, dest_layout)?,\n+                };\n+\n+                // Sanity check\n+                match res {\n+                    Scalar::Ptr(_) => bug!(\"Fabricated a ptr value from an int...?\"),\n+                    Scalar::Bits { bits, size } => {\n+                        debug_assert_eq!(size as u64, dest_layout.size.bytes());\n+                        debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                            \"Unexpected value of size {} after casting\", size);\n+                    }\n                 }\n+                // Done\n+                Ok(res)\n             }\n         }\n     }\n@@ -218,30 +236,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             // float -> uint\n             TyUint(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n-                match fty {\n-                    FloatTy::F32 => Ok(Scalar::Bits {\n-                        bits: Single::from_bits(bits).to_u128(width).value,\n-                        size: (width / 8) as u8,\n-                    }),\n-                    FloatTy::F64 => Ok(Scalar::Bits {\n-                        bits: Double::from_bits(bits).to_u128(width).value,\n-                        size: (width / 8) as u8,\n-                    }),\n-                }\n+                let v = match fty {\n+                    FloatTy::F32 => Single::from_bits(bits).to_u128(width).value,\n+                    FloatTy::F64 => Double::from_bits(bits).to_u128(width).value,\n+                };\n+                // This should already fit the bit width\n+                Ok(Scalar::Bits {\n+                    bits: v,\n+                    size: (width / 8) as u8,\n+                })\n             },\n             // float -> int\n             TyInt(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n-                match fty {\n-                    FloatTy::F32 => Ok(Scalar::Bits {\n-                        bits: Single::from_bits(bits).to_i128(width).value as u128,\n-                        size: (width / 8) as u8,\n-                    }),\n-                    FloatTy::F64 => Ok(Scalar::Bits {\n-                        bits: Double::from_bits(bits).to_i128(width).value as u128,\n-                        size: (width / 8) as u8,\n-                    }),\n-                }\n+                let v = match fty {\n+                    FloatTy::F32 => Single::from_bits(bits).to_i128(width).value,\n+                    FloatTy::F64 => Double::from_bits(bits).to_i128(width).value,\n+                };\n+                // We got an i128, but we may need something smaller. We have to truncate ourselves.\n+                let truncated = truncate(v as u128, Size::from_bits(width as u64));\n+                assert_eq!(sign_extend(truncated, Size::from_bits(width as u64)) as i128, v,\n+                    \"truncating and extending changed the value?!?\");\n+                Ok(Scalar::Bits {\n+                    bits: truncated,\n+                    size: (width / 8) as u8,\n+                })\n             },\n             // f64 -> f32\n             TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {"}, {"sha": "539428b9e517e4679c58068eda1d553aed687c44", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -18,6 +18,7 @@ use rustc::mir::interpret::{\n     GlobalId, Scalar, FrameInfo, AllocType,\n     EvalResult, EvalErrorKind,\n     ScalarMaybeUndef,\n+    truncate, sign_extend,\n };\n \n use syntax::source_map::{self, Span};\n@@ -906,10 +907,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n+    #[inline(always)]\n     pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n+    #[inline(always)]\n     pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n@@ -1028,13 +1031,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         (frames, self.tcx.span)\n     }\n \n+    #[inline(always)]\n     pub fn sign_extend(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n         assert!(ty.abi.is_signed());\n-        super::sign_extend(value, ty.size)\n+        sign_extend(value, ty.size)\n     }\n \n+    #[inline(always)]\n     pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n-        super::truncate(value, ty.size)\n+        truncate(value, ty.size)\n     }\n \n     fn dump_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n@@ -1105,18 +1110,3 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n }\n \n-pub fn sign_extend(value: u128, size: Size) -> u128 {\n-    let size = size.bits();\n-    // sign extend\n-    let shift = 128 - size;\n-    // shift the unsigned value to the left\n-    // and back to the right as signed (essentially fills with FF on the left)\n-    (((value << shift) as i128) >> shift) as u128\n-}\n-\n-pub fn truncate(value: u128, size: Size) -> u128 {\n-    let size = size.bits();\n-    let shift = 128 - size;\n-    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n-    (value << shift) >> shift\n-}"}, {"sha": "72bd32efe7bff839032d1ef455023f490c85c709", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -8,8 +8,8 @@ use rustc::ty::ParamEnv;\n use rustc::ty::query::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, ScalarMaybeUndef,\n-                            EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n-pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n+                            EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType, truncate};\n+pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n use syntax::ast::Mutability;\n@@ -791,7 +791,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         val: ScalarMaybeUndef,\n         type_size: Size,\n         type_align: Align,\n-        signed: bool,\n     ) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n         self.check_align(ptr, ptr_align)?;\n@@ -815,6 +814,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, type_size.bytes());\n+                assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                    \"Unexpected value of size {} when writing to memory\", size);\n                 bits\n             },\n         };\n@@ -823,12 +824,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         {\n             let dst = self.get_bytes_mut(ptr, type_size, ptr_align.min(type_align))?;\n-            // TODO: Why do we still need `signed` here? We do NOT have it for loading!\n-            if signed {\n-                write_target_int(endianness, dst, bytes as i128).unwrap();\n-            } else {\n-                write_target_uint(endianness, dst, bytes).unwrap();\n-            }\n+            write_target_uint(endianness, dst, bytes).unwrap();\n         }\n \n         // See if we have to also write a relocation\n@@ -845,9 +841,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized_unsigned(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n-        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, ptr_align, false)\n+        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, ptr_align)\n     }\n \n     fn int_align(&self, size: Size) -> Align {"}, {"sha": "167fb5d184cfcc361214787ae91256e9fb4be46a", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -13,8 +13,7 @@ mod traits;\n mod const_eval;\n \n pub use self::eval_context::{\n-    EvalContext, Frame, StackPopCleanup,\n-    sign_extend, truncate, LocalValue,\n+    EvalContext, Frame, StackPopCleanup, LocalValue,\n };\n \n pub use self::place::{Place, PlaceExtra, PlaceTy, MemPlace, MPlaceTy};"}, {"sha": "8b8c050acb7b31c5e9e2d65f5c1e423061db0ef5", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -551,15 +551,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // correct if we never look at this data with the wrong type.\n         match value {\n             Value::Scalar(scalar) => {\n-                let signed = match dest.layout.abi {\n-                    layout::Abi::Scalar(ref scal) => match scal.value {\n-                        layout::Primitive::Int(_, signed) => signed,\n-                        _ => false,\n-                    },\n-                    _ => false,\n-                };\n                 self.memory.write_scalar(\n-                    dest.ptr, dest.align, scalar, dest.layout.size, dest.layout.align, signed\n+                    dest.ptr, dest.align, scalar, dest.layout.size, dest.layout.align\n                 )\n             }\n             Value::ScalarPair(a_val, b_val) => {\n@@ -572,9 +565,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let a_ptr = dest.ptr;\n                 let b_offset = a_size.abi_align(b_align);\n                 let b_ptr = a_ptr.ptr_offset(b_offset, &self)?.into();\n-                // TODO: What about signedess?\n-                self.memory.write_scalar(a_ptr, dest.align, a_val, a_size, a_align, false)?;\n-                self.memory.write_scalar(b_ptr, dest.align, b_val, b_size, b_align, false)\n+\n+                self.memory.write_scalar(a_ptr, dest.align, a_val, a_size, a_align)?;\n+                self.memory.write_scalar(b_ptr, dest.align, b_val, b_size, b_align)\n             }\n         }\n     }"}, {"sha": "18718cc3dcd6e396b7eef38501d700a0b867df29", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa760a522588a15b7167f51296df8e1f87bbae50/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=aa760a522588a15b7167f51296df8e1f87bbae50", "patch": "@@ -36,15 +36,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n+        self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n+        self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::Bits {\n             bits: size as u128,\n             size: ptr_size.bytes() as u8,\n         }.into())?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n+        self.memory.write_ptr_sized(align_ptr, ptr_align, Scalar::Bits {\n             bits: align as u128,\n             size: ptr_size.bytes() as u8,\n         }.into())?;\n@@ -54,7 +54,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n+                self.memory.write_ptr_sized(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }\n "}]}