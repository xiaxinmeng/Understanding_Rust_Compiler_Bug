{"sha": "41706ff12b39e5efaf97f6a0b6163bc521815cb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNzA2ZmYxMmIzOWU1ZWZhZjk3ZjZhMGI2MTYzYmM1MjE4MTVjYjc=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-01T08:13:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-01T08:13:00Z"}, "message": "Rollup merge of #54641 - ljedrz:cleanup_rustc_infer, r=estebank\n\nA few cleanups and minor improvements to rustc/infer\n\n- use unwrap_or(_else) where applicable\n- convert single-branch matches to if-let\n- use to_owned instead of to_string with string literals\n- improve vector allocations\n- readability improvements\n- miscellaneous minor code improvements", "tree": {"sha": "00922776a31f128e6a272b3cc2f1f532dba717a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00922776a31f128e6a272b3cc2f1f532dba717a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41706ff12b39e5efaf97f6a0b6163bc521815cb7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbsdcMCRBK7hj4Ov3rIwAAdHIIABo7+gHJmRiY8O17K6giLqHy\n8avi1xzez+fN3ELIYyM8XMAnWDIb2bijisEDJBgoCsZ1H0nsZyF8TAwm3lCi+Uww\nk8UlpIna0Hs4xciTe/o9ZcNhbvsorJcB4KARaLOsiNcseflHtcIvCjvFBXclvzEk\n1XulYxyS1jH8HY00pijdVUMTt4mCJjGesI4ABHQhST+SxuxfdxcGzOHlp2UPEGl5\nads8vlEekViq8rARhsdML9FA59Kfo/EPK5f20L7L1v+WcPx0/CB7DeVgynMghoiS\nuM5ckf69mmXSsdnJ1UOR99hsLbQtlpUynr7HvZ3joVc4NzYvdQYGbTb6mxlKCtc=\n=+2rW\n-----END PGP SIGNATURE-----\n", "payload": "tree 00922776a31f128e6a272b3cc2f1f532dba717a3\nparent 5bfd085cd28095ae2549f286fd856c3e6bd5c1b0\nparent 52da88639e515dabe4927706025adf976d9cd2b7\nauthor kennytm <kennytm@gmail.com> 1538381580 +0800\ncommitter GitHub <noreply@github.com> 1538381580 +0800\n\nRollup merge of #54641 - ljedrz:cleanup_rustc_infer, r=estebank\n\nA few cleanups and minor improvements to rustc/infer\n\n- use unwrap_or(_else) where applicable\n- convert single-branch matches to if-let\n- use to_owned instead of to_string with string literals\n- improve vector allocations\n- readability improvements\n- miscellaneous minor code improvements\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41706ff12b39e5efaf97f6a0b6163bc521815cb7", "html_url": "https://github.com/rust-lang/rust/commit/41706ff12b39e5efaf97f6a0b6163bc521815cb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41706ff12b39e5efaf97f6a0b6163bc521815cb7/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bfd085cd28095ae2549f286fd856c3e6bd5c1b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bfd085cd28095ae2549f286fd856c3e6bd5c1b0", "html_url": "https://github.com/rust-lang/rust/commit/5bfd085cd28095ae2549f286fd856c3e6bd5c1b0"}, {"sha": "52da88639e515dabe4927706025adf976d9cd2b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/52da88639e515dabe4927706025adf976d9cd2b7", "html_url": "https://github.com/rust-lang/rust/commit/52da88639e515dabe4927706025adf976d9cd2b7"}], "stats": {"total": 370, "additions": 170, "deletions": 200}, "files": [{"sha": "a327f1f5c9d50b462a5e1319da2eb57ac9d879cf", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 56, "deletions": 64, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -135,10 +135,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         // Select everything, returning errors.\n-        let true_errors = match fulfill_cx.select_where_possible(self) {\n-            Ok(()) => vec![],\n-            Err(errors) => errors,\n-        };\n+        let true_errors = fulfill_cx.select_where_possible(self).err().unwrap_or_else(Vec::new);\n         debug!(\"true_errors = {:#?}\", true_errors);\n \n         if !true_errors.is_empty() {\n@@ -148,10 +145,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // Anything left unselected *now* must be an ambiguity.\n-        let ambig_errors = match fulfill_cx.select_all_or_error(self) {\n-            Ok(()) => vec![],\n-            Err(errors) => errors,\n-        };\n+        let ambig_errors = fulfill_cx.select_all_or_error(self).err().unwrap_or_else(Vec::new);\n         debug!(\"ambig_errors = {:#?}\", ambig_errors);\n \n         let region_obligations = self.take_registered_region_obligations();\n@@ -316,16 +310,18 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // ...also include the other query region constraints from the query.\n-        output_query_region_constraints.reserve(query_result.value.region_constraints.len());\n-        for r_c in query_result.value.region_constraints.iter() {\n-            let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n-            let k1 = substitute_value(self.tcx, &result_subst, &k1);\n-            let r2 = substitute_value(self.tcx, &result_subst, &r2);\n-            if k1 != r2.into() {\n-                output_query_region_constraints\n-                    .push(ty::Binder::bind(ty::OutlivesPredicate(k1, r2)));\n-            }\n-        }\n+        output_query_region_constraints.extend(\n+            query_result.value.region_constraints.iter().filter_map(|r_c| {\n+                let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n+                let k1 = substitute_value(self.tcx, &result_subst, &k1);\n+                let r2 = substitute_value(self.tcx, &result_subst, &r2);\n+                if k1 != r2.into() {\n+                    Some(ty::Binder::bind(ty::OutlivesPredicate(k1, r2)))\n+                } else {\n+                    None\n+                }\n+            })\n+        );\n \n         let user_result: R =\n             query_result.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n@@ -448,10 +444,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 .variables\n                 .iter()\n                 .enumerate()\n-                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n-                    Some(k) => k,\n-                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n-                })\n+                .map(|(index, info)| opt_values[CanonicalVar::new(index)].unwrap_or_else(||\n+                    self.fresh_inference_var_for_canonical_var(cause.span, *info)\n+                ))\n                 .collect(),\n         };\n \n@@ -504,24 +499,22 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n                     let k1 = substitute_value(self.tcx, result_subst, k1);\n                     let r2 = substitute_value(self.tcx, result_subst, r2);\n-                    match k1.unpack() {\n-                        UnpackedKind::Lifetime(r1) => Obligation::new(\n-                            cause.clone(),\n-                            param_env,\n-                            ty::Predicate::RegionOutlives(ty::Binder::dummy(\n-                                ty::OutlivesPredicate(r1, r2),\n+\n+                    Obligation::new(\n+                        cause.clone(),\n+                        param_env,\n+                        match k1.unpack() {\n+                            UnpackedKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n+                                ty::Binder::dummy(\n+                                    ty::OutlivesPredicate(r1, r2)\n                             )),\n-                        ),\n-\n-                        UnpackedKind::Type(t1) => Obligation::new(\n-                            cause.clone(),\n-                            param_env,\n-                            ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n-                                t1, r2,\n-                            ))),\n-                        ),\n-                    }\n-                }),\n+                            UnpackedKind::Type(t1) => ty::Predicate::TypeOutlives(\n+                                ty::Binder::dummy(ty::OutlivesPredicate(\n+                                    t1, r2\n+                            )))\n+                        }\n+                    )\n+                })\n         ) as Box<dyn Iterator<Item = _>>\n     }\n \n@@ -583,31 +576,30 @@ pub fn make_query_outlives<'tcx>(\n     assert!(verifys.is_empty());\n     assert!(givens.is_empty());\n \n-    let mut outlives: Vec<_> = constraints\n-            .into_iter()\n-            .map(|(k, _)| match *k {\n-                // Swap regions because we are going from sub (<=) to outlives\n-                // (>=).\n-                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                    tcx.mk_region(ty::ReVar(v2)).into(),\n-                    tcx.mk_region(ty::ReVar(v1)),\n-                ),\n-                Constraint::VarSubReg(v1, r2) => {\n-                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-                }\n-                Constraint::RegSubVar(r1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-                }\n-                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n-            })\n-            .map(ty::Binder::dummy) // no bound regions in the code above\n-            .collect();\n-\n-    outlives.extend(\n-        outlives_obligations\n-            .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n-            .map(ty::Binder::dummy), // no bound regions in the code above\n-    );\n+    let outlives: Vec<_> = constraints\n+        .into_iter()\n+        .map(|(k, _)| match *k {\n+            // Swap regions because we are going from sub (<=) to outlives\n+            // (>=).\n+            Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                tcx.mk_region(ty::ReVar(v2)).into(),\n+                tcx.mk_region(ty::ReVar(v1)),\n+            ),\n+            Constraint::VarSubReg(v1, r2) => {\n+                ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+            }\n+            Constraint::RegSubVar(r1, v2) => {\n+                ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+            }\n+            Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+        })\n+        .map(ty::Binder::dummy) // no bound regions in the code above\n+        .chain(\n+            outlives_obligations\n+                .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n+                .map(ty::Binder::dummy), // no bound regions in the code above\n+        )\n+        .collect();\n \n     outlives\n }"}, {"sha": "854960492c9bd4c897e3f357747a3c1dcdbbecf5", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -77,24 +77,22 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         match (&a.sty, &b.sty) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().equate(a_id, b_id);\n-                Ok(a)\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {\n                 self.fields.instantiate(b, RelationDir::EqTo, a_id, self.a_is_expected)?;\n-                Ok(a)\n             }\n \n             (_, &ty::Infer(TyVar(b_id))) => {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n-                Ok(a)\n             }\n \n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n-                Ok(a)\n             }\n         }\n+\n+        Ok(a)\n     }\n \n     fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)"}, {"sha": "a68241ff2c0201c761894a3736e9d4c72aa44f2d", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -406,10 +406,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             errors.clone()\n         } else {\n             errors\n-                .iter()\n-                .filter(|&e| !is_bound_failure(e))\n-                .cloned()\n-                .collect()\n+            .iter()\n+            .filter(|&e| !is_bound_failure(e))\n+            .cloned()\n+            .collect()\n         };\n \n         // sort the errors by span, for better error message stability.\n@@ -455,11 +455,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             TypeError::Sorts(ref exp_found) => {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n-                match (&exp_found.expected.sty, &exp_found.found.sty) {\n-                    (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _)) => {\n-                        report_path_match(err, exp_adt.did, found_adt.did);\n-                    }\n-                    _ => (),\n+                if let (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _))\n+                     = (&exp_found.expected.sty, &exp_found.found.sty)\n+                {\n+                    report_path_match(err, exp_adt.did, found_adt.did);\n                 }\n             }\n             TypeError::Traits(ref exp_found) => {"}, {"sha": "efb316243fad036933d94c2cee3436074323fb9f", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut labels = vec![(\n             span,\n             if &name == \"_\" {\n-                \"cannot infer type\".to_string()\n+                \"cannot infer type\".to_owned()\n             } else {\n                 format!(\"cannot infer type for `{}`\", name)\n             },\n@@ -138,20 +138,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // ```\n             labels.clear();\n             labels.push(\n-                (pattern.span, \"consider giving this closure parameter a type\".to_string()));\n+                (pattern.span, \"consider giving this closure parameter a type\".to_owned()));\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n             if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.compiler_desugaring_kind() {\n                     None => labels.push((pattern.span,\n                                          format!(\"consider giving `{}` a type\", simple_ident))),\n                     Some(CompilerDesugaringKind::ForLoop) => labels.push((\n                         pattern.span,\n-                        \"the element type for this iterator is not specified\".to_string(),\n+                        \"the element type for this iterator is not specified\".to_owned(),\n                     )),\n                     _ => {}\n                 }\n             } else {\n-                labels.push((pattern.span, \"consider giving the pattern a type\".to_string()));\n+                labels.push((pattern.span, \"consider giving the pattern a type\".to_owned()));\n             }\n         }\n "}, {"sha": "1f84c73a715833fae46ac4cd09fea46b17f8bd1b", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -113,12 +113,12 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             (None, None) => {\n                 let (main_label_1, span_label_1) = if ty_sup.id == ty_sub.id {\n                     (\n-                        \"this type is declared with multiple lifetimes...\".to_string(),\n-                        \"...but data with one lifetime flows into the other here\".to_string()\n+                        \"this type is declared with multiple lifetimes...\".to_owned(),\n+                        \"...but data with one lifetime flows into the other here\".to_owned()\n                     )\n                 } else {\n                     (\n-                        \"these two types are declared with different lifetimes...\".to_string(),\n+                        \"these two types are declared with different lifetimes...\".to_owned(),\n                         format!(\n                             \"...but data{} flows{} here\",\n                             span_label_var1,\n@@ -133,15 +133,15 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 ty_sub.span,\n                 ret_span,\n                 \"this parameter and the return type are declared \\\n-                 with different lifetimes...\".to_string()\n+                 with different lifetimes...\".to_owned()\n                 ,\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),\n             (_, Some(ret_span)) => (\n                 ty_sup.span,\n                 ret_span,\n                 \"this parameter and the return type are declared \\\n-                 with different lifetimes...\".to_string()\n+                 with different lifetimes...\".to_owned()\n                 ,\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),"}, {"sha": "009a823568131fb6b007e44aabd6b58c2ecce3cd", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -58,18 +58,17 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                     &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n                 let hir = &self.tcx.hir;\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n-                    match hir.get(node_id) {\n-                        Node::Expr(Expr {\n-                            node: Closure(_, _, _, closure_span, None),\n-                            ..\n-                        }) => {\n-                            let sup_sp = sup_origin.span();\n-                            let origin_sp = origin.span();\n-                            let mut err = self.tcx.sess.struct_span_err(\n-                                sup_sp,\n-                                \"borrowed data cannot be stored outside of its closure\");\n-                            err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n-                            if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n+                    if let Node::Expr(Expr {\n+                        node: Closure(_, _, _, closure_span, None),\n+                        ..\n+                    }) = hir.get(node_id) {\n+                        let sup_sp = sup_origin.span();\n+                        let origin_sp = origin.span();\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            sup_sp,\n+                            \"borrowed data cannot be stored outside of its closure\");\n+                        err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n+                        if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n // // sup_sp == origin.span():\n //\n // let mut x = None;\n@@ -87,11 +86,11 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n //                         ------------ ... because it cannot outlive this closure\n //     f = Some(x);\n //              ^ cannot be stored outside of its closure\n-                                err.span_label(*external_span,\n-                                               \"borrowed data cannot be stored into here...\");\n-                                err.span_label(*closure_span,\n-                                               \"...because it cannot outlive this closure\");\n-                            } else {\n+                            err.span_label(*external_span,\n+                                           \"borrowed data cannot be stored into here...\");\n+                            err.span_label(*closure_span,\n+                                           \"...because it cannot outlive this closure\");\n+                        } else {\n // FIXME: the wording for this case could be much improved\n //\n // let mut lines_to_use: Vec<&CrateId> = Vec::new();\n@@ -102,18 +101,16 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n //     ...so that variable is valid at time of its declaration\n //     lines_to_use.push(installed_id);\n //                       ^^^^^^^^^^^^ cannot be stored outside of its closure\n-                                err.span_label(origin_sp,\n-                                               \"cannot infer an appropriate lifetime...\");\n-                                err.span_label(*external_span,\n-                                               \"...so that variable is valid at time of its \\\n-                                                declaration\");\n-                                err.span_label(*closure_span,\n-                                               \"borrowed data cannot outlive this closure\");\n-                            }\n-                            err.emit();\n-                            return Some(ErrorReported);\n+                            err.span_label(origin_sp,\n+                                           \"cannot infer an appropriate lifetime...\");\n+                            err.span_label(*external_span,\n+                                           \"...so that variable is valid at time of its \\\n+                                            declaration\");\n+                            err.span_label(*closure_span,\n+                                           \"borrowed data cannot outlive this closure\");\n                         }\n-                        _ => {}\n+                        err.emit();\n+                        return Some(ErrorReported);\n                     }\n                 }\n             }"}, {"sha": "766173bf66283d4118d8250137a5e19daaf04381", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -20,64 +20,62 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         if let Some(ref error) = self.error {\n-            match error.clone() {\n-                RegionResolutionError::SubSupConflict(\n+            if let RegionResolutionError::SubSupConflict(\n                     var_origin,\n                     sub_origin,\n                     sub_r,\n                     sup_origin,\n                     sup_r,\n-                ) => {\n-                    let anon_reg_sup = self.tcx.is_suitable_region(sup_r)?;\n-                    if sub_r == &RegionKind::ReStatic &&\n-                        self.tcx.return_type_impl_trait(anon_reg_sup.def_id).is_some()\n-                    {\n-                        let sp = var_origin.span();\n-                        let return_sp = sub_origin.span();\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            sp,\n-                            \"cannot infer an appropriate lifetime\",\n+                ) = error.clone()\n+            {\n+                let anon_reg_sup = self.tcx.is_suitable_region(sup_r)?;\n+                if sub_r == &RegionKind::ReStatic &&\n+                    self.tcx.return_type_impl_trait(anon_reg_sup.def_id).is_some()\n+                {\n+                    let sp = var_origin.span();\n+                    let return_sp = sub_origin.span();\n+                    let mut err = self.tcx.sess.struct_span_err(\n+                        sp,\n+                        \"cannot infer an appropriate lifetime\",\n+                    );\n+                    err.span_label(\n+                        return_sp,\n+                        \"this return type evaluates to the `'static` lifetime...\",\n+                    );\n+                    err.span_label(\n+                        sup_origin.span(),\n+                        \"...but this borrow...\",\n+                    );\n+\n+                    let (lifetime, lt_sp_opt) = self.tcx.msg_span_from_free_region(sup_r);\n+                    if let Some(lifetime_sp) = lt_sp_opt {\n+                        err.span_note(\n+                            lifetime_sp,\n+                            &format!(\"...can't outlive {}\", lifetime),\n                         );\n-                        err.span_label(\n+                    }\n+\n+                    let lifetime_name = match sup_r {\n+                        RegionKind::ReFree(FreeRegion {\n+                            bound_region: BoundRegion::BrNamed(_, ref name), ..\n+                        }) => name.to_string(),\n+                        _ => \"'_\".to_owned(),\n+                    };\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n+                        err.span_suggestion_with_applicability(\n                             return_sp,\n-                            \"this return type evaluates to the `'static` lifetime...\",\n+                            &format!(\n+                                \"you can add a constraint to the return type to make it last \\\n+                                 less than `'static` and match {}\",\n+                                lifetime,\n+                            ),\n+                            format!(\"{} + {}\", snippet, lifetime_name),\n+                            Applicability::Unspecified,\n                         );\n-                        err.span_label(\n-                            sup_origin.span(),\n-                            \"...but this borrow...\",\n-                        );\n-\n-                        let (lifetime, lt_sp_opt) = self.tcx.msg_span_from_free_region(sup_r);\n-                        if let Some(lifetime_sp) = lt_sp_opt {\n-                            err.span_note(\n-                                lifetime_sp,\n-                                &format!(\"...can't outlive {}\", lifetime),\n-                            );\n-                        }\n-\n-                        let lifetime_name = match sup_r {\n-                            RegionKind::ReFree(FreeRegion {\n-                                bound_region: BoundRegion::BrNamed(_, ref name), ..\n-                            }) => name.to_string(),\n-                            _ => \"'_\".to_owned(),\n-                        };\n-                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n-                            err.span_suggestion_with_applicability(\n-                                return_sp,\n-                                &format!(\n-                                    \"you can add a constraint to the return type to make it last \\\n-                                     less than `'static` and match {}\",\n-                                    lifetime,\n-                                ),\n-                                format!(\"{} + {}\", snippet, lifetime_name),\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n-                        err.emit();\n-                        return Some(ErrorReported);\n                     }\n+                    err.emit();\n+                    return Some(ErrorReported);\n                 }\n-                _ => {}\n             }\n         }\n         None"}, {"sha": "013c02f75b88315f1a7f776d2ed8d70c93e4522d", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -119,16 +119,13 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         decl: &hir::FnDecl,\n     ) -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n-        match ret_ty.sty {\n-            ty::FnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(self.tcx);\n-                let late_bound_regions = self.tcx\n-                    .collect_referenced_late_bound_regions(&sig.output());\n-                if late_bound_regions.iter().any(|r| *r == br) {\n-                    return Some(decl.output.span());\n-                }\n+        if let ty::FnDef(_, _) = ret_ty.sty {\n+            let sig = ret_ty.fn_sig(self.tcx);\n+            let late_bound_regions = self.tcx\n+                .collect_referenced_late_bound_regions(&sig.output());\n+            if late_bound_regions.iter().any(|r| *r == br) {\n+                return Some(decl.output.span());\n             }\n-            _ => {}\n         }\n         None\n     }\n@@ -140,8 +137,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n         is_first\n             && self.tcx\n-                .opt_associated_item(scope_def_id)\n-                .map(|i| i.method_has_self_argument) == Some(true)\n+                   .opt_associated_item(scope_def_id)\n+                   .map(|i| i.method_has_self_argument) == Some(true)\n     }\n \n }"}, {"sha": "b55727d2c84f0902a5d8f266d783c6d77314400e", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -112,12 +112,9 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         }\n     };\n \n-    match dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n-        Ok(()) => {}\n-        Err(e) => {\n-            let msg = format!(\"io error dumping region constraints: {}\", e);\n-            tcx.sess.err(&msg)\n-        }\n+    if let Err(e) = dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n+        let msg = format!(\"io error dumping region constraints: {}\", e);\n+        tcx.sess.err(&msg)\n     }\n }\n \n@@ -187,12 +184,9 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n             None => bug!(\"no node_id found for node: {:?}\", n),\n         };\n         let name = || format!(\"node_{}\", node_id);\n-        match dot::Id::new(name()) {\n-            Ok(id) => id,\n-            Err(_) => {\n-                bug!(\"failed to create graphviz node identified by {}\", name());\n-            }\n-        }\n+\n+        dot::Id::new(name()).unwrap_or_else(|_|\n+            bug!(\"failed to create graphviz node identified by {}\", name()))\n     }\n     fn node_label(&self, n: &Node) -> dot::LabelText<'_> {\n         match *n {\n@@ -204,7 +198,7 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n         match *e {\n             Edge::Constraint(ref c) =>\n                 dot::LabelText::label(format!(\"{:?}\", self.map.get(c).unwrap())),\n-            Edge::EnclScope(..) => dot::LabelText::label(\"(enclosed)\".to_string()),\n+            Edge::EnclScope(..) => dot::LabelText::label(\"(enclosed)\".to_owned()),\n         }\n     }\n }"}, {"sha": "ca49d053210c7c0026ada442afc0ca14f55bed34", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -147,9 +147,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.types.re_static,\n-            values: (0..self.num_vars())\n-                .map(|_| VarValue::Value(tcx.types.re_empty))\n-                .collect(),\n+            values: IndexVec::from_elem_n(VarValue::Value(tcx.types.re_empty), self.num_vars())\n         }\n     }\n "}, {"sha": "49858972416d8f1c025b18e4fbd256d9a47bf87a", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -803,6 +803,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         );\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n+        self.obligations.reserve(bounds.predicates.len());\n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,\n             // which will be the concrete type instead of the opaque type."}, {"sha": "87bfbaef54c4e7748bf3cb6dee249b4fcf2b3ea2", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -443,7 +443,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n \n         if snapshot.length == 0 {\n-            self.undo_log.truncate(0);\n+            self.undo_log.clear();\n         } else {\n             (*self.undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n@@ -661,11 +661,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         debug!(\"RegionConstraintCollector: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n-        match verify.bound {\n-            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => {\n+        if let VerifyBound::AllBounds(ref bs) = verify.bound {\n+            if bs.len() == 0 {\n                 return;\n             }\n-            _ => {}\n         }\n \n         let index = self.data.verifys.len();"}, {"sha": "0ef97618572640f4ac5e1003963d1a3e56c7971b", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -153,8 +153,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !t.needs_infer() && !ty::keep_local(&t) {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n-                // ^ we need to have the `keep_local` check to un-default\n-                // defaulted tuples.\n+              // ^ we need to have the `keep_local` check to un-default\n+              // defaulted tuples.\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match t.sty {"}, {"sha": "970b6e096ffe4d04370e482d43e079e29daa214e", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41706ff12b39e5efaf97f6a0b6163bc521815cb7/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=41706ff12b39e5efaf97f6a0b6163bc521815cb7", "patch": "@@ -273,11 +273,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n         debug!(\"rollback_to{:?}\", {\n             for action in self.values.actions_since_snapshot(&s.snapshot) {\n-                match *action {\n-                    sv::UndoLog::NewElem(index) => {\n-                        debug!(\"inference variable _#{}t popped\", index)\n-                    }\n-                    _ => { }\n+                if let sv::UndoLog::NewElem(index) = *action {\n+                    debug!(\"inference variable _#{}t popped\", index)\n                 }\n             }\n         });"}]}