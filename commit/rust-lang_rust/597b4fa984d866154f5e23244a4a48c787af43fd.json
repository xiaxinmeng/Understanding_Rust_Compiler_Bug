{"sha": "597b4fa984d866154f5e23244a4a48c787af43fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5N2I0ZmE5ODRkODY2MTU0ZjVlMjMyNDRhNGE0OGM3ODdhZjQzZmQ=", "commit": {"author": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2015-01-16T03:04:28Z"}, "committer": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2015-02-02T02:30:35Z"}, "message": "Tweak some \u2018expected\u2026\u2019 error messages\n\nFixes #21153.", "tree": {"sha": "4cf13a45ef5c345f0687fdfc1656d1494929a17f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cf13a45ef5c345f0687fdfc1656d1494929a17f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/597b4fa984d866154f5e23244a4a48c787af43fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/597b4fa984d866154f5e23244a4a48c787af43fd", "html_url": "https://github.com/rust-lang/rust/commit/597b4fa984d866154f5e23244a4a48c787af43fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/597b4fa984d866154f5e23244a4a48c787af43fd/comments", "author": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca4b9674c26c1de07a2042cb68e6a062d7184cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4b9674c26c1de07a2042cb68e6a062d7184cef", "html_url": "https://github.com/rust-lang/rust/commit/ca4b9674c26c1de07a2042cb68e6a062d7184cef"}], "stats": {"total": 177, "additions": 100, "deletions": 77}, "files": [{"sha": "06e8728d23672d101463d36144b5c9bee83c6be8", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -13,7 +13,7 @@ use ast;\n use codemap::{spanned, Spanned, mk_sp, Span};\n use parse::common::*; //resolve bug?\n use parse::token;\n-use parse::parser::Parser;\n+use parse::parser::{Parser, TokenType};\n use ptr::P;\n \n /// A parser that can parse attributes.\n@@ -69,7 +69,9 @@ impl<'a> ParserAttr for Parser<'a> {\n                 let lo = self.span.lo;\n                 self.bump();\n \n-                let style = if self.eat(&token::Not) {\n+                if permit_inner { self.expected_tokens.push(TokenType::Token(token::Not)); }\n+                let style = if self.token == token::Not {\n+                    self.bump();\n                     if !permit_inner {\n                         let span = self.span;\n                         self.span_err(span,\n@@ -96,7 +98,8 @@ impl<'a> ParserAttr for Parser<'a> {\n             }\n         };\n \n-        if permit_inner && self.eat(&token::Semi) {\n+        if permit_inner && self.token == token::Semi {\n+            self.bump();\n             self.span_warn(span, \"this inner attribute syntax is deprecated. \\\n                            The new syntax is `#![foo]`, with a bang and no semicolon\");\n             style = ast::AttrInner;"}, {"sha": "66f5cdfd1e357acca2974408c1a04b445917a90c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -290,6 +290,7 @@ pub struct Parser<'a> {\n #[derive(PartialEq, Eq, Clone)]\n pub enum TokenType {\n     Token(token::Token),\n+    Keyword(keywords::Keyword),\n     Operator,\n }\n \n@@ -298,6 +299,7 @@ impl TokenType {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n             TokenType::Operator => \"an operator\".to_string(),\n+            TokenType::Keyword(kw) => format!(\"`{}`\", token::get_name(kw.to_name())),\n         }\n     }\n }\n@@ -365,9 +367,9 @@ impl<'a> Parser<'a> {\n                                                 token_str)[]);\n     }\n \n-    pub fn unexpected(&self) -> ! {\n-        let this_token = self.this_token_to_string();\n-        self.fatal(&format!(\"unexpected token: `{}`\", this_token)[]);\n+    pub fn unexpected(&mut self) -> ! {\n+        self.expect_one_of(&[], &[]);\n+        unreachable!()\n     }\n \n     /// Expect and consume the token t. Signal an error if\n@@ -425,10 +427,13 @@ impl<'a> Parser<'a> {\n             let expect = tokens_to_string(&expected[]);\n             let actual = self.this_token_to_string();\n             self.fatal(\n-                &(if expected.len() != 1 {\n+                &(if expected.len() > 1 {\n                     (format!(\"expected one of {}, found `{}`\",\n                              expect,\n                              actual))\n+                } else if expected.len() == 0 {\n+                    (format!(\"unexpected token: `{}`\",\n+                             actual))\n                 } else {\n                     (format!(\"expected {}, found `{}`\",\n                              expect,\n@@ -515,7 +520,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_path_list_item(&mut self) -> ast::PathListItem {\n         let lo = self.span.lo;\n-        let node = if self.eat_keyword(keywords::Mod) {\n+        let node = if self.eat_keyword_noexpect(keywords::Mod) {\n             let span = self.last_span;\n             self.span_warn(span, \"deprecated syntax; use the `self` keyword now\");\n             ast::PathListMod { id: ast::DUMMY_NODE_ID }\n@@ -547,9 +552,23 @@ impl<'a> Parser<'a> {\n         is_present\n     }\n \n+    pub fn check_keyword(&mut self, kw: keywords::Keyword) -> bool {\n+        self.expected_tokens.push(TokenType::Keyword(kw));\n+        self.token.is_keyword(kw)\n+    }\n+\n     /// If the next token is the given keyword, eat it and return\n     /// true. Otherwise, return false.\n     pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> bool {\n+        if self.check_keyword(kw) {\n+            self.bump();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn eat_keyword_noexpect(&mut self, kw: keywords::Keyword) -> bool {\n         if self.token.is_keyword(kw) {\n             self.bump();\n             true\n@@ -563,10 +582,7 @@ impl<'a> Parser<'a> {\n     /// Otherwise, eat it.\n     pub fn expect_keyword(&mut self, kw: keywords::Keyword) {\n         if !self.eat_keyword(kw) {\n-            let id_interned_str = token::get_name(kw.to_name());\n-            let token_str = self.this_token_to_string();\n-            self.fatal(&format!(\"expected `{}`, found `{}`\",\n-                               id_interned_str, token_str)[])\n+            self.expect_one_of(&[], &[]);\n         }\n     }\n \n@@ -593,6 +609,7 @@ impl<'a> Parser<'a> {\n     /// Expect and consume an `&`. If `&&` is seen, replace it with a single\n     /// `&` and continue. If an `&` is not seen, signal an error.\n     fn expect_and(&mut self) {\n+        self.expected_tokens.push(TokenType::Token(token::BinOp(token::And)));\n         match self.token {\n             token::BinOp(token::And) => self.bump(),\n             token::AndAnd => {\n@@ -601,19 +618,15 @@ impl<'a> Parser<'a> {\n                 self.replace_token(token::BinOp(token::And), lo, span.hi)\n             }\n             _ => {\n-                let token_str = self.this_token_to_string();\n-                let found_token =\n-                    Parser::token_to_string(&token::BinOp(token::And));\n-                self.fatal(&format!(\"expected `{}`, found `{}`\",\n-                                   found_token,\n-                                   token_str)[])\n+                self.expect_one_of(&[], &[]);\n             }\n         }\n     }\n \n     /// Expect and consume a `|`. If `||` is seen, replace it with a single\n     /// `|` and continue. If a `|` is not seen, signal an error.\n     fn expect_or(&mut self) {\n+        self.expected_tokens.push(TokenType::Token(token::BinOp(token::Or)));\n         match self.token {\n             token::BinOp(token::Or) => self.bump(),\n             token::OrOr => {\n@@ -622,12 +635,7 @@ impl<'a> Parser<'a> {\n                 self.replace_token(token::BinOp(token::Or), lo, span.hi)\n             }\n             _ => {\n-                let found_token = self.this_token_to_string();\n-                let token_str =\n-                    Parser::token_to_string(&token::BinOp(token::Or));\n-                self.fatal(&format!(\"expected `{}`, found `{}`\",\n-                                   token_str,\n-                                   found_token)[])\n+                self.expect_one_of(&[], &[]);\n             }\n         }\n     }\n@@ -652,6 +660,7 @@ impl<'a> Parser<'a> {\n     /// This is meant to be used when parsing generics on a path to get the\n     /// starting token.\n     fn eat_lt(&mut self) -> bool {\n+        self.expected_tokens.push(TokenType::Token(token::Lt));\n         match self.token {\n             token::Lt => { self.bump(); true }\n             token::BinOp(token::Shl) => {\n@@ -666,11 +675,7 @@ impl<'a> Parser<'a> {\n \n     fn expect_lt(&mut self) {\n         if !self.eat_lt() {\n-            let found_token = self.this_token_to_string();\n-            let token_str = Parser::token_to_string(&token::Lt);\n-            self.fatal(&format!(\"expected `{}`, found `{}`\",\n-                               token_str,\n-                               found_token)[])\n+            self.expect_one_of(&[], &[]);\n         }\n     }\n \n@@ -700,6 +705,7 @@ impl<'a> Parser<'a> {\n     /// with a single > and continue. If a GT is not seen,\n     /// signal an error.\n     pub fn expect_gt(&mut self) {\n+        self.expected_tokens.push(TokenType::Token(token::Gt));\n         match self.token {\n             token::Gt => self.bump(),\n             token::BinOp(token::Shr) => {\n@@ -998,14 +1004,14 @@ impl<'a> Parser<'a> {\n     /// Is the current token one of the keywords that signals a bare function\n     /// type?\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n-        self.token.is_keyword(keywords::Fn) ||\n-            self.token.is_keyword(keywords::Unsafe) ||\n-            self.token.is_keyword(keywords::Extern)\n+        self.check_keyword(keywords::Fn) ||\n+            self.check_keyword(keywords::Unsafe) ||\n+            self.check_keyword(keywords::Extern)\n     }\n \n     /// Is the current token one of the keywords that signals a closure type?\n     pub fn token_is_closure_keyword(&mut self) -> bool {\n-        self.token.is_keyword(keywords::Unsafe)\n+        self.check_keyword(keywords::Unsafe)\n     }\n \n     pub fn get_lifetime(&mut self) -> ast::Ident {\n@@ -1035,7 +1041,7 @@ impl<'a> Parser<'a> {\n         let lifetime_defs = self.parse_late_bound_lifetime_defs();\n \n         // examine next token to decide to do\n-        if self.eat_keyword(keywords::Proc) {\n+        if self.eat_keyword_noexpect(keywords::Proc) {\n             self.parse_proc_type(lifetime_defs)\n         } else if self.token_is_bare_fn_keyword() || self.token_is_closure_keyword() {\n             self.parse_ty_bare_fn_or_ty_closure(lifetime_defs)\n@@ -1166,11 +1172,11 @@ impl<'a> Parser<'a> {\n         // Closure:  [unsafe] <'lt> |S| [:Bounds] -> T\n         // Fn:       [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n \n-        if self.token.is_keyword(keywords::Fn) {\n+        if self.check_keyword(keywords::Fn) {\n             self.parse_ty_bare_fn(lifetime_defs)\n-        } else if self.token.is_keyword(keywords::Extern) {\n+        } else if self.check_keyword(keywords::Extern) {\n             self.parse_ty_bare_fn(lifetime_defs)\n-        } else if self.token.is_keyword(keywords::Unsafe) {\n+        } else if self.check_keyword(keywords::Unsafe) {\n             if self.look_ahead(1, |t| t.is_keyword(keywords::Fn) ||\n                                       t.is_keyword(keywords::Extern)) {\n                 self.parse_ty_bare_fn(lifetime_defs)\n@@ -1480,7 +1486,7 @@ impl<'a> Parser<'a> {\n             // BORROWED POINTER\n             self.expect_and();\n             self.parse_borrowed_pointee()\n-        } else if self.token.is_keyword(keywords::For) {\n+        } else if self.check_keyword(keywords::For) {\n             self.parse_for_in_type()\n         } else if self.token_is_bare_fn_keyword() ||\n                   self.token_is_closure_keyword() {\n@@ -1494,14 +1500,14 @@ impl<'a> Parser<'a> {\n                    })) {\n             // CLOSURE\n             self.parse_ty_closure(Vec::new())\n-        } else if self.eat_keyword(keywords::Typeof) {\n+        } else if self.eat_keyword_noexpect(keywords::Typeof) {\n             // TYPEOF\n             // In order to not be ambiguous, the type must be surrounded by parens.\n             self.expect(&token::OpenDelim(token::Paren));\n             let e = self.parse_expr();\n             self.expect(&token::CloseDelim(token::Paren));\n             TyTypeof(e)\n-        } else if self.eat_keyword(keywords::Proc) {\n+        } else if self.eat_keyword_noexpect(keywords::Proc) {\n             self.parse_proc_type(Vec::new())\n         } else if self.eat_lt() {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n@@ -2092,6 +2098,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn expect_open_delim(&mut self) -> token::DelimToken {\n+        self.expected_tokens.push(TokenType::Token(token::Gt));\n         match self.token {\n             token::OpenDelim(delim) => {\n                 self.bump();\n@@ -2233,7 +2240,7 @@ impl<'a> Parser<'a> {\n                 if self.eat_keyword(keywords::Move) {\n                     return self.parse_lambda_expr(CaptureByValue);\n                 }\n-                if self.eat_keyword(keywords::Proc) {\n+                if self.eat_keyword_noexpect(keywords::Proc) {\n                     let span = self.last_span;\n                     let _ = self.parse_proc_decl();\n                     let _ = self.parse_expr();\n@@ -2307,8 +2314,8 @@ impl<'a> Parser<'a> {\n                     hi = self.span.hi;\n                 } else if self.check(&token::ModSep) ||\n                         self.token.is_ident() &&\n-                        !self.token.is_keyword(keywords::True) &&\n-                        !self.token.is_keyword(keywords::False) {\n+                        !self.check_keyword(keywords::True) &&\n+                        !self.check_keyword(keywords::False) {\n                     let pth =\n                         self.parse_path(LifetimeAndTypesWithColons);\n \n@@ -2792,7 +2799,7 @@ impl<'a> Parser<'a> {\n             ex = ExprAddrOf(m, e);\n           }\n           token::Ident(_, _) => {\n-            if !self.token.is_keyword(keywords::Box) {\n+            if !self.check_keyword(keywords::Box) {\n                 return self.parse_dot_or_call_expr();\n             }\n \n@@ -2879,7 +2886,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             None => {\n-                if AS_PREC >= min_prec && self.eat_keyword(keywords::As) {\n+                if AS_PREC >= min_prec && self.eat_keyword_noexpect(keywords::As) {\n                     let rhs = self.parse_ty();\n                     let _as = self.mk_expr(lhs.span.lo,\n                                            rhs.span.hi,\n@@ -3002,7 +3009,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n     pub fn parse_if_expr(&mut self) -> P<Expr> {\n-        if self.token.is_keyword(keywords::Let) {\n+        if self.check_keyword(keywords::Let) {\n             return self.parse_if_let_expr();\n         }\n         let lo = self.last_span.lo;\n@@ -3655,7 +3662,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let lo = self.span.lo;\n-        if self.token.is_keyword(keywords::Let) {\n+        if self.check_keyword(keywords::Let) {\n             check_expected_item(self, &item_attrs[]);\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n@@ -5302,7 +5309,7 @@ impl<'a> Parser<'a> {\n         let (maybe_path, ident) = match self.token {\n             token::Ident(..) => {\n                 let the_ident = self.parse_ident();\n-                let path = if self.eat_keyword(keywords::As) {\n+                let path = if self.eat_keyword_noexpect(keywords::As) {\n                     // skip the ident if there is one\n                     if self.token.is_ident() { self.bump(); }\n \n@@ -5595,14 +5602,13 @@ impl<'a> Parser<'a> {\n                                     token_str)[]);\n         }\n \n-        if self.eat_keyword(keywords::Virtual) {\n+        if self.eat_keyword_noexpect(keywords::Virtual) {\n             let span = self.span;\n             self.span_err(span, \"`virtual` structs have been removed from the language\");\n         }\n \n-        if self.token.is_keyword(keywords::Static) {\n+        if self.eat_keyword(keywords::Static) {\n             // STATIC ITEM\n-            self.bump();\n             let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n             let (ident, item_, extra_attrs) = self.parse_item_const(Some(m));\n             let last_span = self.last_span;\n@@ -5614,9 +5620,8 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(item);\n         }\n-        if self.token.is_keyword(keywords::Const) {\n+        if self.eat_keyword(keywords::Const) {\n             // CONST ITEM\n-            self.bump();\n             if self.eat_keyword(keywords::Mut) {\n                 let last_span = self.last_span;\n                 self.span_err(last_span, \"const globals cannot be mutable\");\n@@ -5632,7 +5637,7 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(item);\n         }\n-        if self.token.is_keyword(keywords::Unsafe) &&\n+        if self.check_keyword(keywords::Unsafe) &&\n             self.look_ahead(1us, |t| t.is_keyword(keywords::Trait))\n         {\n             // UNSAFE TRAIT ITEM\n@@ -5649,7 +5654,7 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(item);\n         }\n-        if self.token.is_keyword(keywords::Unsafe) &&\n+        if self.check_keyword(keywords::Unsafe) &&\n             self.look_ahead(1us, |t| t.is_keyword(keywords::Impl))\n         {\n             // IMPL ITEM\n@@ -5665,7 +5670,7 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(item);\n         }\n-        if self.token.is_keyword(keywords::Fn) {\n+        if self.check_keyword(keywords::Fn) {\n             // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n@@ -5679,7 +5684,7 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(item);\n         }\n-        if self.token.is_keyword(keywords::Unsafe)\n+        if self.check_keyword(keywords::Unsafe)\n             && self.look_ahead(1us, |t| *t != token::OpenDelim(token::Brace)) {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n@@ -5784,11 +5789,11 @@ impl<'a> Parser<'a> {\n \n         let visibility = self.parse_visibility();\n \n-        if self.token.is_keyword(keywords::Static) {\n+        if self.check_keyword(keywords::Static) {\n             // FOREIGN STATIC ITEM\n             return Ok(self.parse_item_foreign_static(visibility, attrs));\n         }\n-        if self.token.is_keyword(keywords::Fn) || self.token.is_keyword(keywords::Unsafe) {\n+        if self.check_keyword(keywords::Fn) || self.check_keyword(keywords::Unsafe) {\n             // FOREIGN FUNCTION ITEM\n             return Ok(self.parse_item_foreign_fn(visibility, attrs));\n         }"}, {"sha": "5c3892e49c0587543e02f334921741b971db5f39", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -456,7 +456,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         pub use self::Keyword::*;\n         use ast;\n \n-        #[derive(Copy)]\n+        #[derive(Copy, Clone, PartialEq, Eq)]\n         pub enum Keyword {\n             $( $sk_variant, )*\n             $( $rk_variant, )*"}, {"sha": "e07f4b8e549008db0911a2d12d741d390cc86ac2", "filename": "src/test/compile-fail/better-expected.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let x: [isize 3]; //~ ERROR expected one of `(`, `+`, `::`, `;`, or `]`, found `3`\n+    let x: [isize 3]; //~ ERROR expected one of `(`, `+`, `::`, `;`, `<`, or `]`, found `3`\n }"}, {"sha": "70c7d42feb53f063c3094c815a97ec25034b9b94", "filename": "src/test/compile-fail/empty-impl-semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-impl Foo; //~ ERROR expected one of `(`, `+`, `::`, or `{`, found `;`\n+impl Foo; //~ ERROR expected one of `(`, `+`, `::`, `<`, `for`, `where`, or `{`, found `;`"}, {"sha": "69e2f3ae60be5c02ace2dfc4b79c587165a6868c", "filename": "src/test/compile-fail/extern-no-fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fextern-no-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fextern-no-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-no-fn.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:unexpected token\n extern {\n-    f();\n+    f(); //~ ERROR expected one of `fn`, `pub`, `static`, `unsafe`, or `}`, found `f`\n }\n \n fn main() {"}, {"sha": "a6c4570c60f7f93d7862d086f1bfabb4cbc9a5c1", "filename": "src/test/compile-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -14,7 +14,7 @@ impl Foo {\n     fn foo() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected `fn`, found `}`\n+} //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n \n fn main() {}\n "}, {"sha": "3b329d78237491a491a42020fc67083cc3829a3f", "filename": "src/test/compile-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -12,6 +12,6 @@ struct Foo;\n \n impl Foo {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected `fn`, found `}`\n+} //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n \n fn main() {}"}, {"sha": "e2b6deb0ad93a4a04c7c416f86aac0b18a3e1147", "filename": "src/test/compile-fail/issue-21153.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21153.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait MyTrait<T>: Iterator {\n+    Item = T; //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `Item`\n+}"}, {"sha": "f182eb8fa5ba6bb7f77f84e7eb80f39245500773", "filename": "src/test/compile-fail/multitrait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -12,7 +12,8 @@ struct S {\n  y: isize\n }\n \n-impl Cmp, ToString for S { //~ ERROR: expected one of `(`, `+`, `::`, or `{`, found `,`\n+impl Cmp, ToString for S {\n+//~^ ERROR: expected one of `(`, `+`, `::`, `<`, `for`, `where`, or `{`, found `,`\n   fn eq(&&other: S) { false }\n   fn to_string(&self) -> String { \"hi\".to_string() }\n }"}, {"sha": "c52fb8c9b67979cf55c412ca91d145981ace7fa5", "filename": "src/test/compile-fail/pat-range-bad-dots.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     match 22 {\n-        0 .. 3 => {} //~ ERROR expected one of `...`, `=>`, or `|`, found `..`\n+        0 .. 3 => {} //~ ERROR expected one of `...`, `=>`, `if`, or `|`, found `..`\n         _ => {}\n     }\n }"}, {"sha": "0cea87dba19bbba306bd531223fff888ed20056e", "filename": "src/test/compile-fail/removed-syntax-closure-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type closure = Box<lt/fn()>; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `>`, found `/`\n+type closure = Box<lt/fn()>; //~ ERROR expected one of `(`, `+`, `,`, `::`, `<`, or `>`, found `/`"}, {"sha": "b067cee03d257a07bbe0e57651fe824e8ffb25e0", "filename": "src/test/compile-fail/removed-syntax-enum-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum e = isize; //~ ERROR expected one of `<` or `{`, found `=`\n+enum e = isize; //~ ERROR expected one of `<`, `where`, or `{`, found `=`"}, {"sha": "a0e1d04a3dc5d098d34d41f29c7776f29e8fa4e5", "filename": "src/test/compile-fail/removed-syntax-extern-const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-extern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-extern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-extern-const.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -9,5 +9,6 @@\n // except according to those terms.\n \n extern {\n-    const i: isize; //~ ERROR unexpected token: `const`\n+    const i: isize;\n+    //~^ ERROR expected one of `fn`, `pub`, `static`, `unsafe`, or `}`, found `const`\n }"}, {"sha": "0e8e20b38918724cc2cf384a0d2ee8b19088e5f9", "filename": "src/test/compile-fail/removed-syntax-fixed-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type v = [isize * 3]; //~ ERROR expected one of `(`, `+`, `::`, `;`, or `]`, found `*`\n+type v = [isize * 3]; //~ ERROR expected one of `(`, `+`, `::`, `;`, `<`, or `]`, found `*`"}, {"sha": "9a7570a92f002ace9a002b1bb505f9f844bc1fc2", "filename": "src/test/compile-fail/removed-syntax-mut-vec-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -10,4 +10,4 @@\n \n type v = [mut isize];\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected one of `(`, `+`, `::`, `;`, or `]`, found `isize`\n+    //~^^ ERROR expected one of `(`, `+`, `::`, `;`, `<`, or `]`, found `isize`"}, {"sha": "44c65d98c0b7201ad46949ddae0a77dddbc80198", "filename": "src/test/compile-fail/removed-syntax-ptr-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type bptr = &lifetime/isize; //~ ERROR expected one of `(`, `+`, `::`, or `;`, found `/`\n+type bptr = &lifetime/isize; //~ ERROR expected one of `(`, `+`, `::`, `;`, or `<`, found `/`"}, {"sha": "caf939e7b8aa9d039755e514b7579fa44b3f9af7", "filename": "src/test/compile-fail/removed-syntax-static-fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-static-fn.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -11,5 +11,6 @@\n struct S;\n \n impl S {\n-    static fn f() {} //~ ERROR expected `fn`, found `static`\n+    static fn f() {}\n+    //~^ ERROR expected one of `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `static`\n }"}, {"sha": "d1c2fc69f523383354671b838aa8182a57e3ee3c", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -10,4 +10,4 @@\n \n type mut_box = Box<mut isize>;\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected one of `(`, `+`, `,`, `::`, or `>`, found `isize`\n+    //~^^ ERROR expected one of `(`, `+`, `,`, `::`, `<`, or `>`, found `isize`"}, {"sha": "e6948b7c7c99580145f650518df52725ecfb6aa1", "filename": "src/test/compile-fail/struct-literal-in-match-discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597b4fa984d866154f5e23244a4a48c787af43fd/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs?ref=597b4fa984d866154f5e23244a4a48c787af43fd", "patch": "@@ -14,7 +14,7 @@ struct Foo {\n \n fn main() {\n     match Foo {\n-        x: 3    //~ ERROR expected one of `!`, `=>`, `@`, or `|`, found `:`\n+        x: 3    //~ ERROR expected one of `!`, `=>`, `@`, `if`, or `|`, found `:`\n     } {\n         Foo {\n             x: x"}]}