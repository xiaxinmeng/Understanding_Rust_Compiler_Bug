{"sha": "7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNzZkOGI3NjEzYzgxYzA5ZmVlZWMzYmY5NGQ0N2M0YTUxNzRiYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-25T18:16:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-25T18:16:51Z"}, "message": "Auto merge of #27258 - nikomatsakis:issue-26952, r=eddyb\n\nCorrect regression in type-inference caused by failing to reconfirm that\r\nthe object trait matches the required trait during trait selection.  The\r\nexisting code was checking that the object trait WOULD match (in a\r\nprobe), but never executing the match outside of a probe.\r\n\r\nThis corrects various regressions observed in the wild, including\r\nissue #26952. Fixes #26952.\r\n\r\nr? @eddyb \r\ncc @frankmcsherry", "tree": {"sha": "69368d9c8bdea0d1956f32807a87df6a59c08bae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69368d9c8bdea0d1956f32807a87df6a59c08bae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "html_url": "https://github.com/rust-lang/rust/commit/7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "url": "https://api.github.com/repos/rust-lang/rust/commits/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "html_url": "https://github.com/rust-lang/rust/commit/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af"}, {"sha": "4726bb46b0ac5eea5761bea2f02ad08d8d4d7048", "url": "https://api.github.com/repos/rust-lang/rust/commits/4726bb46b0ac5eea5761bea2f02ad08d8d4d7048", "html_url": "https://github.com/rust-lang/rust/commit/4726bb46b0ac5eea5761bea2f02ad08d8d4d7048"}], "stats": {"total": 111, "additions": 80, "deletions": 31}, "files": [{"sha": "c6df1c395cceccb6dc05d234ed0dfc36e0168f36", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "patch": "@@ -698,8 +698,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn rollback_to(&self, snapshot: CombinedSnapshot) {\n-        debug!(\"rollback!\");\n+    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot) {\n+        debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot { type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n@@ -759,7 +759,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n         match r {\n             Ok(_) => { self.commit_from(snapshot); }\n-            Err(_) => { self.rollback_to(snapshot); }\n+            Err(_) => { self.rollback_to(\"commit_if_ok -- error\", snapshot); }\n         }\n         r\n     }\n@@ -778,6 +778,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let r = self.commit_if_ok(|_| f());\n \n+        debug!(\"commit_regions_if_ok: rolling back everything but regions\");\n+\n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n         self.type_variables\n@@ -804,7 +806,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n-        self.rollback_to(snapshot);\n+        self.rollback_to(\"probe\", snapshot);\n         r\n     }\n "}, {"sha": "5727f07edb1d0e77324b3734ee583463f4c1b2a5", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "patch": "@@ -1351,11 +1351,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // correct trait, but also the correct type parameters.\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo : Bar<u32>`.\n-            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n-                .filter(|upcast_trait_ref| self.infcx.probe(|_| {\n-                    let upcast_trait_ref = upcast_trait_ref.clone();\n-                    self.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n-                })).count();\n+            let upcast_trait_refs =\n+                util::supertraits(self.tcx(), poly_trait_ref)\n+                .filter(|upcast_trait_ref| {\n+                    self.infcx.probe(|_| {\n+                        let upcast_trait_ref = upcast_trait_ref.clone();\n+                        self.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n+                    })\n+                })\n+                .count();\n \n             if upcast_trait_refs > 1 {\n                 // can be upcast in many ways; need more type information\n@@ -1627,9 +1631,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             let principal =\n                                 data.principal_trait_ref_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);\n-                            let desired_def_id = obligation.predicate.def_id();\n+                            let copy_def_id = obligation.predicate.def_id();\n                             for tr in util::supertraits(self.tcx(), principal) {\n-                                if tr.def_id() == desired_def_id {\n+                                if tr.def_id() == copy_def_id {\n                                     return ok_if(Vec::new())\n                                 }\n                             }\n@@ -2282,31 +2286,41 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        // Upcast the object type to the obligation type. There must\n-        // be exactly one applicable trait-reference; if this were not\n-        // the case, we would have reported an ambiguity error rather\n-        // than successfully selecting one of the candidates.\n-        let mut upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n-            .map(|upcast_trait_ref| {\n-                (upcast_trait_ref.clone(), self.infcx.probe(|_| {\n-                    self.match_poly_trait_ref(obligation, upcast_trait_ref)\n-                }).is_ok())\n-            });\n         let mut upcast_trait_ref = None;\n-        let mut vtable_base = 0;\n+        let vtable_base;\n+\n+        {\n+            // We want to find the first supertrait in the list of\n+            // supertraits that we can unify with, and do that\n+            // unification. We know that there is exactly one in the list\n+            // where we can unify because otherwise select would have\n+            // reported an ambiguity. (When we do find a match, also\n+            // record it for later.)\n+            let nonmatching =\n+                util::supertraits(self.tcx(), poly_trait_ref)\n+                .take_while(|&t| {\n+                    match\n+                        self.infcx.commit_if_ok(\n+                            |_| self.match_poly_trait_ref(obligation, t))\n+                    {\n+                        Ok(_) => { upcast_trait_ref = Some(t); false }\n+                        Err(_) => { true }\n+                    }\n+                });\n+\n+            // Additionally, for each of the nonmatching predicates that\n+            // we pass over, we sum up the set of number of vtable\n+            // entries, so that we can compute the offset for the selected\n+            // trait.\n+            vtable_base =\n+                nonmatching.map(|t| util::count_own_vtable_entries(self.tcx(), t))\n+                           .sum();\n \n-        while let Some((supertrait, matches)) = upcast_trait_refs.next() {\n-            if matches {\n-                upcast_trait_ref = Some(supertrait);\n-                break;\n-            }\n-            vtable_base += util::count_own_vtable_entries(self.tcx(), supertrait);\n         }\n-        assert!(upcast_trait_refs.all(|(_, matches)| !matches));\n \n         VtableObjectData {\n             upcast_trait_ref: upcast_trait_ref.unwrap(),\n-            vtable_base: vtable_base\n+            vtable_base: vtable_base,\n         }\n     }\n "}, {"sha": "84ca7cd437a96f7ee0bcfcc0e2f72d7ffe3e8b2b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "patch": "@@ -1985,7 +1985,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {"}, {"sha": "d5ca90c1a28c4c0b37aee0af00f1a922eaa63bcd", "filename": "src/test/run-pass/infer-from-object-trait-issue-26952.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/src%2Ftest%2Frun-pass%2Finfer-from-object-trait-issue-26952.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7276d8b7613c81c09feeec3bf94d47c4a5174bc8/src%2Ftest%2Frun-pass%2Finfer-from-object-trait-issue-26952.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfer-from-object-trait-issue-26952.rs?ref=7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when we match a trait reference like `Foo<A>: Foo<_#0t>`,\n+// we unify with `_#0t` with `A`. In this code, if we failed to do\n+// that, then you get an unconstrained type-variable in `call`.\n+//\n+// Also serves as a regression test for issue #26952, though the test\n+// was derived from another reported regression with the same cause.\n+\n+use std::marker::PhantomData;\n+\n+trait Trait<A> { fn foo(&self); }\n+\n+struct Type<A> { a: PhantomData<A> }\n+\n+fn as_trait<A>(t: &Type<A>) -> &Trait<A> { loop {  } }\n+\n+fn want<A,T:Trait<A>+?Sized>(t: &T) { }\n+\n+fn call<A>(p: Type<A>) {\n+    let q = as_trait(&p);\n+    want(q); // parameter A to `want` *would* be unconstrained\n+}\n+\n+fn main() { }"}]}