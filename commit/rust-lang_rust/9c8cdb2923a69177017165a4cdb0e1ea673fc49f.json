{"sha": "9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOGNkYjI5MjNhNjkxNzcwMTcxNjVhNGNkYjBlMWVhNjczZmM0OWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-05T14:15:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-05T14:15:18Z"}, "message": "Auto merge of #39563 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 19 pull requests\n\n- Successful merges: #38518, #38921, #38959, #38983, #39009, #39107, #39193, #39289, #39312, #39393, #39442, #39443, #39453, #39454, #39471, #39477, #39478, #39527, #39552\n- Failed merges:", "tree": {"sha": "69ebb9fa31a84a98c42c14f56e866762a844ce2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69ebb9fa31a84a98c42c14f56e866762a844ce2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "html_url": "https://github.com/rust-lang/rust/commit/9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "696f5c1fc695494053709ae3b18b4c6a65b619a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/696f5c1fc695494053709ae3b18b4c6a65b619a6", "html_url": "https://github.com/rust-lang/rust/commit/696f5c1fc695494053709ae3b18b4c6a65b619a6"}, {"sha": "0a09274e27c7b409a321c0c7ed20d99492601b44", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a09274e27c7b409a321c0c7ed20d99492601b44", "html_url": "https://github.com/rust-lang/rust/commit/0a09274e27c7b409a321c0c7ed20d99492601b44"}], "stats": {"total": 1920, "additions": 1344, "deletions": 576}, "files": [{"sha": "5ca5ce1648f2fc80ee0735f723dc5523333a2e26", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -11,8 +11,8 @@\n //! rustbuild, the Rust build system\n //!\n //! This is the entry point for the build system used to compile the `rustc`\n-//! compiler. Lots of documentation can be found in the `README.md` file next to\n-//! this file, and otherwise documentation can be found throughout the `build`\n+//! compiler. Lots of documentation can be found in the `README.md` file in the\n+//! parent directory, and otherwise documentation can be found throughout the `build`\n //! directory in each respective module.\n \n #![deny(warnings)]"}, {"sha": "bc8341102421b8f217311eca2903f5a92e217c4a", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -438,14 +438,14 @@ def main():\n     rb.use_vendored_sources = '\\nvendor = true' in rb.config_toml or \\\n                               'CFG_ENABLE_VENDOR' in rb.config_mk\n \n-    if 'SUDO_USER' in os.environ:\n-        if os.environ['USER'] != os.environ['SUDO_USER']:\n+    if 'SUDO_USER' in os.environ and not rb.use_vendored_sources:\n+        if os.environ.get('USER') != os.environ['SUDO_USER']:\n             rb.use_vendored_sources = True\n             print('info: looks like you are running this command under `sudo`')\n             print('      and so in order to preserve your $HOME this will now')\n             print('      use vendored sources by default. Note that if this')\n             print('      does not work you should run a normal build first')\n-            print('      before running a command like `sudo make intall`')\n+            print('      before running a command like `sudo make install`')\n \n     if rb.use_vendored_sources:\n         if not os.path.exists('.cargo'):"}, {"sha": "9327cc0cf7faf63845940cbe6f113e4584cc4e9c", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -381,7 +381,8 @@ pub fn rust_src(build: &Build) {\n         \"README.md\",\n         \"RELEASES.md\",\n         \"configure\",\n-        \"Makefile.in\"\n+        \"Makefile.in\",\n+        \"x.py\",\n     ];\n     let src_dirs = [\n         \"man\","}, {"sha": "23e0295ba5401b998749699796088c25bae7cec2", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1088,7 +1088,7 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T: 'a> FusedIterator for Drain<'a, T> {}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     fn from(vec: Vec<T>) -> BinaryHeap<T> {\n         let mut heap = BinaryHeap { data: vec };\n@@ -1097,7 +1097,7 @@ impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T> From<BinaryHeap<T>> for Vec<T> {\n     fn from(heap: BinaryHeap<T>) -> Vec<T> {\n         heap.data"}, {"sha": "78764091cf03275a3569dc30bae907ff275292d7", "filename": "src/libcore/char.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -588,7 +588,7 @@ impl ExactSizeIterator for EscapeUnicode {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeUnicode {}\n \n-#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n impl fmt::Display for EscapeUnicode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for c in self.clone() {\n@@ -701,7 +701,7 @@ impl ExactSizeIterator for EscapeDefault {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDefault {}\n \n-#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n impl fmt::Display for EscapeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for c in self.clone() {\n@@ -735,7 +735,7 @@ impl ExactSizeIterator for EscapeDebug { }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDebug {}\n \n-#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+#[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n impl fmt::Display for EscapeDebug {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.0, f)"}, {"sha": "4e170794c1d6e411d57443a56c91e2ff7339f93b", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -225,7 +225,7 @@ pub trait TryFrom<T>: Sized {\n     type Err;\n \n     /// Performs the conversion.\n-    fn try_from(T) -> Result<Self, Self::Err>;\n+    fn try_from(value: T) -> Result<Self, Self::Err>;\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9a7914064fdd56bb176fe19d1d811a288ff6ba79", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -13,7 +13,11 @@\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n     (impl $imp:ident, $method:ident for $t:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        forward_ref_unop!(impl $imp, $method for $t,\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n+    };\n+    (impl $imp:ident, $method:ident for $t:ty, #[$attr:meta]) => {\n+        #[$attr]\n         impl<'a> $imp for &'a $t {\n             type Output = <$t as $imp>::Output;\n \n@@ -29,7 +33,11 @@ macro_rules! forward_ref_unop {\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        forward_ref_binop!(impl $imp, $method for $t, $u,\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n+    };\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n+        #[$attr]\n         impl<'a> $imp<$u> for &'a $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -39,7 +47,7 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[$attr]\n         impl<'a> $imp<&'a $u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -49,7 +57,7 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[$attr]\n         impl<'a, 'b> $imp<&'a $u> for &'b $t {\n             type Output = <$t as $imp<$u>>::Output;\n "}, {"sha": "d9b8c5ea589fd57aa74a840b889ae5aad9deb4de", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1086,7 +1086,7 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        for x in self.iter.by_ref() {\n+        for x in &mut self.iter {\n             if (self.predicate)(&x) {\n                 return Some(x);\n             }\n@@ -1099,6 +1099,26 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    // this special case allows the compiler to make `.filter(_).count()`\n+    // branchless. Barring perfect branch prediction (which is unattainable in\n+    // the general case), this will be much faster in >90% of cases (containing\n+    // virtually all real workloads) and only a tiny bit slower in the rest.\n+    //\n+    // Having this specialization thus allows us to write `.filter(p).count()`\n+    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n+    // less readable and also less backwards-compatible to Rust before 1.10.\n+    //\n+    // Using the branchless version will also simplify the LLVM byte code, thus\n+    // leaving more budget for LLVM optimizations.\n+    #[inline]\n+    fn count(mut self) -> usize {\n+        let mut count = 0;\n+        for x in &mut self.iter {\n+            count += (self.predicate)(&x) as usize;\n+        }\n+        count\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "cb180110d3cc0116159b137a1201c744ba677264", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -661,38 +661,42 @@ pub trait Product<A = Self>: Sized {\n \n // NB: explicitly use Add and Mul here to inherit overflow checks\n macro_rules! integer_sum_product {\n-    (@impls $zero:expr, $one:expr, $($a:ty)*) => ($(\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n+        #[$attr]\n         impl Sum for $a {\n             fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n                 iter.fold($zero, Add::add)\n             }\n         }\n \n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        #[$attr]\n         impl Product for $a {\n             fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n                 iter.fold($one, Mul::mul)\n             }\n         }\n \n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        #[$attr]\n         impl<'a> Sum<&'a $a> for $a {\n             fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n                 iter.fold($zero, Add::add)\n             }\n         }\n \n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        #[$attr]\n         impl<'a> Product<&'a $a> for $a {\n             fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n                 iter.fold($one, Mul::mul)\n             }\n         }\n     )*);\n     ($($a:ty)*) => (\n-        integer_sum_product!(@impls 0, 1, $($a)+);\n-        integer_sum_product!(@impls Wrapping(0), Wrapping(1), $(Wrapping<$a>)+);\n+        integer_sum_product!(@impls 0, 1,\n+                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n+                $($a)+);\n+        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n+                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n+                $(Wrapping<$a>)+);\n     );\n }\n "}, {"sha": "3b1612a4ee29f8d051c0a8ec4b2cef9fa314c634", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -12,12 +12,12 @@\n \n macro_rules! int_module {\n     ($T:ident) => (int_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n-    ($T:ident, $($attr: tt)*) => (\n+    ($T:ident, #[$attr:meta]) => (\n         /// The smallest value that can be represented by this integer type.\n-        $($attr)*\n+        #[$attr]\n         pub const MIN: $T = $T::min_value();\n         /// The largest value that can be represented by this integer type.\n-        $($attr)*\n+        #[$attr]\n         pub const MAX: $T = $T::max_value();\n     )\n }"}, {"sha": "f7e1f78d69ebf64396ae21e6cbff0323b4056b5b", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -12,12 +12,12 @@\n \n macro_rules! uint_module {\n     ($T:ident) => (uint_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n-    ($T:ident, $($attr: tt)*) => (\n+    ($T:ident, #[$attr:meta]) => (\n         /// The smallest value that can be represented by this integer type.\n-        $($attr)*\n+        #[$attr]\n         pub const MIN: $T = $T::min_value();\n         /// The largest value that can be represented by this integer type.\n-        $($attr)*\n+        #[$attr]\n         pub const MAX: $T = $T::max_value();\n     )\n }"}, {"sha": "013f02685bad117149951d86e56b9c3f662d6f71", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -131,7 +131,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_add(other.0))\n             }\n         }\n-        forward_ref_binop! { impl Add, add for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_binop! { impl Add, add for Wrapping<$t>, Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl AddAssign for Wrapping<$t> {\n@@ -150,7 +151,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_sub(other.0))\n             }\n         }\n-        forward_ref_binop! { impl Sub, sub for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_binop! { impl Sub, sub for Wrapping<$t>, Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl SubAssign for Wrapping<$t> {\n@@ -169,7 +171,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_mul(other.0))\n             }\n         }\n-        forward_ref_binop! { impl Mul, mul for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_binop! { impl Mul, mul for Wrapping<$t>, Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl MulAssign for Wrapping<$t> {\n@@ -188,7 +191,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_div(other.0))\n             }\n         }\n-        forward_ref_binop! { impl Div, div for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_binop! { impl Div, div for Wrapping<$t>, Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl DivAssign for Wrapping<$t> {\n@@ -207,7 +211,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_rem(other.0))\n             }\n         }\n-        forward_ref_binop! { impl Rem, rem for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_binop! { impl Rem, rem for Wrapping<$t>, Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl RemAssign for Wrapping<$t> {\n@@ -226,7 +231,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(!self.0)\n             }\n         }\n-        forward_ref_unop! { impl Not, not for Wrapping<$t> }\n+        forward_ref_unop! { impl Not, not for Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitXor for Wrapping<$t> {\n@@ -237,7 +243,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0 ^ other.0)\n             }\n         }\n-        forward_ref_binop! { impl BitXor, bitxor for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_binop! { impl BitXor, bitxor for Wrapping<$t>, Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitXorAssign for Wrapping<$t> {\n@@ -256,7 +263,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0 | other.0)\n             }\n         }\n-        forward_ref_binop! { impl BitOr, bitor for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_binop! { impl BitOr, bitor for Wrapping<$t>, Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitOrAssign for Wrapping<$t> {\n@@ -275,7 +283,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0 & other.0)\n             }\n         }\n-        forward_ref_binop! { impl BitAnd, bitand for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_binop! { impl BitAnd, bitand for Wrapping<$t>, Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitAndAssign for Wrapping<$t> {\n@@ -293,7 +302,8 @@ macro_rules! wrapping_impl {\n                 Wrapping(0) - self\n             }\n         }\n-        forward_ref_unop! { impl Neg, neg for Wrapping<$t> }\n+        forward_ref_unop! { impl Neg, neg for Wrapping<$t>,\n+                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n     )*)\n }\n "}, {"sha": "9df8350d90ffdc8cb864ed4899b57018e390139f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -632,6 +632,76 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /////////////////////////////////////////////////////////////////////////\n+    // Entry-like operations to insert if None and return a reference\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Inserts `v` into the option if it is `None`, then\n+    /// returns a mutable reference to the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(option_entry)]\n+    ///\n+    /// let mut x = None;\n+    ///\n+    /// {\n+    ///     let y: &mut u32 = x.get_or_insert(5);\n+    ///     assert_eq!(y, &5);\n+    ///\n+    ///     *y = 7;\n+    /// }\n+    ///\n+    /// assert_eq!(x, Some(7));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"option_entry\", issue = \"39288\")]\n+    pub fn get_or_insert(&mut self, v: T) -> &mut T {\n+        match *self {\n+            None => *self = Some(v),\n+            _ => (),\n+        }\n+\n+        match *self {\n+            Some(ref mut v) => v,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    /// Inserts a value computed from `f` into the option if it is `None`, then\n+    /// returns a mutable reference to the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(option_entry)]\n+    ///\n+    /// let mut x = None;\n+    ///\n+    /// {\n+    ///     let y: &mut u32 = x.get_or_insert_with(|| 5);\n+    ///     assert_eq!(y, &5);\n+    ///\n+    ///     *y = 7;\n+    /// }\n+    ///\n+    /// assert_eq!(x, Some(7));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"option_entry\", issue = \"39288\")]\n+    pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n+        match *self {\n+            None => *self = Some(f()),\n+            _ => (),\n+        }\n+\n+        match *self {\n+            Some(ref mut v) => v,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Misc\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "1a482b75731c102fc36b1e92d772822f2e8a07fd", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -616,7 +616,7 @@ pub trait SliceIndex<T> {\n     fn index_mut(self, slice: &mut [T]) -> &mut Self::Output;\n }\n \n-#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n impl<T> SliceIndex<T> for usize {\n     type Output = T;\n \n@@ -665,7 +665,7 @@ impl<T> SliceIndex<T> for usize {\n     }\n }\n \n-#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n impl<T> SliceIndex<T> for  ops::Range<usize> {\n     type Output = [T];\n \n@@ -726,7 +726,7 @@ impl<T> SliceIndex<T> for  ops::Range<usize> {\n     }\n }\n \n-#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n impl<T> SliceIndex<T> for ops::RangeTo<usize> {\n     type Output = [T];\n \n@@ -761,7 +761,7 @@ impl<T> SliceIndex<T> for ops::RangeTo<usize> {\n     }\n }\n \n-#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n impl<T> SliceIndex<T> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n@@ -796,7 +796,7 @@ impl<T> SliceIndex<T> for ops::RangeFrom<usize> {\n     }\n }\n \n-#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n impl<T> SliceIndex<T> for ops::RangeFull {\n     type Output = [T];\n \n@@ -832,7 +832,7 @@ impl<T> SliceIndex<T> for ops::RangeFull {\n }\n \n \n-#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<T> SliceIndex<T> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n@@ -895,7 +895,7 @@ impl<T> SliceIndex<T> for ops::RangeInclusive<usize> {\n     }\n }\n \n-#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<T> SliceIndex<T> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n "}, {"sha": "58cd0af7ee38752618f90bff1524d6dfe2b99524", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1318,6 +1318,24 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n+#[cfg(not(stage0))]\n+#[cfg(target_has_atomic = \"128\")]\n+atomic_int! {\n+    unstable(feature = \"i128\", issue = \"35118\"),\n+    unstable(feature = \"i128\", issue = \"35118\"),\n+    unstable(feature = \"i128\", issue = \"35118\"),\n+    unstable(feature = \"i128\", issue = \"35118\"),\n+    i128 AtomicI128 ATOMIC_I128_INIT\n+}\n+#[cfg(not(stage0))]\n+#[cfg(target_has_atomic = \"128\")]\n+atomic_int! {\n+    unstable(feature = \"i128\", issue = \"35118\"),\n+    unstable(feature = \"i128\", issue = \"35118\"),\n+    unstable(feature = \"i128\", issue = \"35118\"),\n+    unstable(feature = \"i128\", issue = \"35118\"),\n+    u128 AtomicU128 ATOMIC_U128_INIT\n+}\n #[cfg(target_has_atomic = \"ptr\")]\n atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),"}, {"sha": "c7833dbd15629431504d6b9935a5334022926bc4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -191,6 +191,12 @@ fn test_iterator_enumerate_count() {\n     assert_eq!(xs.iter().count(), 6);\n }\n \n+#[test]\n+fn test_iterator_filter_count() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    assert_eq!(xs.iter().filter(|&&x| x % 2 == 0).count(), 5);\n+}\n+\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];"}, {"sha": "cb7f66732175e6171587ed69656b7aae7dd2e6ec", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1 +1 @@\n-Subproject commit 7d57bdcdbb56540f37afe5a934ce12d33a6ca7fc\n+Subproject commit cb7f66732175e6171587ed69656b7aae7dd2e6ec"}, {"sha": "70f03e02f46d9b9c6a8dd7c22c7afaa2cd4f31ae", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -192,6 +192,13 @@ declare_lint! {\n     \"lifetimes or labels named `'_` were erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n+    Warn,\n+    \"attempt to resolve a trait on an expression whose type cannot be inferred but which \\\n+     currently defaults to ()\"\n+}\n+\n declare_lint! {\n     pub SAFE_EXTERN_STATICS,\n     Warn,\n@@ -272,6 +279,7 @@ impl LintPass for HardwiredLints {\n             SUPER_OR_SELF_IN_GLOBAL_PATH,\n             HR_LIFETIME_IN_ASSOC_TYPE,\n             LIFETIME_UNDERSCORE,\n+            RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n             SAFE_EXTERN_STATICS,\n             PATTERNS_IN_FNS_WITHOUT_BODY,\n             EXTRA_REQUIREMENT_IN_IMPL,"}, {"sha": "9d1bcb8164a9e08c477ef02cab8e6f6f7bb700de", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1199,7 +1199,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           PatKind::Tuple(ref subpats, ddpos) => {\n             // (p1, ..., pN)\n             let expected_len = match self.pat_ty(&pat)?.sty {\n-                ty::TyTuple(ref tys) => tys.len(),\n+                ty::TyTuple(ref tys, _) => tys.len(),\n                 ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {"}, {"sha": "f1268521d67086781de6701def629e40d4ab251e", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -163,7 +163,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 let lhs_ty = lhs.ty(mir, tcx);\n                 let rhs_ty = rhs.ty(mir, tcx);\n                 let ty = op.ty(tcx, lhs_ty, rhs_ty);\n-                let ty = tcx.intern_tup(&[ty, tcx.types.bool]);\n+                let ty = tcx.intern_tup(&[ty, tcx.types.bool], false);\n                 Some(ty)\n             }\n             &Rvalue::UnaryOp(_, ref operand) => {\n@@ -184,7 +184,8 @@ impl<'tcx> Rvalue<'tcx> {\n                     }\n                     AggregateKind::Tuple => {\n                         Some(tcx.mk_tup(\n-                            ops.iter().map(|op| op.ty(mir, tcx))\n+                            ops.iter().map(|op| op.ty(mir, tcx)),\n+                            false\n                         ))\n                     }\n                     AggregateKind::Adt(def, _, substs, _) => {"}, {"sha": "41f3f825c3d191e16770527fd80819af4ef77719", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -52,6 +52,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n+use lint;\n use util::nodemap::FxHashMap;\n \n struct InferredObligationsSnapshotVecDelegate<'tcx> {\n@@ -407,19 +408,62 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"select({:?})\", obligation);\n         assert!(!obligation.predicate.has_escaping_regions());\n \n+        let tcx = self.tcx();\n         let dep_node = obligation.predicate.dep_node();\n-        let _task = self.tcx().dep_graph.in_task(dep_node);\n+        let _task = tcx.dep_graph.in_task(dep_node);\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n-        match self.candidate_from_obligation(&stack)? {\n-            None => Ok(None),\n+        let ret = match self.candidate_from_obligation(&stack)? {\n+            None => None,\n             Some(candidate) => {\n                 let mut candidate = self.confirm_candidate(obligation, candidate)?;\n                 let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n                 candidate.nested_obligations_mut().extend(inferred_obligations);\n-                Ok(Some(candidate))\n+                Some(candidate)\n             },\n+        };\n+\n+        // Test whether this is a `()` which was produced by defaulting a\n+        // diverging type variable with `!` disabled. If so, we may need\n+        // to raise a warning.\n+        if obligation.predicate.skip_binder().self_ty().is_defaulted_unit() {\n+            let mut raise_warning = true;\n+            // Don't raise a warning if the trait is implemented for ! and only\n+            // permits a trivial implementation for !. This stops us warning\n+            // about (for example) `(): Clone` becoming `!: Clone` because such\n+            // a switch can't cause code to stop compiling or execute\n+            // differently.\n+            let mut never_obligation = obligation.clone();\n+            let def_id = never_obligation.predicate.skip_binder().trait_ref.def_id;\n+            never_obligation.predicate = never_obligation.predicate.map_bound(|mut trait_pred| {\n+                // Swap out () with ! so we can check if the trait is impld for !\n+                {\n+                    let mut trait_ref = &mut trait_pred.trait_ref;\n+                    let unit_substs = trait_ref.substs;\n+                    let mut never_substs = Vec::with_capacity(unit_substs.len());\n+                    never_substs.push(From::from(tcx.types.never));\n+                    never_substs.extend(&unit_substs[1..]);\n+                    trait_ref.substs = tcx.intern_substs(&never_substs);\n+                }\n+                trait_pred\n+            });\n+            if let Ok(Some(..)) = self.select(&never_obligation) {\n+                if !tcx.trait_relevant_for_never(def_id) {\n+                    // The trait is also implemented for ! and the resulting\n+                    // implementation cannot actually be invoked in any way.\n+                    raise_warning = false;\n+                }\n+            }\n+\n+            if raise_warning {\n+                tcx.sess.add_lint(lint::builtin::RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n+                                  obligation.cause.body_id,\n+                                  obligation.cause.span,\n+                                  format!(\"code relies on type inference rules which are likely \\\n+                                           to change\"));\n+            }\n         }\n+        Ok(ret)\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1744,15 +1788,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) => Never,\n \n-            ty::TyTuple(tys) => {\n+            ty::TyTuple(tys, _) => {\n                 Where(ty::Binder(tys.last().into_iter().cloned().collect()))\n             }\n \n             ty::TyAdt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(ty::Binder(match sized_crit.sty {\n-                    ty::TyTuple(tys) => tys.to_vec().subst(self.tcx(), substs),\n+                    ty::TyTuple(tys, _) => tys.to_vec().subst(self.tcx(), substs),\n                     ty::TyBool => vec![],\n                     _ => vec![sized_crit.subst(self.tcx(), substs)]\n                 }))\n@@ -1799,7 +1843,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(vec![element_ty]))\n             }\n \n-            ty::TyTuple(tys) => {\n+            ty::TyTuple(tys, _) => {\n                 // (*) binder moved here\n                 Where(ty::Binder(tys.to_vec()))\n             }\n@@ -1874,7 +1918,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 vec![element_ty]\n             }\n \n-            ty::TyTuple(ref tys) => {\n+            ty::TyTuple(ref tys, _) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n                 tys.to_vec()\n             }"}, {"sha": "7b2882bb64f2cb97a13825a6e66ae7eefcf0b877", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -489,7 +489,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let arguments_tuple = match tuple_arguments {\n             TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n             TupleArgumentsFlag::Yes =>\n-                self.intern_tup(sig.skip_binder().inputs()),\n+                self.intern_tup(sig.skip_binder().inputs(), false),\n         };\n         let trait_ref = ty::TraitRef {\n             def_id: fn_trait_def_id,"}, {"sha": "56621c57eb8f7bed86f3b7c10f99b6fbd565acc1", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         |ty| tc_ty(tcx, &ty, cache))\n                 }\n \n-                ty::TyTuple(ref tys) => {\n+                ty::TyTuple(ref tys, _) => {\n                     TypeContents::union(&tys[..],\n                                         |ty| tc_ty(tcx, *ty, cache))\n                 }"}, {"sha": "a0eae33c4402b20c5a03478840ae208efe05bc54", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1384,23 +1384,24 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TySlice(ty))\n     }\n \n-    pub fn intern_tup(self, ts: &[Ty<'tcx>]) -> Ty<'tcx> {\n-        self.mk_ty(TyTuple(self.intern_type_list(ts)))\n+    pub fn intern_tup(self, ts: &[Ty<'tcx>], defaulted: bool) -> Ty<'tcx> {\n+        self.mk_ty(TyTuple(self.intern_type_list(ts), defaulted))\n     }\n \n-    pub fn mk_tup<I: InternAs<[Ty<'tcx>], Ty<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|ts| self.mk_ty(TyTuple(self.intern_type_list(ts))))\n+    pub fn mk_tup<I: InternAs<[Ty<'tcx>], Ty<'tcx>>>(self, iter: I,\n+                                                     defaulted: bool) -> I::Output {\n+        iter.intern_with(|ts| self.mk_ty(TyTuple(self.intern_type_list(ts), defaulted)))\n     }\n \n     pub fn mk_nil(self) -> Ty<'tcx> {\n-        self.intern_tup(&[])\n+        self.intern_tup(&[], false)\n     }\n \n     pub fn mk_diverging_default(self) -> Ty<'tcx> {\n         if self.sess.features.borrow().never_type {\n             self.types.never\n         } else {\n-            self.mk_nil()\n+            self.intern_tup(&[], true)\n         }\n     }\n "}, {"sha": "3ab3fc899e78c6754305f18f307f6534c3cc5378", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr | ty::TyNever => self.to_string(),\n-            ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n+            ty::TyTuple(ref tys, _) if tys.is_empty() => self.to_string(),\n \n             ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n             ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n@@ -209,7 +209,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n             }\n             ty::TyClosure(..) => \"closure\".to_string(),\n-            ty::TyTuple(_) => \"tuple\".to_string(),\n+            ty::TyTuple(..) => \"tuple\".to_string(),\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n             ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),\n             ty::TyInfer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),"}, {"sha": "981cf0897a034f2f68e1d600bdaac3e4448bbe31", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -72,7 +72,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             Some(ClosureSimplifiedType(def_id))\n         }\n         ty::TyNever => Some(NeverSimplifiedType),\n-        ty::TyTuple(ref tys) => {\n+        ty::TyTuple(ref tys, _) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n         ty::TyFnDef(.., ref f) | ty::TyFnPtr(ref f) => {"}, {"sha": "2012917f93a87e91669d74d8b61442ee97763e9f", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -151,7 +151,7 @@ impl FlagComputation {\n                 self.add_ty(m.ty);\n             }\n \n-            &ty::TyTuple(ref ts) => {\n+            &ty::TyTuple(ref ts, _) => {\n                 self.add_tys(&ts[..]);\n             }\n "}, {"sha": "18a3f1a218d854e00d9e2f4204152234b08ba18f", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             },\n \n             TyNever => DefIdForest::full(tcx),\n-            TyTuple(ref tys) => {\n+            TyTuple(ref tys, _) => {\n                 DefIdForest::union(tcx, tys.iter().map(|ty| {\n                     ty.uninhabited_from(visited, tcx)\n                 }))"}, {"sha": "f45f00b4dec96bbf20590469c44687b98858a625", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -319,9 +319,9 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyRawPtr(mt) |\n         ty::TyRef(_, mt) => characteristic_def_id_of_type(mt.ty),\n \n-        ty::TyTuple(ref tys) => tys.iter()\n-                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n-                                   .next(),\n+        ty::TyTuple(ref tys, _) => tys.iter()\n+                                      .filter_map(|ty| characteristic_def_id_of_type(ty))\n+                                      .next(),\n \n         ty::TyFnDef(def_id, ..) |\n         ty::TyClosure(def_id, _) => Some(def_id),"}, {"sha": "ff3ac3586a78778b69a84b0bbd9b8ec9b2347f27", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -791,7 +791,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n                     Some(&variant.memory_index[..]))\n             }\n             // Can we use one of the fields in this tuple?\n-            (&Univariant { ref variant, .. }, &ty::TyTuple(tys)) => {\n+            (&Univariant { ref variant, .. }, &ty::TyTuple(tys, _)) => {\n                 Struct::non_zero_field_paths(infcx, tys.iter().cloned(),\n                     Some(&variant.memory_index[..]))\n             }\n@@ -1157,7 +1157,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Univariant { variant: st, non_zero: false }\n             }\n \n-            ty::TyTuple(tys) => {\n+            ty::TyTuple(tys, _) => {\n                 // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked.\n                 // See the univariant case below to learn how.\n                 let st = Struct::new(dl,"}, {"sha": "c9ae3b3df028c80ddb07bf7034087ed4f0c36dc5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -197,6 +197,17 @@ impl AssociatedItem {\n             AssociatedKind::Type => Def::AssociatedTy(self.def_id),\n         }\n     }\n+\n+    /// Tests whether the associated item admits a non-trivial implementation\n+    /// for !\n+    pub fn relevant_for_never<'tcx>(&self) -> bool {\n+        match self.kind {\n+            AssociatedKind::Const => true,\n+            AssociatedKind::Type => true,\n+            // FIXME(canndrew): Be more thorough here, check if any argument is uninhabited.\n+            AssociatedKind::Method => !self.method_has_self_argument,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable)]\n@@ -1603,7 +1614,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             _ if tys.references_error() => tcx.types.err,\n             0 => tcx.types.bool,\n             1 => tys[0],\n-            _ => tcx.intern_tup(&tys[..])\n+            _ => tcx.intern_tup(&tys[..], false)\n         };\n \n         let old = tcx.adt_sized_constraint.borrow().get(&self.did).cloned();\n@@ -1638,7 +1649,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 vec![ty]\n             }\n \n-            TyTuple(ref tys) => {\n+            TyTuple(ref tys, _) => {\n                 match tys.last() {\n                     None => vec![],\n                     Some(ty) => self.sized_constraint_for_ty(tcx, stack, ty)\n@@ -1652,7 +1663,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                        .subst(tcx, substs);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n                        ty, adt_ty);\n-                if let ty::TyTuple(ref tys) = adt_ty.sty {\n+                if let ty::TyTuple(ref tys, _) = adt_ty.sty {\n                     tys.iter().flat_map(|ty| {\n                         self.sized_constraint_for_ty(tcx, stack, ty)\n                     }).collect()\n@@ -2010,6 +2021,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n+        self.associated_items(did).any(|item| {\n+            item.relevant_for_never()\n+        })\n+    }\n+\n     pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n         self.custom_coerce_unsized_kinds.memoize(did, || {\n             let (kind, src) = if did.krate != LOCAL_CRATE {"}, {"sha": "adedf78bba7c013e922cbc40cb89fcbaf67e9ced", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -447,10 +447,11 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_slice(t))\n         }\n \n-        (&ty::TyTuple(as_), &ty::TyTuple(bs)) =>\n+        (&ty::TyTuple(as_, a_defaulted), &ty::TyTuple(bs, b_defaulted)) =>\n         {\n             if as_.len() == bs.len() {\n-                Ok(tcx.mk_tup(as_.iter().zip(bs).map(|(a, b)| relation.relate(a, b)))?)\n+                let defaulted = a_defaulted || b_defaulted;\n+                Ok(tcx.mk_tup(as_.iter().zip(bs).map(|(a, b)| relation.relate(a, b)), defaulted)?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(\n                     expected_found(relation, &as_.len(), &bs.len())))"}, {"sha": "aa74e7cc0d0430c809f0195b34fcf98a4bdc2170", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -474,7 +474,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n             ty::TyDynamic(ref trait_ty, ref region) =>\n                 ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n-            ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n+            ty::TyTuple(ts, defaulted) => ty::TyTuple(ts.fold_with(folder), defaulted),\n             ty::TyFnDef(def_id, substs, f) => {\n                 ty::TyFnDef(def_id,\n                             substs.fold_with(folder),\n@@ -511,7 +511,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyAdt(_, substs) => substs.visit_with(visitor),\n             ty::TyDynamic(ref trait_ty, ref reg) =>\n                 trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n-            ty::TyTuple(ts) => ts.visit_with(visitor),\n+            ty::TyTuple(ts, _) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs, ref f) => {\n                 substs.visit_with(visitor) || f.visit_with(visitor)\n             }"}, {"sha": "9bba4c6e37a69dda4b77460bd6a0f5e5fd4b6d22", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -151,7 +151,11 @@ pub enum TypeVariants<'tcx> {\n     TyNever,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(&'tcx Slice<Ty<'tcx>>),\n+    /// The bool indicates whether this is a unit tuple and was created by\n+    /// defaulting a diverging type variable with feature(never_type) disabled.\n+    /// It's only purpose is for raising future-compatibility warnings for when\n+    /// diverging type variables start defaulting to ! instead of ().\n+    TyTuple(&'tcx Slice<Ty<'tcx>>, bool),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n@@ -961,7 +965,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_nil(&self) -> bool {\n         match self.sty {\n-            TyTuple(ref tys) => tys.is_empty(),\n+            TyTuple(ref tys, _) => tys.is_empty(),\n             _ => false\n         }\n     }\n@@ -973,6 +977,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    // Test whether this is a `()` which was produced by defaulting a\n+    // diverging type variable with feature(never_type) disabled.\n+    pub fn is_defaulted_unit(&self) -> bool {\n+        match self.sty {\n+            TyTuple(_, true) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Checks whether a type is visibly uninhabited from a particular module.\n     /// # Example\n     /// ```rust\n@@ -1355,7 +1368,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TySlice(_) |\n             TyRawPtr(_) |\n             TyNever |\n-            TyTuple(_) |\n+            TyTuple(..) |\n             TyParam(_) |\n             TyInfer(_) |\n             TyError => {"}, {"sha": "b01b77bbcf8a5c5e184b9a03ab06df54e037f2b9", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // Don't use `struct_variant`, this may be a univariant enum.\n                 adt.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n             }\n-            (&TyTuple(ref v), None) => v.get(i).cloned(),\n+            (&TyTuple(ref v, _), None) => v.get(i).cloned(),\n             _ => None\n         }\n     }\n@@ -466,8 +466,9 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n                     self.def_id(d);\n                 }\n             }\n-            TyTuple(tys) => {\n+            TyTuple(tys, defaulted) => {\n                 self.hash(tys.len());\n+                self.hash(defaulted);\n             }\n             TyParam(p) => {\n                 self.hash(p.idx);\n@@ -675,7 +676,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                                seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n                                                -> Representability {\n             match ty.sty {\n-                TyTuple(ref ts) => {\n+                TyTuple(ref ts, _) => {\n                     find_nonrepresentable(tcx, sp, seen, ts.iter().cloned())\n                 }\n                 // Fixed-length vectors."}, {"sha": "01f31e5024c0dfeaf258100b77b17e136193a493", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -112,7 +112,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyClosure(_, ref substs) => {\n             stack.extend(substs.substs.types().rev());\n         }\n-        ty::TyTuple(ts) => {\n+        ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());\n         }\n         ty::TyFnDef(_, substs, ref ft) => {"}, {"sha": "8a5bd6862cf4552c099b431fa344c81142dc7876", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n                 }\n \n-                ty::TyTuple(ref tys) => {\n+                ty::TyTuple(ref tys, _) => {\n                     if let Some((_last, rest)) = tys.split_last() {\n                         for elem in rest {\n                             self.require_sized(elem, traits::TupleElem);"}, {"sha": "5d6ee1a277a5f88049c9d68a33dc1f462a76066a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -156,7 +156,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args) = substs.type_at(1).sty {\n+        if let TyTuple(ref args, _) = substs.type_at(1).sty {\n             return fn_sig(f, args, false, projection_ty);\n         }\n     }\n@@ -724,7 +724,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 write!(f, \"{}\", tm)\n             }\n             TyNever => write!(f, \"!\"),\n-            TyTuple(ref tys) => {\n+            TyTuple(ref tys, _) => {\n                 write!(f, \"(\")?;\n                 let mut tys = tys.iter();\n                 if let Some(&ty) = tys.next() {"}, {"sha": "4d38b0d1705962afa24e58c81801073ea0569d67", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Result<Target, String> {\n         linker_is_gnu: true,\n         allow_asm: false,\n         obj_is_bitcode: true,\n+        is_like_emscripten: true,\n         max_atomic_width: Some(32),\n         post_link_args: vec![\"-s\".to_string(), \"ERROR_ON_UNDEFINED_SYMBOLS=1\".to_string()],\n         target_family: Some(\"unix\".to_string()),"}, {"sha": "d2b76b1d55a984c8d3abf9e476822ae698dee54e", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -330,6 +330,10 @@ pub struct TargetOptions {\n     /// Whether the target toolchain is like Android's. Only useful for compiling against Android.\n     /// Defaults to false.\n     pub is_like_android: bool,\n+    /// Whether the target toolchain is like Emscripten's. Only useful for compiling with\n+    /// Emscripten toolchain.\n+    /// Defaults to false.\n+    pub is_like_emscripten: bool,\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n     pub linker_is_gnu: bool,\n     /// The MinGW toolchain has a known issue that prevents it from correctly\n@@ -428,6 +432,7 @@ impl Default for TargetOptions {\n             is_like_solaris: false,\n             is_like_windows: false,\n             is_like_android: false,\n+            is_like_emscripten: false,\n             is_like_msvc: false,\n             linker_is_gnu: false,\n             allows_weak_linkage: true,\n@@ -603,6 +608,7 @@ impl Target {\n         key!(is_like_solaris, bool);\n         key!(is_like_windows, bool);\n         key!(is_like_msvc, bool);\n+        key!(is_like_emscripten, bool);\n         key!(is_like_android, bool);\n         key!(linker_is_gnu, bool);\n         key!(allows_weak_linkage, bool);\n@@ -767,6 +773,7 @@ impl ToJson for Target {\n         target_option_val!(is_like_solaris);\n         target_option_val!(is_like_windows);\n         target_option_val!(is_like_msvc);\n+        target_option_val!(is_like_emscripten);\n         target_option_val!(is_like_android);\n         target_option_val!(linker_is_gnu);\n         target_option_val!(allows_weak_linkage);"}, {"sha": "b1967fa8f37a7aea5c3052d48d45e24bfbbf4098", "filename": "src/librustc_back/target/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -24,6 +24,7 @@ pub fn target() -> Result<Target, String> {\n         linker_is_gnu: true,\n         allow_asm: false,\n         obj_is_bitcode: true,\n+        is_like_emscripten: true,\n         max_atomic_width: Some(32),\n         post_link_args: vec![\"-s\".to_string(), \"BINARYEN=1\".to_string(),\n                              \"-s\".to_string(), \"ERROR_ON_UNDEFINED_SYMBOLS=1\".to_string()],"}, {"sha": "dbab3bca52b4eccc5caba872e2d2d476de468cdf", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -423,7 +423,7 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n     };\n \n     match parent_ty.sty {\n-        ty::TyTuple(ref v) => {\n+        ty::TyTuple(ref v, _) => {\n             let tuple_idx = match *origin_field_name {\n                 mc::PositionalField(tuple_idx) => tuple_idx,\n                 mc::NamedField(_) =>"}, {"sha": "d2f744bde2d63d33444202a38a1515d3fec1ae50", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -713,7 +713,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx).collect();\n                 self.open_drop_for_tuple(c, &tys)\n             }\n-            ty::TyTuple(tys) => {\n+            ty::TyTuple(tys, _) => {\n                 self.open_drop_for_tuple(c, tys)\n             }\n             ty::TyAdt(def, _) if def.is_box() => {"}, {"sha": "7a64ff7114a7eaba36871218c566db2e58c54c2e", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -721,7 +721,7 @@ fn pat_constructors(_cx: &mut MatchCheckCtxt,\n fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n     debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs) => fs.len(),\n+        ty::TyTuple(ref fs, _) => fs.len(),\n         ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n             Slice(length) => length,\n             ConstantValue(_) => 0,\n@@ -745,7 +745,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n {\n     debug!(\"constructor_sub_pattern_tys({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n+        ty::TyTuple(ref fs, _) => fs.into_iter().map(|t| *t).collect(),\n         ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n             Slice(length) => repeat(ty).take(length).collect(),\n             ConstantValue(_) => vec![],"}, {"sha": "609fb3e39d62cc8406987ca1ebd8e6fffb3d0e03", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -342,7 +342,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             PatKind::Tuple(ref subpatterns, ddpos) => {\n                 let ty = self.tables.node_id_to_type(pat.id);\n                 match ty.sty {\n-                    ty::TyTuple(ref tys) => {\n+                    ty::TyTuple(ref tys, _) => {\n                         let subpatterns =\n                             subpatterns.iter()\n                                        .enumerate_and_adjust(tys.len(), ddpos)"}, {"sha": "5481de1811d78b91b411b6b470b288bec54dc154", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_pair(&self, ty1: Ty<'tcx>, ty2: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.intern_tup(&[ty1, ty2])\n+        self.infcx.tcx.intern_tup(&[ty1, ty2], false)\n     }\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n@@ -803,8 +803,8 @@ fn walk_ty() {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n         let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty]);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty]);\n+        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty], false);\n+        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty], false);\n         let walked: Vec<_> = tup2_ty.walk().collect();\n         assert_eq!(walked,\n                    [tup2_ty, tup1_ty, int_ty, uint_ty, int_ty, uint_ty, tup1_ty, int_ty,\n@@ -818,8 +818,8 @@ fn walk_ty_skip_subtree() {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n         let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty]);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty]);\n+        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty], false);\n+        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty], false);\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree."}, {"sha": "8fb1740e66eacbfccf65cd8991bcd67aaea28130", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -219,6 +219,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(LIFETIME_UNDERSCORE),\n             reference: \"issue #36892 <https://github.com/rust-lang/rust/issues/36892>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(RESOLVE_TRAIT_ON_DEFAULTED_UNIT),\n+            reference: \"issue #39216 <https://github.com/rust-lang/rust/issues/39216>\",\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(SAFE_EXTERN_STATICS),\n             reference: \"issue #36247 <https://github.com/rust-lang/rust/issues/35112>\","}, {"sha": "e42e038ea4d6c5a53779943ccb140522a9e3f442", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -532,7 +532,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                            consider using a `*const libc::c_char`\")\n             }\n \n-            ty::TyTuple(_) => {\n+            ty::TyTuple(..) => {\n                 FfiUnsafe(\"found Rust tuple type in foreign module; \\\n                            consider using a struct instead\")\n             }"}, {"sha": "28ce9126019ebdebb86da7436e62674b52e30474", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -141,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let t = cx.tables.expr_ty(&expr);\n         let warned = match t.sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => return,\n+            ty::TyTuple(ref tys, _) if tys.is_empty() => return,\n             ty::TyNever => return,\n             ty::TyBool => return,\n             ty::TyAdt(def, _) => {"}, {"sha": "81a4f7c93b6e91abe2eec44da15ef705b8dbccb9", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -584,7 +584,7 @@ impl<'a> CrateLoader<'a> {\n         use proc_macro::TokenStream;\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n-        use syntax_ext::deriving::custom::CustomDerive;\n+        use syntax_ext::deriving::custom::ProcMacroDerive;\n         use syntax_ext::proc_macro_impl::AttrProcMacro;\n \n         let path = match dylib {\n@@ -616,8 +616,8 @@ impl<'a> CrateLoader<'a> {\n                                       expand: fn(TokenStream) -> TokenStream,\n                                       attributes: &[&'static str]) {\n                 let attrs = attributes.iter().cloned().map(Symbol::intern).collect();\n-                let derive = SyntaxExtension::CustomDerive(\n-                    Box::new(CustomDerive::new(expand, attrs))\n+                let derive = SyntaxExtension::ProcMacroDerive(\n+                    Box::new(ProcMacroDerive::new(expand, attrs))\n                 );\n                 self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n             }"}, {"sha": "dad1d713168cd43e39c66608a1909ba8440d9f4c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = self.source_info(span);\n         let bool_ty = self.hir.bool_ty();\n         if self.hir.check_overflow() && op.is_checkable() && ty.is_integral() {\n-            let result_tup = self.hir.tcx().intern_tup(&[ty, bool_ty]);\n+            let result_tup = self.hir.tcx().intern_tup(&[ty, bool_ty], false);\n             let result_value = self.temp(result_tup);\n \n             self.cfg.push_assign(block, source_info,"}, {"sha": "529fe564af02bc54e4dce16e0e046298fe381816", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         })\n                     }\n                 }\n-                ty::TyTuple(tys) => {\n+                ty::TyTuple(tys, _) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {"}, {"sha": "4679b6be88b6f0835a06e410c37af1082423455a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -559,7 +559,7 @@ impl<'a> Resolver<'a> {\n                       \"an `extern crate` loading macros must be at the crate root\");\n         } else if !self.use_extern_macros && !used &&\n                   self.session.cstore.dep_kind(module.def_id().unwrap().krate).macros_only() {\n-            let msg = \"custom derive crates and `#[no_link]` crates have no effect without \\\n+            let msg = \"proc macro crates and `#[no_link]` crates have no effect without \\\n                        `#[macro_use]`\";\n             self.session.span_warn(item.span, msg);\n             used = true; // Avoid the normal unused extern crate warning"}, {"sha": "ea3112b2463f8ba27007e6e14405c475ef93e153", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -250,6 +250,32 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n         result\n     }\n+\n+    fn resolve_builtin_macro(&mut self, tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        match self.builtin_macros.get(&tname).cloned() {\n+            Some(binding) => Ok(binding.get_macro(self)),\n+            None => Err(Determinacy::Undetermined),\n+        }\n+    }\n+\n+    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        let ast::Path { span, .. } = *path;\n+        match self.resolve_macro(scope, path, false) {\n+            Ok(ext) => match *ext {\n+                SyntaxExtension::BuiltinDerive(..) |\n+                SyntaxExtension::ProcMacroDerive(..) => Ok(ext),\n+                _ => Err(Determinacy::Determined),\n+            },\n+            Err(Determinacy::Undetermined) if force => {\n+                let msg = format!(\"cannot find derive macro `{}` in this scope\", path);\n+                let mut err = self.session.struct_span_err(span, &msg);\n+                err.emit();\n+                Err(Determinacy::Determined)\n+            },\n+            Err(err) => Err(err),\n+        }\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "dbc8bca548b769a1334f15facf53288a0a7e8845", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -639,7 +639,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let names = resolutions.iter().filter_map(|(&(ref i, _), resolution)| {\n                     if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n-                        NameResolution { binding: Some(_), .. } => Some(&i.name),\n+                        NameResolution { binding: Some(name_binding), .. } => {\n+                            match name_binding.kind {\n+                                NameBindingKind::Import { binding, .. } => {\n+                                    match binding.kind {\n+                                        // Never suggest the name that has binding error\n+                                        // i.e. the name that cannot be previously resolved\n+                                        NameBindingKind::Def(Def::Err) => return None,\n+                                        _ => Some(&i.name),\n+                                    }\n+                                },\n+                                _ => Some(&i.name),\n+                            }\n+                        },\n                         NameResolution { single_imports: SingleImports::None, .. } => None,\n                         _ => Some(&i.name),\n                     }"}, {"sha": "41f91a1d2acc17ac234f00824cd88655868bde26", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1440,7 +1440,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                             }.lower(self.tcx));\n                         }\n                     }\n-                    ty::TyTuple(_) => {}\n+                    ty::TyTuple(..) => {}\n                     _ => span_bug!(ex.span,\n                                    \"Expected struct or tuple type, found {:?}\",\n                                    ty),"}, {"sha": "ebb33a12c870397fe2dbd2331cb95de79cd0f67d", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -430,6 +430,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                               -> Option<TypeRefData> {\n         self.lookup_ref_id(trait_ref.ref_id).and_then(|def_id| {\n             let span = trait_ref.path.span;\n+            if generated_code(span) {\n+                return None;\n+            }\n             let sub_span = self.span_utils.sub_span_for_type_name(span).or(Some(span));\n             filter!(self.span_utils, sub_span, span, None);\n             Some(TypeRefData {"}, {"sha": "a476b1d29e5fb823ef8ffb9a605c2ab474210ba5", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -367,7 +367,7 @@ impl FnType {\n             assert!(!sig.variadic && extra_args.is_empty());\n \n             match sig.inputs().last().unwrap().sty {\n-                ty::TyTuple(ref tupled_arguments) => {\n+                ty::TyTuple(ref tupled_arguments, _) => {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n                     &tupled_arguments[..]\n                 }"}, {"sha": "bc1e07e708c248e5dc051b450ec4fa6d5230ff85", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -72,7 +72,7 @@ pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n                 monomorphize::field_ty(cx.tcx(), substs, f)\n             }).collect::<Vec<_>>()\n         },\n-        ty::TyTuple(fields) => fields.to_vec(),\n+        ty::TyTuple(fields, _) => fields.to_vec(),\n         ty::TyClosure(def_id, substs) => {\n             if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n             substs.upvar_tys(def_id, cx.tcx()).collect()"}, {"sha": "4ddf8a883bc488781efd48a31d5758eefb7460b0", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -29,6 +29,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n+use rustc_back::PanicStrategy;\n use rustc_incremental::IncrementalHashesMap;\n \n use std::ascii;\n@@ -714,6 +715,11 @@ fn link_natively(sess: &Session,\n         cmd.arg(root.join(obj));\n     }\n \n+    if sess.target.target.options.is_like_emscripten &&\n+       sess.panic_strategy() == PanicStrategy::Abort {\n+        cmd.args(&[\"-s\", \"DISABLE_EXCEPTION_CATCHING=1\"]);\n+    }\n+\n     {\n         let mut linker = trans.linker_info.to_linker(&mut cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,"}, {"sha": "c6b86c6ba48deed1ee9f5a775409b5e0c8f6fbb2", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -485,7 +485,7 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n         }\n     };\n     let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-    let tuple_input_ty = tcx.intern_tup(sig.inputs());\n+    let tuple_input_ty = tcx.intern_tup(sig.inputs(), false);\n     let sig = tcx.mk_fn_sig(\n         [bare_fn_ty_maybe_ref, tuple_input_ty].iter().cloned(),\n         sig.output(),"}, {"sha": "89f5c00e9c11a6c6bf1e911f6c6e3e61880a75f9", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -823,7 +823,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n             }\n         }\n-        ty::TyTuple(args) => {\n+        ty::TyTuple(args, _) => {\n             for arg in args {\n                 let arg = glue::get_drop_glue_type(scx, arg);\n                 if scx.type_needs_drop(arg) {"}, {"sha": "725b0e06e30888fbbab359915defb8c38da90169", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -93,7 +93,7 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                 }\n             }))\n         }\n-        ty::TyTuple(tys) => {\n+        ty::TyTuple(tys, _) => {\n             if tys.len() != 2 {\n                 return None;\n             }"}, {"sha": "c83e2f4854bf5cda8cbfd195df2b58d6462b0a84", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -383,7 +383,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // return type\n     signature_metadata.push(match signature.output().sty {\n-        ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n+        ty::TyTuple(ref tys, _) if tys.is_empty() => ptr::null_mut(),\n         _ => type_metadata(cx, signature.output(), span)\n     });\n \n@@ -528,7 +528,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyFloat(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyTuple(ref elements) if elements.is_empty() => {\n+        ty::TyTuple(ref elements, _) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::TyArray(typ, len) => {\n@@ -603,7 +603,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     usage_site_span).finalize(cx)\n             }\n         },\n-        ty::TyTuple(ref elements) => {\n+        ty::TyTuple(ref elements, _) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &elements[..],\n@@ -706,7 +706,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (name, encoding) = match t.sty {\n         ty::TyNever => (\"!\", DW_ATE_unsigned),\n-        ty::TyTuple(ref elements) if elements.is_empty() =>\n+        ty::TyTuple(ref elements, _) if elements.is_empty() =>\n             (\"()\", DW_ATE_unsigned),\n         ty::TyBool => (\"bool\", DW_ATE_boolean),\n         ty::TyChar => (\"char\", DW_ATE_unsigned_char),"}, {"sha": "501f891befa8dafa279002972a0610e9571ac39d", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -295,7 +295,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         signature.push(match sig.output().sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n+            ty::TyTuple(ref tys, _) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP)\n         });\n \n@@ -311,7 +311,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n \n         if abi == Abi::RustCall && !sig.inputs().is_empty() {\n-            if let ty::TyTuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n+            if let ty::TyTuple(args, _) = sig.inputs()[sig.inputs().len() - 1].sty {\n                 for &argument_type in args {\n                     signature.push(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP));\n                 }"}, {"sha": "018bbb6e97d345167e46c9edfec272fa803f58f4", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -48,7 +48,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_item_name(cx, def.did, qualified, output);\n             push_type_params(cx, substs, output);\n         },\n-        ty::TyTuple(component_types) => {\n+        ty::TyTuple(component_types, _) => {\n             output.push('(');\n             for &component_type in component_types {\n                 push_debuginfo_type_name(cx, component_type, true, output);"}, {"sha": "fdefd37549ced1251245822615473da33c8f46ab", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -442,7 +442,7 @@ fn drop_structural_ty<'a, 'tcx>(\n             cx = tvec::slice_for_each(&cx, ptr.llval, unit_ty, ptr.llextra,\n                 |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n         }\n-        ty::TyTuple(ref args) => {\n+        ty::TyTuple(ref args, _) => {\n             for (i, arg) in args.iter().enumerate() {\n                 let llfld_a = ptr.trans_field_ptr(&cx, i);\n                 drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg));"}, {"sha": "027779aca63e4e03f1432873278301674aedebc2", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -695,7 +695,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let tuple = self.trans_operand(bcx, operand);\n \n         let arg_types = match tuple.ty.sty {\n-            ty::TyTuple(ref tys) => tys,\n+            ty::TyTuple(ref tys, _) => tys,\n             _ => span_bug!(self.mir.span,\n                            \"bad final argument to \\\"rust-call\\\" fn {:?}\", tuple.ty)\n         };"}, {"sha": "c8a680d25195a023d823328b35b0325892ccec61", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -735,7 +735,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let rhs = self.const_operand(rhs, span)?;\n                 let ty = lhs.ty;\n                 let val_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                let binop_ty = tcx.intern_tup(&[val_ty, tcx.types.bool]);\n+                let binop_ty = tcx.intern_tup(&[val_ty, tcx.types.bool], false);\n                 let (lhs, rhs) = (lhs.llval, rhs.llval);\n                 assert!(!ty.is_fp());\n "}, {"sha": "8a0a97a56343955c8fd258b09097da0b76912171", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -384,7 +384,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // individual LLVM function arguments.\n \n             let tupled_arg_tys = match arg_ty.sty {\n-                ty::TyTuple(ref tys) => tys,\n+                ty::TyTuple(ref tys, _) => tys,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n "}, {"sha": "81b241b4851756a2441c572254900f3a1331afd3", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -402,7 +402,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                                              lhs.immediate(), rhs.immediate(),\n                                                              lhs.ty);\n                 let val_ty = op.ty(bcx.tcx(), lhs.ty, rhs.ty);\n-                let operand_ty = bcx.tcx().intern_tup(&[val_ty, bcx.tcx().types.bool]);\n+                let operand_ty = bcx.tcx().intern_tup(&[val_ty, bcx.tcx().types.bool], false);\n                 let operand = OperandRef {\n                     val: result,\n                     ty: operand_ty"}, {"sha": "04a6cb27501b3eab4000d02358d4d2103ca67948", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -409,7 +409,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 self.push_def_path(adt_def.did, output);\n                 self.push_type_params(substs, iter::empty(), output);\n             },\n-            ty::TyTuple(component_types) => {\n+            ty::TyTuple(component_types, _) => {\n                 output.push('(');\n                 for &component_type in component_types {\n                     self.push_type_name(component_type, output);"}, {"sha": "87af3b6c5e1535bc4748624e367d36b73deb446b", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -74,7 +74,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::array(&llty, size)\n         }\n \n-        ty::TyTuple(ref tys) if tys.is_empty() => {\n+        ty::TyTuple(ref tys, _) if tys.is_empty() => {\n             Type::nil(cx)\n         }\n \n@@ -276,7 +276,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n         let sig = cx.tcx().erase_late_bound_regions_and_normalize(&f.sig);\n         FnType::new(cx, f.abi, &sig, &[]).llvm_type(cx).ptr_to()\n       }\n-      ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n+      ty::TyTuple(ref tys, _) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {\n           adt::type_of(cx, t)\n       }"}, {"sha": "a3373f6da28526b17e2ae4f1bc65777404ad689e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -421,7 +421,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             span: output_span\n         };\n \n-        (self.tcx().mk_ty(ty::TyTuple(inputs)), output_binding)\n+        (self.tcx().mk_ty(ty::TyTuple(inputs, false)), output_binding)\n     }\n \n     /// Instantiates the path for the given trait reference, assuming that it's\n@@ -1170,7 +1170,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.types.never\n             },\n             hir::TyTup(ref fields) => {\n-                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)))\n+                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)), false)\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);"}, {"sha": "feed5752cf8fb6c3b92bbeb8dd7ccfb0eb93229a", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut expected_len = elements.len();\n                 if ddpos.is_some() {\n                     // Require known type only when `..` is present\n-                    if let ty::TyTuple(ref tys) =\n+                    if let ty::TyTuple(ref tys, _) =\n                             self.structurally_resolved_type(pat.span, expected).sty {\n                         expected_len = tys.len();\n                     }\n@@ -176,7 +176,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     //       from all tuple elements isn't trivial.\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n-                let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys));\n+                let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys, false));\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n                 for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n                     self.check_pat(elem, &element_tys[i]);"}, {"sha": "7979edbf5e27a1c7c78536a1e8272b6662680db0", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table.\n         fn_ty.sig.0 = self.tcx.mk_fn_sig(\n-            iter::once(self.tcx.intern_tup(fn_ty.sig.skip_binder().inputs())),\n+            iter::once(self.tcx.intern_tup(fn_ty.sig.skip_binder().inputs(), false)),\n             fn_ty.sig.skip_binder().output(),\n             fn_ty.sig.variadic()\n         );\n@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                arg_param_ty);\n \n         let input_tys = match arg_param_ty.sty {\n-            ty::TyTuple(tys) => tys.into_iter(),\n+            ty::TyTuple(tys, _) => tys.into_iter(),\n             _ => {\n                 return None;\n             }"}, {"sha": "f701bc3220848d452b0b51aa913751d676ab9137", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -489,7 +489,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n             Ok(())\n         }\n \n-        ty::TyTuple(tys) => {\n+        ty::TyTuple(tys, _) => {\n             for ty in tys {\n                 iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n             }"}, {"sha": "cb4e85e842c2a8f3727cfad82a312fcfb7a3aecf", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -87,7 +87,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n             \"cxchg\" | \"cxchgweak\" => (1, vec![tcx.mk_mut_ptr(param(ccx, 0)),\n                                               param(ccx, 0),\n                                               param(ccx, 0)],\n-                                      tcx.intern_tup(&[param(ccx, 0), tcx.types.bool])),\n+                                      tcx.intern_tup(&[param(ccx, 0), tcx.types.bool], false)),\n             \"load\" => (1, vec![tcx.mk_imm_ptr(param(ccx, 0))],\n                        param(ccx, 0)),\n             \"store\" => (1, vec![tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)],\n@@ -272,7 +272,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n \n             \"add_with_overflow\" | \"sub_with_overflow\"  | \"mul_with_overflow\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)],\n-                tcx.intern_tup(&[param(ccx, 0), tcx.types.bool])),\n+                tcx.intern_tup(&[param(ccx, 0), tcx.types.bool], false)),\n \n             \"unchecked_div\" | \"unchecked_rem\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n@@ -420,7 +420,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n \n     match *expected {\n         Void => match t.sty {\n-            ty::TyTuple(ref v) if v.is_empty() => {},\n+            ty::TyTuple(ref v, _) if v.is_empty() => {},\n             _ => simple_error(&format!(\"`{}`\", t), \"()\"),\n         },\n         // (The width we pass to LLVM doesn't concern the type checker.)\n@@ -494,7 +494,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         }\n         Aggregate(_flatten, ref expected_contents) => {\n             match t.sty {\n-                ty::TyTuple(contents) => {\n+                ty::TyTuple(contents, _) => {\n                     if contents.len() != expected_contents.len() {\n                         simple_error(&format!(\"tuple with length {}\", contents.len()),\n                                      &format!(\"tuple with length {}\", expected_contents.len()));"}, {"sha": "c4a366c2f17fe1ed336ac4bab56cd6c31a68551e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1947,7 +1947,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Apply \"fallbacks\" to some types\n-    /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n+    /// unconstrained types get replaced with ! or  () (depending on whether\n+    /// feature(never_type) is enabled), unconstrained ints with i32, and\n+    /// unconstrained floats with f64.\n     fn default_type_parameters(&self) {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n@@ -2408,7 +2410,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let err_inputs = match tuple_arguments {\n                 DontTupleArguments => err_inputs,\n-                TupleArguments => vec![self.tcx.intern_tup(&err_inputs[..])],\n+                TupleArguments => vec![self.tcx.intern_tup(&err_inputs[..], false)],\n             };\n \n             self.check_argument_types(sp, &err_inputs[..], &[], args_no_rcvr,\n@@ -2505,16 +2507,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let formal_tys = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n             match tuple_type.sty {\n-                ty::TyTuple(arg_types) if arg_types.len() != args.len() => {\n+                ty::TyTuple(arg_types, _) if arg_types.len() != args.len() => {\n                     parameter_count_error(tcx.sess, sp_args, arg_types.len(), args.len(),\n                                           \"E0057\", false, def_span);\n                     expected_arg_tys = &[];\n                     self.err_args(args.len())\n                 }\n-                ty::TyTuple(arg_types) => {\n+                ty::TyTuple(arg_types, _) => {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n                         Some(&ty) => match ty.sty {\n-                            ty::TyTuple(ref tys) => &tys,\n+                            ty::TyTuple(ref tys, _) => &tys,\n                             _ => &[]\n                         },\n                         None => &[]\n@@ -3072,7 +3074,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     })\n                 }\n-                ty::TyTuple(ref v) => {\n+                ty::TyTuple(ref v, _) => {\n                     tuple_like = true;\n                     v.get(idx.node).cloned()\n                 }\n@@ -3864,7 +3866,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprTup(ref elts) => {\n             let flds = expected.only_has_type(self).and_then(|ty| {\n                 match ty.sty {\n-                    ty::TyTuple(ref flds) => Some(&flds[..]),\n+                    ty::TyTuple(ref flds, _) => Some(&flds[..]),\n                     _ => None\n                 }\n             });\n@@ -3882,7 +3884,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 t\n             });\n-            let tuple = tcx.mk_tup(elt_ts_iter);\n+            let tuple = tcx.mk_tup(elt_ts_iter, false);\n             if tuple.references_error() {\n                 tcx.types.err\n             } else {\n@@ -3923,7 +3925,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               },\n                               base_t);\n                           // Try to give some advice about indexing tuples.\n-                          if let ty::TyTuple(_) = base_t.sty {\n+                          if let ty::TyTuple(..) = base_t.sty {\n                               let mut needs_note = true;\n                               // If the index is an integer, we can show the actual\n                               // fixed expression:"}, {"sha": "860f6d98370ad1926a192e20b1c164c1f99f9c0b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n-            ty::TyTuple(subtys) => {\n+            ty::TyTuple(subtys, _) => {\n                 for &subty in subtys {\n                     self.add_constraints_from_ty(generics, subty, variance);\n                 }"}, {"sha": "dc2aa1f138d62d04eb74b385b1875aa9feb02c75", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -655,7 +655,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n         Some(did) if cx.tcx.lang_items.fn_trait_kind(did).is_some() => {\n             assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n-                ty::TyTuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n+                ty::TyTuple(ref tys, _) => tys.iter().map(|t| t.clean(cx)).collect(),\n                 _ => {\n                     return PathParameters::AngleBracketed {\n                         lifetimes: lifetimes,\n@@ -667,7 +667,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n             let output = None;\n             // FIXME(#20299) return type comes from a projection now\n             // match types[1].sty {\n-            //     ty::TyTuple(ref v) if v.is_empty() => None, // -> ()\n+            //     ty::TyTuple(ref v, _) if v.is_empty() => None, // -> ()\n             //     _ => Some(types[1].clean(cx))\n             // };\n             PathParameters::Parenthesized {\n@@ -710,7 +710,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         // collect any late bound regions\n         let mut late_bounds = vec![];\n         for ty_s in self.input_types().skip(1) {\n-            if let ty::TyTuple(ts) = ty_s.sty {\n+            if let ty::TyTuple(ts, _) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {\n                         if let &ty::Region::ReLateBound(..) = *reg {\n@@ -1895,7 +1895,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     Never\n                 }\n             }\n-            ty::TyTuple(ref t) => Tuple(t.clean(cx)),\n+            ty::TyTuple(ref t, _) => Tuple(t.clean(cx)),\n \n             ty::TyProjection(ref data) => data.clean(cx),\n "}, {"sha": "84f69cd35045c91fd833f4dce04235ecd14048d6", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -193,7 +193,7 @@ pub fn main_args(args: &[String]) -> isize {\n     nightly_options::check_nightly_options(&matches, &opts());\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(&args[0]);\n+        usage(\"rustdoc\");\n         return 0;\n     } else if matches.opt_present(\"version\") {\n         rustc_driver::version(\"rustdoc\", &matches);"}, {"sha": "35c388ba076cef69d9c2eb32608275ff884d3a79", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -399,7 +399,7 @@ impl ExactSizeIterator for EscapeDefault {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDefault {}\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for EscapeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"EscapeDefault { .. }\")"}, {"sha": "ffb7a1a1fc15f2b0acd6ad439c9d407fce602259", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1283,7 +1283,7 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, K: Debug, V: Debug> fmt::Debug for Iter<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_list()\n@@ -1318,7 +1318,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, K: Debug, V: Debug> fmt::Debug for Keys<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_list()\n@@ -1341,7 +1341,7 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, K: Debug, V: Debug> fmt::Debug for Values<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_list()\n@@ -1591,7 +1591,7 @@ impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, K, V> fmt::Debug for IterMut<'a, K, V>\n     where K: fmt::Debug,\n           V: fmt::Debug,\n@@ -1626,7 +1626,7 @@ impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K, V> FusedIterator for IntoIter<K, V> {}\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: Debug, V: Debug> fmt::Debug for IntoIter<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_list()\n@@ -1704,7 +1704,7 @@ impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, K, V> fmt::Debug for ValuesMut<'a, K, V>\n     where K: fmt::Debug,\n           V: fmt::Debug,\n@@ -1739,7 +1739,7 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Drain<'a, K, V> {}\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, K, V> fmt::Debug for Drain<'a, K, V>\n     where K: fmt::Debug,\n           V: fmt::Debug,\n@@ -2227,7 +2227,7 @@ impl Default for RandomState {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for RandomState {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"RandomState { .. }\")"}, {"sha": "a3f7e13bbf9131615f369a5ee328947e1cdfc8b2", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -948,7 +948,7 @@ impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K> FusedIterator for Iter<'a, K> {}\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, K: fmt::Debug> fmt::Debug for Iter<'a, K> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_list()\n@@ -977,7 +977,7 @@ impl<K> ExactSizeIterator for IntoIter<K> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K> FusedIterator for IntoIter<K> {}\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let entries_iter = self.iter.inner.iter().map(|(k, _)| k);\n@@ -1007,7 +1007,7 @@ impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K> FusedIterator for Drain<'a, K> {}\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, K: fmt::Debug> fmt::Debug for Drain<'a, K> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let entries_iter = self.iter.inner.iter().map(|(k, _)| k);\n@@ -1050,7 +1050,7 @@ impl<'a, T, S> Iterator for Intersection<'a, T, S>\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, T, S> fmt::Debug for Intersection<'a, T, S>\n     where T: fmt::Debug + Eq + Hash,\n           S: BuildHasher,\n@@ -1109,7 +1109,7 @@ impl<'a, T, S> FusedIterator for Difference<'a, T, S>\n {\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, T, S> fmt::Debug for Difference<'a, T, S>\n     where T: fmt::Debug + Eq + Hash,\n           S: BuildHasher,\n@@ -1150,7 +1150,7 @@ impl<'a, T, S> FusedIterator for SymmetricDifference<'a, T, S>\n {\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, T, S> fmt::Debug for SymmetricDifference<'a, T, S>\n     where T: fmt::Debug + Eq + Hash,\n           S: BuildHasher,\n@@ -1176,7 +1176,7 @@ impl<'a, T, S> FusedIterator for Union<'a, T, S>\n {\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, T, S> fmt::Debug for Union<'a, T, S>\n     where T: fmt::Debug + Eq + Hash,\n           S: BuildHasher,"}, {"sha": "29f2ac6ab444c05463ac2eb6d87ded54ade44121", "filename": "src/libstd/env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -145,7 +145,7 @@ impl Iterator for Vars {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Vars {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Vars { .. }\")\n@@ -159,7 +159,7 @@ impl Iterator for VarsOs {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for VarsOs {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"VarsOs { .. }\")\n@@ -382,7 +382,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a> fmt::Debug for SplitPaths<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"SplitPaths { .. }\")\n@@ -665,7 +665,7 @@ impl DoubleEndedIterator for Args {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Args {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Args { .. }\")\n@@ -690,7 +690,7 @@ impl DoubleEndedIterator for ArgsOs {\n     fn next_back(&mut self) -> Option<OsString> { self.inner.next_back() }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for ArgsOs {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"ArgsOs { .. }\")"}, {"sha": "e5562d05f10ae92472aebb2a3fbe2c114f82f372", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -869,7 +869,7 @@ impl Metadata {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Metadata {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"Metadata\")"}, {"sha": "8cb7b2bda7554239a9e2684f51843ad96aae8167", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1450,7 +1450,7 @@ pub struct Chain<T, U> {\n     done_first: bool,\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<T: fmt::Debug, U: fmt::Debug> fmt::Debug for Chain<T, U> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"Chain\")"}, {"sha": "e16e8019b5f735fb6e2af5192363d2941bf6b869", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -282,7 +282,7 @@ impl Stdin {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Stdin {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Stdin { .. }\")\n@@ -321,7 +321,7 @@ impl<'a> BufRead for StdinLock<'a> {\n     fn consume(&mut self, n: usize) { self.inner.consume(n) }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a> fmt::Debug for StdinLock<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"StdinLock { .. }\")\n@@ -438,7 +438,7 @@ impl Stdout {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Stdout {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Stdout { .. }\")\n@@ -470,7 +470,7 @@ impl<'a> Write for StdoutLock<'a> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a> fmt::Debug for StdoutLock<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"StdoutLock { .. }\")\n@@ -573,7 +573,7 @@ impl Stderr {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Stderr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Stderr { .. }\")\n@@ -605,7 +605,7 @@ impl<'a> Write for StderrLock<'a> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a> fmt::Debug for StderrLock<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"StderrLock { .. }\")"}, {"sha": "4163187488e6544d378808bde18689977623edf3", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -98,7 +98,7 @@ impl BufRead for Empty {\n     fn consume(&mut self, _n: usize) {}\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Empty {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Empty { .. }\")\n@@ -141,7 +141,7 @@ impl Read for Repeat {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Repeat {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Repeat { .. }\")\n@@ -180,7 +180,7 @@ impl Write for Sink {\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Sink {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Sink { .. }\")"}, {"sha": "9bcecebf693d2e73265285260c3e9317bde5a7b6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -277,6 +277,7 @@\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n #![feature(panic_unwind)]\n+#![feature(peek)]\n #![feature(placement_in_syntax)]\n #![feature(prelude_import)]\n #![feature(pub_restricted)]"}, {"sha": "b0d2e3e4687b44c24e4fee5cf64a14b9109261c0", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -106,7 +106,10 @@ impl Iterator for LookupHost {\n     fn next(&mut self) -> Option<SocketAddr> { self.0.next() }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[unstable(feature = \"lookup_host\", reason = \"unsure about the returned \\\n+                                              iterator and returning socket \\\n+                                              addresses\",\n+           issue = \"27705\")]\n impl fmt::Debug for LookupHost {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"LookupHost { .. }\")"}, {"sha": "9bead22ef7f5e0516267712a326b3c465671e159", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -296,6 +296,29 @@ impl TcpStream {\n         self.0.write_timeout()\n     }\n \n+    /// Receives data on the socket from the remote adress to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(peek)]\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8000\")\n+    ///                        .expect(\"couldn't bind to address\");\n+    /// let mut buf = [0; 10];\n+    /// let len = stream.peek(&mut buf).expect(\"peek failed\");\n+    /// ```\n+    #[unstable(feature = \"peek\", issue = \"38980\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n     /// Sets the value of the `TCP_NODELAY` option on this socket.\n     ///\n     /// If set, this option disables the Nagle algorithm. This means that\n@@ -1406,4 +1429,35 @@ mod tests {\n             Err(e) => panic!(\"unexpected error {}\", e),\n         }\n     }\n+\n+    #[test]\n+    fn peek() {\n+        each_ip(&mut |addr| {\n+            let (txdone, rxdone) = channel();\n+\n+            let srv = t!(TcpListener::bind(&addr));\n+            let _t = thread::spawn(move|| {\n+                let mut cl = t!(srv.accept()).0;\n+                cl.write(&[1,3,3,7]).unwrap();\n+                t!(rxdone.recv());\n+            });\n+\n+            let mut c = t!(TcpStream::connect(&addr));\n+            let mut b = [0; 10];\n+            for _ in 1..3 {\n+                let len = c.peek(&mut b).unwrap();\n+                assert_eq!(len, 4);\n+            }\n+            let len = c.read(&mut b).unwrap();\n+            assert_eq!(len, 4);\n+\n+            t!(c.set_nonblocking(true));\n+            match c.peek(&mut b) {\n+                Ok(_) => panic!(\"expected error\"),\n+                Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+                Err(e) => panic!(\"unexpected error {}\", e),\n+            }\n+            t!(txdone.send(()));\n+        })\n+    }\n }"}, {"sha": "f452c75d389664ed90bf0da30aa2066ec12a7086", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -83,6 +83,30 @@ impl UdpSocket {\n         self.0.recv_from(buf)\n     }\n \n+    /// Receives data from the socket, without removing it from the queue.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n+    ///\n+    /// On success, returns the number of bytes peeked and the address from\n+    /// whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(peek)]\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let mut buf = [0; 10];\n+    /// let (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n+    ///                                         .expect(\"Didn't receive data\");\n+    /// ```\n+    #[unstable(feature = \"peek\", issue = \"38980\")]\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.0.peek_from(buf)\n+    }\n+\n     /// Sends data on the socket to the given address. On success, returns the\n     /// number of bytes written.\n     ///\n@@ -579,6 +603,37 @@ impl UdpSocket {\n         self.0.recv(buf)\n     }\n \n+    /// Receives data on the socket from the remote adress to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method will fail if the socket is not connected. The `connect` method\n+    /// will connect this socket to a remote address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(peek)]\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n+    /// let mut buf = [0; 10];\n+    /// match socket.peek(&mut buf) {\n+    ///     Ok(received) => println!(\"received {} bytes\", received),\n+    ///     Err(e) => println!(\"peek function failed: {:?}\", e),\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"peek\", issue = \"38980\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n     /// Moves this UDP socket into or out of nonblocking mode.\n     ///\n     /// On Unix this corresponds to calling fcntl, and on Windows this\n@@ -869,6 +924,48 @@ mod tests {\n         assert_eq!(b\"hello world\", &buf[..]);\n     }\n \n+    #[test]\n+    fn connect_send_peek_recv() {\n+        each_ip(&mut |addr, _| {\n+            let socket = t!(UdpSocket::bind(&addr));\n+            t!(socket.connect(addr));\n+\n+            t!(socket.send(b\"hello world\"));\n+\n+            for _ in 1..3 {\n+                let mut buf = [0; 11];\n+                let size = t!(socket.peek(&mut buf));\n+                assert_eq!(b\"hello world\", &buf[..]);\n+                assert_eq!(size, 11);\n+            }\n+\n+            let mut buf = [0; 11];\n+            let size = t!(socket.recv(&mut buf));\n+            assert_eq!(b\"hello world\", &buf[..]);\n+            assert_eq!(size, 11);\n+        })\n+    }\n+\n+    #[test]\n+    fn peek_from() {\n+        each_ip(&mut |addr, _| {\n+            let socket = t!(UdpSocket::bind(&addr));\n+            t!(socket.send_to(b\"hello world\", &addr));\n+\n+            for _ in 1..3 {\n+                let mut buf = [0; 11];\n+                let (size, _) = t!(socket.peek_from(&mut buf));\n+                assert_eq!(b\"hello world\", &buf[..]);\n+                assert_eq!(size, 11);\n+            }\n+\n+            let mut buf = [0; 11];\n+            let (size, _) = t!(socket.recv_from(&mut buf));\n+            assert_eq!(b\"hello world\", &buf[..]);\n+            assert_eq!(size, 11);\n+        })\n+    }\n+\n     #[test]\n     fn ttl() {\n         let ttl = 100;"}, {"sha": "68d4ca900195c5ed8c3161eaa5d9853942fb5500", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -73,7 +73,7 @@ pub enum c_void {\n     #[doc(hidden)] __variant2,\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for c_void {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"c_void\")"}, {"sha": "ac0d0d2afb80328042a8a3109c7cffa366e520b5", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -297,7 +297,7 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"AssertUnwindSafe\")"}, {"sha": "c16b97ebda5e3c2bd4a1d4a4ca055c6101077c50", "filename": "src/libstd/process.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -114,7 +114,7 @@ impl IntoInner<imp::Process> for Child {\n     fn into_inner(self) -> imp::Process { self.handle }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Child {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"Child\")\n@@ -160,7 +160,7 @@ impl FromInner<AnonPipe> for ChildStdin {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for ChildStdin {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"ChildStdin { .. }\")\n@@ -201,7 +201,7 @@ impl FromInner<AnonPipe> for ChildStdout {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for ChildStdout {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"ChildStdout { .. }\")\n@@ -242,7 +242,7 @@ impl FromInner<AnonPipe> for ChildStderr {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for ChildStderr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"ChildStderr { .. }\")\n@@ -696,7 +696,7 @@ impl FromInner<imp::Stdio> for Stdio {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Stdio {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Stdio { .. }\")\n@@ -959,10 +959,27 @@ impl Child {\n ///\n /// # Examples\n ///\n+/// Due to this function\u2019s behavior regarding destructors, a conventional way\n+/// to use the function is to extract the actual computation to another\n+/// function and compute the exit code from its return value:\n+///\n /// ```\n-/// use std::process;\n+/// use std::io::{self, Write};\n+///\n+/// fn run_app() -> Result<(), ()> {\n+///     // Application logic here\n+///     Ok(())\n+/// }\n ///\n-/// process::exit(0);\n+/// fn main() {\n+///     ::std::process::exit(match run_app() {\n+///        Ok(_) => 0,\n+///        Err(err) => {\n+///            writeln!(io::stderr(), \"error: {:?}\", err).unwrap();\n+///            1\n+///        }\n+///     });\n+/// }\n /// ```\n ///\n /// Due to [platform-specific behavior], the exit code for this example will be"}, {"sha": "fc4fd4ce92b1b6fbe6f37e8fc3d998e90d68b8e4", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -55,7 +55,7 @@ struct BarrierState {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BarrierWaitResult(bool);\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Barrier {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Barrier { .. }\")\n@@ -110,7 +110,7 @@ impl Barrier {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for BarrierWaitResult {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"BarrierWaitResult\")"}, {"sha": "7ee1c98565cfd5525fd3afba2cdfba2e4743ac69", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -240,7 +240,7 @@ impl Condvar {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Condvar {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Condvar { .. }\")"}, {"sha": "0d6ad5e38e98b0bcdec7b57e691a3675359e546f", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -428,7 +428,7 @@ impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, T: ?Sized + fmt::Debug> fmt::Debug for MutexGuard<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"MutexGuard\")"}, {"sha": "ba99375139139c7d2a1cd71ed5e9c3961e8233df", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -330,7 +330,7 @@ impl Once {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Once {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Once { .. }\")"}, {"sha": "a3db0adeda00dc6042c2c8f26dc77d6c3b65162c", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -361,7 +361,7 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, T: fmt::Debug> fmt::Debug for RwLockReadGuard<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RwLockReadGuard\")\n@@ -370,7 +370,7 @@ impl<'a, T: fmt::Debug> fmt::Debug for RwLockReadGuard<'a, T> {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<'a, T: fmt::Debug> fmt::Debug for RwLockWriteGuard<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RwLockWriteGuard\")"}, {"sha": "2961c4ec58245588d1592ef7d0799702852383c7", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -67,10 +67,20 @@ pub trait CommandExt {\n     /// an error indicating why the exec (or another part of the setup of the\n     /// `Command`) failed.\n     ///\n+    /// `exec` not returning has the same implications as calling\n+    /// [`process::exit`] \u2013 no destructors on the current stack or any other\n+    /// thread\u2019s stack will be run. Therefore, it is recommended to only call\n+    /// `exec` at a point where it is fine to not run any destructors. Note,\n+    /// that the `execvp` syscall independently guarantees that all memory is\n+    /// freed and all file descriptors with the `CLOEXEC` option (set by default\n+    /// on all file descriptors opened by the standard library) are closed.\n+    ///\n     /// This function, unlike `spawn`, will **not** `fork` the process to create\n     /// a new child. Like spawn, however, the default behavior for the stdio\n     /// descriptors will be to inherited from the current process.\n     ///\n+    /// [`process::exit`]: ../../../process/fn.exit.html\n+    ///\n     /// # Notes\n     ///\n     /// The process may be in a \"broken state\" if this function returns in"}, {"sha": "5efddca110f0506a048828e4611ddd2aac2eb723", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -10,12 +10,13 @@\n \n use ffi::CStr;\n use io;\n-use libc::{self, c_int, size_t, sockaddr, socklen_t, EAI_SYSTEM};\n+use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n+use mem;\n use net::{SocketAddr, Shutdown};\n use str;\n use sys::fd::FileDesc;\n use sys_common::{AsInner, FromInner, IntoInner};\n-use sys_common::net::{getsockopt, setsockopt};\n+use sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n use time::Duration;\n \n pub use sys::{cvt, cvt_r};\n@@ -155,8 +156,46 @@ impl Socket {\n         self.0.duplicate().map(Socket)\n     }\n \n+    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::recv(self.0.raw(),\n+                       buf.as_mut_ptr() as *mut c_void,\n+                       buf.len(),\n+                       flags)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n+        self.recv_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, MSG_PEEK)\n+    }\n+\n+    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n+                            -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n+\n+        let n = cvt(unsafe {\n+            libc::recvfrom(self.0.raw(),\n+                        buf.as_mut_ptr() as *mut c_void,\n+                        buf.len(),\n+                        flags,\n+                        &mut storage as *mut _ as *mut _,\n+                        &mut addrlen)\n+        })?;\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, MSG_PEEK)\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {"}, {"sha": "850d6f49612ee3b7626e6f11bd9d5972c8050aea", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -167,6 +167,7 @@ pub const SYMLINK_FLAG_RELATIVE: DWORD = 0x00000001;\n pub const FSCTL_SET_REPARSE_POINT: DWORD = 0x900a4;\n \n pub const SYMBOLIC_LINK_FLAG_DIRECTORY: DWORD = 0x1;\n+pub const SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE: DWORD = 0x2;\n \n // Note that these are not actually HANDLEs, just values to pass to GetStdHandle\n pub const STD_INPUT_HANDLE: DWORD = -10i32 as DWORD;\n@@ -245,6 +246,7 @@ pub const IP_ADD_MEMBERSHIP: c_int = 12;\n pub const IP_DROP_MEMBERSHIP: c_int = 13;\n pub const IPV6_ADD_MEMBERSHIP: c_int = 12;\n pub const IPV6_DROP_MEMBERSHIP: c_int = 13;\n+pub const MSG_PEEK: c_int = 0x2;\n \n #[repr(C)]\n pub struct ip_mreq {"}, {"sha": "4efc68afdc4c74f6387f359c788f30eb42b20fbe", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -646,9 +646,25 @@ pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n     let src = to_u16s(src)?;\n     let dst = to_u16s(dst)?;\n     let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n-    cvt(unsafe {\n-        c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as c::BOOL\n-    })?;\n+    // Formerly, symlink creation required the SeCreateSymbolicLink privilege. For the Windows 10\n+    // Creators Update, Microsoft loosened this to allow unprivileged symlink creation if the\n+    // computer is in Developer Mode, but SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE must be\n+    // added to dwFlags to opt into this behaviour.\n+    let result = cvt(unsafe {\n+        c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(),\n+                               flags | c::SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE) as c::BOOL\n+    });\n+    if let Err(err) = result {\n+        if err.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) {\n+            // Older Windows objects to SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE,\n+            // so if we encounter ERROR_INVALID_PARAMETER, retry without that flag.\n+            cvt(unsafe {\n+                c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as c::BOOL\n+            })?;\n+        } else {\n+            return Err(err);\n+        }\n+    }\n     Ok(())\n }\n "}, {"sha": "adf6210d82e897542d990bd43bcfb7b4cf2bf807", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -147,19 +147,59 @@ impl Socket {\n         Ok(socket)\n     }\n \n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n         let len = cmp::min(buf.len(), i32::max_value() as usize) as i32;\n         unsafe {\n-            match c::recv(self.0, buf.as_mut_ptr() as *mut c_void, len, 0) {\n+            match c::recv(self.0, buf.as_mut_ptr() as *mut c_void, len, flags) {\n                 -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n                 -1 => Err(last_error()),\n                 n => Ok(n as usize)\n             }\n         }\n     }\n \n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, c::MSG_PEEK)\n+    }\n+\n+    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n+                            -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: c::SOCKADDR_STORAGE_LH = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n+        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+\n+        // On unix when a socket is shut down all further reads return 0, so we\n+        // do the same on windows to map a shut down socket to returning EOF.\n+        unsafe {\n+            match c::recvfrom(self.0,\n+                              buf.as_mut_ptr() as *mut c_void,\n+                              len,\n+                              flags,\n+                              &mut storage as *mut _ as *mut _,\n+                              &mut addrlen) {\n+                -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => {\n+                    Ok((0, net::sockaddr_to_addr(&storage, addrlen as usize)?))\n+                },\n+                -1 => Err(last_error()),\n+                n => Ok((n as usize, net::sockaddr_to_addr(&storage, addrlen as usize)?)),\n+            }\n+        }\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, c::MSG_PEEK)\n+    }\n+\n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         let mut me = self;\n         (&mut me).read_to_end(buf)"}, {"sha": "3cdeb511945756d7d8c451ad4ff89ff6aac8f164", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -91,7 +91,7 @@ fn sockname<F>(f: F) -> io::Result<SocketAddr>\n     }\n }\n \n-fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n+pub fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n                     len: usize) -> io::Result<SocketAddr> {\n     match storage.ss_family as c_int {\n         c::AF_INET => {\n@@ -222,6 +222,10 @@ impl TcpStream {\n         self.inner.timeout(c::SO_SNDTIMEO)\n     }\n \n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.peek(buf)\n+    }\n+\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n@@ -441,17 +445,11 @@ impl UdpSocket {\n     }\n \n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        let mut storage: c::sockaddr_storage = unsafe { mem::zeroed() };\n-        let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n-        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+        self.inner.recv_from(buf)\n+    }\n \n-        let n = cvt(unsafe {\n-            c::recvfrom(*self.inner.as_inner(),\n-                        buf.as_mut_ptr() as *mut c_void,\n-                        len, 0,\n-                        &mut storage as *mut _ as *mut _, &mut addrlen)\n-        })?;\n-        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.inner.peek_from(buf)\n     }\n \n     pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n@@ -578,6 +576,10 @@ impl UdpSocket {\n         self.inner.read(buf)\n     }\n \n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.peek(buf)\n+    }\n+\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let ret = cvt(unsafe {"}, {"sha": "5166ddf8a21b620bc516150da11ae1dd51926055", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -99,7 +99,7 @@ pub struct LocalKey<T: 'static> {\n     init: fn() -> T,\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<T: 'static> fmt::Debug for LocalKey<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"LocalKey { .. }\")\n@@ -332,7 +332,6 @@ pub mod os {\n         marker: marker::PhantomData<Cell<T>>,\n     }\n \n-    #[stable(feature = \"std_debug\", since = \"1.15.0\")]\n     impl<T> fmt::Debug for Key<T> {\n         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n             f.pad(\"Key { .. }\")"}, {"sha": "93e320c45223c5978b06f523002e01be941b889b", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -698,7 +698,7 @@ impl ThreadId {\n     }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[unstable(feature = \"thread_id\", issue = \"21507\")]\n impl fmt::Debug for ThreadId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"ThreadId { .. }\")\n@@ -1002,7 +1002,7 @@ impl<T> IntoInner<imp::Thread> for JoinHandle<T> {\n     fn into_inner(self) -> imp::Thread { self.0.native.unwrap() }\n }\n \n-#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<T> fmt::Debug for JoinHandle<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"JoinHandle { .. }\")"}, {"sha": "4269ce8534bd032e056a76dabec6fd88359e1669", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -131,7 +131,6 @@ impl Iterator for CaseMappingIter {\n     }\n }\n \n-#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n impl fmt::Display for CaseMappingIter {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -152,14 +151,14 @@ impl fmt::Display for CaseMappingIter {\n     }\n }\n \n-#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n impl fmt::Display for ToLowercase {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.0, f)\n     }\n }\n \n-#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n impl fmt::Display for ToUppercase {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.0, f)"}, {"sha": "9a717b86d091ed6682cd67427c89bda2baadf850", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -10,7 +10,7 @@\n \n pub use self::SyntaxExtension::{MultiDecorator, MultiModifier, NormalTT, IdentTT};\n \n-use ast::{self, Attribute, Name, PatKind};\n+use ast::{self, Attribute, Name, PatKind, MetaItem};\n use attr::HasAttrs;\n use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n@@ -471,6 +471,9 @@ impl MacResult for DummyResult {\n     }\n }\n \n+pub type BuiltinDeriveFn =\n+    for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut FnMut(Annotatable));\n+\n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n     /// A syntax extension that is attached to an item and creates new items\n@@ -507,7 +510,14 @@ pub enum SyntaxExtension {\n     ///\n     IdentTT(Box<IdentMacroExpander>, Option<Span>, bool),\n \n-    CustomDerive(Box<MultiItemModifier>),\n+    /// An attribute-like procedural macro. TokenStream -> TokenStream.\n+    /// The input is the annotated item.\n+    /// Allows generating code to implement a Trait for a given struct\n+    /// or enum item.\n+    ProcMacroDerive(Box<MultiItemModifier>),\n+\n+    /// An attribute-like procedural macro that derives a builtin trait.\n+    BuiltinDerive(BuiltinDeriveFn),\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -526,6 +536,9 @@ pub trait Resolver {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_builtin_macro(&mut self, tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -552,6 +565,13 @@ impl Resolver for DummyResolver {\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n+    fn resolve_builtin_macro(&mut self, _tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n+    }\n+    fn resolve_derive_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n+    }\n }\n \n #[derive(Clone)]"}, {"sha": "946448eaaee99a2efbfe170e6c59515d7c24794f", "filename": "src/libsyntax/ext/derive.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::Name;\n+use attr;\n+use ast::{self, NestedMetaItem}; use ext::base::{ExtCtxt, SyntaxExtension};\n+use codemap;\n+use ext::build::AstBuilder;\n+use feature_gate;\n+use symbol::Symbol;\n+use syntax_pos::Span;\n+\n+pub fn derive_attr_trait<'a>(cx: &mut ExtCtxt, attr: &'a ast::Attribute)\n+                             -> Option<&'a NestedMetaItem> {\n+    if attr.name() != \"derive\" {\n+        return None;\n+    }\n+    if attr.value_str().is_some() {\n+        cx.span_err(attr.span, \"unexpected value in `derive`\");\n+        return None;\n+    }\n+\n+    let traits = attr.meta_item_list().unwrap_or(&[]);\n+\n+    if traits.is_empty() {\n+        cx.span_warn(attr.span, \"empty trait list in `derive`\");\n+        return None;\n+    }\n+\n+    return traits.get(0);\n+}\n+\n+pub fn verify_derive_attrs(cx: &mut ExtCtxt, attrs: &[ast::Attribute]) {\n+    for attr in attrs {\n+        if attr.name() != \"derive\" {\n+            continue;\n+        }\n+\n+        if attr.value_str().is_some() {\n+            cx.span_err(attr.span, \"unexpected value in `derive`\");\n+        }\n+\n+        let traits = attr.meta_item_list().unwrap_or(&[]).to_owned();\n+\n+        if traits.is_empty() {\n+            cx.span_warn(attr.span, \"empty trait list in `derive`\");\n+            attr::mark_used(&attr);\n+            continue;\n+        }\n+        for titem in traits {\n+            if titem.word().is_none() {\n+                cx.span_err(titem.span, \"malformed `derive` entry\");\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Debug, Clone, Copy)]\n+pub enum DeriveType {\n+    Legacy,\n+    ProcMacro,\n+    Builtin\n+}\n+\n+impl DeriveType {\n+    // Classify a derive trait name by resolving the macro.\n+    pub fn classify(cx: &mut ExtCtxt, tname: Name) -> DeriveType {\n+        let legacy_derive_name = Symbol::intern(&format!(\"derive_{}\", tname));\n+\n+        if let Ok(_) = cx.resolver.resolve_builtin_macro(legacy_derive_name) {\n+            return DeriveType::Legacy;\n+        }\n+\n+        match cx.resolver.resolve_builtin_macro(tname) {\n+            Ok(ext) => match *ext {\n+                SyntaxExtension::BuiltinDerive(..) => DeriveType::Builtin,\n+                _ => DeriveType::ProcMacro,\n+            },\n+            Err(_) => DeriveType::ProcMacro,\n+        }\n+    }\n+}\n+\n+pub fn get_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>,\n+                       derive_type: DeriveType) -> Option<ast::Attribute> {\n+    for i in 0..attrs.len() {\n+        if attrs[i].name() != \"derive\" {\n+            continue;\n+        }\n+\n+        if attrs[i].value_str().is_some() {\n+            continue;\n+        }\n+\n+        let mut traits = attrs[i].meta_item_list().unwrap_or(&[]).to_owned();\n+\n+        // First, weed out malformed #[derive]\n+        traits.retain(|titem| titem.word().is_some());\n+\n+        let mut titem = None;\n+\n+        // See if we can find a matching trait.\n+        for j in 0..traits.len() {\n+            let tname = match traits[j].name() {\n+                Some(tname) => tname,\n+                _ => continue,\n+            };\n+\n+            if DeriveType::classify(cx, tname) == derive_type {\n+                titem = Some(traits.remove(j));\n+                break;\n+            }\n+        }\n+\n+        // If we find a trait, remove the trait from the attribute.\n+        if let Some(titem) = titem {\n+            if traits.len() == 0 {\n+                attrs.remove(i);\n+            } else {\n+                let derive = Symbol::intern(\"derive\");\n+                let mitem = cx.meta_list(titem.span, derive, traits);\n+                attrs[i] = cx.attribute(titem.span, mitem);\n+            }\n+            let derive = Symbol::intern(\"derive\");\n+            let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n+            return Some(cx.attribute(mitem.span, mitem));\n+        }\n+    }\n+    return None;\n+}\n+\n+fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n+    Span {\n+        expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+            call_site: span,\n+            callee: codemap::NameAndSpan {\n+                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n+                span: Some(span),\n+                allow_internal_unstable: true,\n+            },\n+        }),\n+        ..span\n+    }\n+}\n+\n+pub fn add_derived_markers(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) {\n+    if attrs.is_empty() {\n+        return;\n+    }\n+\n+    let titems = attrs.iter().filter(|a| {\n+        a.name() == \"derive\"\n+    }).flat_map(|a| {\n+        a.meta_item_list().unwrap_or(&[]).iter()\n+    }).filter_map(|titem| {\n+        titem.name()\n+    }).collect::<Vec<_>>();\n+\n+    let span = attrs[0].span;\n+\n+    if !attrs.iter().any(|a| a.name() == \"structural_match\") &&\n+       titems.iter().any(|t| *t == \"PartialEq\") && titems.iter().any(|t| *t == \"Eq\") {\n+        let structural_match = Symbol::intern(\"structural_match\");\n+        let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n+        let meta = cx.meta_word(span, structural_match);\n+        attrs.push(cx.attribute(span, meta));\n+    }\n+\n+    if !attrs.iter().any(|a| a.name() == \"rustc_copy_clone_marker\") &&\n+       titems.iter().any(|t| *t == \"Copy\") && titems.iter().any(|t| *t == \"Clone\") {\n+        let structural_match = Symbol::intern(\"rustc_copy_clone_marker\");\n+        let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n+        let meta = cx.meta_word(span, structural_match);\n+        attrs.push(cx.attribute(span, meta));\n+    }\n+}\n+\n+pub fn find_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>)\n+                        -> Option<ast::Attribute> {\n+    verify_derive_attrs(cx, attrs);\n+    get_derive_attr(cx, attrs, DeriveType::Legacy).and_then(|a| {\n+        let titem = derive_attr_trait(cx, &a);\n+        titem.and_then(|titem| {\n+            let tword = titem.word().unwrap();\n+            let tname = tword.name();\n+            if !cx.ecfg.enable_custom_derive() {\n+                feature_gate::emit_feature_err(\n+                    &cx.parse_sess,\n+                    \"custom_derive\",\n+                    titem.span,\n+                    feature_gate::GateIssue::Language,\n+                    feature_gate::EXPLAIN_CUSTOM_DERIVE\n+                );\n+                None\n+            } else {\n+                let name = Symbol::intern(&format!(\"derive_{}\", tname));\n+                if !cx.resolver.is_whitelisted_legacy_custom_derive(name) {\n+                    cx.span_warn(titem.span,\n+                                 feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n+                }\n+                let mitem = cx.meta_word(titem.span, name);\n+                Some(cx.attribute(mitem.span, mitem))\n+            }\n+        })\n+    }).or_else(|| {\n+        get_derive_attr(cx, attrs, DeriveType::ProcMacro)\n+    }).or_else(|| {\n+        add_derived_markers(cx, attrs);\n+        get_derive_attr(cx, attrs, DeriveType::Builtin)\n+    })\n+}"}, {"sha": "8e7f8830eafbc586d2b2c04ad60d44487cc12dc9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 104, "deletions": 10, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -8,26 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Ident, Mac_, PatKind};\n+use ast::{self, Block, Ident, Mac_, PatKind};\n use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n-use ast;\n-use ext::hygiene::Mark;\n-use ext::placeholders::{placeholder, PlaceholderExpander};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n-use syntax_pos::{self, Span, ExpnId};\n use config::{is_test_or_bench, StripUnconfigured};\n use ext::base::*;\n+use ext::derive::{find_derive_attr, derive_attr_trait};\n+use ext::hygiene::Mark;\n+use ext::placeholders::{placeholder, PlaceholderExpander};\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, DirectoryOwnership, PResult, filemap_to_tts};\n use parse::parser::Parser;\n use parse::token;\n+use parse::{ParseSess, DirectoryOwnership, PResult, filemap_to_tts};\n use print::pprust;\n use ptr::P;\n use std_inject;\n+use symbol::Symbol;\n use symbol::keywords;\n+use syntax_pos::{self, Span, ExpnId};\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -166,13 +167,18 @@ pub enum InvocationKind {\n         attr: ast::Attribute,\n         item: Annotatable,\n     },\n+    Derive {\n+        attr: ast::Attribute,\n+        item: Annotatable,\n+    },\n }\n \n impl Invocation {\n     fn span(&self) -> Span {\n         match self.kind {\n             InvocationKind::Bang { span, .. } => span,\n             InvocationKind::Attr { ref attr, .. } => attr.span,\n+            InvocationKind::Derive { ref attr, .. } => attr.span,\n         }\n     }\n }\n@@ -250,6 +256,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let path = ast::Path::from_ident(attr.span, ident);\n                     self.cx.resolver.resolve_macro(scope, &path, force)\n                 }\n+                InvocationKind::Derive { ref attr, .. } => {\n+                    let titem = derive_attr_trait(self.cx, &attr).unwrap();\n+                    let tname = titem.name().expect(\"Expected derive macro name\");\n+                    let ident = Ident::with_empty_ctxt(tname);\n+                    let path = ast::Path::from_ident(attr.span, ident);\n+                    self.cx.resolver.resolve_derive_macro(scope, &path, force)\n+                }\n             };\n             let ext = match resolution {\n                 Ok(ext) => Some(ext),\n@@ -330,6 +343,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n             InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n+            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n         }\n     }\n \n@@ -370,7 +384,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n                 self.parse_expansion(tok_result, kind, name, attr.span)\n             }\n-            SyntaxExtension::CustomDerive(_) => {\n+            SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", name));\n                 kind.dummy(attr.span)\n             }\n@@ -440,7 +454,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 return kind.dummy(span);\n             }\n \n-            SyntaxExtension::CustomDerive(..) => {\n+            SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", extname));\n                 return kind.dummy(span);\n             }\n@@ -486,6 +500,71 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         })\n     }\n \n+    /// Expand a derive invocation. Returns the result of expansion.\n+    fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+        let Invocation { expansion_kind: kind, .. } = invoc;\n+        let (attr, item) = match invoc.kind {\n+            InvocationKind::Derive { attr, item } => (attr, item),\n+            _ => unreachable!(),\n+        };\n+\n+        attr::mark_used(&attr);\n+        let titem = derive_attr_trait(self.cx, &attr).unwrap();\n+        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n+        let name = Symbol::intern(&format!(\"derive({})\", tname));\n+        let mitem = &attr.value;\n+\n+        self.cx.bt_push(ExpnInfo {\n+            call_site: attr.span,\n+            callee: NameAndSpan {\n+                format: MacroAttribute(attr.name()),\n+                span: Some(attr.span),\n+                allow_internal_unstable: false,\n+            }\n+        });\n+\n+        match *ext {\n+            SyntaxExtension::ProcMacroDerive(ref ext) => {\n+                let span = Span {\n+                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n+                        call_site: mitem.span,\n+                        callee: NameAndSpan {\n+                            format: MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n+                            span: None,\n+                            allow_internal_unstable: false,\n+                        },\n+                    }),\n+                    ..mitem.span\n+                };\n+                return kind.expect_from_annotatables(ext.expand(self.cx, span, &mitem, item));\n+            }\n+            SyntaxExtension::BuiltinDerive(func) => {\n+                let span = Span {\n+                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n+                        call_site: titem.span,\n+                        callee: NameAndSpan {\n+                            format: MacroAttribute(name),\n+                            span: None,\n+                            allow_internal_unstable: true,\n+                        },\n+                    }),\n+                    ..titem.span\n+                };\n+                let mut items = Vec::new();\n+                func(self.cx, span, &mitem, &item, &mut |a| {\n+                    items.push(a)\n+                });\n+                items.insert(0, item);\n+                return kind.expect_from_annotatables(items);\n+            }\n+            _ => {\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", name);\n+                self.cx.span_err(attr.span, &msg);\n+                kind.dummy(attr.span)\n+            }\n+        }\n+    }\n+\n     fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n                        -> Expansion {\n         let mut parser = self.cx.new_parser_from_tts(&toks.trees().cloned().collect::<Vec<_>>());\n@@ -595,16 +674,31 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(&mut self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n                     -> Expansion {\n-        self.collect(kind, InvocationKind::Attr { attr: attr, item: item })\n+        let invoc_kind = if attr.name() == \"derive\" {\n+            if kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems {\n+                self.cx.span_err(attr.span, \"`derive` can be only be applied to items\");\n+                return kind.expect_from_annotatables(::std::iter::once(item));\n+            }\n+            InvocationKind::Derive { attr: attr, item: item }\n+        } else {\n+            InvocationKind::Attr { attr: attr, item: item }\n+        };\n+\n+        self.collect(kind, invoc_kind)\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n     fn classify_item<T: HasAttrs>(&mut self, mut item: T) -> (T, Option<ast::Attribute>) {\n         let mut attr = None;\n+\n         item = item.map_attrs(|mut attrs| {\n-            attr = self.cx.resolver.find_attr_invoc(&mut attrs);\n+            attr = self.cx.resolver.find_attr_invoc(&mut attrs).or_else(|| {\n+                find_derive_attr(self.cx, &mut attrs)\n+            });\n+\n             attrs\n         });\n+\n         (item, attr)\n     }\n "}, {"sha": "52ef2a05fcf195fa93fb1e72a875aff95ae47de2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -318,7 +318,7 @@ declare_features! (\n     (active, abi_unadjusted, \"1.16.0\", None),\n \n     // Macros 1.1\n-    (active, proc_macro, \"1.16.0\", Some(35900)),\n+    (active, proc_macro, \"1.16.0\", Some(38356)),\n \n     // Allows attributes on struct literal fields.\n     (active, struct_field_attributes, \"1.16.0\", Some(38814)),\n@@ -381,7 +381,7 @@ declare_features! (\n     (accepted, dotdot_in_tuple_patterns, \"1.14.0\", Some(33627)),\n     (accepted, item_like_imports, \"1.14.0\", Some(35120)),\n     // Allows using `Self` and associated types in struct expressions and patterns.\n-    (accepted, more_struct_aliases, \"1.14.0\", Some(37544)),\n+    (accepted, more_struct_aliases, \"1.16.0\", Some(37544)),\n );\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n "}, {"sha": "87a03adf6b77c018784aa535a3939f0ba1db4a2c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -128,6 +128,7 @@ pub mod print {\n pub mod ext {\n     pub mod base;\n     pub mod build;\n+    pub mod derive;\n     pub mod expand;\n     pub mod placeholders;\n     pub mod hygiene;"}, {"sha": "45d8354d317dc5949959ebbdef94b67cfb157f6b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1691,6 +1691,7 @@ impl<'a> Parser<'a> {\n         }\n \n         // Assemble the span.\n+        // FIXME(#39450) This is bogus if part of the path is macro generated.\n         let span = mk_sp(lo, self.prev_span.hi);\n \n         // Assemble the result."}, {"sha": "974e86a57412446d0b2457b48704e8e46a91f927", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -32,18 +32,18 @@ impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_mac(&mut self, _mac: &Mac) {}\n }\n \n-pub struct CustomDerive {\n+pub struct ProcMacroDerive {\n     inner: fn(TokenStream) -> TokenStream,\n     attrs: Vec<ast::Name>,\n }\n \n-impl CustomDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream, attrs: Vec<ast::Name>) -> CustomDerive {\n-        CustomDerive { inner: inner, attrs: attrs }\n+impl ProcMacroDerive {\n+    pub fn new(inner: fn(TokenStream) -> TokenStream, attrs: Vec<ast::Name>) -> ProcMacroDerive {\n+        ProcMacroDerive { inner: inner, attrs: attrs }\n     }\n }\n \n-impl MultiItemModifier for CustomDerive {\n+impl MultiItemModifier for ProcMacroDerive {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n@@ -54,7 +54,7 @@ impl MultiItemModifier for CustomDerive {\n             Annotatable::Item(item) => item,\n             Annotatable::ImplItem(_) |\n             Annotatable::TraitItem(_) => {\n-                ecx.span_err(span, \"custom derive attributes may only be \\\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n@@ -63,7 +63,7 @@ impl MultiItemModifier for CustomDerive {\n             ItemKind::Struct(..) |\n             ItemKind::Enum(..) => {},\n             _ => {\n-                ecx.span_err(span, \"custom derive attributes may only be \\\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n@@ -81,7 +81,7 @@ impl MultiItemModifier for CustomDerive {\n         let stream = match res {\n             Ok(stream) => stream,\n             Err(e) => {\n-                let msg = \"custom derive attribute panicked\";\n+                let msg = \"proc-macro derive panicked\";\n                 let mut err = ecx.struct_span_fatal(span, msg);\n                 if let Some(s) = e.downcast_ref::<String>() {\n                     err.help(&format!(\"message: {}\", s));\n@@ -100,7 +100,7 @@ impl MultiItemModifier for CustomDerive {\n                 Ok(new_items) => new_items,\n                 Err(_) => {\n                     // FIXME: handle this better\n-                    let msg = \"custom derive produced unparseable tokens\";\n+                    let msg = \"proc-macro derive produced unparseable tokens\";\n                     ecx.struct_span_fatal(span, msg).emit();\n                     panic!(FatalError);\n                 }"}, {"sha": "498f2348b80f109157f55992e684e7e91111b864", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -13,6 +13,7 @@\n use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n+use deriving::warn_if_deprecated;\n \n use syntax::ast;\n use syntax::ast::{Expr, MetaItem, Mutability};\n@@ -35,6 +36,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n                                  push: &mut FnMut(Annotatable)) {\n+    warn_if_deprecated(cx, span, \"Decodable\");\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n "}, {"sha": "9d155c22ad031d86f4f3508d4195c5c051b5a5d8", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -91,6 +91,7 @@\n use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n+use deriving::warn_if_deprecated;\n \n use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -112,6 +113,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n                                  push: &mut FnMut(Annotatable)) {\n+    warn_if_deprecated(cx, span, \"Encodable\");\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n "}, {"sha": "3bceb02f3d6c5af6a2e2cff0a5cb9c452ce275c5", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 10, "deletions": 247, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -10,12 +10,11 @@\n \n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use syntax::ast::{self, MetaItem};\n-use syntax::attr::HasAttrs;\n+use std::rc::Rc;\n+use syntax::ast;\n use syntax::codemap;\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n use syntax::ext::build::AstBuilder;\n-use syntax::feature_gate;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -89,234 +88,6 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-pub fn expand_derive(cx: &mut ExtCtxt,\n-                     span: Span,\n-                     mitem: &MetaItem,\n-                     annotatable: Annotatable)\n-                     -> Vec<Annotatable> {\n-    debug!(\"expand_derive: span = {:?}\", span);\n-    debug!(\"expand_derive: mitem = {:?}\", mitem);\n-    debug!(\"expand_derive: annotatable input  = {:?}\", annotatable);\n-    let mut item = match annotatable {\n-        Annotatable::Item(item) => item,\n-        other => {\n-            cx.span_err(span, \"`derive` can only be applied to items\");\n-            return vec![other]\n-        }\n-    };\n-\n-    let derive = Symbol::intern(\"derive\");\n-    let mut derive_attrs = Vec::new();\n-    item = item.map_attrs(|attrs| {\n-        let partition = attrs.into_iter().partition(|attr| attr.name() == derive);\n-        derive_attrs = partition.0;\n-        partition.1\n-    });\n-\n-    // Expand `#[derive]`s after other attribute macro invocations.\n-    if cx.resolver.find_attr_invoc(&mut item.attrs.clone()).is_some() {\n-        return vec![Annotatable::Item(item.map_attrs(|mut attrs| {\n-            attrs.push(cx.attribute(span, mitem.clone()));\n-            attrs.extend(derive_attrs);\n-            attrs\n-        }))];\n-    }\n-\n-    let get_traits = |mitem: &MetaItem, cx: &ExtCtxt| {\n-        if mitem.value_str().is_some() {\n-            cx.span_err(mitem.span, \"unexpected value in `derive`\");\n-        }\n-\n-        let traits = mitem.meta_item_list().unwrap_or(&[]).to_owned();\n-        if traits.is_empty() {\n-            cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n-        }\n-        traits\n-    };\n-\n-    let mut traits = get_traits(mitem, cx);\n-    for derive_attr in derive_attrs {\n-        traits.extend(get_traits(&derive_attr.value, cx));\n-    }\n-\n-    // First, weed out malformed #[derive]\n-    traits.retain(|titem| {\n-        if titem.word().is_none() {\n-            cx.span_err(titem.span, \"malformed `derive` entry\");\n-            false\n-        } else {\n-            true\n-        }\n-    });\n-\n-    // Next, check for old-style #[derive(Foo)]\n-    //\n-    // These all get expanded to `#[derive_Foo]` and will get expanded first. If\n-    // we actually add any attributes here then we return to get those expanded\n-    // and then eventually we'll come back to finish off the other derive modes.\n-    let mut new_attributes = Vec::new();\n-    traits.retain(|titem| {\n-        let tword = titem.word().unwrap();\n-        let tname = tword.name();\n-\n-        if is_builtin_trait(tname) || {\n-            let derive_mode = ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(tname));\n-            cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n-                if let SyntaxExtension::CustomDerive(_) = *ext { true } else { false }\n-            }).unwrap_or(false)\n-        } {\n-            return true;\n-        }\n-\n-        if !cx.ecfg.enable_custom_derive() {\n-            feature_gate::emit_feature_err(&cx.parse_sess,\n-                                           \"custom_derive\",\n-                                           titem.span,\n-                                           feature_gate::GateIssue::Language,\n-                                           feature_gate::EXPLAIN_CUSTOM_DERIVE);\n-        } else {\n-            let name = Symbol::intern(&format!(\"derive_{}\", tname));\n-            if !cx.resolver.is_whitelisted_legacy_custom_derive(name) {\n-                cx.span_warn(titem.span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-            }\n-            let mitem = cx.meta_word(titem.span, name);\n-            new_attributes.push(cx.attribute(mitem.span, mitem));\n-        }\n-        false\n-    });\n-    if new_attributes.len() > 0 {\n-        item = item.map(|mut i| {\n-            i.attrs.extend(new_attributes);\n-            if traits.len() > 0 {\n-                let list = cx.meta_list(mitem.span, derive, traits);\n-                i.attrs.push(cx.attribute(mitem.span, list));\n-            }\n-            i\n-        });\n-        return vec![Annotatable::Item(item)]\n-    }\n-\n-    // Now check for macros-1.1 style custom #[derive].\n-    //\n-    // Expand each of them in order given, but *before* we expand any built-in\n-    // derive modes. The logic here is to:\n-    //\n-    // 1. Collect the remaining `#[derive]` annotations into a list. If\n-    //    there are any left, attach a `#[derive]` attribute to the item\n-    //    that we're currently expanding with the remaining derive modes.\n-    // 2. Manufacture a `#[derive(Foo)]` attribute to pass to the expander.\n-    // 3. Expand the current item we're expanding, getting back a list of\n-    //    items that replace it.\n-    // 4. Extend the returned list with the current list of items we've\n-    //    collected so far.\n-    // 5. Return everything!\n-    //\n-    // If custom derive extensions end up threading through the `#[derive]`\n-    // attribute, we'll get called again later on to continue expanding\n-    // those modes.\n-    let macros_11_derive = traits.iter()\n-                                 .cloned()\n-                                 .enumerate()\n-                                 .filter(|&(_, ref name)| !is_builtin_trait(name.name().unwrap()))\n-                                 .next();\n-    if let Some((i, titem)) = macros_11_derive {\n-        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n-        let path = ast::Path::from_ident(titem.span, tname);\n-        let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n-\n-        traits.remove(i);\n-        if traits.len() > 0 {\n-            item = item.map(|mut i| {\n-                let list = cx.meta_list(mitem.span, derive, traits);\n-                i.attrs.push(cx.attribute(mitem.span, list));\n-                i\n-            });\n-        }\n-        let titem = cx.meta_list_item_word(titem.span, titem.name().unwrap());\n-        let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n-        let item = Annotatable::Item(item);\n-\n-        let span = Span {\n-            expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                call_site: mitem.span,\n-                callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n-                    span: None,\n-                    allow_internal_unstable: false,\n-                },\n-            }),\n-            ..mitem.span\n-        };\n-\n-        if let SyntaxExtension::CustomDerive(ref ext) = *ext {\n-            return ext.expand(cx, span, &mitem, item);\n-        } else {\n-            unreachable!()\n-        }\n-    }\n-\n-    // Ok, at this point we know that there are no old-style `#[derive_Foo]` nor\n-    // any macros-1.1 style `#[derive(Foo)]`. Expand all built-in traits here.\n-\n-    // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n-    // `#[structural_match]` attribute.\n-    let (partial_eq, eq) = (Symbol::intern(\"PartialEq\"), Symbol::intern(\"Eq\"));\n-    if traits.iter().any(|t| t.name() == Some(partial_eq)) &&\n-       traits.iter().any(|t| t.name() == Some(eq)) {\n-        let structural_match = Symbol::intern(\"structural_match\");\n-        let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n-        let meta = cx.meta_word(span, structural_match);\n-        item = item.map(|mut i| {\n-            i.attrs.push(cx.attribute(span, meta));\n-            i\n-        });\n-    }\n-\n-    // RFC #1521. `Clone` can assume that `Copy` types' clone implementation is\n-    // the same as the copy implementation.\n-    //\n-    // Add a marker attribute here picked up during #[derive(Clone)]\n-    let (copy, clone) = (Symbol::intern(\"Copy\"), Symbol::intern(\"Clone\"));\n-    if traits.iter().any(|t| t.name() == Some(clone)) &&\n-       traits.iter().any(|t| t.name() == Some(copy)) {\n-        let marker = Symbol::intern(\"rustc_copy_clone_marker\");\n-        let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n-        let meta = cx.meta_word(span, marker);\n-        item = item.map(|mut i| {\n-            i.attrs.push(cx.attribute(span, meta));\n-            i\n-        });\n-    }\n-\n-    let mut items = Vec::new();\n-    for titem in traits.iter() {\n-        let tname = titem.word().unwrap().name();\n-        let name = Symbol::intern(&format!(\"derive({})\", tname));\n-        let mitem = cx.meta_word(titem.span, name);\n-\n-        let span = Span {\n-            expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                call_site: titem.span,\n-                callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(name),\n-                    span: None,\n-                    allow_internal_unstable: true,\n-                },\n-            }),\n-            ..titem.span\n-        };\n-\n-        let my_item = Annotatable::Item(item);\n-        expand_builtin(&tname.as_str(), cx, span, &mitem, &my_item, &mut |a| {\n-            items.push(a);\n-        });\n-        item = my_item.expect_item();\n-    }\n-\n-    items.insert(0, Annotatable::Item(item));\n-    return items\n-}\n-\n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn is_builtin_trait(name: ast::Name) -> bool {\n@@ -326,21 +97,13 @@ macro_rules! derive_traits {\n             }\n         }\n \n-        fn expand_builtin(name: &str,\n-                          ecx: &mut ExtCtxt,\n-                          span: Span,\n-                          mitem: &MetaItem,\n-                          item: &Annotatable,\n-                          push: &mut FnMut(Annotatable)) {\n-            match name {\n-                $(\n-                    $name => {\n-                        warn_if_deprecated(ecx, span, $name);\n-                        $func(ecx, span, mitem, item, push);\n-                    }\n-                )*\n-                _ => panic!(\"not a builtin derive mode: {}\", name),\n-            }\n+        pub fn register_builtin_derives(resolver: &mut Resolver) {\n+            $(\n+                resolver.add_ext(\n+                    ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n+                    Rc::new(SyntaxExtension::BuiltinDerive($func))\n+                );\n+            )*\n         }\n     }\n }"}, {"sha": "7533171b08556df082f2fcabfd27dbcb11e3e3d0", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -24,7 +24,6 @@\n #![feature(staged_api)]\n \n extern crate fmt_macros;\n-#[macro_use]\n extern crate log;\n #[macro_use]\n extern crate syntax;\n@@ -51,12 +50,14 @@ pub mod proc_macro_impl;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, MultiModifier, NamedSyntaxExtension};\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension};\n use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n                          enable_quotes: bool) {\n+    deriving::register_builtin_derives(resolver);\n+\n     let mut register = |name, ext| {\n         resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n@@ -112,8 +113,6 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     register(Symbol::intern(\"format_args\"),\n              NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(Symbol::intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n-\n     for (name, ext) in user_exts {\n         register(name, ext);\n     }"}, {"sha": "325f09a83ddab80860afd3524f7937ab23cd2e7c", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -27,7 +27,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use deriving;\n \n-struct CustomDerive {\n+struct ProcMacroDerive {\n     trait_name: ast::Name,\n     function_name: Ident,\n     span: Span,\n@@ -40,7 +40,7 @@ struct AttrProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n-    derives: Vec<CustomDerive>,\n+    derives: Vec<ProcMacroDerive>,\n     attr_macros: Vec<AttrProcMacro>,\n     in_root: bool,\n     handler: &'a errors::Handler,\n@@ -176,7 +176,7 @@ impl<'a> CollectProcMacros<'a> {\n         };\n \n         if self.in_root && item.vis == ast::Visibility::Public {\n-            self.derives.push(CustomDerive {\n+            self.derives.push(ProcMacroDerive {\n                 span: item.span,\n                 trait_name: trait_name,\n                 function_name: item.ident,\n@@ -319,7 +319,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //          }\n //      }\n fn mk_registrar(cx: &mut ExtCtxt,\n-                custom_derives: &[CustomDerive],\n+                custom_derives: &[ProcMacroDerive],\n                 custom_attrs: &[AttrProcMacro]) -> P<ast::Item> {\n     let eid = cx.codemap().record_expansion(ExpnInfo {\n         call_site: DUMMY_SP,"}, {"sha": "42fad803bfa68ae345d5643ff0ae3b0e99fbdadb", "filename": "src/test/compile-fail-fulldeps/proc-macro/derive-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -16,7 +16,7 @@ extern crate derive_bad;\n #[derive(\n     A\n )]\n-//~^^ ERROR: custom derive produced unparseable tokens\n+//~^^ ERROR: proc-macro derive produced unparseable tokens\n struct A;\n \n fn main() {}"}, {"sha": "c483c048b418f11f437a37a8f13a03200cd472a6", "filename": "src/test/compile-fail-fulldeps/proc-macro/load-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -14,7 +14,7 @@\n extern crate derive_panic;\n \n #[derive(A)]\n-//~^ ERROR: custom derive attribute panicked\n+//~^ ERROR: proc-macro derive panicked\n //~| HELP: message: nope!\n struct Foo;\n "}, {"sha": "e47a4aefb5e0b67447dde7a118477e45622574ba", "filename": "src/test/compile-fail-fulldeps/proc-macro/no-macro-use-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -13,7 +13,7 @@\n #![feature(rustc_attrs)]\n \n extern crate derive_a;\n-//~^ WARN custom derive crates and `#[no_link]` crates have no effect without `#[macro_use]`\n+//~^ WARN proc macro crates and `#[no_link]` crates have no effect without `#[macro_use]`\n \n #[rustc_error]\n fn main() {} //~ ERROR compilation successful"}, {"sha": "5213a189714dd52fd865acae8421b0c15f9536ac", "filename": "src/test/compile-fail/defaulted-unit-warning.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fdefaulted-unit-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fdefaulted-unit-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefaulted-unit-warning.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![allow(unreachable_code)]\n+#![deny(resolve_trait_on_defaulted_unit)]\n+\n+trait Deserialize: Sized {\n+    fn deserialize() -> Result<Self, String>;\n+}\n+\n+impl Deserialize for () {\n+    fn deserialize() -> Result<(), String> {\n+        Ok(())\n+    }\n+}\n+\n+fn doit() -> Result<(), String> {\n+    let _ = match Deserialize::deserialize() {\n+        //~^ ERROR code relies on type\n+        //~| WARNING previously accepted\n+        Ok(x) => x,\n+        Err(e) => return Err(e),\n+    };\n+    Ok(())\n+}\n+\n+trait ImplementedForUnitButNotNever {}\n+\n+impl ImplementedForUnitButNotNever for () {}\n+\n+fn foo<T: ImplementedForUnitButNotNever>(_t: T) {}\n+\n+fn smeg() {\n+    let _x = return;\n+    foo(_x);\n+    //~^ ERROR code relies on type\n+    //~| WARNING previously accepted\n+}\n+\n+fn main() {\n+    let _ = doit();\n+}\n+"}, {"sha": "d388ece084417160ce98517533942f71e0387ca5", "filename": "src/test/compile-fail/deriving-meta-unknown-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n \n #[derive(Eqr)]\n-//~^ ERROR `#[derive]` for custom traits is not stable enough for use. It is deprecated and will be removed in v1.15 (see issue #29644)\n+//~^ ERROR cannot find derive macro `Eqr` in this scope\n struct Foo;\n \n pub fn main() {}"}, {"sha": "97a39a46c19a81774f5e06f1b45118b65c7253da", "filename": "src/test/compile-fail/deriving-primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(FromPrimitive)] //~ERROR `#[derive]` for custom traits is not stable\n+#[derive(FromPrimitive)] //~ERROR cannot find derive macro `FromPrimitive` in this scope\n enum Foo {}\n \n fn main() {}"}, {"sha": "f467ba3b1e19521a8e161573ea538c494ea5e34a", "filename": "src/test/compile-fail/macro-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     foo!(0); // Check that we report errors at macro definition, not expansion.\n \n     let _: cfg!(foo) = (); //~ ERROR non-type macro in type position\n-    derive!(); //~ ERROR `derive` can only be used in attributes\n+    derive!(); //~ ERROR macro undefined: 'derive!'\n }"}, {"sha": "3f710af8ac9a883f0c31ac5161e2828b3998771f", "filename": "src/test/compile-fail/macros-nonfatal-errors.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -14,9 +14,11 @@\n #![feature(asm)]\n #![feature(trace_macros, concat_idents)]\n \n-#[derive(Default, //~ ERROR\n-           Zero)] //~ ERROR\n-enum CantDeriveThose {}\n+#[derive(Zero)] //~ ERROR\n+struct CantDeriveThis;\n+\n+#[derive(Default)] //~ ERROR\n+enum OrDeriveThis {}\n \n fn main() {\n     doesnt_exist!(); //~ ERROR"}, {"sha": "f74ff55e2c08e406399443b2c7a4ca49a3a3c7c1", "filename": "src/test/compile-fail/no-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-link.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -12,7 +12,7 @@\n \n #[no_link]\n extern crate empty_struct;\n-//~^ WARN custom derive crates and `#[no_link]` crates have no effect without `#[macro_use]`\n+//~^ WARN proc macro crates and `#[no_link]` crates have no effect without `#[macro_use]`\n \n fn main() {\n     empty_struct::XEmpty1; //~ ERROR cannot find value `XEmpty1` in module `empty_struct`"}, {"sha": "a1c581a18682c5a1fdf5373568a0e2e080027ee1", "filename": "src/test/pretty/attr-derive.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fpretty%2Fattr-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fpretty%2Fattr-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-derive.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-foo.rs\n+// ignore-stage1\n+// pp-exact\n+// Testing that both the inner item and next outer item are\n+// preserved, and that the first outer item parsed in main is not\n+// accidentally carried over to each inner function\n+\n+#[macro_use]\n+extern crate derive_foo;\n+\n+#[derive(Foo)]\n+struct X;\n+\n+#[derive(Foo)]\n+#[Bar]\n+struct Y;\n+\n+#[derive(Foo)]\n+struct WithRef {\n+    x: X,\n+    #[Bar]\n+    y: Y,\n+}\n+\n+#[derive(Foo)]\n+enum Enum {\n+\n+    #[Bar]\n+    Asdf,\n+    Qwerty,\n+}\n+\n+fn main() { }"}, {"sha": "1ffacaa9f5a5d89bbc6add9c3674d0ec2ba77cfb", "filename": "src/test/pretty/attr-variant-data.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/696f5c1fc695494053709ae3b18b4c6a65b619a6/src%2Ftest%2Fpretty%2Fattr-variant-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f5c1fc695494053709ae3b18b4c6a65b619a6/src%2Ftest%2Fpretty%2Fattr-variant-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-variant-data.rs?ref=696f5c1fc695494053709ae3b18b4c6a65b619a6", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pp-exact\n-// Testing that both the inner item and next outer item are\n-// preserved, and that the first outer item parsed in main is not\n-// accidentally carried over to each inner function\n-\n-#![feature(custom_attribute)]\n-#![feature(custom_derive)]\n-\n-#[derive(Serialize, Deserialize)]\n-struct X;\n-\n-#[derive(Serialize, Deserialize)]\n-struct WithRef<'a, T: 'a> {\n-    #[serde(skip_deserializing)]\n-    t: Option<&'a T>,\n-    #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-    x: X,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-enum EnumWith<T> {\n-    Unit,\n-    Newtype(\n-            #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-            X),\n-    Tuple(T,\n-          #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-          X),\n-    Struct {\n-        t: T,\n-        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-        x: X,\n-    },\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-struct Tuple<T>(T,\n-                #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-                X);\n-\n-fn main() { }"}, {"sha": "bd81d3e5a3b53f26260647f268cbfebe0127726c", "filename": "src/test/pretty/auxiliary/derive-foo.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fpretty%2Fauxiliary%2Fderive-foo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fpretty%2Fauxiliary%2Fderive-foo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fauxiliary%2Fderive-foo.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Foo, attributes(Bar))]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "5ac50e04b8d2fc81e3e1991a5f682f9d1d89232b", "filename": "src/test/run-make/atomic-lock-free/atomic_lock_free.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(cfg_target_has_atomic, no_core, intrinsics, lang_items)]\n+#![feature(cfg_target_has_atomic, no_core, intrinsics, lang_items, i128_type)]\n #![crate_type=\"rlib\"]\n #![no_core]\n \n@@ -54,6 +54,14 @@ pub unsafe fn atomic_u64(x: *mut u64) {\n pub unsafe fn atomic_i64(x: *mut i64) {\n     atomic_xadd(x, 1);\n }\n+#[cfg(target_has_atomic = \"128\")]\n+pub unsafe fn atomic_u128(x: *mut u128) {\n+    atomic_xadd(x, 1);\n+}\n+#[cfg(target_has_atomic = \"128\")]\n+pub unsafe fn atomic_i128(x: *mut i128) {\n+    atomic_xadd(x, 1);\n+}\n #[cfg(target_has_atomic = \"ptr\")]\n pub unsafe fn atomic_usize(x: *mut usize) {\n     atomic_xadd(x, 1);"}, {"sha": "9a5e2de14e3b0788754bee7982778fea7adb0253", "filename": "src/test/ui/custom-derive/issue-36935.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -1,4 +1,4 @@\n-error: custom derive attribute panicked\n+error: proc-macro derive panicked\n   --> $DIR/issue-36935.rs:17:15\n    |\n 17 | #[derive(Foo, Bar)]"}, {"sha": "1938d33e5303020d2fd975f917e2bb67350847ac", "filename": "src/test/ui/did_you_mean/issue-38054-do-not-show-unresolved-names.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38054-do-not-show-unresolved-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38054-do-not-show-unresolved-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38054-do-not-show-unresolved-names.rs?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Foo;\n+\n+use Foo1;\n+\n+fn main() {}"}, {"sha": "325f55e686c622e12ec5772512392b0a1e70f460", "filename": "src/test/ui/did_you_mean/issue-38054-do-not-show-unresolved-names.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38054-do-not-show-unresolved-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c8cdb2923a69177017165a4cdb0e1ea673fc49f/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38054-do-not-show-unresolved-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38054-do-not-show-unresolved-names.stderr?ref=9c8cdb2923a69177017165a4cdb0e1ea673fc49f", "patch": "@@ -0,0 +1,14 @@\n+error[E0432]: unresolved import `Foo`\n+  --> $DIR/issue-38054-do-not-show-unresolved-names.rs:11:5\n+   |\n+11 | use Foo;\n+   |     ^^^ no `Foo` in the root\n+\n+error[E0432]: unresolved import `Foo1`\n+  --> $DIR/issue-38054-do-not-show-unresolved-names.rs:13:5\n+   |\n+13 | use Foo1;\n+   |     ^^^^ no `Foo1` in the root\n+\n+error: aborting due to 2 previous errors\n+"}]}