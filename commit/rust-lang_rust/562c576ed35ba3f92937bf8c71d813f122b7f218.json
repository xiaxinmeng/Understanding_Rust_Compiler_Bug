{"sha": "562c576ed35ba3f92937bf8c71d813f122b7f218", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MmM1NzZlZDM1YmEzZjkyOTM3YmY4YzcxZDgxM2YxMjJiN2YyMTg=", "commit": {"author": {"name": "Philipp Krones", "email": "uwdkn@student.kit.edu", "date": "2018-08-24T16:28:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-24T16:28:50Z"}, "message": "Merge pull request #3059 from elpiel/writeln_empty_string_harcoded-suggestion\n\n#3016 writeln_empty_string Hardcoded suggestion", "tree": {"sha": "4417bfd6e2ee1db5192e53a37b8ef1c252657e59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4417bfd6e2ee1db5192e53a37b8ef1c252657e59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/562c576ed35ba3f92937bf8c71d813f122b7f218", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbgDJCCRBK7hj4Ov3rIwAAdHIIAFdIiaJ1eaFSl5h7sQYcShrR\nRKGBxEbgIWV45CUJAyUPWjIbBkDVYEZnTXZ3RbdgMSRCopRvX7+uFXJq61fGUssx\nhH8HnITDNglH8PgghAB+atKIiASNi+kNdkfvwrEvN4JYiaABccCVEIxat6L7WT+7\ngA+KiPjKnafn9mI9wFNyVX6D05hIQ8J9YVQFJyBEMJMOJqTCNyeRwAny2GZ/anQY\nWcPqeFI0eyNA8LgMlCE95PVCUDET1Oah/F5v5p7LqDWKgJSqAfvhRBgZJOuFF8bT\nGCHxdGr7dkbmltvDw+62vzB82CiJHRF6/wn3kIhWRa6UwnFQci8DoupPoasENuo=\n=XFrL\n-----END PGP SIGNATURE-----\n", "payload": "tree 4417bfd6e2ee1db5192e53a37b8ef1c252657e59\nparent 72344f466fefd6e4a0a92d105b5844464eb09429\nparent 76f7bfcefd6c7ad16b01864a3e616eb66fbfae2f\nauthor Philipp Krones <uwdkn@student.kit.edu> 1535128130 +0200\ncommitter GitHub <noreply@github.com> 1535128130 +0200\n\nMerge pull request #3059 from elpiel/writeln_empty_string_harcoded-suggestion\n\n#3016 writeln_empty_string Hardcoded suggestion"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/562c576ed35ba3f92937bf8c71d813f122b7f218", "html_url": "https://github.com/rust-lang/rust/commit/562c576ed35ba3f92937bf8c71d813f122b7f218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/562c576ed35ba3f92937bf8c71d813f122b7f218/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72344f466fefd6e4a0a92d105b5844464eb09429", "url": "https://api.github.com/repos/rust-lang/rust/commits/72344f466fefd6e4a0a92d105b5844464eb09429", "html_url": "https://github.com/rust-lang/rust/commit/72344f466fefd6e4a0a92d105b5844464eb09429"}, {"sha": "76f7bfcefd6c7ad16b01864a3e616eb66fbfae2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/76f7bfcefd6c7ad16b01864a3e616eb66fbfae2f", "html_url": "https://github.com/rust-lang/rust/commit/76f7bfcefd6c7ad16b01864a3e616eb66fbfae2f"}], "stats": {"total": 67, "additions": 46, "deletions": 21}, "files": [{"sha": "97fe12f23303e3cb52e1c4fed9e997b99e98dbcb", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/562c576ed35ba3f92937bf8c71d813f122b7f218/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562c576ed35ba3f92937bf8c71d813f122b7f218/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=562c576ed35ba3f92937bf8c71d813f122b7f218", "patch": "@@ -3,7 +3,8 @@ use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use syntax::tokenstream::{ThinTokenStream, TokenStream};\n use syntax::parse::{token, parser};\n-use crate::utils::{span_lint, span_lint_and_sugg};\n+use std::borrow::Cow;\n+use crate::utils::{span_lint, span_lint_and_sugg, snippet};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -179,7 +180,7 @@ impl EarlyLintPass for Pass {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &Mac) {\n         if mac.node.path == \"println\" {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n                 if fmtstr == \"\" {\n                     span_lint_and_sugg(\n                         cx,\n@@ -193,39 +194,42 @@ impl EarlyLintPass for Pass {\n             }\n         } else if mac.node.path == \"print\" {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n                 if fmtstr.ends_with(\"\\\\n\") && !fmtstr.ends_with(\"\\\\n\\\\n\") {\n                     span_lint(cx, PRINT_WITH_NEWLINE, mac.span,\n                             \"using `print!()` with a format string that ends in a \\\n                             single newline, consider using `println!()` instead\");\n                 }\n             }\n         } else if mac.node.path == \"write\" {\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true).0 {\n                 if fmtstr.ends_with(\"\\\\n\") && !fmtstr.ends_with(\"\\\\n\\\\n\") {\n                     span_lint(cx, WRITE_WITH_NEWLINE, mac.span,\n                             \"using `write!()` with a format string that ends in a \\\n                             single newline, consider using `writeln!()` instead\");\n                 }\n             }\n         } else if mac.node.path == \"writeln\" {\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+            let check_tts = check_tts(cx, &mac.node.tts, true);\n+            if let Some(fmtstr) = check_tts.0 {\n                 if fmtstr == \"\" {\n+                    let suggestion = check_tts.1.map_or(Cow::Borrowed(\"v\"), |expr| snippet(cx, expr.span, \"v\"));\n+\n                     span_lint_and_sugg(\n                         cx,\n                         WRITELN_EMPTY_STRING,\n                         mac.span,\n-                        \"using `writeln!(v, \\\"\\\")`\",\n+                        format!(\"using `writeln!({}, \\\"\\\")`\", suggestion).as_str(),\n                         \"replace it with\",\n-                        \"writeln!(v)\".to_string(),\n+                        format!(\"writeln!({})\", suggestion),\n                     );\n                 }\n             }\n         }\n     }\n }\n \n-fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> Option<String> {\n+fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> (Option<String>, Option<Expr>) {\n     let tts = TokenStream::from(tts.clone());\n     let mut parser = parser::Parser::new(\n         &cx.sess.parse_sess,\n@@ -234,20 +238,29 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n         false,\n         false,\n     );\n+    let mut expr: Option<Expr> = None;\n     if is_write {\n-        // skip the initial write target\n-        parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n+            Ok(p) => Some(p.into_inner()),\n+            Err(_) => return (None, None),\n+        };\n         // might be `writeln!(foo)`\n-        parser.expect(&token::Comma).map_err(|mut err| err.cancel()).ok()?;\n+        if parser.expect(&token::Comma).map_err(|mut err| err.cancel()).is_err() {\n+            return (None, expr);\n+        }\n     }\n-    let fmtstr = parser.parse_str().map_err(|mut err| err.cancel()).ok()?.0.to_string();\n+\n+    let fmtstr = match parser.parse_str().map_err(|mut err| err.cancel()) {\n+        Ok(token) => token.0.to_string(),\n+        Err(_) => return (None, expr),\n+    };\n     use fmt_macros::*;\n     let tmp = fmtstr.clone();\n     let mut args = vec![];\n     let mut fmt_parser = Parser::new(&tmp, None);\n     while let Some(piece) = fmt_parser.next() {\n         if !fmt_parser.errors.is_empty() {\n-            return None;\n+            return (None, expr);\n         }\n         if let Piece::NextArgument(arg) = piece {\n             if arg.format.ty == \"?\" {\n@@ -266,9 +279,12 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n     loop {\n         if !parser.eat(&token::Comma) {\n             assert!(parser.eat(&token::Eof));\n-            return Some(fmtstr);\n+            return (Some(fmtstr), expr);\n         }\n-        let expr = parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        let token_expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n+            Ok(expr) => expr,\n+            Err(_) => return (Some(fmtstr), None),\n+        };\n         const SIMPLE: FormatSpec<'_> = FormatSpec {\n             fill: None,\n             align: AlignUnknown,\n@@ -277,7 +293,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n             width: CountImplied,\n             ty: \"\",\n         };\n-        match &expr.node {\n+        match &token_expr.node {\n             ExprKind::Lit(_) => {\n                 let mut all_simple = true;\n                 let mut seen = false;\n@@ -293,7 +309,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n                     }\n                 }\n                 if all_simple && seen {\n-                    span_lint(cx, lint, expr.span, \"literal with an empty format string\");\n+                    span_lint(cx, lint, token_expr.span, \"literal with an empty format string\");\n                 }\n                 idx += 1;\n             },"}, {"sha": "faccfd8291c0c29a96ba3c818357e8c6b27fd057", "filename": "tests/ui/writeln_empty_string.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/562c576ed35ba3f92937bf8c71d813f122b7f218/tests%2Fui%2Fwriteln_empty_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562c576ed35ba3f92937bf8c71d813f122b7f218/tests%2Fui%2Fwriteln_empty_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.rs?ref=562c576ed35ba3f92937bf8c71d813f122b7f218", "patch": "@@ -5,9 +5,12 @@ use std::io::Write;\n fn main() {\n     let mut v = Vec::new();\n \n-    // This should fail\n+    // These should fail\n     writeln!(&mut v, \"\");\n \n+    let mut suggestion = Vec::new();\n+    writeln!(&mut suggestion, \"\");\n+\n     // These should be fine\n     writeln!(&mut v);\n     writeln!(&mut v, \" \");"}, {"sha": "7bb6350ecd20c118f03c02aa81919314e5531064", "filename": "tests/ui/writeln_empty_string.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/562c576ed35ba3f92937bf8c71d813f122b7f218/tests%2Fui%2Fwriteln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/562c576ed35ba3f92937bf8c71d813f122b7f218/tests%2Fui%2Fwriteln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.stderr?ref=562c576ed35ba3f92937bf8c71d813f122b7f218", "patch": "@@ -1,10 +1,16 @@\n-error: using `writeln!(v, \"\")`\n+error: using `writeln!(&mut v, \"\")`\n  --> $DIR/writeln_empty_string.rs:9:5\n   |\n 9 |     writeln!(&mut v, \"\");\n-  |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(v)`\n+  |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(&mut v)`\n   |\n   = note: `-D writeln-empty-string` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: using `writeln!(&mut suggestion, \"\")`\n+  --> $DIR/writeln_empty_string.rs:12:5\n+   |\n+12 |     writeln!(&mut suggestion, \"\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(&mut suggestion)`\n+\n+error: aborting due to 2 previous errors\n "}]}