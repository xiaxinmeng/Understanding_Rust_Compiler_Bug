{"sha": "d130e41423771a592300e7b08d981c58e6eacbc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMzBlNDE0MjM3NzFhNTkyMzAwZTdiMDhkOTgxYzU4ZTZlYWNiYzA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-24T17:25:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-24T17:25:41Z"}, "message": "Rollup merge of #57380 - bearcage:master, r=alexcrichton\n\nFix Instant/Duration math precision & associativity on Windows\n\n**tl;dr** Addition and subtraction on Duration/Instant are not associative on windows because we use the perfcounter frequency in every calculation instead of just when we measure time.\n\nThis is my first contrib (PR or Issue) to Rust, so please lmk if I've done this wrong. I followed CONTRIBUTING to the extent I could given my system doesn't seem to be able to build the compiler with changes in the source tree. I also asked about this issue in #rust-beginners a week or so ago, before digging through libstd -- I'm unsure if there's a good way to follow up on that, but I'd be happy to update the docs on the timing structs if this fixes the problem.\n\n## Issue\n\nThe `Duration` type keeps seconds in the upper-64 and nanoseconds in the lower-32 bits. In theory doing math on these ought to be basically the same as doing math on any other 64 or 32 bit integral number.\n\nOn windows (and I think macos too), however, our math gets messy because the Instant type stores the current point in time in units of HPET Performance Counter counts, not nanoseconds, and does unit conversions on every math operation, rather than just when we measure the time from the system clock.\n\nI tried this code:\n\n```\nuse std::time::{Duration, Instant};\n\nfn main() {\n    let now = Instant::now();\n    let offset = Duration::from_millis(5);\n    assert_eq!((now + offset) - now, (now - now) + offset);\n}\n```\n\nOn UNIX machines (linux and macos) it behaves as you'd expect -- [no crash](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=cf2206c0b7e07d8ecc7767a512364094).\n\nOn Windows hosts, however, it blows up because of a precision problem in the Instant +/- Duration math:\n\n```\nC:\\Users\\aberg\\work\\timetest (master -> origin)\n\u03bb cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target\\debug\\timetest.exe`\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4.999914ms`,\n right: `5ms`', src\\main.rs:6:5\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\nerror: process didn't exit successfully: `target\\debug\\timetest.exe` (exit code: 101)\n\nC:\\Users\\aberg\\work\\timetest (master -> origin)\n\u03bb cat src\\main.rs\nuse std::time::{Duration, Instant};\n\nfn main() {\n    let now = Instant::now();\n    let offset = Duration::from_millis(5);\n    assert_eq!((now + offset) - now, (now - now) + offset);\n}\n```\n\nOn windows I think this is a consequence of doing the HPET-PerfCounter-Unit conversion on each math operation. I suspect the reason it works on macs is that (from what I could find online) most apple machines report timing in nanoseconds anyway. For anyone interested, the equivalent functions on macos, with a little work to fish out the numerator/denominator from a timebase struct:\n\n* `QueryPerformanceCounter()` -> `mach_absolute_time()`\n* `QueryPerformanceFrequency()` -> `mach_timebase_info()`\n\nIf this PR ends up working as I expect it to when CI runs the tests, I can make the same changes to the macos implementation.\n\n## Potential Fix\n\nWe ought to be able to sort this out by storing nanoseconds, rather than PerfCounter units, that way intermediate math is done in the most precise units we support and we're only doing unit conversions when we actually measure the system clock (and it might even translate to a small perf gain for people doing tons of Instant/Duration math).\n\nI believe this will address the underlying cause of #56034, and make the guessed epsilon constant from #56059 unnecessary. If it's of interest, I can write up how these timing types work on the tier 1 platforms to address #32626 as well, since I'm already in here figuring it out.\n\n## This Patch\n\nTo that end, I've got this patch, which I think should fix it on windows, but I'm having trouble testing it -- any time I change anything in libstd I start getting this error, which no amount of clean building seems to resolve:\n\n```\nC:\\Users\\aberg\\work\\rust (master -> origin)\n\u03bb python x.py test --stage 0 --no-doc src/libstd\nUpdating only changed submodules\nSubmodules updated in 0.27 seconds\n    Finished dev [unoptimized] target(s) in 2.41s\nBuilding stage0 std artifacts (x86_64-pc-windows-msvc -> x86_64-pc-windows-msvc)\n    Finished release [optimized] target(s) in 6.78s\nCopying stage0 std from stage0 (x86_64-pc-windows-msvc -> x86_64-pc-windows-msvc / x86_64-pc-windows-msvc)\nBuilding stage0 test artifacts (x86_64-pc-windows-msvc -> x86_64-pc-windows-msvc)\n   Compiling test v0.0.0 (C:\\Users\\aberg\\work\\rust\\src\\libtest)\nerror[E0460]: found possibly newer version of crate `std` which `getopts` depends on\n  --> src\\libtest\\lib.rs:36:1\n   |\n36 | extern crate getopts;\n   | ^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: perhaps that crate needs to be recompiled?\n   = note: the following crate versions were found:\n           crate `std`: \\\\?\\C:\\Users\\aberg\\work\\rust\\build\\x86_64-pc-windows-msvc\\stage0-sysroot\\lib\\rustlib\\x86_64-pc-windows-msvc\\lib\\libstd-d7a80ca2ae113c97.rlib\n           crate `std`: \\\\?\\C:\\Users\\aberg\\work\\rust\\build\\x86_64-pc-windows-msvc\\stage0-sysroot\\lib\\rustlib\\x86_64-pc-windows-msvc\\lib\\std-d7a80ca2ae113c97.dll\n           crate `getopts`: \\\\?\\C:\\Users\\aberg\\work\\rust\\build\\x86_64-pc-windows-msvc\\stage0-test\\x86_64-pc-windows-msvc\\release\\deps\\libgetopts-ae40a96de5f5d144.rlib\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0460`.\nerror: Could not compile `test`.\n\nTo learn more, run the command again with --verbose.\ncommand did not execute successfully: \"C:\\\\Users\\\\aberg\\\\work\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0\\\\bin\\\\cargo.exe\" \"build\" \"--target\" \"x86_64-pc-windows-msvc\" \"-j\" \"12\" \"--release\" \"--manifest-path\" \"C:\\\\Users\\\\aberg\\\\work\\\\rust\\\\src/libtest/Cargo.toml\" \"--message-format\" \"json\"\nexpected success, got: exit code: 101\nfailed to run: C:\\Users\\aberg\\work\\rust\\build\\bootstrap\\debug\\bootstrap test --stage 0 --no-doc src/libstd\nBuild completed unsuccessfully in 0:00:20\n```\n\n---\n\nSince you wrote the linked PRs and might remember looking at related problems:\n\nr? @alexcrichton", "tree": {"sha": "ed4fe8647030cc6813db5c6b180cca86195f632a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed4fe8647030cc6813db5c6b180cca86195f632a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d130e41423771a592300e7b08d981c58e6eacbc0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcSfUVCRBK7hj4Ov3rIwAAdHIIAAcLTIeYz4x4F7TujtDL86Uy\nQSVeoBOyXwmsNV1lA1ZIwK65h7RAAW0RD3xh8vj3YzgU/t8jNhE/OtSUYy6Ln9Tr\npRshLPSgcCESuZtCc4zVNy/VE4OQMngf7m9EkrUC6wblWYkG4g8Xr336ezu9QROm\nMKfjUEU76jB19Kkk9q2e10sRNSw5U3FkkeQAkHio/C0DJjW3JccRNsdl3RN8kQYS\nI3WliSDFNK3i8bz1aIHiLcjONg4e8YgOdlfrSej4yppmEgyryvu7r2u+C+xiQ5K/\nhh97edt6e9Nm3/376P+Knz5cBSs7XwePN6u6VB3XsJ/7CzWB32Ur+JC30ScZYYk=\n=J+5r\n-----END PGP SIGNATURE-----\n", "payload": "tree ed4fe8647030cc6813db5c6b180cca86195f632a\nparent 095b44c83b540bb4dbf74be1cae604f4bae87989\nparent 14ce5364de3bf7d2da59fbe52360459c0f2c6ada\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1548350741 +0100\ncommitter GitHub <noreply@github.com> 1548350741 +0100\n\nRollup merge of #57380 - bearcage:master, r=alexcrichton\n\nFix Instant/Duration math precision & associativity on Windows\n\n**tl;dr** Addition and subtraction on Duration/Instant are not associative on windows because we use the perfcounter frequency in every calculation instead of just when we measure time.\n\nThis is my first contrib (PR or Issue) to Rust, so please lmk if I've done this wrong. I followed CONTRIBUTING to the extent I could given my system doesn't seem to be able to build the compiler with changes in the source tree. I also asked about this issue in #rust-beginners a week or so ago, before digging through libstd -- I'm unsure if there's a good way to follow up on that, but I'd be happy to update the docs on the timing structs if this fixes the problem.\n\n## Issue\n\nThe `Duration` type keeps seconds in the upper-64 and nanoseconds in the lower-32 bits. In theory doing math on these ought to be basically the same as doing math on any other 64 or 32 bit integral number.\n\nOn windows (and I think macos too), however, our math gets messy because the Instant type stores the current point in time in units of HPET Performance Counter counts, not nanoseconds, and does unit conversions on every math operation, rather than just when we measure the time from the system clock.\n\nI tried this code:\n\n```\nuse std::time::{Duration, Instant};\n\nfn main() {\n    let now = Instant::now();\n    let offset = Duration::from_millis(5);\n    assert_eq!((now + offset) - now, (now - now) + offset);\n}\n```\n\nOn UNIX machines (linux and macos) it behaves as you'd expect -- [no crash](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=cf2206c0b7e07d8ecc7767a512364094).\n\nOn Windows hosts, however, it blows up because of a precision problem in the Instant +/- Duration math:\n\n```\nC:\\Users\\aberg\\work\\timetest (master -> origin)\n\u03bb cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target\\debug\\timetest.exe`\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4.999914ms`,\n right: `5ms`', src\\main.rs:6:5\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\nerror: process didn't exit successfully: `target\\debug\\timetest.exe` (exit code: 101)\n\nC:\\Users\\aberg\\work\\timetest (master -> origin)\n\u03bb cat src\\main.rs\nuse std::time::{Duration, Instant};\n\nfn main() {\n    let now = Instant::now();\n    let offset = Duration::from_millis(5);\n    assert_eq!((now + offset) - now, (now - now) + offset);\n}\n```\n\nOn windows I think this is a consequence of doing the HPET-PerfCounter-Unit conversion on each math operation. I suspect the reason it works on macs is that (from what I could find online) most apple machines report timing in nanoseconds anyway. For anyone interested, the equivalent functions on macos, with a little work to fish out the numerator/denominator from a timebase struct:\n\n* `QueryPerformanceCounter()` -> `mach_absolute_time()`\n* `QueryPerformanceFrequency()` -> `mach_timebase_info()`\n\nIf this PR ends up working as I expect it to when CI runs the tests, I can make the same changes to the macos implementation.\n\n## Potential Fix\n\nWe ought to be able to sort this out by storing nanoseconds, rather than PerfCounter units, that way intermediate math is done in the most precise units we support and we're only doing unit conversions when we actually measure the system clock (and it might even translate to a small perf gain for people doing tons of Instant/Duration math).\n\nI believe this will address the underlying cause of #56034, and make the guessed epsilon constant from #56059 unnecessary. If it's of interest, I can write up how these timing types work on the tier 1 platforms to address #32626 as well, since I'm already in here figuring it out.\n\n## This Patch\n\nTo that end, I've got this patch, which I think should fix it on windows, but I'm having trouble testing it -- any time I change anything in libstd I start getting this error, which no amount of clean building seems to resolve:\n\n```\nC:\\Users\\aberg\\work\\rust (master -> origin)\n\u03bb python x.py test --stage 0 --no-doc src/libstd\nUpdating only changed submodules\nSubmodules updated in 0.27 seconds\n    Finished dev [unoptimized] target(s) in 2.41s\nBuilding stage0 std artifacts (x86_64-pc-windows-msvc -> x86_64-pc-windows-msvc)\n    Finished release [optimized] target(s) in 6.78s\nCopying stage0 std from stage0 (x86_64-pc-windows-msvc -> x86_64-pc-windows-msvc / x86_64-pc-windows-msvc)\nBuilding stage0 test artifacts (x86_64-pc-windows-msvc -> x86_64-pc-windows-msvc)\n   Compiling test v0.0.0 (C:\\Users\\aberg\\work\\rust\\src\\libtest)\nerror[E0460]: found possibly newer version of crate `std` which `getopts` depends on\n  --> src\\libtest\\lib.rs:36:1\n   |\n36 | extern crate getopts;\n   | ^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: perhaps that crate needs to be recompiled?\n   = note: the following crate versions were found:\n           crate `std`: \\\\?\\C:\\Users\\aberg\\work\\rust\\build\\x86_64-pc-windows-msvc\\stage0-sysroot\\lib\\rustlib\\x86_64-pc-windows-msvc\\lib\\libstd-d7a80ca2ae113c97.rlib\n           crate `std`: \\\\?\\C:\\Users\\aberg\\work\\rust\\build\\x86_64-pc-windows-msvc\\stage0-sysroot\\lib\\rustlib\\x86_64-pc-windows-msvc\\lib\\std-d7a80ca2ae113c97.dll\n           crate `getopts`: \\\\?\\C:\\Users\\aberg\\work\\rust\\build\\x86_64-pc-windows-msvc\\stage0-test\\x86_64-pc-windows-msvc\\release\\deps\\libgetopts-ae40a96de5f5d144.rlib\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0460`.\nerror: Could not compile `test`.\n\nTo learn more, run the command again with --verbose.\ncommand did not execute successfully: \"C:\\\\Users\\\\aberg\\\\work\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0\\\\bin\\\\cargo.exe\" \"build\" \"--target\" \"x86_64-pc-windows-msvc\" \"-j\" \"12\" \"--release\" \"--manifest-path\" \"C:\\\\Users\\\\aberg\\\\work\\\\rust\\\\src/libtest/Cargo.toml\" \"--message-format\" \"json\"\nexpected success, got: exit code: 101\nfailed to run: C:\\Users\\aberg\\work\\rust\\build\\bootstrap\\debug\\bootstrap test --stage 0 --no-doc src/libstd\nBuild completed unsuccessfully in 0:00:20\n```\n\n---\n\nSince you wrote the linked PRs and might remember looking at related problems:\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d130e41423771a592300e7b08d981c58e6eacbc0", "html_url": "https://github.com/rust-lang/rust/commit/d130e41423771a592300e7b08d981c58e6eacbc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d130e41423771a592300e7b08d981c58e6eacbc0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "095b44c83b540bb4dbf74be1cae604f4bae87989", "url": "https://api.github.com/repos/rust-lang/rust/commits/095b44c83b540bb4dbf74be1cae604f4bae87989", "html_url": "https://github.com/rust-lang/rust/commit/095b44c83b540bb4dbf74be1cae604f4bae87989"}, {"sha": "14ce5364de3bf7d2da59fbe52360459c0f2c6ada", "url": "https://api.github.com/repos/rust-lang/rust/commits/14ce5364de3bf7d2da59fbe52360459c0f2c6ada", "html_url": "https://github.com/rust-lang/rust/commit/14ce5364de3bf7d2da59fbe52360459c0f2c6ada"}], "stats": {"total": 127, "additions": 83, "deletions": 44}, "files": [{"sha": "8a8159af2f1a6ee2b5c4e8eecb8995296dc65726", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 74, "deletions": 44, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d130e41423771a592300e7b08d981c58e6eacbc0/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d130e41423771a592300e7b08d981c58e6eacbc0/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=d130e41423771a592300e7b08d981c58e6eacbc0", "patch": "@@ -1,10 +1,7 @@\n use cmp::Ordering;\n use fmt;\n use mem;\n-use sync::Once;\n use sys::c;\n-use sys::cvt;\n-use sys_common::mul_div_u64;\n use time::Duration;\n use convert::TryInto;\n use core::hash::{Hash, Hasher};\n@@ -14,7 +11,9 @@ const INTERVALS_PER_SEC: u64 = NANOS_PER_SEC / 100;\n \n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n pub struct Instant {\n-    t: c::LARGE_INTEGER,\n+    // This duration is relative to an arbitrary microsecond epoch\n+    // from the winapi QueryPerformanceCounter function.\n+    t: Duration,\n }\n \n #[derive(Copy, Clone)]\n@@ -33,59 +32,44 @@ pub const UNIX_EPOCH: SystemTime = SystemTime {\n \n impl Instant {\n     pub fn now() -> Instant {\n-        let mut t = Instant { t: 0 };\n-        cvt(unsafe {\n-            c::QueryPerformanceCounter(&mut t.t)\n-        }).unwrap();\n-        t\n+        // High precision timing on windows operates in \"Performance Counter\"\n+        // units, as returned by the WINAPI QueryPerformanceCounter function.\n+        // These relate to seconds by a factor of QueryPerformanceFrequency.\n+        // In order to keep unit conversions out of normal interval math, we\n+        // measure in QPC units and immediately convert to nanoseconds.\n+        perf_counter::PerformanceCounterInstant::now().into()\n     }\n \n     pub fn actually_monotonic() -> bool {\n         false\n     }\n \n     pub const fn zero() -> Instant {\n-        Instant { t: 0 }\n+        Instant { t: Duration::from_secs(0) }\n     }\n \n     pub fn sub_instant(&self, other: &Instant) -> Duration {\n-        // Values which are +- 1 need to be considered as basically the same\n-        // units in time due to various measurement oddities, according to\n-        // Windows [1]\n-        //\n-        // [1]:\n-        // https://msdn.microsoft.com/en-us/library/windows/desktop\n-        //                           /dn553408%28v=vs.85%29.aspx#guidance\n-        if other.t > self.t && other.t - self.t == 1 {\n+        // On windows there's a threshold below which we consider two timestamps\n+        // equivalent due to measurement error. For more details + doc link,\n+        // check the docs on epsilon.\n+        let epsilon =\n+            perf_counter::PerformanceCounterInstant::epsilon();\n+        if other.t > self.t && other.t - self.t <= epsilon {\n             return Duration::new(0, 0)\n         }\n-        let diff = (self.t as u64).checked_sub(other.t as u64)\n-                                  .expect(\"specified instant was later than \\\n-                                           self\");\n-        let nanos = mul_div_u64(diff, NANOS_PER_SEC, frequency() as u64);\n-        Duration::new(nanos / NANOS_PER_SEC, (nanos % NANOS_PER_SEC) as u32)\n+        self.t.checked_sub(other.t)\n+              .expect(\"specified instant was later than self\")\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-        let freq = frequency() as u64;\n-        let t = other.as_secs()\n-            .checked_mul(freq)?\n-            .checked_add(mul_div_u64(other.subsec_nanos() as u64, freq, NANOS_PER_SEC))?\n-            .checked_add(self.t as u64)?;\n         Some(Instant {\n-            t: t as c::LARGE_INTEGER,\n+            t: self.t.checked_add(*other)?\n         })\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-        let freq = frequency() as u64;\n-        let t = other.as_secs().checked_mul(freq).and_then(|i| {\n-            (self.t as u64).checked_sub(i)\n-        }).and_then(|i| {\n-            i.checked_sub(mul_div_u64(other.subsec_nanos() as u64, freq, NANOS_PER_SEC))\n-        })?;\n         Some(Instant {\n-            t: t as c::LARGE_INTEGER,\n+            t: self.t.checked_sub(*other)?\n         })\n     }\n }\n@@ -186,14 +170,60 @@ fn intervals2dur(intervals: u64) -> Duration {\n                   ((intervals % INTERVALS_PER_SEC) * 100) as u32)\n }\n \n-fn frequency() -> c::LARGE_INTEGER {\n-    static mut FREQUENCY: c::LARGE_INTEGER = 0;\n-    static ONCE: Once = Once::new();\n+mod perf_counter {\n+    use super::{NANOS_PER_SEC};\n+    use sync::Once;\n+    use sys_common::mul_div_u64;\n+    use sys::c;\n+    use sys::cvt;\n+    use time::Duration;\n+\n+    pub struct PerformanceCounterInstant {\n+        ts: c::LARGE_INTEGER\n+    }\n+    impl PerformanceCounterInstant {\n+        pub fn now() -> Self {\n+            Self {\n+                ts: query()\n+            }\n+        }\n \n-    unsafe {\n-        ONCE.call_once(|| {\n-            cvt(c::QueryPerformanceFrequency(&mut FREQUENCY)).unwrap();\n-        });\n-        FREQUENCY\n+        // Per microsoft docs, the margin of error for cross-thread time comparisons\n+        // using QueryPerformanceCounter is 1 \"tick\" -- defined as 1/frequency().\n+        // Reference: https://docs.microsoft.com/en-us/windows/desktop/SysInfo\n+        //                   /acquiring-high-resolution-time-stamps\n+        pub fn epsilon() -> Duration {\n+            let epsilon = NANOS_PER_SEC / (frequency() as u64);\n+            Duration::from_nanos(epsilon)\n+        }\n+    }\n+    impl From<PerformanceCounterInstant> for super::Instant {\n+        fn from(other: PerformanceCounterInstant) -> Self {\n+            let freq = frequency() as u64;\n+            let instant_nsec = mul_div_u64(other.ts as u64, NANOS_PER_SEC, freq);\n+            Self {\n+                t: Duration::from_nanos(instant_nsec)\n+            }\n+        }\n+    }\n+\n+    fn frequency() -> c::LARGE_INTEGER {\n+        static mut FREQUENCY: c::LARGE_INTEGER = 0;\n+        static ONCE: Once = Once::new();\n+\n+        unsafe {\n+            ONCE.call_once(|| {\n+                cvt(c::QueryPerformanceFrequency(&mut FREQUENCY)).unwrap();\n+            });\n+            FREQUENCY\n+        }\n+    }\n+\n+    fn query() -> c::LARGE_INTEGER {\n+        let mut qpc_value: c::LARGE_INTEGER = 0;\n+        cvt(unsafe {\n+            c::QueryPerformanceCounter(&mut qpc_value)\n+        }).unwrap();\n+        qpc_value\n     }\n }"}, {"sha": "23924559fcc248c447bb54fc268a115dc07d4da4", "filename": "src/libstd/time.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d130e41423771a592300e7b08d981c58e6eacbc0/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d130e41423771a592300e7b08d981c58e6eacbc0/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=d130e41423771a592300e7b08d981c58e6eacbc0", "patch": "@@ -610,6 +610,15 @@ mod tests {\n         assert_eq!(a + year, a.checked_add(year).unwrap());\n     }\n \n+    #[test]\n+    fn instant_math_is_associative() {\n+        let now = Instant::now();\n+        let offset = Duration::from_millis(5);\n+        // Changing the order of instant math shouldn't change the results,\n+        // especially when the expression reduces to X + identity.\n+        assert_eq!((now + offset) - now, (now - now) + offset);\n+    }\n+\n     #[test]\n     #[should_panic]\n     fn instant_duration_panic() {"}]}