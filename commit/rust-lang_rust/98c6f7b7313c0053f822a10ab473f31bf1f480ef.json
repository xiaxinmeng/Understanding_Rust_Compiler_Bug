{"sha": "98c6f7b7313c0053f822a10ab473f31bf1f480ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4YzZmN2I3MzEzYzAwNTNmODIyYTEwYWI0NzNmMzFiZjFmNDgwZWY=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-25T22:36:44Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-25T22:36:44Z"}, "message": "Format array using overflow module\n\nThis commit applies heuristics used for function calls to array\nand vice versa.", "tree": {"sha": "85ded5531190a6574b8b268f6e5327d0dd40627c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85ded5531190a6574b8b268f6e5327d0dd40627c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c6f7b7313c0053f822a10ab473f31bf1f480ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c6f7b7313c0053f822a10ab473f31bf1f480ef", "html_url": "https://github.com/rust-lang/rust/commit/98c6f7b7313c0053f822a10ab473f31bf1f480ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c6f7b7313c0053f822a10ab473f31bf1f480ef/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "affa4ce1ecdcfd031122004417afa5b2ccaa92f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/affa4ce1ecdcfd031122004417afa5b2ccaa92f7", "html_url": "https://github.com/rust-lang/rust/commit/affa4ce1ecdcfd031122004417afa5b2ccaa92f7"}], "stats": {"total": 280, "additions": 116, "deletions": 164}, "files": [{"sha": "c719f9938ee995c8bb43992f30692deea44b9681", "filename": "src/expr.rs", "status": "modified", "additions": 18, "deletions": 142, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/98c6f7b7313c0053f822a10ab473f31bf1f480ef/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6f7b7313c0053f822a10ab473f31bf1f480ef/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=98c6f7b7313c0053f822a10ab473f31bf1f480ef", "patch": "@@ -13,6 +13,7 @@ use std::cmp::min;\n \n use config::lists::*;\n use syntax::codemap::{BytePos, CodeMap, Span};\n+use syntax::parse::token::DelimToken;\n use syntax::{ast, ptr};\n \n use chains::rewrite_chain;\n@@ -64,14 +65,13 @@ pub fn format_expr(\n \n     let expr_rw = match expr.node {\n         ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n+            \"\",\n             &ptr_vec_to_ref_vec(expr_vec),\n-            mk_sp(\n-                context.snippet_provider.span_after(expr.span, \"[\"),\n-                expr.span.hi(),\n-            ),\n+            expr.span,\n             context,\n             shape,\n-            false,\n+            None,\n+            None,\n         ),\n         ast::ExprKind::Lit(ref l) => rewrite_literal(context, l, shape),\n         ast::ExprKind::Call(ref callee, ref args) => {\n@@ -422,147 +422,23 @@ where\n }\n \n pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n+    name: &str,\n     exprs: &[&T],\n     span: Span,\n     context: &RewriteContext,\n     shape: Shape,\n-    trailing_comma: bool,\n+    force_separator_tactic: Option<SeparatorTactic>,\n+    delim_token: Option<DelimToken>,\n ) -> Option<String> {\n-    let bracket_size = if context.config.spaces_within_parens_and_brackets() {\n-        2 // \"[ \"\n-    } else {\n-        1 // \"[\"\n-    };\n-\n-    let nested_shape = match context.config.indent_style() {\n-        IndentStyle::Block => shape\n-            .block()\n-            .block_indent(context.config.tab_spaces())\n-            .with_max_width(context.config)\n-            .sub_width(1)?,\n-        IndentStyle::Visual => shape\n-            .visual_indent(bracket_size)\n-            .sub_width(bracket_size * 2)?,\n-    };\n-\n-    let items = itemize_list(\n-        context.snippet_provider,\n-        exprs.iter(),\n-        \"]\",\n-        \",\",\n-        |item| item.span().lo(),\n-        |item| item.span().hi(),\n-        |item| item.rewrite(context, nested_shape),\n-        span.lo(),\n-        span.hi(),\n-        false,\n-    ).collect::<Vec<_>>();\n-\n-    if items.is_empty() {\n-        if context.config.spaces_within_parens_and_brackets() {\n-            return Some(\"[ ]\".to_string());\n-        } else {\n-            return Some(\"[]\".to_string());\n-        }\n-    }\n-\n-    let tactic = array_tactic(context, shape, nested_shape, exprs, &items, bracket_size);\n-    let ends_with_newline = tactic.ends_with_newline(context.config.indent_style());\n-\n-    let fmt = ListFormatting {\n-        tactic,\n-        separator: \",\",\n-        trailing_separator: if trailing_comma {\n-            SeparatorTactic::Always\n-        } else if context.inside_macro() && !exprs.is_empty() {\n-            let ends_with_bracket = context.snippet(span).ends_with(']');\n-            let bracket_offset = if ends_with_bracket { 1 } else { 0 };\n-            let snippet = context.snippet(mk_sp(span.lo(), span.hi() - BytePos(bracket_offset)));\n-            let last_char_index = snippet.rfind(|c: char| !c.is_whitespace())?;\n-            if &snippet[last_char_index..last_char_index + 1] == \",\" {\n-                SeparatorTactic::Always\n-            } else {\n-                SeparatorTactic::Never\n-            }\n-        } else if context.config.indent_style() == IndentStyle::Visual {\n-            SeparatorTactic::Never\n-        } else {\n-            SeparatorTactic::Vertical\n-        },\n-        separator_place: SeparatorPlace::Back,\n-        shape: nested_shape,\n-        ends_with_newline,\n-        preserve_newline: false,\n-        config: context.config,\n-    };\n-    let list_str = write_list(&items, &fmt)?;\n-\n-    let result = if context.config.indent_style() == IndentStyle::Visual\n-        || tactic == DefinitiveListTactic::Horizontal\n-    {\n-        if context.config.spaces_within_parens_and_brackets() && !list_str.is_empty() {\n-            format!(\"[ {} ]\", list_str)\n-        } else {\n-            format!(\"[{}]\", list_str)\n-        }\n-    } else {\n-        format!(\n-            \"[{}{}{}]\",\n-            nested_shape.indent.to_string_with_newline(context.config),\n-            list_str,\n-            shape.block().indent.to_string_with_newline(context.config)\n-        )\n-    };\n-\n-    Some(result)\n-}\n-\n-fn array_tactic<T: Rewrite + Spanned + ToExpr>(\n-    context: &RewriteContext,\n-    shape: Shape,\n-    nested_shape: Shape,\n-    exprs: &[&T],\n-    items: &[ListItem],\n-    bracket_size: usize,\n-) -> DefinitiveListTactic {\n-    let has_long_item = items\n-        .iter()\n-        .any(|li| li.item.as_ref().map(|s| s.len() > 10).unwrap_or(false));\n-\n-    match context.config.indent_style() {\n-        IndentStyle::Block => {\n-            let tactic = match shape.width.checked_sub(2 * bracket_size) {\n-                Some(width) => {\n-                    let tactic = ListTactic::LimitedHorizontalVertical(\n-                        context.config.width_heuristics().array_width,\n-                    );\n-                    definitive_tactic(items, tactic, Separator::Comma, width)\n-                }\n-                None => DefinitiveListTactic::Vertical,\n-            };\n-            if tactic == DefinitiveListTactic::Vertical && !has_long_item\n-                && is_every_expr_simple(exprs)\n-            {\n-                DefinitiveListTactic::Mixed\n-            } else {\n-                tactic\n-            }\n-        }\n-        IndentStyle::Visual => {\n-            if has_long_item || items.iter().any(ListItem::is_multiline) {\n-                definitive_tactic(\n-                    items,\n-                    ListTactic::LimitedHorizontalVertical(\n-                        context.config.width_heuristics().array_width,\n-                    ),\n-                    Separator::Comma,\n-                    nested_shape.width,\n-                )\n-            } else {\n-                DefinitiveListTactic::Mixed\n-            }\n-        }\n-    }\n+    overflow::rewrite_with_square_brackets(\n+        context,\n+        name,\n+        exprs,\n+        shape,\n+        span,\n+        force_separator_tactic,\n+        delim_token,\n+    )\n }\n \n fn rewrite_empty_block(\n@@ -1489,7 +1365,7 @@ fn is_simple_expr(expr: &ast::Expr) -> bool {\n     }\n }\n \n-fn is_every_expr_simple<T: ToExpr>(lists: &[&T]) -> bool {\n+pub fn is_every_expr_simple<T: ToExpr>(lists: &[&T]) -> bool {\n     lists\n         .iter()\n         .all(|arg| arg.to_expr().map_or(false, is_simple_expr))"}, {"sha": "05b1a7ce2963be91e8575f935ecf49fb3b741877", "filename": "src/lists.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98c6f7b7313c0053f822a10ab473f31bf1f480ef/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6f7b7313c0053f822a10ab473f31bf1f480ef/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=98c6f7b7313c0053f822a10ab473f31bf1f480ef", "patch": "@@ -101,7 +101,7 @@ impl ListItem {\n                 .map_or(false, |s| s.contains('\\n'))\n     }\n \n-    pub fn has_comment(&self) -> bool {\n+    pub fn has_single_line_comment(&self) -> bool {\n         self.pre_comment\n             .as_ref()\n             .map_or(false, |comment| comment.trim_left().starts_with(\"//\"))\n@@ -110,6 +110,10 @@ impl ListItem {\n                 .map_or(false, |comment| comment.trim_left().starts_with(\"//\"))\n     }\n \n+    pub fn has_comment(&self) -> bool {\n+        self.pre_comment.is_some() || self.post_comment.is_some()\n+    }\n+\n     pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n         ListItem {\n             pre_comment: None,\n@@ -164,7 +168,7 @@ where\n     let pre_line_comments = items\n         .clone()\n         .into_iter()\n-        .any(|item| item.as_ref().has_comment());\n+        .any(|item| item.as_ref().has_single_line_comment());\n \n     let limit = match tactic {\n         _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n@@ -266,11 +270,15 @@ where\n                     result.push_str(indent_str);\n                     line_len = 0;\n                     if formatting.ends_with_newline {\n-                        if last {\n-                            separate = true;\n-                        } else {\n-                            trailing_separator = true;\n-                        }\n+                        trailing_separator = true;\n+                    }\n+                }\n+\n+                if last && formatting.ends_with_newline {\n+                    match formatting.trailing_separator {\n+                        SeparatorTactic::Always => separate = true,\n+                        SeparatorTactic::Vertical if result.contains('\\n') => separate = true,\n+                        _ => (),\n                     }\n                 }\n "}, {"sha": "c65cc74b5f4877497c0e649e970a06b40d778838", "filename": "src/macros.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98c6f7b7313c0053f822a10ab473f31bf1f480ef/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6f7b7313c0053f822a10ab473f31bf1f480ef/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=98c6f7b7313c0053f822a10ab473f31bf1f480ef", "patch": "@@ -256,6 +256,7 @@ pub fn rewrite_macro_inner(\n         DelimToken::Bracket => {\n             // Handle special case: `vec![expr; expr]`\n             if vec_with_semi {\n+                let mac_shape = shape.offset_left(macro_name.len())?;\n                 let (lbr, rbr) = if context.config.spaces_within_parens_and_brackets() {\n                     (\"[ \", \" ]\")\n                 } else {\n@@ -287,25 +288,35 @@ pub fn rewrite_macro_inner(\n                 // If we are rewriting `vec!` macro or other special macros,\n                 // then we can rewrite this as an usual array literal.\n                 // Otherwise, we must preserve the original existence of trailing comma.\n-                if FORCED_BRACKET_MACROS.contains(&macro_name.as_str()) {\n+                let macro_name = &macro_name.as_str();\n+                let mut force_trailing_comma = if trailing_comma {\n+                    Some(SeparatorTactic::Always)\n+                } else {\n+                    Some(SeparatorTactic::Never)\n+                };\n+                if FORCED_BRACKET_MACROS.contains(macro_name) {\n                     context.inside_macro.replace(false);\n-                    trailing_comma = false;\n+                    if context.use_block_indent() {\n+                        force_trailing_comma = Some(SeparatorTactic::Vertical);\n+                    };\n                 }\n                 // Convert `MacroArg` into `ast::Expr`, as `rewrite_array` only accepts the latter.\n-                let sp = mk_sp(\n-                    context\n-                        .snippet_provider\n-                        .span_after(mac.span, original_style.opener()),\n-                    mac.span.hi() - BytePos(1),\n-                );\n                 let arg_vec = &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>()[..];\n-                let rewrite = rewrite_array(arg_vec, sp, context, mac_shape, trailing_comma)?;\n+                let rewrite = rewrite_array(\n+                    macro_name,\n+                    arg_vec,\n+                    mac.span,\n+                    context,\n+                    shape,\n+                    force_trailing_comma,\n+                    Some(original_style),\n+                )?;\n                 let comma = match position {\n                     MacroPosition::Item => \";\",\n                     _ => \"\",\n                 };\n \n-                Some(format!(\"{}{}{}\", macro_name, rewrite, comma))\n+                Some(format!(\"{}{}\", rewrite, comma))\n             }\n         }\n         DelimToken::Brace => {"}, {"sha": "6383d032273bdf4e4bcab637137b8d5ffd9f9417", "filename": "src/overflow.rs", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/98c6f7b7313c0053f822a10ab473f31bf1f480ef/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6f7b7313c0053f822a10ab473f31bf1f480ef/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=98c6f7b7313c0053f822a10ab473f31bf1f480ef", "patch": "@@ -14,10 +14,11 @@\n use config::lists::*;\n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::parse::token::DelimToken;\n \n use closures;\n use codemap::SpanUtils;\n-use expr::{is_nested_call, maybe_get_args_offset, ToExpr};\n+use expr::{is_every_expr_simple, is_nested_call, maybe_get_args_offset, ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n@@ -26,6 +27,8 @@ use utils::{count_newlines, extra_offset, first_line_width, last_line_width, mk_\n \n use std::cmp::min;\n \n+const SHORT_ITEM_THRESHOLD: usize = 10;\n+\n pub fn rewrite_with_parens<T>(\n     context: &RewriteContext,\n     ident: &str,\n@@ -48,6 +51,7 @@ where\n         \")\",\n         item_max_width,\n         force_separator_tactic,\n+        None,\n     ).rewrite(shape)\n }\n \n@@ -71,6 +75,38 @@ where\n         \">\",\n         context.config.max_width(),\n         None,\n+        None,\n+    ).rewrite(shape)\n+}\n+\n+pub fn rewrite_with_square_brackets<T>(\n+    context: &RewriteContext,\n+    name: &str,\n+    items: &[&T],\n+    shape: Shape,\n+    span: Span,\n+    force_separator_tactic: Option<SeparatorTactic>,\n+    delim_token: Option<DelimToken>,\n+) -> Option<String>\n+where\n+    T: Rewrite + ToExpr + Spanned,\n+{\n+    let (lhs, rhs) = match delim_token {\n+        Some(DelimToken::Paren) => (\"(\", \")\"),\n+        Some(DelimToken::Brace) => (\"{\", \"}\"),\n+        _ => (\"[\", \"]\"),\n+    };\n+    Context::new(\n+        context,\n+        items,\n+        name,\n+        shape,\n+        span,\n+        lhs,\n+        rhs,\n+        context.config.width_heuristics().array_width,\n+        force_separator_tactic,\n+        Some((\"[\", \"]\")),\n     ).rewrite(shape)\n }\n \n@@ -86,6 +122,7 @@ struct Context<'a, T: 'a> {\n     item_max_width: usize,\n     one_line_width: usize,\n     force_separator_tactic: Option<SeparatorTactic>,\n+    custom_delims: Option<(&'a str, &'a str)>,\n }\n \n impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n@@ -99,6 +136,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         suffix: &'static str,\n         item_max_width: usize,\n         force_separator_tactic: Option<SeparatorTactic>,\n+        custom_delims: Option<(&'a str, &'a str)>,\n     ) -> Context<'a, T> {\n         // 2 = `( `, 1 = `(`\n         let paren_overhead = if context.config.spaces_within_parens_and_brackets() {\n@@ -135,6 +173,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n             item_max_width,\n             one_line_width,\n             force_separator_tactic,\n+            custom_delims,\n         }\n     }\n \n@@ -301,6 +340,8 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                             if one_line {\n                                 tactic = DefinitiveListTactic::SpecialMacro(num_args_before);\n                             };\n+                        } else if is_every_expr_simple(self.items) && no_long_items(list_items) {\n+                            tactic = DefinitiveListTactic::Mixed;\n                         }\n                     }\n                 }\n@@ -339,13 +380,20 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                 tactic\n             } else if !self.context.use_block_indent() {\n                 SeparatorTactic::Never\n+            } else if tactic == DefinitiveListTactic::Mixed {\n+                // We are using mixed layout because everything did not fit within a single line.\n+                SeparatorTactic::Always\n             } else {\n                 self.context.config.trailing_comma()\n             },\n             separator_place: SeparatorPlace::Back,\n             shape: self.nested_shape,\n-            ends_with_newline: self.context.use_block_indent()\n-                && tactic == DefinitiveListTactic::Vertical,\n+            ends_with_newline: match tactic {\n+                DefinitiveListTactic::Vertical | DefinitiveListTactic::Mixed => {\n+                    self.context.use_block_indent()\n+                }\n+                _ => false,\n+            },\n             preserve_newline: false,\n             config: self.context.config,\n         };\n@@ -363,6 +411,10 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n             ..shape\n         };\n \n+        let (prefix, suffix) = match self.custom_delims {\n+            Some((lhs, rhs)) => (lhs, rhs),\n+            _ => (self.prefix, self.suffix),\n+        };\n         let paren_overhead = paren_overhead(self.context);\n         let fits_one_line = items_str.len() + paren_overhead <= shape.width;\n         let extend_width = if items_str.is_empty() {\n@@ -381,7 +433,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n             self.ident.len() + items_str.len() + 2 + indent_str.len() + nested_indent_str.len(),\n         );\n         result.push_str(self.ident);\n-        result.push_str(self.prefix);\n+        result.push_str(prefix);\n         if !self.context.use_block_indent()\n             || (self.context.inside_macro() && !items_str.contains('\\n') && fits_one_line)\n             || (is_extendable && extend_width <= shape.width)\n@@ -400,7 +452,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n             }\n             result.push_str(&indent_str);\n         }\n-        result.push_str(self.suffix);\n+        result.push_str(suffix);\n         result\n     }\n \n@@ -488,3 +540,8 @@ fn shape_from_indent_style(\n         }\n     }\n }\n+\n+fn no_long_items(list: &[ListItem]) -> bool {\n+    list.iter()\n+        .all(|item| !item.has_comment() && item.inner_as_ref().len() <= SHORT_ITEM_THRESHOLD)\n+}"}]}