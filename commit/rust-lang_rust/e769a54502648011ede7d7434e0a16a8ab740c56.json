{"sha": "e769a54502648011ede7d7434e0a16a8ab740c56", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NjlhNTQ1MDI2NDgwMTFlZGU3ZDc0MzRlMGExNmE4YWI3NDBjNTY=", "commit": {"author": {"name": "L\u00fac\u00e1s Meier", "email": "cronokirby@gmail.com", "date": "2019-10-03T20:48:35Z"}, "committer": {"name": "L\u00fac\u00e1s Meier", "email": "cronokirby@gmail.com", "date": "2019-10-03T20:48:35Z"}, "message": "Create an assist for applying De Morgan's law\n\nFixes #1807\n\nThis assist can transform expressions of the form `!x || !y` into\n`!(x && y)`. This also works with `&&`.\n\nThis assist will only trigger if the cursor is on the central logical\noperator.\n\nThe main limitation of this current implementation is that both operands\nneed to be an explicit negation, either of the form `!x`, or `x != y`.\nMore operands could be accepted, but this would complicate the implementation\nquite a bit.", "tree": {"sha": "f7a1c297c34a21eec9308de960df9063a6f5c878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7a1c297c34a21eec9308de960df9063a6f5c878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e769a54502648011ede7d7434e0a16a8ab740c56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e769a54502648011ede7d7434e0a16a8ab740c56", "html_url": "https://github.com/rust-lang/rust/commit/e769a54502648011ede7d7434e0a16a8ab740c56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e769a54502648011ede7d7434e0a16a8ab740c56/comments", "author": {"login": "cronokirby", "id": 22821947, "node_id": "MDQ6VXNlcjIyODIxOTQ3", "avatar_url": "https://avatars.githubusercontent.com/u/22821947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cronokirby", "html_url": "https://github.com/cronokirby", "followers_url": "https://api.github.com/users/cronokirby/followers", "following_url": "https://api.github.com/users/cronokirby/following{/other_user}", "gists_url": "https://api.github.com/users/cronokirby/gists{/gist_id}", "starred_url": "https://api.github.com/users/cronokirby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cronokirby/subscriptions", "organizations_url": "https://api.github.com/users/cronokirby/orgs", "repos_url": "https://api.github.com/users/cronokirby/repos", "events_url": "https://api.github.com/users/cronokirby/events{/privacy}", "received_events_url": "https://api.github.com/users/cronokirby/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cronokirby", "id": 22821947, "node_id": "MDQ6VXNlcjIyODIxOTQ3", "avatar_url": "https://avatars.githubusercontent.com/u/22821947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cronokirby", "html_url": "https://github.com/cronokirby", "followers_url": "https://api.github.com/users/cronokirby/followers", "following_url": "https://api.github.com/users/cronokirby/following{/other_user}", "gists_url": "https://api.github.com/users/cronokirby/gists{/gist_id}", "starred_url": "https://api.github.com/users/cronokirby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cronokirby/subscriptions", "organizations_url": "https://api.github.com/users/cronokirby/orgs", "repos_url": "https://api.github.com/users/cronokirby/repos", "events_url": "https://api.github.com/users/cronokirby/events{/privacy}", "received_events_url": "https://api.github.com/users/cronokirby/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad65ba40624a0f9d0ecbfbfc2671e20cb98db029", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad65ba40624a0f9d0ecbfbfc2671e20cb98db029", "html_url": "https://github.com/rust-lang/rust/commit/ad65ba40624a0f9d0ecbfbfc2671e20cb98db029"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "e4a8657ca6583e017ad761cc7e866c0a3a7591e3", "filename": "crates/ra_assists/src/assists/apply_demorgan.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e769a54502648011ede7d7434e0a16a8ab740c56/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e769a54502648011ede7d7434e0a16a8ab740c56/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs?ref=e769a54502648011ede7d7434e0a16a8ab740c56", "patch": "@@ -0,0 +1,115 @@\n+//! This contains the functions associated with the demorgan assist.\n+//! This assist transforms boolean expressions of the form `!a || !b` into\n+//! `!(a && b)`.\n+use hir::db::HirDatabase;\n+use ra_syntax::SyntaxNode;\n+use ra_syntax::ast::{AstNode, BinExpr, BinOp, Expr, PrefixOp};\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+\n+// Return the opposite text for a given logical operator, if it makes sense\n+fn opposite_logic_op(kind: BinOp) -> Option<&'static str> {\n+    match kind {\n+        BinOp::BooleanOr => Some(\"&&\"),\n+        BinOp::BooleanAnd => Some(\"||\"),\n+        _ => None,\n+    }\n+}\n+\n+// This function tries to undo unary negation, or inequality\n+fn undo_negation(node: SyntaxNode) -> Option<String> {\n+    match Expr::cast(node)? {\n+        Expr::BinExpr(bin) => match bin.op_kind()? {\n+            BinOp::NegatedEqualityTest => {\n+                let lhs = bin.lhs()?.syntax().text();\n+                let rhs = bin.rhs()?.syntax().text();\n+                Some(format!(\"{} == {}\", lhs, rhs))\n+            }\n+            _ => None\n+        }\n+        Expr::PrefixExpr(pe) => match pe.op_kind()? {\n+            PrefixOp::Not => {\n+                let child = pe.expr()?.syntax().text();\n+                Some(String::from(child))\n+            }\n+            _ => None\n+        }\n+        _ => None\n+    }\n+}\n+\n+/// Assist for applying demorgan's law\n+///\n+/// This transforms expressions of the form `!l || !r` into `!(l && r)`.\n+/// This also works with `&&`. This assist can only be applied with the cursor\n+/// on either `||` or `&&`, with both operands being a negation of some kind.\n+/// This means something of the form `!x` or `x != y`.\n+pub(crate) fn apply_demorgan(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let expr = ctx.node_at_offset::<BinExpr>()?;\n+    let op = expr.op_kind()?;\n+    let op_range = expr.op_token()?.text_range();\n+    let opposite_op = opposite_logic_op(op)?;\n+    let cursor_in_range = ctx.frange.range.is_subrange(&op_range);\n+    if !cursor_in_range {\n+        return None;\n+    }\n+    let lhs = expr.lhs()?.syntax().clone();\n+    let lhs_range = lhs.text_range();\n+    let rhs = expr.rhs()?.syntax().clone();\n+    let rhs_range = rhs.text_range();\n+    let not_lhs = undo_negation(lhs)?;\n+    let not_rhs = undo_negation(rhs)?;\n+\n+\n+    ctx.add_action(AssistId(\"apply_demorgan\"), \"apply demorgan's law\", |edit| {\n+        edit.target(op_range);\n+        edit.replace(op_range, opposite_op);\n+        edit.replace(lhs_range, format!(\"!({}\", not_lhs));\n+        edit.replace(rhs_range, format!(\"{})\", not_rhs));\n+    });\n+    ctx.build()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn demorgan_turns_and_into_or() {\n+        check_assist(\n+            apply_demorgan,\n+            \"fn f() { !x &&<|> !x }\",\n+            \"fn f() { !(x ||<|> x) }\"\n+        )\n+    }\n+\n+    #[test]\n+    fn demorgan_turns_or_into_and() {\n+        check_assist(\n+            apply_demorgan,\n+            \"fn f() { !x ||<|> !x }\",\n+            \"fn f() { !(x &&<|> x) }\"\n+        )\n+    }\n+\n+    #[test]\n+    fn demorgan_removes_inequality() {\n+        check_assist(\n+            apply_demorgan,\n+            \"fn f() { x != x ||<|> !x }\",\n+            \"fn f() { !(x == x &&<|> x) }\"\n+        )\n+    }\n+\n+    #[test]\n+    fn demorgan_doesnt_apply_with_cursor_not_on_op() {\n+        check_assist_not_applicable(apply_demorgan, \"fn f() { <|> !x || !x }\")\n+    }\n+\n+    #[test]\n+    fn demorgan_doesnt_apply_when_operands_arent_negated_already() {\n+        check_assist_not_applicable(apply_demorgan, \"fn f() { x ||<|> x }\")\n+    }\n+}"}]}