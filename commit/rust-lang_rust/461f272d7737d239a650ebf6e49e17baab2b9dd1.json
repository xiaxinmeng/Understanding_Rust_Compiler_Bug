{"sha": "461f272d7737d239a650ebf6e49e17baab2b9dd1", "node_id": "C_kwDOAAsO6NoAKDQ2MWYyNzJkNzczN2QyMzlhNjUwZWJmNmU0OWUxN2JhYWIyYjlkZDE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-01-23T08:59:23Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-01-23T08:59:23Z"}, "message": "Merge from rustc", "tree": {"sha": "8985468af9c8a1732c04def8a789421ac3899541", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8985468af9c8a1732c04def8a789421ac3899541"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/461f272d7737d239a650ebf6e49e17baab2b9dd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/461f272d7737d239a650ebf6e49e17baab2b9dd1", "html_url": "https://github.com/rust-lang/rust/commit/461f272d7737d239a650ebf6e49e17baab2b9dd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/461f272d7737d239a650ebf6e49e17baab2b9dd1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f055ad385f0f5a684f2658385dd47cf4df834af0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f055ad385f0f5a684f2658385dd47cf4df834af0", "html_url": "https://github.com/rust-lang/rust/commit/f055ad385f0f5a684f2658385dd47cf4df834af0"}, {"sha": "6520488e37f39a11affd776ab1283a0a3fe8087e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6520488e37f39a11affd776ab1283a0a3fe8087e", "html_url": "https://github.com/rust-lang/rust/commit/6520488e37f39a11affd776ab1283a0a3fe8087e"}], "stats": {"total": 1054, "additions": 824, "deletions": 230}, "files": [{"sha": "5f77656e5c189957be0dca0cb1047f2195795a4a", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -291,6 +291,14 @@ jobs:\n           - name: x86_64-gnu-distcheck\n             os: ubuntu-20.04-xl\n             env: {}\n+          - name: x86_64-gnu-llvm-15\n+            env:\n+              RUST_BACKTRACE: 1\n+            os: ubuntu-20.04-xl\n+          - name: x86_64-gnu-llvm-14\n+            env:\n+              RUST_BACKTRACE: 1\n+            os: ubuntu-20.04-xl\n           - name: x86_64-gnu-llvm-13\n             env:\n               RUST_BACKTRACE: 1"}, {"sha": "8ed692989ccbf73baf3dbe06012380237c5b3a56", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -325,6 +325,7 @@ Lennart Kudling <github@kudling.de>\n L\u00e9o Lanteri Thauvin <leseulartichaut@gmail.com>\n L\u00e9o Lanteri Thauvin <leseulartichaut@gmail.com> <38361244+LeSeulArtichaut@users.noreply.github.com>\n L\u00e9o Testard <leo.testard@gmail.com>\n+Le\u00f3n Orell Valerian Liehr <me@fmease.dev> <liehr.exchange@gmx.net>\n Leonardo Yvens <leoyvens@gmail.com>\n Liigo Zhuang <liigo@qq.com>\n Lily Ballard <lily@ballards.net> <kevin@sb.org>"}, {"sha": "8e1a3c57f0314e4e94756c50091ee73cec8147e2", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -4326,6 +4326,7 @@ dependencies = [\n name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags\",\n  \"libloading\",\n  \"odht\",\n  \"rustc_ast\","}, {"sha": "8bff66f8d5cca02c3c6b15e525e98347cad0d1e7", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -162,7 +162,7 @@ struct UniversalRegionIndices<'tcx> {\n     /// `ty::Region` to the internal `RegionVid` we are using. This is\n     /// used because trait matching and type-checking will feed us\n     /// region constraints that reference those regions and we need to\n-    /// be able to map them our internal `RegionVid`. This is\n+    /// be able to map them to our internal `RegionVid`. This is\n     /// basically equivalent to an `InternalSubsts`, except that it also\n     /// contains an entry for `ReStatic` -- it might be nice to just\n     /// use a substs, and then handle `ReStatic` another way."}, {"sha": "bd1626dff79515908687a64fd667223ab24ca127", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1233,6 +1233,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             sugg_sp = receiver.span;\n                         }\n                     }\n+\n+                    if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner) = expr.kind\n+                        && let Some(1) = self.deref_steps(expected, checked_ty) {\n+                        // We have `*&T`, check if what was expected was `&T`.\n+                        // If so, we may want to suggest removing a `*`.\n+                        sugg_sp = sugg_sp.with_hi(inner.span.lo());\n+                        return Some((\n+                            sugg_sp,\n+                            \"consider removing deref here\".to_string(),\n+                            \"\".to_string(),\n+                            Applicability::MachineApplicable,\n+                            true,\n+                            false,\n+                        ));\n+                    }\n+\n                     if let Ok(src) = sm.span_to_snippet(sugg_sp) {\n                         let needs_parens = match expr.kind {\n                             // parenthesize if needed (Issue #46756)"}, {"sha": "943dc9b9646fc63131cd4f4394b0b530f7bbd978", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -196,8 +196,6 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     ) -> FxHashMap<Ty<'tcx>, Ty<'tcx>> {\n         debug!(\"calculate_diverging_fallback({:?})\", unsolved_variables);\n \n-        let relationships = self.fulfillment_cx.borrow_mut().relationships().clone();\n-\n         // Construct a coercion graph where an edge `A -> B` indicates\n         // a type variable is that is coerced\n         let coercion_graph = self.create_coercion_graph();\n@@ -281,9 +279,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             roots_reachable_from_non_diverging,\n         );\n \n-        debug!(\"inherited: {:#?}\", self.inh.fulfillment_cx.borrow_mut().pending_obligations());\n         debug!(\"obligations: {:#?}\", self.fulfillment_cx.borrow_mut().pending_obligations());\n-        debug!(\"relationships: {:#?}\", relationships);\n \n         // For each diverging variable, figure out whether it can\n         // reach a member of N. If so, it falls back to `()`. Else\n@@ -297,16 +293,16 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n                 .depth_first_search(root_vid)\n                 .any(|n| roots_reachable_from_non_diverging.visited(n));\n \n-            let mut relationship = ty::FoundRelationships { self_in_trait: false, output: false };\n+            let mut found_infer_var_info = ty::InferVarInfo { self_in_trait: false, output: false };\n \n-            for (vid, rel) in relationships.iter() {\n-                if self.root_var(*vid) == root_vid {\n-                    relationship.self_in_trait |= rel.self_in_trait;\n-                    relationship.output |= rel.output;\n+            for (vid, info) in self.inh.infer_var_info.borrow().iter() {\n+                if self.infcx.root_var(*vid) == root_vid {\n+                    found_infer_var_info.self_in_trait |= info.self_in_trait;\n+                    found_infer_var_info.output |= info.output;\n                 }\n             }\n \n-            if relationship.self_in_trait && relationship.output {\n+            if found_infer_var_info.self_in_trait && found_infer_var_info.output {\n                 // This case falls back to () to ensure that the code pattern in\n                 // tests/ui/never_type/fallback-closure-ret.rs continues to\n                 // compile when never_type_fallback is enabled."}, {"sha": "ba34f299453ecff0473190c130ccf5643542d351", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,6 +1,6 @@\n use super::callee::DeferredCallResolution;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n@@ -10,7 +10,8 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefIdMap;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits::{self, TraitEngine, TraitEngineExt as _};\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, PredicateObligation, TraitEngine, TraitEngineExt as _};\n \n use std::cell::RefCell;\n use std::ops::Deref;\n@@ -63,6 +64,8 @@ pub struct Inherited<'tcx> {\n     /// we record that type variable here. This is later used to inform\n     /// fallback. See the `fallback` module for details.\n     pub(super) diverging_type_vars: RefCell<FxHashSet<Ty<'tcx>>>,\n+\n+    pub(super) infer_var_info: RefCell<FxHashMap<ty::TyVid, ty::InferVarInfo>>,\n }\n \n impl<'tcx> Deref for Inherited<'tcx> {\n@@ -128,6 +131,7 @@ impl<'tcx> Inherited<'tcx> {\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n             diverging_type_vars: RefCell::new(Default::default()),\n             body_id,\n+            infer_var_info: RefCell::new(Default::default()),\n         }\n     }\n \n@@ -136,6 +140,9 @@ impl<'tcx> Inherited<'tcx> {\n         if obligation.has_escaping_bound_vars() {\n             span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\", obligation);\n         }\n+\n+        self.update_infer_var_info(&obligation);\n+\n         self.fulfillment_cx.borrow_mut().register_predicate_obligation(self, obligation);\n     }\n \n@@ -152,4 +159,43 @@ impl<'tcx> Inherited<'tcx> {\n         self.register_predicates(infer_ok.obligations);\n         infer_ok.value\n     }\n+\n+    pub fn update_infer_var_info(&self, obligation: &PredicateObligation<'tcx>) {\n+        let infer_var_info = &mut self.infer_var_info.borrow_mut();\n+\n+        // (*) binder skipped\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(tpred)) = obligation.predicate.kind().skip_binder()\n+            && let Some(ty) = self.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| self.root_var(t))\n+            && self.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n+        {\n+            let new_self_ty = self.tcx.types.unit;\n+\n+            // Then construct a new obligation with Self = () added\n+            // to the ParamEnv, and see if it holds.\n+            let o = obligation.with(self.tcx,\n+                obligation\n+                    .predicate\n+                    .kind()\n+                    .rebind(\n+                        // (*) binder moved here\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(tpred.with_self_ty(self.tcx, new_self_ty)))\n+                    ),\n+            );\n+            // Don't report overflow errors. Otherwise equivalent to may_hold.\n+            if let Ok(result) = self.probe(|_| self.evaluate_obligation(&o)) && result.may_apply() {\n+                infer_var_info.entry(ty).or_default().self_in_trait = true;\n+            }\n+        }\n+\n+        if let ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) =\n+            obligation.predicate.kind().skip_binder()\n+        {\n+            // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n+            // we need to make it into one.\n+            if let Some(vid) = predicate.term.ty().and_then(|ty| ty.ty_vid()) {\n+                debug!(\"infer_var_info: {:?}.output = true\", vid);\n+                infer_var_info.entry(vid).or_default().output = true;\n+            }\n+        }\n+    }\n }"}, {"sha": "47396204b14e7c50314d32a35ef9ecbd8bc7bb01", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -76,7 +76,7 @@ pub struct NoMatchData<'tcx> {\n     pub unsatisfied_predicates:\n         Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n     pub out_of_scope_traits: Vec<DefId>,\n-    pub lev_candidate: Option<ty::AssocItem>,\n+    pub similar_candidate: Option<ty::AssocItem>,\n     pub mode: probe::Mode,\n }\n "}, {"sha": "9c06a22315bcba12189377e2770e9884588d5e5f", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     static_candidates: Vec::new(),\n                     unsatisfied_predicates: Vec::new(),\n                     out_of_scope_traits: Vec::new(),\n-                    lev_candidate: None,\n+                    similar_candidate: None,\n                     mode,\n                 }));\n             }\n@@ -1076,13 +1076,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         if let Some((kind, def_id)) = private_candidate {\n             return Err(MethodError::PrivateMatch(kind, def_id, out_of_scope_traits));\n         }\n-        let lev_candidate = self.probe_for_lev_candidate()?;\n+        let similar_candidate = self.probe_for_similar_candidate()?;\n \n         Err(MethodError::NoMatch(NoMatchData {\n             static_candidates,\n             unsatisfied_predicates,\n             out_of_scope_traits,\n-            lev_candidate,\n+            similar_candidate,\n             mode: self.mode,\n         }))\n     }\n@@ -1787,7 +1787,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n     /// candidate method where the method name may have been misspelled. Similarly to other\n     /// Levenshtein based suggestions, we provide at most one such suggestion.\n-    fn probe_for_lev_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n+    fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n         let steps = self.steps.clone();\n@@ -1831,6 +1831,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         None,\n                     )\n                 }\n+                .or_else(|| {\n+                    applicable_close_candidates\n+                        .iter()\n+                        .find(|cand| self.matches_by_doc_alias(cand.def_id))\n+                        .map(|cand| cand.name)\n+                })\n                 .unwrap();\n                 Ok(applicable_close_candidates.into_iter().find(|method| method.name == best_name))\n             }\n@@ -1981,6 +1987,38 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n+    /// Determine if the associated item withe the given DefId matches\n+    /// the desired name via a doc alias.\n+    fn matches_by_doc_alias(&self, def_id: DefId) -> bool {\n+        let Some(name) = self.method_name else { return false; };\n+        let Some(local_def_id) = def_id.as_local() else { return false; };\n+        let hir_id = self.fcx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        let attrs = self.fcx.tcx.hir().attrs(hir_id);\n+        for attr in attrs {\n+            let sym::doc = attr.name_or_empty() else { continue; };\n+            let Some(values) = attr.meta_item_list() else { continue; };\n+            for v in values {\n+                if v.name_or_empty() != sym::alias {\n+                    continue;\n+                }\n+                if let Some(nested) = v.meta_item_list() {\n+                    // #[doc(alias(\"foo\", \"bar\"))]\n+                    for n in nested {\n+                        if let Some(lit) = n.lit() && name.as_str() == lit.symbol.as_str() {\n+                            return true;\n+                        }\n+                    }\n+                } else if let Some(meta) = v.meta_item()\n+                    && let Some(lit) = meta.name_value_literal()\n+                    && name.as_str() == lit.symbol.as_str() {\n+                        // #[doc(alias = \"foo\")]\n+                        return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     /// Finds the method with the appropriate name (or return type, as the case may be). If\n     /// `allow_similar_names` is set, find methods with close-matching names.\n     // The length of the returned iterator is nearly always 0 or 1 and this\n@@ -1996,6 +2034,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if !self.is_relevant_kind_for_mode(x.kind) {\n                             return false;\n                         }\n+                        if self.matches_by_doc_alias(x.def_id) {\n+                            return true;\n+                        }\n                         match lev_distance_with_substrings(name.as_str(), x.name.as_str(), max_dist)\n                         {\n                             Some(d) => d > 0,"}, {"sha": "8c54e9bdb5fb3a3ae7670f01c5d8e3b66c346b98", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n         let is_method = mode == Mode::MethodCall;\n         let unsatisfied_predicates = &no_match_data.unsatisfied_predicates;\n-        let lev_candidate = no_match_data.lev_candidate;\n+        let similar_candidate = no_match_data.similar_candidate;\n         let item_kind = if is_method {\n             \"method\"\n         } else if rcvr_ty.is_enum() {\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // give a helping note that it has to be called as `(x.f)(...)`.\n         if let SelfSource::MethodCall(expr) = source {\n             if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n-                && lev_candidate.is_none()\n+                && similar_candidate.is_none()\n                 && !custom_span_label\n             {\n                 label_span_not_found(&mut err);\n@@ -1015,20 +1015,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if fallback_span {\n                 err.span_label(span, msg);\n             }\n-        } else if let Some(lev_candidate) = lev_candidate {\n+        } else if let Some(similar_candidate) = similar_candidate {\n             // Don't emit a suggestion if we found an actual method\n             // that had unsatisfied trait bounds\n             if unsatisfied_predicates.is_empty() {\n-                let def_kind = lev_candidate.kind.as_def_kind();\n+                let def_kind = similar_candidate.kind.as_def_kind();\n                 // Methods are defined within the context of a struct and their first parameter is always self,\n                 // which represents the instance of the struct the method is being called on\n                 // Associated functions don\u2019t take self as a parameter and\n                 // they are not methods because they don\u2019t have an instance of the struct to work with.\n-                if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n+                if def_kind == DefKind::AssocFn && similar_candidate.fn_has_self_parameter {\n                     err.span_suggestion(\n                         span,\n                         \"there is a method with a similar name\",\n-                        lev_candidate.name,\n+                        similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n@@ -1037,9 +1037,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &format!(\n                             \"there is {} {} with a similar name\",\n                             def_kind.article(),\n-                            def_kind.descr(lev_candidate.def_id),\n+                            def_kind.descr(similar_candidate.def_id),\n                         ),\n-                        lev_candidate.name,\n+                        similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n                 }"}, {"sha": "fcde00056cbf1c4cf4738e80e851497506a05dcf", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,6 +1,5 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, ToPredicate, Ty};\n \n@@ -42,8 +41,6 @@ pub trait TraitEngine<'tcx>: 'tcx {\n     fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n-\n-    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships>;\n }\n \n pub trait TraitEngineExt<'tcx> {"}, {"sha": "bee5c8541d68ee9f5f580e80871ef486e9fe74d5", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -6,6 +6,7 @@ edition = \"2021\"\n [lib]\n \n [dependencies]\n+bitflags = \"1.2.1\"\n libloading = \"0.7.1\"\n odht = { version = \"0.3.1\", features = [\"nightly\"] }\n snap = \"1\""}, {"sha": "44da3fbe300ca1cf4d4c167f1efb3c4a67df1e2c", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1594,8 +1594,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             })\n     }\n \n-    fn get_may_have_doc_links(self, index: DefIndex) -> bool {\n-        self.root.tables.may_have_doc_links.get(self, index).is_some()\n+    fn get_attr_flags(self, index: DefIndex) -> AttrFlags {\n+        self.root.tables.attr_flags.get(self, index).unwrap_or(AttrFlags::empty())\n     }\n \n     fn get_is_intrinsic(self, index: DefIndex) -> bool {"}, {"sha": "2fa645cd9e33de1a4dfdf1f31362ee26392cffaf", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,6 +1,7 @@\n use crate::creader::{CStore, LoadedMacro};\n use crate::foreign_modules;\n use crate::native_libs;\n+use crate::rmeta::AttrFlags;\n \n use rustc_ast as ast;\n use rustc_attr::Deprecation;\n@@ -338,6 +339,7 @@ provide! { tcx, def_id, other, cdata,\n     crate_extern_paths => { cdata.source().paths().cloned().collect() }\n     expn_that_defined => { cdata.get_expn_that_defined(def_id.index, tcx.sess) }\n     generator_diagnostic_data => { cdata.get_generator_diagnostic_data(tcx, def_id.index) }\n+    is_doc_hidden => { cdata.get_attr_flags(def_id.index).contains(AttrFlags::IS_DOC_HIDDEN) }\n }\n \n pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n@@ -425,7 +427,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                         return;\n                     }\n \n-                    if ty::util::is_doc_hidden(tcx, parent) {\n+                    if tcx.is_doc_hidden(parent) {\n                         fallback_map.push((def_id, parent));\n                         return;\n                     }\n@@ -631,7 +633,9 @@ impl CStore {\n     }\n \n     pub fn may_have_doc_links_untracked(&self, def_id: DefId) -> bool {\n-        self.get_crate_data(def_id.krate).get_may_have_doc_links(def_id.index)\n+        self.get_crate_data(def_id.krate)\n+            .get_attr_flags(def_id.index)\n+            .contains(AttrFlags::MAY_HAVE_DOC_LINKS)\n     }\n }\n "}, {"sha": "2ecaa33d4d315b604fb10bafd12345e923517652", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1111,15 +1111,26 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n         let mut is_public: Option<bool> = None;\n \n-        let mut attrs = tcx\n-            .hir()\n-            .attrs(tcx.hir().local_def_id_to_hir_id(def_id))\n+        let hir_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n+        let mut attrs = hir_attrs\n             .iter()\n             .filter(move |attr| should_encode_attr(tcx, attr, def_id, &mut is_public));\n \n         record_array!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n+        let mut attr_flags = AttrFlags::empty();\n         if attrs.any(|attr| attr.may_have_doc_links()) {\n-            self.tables.may_have_doc_links.set(def_id.local_def_index, ());\n+            attr_flags |= AttrFlags::MAY_HAVE_DOC_LINKS;\n+        }\n+        if hir_attrs\n+            .iter()\n+            .filter(|attr| attr.has_name(sym::doc))\n+            .filter_map(|attr| attr.meta_item_list())\n+            .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))\n+        {\n+            attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n+        }\n+        if !attr_flags.is_empty() {\n+            self.tables.attr_flags.set(def_id.local_def_index, attr_flags);\n         }\n     }\n "}, {"sha": "69690264ae4ea5e96d7ffd1642d322028effd3ef", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -395,7 +395,7 @@ define_tables! {\n     def_path_hashes: Table<DefIndex, DefPathHash>,\n     proc_macro_quoted_spans: Table<usize, LazyValue<Span>>,\n     generator_diagnostic_data: Table<DefIndex, LazyValue<GeneratorDiagnosticData<'static>>>,\n-    may_have_doc_links: Table<DefIndex, ()>,\n+    attr_flags: Table<DefIndex, AttrFlags>,\n     variant_data: Table<DefIndex, LazyValue<VariantData>>,\n     assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n     // Slot is full when macro is macro_rules.\n@@ -418,6 +418,13 @@ struct VariantData {\n     is_non_exhaustive: bool,\n }\n \n+bitflags::bitflags! {\n+    pub struct AttrFlags: u8 {\n+        const MAY_HAVE_DOC_LINKS = 1 << 0;\n+        const IS_DOC_HIDDEN      = 1 << 1;\n+    }\n+}\n+\n // Tags used for encoding Spans:\n const TAG_VALID_SPAN_LOCAL: u8 = 0;\n const TAG_VALID_SPAN_FOREIGN: u8 = 1;\n@@ -440,4 +447,5 @@ trivially_parameterized_over_tcx! {\n     IncoherentImpls,\n     CrateRoot,\n     CrateDep,\n+    AttrFlags,\n }"}, {"sha": "dc003227d40bd1d63ff84d2d245d196524776029", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -199,6 +199,20 @@ impl FixedSizeEncoding for Option<RawDefId> {\n     }\n }\n \n+impl FixedSizeEncoding for Option<AttrFlags> {\n+    type ByteArray = [u8; 1];\n+\n+    #[inline]\n+    fn from_bytes(b: &[u8; 1]) -> Self {\n+        (b[0] != 0).then(|| AttrFlags::from_bits_truncate(b[0]))\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 1]) {\n+        b[0] = self.map_or(0, |flags| flags.bits())\n+    }\n+}\n+\n impl FixedSizeEncoding for Option<()> {\n     type ByteArray = [u8; 1];\n "}, {"sha": "7db86c8d0d4545f355f1b94f7734c713883dbbc9", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1157,6 +1157,7 @@ rustc_queries! {\n     /// Determines whether an item is annotated with `doc(hidden)`.\n     query is_doc_hidden(def_id: DefId) -> bool {\n         desc { |tcx| \"checking whether `{}` is `doc(hidden)`\", tcx.def_path_str(def_id) }\n+        separate_provide_extern\n     }\n \n     /// Determines whether an item is annotated with `doc(notable_trait)`."}, {"sha": "f83bceca3b53ba27bdcab4885698a9ea0193c60d", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -2619,7 +2619,7 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n }\n \n #[derive(Debug, Default, Copy, Clone)]\n-pub struct FoundRelationships {\n+pub struct InferVarInfo {\n     /// This is true if we identified that this Ty (`?T`) is found in a `?T: Foo`\n     /// obligation, where:\n     ///"}, {"sha": "60076c8cb5f9936d0e16e93798b279fb0d2a0fdc", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1310,7 +1310,8 @@ pub fn reveal_opaque_types_in_bounds<'tcx>(\n }\n \n /// Determines whether an item is annotated with `doc(hidden)`.\n-pub fn is_doc_hidden(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+fn is_doc_hidden(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    assert!(def_id.is_local());\n     tcx.get_attrs(def_id, sym::doc)\n         .filter_map(|attr| attr.meta_item_list())\n         .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))"}, {"sha": "40b9bedc84fd3afd8292c2c721bee97d1d8b62de", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,14 +1,12 @@\n use std::mem;\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_infer::{\n     infer::InferCtxt,\n     traits::{\n         query::NoSolution, FulfillmentError, FulfillmentErrorCode, PredicateObligation,\n         SelectionError, TraitEngine,\n     },\n };\n-use rustc_middle::ty;\n \n use super::{search_graph, Certainty, EvalCtxt};\n \n@@ -102,8 +100,4 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.clone()\n     }\n-\n-    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n-        unimplemented!(\"Should be moved out of `TraitEngine`\")\n-    }\n }"}, {"sha": "61d09189798ea2d82eda6eff65546dde89c3adb2", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -7,24 +7,18 @@ use crate::traits::{\n     ChalkEnvironmentAndGoal, FulfillmentError, FulfillmentErrorCode, PredicateObligation,\n     SelectionError, TraitEngine,\n };\n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_middle::ty::{self, TypeVisitable};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_middle::ty::TypeVisitable;\n \n pub struct FulfillmentContext<'tcx> {\n     obligations: FxIndexSet<PredicateObligation<'tcx>>,\n \n-    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n-\n     usable_in_snapshot: bool,\n }\n \n impl FulfillmentContext<'_> {\n     pub(super) fn new() -> Self {\n-        FulfillmentContext {\n-            obligations: FxIndexSet::default(),\n-            relationships: FxHashMap::default(),\n-            usable_in_snapshot: false,\n-        }\n+        FulfillmentContext { obligations: FxIndexSet::default(), usable_in_snapshot: false }\n     }\n \n     pub(crate) fn new_in_snapshot() -> Self {\n@@ -43,8 +37,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         }\n         let obligation = infcx.resolve_vars_if_possible(obligation);\n \n-        super::relationships::update(self, infcx, &obligation);\n-\n         self.obligations.insert(obligation);\n     }\n \n@@ -154,8 +146,4 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.iter().cloned().collect()\n     }\n-\n-    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n-        &mut self.relationships\n-    }\n }"}, {"sha": "5a58d37e18362694dc1b5ec00ec16c22c20a15c7", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,5 +1,4 @@\n use crate::infer::{InferCtxt, TyOrConstInferVar};\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n@@ -54,8 +53,6 @@ pub struct FulfillmentContext<'tcx> {\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n \n-    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n-\n     // Is it OK to register obligations into this infcx inside\n     // an infcx snapshot?\n     //\n@@ -85,19 +82,11 @@ static_assert_size!(PendingPredicateObligation<'_>, 72);\n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub(super) fn new() -> FulfillmentContext<'tcx> {\n-        FulfillmentContext {\n-            predicates: ObligationForest::new(),\n-            relationships: FxHashMap::default(),\n-            usable_in_snapshot: false,\n-        }\n+        FulfillmentContext { predicates: ObligationForest::new(), usable_in_snapshot: false }\n     }\n \n     pub(super) fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n-        FulfillmentContext {\n-            predicates: ObligationForest::new(),\n-            relationships: FxHashMap::default(),\n-            usable_in_snapshot: true,\n-        }\n+        FulfillmentContext { predicates: ObligationForest::new(), usable_in_snapshot: true }\n     }\n \n     /// Attempts to select obligations using `selcx`.\n@@ -139,8 +128,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);\n \n-        super::relationships::update(self, infcx, &obligation);\n-\n         self.predicates\n             .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });\n     }\n@@ -164,10 +151,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.predicates.map_pending_obligations(|o| o.obligation.clone())\n     }\n-\n-    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n-        &mut self.relationships\n-    }\n }\n \n struct FulfillProcessor<'a, 'tcx> {"}, {"sha": "3c640cdc503ceba9010ffe62f5119be36868ff2f", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -14,7 +14,6 @@ mod object_safety;\n pub mod outlives_bounds;\n mod project;\n pub mod query;\n-pub(crate) mod relationships;\n mod select;\n mod specialize;\n mod structural_match;"}, {"sha": "34b5fc4891eb36643e65c2412e8ac70330559e55", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f055ad385f0f5a684f2658385dd47cf4df834af0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f055ad385f0f5a684f2658385dd47cf4df834af0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=f055ad385f0f5a684f2658385dd47cf4df834af0", "patch": "@@ -1,48 +0,0 @@\n-use crate::infer::InferCtxt;\n-use crate::traits::query::evaluate_obligation::InferCtxtExt;\n-use crate::traits::PredicateObligation;\n-use rustc_infer::traits::TraitEngine;\n-use rustc_middle::ty;\n-\n-pub(crate) fn update<'tcx, T>(\n-    engine: &mut T,\n-    infcx: &InferCtxt<'tcx>,\n-    obligation: &PredicateObligation<'tcx>,\n-) where\n-    T: TraitEngine<'tcx>,\n-{\n-    // (*) binder skipped\n-    if let ty::PredicateKind::Clause(ty::Clause::Trait(tpred)) = obligation.predicate.kind().skip_binder()\n-        && let Some(ty) = infcx.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n-        && infcx.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n-    {\n-        let new_self_ty = infcx.tcx.types.unit;\n-\n-        // Then construct a new obligation with Self = () added\n-        // to the ParamEnv, and see if it holds.\n-        let o = obligation.with(infcx.tcx,\n-            obligation\n-                .predicate\n-                .kind()\n-                .rebind(\n-                    // (*) binder moved here\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(tpred.with_self_ty(infcx.tcx, new_self_ty)))\n-                ),\n-        );\n-        // Don't report overflow errors. Otherwise equivalent to may_hold.\n-        if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) && result.may_apply() {\n-            engine.relationships().entry(ty).or_default().self_in_trait = true;\n-        }\n-    }\n-\n-    if let ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) =\n-        obligation.predicate.kind().skip_binder()\n-    {\n-        // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n-        // we need to make it into one.\n-        if let Some(vid) = predicate.term.ty().and_then(|ty| ty.ty_vid()) {\n-            debug!(\"relationship: {:?}.output = true\", vid);\n-            engine.relationships().entry(vid).or_default().output = true;\n-        }\n-    }\n-}"}, {"sha": "9bc9182f7b53c3b170d0634ed959164f5b4204ea", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -654,6 +654,20 @@ impl<T> Arc<T> {\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n+    // FIXME: when `Arc::into_inner` is stabilized, add this paragraph:\n+    /*\n+    /// It is strongly recommended to use [`Arc::into_inner`] instead if you don't\n+    /// want to keep the `Arc` in the [`Err`] case.\n+    /// Immediately dropping the [`Err`] payload, like in the expression\n+    /// `Arc::try_unwrap(this).ok()`, can still cause the strong count to\n+    /// drop to zero and the inner value of the `Arc` to be dropped:\n+    /// For instance if two threads execute this expression in parallel, then\n+    /// there is a race condition. The threads could first both check whether they\n+    /// have the last clone of their `Arc` via `Arc::try_unwrap`, and then\n+    /// both drop their `Arc` in the call to [`ok`][`Result::ok`],\n+    /// taking the strong count from two down to zero.\n+    ///\n+     */\n     /// # Examples\n     ///\n     /// ```\n@@ -685,6 +699,137 @@ impl<T> Arc<T> {\n             Ok(elem)\n         }\n     }\n+\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n+    ///\n+    /// Otherwise, [`None`] is returned and the `Arc` is dropped.\n+    ///\n+    /// This will succeed even if there are outstanding weak references.\n+    ///\n+    /// If `Arc::into_inner` is called on every clone of this `Arc`,\n+    /// it is guaranteed that exactly one of the calls returns the inner value.\n+    /// This means in particular that the inner value is not dropped.\n+    ///\n+    /// The similar expression `Arc::try_unwrap(this).ok()` does not\n+    /// offer such a guarantee. See the last example below.\n+    //\n+    // FIXME: when `Arc::into_inner` is stabilized, add this to end\n+    // of the previous sentence:\n+    /*\n+    /// and the documentation of [`Arc::try_unwrap`].\n+     */\n+    ///\n+    /// # Examples\n+    ///\n+    /// Minimal example demonstrating the guarantee that `Arc::into_inner` gives.\n+    /// ```\n+    /// #![feature(arc_into_inner)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(3);\n+    /// let y = Arc::clone(&x);\n+    ///\n+    /// // Two threads calling `Arc::into_inner` on both clones of an `Arc`:\n+    /// let x_thread = std::thread::spawn(|| Arc::into_inner(x));\n+    /// let y_thread = std::thread::spawn(|| Arc::into_inner(y));\n+    ///\n+    /// let x_inner_value = x_thread.join().unwrap();\n+    /// let y_inner_value = y_thread.join().unwrap();\n+    ///\n+    /// // One of the threads is guaranteed to receive the inner value:\n+    /// assert!(matches!(\n+    ///     (x_inner_value, y_inner_value),\n+    ///     (None, Some(3)) | (Some(3), None)\n+    /// ));\n+    /// // The result could also be `(None, None)` if the threads called\n+    /// // `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.\n+    /// ```\n+    ///\n+    /// A more practical example demonstrating the need for `Arc::into_inner`:\n+    /// ```\n+    /// #![feature(arc_into_inner)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// // Definition of a simple singly linked list using `Arc`:\n+    /// #[derive(Clone)]\n+    /// struct LinkedList<T>(Option<Arc<Node<T>>>);\n+    /// struct Node<T>(T, Option<Arc<Node<T>>>);\n+    ///\n+    /// // Dropping a long `LinkedList<T>` relying on the destructor of `Arc`\n+    /// // can cause a stack overflow. To prevent this, we can provide a\n+    /// // manual `Drop` implementation that does the destruction in a loop:\n+    /// impl<T> Drop for LinkedList<T> {\n+    ///     fn drop(&mut self) {\n+    ///         let mut link = self.0.take();\n+    ///         while let Some(arc_node) = link.take() {\n+    ///             if let Some(Node(_value, next)) = Arc::into_inner(arc_node) {\n+    ///                 link = next;\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// // Implementation of `new` and `push` omitted\n+    /// impl<T> LinkedList<T> {\n+    ///     /* ... */\n+    /// #   fn new() -> Self {\n+    /// #       LinkedList(None)\n+    /// #   }\n+    /// #   fn push(&mut self, x: T) {\n+    /// #       self.0 = Some(Arc::new(Node(x, self.0.take())));\n+    /// #   }\n+    /// }\n+    ///\n+    /// // The following code could have still caused a stack overflow\n+    /// // despite the manual `Drop` impl if that `Drop` impl had used\n+    /// // `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.\n+    ///\n+    /// // Create a long list and clone it\n+    /// let mut x = LinkedList::new();\n+    /// for i in 0..100000 {\n+    ///     x.push(i); // Adds i to the front of x\n+    /// }\n+    /// let y = x.clone();\n+    ///\n+    /// // Drop the clones in parallel\n+    /// let x_thread = std::thread::spawn(|| drop(x));\n+    /// let y_thread = std::thread::spawn(|| drop(y));\n+    /// x_thread.join().unwrap();\n+    /// y_thread.join().unwrap();\n+    /// ```\n+\n+    // FIXME: when `Arc::into_inner` is stabilized, adjust above documentation\n+    // and the documentation of `Arc::try_unwrap` according to the `FIXME`s. Also\n+    // open an issue on rust-lang/rust-clippy, asking for a lint against\n+    // `Arc::try_unwrap(...).ok()`.\n+    #[inline]\n+    #[unstable(feature = \"arc_into_inner\", issue = \"106894\")]\n+    pub fn into_inner(this: Self) -> Option<T> {\n+        // Make sure that the ordinary `Drop` implementation isn\u2019t called as well\n+        let mut this = mem::ManuallyDrop::new(this);\n+\n+        // Following the implementation of `drop` and `drop_slow`\n+        if this.inner().strong.fetch_sub(1, Release) != 1 {\n+            return None;\n+        }\n+\n+        acquire!(this.inner().strong);\n+\n+        // SAFETY: This mirrors the line\n+        //\n+        //     unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };\n+        //\n+        // in `drop_slow`. Instead of dropping the value behind the pointer,\n+        // it is read and eventually returned; `ptr::read` has the same\n+        // safety conditions as `ptr::drop_in_place`.\n+        let inner = unsafe { ptr::read(Self::get_mut_unchecked(&mut this)) };\n+\n+        drop(Weak { ptr: this.ptr });\n+\n+        Some(inner)\n+    }\n }\n \n impl<T> Arc<[T]> {"}, {"sha": "863d58bdf4d9cdad35f341f1aeb519a67f9bb63f", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -101,6 +101,38 @@ fn try_unwrap() {\n     assert_eq!(Arc::try_unwrap(x), Ok(5));\n }\n \n+#[test]\n+fn into_inner() {\n+    for _ in 0..100\n+    // ^ Increase chances of hitting potential race conditions\n+    {\n+        let x = Arc::new(3);\n+        let y = Arc::clone(&x);\n+        let r_thread = std::thread::spawn(|| Arc::into_inner(x));\n+        let s_thread = std::thread::spawn(|| Arc::into_inner(y));\n+        let r = r_thread.join().expect(\"r_thread panicked\");\n+        let s = s_thread.join().expect(\"s_thread panicked\");\n+        assert!(\n+            matches!((r, s), (None, Some(3)) | (Some(3), None)),\n+            \"assertion failed: unexpected result `{:?}`\\\n+            \\n  expected `(None, Some(3))` or `(Some(3), None)`\",\n+            (r, s),\n+        );\n+    }\n+\n+    let x = Arc::new(3);\n+    assert_eq!(Arc::into_inner(x), Some(3));\n+\n+    let x = Arc::new(4);\n+    let y = Arc::clone(&x);\n+    assert_eq!(Arc::into_inner(x), None);\n+    assert_eq!(Arc::into_inner(y), Some(4));\n+\n+    let x = Arc::new(5);\n+    let _w = Arc::downgrade(&x);\n+    assert_eq!(Arc::into_inner(x), Some(5));\n+}\n+\n #[test]\n fn into_from_raw() {\n     let x = Arc::new(Box::new(\"hello\"));"}, {"sha": "99cc01863104850f21f1aba37334021cc8cba5f6", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -238,7 +238,6 @@\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n-#![feature(box_syntax)]\n #![feature(c_unwind)]\n #![feature(cfg_target_thread_local)]\n #![feature(concat_idents)]"}, {"sha": "7e85d6a063a785fba7e5e182cc9c4e9d55ff2323", "filename": "library/std/src/sync/lazy_lock.rs", "status": "modified", "additions": 70, "deletions": 16, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,8 +1,21 @@\n-use crate::cell::Cell;\n+use crate::cell::UnsafeCell;\n use crate::fmt;\n+use crate::mem::ManuallyDrop;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n-use crate::sync::OnceLock;\n+use crate::sync::Once;\n+\n+use super::once::ExclusiveState;\n+\n+// We use the state of a Once as discriminant value. Upon creation, the state is\n+// \"incomplete\" and `f` contains the initialization closure. In the first call to\n+// `call_once`, `f` is taken and run. If it succeeds, `value` is set and the state\n+// is changed to \"complete\". If it panics, the Once is poisoned, so none of the\n+// two fields is initialized.\n+union Data<T, F> {\n+    value: ManuallyDrop<T>,\n+    f: ManuallyDrop<F>,\n+}\n \n /// A value which is initialized on the first access.\n ///\n@@ -43,16 +56,17 @@ use crate::sync::OnceLock;\n /// ```\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub struct LazyLock<T, F = fn() -> T> {\n-    cell: OnceLock<T>,\n-    init: Cell<Option<F>>,\n+    once: Once,\n+    data: UnsafeCell<Data<T, F>>,\n }\n+\n impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     /// Creates a new lazy value with the given initializing\n     /// function.\n     #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new(f: F) -> LazyLock<T, F> {\n-        LazyLock { cell: OnceLock::new(), init: Cell::new(Some(f)) }\n+        LazyLock { once: Once::new(), data: UnsafeCell::new(Data { f: ManuallyDrop::new(f) }) }\n     }\n \n     /// Forces the evaluation of this lazy value and\n@@ -74,10 +88,50 @@ impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn force(this: &LazyLock<T, F>) -> &T {\n-        this.cell.get_or_init(|| match this.init.take() {\n-            Some(f) => f(),\n-            None => panic!(\"Lazy instance has previously been poisoned\"),\n-        })\n+        this.once.call_once(|| {\n+            // SAFETY: `call_once` only runs this closure once, ever.\n+            let data = unsafe { &mut *this.data.get() };\n+            let f = unsafe { ManuallyDrop::take(&mut data.f) };\n+            let value = f();\n+            data.value = ManuallyDrop::new(value);\n+        });\n+\n+        // SAFETY:\n+        // There are four possible scenarios:\n+        // * the closure was called and initialized `value`.\n+        // * the closure was called and panicked, so this point is never reached.\n+        // * the closure was not called, but a previous call initialized `value`.\n+        // * the closure was not called because the Once is poisoned, so this point\n+        //   is never reached.\n+        // So `value` has definitely been initialized and will not be modified again.\n+        unsafe { &*(*this.data.get()).value }\n+    }\n+}\n+\n+impl<T, F> LazyLock<T, F> {\n+    /// Get the inner value if it has already been initialized.\n+    fn get(&self) -> Option<&T> {\n+        if self.once.is_completed() {\n+            // SAFETY:\n+            // The closure has been run successfully, so `value` has been initialized\n+            // and will not be modified again.\n+            Some(unsafe { &*(*self.data.get()).value })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F> Drop for LazyLock<T, F> {\n+    fn drop(&mut self) {\n+        match self.once.state() {\n+            ExclusiveState::Incomplete => unsafe { ManuallyDrop::drop(&mut self.data.get_mut().f) },\n+            ExclusiveState::Complete => unsafe {\n+                ManuallyDrop::drop(&mut self.data.get_mut().value)\n+            },\n+            ExclusiveState::Poisoned => {}\n+        }\n     }\n }\n \n@@ -103,23 +157,23 @@ impl<T: Default> Default for LazyLock<T> {\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: fmt::Debug, F> fmt::Debug for LazyLock<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).finish_non_exhaustive()\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"LazyLock\").field(v).finish(),\n+            None => f.write_str(\"LazyLock(Uninit)\"),\n+        }\n     }\n }\n \n // We never create a `&F` from a `&LazyLock<T, F>` so it is fine\n // to not impl `Sync` for `F`\n-// we do create a `&mut Option<F>` in `force`, but this is\n-// properly synchronized, so it only happens once\n-// so it also does not contribute to this impl.\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-unsafe impl<T, F: Send> Sync for LazyLock<T, F> where OnceLock<T>: Sync {}\n+unsafe impl<T: Sync + Send, F: Send> Sync for LazyLock<T, F> {}\n // auto-derived `Send` impl is OK.\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: UnwindSafe> RefUnwindSafe for LazyLock<T, F> where OnceLock<T>: RefUnwindSafe {}\n+impl<T: RefUnwindSafe + UnwindSafe, F: UnwindSafe> RefUnwindSafe for LazyLock<T, F> {}\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: UnwindSafe> UnwindSafe for LazyLock<T, F> where OnceLock<T>: UnwindSafe {}\n+impl<T: UnwindSafe, F: UnwindSafe> UnwindSafe for LazyLock<T, F> {}\n \n #[cfg(test)]\n mod tests;"}, {"sha": "4edc956173b08e37d94d4e87a6b9d9f8112fee95", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -186,7 +186,7 @@ mod condvar;\n mod lazy_lock;\n mod mpmc;\n mod mutex;\n-mod once;\n+pub(crate) mod once;\n mod once_lock;\n mod poison;\n mod remutex;"}, {"sha": "1b17c31089ff2d9dba11eea7dc7bcf30980a4584", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -43,6 +43,12 @@ pub struct OnceState {\n     pub(crate) inner: sys::OnceState,\n }\n \n+pub(crate) enum ExclusiveState {\n+    Incomplete,\n+    Poisoned,\n+    Complete,\n+}\n+\n /// Initialization value for static [`Once`] values.\n ///\n /// # Examples\n@@ -248,6 +254,16 @@ impl Once {\n     pub fn is_completed(&self) -> bool {\n         self.inner.is_completed()\n     }\n+\n+    /// Returns the current state of the `Once` instance.\n+    ///\n+    /// Since this takes a mutable reference, no initialization can currently\n+    /// be running, so the state must be either \"incomplete\", \"poisoned\" or\n+    /// \"complete\".\n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        self.inner.state()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]"}, {"sha": "2507f70695173396f81d8356b97ad1e24ec8f1f2", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -27,10 +27,10 @@ impl Thread {\n         p: Box<dyn FnOnce()>,\n         core_id: isize,\n     ) -> io::Result<Thread> {\n-        let p = Box::into_raw(box p);\n+        let p = Box::into_raw(Box::new(p));\n         let tid = abi::spawn2(\n             thread_start,\n-            p as usize,\n+            p.expose_addr(),\n             abi::Priority::into(abi::NORMAL_PRIO),\n             stack,\n             core_id,"}, {"sha": "613266b9530a800d47560ebb3d5f018b17732387", "filename": "library/std/src/sys/hermit/thread_local_dtor.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread_local_dtor.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -5,32 +5,23 @@\n // The this solution works like the implementation of macOS and\n // doesn't additional OS support\n \n-use crate::cell::Cell;\n-use crate::ptr;\n+use crate::mem;\n \n #[thread_local]\n-static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n-\n-type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n+static mut DTORS: Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))> = Vec::new();\n \n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n-    if DTORS.get().is_null() {\n-        let v: Box<List> = box Vec::new();\n-        DTORS.set(Box::into_raw(v));\n-    }\n-\n-    let list: &mut List = &mut *DTORS.get();\n+    let list = &mut DTORS;\n     list.push((t, dtor));\n }\n \n // every thread call this function to run through all possible destructors\n pub unsafe fn run_dtors() {\n-    let mut ptr = DTORS.replace(ptr::null_mut());\n-    while !ptr.is_null() {\n-        let list = Box::from_raw(ptr);\n-        for (ptr, dtor) in list.into_iter() {\n+    let mut list = mem::take(&mut DTORS);\n+    while !list.is_empty() {\n+        for (ptr, dtor) in list {\n             dtor(ptr);\n         }\n-        ptr = DTORS.replace(ptr::null_mut());\n+        list = mem::take(&mut DTORS);\n     }\n }"}, {"sha": "bad14bb37f720e50707898944ca5e88212e358c9", "filename": "library/std/src/sys/solid/thread_local_dtor.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_dtor.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -5,43 +5,35 @@\n \n use super::{abi, itron::task};\n use crate::cell::Cell;\n-use crate::ptr;\n+use crate::mem;\n \n #[thread_local]\n-static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n+static REGISTERED: Cell<bool> = Cell::new(false);\n \n-type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n+#[thread_local]\n+static mut DTORS: Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))> = Vec::new();\n \n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n-    if DTORS.get().is_null() {\n+    if !REGISTERED.get() {\n         let tid = task::current_task_id_aborting();\n-        let v: Box<List> = box Vec::new();\n-        DTORS.set(Box::into_raw(v));\n-\n         // Register `tls_dtor` to make sure the TLS destructors are called\n         // for tasks created by other means than `std::thread`\n         unsafe { abi::SOLID_TLS_AddDestructor(tid as i32, tls_dtor) };\n+        REGISTERED.set(true);\n     }\n \n-    let list: &mut List = unsafe { &mut *DTORS.get() };\n+    let list = unsafe { &mut DTORS };\n     list.push((t, dtor));\n }\n \n pub unsafe fn run_dtors() {\n-    let ptr = DTORS.get();\n-    if !ptr.is_null() {\n-        // Swap the destructor list, call all registered destructors,\n-        // and repeat this until the list becomes permanently empty.\n-        while let Some(list) = Some(crate::mem::replace(unsafe { &mut *ptr }, Vec::new()))\n-            .filter(|list| !list.is_empty())\n-        {\n-            for (ptr, dtor) in list.into_iter() {\n-                unsafe { dtor(ptr) };\n-            }\n+    let mut list = mem::take(unsafe { &mut DTORS });\n+    while !list.is_empty() {\n+        for (ptr, dtor) in list {\n+            unsafe { dtor(ptr) };\n         }\n \n-        // Drop the destructor list\n-        unsafe { Box::from_raw(DTORS.replace(ptr::null_mut())) };\n+        list = mem::take(unsafe { &mut DTORS });\n     }\n }\n "}, {"sha": "cc0e5929569729ef17de83334958ca55eddad79f", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -49,7 +49,7 @@ unsafe impl Sync for Thread {}\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = Box::into_raw(box p);\n+        let p = Box::into_raw(Box::new(p));\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);"}, {"sha": "c31fb3a48dabb474bda286a79d59a9fcfe9cc119", "filename": "library/std/src/sys/unix/thread_local_dtor.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -57,39 +57,34 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n #[cfg(target_os = \"macos\")]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::cell::Cell;\n+    use crate::mem;\n     use crate::ptr;\n \n     #[thread_local]\n     static REGISTERED: Cell<bool> = Cell::new(false);\n+\n+    #[thread_local]\n+    static mut DTORS: Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))> = Vec::new();\n+\n     if !REGISTERED.get() {\n         _tlv_atexit(run_dtors, ptr::null_mut());\n         REGISTERED.set(true);\n     }\n \n-    type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n-\n-    #[thread_local]\n-    static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n-    if DTORS.get().is_null() {\n-        let v: Box<List> = box Vec::new();\n-        DTORS.set(Box::into_raw(v));\n-    }\n-\n     extern \"C\" {\n         fn _tlv_atexit(dtor: unsafe extern \"C\" fn(*mut u8), arg: *mut u8);\n     }\n \n-    let list: &mut List = &mut *DTORS.get();\n+    let list = &mut DTORS;\n     list.push((t, dtor));\n \n     unsafe extern \"C\" fn run_dtors(_: *mut u8) {\n-        let mut ptr = DTORS.replace(ptr::null_mut());\n-        while !ptr.is_null() {\n-            let list = Box::from_raw(ptr);\n-            for (ptr, dtor) in list.into_iter() {\n+        let mut list = mem::take(&mut DTORS);\n+        while !list.is_empty() {\n+            for (ptr, dtor) in list {\n                 dtor(ptr);\n             }\n-            ptr = DTORS.replace(ptr::null_mut());\n+            list = mem::take(&mut DTORS);\n         }\n     }\n }"}, {"sha": "11fde1888ba7cf975a360031a846f401d75938a7", "filename": "library/std/src/sys/unsupported/once.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,5 +1,6 @@\n use crate::cell::Cell;\n use crate::sync as public;\n+use crate::sync::once::ExclusiveState;\n \n pub struct Once {\n     state: Cell<State>,\n@@ -44,6 +45,16 @@ impl Once {\n         self.state.get() == State::Complete\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match self.state.get() {\n+            State::Incomplete => ExclusiveState::Incomplete,\n+            State::Poisoned => ExclusiveState::Poisoned,\n+            State::Complete => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     #[cold]\n     #[track_caller]\n     pub fn call(&self, ignore_poisoning: bool, f: &mut impl FnMut(&public::OnceState)) {"}, {"sha": "ed58c47e0907bb5aab534b92f2e6a6d4e6ca4733", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -22,7 +22,7 @@ pub struct Thread {\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = Box::into_raw(box p);\n+        let p = Box::into_raw(Box::new(p));\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least"}, {"sha": "42db5fad4b4518d270bbaea0da48ca854499c3f3", "filename": "library/std/src/sys_common/once/futex.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -4,6 +4,7 @@ use crate::sync::atomic::{\n     AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n+use crate::sync::once::ExclusiveState;\n use crate::sys::futex::{futex_wait, futex_wake_all};\n \n // On some platforms, the OS is very nice and handles the waiter queue for us.\n@@ -78,6 +79,16 @@ impl Once {\n         self.state.load(Acquire) == COMPLETE\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match *self.state.get_mut() {\n+            INCOMPLETE => ExclusiveState::Incomplete,\n+            POISONED => ExclusiveState::Poisoned,\n+            COMPLETE => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     // This uses FnMut to match the API of the generic implementation. As this\n     // implementation is quite light-weight, it is generic over the closure and\n     // so avoids the cost of dynamic dispatch."}, {"sha": "def0bcd6fac444167a13c8338d9a8b1d03129a23", "filename": "library/std/src/sys_common/once/queue.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -60,6 +60,7 @@ use crate::fmt;\n use crate::ptr;\n use crate::sync as public;\n use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n+use crate::sync::once::ExclusiveState;\n use crate::thread::{self, Thread};\n \n type Masked = ();\n@@ -121,6 +122,16 @@ impl Once {\n         self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match self.state_and_queue.get_mut().addr() {\n+            INCOMPLETE => ExclusiveState::Incomplete,\n+            POISONED => ExclusiveState::Poisoned,\n+            COMPLETE => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     // This is a non-generic function to reduce the monomorphization cost of\n     // using `call_once` (this isn't exactly a trivial or small implementation).\n     //"}, {"sha": "844946eda031f792603f0e363f597a4006047948", "filename": "library/std/src/sys_common/thread_local_dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_dtor.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -30,7 +30,7 @@ pub unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut\n     static DTORS: StaticKey = StaticKey::new(Some(run_dtors));\n     type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n     if DTORS.get().is_null() {\n-        let v: Box<List> = box Vec::new();\n+        let v: Box<List> = Box::new(Vec::new());\n         DTORS.set(Box::into_raw(v) as *mut u8);\n     }\n     let list: &mut List = &mut *(DTORS.get() as *mut List);"}, {"sha": "cf7c2e05a2e9df94c60d536b97ba27e5fa48d7f9", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1110,8 +1110,7 @@ pub mod os {\n             let ptr = if ptr.is_null() {\n                 // If the lookup returned null, we haven't initialized our own\n                 // local copy, so do that now.\n-                let ptr: Box<Value<T>> = box Value { inner: LazyKeyInner::new(), key: self };\n-                let ptr = Box::into_raw(ptr);\n+                let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n                 // SAFETY: At this point we are sure there is no value inside\n                 // ptr so setting it will not affect anyone else.\n                 unsafe {"}, {"sha": "db6032f87521177d847b4ce9ce5fb617a7d17e0f", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-14/Dockerfile", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -0,0 +1,67 @@\n+FROM ubuntu:22.04\n+\n+ARG DEBIAN_FRONTEND=noninteractive\n+\n+# NOTE: intentionally installs both python2 and python3 so we can test support for both.\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  gcc-multilib \\\n+  make \\\n+  ninja-build \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  llvm-14-tools \\\n+  llvm-14-dev \\\n+  libedit-dev \\\n+  libssl-dev \\\n+  pkg-config \\\n+  zlib1g-dev \\\n+  xz-utils \\\n+  nodejs \\\n+  && rm -rf /var/lib/apt/lists/*\n+\n+# Install powershell (universal package) so we can test x.ps1 on Linux\n+RUN curl -sL \"https://github.com/PowerShell/PowerShell/releases/download/v7.3.1/powershell_7.3.1-1.deb_amd64.deb\" > powershell.deb && \\\n+    dpkg -i powershell.deb && \\\n+    rm -f powershell.deb\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# We are disabling CI LLVM since this builder is intentionally using a host\n+# LLVM, rather than the typical src/llvm-project LLVM.\n+ENV NO_DOWNLOAD_CI_LLVM 1\n+\n+# Using llvm-link-shared due to libffi issues -- see #34486\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --llvm-root=/usr/lib/llvm-14 \\\n+      --enable-llvm-link-shared \\\n+      --set rust.thin-lto-import-instr-limit=10\n+\n+# NOTE: intentionally uses all of `x.py`, `x`, and `x.ps1` to make sure they all work on Linux.\n+ENV SCRIPT ../x.py --stage 2 test --exclude src/tools/tidy && \\\n+           # Run the `mir-opt` tests again but this time for a 32-bit target.\n+           # This enforces that tests using `// EMIT_MIR_FOR_EACH_BIT_WIDTH` have\n+           # both 32-bit and 64-bit outputs updated by the PR author, before\n+           # the PR is approved and tested for merging.\n+           # It will also detect tests lacking `// EMIT_MIR_FOR_EACH_BIT_WIDTH`,\n+           # despite having different output on 32-bit vs 64-bit targets.\n+           ../x --stage 2 test tests/mir-opt \\\n+                             --host='' --target=i686-unknown-linux-gnu && \\\n+           # Run the UI test suite again, but in `--pass=check` mode\n+           #\n+           # This is intended to make sure that both `--pass=check` continues to\n+           # work.\n+           #\n+           ../x.ps1 --stage 2 test tests/ui --pass=check \\\n+                             --host='' --target=i686-unknown-linux-gnu && \\\n+           # Run tidy at the very end, after all the other tests.\n+           python2.7 ../x.py --stage 2 test src/tools/tidy"}, {"sha": "5219247cc6f6c0825dd3977996e1054dd5686e31", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-15/Dockerfile", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-15%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-15%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-15%2FDockerfile?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -0,0 +1,67 @@\n+FROM ubuntu:22.10\n+\n+ARG DEBIAN_FRONTEND=noninteractive\n+\n+# NOTE: intentionally installs both python2 and python3 so we can test support for both.\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  gcc-multilib \\\n+  make \\\n+  ninja-build \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  python3 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  llvm-15-tools \\\n+  llvm-15-dev \\\n+  libedit-dev \\\n+  libssl-dev \\\n+  pkg-config \\\n+  zlib1g-dev \\\n+  xz-utils \\\n+  nodejs \\\n+  && rm -rf /var/lib/apt/lists/*\n+\n+# Install powershell (universal package) so we can test x.ps1 on Linux\n+RUN curl -sL \"https://github.com/PowerShell/PowerShell/releases/download/v7.3.1/powershell_7.3.1-1.deb_amd64.deb\" > powershell.deb && \\\n+    dpkg -i powershell.deb && \\\n+    rm -f powershell.deb\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# We are disabling CI LLVM since this builder is intentionally using a host\n+# LLVM, rather than the typical src/llvm-project LLVM.\n+ENV NO_DOWNLOAD_CI_LLVM 1\n+\n+# Using llvm-link-shared due to libffi issues -- see #34486\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --llvm-root=/usr/lib/llvm-15 \\\n+      --enable-llvm-link-shared \\\n+      --set rust.thin-lto-import-instr-limit=10\n+\n+# NOTE: intentionally uses all of `x.py`, `x`, and `x.ps1` to make sure they all work on Linux.\n+ENV SCRIPT ../x.py --stage 2 test --exclude src/tools/tidy && \\\n+           # Run the `mir-opt` tests again but this time for a 32-bit target.\n+           # This enforces that tests using `// EMIT_MIR_FOR_EACH_BIT_WIDTH` have\n+           # both 32-bit and 64-bit outputs updated by the PR author, before\n+           # the PR is approved and tested for merging.\n+           # It will also detect tests lacking `// EMIT_MIR_FOR_EACH_BIT_WIDTH`,\n+           # despite having different output on 32-bit vs 64-bit targets.\n+           ../x --stage 2 test tests/mir-opt \\\n+                             --host='' --target=i686-unknown-linux-gnu && \\\n+           # Run the UI test suite again, but in `--pass=check` mode\n+           #\n+           # This is intended to make sure that both `--pass=check` continues to\n+           # work.\n+           #\n+           ../x.ps1 --stage 2 test tests/ui --pass=check \\\n+                             --host='' --target=i686-unknown-linux-gnu && \\\n+           # Run tidy at the very end, after all the other tests.\n+           python2.7 ../x.py --stage 2 test src/tools/tidy"}, {"sha": "a466777dd46f85766125d8ec2a5e12655f32953a", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -450,6 +450,16 @@ jobs:\n           - name: x86_64-gnu-distcheck\n             <<: *job-linux-xl\n \n+          - name: x86_64-gnu-llvm-15\n+            env:\n+              RUST_BACKTRACE: 1\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-llvm-14\n+            env:\n+              RUST_BACKTRACE: 1\n+            <<: *job-linux-xl\n+\n           - name: x86_64-gnu-llvm-13\n             env:\n               RUST_BACKTRACE: 1"}, {"sha": "a020ccd53b8422b55cc80ef0a930856572cdbc1a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -2498,14 +2498,7 @@ impl Import {\n     }\n \n     pub(crate) fn imported_item_is_doc_hidden(&self, tcx: TyCtxt<'_>) -> bool {\n-        match self.source.did {\n-            Some(did) => tcx\n-                .get_attrs(did, sym::doc)\n-                .filter_map(ast::Attribute::meta_item_list)\n-                .flatten()\n-                .has_word(sym::hidden),\n-            None => false,\n-        }\n+        self.source.did.map_or(false, |did| tcx.is_doc_hidden(did))\n     }\n }\n "}, {"sha": "424bbb0ec42be8a1e42765ebc29638de8bc6a399", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1897,21 +1897,21 @@ in storage.js\n \tright: 0.25em;\n }\n \n-.scraped-example:not(.expanded) .code-wrapper:before,\n-.scraped-example:not(.expanded) .code-wrapper:after {\n+.scraped-example:not(.expanded) .code-wrapper::before,\n+.scraped-example:not(.expanded) .code-wrapper::after {\n \tcontent: \" \";\n \twidth: 100%;\n \theight: 5px;\n \tposition: absolute;\n \tz-index: 1;\n }\n-.scraped-example:not(.expanded) .code-wrapper:before {\n+.scraped-example:not(.expanded) .code-wrapper::before {\n \ttop: 0;\n \tbackground: linear-gradient(to bottom,\n \t\tvar(--scrape-example-code-wrapper-background-start),\n \t\tvar(--scrape-example-code-wrapper-background-end));\n }\n-.scraped-example:not(.expanded) .code-wrapper:after {\n+.scraped-example:not(.expanded) .code-wrapper::after {\n \tbottom: 0;\n \tbackground: linear-gradient(to top,\n \t\tvar(--scrape-example-code-wrapper-background-start),"}, {"sha": "3dea8bf7ac81db5f7dbc7c63c4a221f000f2e4bf", "filename": "tests/ui/generic-associated-types/issue-88360.fixed", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.fixed?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -0,0 +1,20 @@\n+// run-rustfix\n+\n+trait GatTrait {\n+    type Gat<'a> where Self: 'a;\n+\n+    fn test(&self) -> Self::Gat<'_>;\n+}\n+\n+trait SuperTrait<T>\n+where\n+    Self: 'static,\n+    for<'a> Self: GatTrait<Gat<'a> = &'a T>,\n+{\n+    fn copy(&self) -> Self::Gat<'_> where T: Copy {\n+        self.test()\n+        //~^ mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4d4c7ea318078ff3412312e010bfa0872e0488ca", "filename": "tests/ui/generic-associated-types/issue-88360.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n trait GatTrait {\n     type Gat<'a> where Self: 'a;\n "}, {"sha": "520aeff1894835c966b31a3fb1ad01c7ac399442", "filename": "tests/ui/generic-associated-types/issue-88360.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,19 +1,21 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-88360.rs:13:9\n+  --> $DIR/issue-88360.rs:15:9\n    |\n LL | trait SuperTrait<T>\n    |                  - this type parameter\n ...\n LL |     fn copy(&self) -> Self::Gat<'_> where T: Copy {\n    |                       ------------- expected `&T` because of return type\n LL |         *self.test()\n-   |         ^^^^^^^^^^^^\n-   |         |\n-   |         expected `&T`, found type parameter `T`\n-   |         help: consider borrowing here: `&*self.test()`\n+   |         ^^^^^^^^^^^^ expected `&T`, found type parameter `T`\n    |\n    = note:   expected reference `&T`\n            found type parameter `T`\n+help: consider removing deref here\n+   |\n+LL -         *self.test()\n+LL +         self.test()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "9c6d10029239b8035c92ab6a48d5136f15fe4866", "filename": "tests/ui/methods/method-not-found-but-doc-alias.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -0,0 +1,11 @@\n+struct Foo;\n+\n+impl Foo {\n+    #[doc(alias = \"quux\")]\n+    fn bar(&self) {}\n+}\n+\n+fn main() {\n+    Foo.quux();\n+    //~^ ERROR  no method named `quux` found for struct `Foo` in the current scope\n+}"}, {"sha": "5102a452f0c28c7267fe2d72cb241ddd211673fc", "filename": "tests/ui/methods/method-not-found-but-doc-alias.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `quux` found for struct `Foo` in the current scope\n+  --> $DIR/method-not-found-but-doc-alias.rs:9:9\n+   |\n+LL | struct Foo;\n+   | ---------- method `quux` not found for this struct\n+...\n+LL |     Foo.quux();\n+   |         ^^^^ help: there is a method with a similar name: `bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "4dc12da03dd023535d701946b98f57e84036b838", "filename": "tests/ui/suggestions/suggest-remove-deref.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.fixed?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+\n+//issue #106496\n+\n+struct S;\n+\n+trait X {}\n+impl X for S {}\n+\n+fn foo<T: X>(_: &T) {}\n+fn test_foo() {\n+    let hello = &S;\n+    foo(hello);\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar(_: &String) {}\n+fn test_bar() {\n+    let v = String::from(\"hello\");\n+    let s = &v;\n+    bar(s);\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {\n+    test_foo();\n+    test_bar();\n+}"}, {"sha": "c2d385cbdc378ac56bb09ce20b54d83936579cda", "filename": "tests/ui/suggestions/suggest-remove-deref.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+\n+//issue #106496\n+\n+struct S;\n+\n+trait X {}\n+impl X for S {}\n+\n+fn foo<T: X>(_: &T) {}\n+fn test_foo() {\n+    let hello = &S;\n+    foo(*hello);\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar(_: &String) {}\n+fn test_bar() {\n+    let v = String::from(\"hello\");\n+    let s = &v;\n+    bar(*s);\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {\n+    test_foo();\n+    test_bar();\n+}"}, {"sha": "f5d810e36f035935913a11faea3c8669b493b166", "filename": "tests/ui/suggestions/suggest-remove-deref.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.stderr?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -0,0 +1,43 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-remove-deref.rs:13:9\n+   |\n+LL |     foo(*hello);\n+   |     --- ^^^^^^ expected reference, found struct `S`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected reference `&_`\n+                 found struct `S`\n+note: function defined here\n+  --> $DIR/suggest-remove-deref.rs:10:4\n+   |\n+LL | fn foo<T: X>(_: &T) {}\n+   |    ^^^       -----\n+help: consider removing deref here\n+   |\n+LL -     foo(*hello);\n+LL +     foo(hello);\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-remove-deref.rs:21:9\n+   |\n+LL |     bar(*s);\n+   |     --- ^^ expected `&String`, found struct `String`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/suggest-remove-deref.rs:17:4\n+   |\n+LL | fn bar(_: &String) {}\n+   |    ^^^ ----------\n+help: consider removing deref here\n+   |\n+LL -     bar(*s);\n+LL +     bar(s);\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "bd65737ee39895df9e33d39ee3717ba52dbbd06d", "filename": "tests/ui/traits/new-solver/fn-trait-closure.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461f272d7737d239a650ebf6e49e17baab2b9dd1/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs?ref=461f272d7737d239a650ebf6e49e17baab2b9dd1", "patch": "@@ -1,12 +1,5 @@\n // compile-flags: -Ztrait-solver=next\n-// known-bug: unknown\n-// failure-status: 101\n-// dont-check-compiler-stderr\n-\n-// This test will fail until we fix `FulfillmentCtxt::relationships`. That's\n-// because we create a type variable for closure upvar types, which is not\n-// constrained until after we try to do fallback on diverging type variables.\n-// Thus, we will call that function, which is unimplemented.\n+// check-pass\n \n fn require_fn(_: impl Fn() -> i32) {}\n "}]}