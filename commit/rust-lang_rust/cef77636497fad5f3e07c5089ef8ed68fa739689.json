{"sha": "cef77636497fad5f3e07c5089ef8ed68fa739689", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZjc3NjM2NDk3ZmFkNWYzZTA3YzUwODllZjhlZDY4ZmE3Mzk2ODk=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-09-25T22:53:24Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-09-25T22:53:24Z"}, "message": "Add timsort to std/sort", "tree": {"sha": "e0054490201d54f817d6463ac9905654724b5725", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0054490201d54f817d6463ac9905654724b5725"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cef77636497fad5f3e07c5089ef8ed68fa739689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cef77636497fad5f3e07c5089ef8ed68fa739689", "html_url": "https://github.com/rust-lang/rust/commit/cef77636497fad5f3e07c5089ef8ed68fa739689", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cef77636497fad5f3e07c5089ef8ed68fa739689/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "349ef79ce7aca24f6633893285cc9a5fc9dd7f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/349ef79ce7aca24f6633893285cc9a5fc9dd7f37", "html_url": "https://github.com/rust-lang/rust/commit/349ef79ce7aca24f6633893285cc9a5fc9dd7f37"}], "stats": {"total": 594, "additions": 594, "deletions": 0}, "files": [{"sha": "8cd98f8ab0ba938f00a06d021889a4e1eb29478b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 594, "deletions": 0, "changes": 594, "blob_url": "https://github.com/rust-lang/rust/blob/cef77636497fad5f3e07c5089ef8ed68fa739689/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cef77636497fad5f3e07c5089ef8ed68fa739689/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=cef77636497fad5f3e07c5089ef8ed68fa739689", "patch": "@@ -4,6 +4,7 @@\n \n use vec::{len, push};\n use core::cmp::{Eq, Ord};\n+use dvec::DVec;\n \n export le;\n export merge_sort;\n@@ -168,6 +169,599 @@ impl<T: Copy Ord Eq> &[mut T] : Sort {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n+const MIN_MERGE: uint = 64;\n+const MIN_GALLOP: uint = 7;\n+const INITIAL_TMP_STORAGE: uint = 128;\n+\n+fn timsort<T: Ord>(array: &[mut T]) {\n+    let size = array.len();\n+    if size < 2 {\n+        return;\n+    }\n+\n+    if size < MIN_MERGE {\n+        let initRunLen = countRunAndMakeAscending(array);\n+        binarysort(array, initRunLen);\n+        return;\n+    }\n+\n+    let ms = &MergeState();\n+    let minRun = minRunLength(size);\n+\n+    let mut idx = 0;\n+    let mut remaining = size;\n+    loop {\n+        let arr = vec::mut_view(array, idx, size);\n+        let mut runLen: uint = countRunAndMakeAscending(arr);\n+\n+        if runLen < minRun {\n+            let force = if remaining <= minRun {remaining} else {minRun};\n+            let slice = vec::mut_view(arr, 0, force);\n+            binarysort(slice, runLen);\n+            runLen = force;\n+        }\n+\n+        ms.pushRun(idx, runLen);\n+        ms.mergeCollapse(array);\n+\n+        idx += runLen;\n+        remaining -= runLen;\n+        if remaining == 0 { break; } \n+    }\n+    \n+    ms.mergeForceCollapse(array);\n+}\n+\n+fn binarysort<T: Ord>(array: &[mut T], start: uint) {\n+    let size = array.len();\n+    let mut start = start;\n+    assert start <= size;\n+\n+    if start == 0 { start += 1; }\n+\n+    let mut pivot = ~[mut];\n+    vec::reserve(pivot, 1);\n+    unsafe { vec::raw::set_len(pivot, 1); };\n+\n+    while start < size {\n+        unsafe {\n+            let tmpView = vec::mut_view(array, start, start+1);\n+            vec::raw::memmove(pivot, tmpView, 1);\n+        }\n+        let mut left = 0;\n+        let mut right = start;\n+        assert left <= right;\n+\n+        while left < right {\n+            let mid = (left + right) >> 1;\n+            if pivot[0] < array[mid] {\n+                right = mid;\n+            } else {\n+                left = mid+1;\n+            }\n+        }\n+        assert left == right;\n+        let mut n = start-left;\n+\n+        unsafe {\n+            moveVec(array, left+1, array, left, n);\n+        }\n+        array[left] <-> pivot[0];\n+        start += 1;\n+    }\n+    unsafe { vec::raw::set_len(pivot, 0); } // Forget the boxed element\n+}\n+\n+/// Reverse the order of elements in a slice, in place\n+fn reverseSlice<T>(v: &[mut T], start: uint, end:uint) {\n+    let mut i = start;\n+    while i < end / 2 {\n+        v[i] <-> v[end - i - 1];\n+        i += 1;\n+    }\n+}\n+\n+pure fn minRunLength(n: uint) -> uint {\n+    let mut n = n;\n+    let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n+\n+    while n >= MIN_MERGE {\n+        r |= n & 1;\n+        n >>= 1;\n+    }\n+    return n + r;\n+}\n+\n+fn countRunAndMakeAscending<T: Ord>(array: &[mut T]) -> uint {\n+    let size = array.len();\n+    assert size > 0;\n+    if size == 1 { return 1; }\n+\n+    let mut run = 2;\n+    if array[1] < array[0] {\n+        while run < size && array[run] < array[run-1] {\n+            run += 1;\n+        }\n+        reverseSlice(array, 0, run);\n+    } else {\n+        while run < size && array[run] >= array[run-1] {\n+            run += 1;\n+        }\n+    }\n+    \n+    return run;\n+}\n+\n+pure fn gallopLeft<T: Ord>(key: &const T, array: &[const T], hint: uint) -> uint {  \n+    let size = array.len();\n+    assert size != 0 && hint < size;\n+\n+    let mut lastOfs = 0;\n+    let mut ofs = 1;\n+    \n+    if *key > array[hint] {\n+        // Gallop right until array[hint+lastOfs] < key <= array[hint+ofs]\n+        let maxOfs = size - hint;\n+        while ofs < maxOfs && *key > array[hint+ofs] {\n+            lastOfs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < lastOfs { ofs = maxOfs; } // uint overflow guard\n+        }\n+        if ofs > maxOfs { ofs = maxOfs; }\n+\n+        lastOfs += hint;\n+        ofs += hint;\n+    } else {\n+        let maxOfs = hint + 1;\n+        while ofs < maxOfs && *key <= array[hint-ofs] {\n+            lastOfs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < lastOfs { ofs = maxOfs; } // uint overflow guard\n+        }\n+        \n+        if ofs > maxOfs { ofs = maxOfs; }\n+\n+        let tmp = lastOfs;\n+        lastOfs = hint - ofs;\n+        ofs = hint - tmp;\n+    }\n+    assert (lastOfs < ofs || lastOfs+1 < ofs+1) && ofs <= size;\n+\n+    lastOfs += 1;\n+    while lastOfs < ofs {\n+        let m = lastOfs + ((ofs - lastOfs) >> 1);\n+        if *key > array[m] {\n+            lastOfs = m+1;\n+        } else {\n+            ofs = m;\n+        }\n+    }\n+    assert lastOfs == ofs;\n+    return ofs;\n+}\n+\n+pure fn gallopRight<T: Ord>(key: &const T, array: &[const T], hint: uint) -> uint {\n+    let size = array.len();\n+    assert size != 0 && hint < size;\n+\n+    let mut lastOfs = 0;\n+    let mut ofs = 1;\n+    \n+    if *key >= array[hint] {\n+        // Gallop right until array[hint+lastOfs] <= key < array[hint+ofs]\n+        let maxOfs = size - hint;\n+        while ofs < maxOfs && *key >= array[hint+ofs] {\n+            lastOfs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < lastOfs { ofs = maxOfs; }\n+        }\n+        if ofs > maxOfs { ofs = maxOfs; }\n+\n+        lastOfs += hint;\n+        ofs += hint;    \n+    } else {\n+        // Gallop left until array[hint-ofs] <= key < array[hint-lastOfs]\n+        let maxOfs = hint + 1;\n+        while ofs < maxOfs && *key < array[hint-ofs] {\n+            lastOfs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < lastOfs { ofs = maxOfs; }\n+        }\n+        if ofs > maxOfs { ofs = maxOfs; }\n+\n+        let tmp = lastOfs;\n+        lastOfs = hint - ofs;\n+        ofs = hint - tmp;\n+    }\n+\n+    assert (lastOfs < ofs || lastOfs+1 < ofs+1) && ofs <= size;\n+\n+    lastOfs += 1;\n+    while lastOfs < ofs {\n+        let m = lastOfs + ((ofs - lastOfs) >> 1);\n+\n+        if *key >= array[m] {\n+            lastOfs = m + 1;\n+        } else {\n+            ofs = m;\n+        }\n+    }\n+    assert lastOfs == ofs;\n+    return ofs;\n+}\n+\n+struct RunState {\n+    base: uint,\n+    len: uint,\n+}\n+\n+struct MergeState<T> {\n+    mut minGallop: uint,\n+    mut tmp: ~[T],\n+    runs: DVec<RunState>,\n+\n+    drop {\n+        unsafe {\n+            vec::raw::set_len(self.tmp, 0);\n+        }\n+    }\n+}\n+\n+fn MergeState<T>() -> MergeState<T> {\n+    let mut tmp = ~[];\n+    vec::reserve(tmp, INITIAL_TMP_STORAGE); \n+    MergeState {\n+        minGallop: MIN_GALLOP,\n+        tmp: tmp,\n+        runs: DVec(),\n+    }\n+}\n+\n+impl<T: Ord> &MergeState<T> {\n+    fn pushRun(runBase: uint, runLen: uint) {\n+        let tmp = RunState{base: runBase, len: runLen};\n+        self.runs.push(tmp);\n+    }\n+\n+    fn mergeAt(n: uint, array: &[mut T]) {\n+        let mut size = self.runs.len();\n+        assert size >= 2;\n+        assert n == size-2 || n == size-3;\n+\n+        do self.runs.borrow_mut |arr| {\n+\n+            let mut b1 = arr[n].base;\n+            let mut l1 = arr[n].len;\n+            let b2 = arr[n+1].base;\n+            let l2 = arr[n+1].len;\n+\n+            assert l1 > 0 && l2 > 0;\n+            assert b1 + l1 == b2;\n+\n+            arr[n].len = l1 + l2;\n+            if n == size-3 {\n+                arr[n+1].base = arr[n+2].base;\n+                arr[n+1].len = arr[n+2].len;\n+            }\n+\n+            let slice = vec::mut_view(array, b1, b1+l1);\n+            let k = gallopRight(&const array[b2], slice, 0);\n+            b1 += k;\n+            l1 -= k;\n+            if l1 != 0 {\n+                let slice = vec::mut_view(array, b2, b2+l2);\n+                let l2 = gallopLeft(\n+                    &const array[b1+l1-1],slice,l2-1);\n+                if l2 > 0 {\n+                    if l1 <= l2 {\n+                        self.mergeLo(array, b1, l1, b2, l2);\n+                    } else {\n+                        self.mergeHi(array, b1, l1, b2, l2);\n+                    }\n+                }\n+            }\n+        }\n+        self.runs.pop();\n+    }\n+\n+    fn mergeLo(array: &[mut T], base1: uint, len1: uint, base2: uint, len2: uint) {\n+        assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n+        \n+        vec::reserve(self.tmp, len1);\n+\n+        unsafe {\n+            vec::raw::set_len(self.tmp, len1);\n+            moveVec(self.tmp, 0, array, base1, len1);\n+        }\n+\n+        let mut c1 = 0;\n+        let mut c2 = base2;\n+        let mut dest = base1;\n+        let mut len1 = len1;\n+        let mut len2 = len2;\n+\n+        array[dest] <-> array[c2];\n+        dest += 1; c2 += 1; len2 -= 1;\n+\n+        if len2 == 0 {\n+            unsafe {\n+                moveVec(array, dest, self.tmp, 0, len1);\n+                vec::raw::set_len(self.tmp, 0); // Forget the elements\n+            }\n+            return;\n+        }\n+        if len1 == 1 {\n+            unsafe {\n+                moveVec(array, dest, array, c2, len2);\n+                array[dest+len2] <-> self.tmp[c1];\n+                vec::raw::set_len(self.tmp, 0); // Forget the element\n+            }\n+            return;\n+        }\n+\n+        let mut minGallop = self.minGallop;\n+        loop {\n+            let mut count1 = 0;\n+            let mut count2 = 0;\n+            let mut breakOuter = false;\n+\n+            loop {\n+                assert len1 > 1 && len2 != 0;\n+                if array[c2] < self.tmp[c1] {\n+                    array[dest] <-> array[c2];\n+                    dest += 1; c2 += 1; len2 -= 1;\n+                    count2 += 1; count1 = 0;\n+                    if len2 == 0 {\n+                        breakOuter = true;\n+                    }\n+                } else {\n+                    array[dest] <-> self.tmp[c1];\n+                    dest += 1; c1 += 1; len1 -= 1;\n+                    count1 += 1; count2 = 0;\n+                    if len1 == 1 {\n+                        breakOuter = true;\n+                    }\n+                }\n+                if breakOuter || ((count1 | count2) >= minGallop) {\n+                    break;\n+                }\n+            }\n+            if breakOuter { break; }\n+\n+            // Start to gallop\n+            loop {\n+                assert len1 > 1 && len2 != 0;\n+\n+                let tmpView = vec::mut_view(self.tmp, c1, c1+len1);\n+                count1 = gallopRight(&const array[c2], tmpView, 0);\n+                if count1 != 0 {\n+                    unsafe {\n+                        moveVec(array, dest, self.tmp, c1, count1);\n+                    }\n+                    dest += count1; c1 += count1; len1 -= count1;\n+                    if len1 <= 1 { breakOuter = true; break; }\n+                }\n+                array[dest] <-> array[c2];\n+                dest += 1; c2 += 1; len2 -= 1;\n+                if len2 == 0 { breakOuter = true; break; }\n+\n+                let tmpView = vec::mut_view(array, c2, c2+len2);\n+                count2 = gallopLeft(&const self.tmp[c1], tmpView, 0);\n+                if count2 != 0 {\n+                    unsafe {\n+                        moveVec(array, dest, array, c2, count2);\n+                    }\n+                    dest += count2; c2 += count2; len2 -= count2;\n+                    if len2 == 0 { breakOuter = true; break; }\n+                }\n+                array[dest] <-> self.tmp[c1];\n+                dest += 1; c1 += 1; len1 -= 1;\n+                if len1 == 1 { breakOuter = true; break; }\n+                minGallop -= 1;\n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) { break; } \n+            }\n+            if breakOuter { break; }\n+            if minGallop < 0 { minGallop = 0; }\n+            minGallop += 2; // Penalize for leaving gallop\n+        }\n+        self.minGallop = if minGallop < 1 { 1 } else { minGallop };\n+\n+        if len1 == 1 {\n+            assert len2 > 0;\n+            unsafe {\n+                moveVec(array, dest, array, c2, len2);\n+            }\n+            array[dest+len2] <-> self.tmp[c1];\n+        } else if len1 == 0 {\n+            fail fmt!(\"Method mergeLo violates its contract! %?\", len1);\n+        } else {\n+            assert len2 == 0;\n+            assert len1 > 1;\n+            unsafe {\n+                moveVec(array, dest, self.tmp, c1, len1);\n+            }\n+        }\n+        unsafe { vec::raw::set_len(self.tmp, 0); }\n+    }\n+\n+    fn mergeHi(array: &[mut T], base1: uint, len1: uint, base2: uint, len2: uint) {\n+        assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n+\n+        vec::reserve(self.tmp, len2);\n+\n+        unsafe {\n+            vec::raw::set_len(self.tmp, len2);\n+            moveVec(self.tmp, 0, array, base2, len2);\n+        }\n+\n+        let mut c1 = base1 + len1 - 1;\n+        let mut c2 = len2 - 1;\n+        let mut dest = base2 + len2 - 1;\n+        let mut len1 = len1;\n+        let mut len2 = len2;\n+\n+        array[dest] <-> array[c1];\n+        dest -= 1; c1 -= 1; len1 -= 1;\n+\n+        if len1 == 0 {\n+            unsafe {\n+                moveVec(array, dest-(len2-1), self.tmp, 0, len2);\n+                vec::raw::set_len(self.tmp, 0); // Forget the elements\n+            }\n+            return;\n+        }\n+        if len2 == 1 {\n+            dest -= len1;\n+            c1 -= len1;\n+            unsafe {\n+                moveVec(array, dest+1, array, c1+1, len1);\n+                array[dest] <-> self.tmp[c2];\n+                vec::raw::set_len(self.tmp, 0); // Forget the element\n+            }\n+            return;\n+        }\n+\n+        let mut minGallop = self.minGallop;\n+        loop {\n+            let mut count1 = 0;\n+            let mut count2 = 0;\n+            let mut breakOuter = false;\n+\n+            loop {\n+                assert len1 != 0 && len2 > 1;\n+                if self.tmp[c2] < array[c1] {\n+                    array[dest] <-> array[c1];\n+                    dest -= 1; c1 -= 1; len1 -= 1;\n+                    count1 += 1; count2 = 0;\n+                    if len1 == 0 {\n+                        breakOuter = true;\n+                    }\n+                } else {\n+                    array[dest] <-> self.tmp[c2];\n+                    dest -= 1; c2 -= 1; len2 -= 1;\n+                    count2 += 1; count1 = 0;\n+                    if len2 == 1 {\n+                        breakOuter = true;\n+                    }\n+                }\n+                if breakOuter || ((count1 | count2) >= minGallop) {\n+                    break;\n+                }\n+            }\n+            if breakOuter { break; }\n+    \n+            // Start to gallop\n+            loop {\n+                assert len2 > 1 && len1 != 0;\n+\n+                let tmpView = vec::mut_view(array, base1, base1+len1);\n+                count1 = len1-gallopRight(&const self.tmp[c2], tmpView, len1-1);\n+\n+                if count1 != 0 {\n+                    dest -= count1; c1 -= count1; len1 -= count1;\n+                    unsafe {\n+                        moveVec(array, dest+1, array, c1+1, count1);\n+                    }\n+                    if len1 == 0 { breakOuter = true; break; }\n+                }\n+\n+                array[dest] <-> self.tmp[c2];\n+                dest -= 1; c2 -= 1; len2 -= 1;\n+                if len2 == 1 { breakOuter = true; break; }\n+\n+                let tmpView = vec::mut_view(self.tmp, 0, len2);\n+                let gL = gallopLeft(&const array[c1], tmpView, len2-1);\n+                count2 = len2 - gL;\n+                if count2 != 0 {\n+                    dest -= count2; c2 -= count2; len2 -= count2;\n+                    unsafe {\n+                        moveVec(array, dest+1, self.tmp, c2+1, count2);\n+                    }\n+                    if len2 <= 1 { breakOuter = true; break; }\n+                }\n+                array[dest] <-> array[c1];\n+                dest -= 1; c1 -= 1; len1 -= 1;\n+                if len1 == 0 { breakOuter = true; break; }\n+                minGallop -= 1;\n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) { break; } \n+            }\n+            \n+            if breakOuter { break; }\n+            if minGallop < 0 { minGallop = 0; }\n+            minGallop += 2; // Penalize for leaving gallop\n+        }\n+        self.minGallop = if minGallop < 1 { 1 } else { minGallop };\n+        \n+        if len2 == 1 {\n+            assert len1 > 0;\n+            dest -= len1;\n+            c1 -= len1;\n+            unsafe {\n+                moveVec(array, dest+1, array, c1+1, len1);\n+            }\n+            array[dest] <-> self.tmp[c2];\n+        } else if len2 == 0 {\n+            fail fmt!(\"Method mergeHi violates its contract! %?\", len2);\n+        } else {\n+            assert len1 == 0;\n+            assert len2 != 0;\n+            unsafe {\n+                moveVec(array, dest-(len2-1), self.tmp, 0, len2);\n+            }\n+        }\n+        unsafe { vec::raw::set_len(self.tmp, 0); }\n+    }\n+\n+    fn mergeCollapse(array: &[mut T]) {\n+        while self.runs.len() > 1 {\n+            let mut n = self.runs.len()-2;\n+            let chk = do self.runs.borrow |arr| {\n+                if n > 0 && arr[n-1].len <= arr[n].len + arr[n+1].len {\n+                    if arr[n-1].len < arr[n+1].len { n -= 1; }\n+                    true\n+                } else if arr[n].len <= arr[n+1].len {\n+                    true\n+                } else {\n+                    false\n+                }\n+            };\n+            if !chk { break; }\n+            self.mergeAt(n, array);\n+        }\n+    }\n+\n+    fn mergeForceCollapse(array: &[mut T]) {\n+        while self.runs.len() > 1 {\n+            let mut n = self.runs.len()-2;\n+            if n > 0 {\n+                do self.runs.borrow |arr| {\n+                    if arr[n-1].len < arr[n+1].len {\n+                        n -= 1;\n+                    }\n+                }\n+            }\n+            self.mergeAt(n, array);\n+        }\n+    }\n+}\n+\n+// Moves elements to from dest to from\n+// Unsafe as it makes the from parameter invalid between s2 and s2+len\n+#[inline(always)]\n+unsafe fn moveVec<T>(dest: &[mut T], s1: uint, from: &[const T], s2: uint, len: uint) {   \n+    assert s1+len <= dest.len() && s2+len <= from.len();\n+\n+    do vec::as_mut_buf(dest) |p, _len| {\n+        let destPtr = ptr::mut_offset(p, s1);\n+\n+        do vec::as_const_buf(from) |p, _len| {\n+            let fromPtr = ptr::const_offset(p, s2);\n+\n+            ptr::memmove(destPtr, fromPtr, len);\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test_qsort3 {\n     #[legacy_exports];"}]}