{"sha": "92f52c5c9ad5acb104c6ce5a042950349a48c532", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjUyYzVjOWFkNWFjYjEwNGM2Y2U1YTA0Mjk1MDM0OWE0OGM1MzI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-30T18:21:25Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-30T18:21:25Z"}, "message": "builtin_macro: move to `mbe::ExpandResult`", "tree": {"sha": "9c2cf858405e41d753b2060521bbaf6bbc64e2cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c2cf858405e41d753b2060521bbaf6bbc64e2cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f52c5c9ad5acb104c6ce5a042950349a48c532", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f52c5c9ad5acb104c6ce5a042950349a48c532", "html_url": "https://github.com/rust-lang/rust/commit/92f52c5c9ad5acb104c6ce5a042950349a48c532", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f52c5c9ad5acb104c6ce5a042950349a48c532/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70eb17027151b4e85cbda2765f7289585b26a823", "url": "https://api.github.com/repos/rust-lang/rust/commits/70eb17027151b4e85cbda2765f7289585b26a823", "html_url": "https://github.com/rust-lang/rust/commit/70eb17027151b4e85cbda2765f7289585b26a823"}], "stats": {"total": 133, "additions": 81, "deletions": 52}, "files": [{"sha": "7f4db106dba65821b6d3f6568a23ddc198db9b1f", "filename": "crates/hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 79, "deletions": 50, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/92f52c5c9ad5acb104c6ce5a042950349a48c532/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f52c5c9ad5acb104c6ce5a042950349a48c532/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=92f52c5c9ad5acb104c6ce5a042950349a48c532", "patch": "@@ -6,7 +6,7 @@ use crate::{\n \n use base_db::FileId;\n use either::Either;\n-use mbe::parse_to_token_tree;\n+use mbe::{parse_to_token_tree, ExpandResult};\n use parser::FragmentKind;\n use syntax::ast::{self, AstToken};\n \n@@ -28,7 +28,7 @@ macro_rules! register_builtin {\n                 db: &dyn AstDatabase,\n                 id: LazyMacroId,\n                 tt: &tt::Subtree,\n-            ) -> Result<tt::Subtree, mbe::ExpandError> {\n+            ) -> ExpandResult<tt::Subtree> {\n                 let expander = match *self {\n                     $( BuiltinFnLikeExpander::$kind => $expand, )*\n                 };\n@@ -42,7 +42,7 @@ macro_rules! register_builtin {\n                 db: &dyn AstDatabase,\n                 arg_id: EagerMacroId,\n                 tt: &tt::Subtree,\n-            ) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+            ) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n                 let expander = match *self {\n                     $( EagerExpander::$e_kind => $e_expand, )*\n                 };\n@@ -109,25 +109,28 @@ fn line_expand(\n     _db: &dyn AstDatabase,\n     _id: LazyMacroId,\n     _tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n+) -> ExpandResult<tt::Subtree> {\n     // dummy implementation for type-checking purposes\n     let line_num = 0;\n     let expanded = quote! {\n         #line_num\n     };\n \n-    Ok(expanded)\n+    ExpandResult::ok(expanded)\n }\n \n fn stringify_expand(\n     db: &dyn AstDatabase,\n     id: LazyMacroId,\n     _tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n+) -> ExpandResult<tt::Subtree> {\n     let loc = db.lookup_intern_macro(id);\n \n     let macro_content = {\n-        let arg = loc.kind.arg(db).ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+        let arg = match loc.kind.arg(db) {\n+            Some(arg) => arg,\n+            None => return ExpandResult::only_err(mbe::ExpandError::UnexpectedToken),\n+        };\n         let macro_args = arg;\n         let text = macro_args.text();\n         let without_parens = TextSize::of('(')..text.len() - TextSize::of(')');\n@@ -138,28 +141,28 @@ fn stringify_expand(\n         #macro_content\n     };\n \n-    Ok(expanded)\n+    ExpandResult::ok(expanded)\n }\n \n fn column_expand(\n     _db: &dyn AstDatabase,\n     _id: LazyMacroId,\n     _tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n+) -> ExpandResult<tt::Subtree> {\n     // dummy implementation for type-checking purposes\n     let col_num = 0;\n     let expanded = quote! {\n         #col_num\n     };\n \n-    Ok(expanded)\n+    ExpandResult::ok(expanded)\n }\n \n fn assert_expand(\n     _db: &dyn AstDatabase,\n     _id: LazyMacroId,\n     tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n+) -> ExpandResult<tt::Subtree> {\n     // A hacky implementation for goto def and hover\n     // We expand `assert!(cond, arg1, arg2)` to\n     // ```\n@@ -191,14 +194,14 @@ fn assert_expand(\n     let expanded = quote! {\n         { { (##arg_tts); } }\n     };\n-    Ok(expanded)\n+    ExpandResult::ok(expanded)\n }\n \n fn file_expand(\n     _db: &dyn AstDatabase,\n     _id: LazyMacroId,\n     _tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n+) -> ExpandResult<tt::Subtree> {\n     // FIXME: RA purposefully lacks knowledge of absolute file names\n     // so just return \"\".\n     let file_name = \"\";\n@@ -207,31 +210,33 @@ fn file_expand(\n         #file_name\n     };\n \n-    Ok(expanded)\n+    ExpandResult::ok(expanded)\n }\n \n fn compile_error_expand(\n     _db: &dyn AstDatabase,\n     _id: LazyMacroId,\n     tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n+) -> ExpandResult<tt::Subtree> {\n     if tt.count() == 1 {\n         if let tt::TokenTree::Leaf(tt::Leaf::Literal(it)) = &tt.token_trees[0] {\n             let s = it.text.as_str();\n             if s.contains('\"') {\n-                return Ok(quote! { loop { #it }});\n+                return ExpandResult::ok(quote! { loop { #it }});\n             }\n         };\n     }\n \n-    Err(mbe::ExpandError::BindingError(\"Must be a string\".into()))\n+    ExpandResult::only_err(mbe::ExpandError::BindingError(\n+        \"`compile_error!` argument be a string\".into(),\n+    ))\n }\n \n fn format_args_expand(\n     _db: &dyn AstDatabase,\n     _id: LazyMacroId,\n     tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n+) -> ExpandResult<tt::Subtree> {\n     // We expand `format_args!(\"\", a1, a2)` to\n     // ```\n     // std::fmt::Arguments::new_v1(&[], &[\n@@ -257,7 +262,7 @@ fn format_args_expand(\n         args.push(current);\n     }\n     if args.is_empty() {\n-        return Err(mbe::ExpandError::NoMatchingRule);\n+        return ExpandResult::only_err(mbe::ExpandError::NoMatchingRule);\n     }\n     let _format_string = args.remove(0);\n     let arg_tts = args.into_iter().flat_map(|arg| {\n@@ -266,7 +271,7 @@ fn format_args_expand(\n     let expanded = quote! {\n         std::fmt::Arguments::new_v1(&[], &[##arg_tts])\n     };\n-    Ok(expanded)\n+    ExpandResult::ok(expanded)\n }\n \n fn unquote_str(lit: &tt::Literal) -> Option<String> {\n@@ -279,19 +284,24 @@ fn concat_expand(\n     _db: &dyn AstDatabase,\n     _arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n     let mut text = String::new();\n     for (i, t) in tt.token_trees.iter().enumerate() {\n         match t {\n             tt::TokenTree::Leaf(tt::Leaf::Literal(it)) if i % 2 == 0 => {\n-                text += &unquote_str(&it).ok_or_else(|| mbe::ExpandError::ConversionError)?;\n+                text += &match unquote_str(&it) {\n+                    Some(s) => s,\n+                    None => {\n+                        return ExpandResult::only_err(mbe::ExpandError::ConversionError);\n+                    }\n+                };\n             }\n             tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if i % 2 == 1 && punct.char == ',' => (),\n-            _ => return Err(mbe::ExpandError::UnexpectedToken),\n+            _ => return ExpandResult::only_err(mbe::ExpandError::UnexpectedToken),\n         }\n     }\n \n-    Ok((quote!(#text), FragmentKind::Expr))\n+    ExpandResult::ok(Some((quote!(#text), FragmentKind::Expr)))\n }\n \n fn relative_file(\n@@ -324,26 +334,35 @@ fn include_expand(\n     db: &dyn AstDatabase,\n     arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n-    let path = parse_string(tt)?;\n-    let file_id = relative_file(db, arg_id.into(), &path, false)\n-        .ok_or_else(|| mbe::ExpandError::ConversionError)?;\n-\n-    // FIXME:\n-    // Handle include as expression\n-    let res = parse_to_token_tree(&db.file_text(file_id))\n-        .ok_or_else(|| mbe::ExpandError::ConversionError)?\n-        .0;\n-\n-    Ok((res, FragmentKind::Items))\n+) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+    let res = (|| {\n+        let path = parse_string(tt)?;\n+        let file_id = relative_file(db, arg_id.into(), &path, false)\n+            .ok_or_else(|| mbe::ExpandError::ConversionError)?;\n+\n+        Ok(parse_to_token_tree(&db.file_text(file_id))\n+            .ok_or_else(|| mbe::ExpandError::ConversionError)?\n+            .0)\n+    })();\n+\n+    match res {\n+        Ok(res) => {\n+            // FIXME:\n+            // Handle include as expression\n+            ExpandResult::ok(Some((res, FragmentKind::Items)))\n+        }\n+        Err(e) => ExpandResult::only_err(e),\n+    }\n }\n \n fn include_bytes_expand(\n     _db: &dyn AstDatabase,\n     _arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n-    let _path = parse_string(tt)?;\n+) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+    if let Err(e) = parse_string(tt) {\n+        return ExpandResult::only_err(e);\n+    }\n \n     // FIXME: actually read the file here if the user asked for macro expansion\n     let res = tt::Subtree {\n@@ -353,15 +372,18 @@ fn include_bytes_expand(\n             id: tt::TokenId::unspecified(),\n         }))],\n     };\n-    Ok((res, FragmentKind::Expr))\n+    ExpandResult::ok(Some((res, FragmentKind::Expr)))\n }\n \n fn include_str_expand(\n     db: &dyn AstDatabase,\n     arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n-    let path = parse_string(tt)?;\n+) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+    let path = match parse_string(tt) {\n+        Ok(it) => it,\n+        Err(e) => return ExpandResult::only_err(e),\n+    };\n \n     // FIXME: we're not able to read excluded files (which is most of them because\n     // it's unusual to `include_str!` a Rust file), but we can return an empty string.\n@@ -370,14 +392,14 @@ fn include_str_expand(\n     let file_id = match relative_file(db, arg_id.into(), &path, true) {\n         Some(file_id) => file_id,\n         None => {\n-            return Ok((quote!(\"\"), FragmentKind::Expr));\n+            return ExpandResult::ok(Some((quote!(\"\"), FragmentKind::Expr)));\n         }\n     };\n \n     let text = db.file_text(file_id);\n     let text = &*text;\n \n-    Ok((quote!(#text), FragmentKind::Expr))\n+    ExpandResult::ok(Some((quote!(#text), FragmentKind::Expr)))\n }\n \n fn get_env_inner(db: &dyn AstDatabase, arg_id: EagerMacroId, key: &str) -> Option<String> {\n@@ -389,8 +411,11 @@ fn env_expand(\n     db: &dyn AstDatabase,\n     arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n-    let key = parse_string(tt)?;\n+) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+    let key = match parse_string(tt) {\n+        Ok(it) => it,\n+        Err(e) => return ExpandResult::only_err(e),\n+    };\n \n     // FIXME:\n     // If the environment variable is not defined int rustc, then a compilation error will be emitted.\n@@ -402,21 +427,25 @@ fn env_expand(\n     let s = get_env_inner(db, arg_id, &key).unwrap_or_else(|| \"__RA_UNIMPLEMENTED__\".to_string());\n     let expanded = quote! { #s };\n \n-    Ok((expanded, FragmentKind::Expr))\n+    ExpandResult::ok(Some((expanded, FragmentKind::Expr)))\n }\n \n fn option_env_expand(\n     db: &dyn AstDatabase,\n     arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n-    let key = parse_string(tt)?;\n+) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+    let key = match parse_string(tt) {\n+        Ok(it) => it,\n+        Err(e) => return ExpandResult::only_err(e),\n+    };\n+\n     let expanded = match get_env_inner(db, arg_id, &key) {\n         None => quote! { std::option::Option::None::<&str> },\n         Some(s) => quote! { std::option::Some(#s) },\n     };\n \n-    Ok((expanded, FragmentKind::Expr))\n+    ExpandResult::ok(Some((expanded, FragmentKind::Expr)))\n }\n \n #[cfg(test)]\n@@ -485,7 +514,7 @@ mod tests {\n                     }\n                 });\n \n-                let (subtree, fragment) = expander.expand(&db, arg_id, &parsed_args).unwrap();\n+                let (subtree, fragment) = expander.expand(&db, arg_id, &parsed_args).value.unwrap();\n                 let eager = EagerCallLoc {\n                     def,\n                     fragment,"}, {"sha": "4fd0ba290f12fe0bff6d4403141598cb758f3625", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f52c5c9ad5acb104c6ce5a042950349a48c532/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f52c5c9ad5acb104c6ce5a042950349a48c532/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=92f52c5c9ad5acb104c6ce5a042950349a48c532", "patch": "@@ -30,8 +30,8 @@ impl TokenExpander {\n     ) -> mbe::ExpandResult<tt::Subtree> {\n         match self {\n             TokenExpander::MacroRules(it) => it.expand(tt),\n+            TokenExpander::Builtin(it) => it.expand(db, id, tt),\n             // FIXME switch these to ExpandResult as well\n-            TokenExpander::Builtin(it) => it.expand(db, id, tt).into(),\n             TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt).into(),\n             TokenExpander::ProcMacro(_) => {\n                 // We store the result in salsa db to prevent non-determinisc behavior in"}, {"sha": "ab6b4477c6a210c9e3a21116dc0ce6f937d35749", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f52c5c9ad5acb104c6ce5a042950349a48c532/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f52c5c9ad5acb104c6ce5a042950349a48c532/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=92f52c5c9ad5acb104c6ce5a042950349a48c532", "patch": "@@ -65,7 +65,7 @@ pub fn expand_eager_macro(\n     let subtree = to_subtree(&result)?;\n \n     if let MacroDefKind::BuiltInEager(eager) = def.kind {\n-        let (subtree, fragment) = eager.expand(db, arg_id, &subtree).ok()?;\n+        let (subtree, fragment) = eager.expand(db, arg_id, &subtree).value?;\n         let eager = EagerCallLoc {\n             def,\n             fragment,"}]}