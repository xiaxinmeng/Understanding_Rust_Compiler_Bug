{"sha": "16593d264c7803b78156c02b2ac596f6d98333c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NTkzZDI2NGM3ODAzYjc4MTU2YzAyYjJhYzU5NmY2ZDk4MzMzYzc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-30T10:30:57Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-30T10:30:57Z"}, "message": "Move return handling to abi/returning.rs", "tree": {"sha": "13883ccb26a38d581e9c27319c643494385117a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13883ccb26a38d581e9c27319c643494385117a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16593d264c7803b78156c02b2ac596f6d98333c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16593d264c7803b78156c02b2ac596f6d98333c7", "html_url": "https://github.com/rust-lang/rust/commit/16593d264c7803b78156c02b2ac596f6d98333c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16593d264c7803b78156c02b2ac596f6d98333c7/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "url": "https://api.github.com/repos/rust-lang/rust/commits/68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "html_url": "https://github.com/rust-lang/rust/commit/68dcfc1c789f8d10f6d0b3981c64bca309a2481e"}], "stats": {"total": 255, "additions": 142, "deletions": 113}, "files": [{"sha": "a724ea2d8ec0b313257eea84caad2510470b1dd2", "filename": "src/abi/mod.rs", "status": "modified", "additions": 31, "deletions": 113, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/16593d264c7803b78156c02b2ac596f6d98333c7/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16593d264c7803b78156c02b2ac596f6d98333c7/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=16593d264c7803b78156c02b2ac596f6d98333c7", "patch": "@@ -1,3 +1,4 @@\n+mod returning;\n mod pass_mode;\n \n use std::borrow::Cow;\n@@ -7,6 +8,8 @@ use rustc_target::spec::abi::Abi;\n use crate::prelude::*;\n use self::pass_mode::*;\n \n+pub use self::returning::codegen_return;\n+\n fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>, is_vtable_fn: bool) -> Signature {\n     let abi = match sig.abi {\n         Abi::System => {\n@@ -296,35 +299,15 @@ pub fn codegen_fn_prelude(\n ) {\n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n-    #[cfg(debug_assertions)]\n-    fx.add_global_comment(format!(\"ssa {:?}\", ssa_analyzed));\n-\n-    let ret_layout = fx.return_layout();\n-    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_layout());\n-    let ret_param = match output_pass_mode {\n-        PassMode::NoPass | PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n-        PassMode::ByRef => Some(fx.bcx.append_ebb_param(start_ebb, fx.pointer_type)),\n-    };\n-\n     #[cfg(debug_assertions)]\n     {\n+        fx.add_global_comment(format!(\"ssa {:?}\", ssa_analyzed));\n         add_local_header_comment(fx);\n-        let ret_param = match ret_param {\n-            Some(param) => Single(param),\n-            None => Empty,\n-        };\n-        add_arg_comment(\n-            fx,\n-            \"ret\",\n-            RETURN_PLACE,\n-            None,\n-            ret_param,\n-            output_pass_mode,\n-            ssa_analyzed[&RETURN_PLACE],\n-            ret_layout.ty,\n-        );\n     }\n \n+    self::returning::codegen_return_param(fx, &ssa_analyzed, start_ebb);\n+\n+\n     // None means pass_mode == NoPass\n     enum ArgKind<'tcx> {\n         Normal(Option<CValue<'tcx>>),\n@@ -373,27 +356,6 @@ pub fn codegen_fn_prelude(\n \n     fx.bcx.switch_to_block(start_ebb);\n \n-    match output_pass_mode {\n-        PassMode::NoPass => {\n-            fx.local_map\n-                .insert(RETURN_PLACE, CPlace::no_place(ret_layout));\n-        }\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n-            let is_ssa = !ssa_analyzed\n-                .get(&RETURN_PLACE)\n-                .unwrap()\n-                .contains(crate::analyze::Flags::NOT_SSA);\n-\n-            local_place(fx, RETURN_PLACE, ret_layout, is_ssa);\n-        }\n-        PassMode::ByRef => {\n-            fx.local_map.insert(\n-                RETURN_PLACE,\n-                CPlace::for_addr(ret_param.unwrap(), ret_layout),\n-            );\n-        }\n-    }\n-\n     for (local, arg_kind, ty) in func_params {\n         let layout = fx.layout_of(ty);\n \n@@ -524,18 +486,6 @@ fn codegen_call_inner<'tcx>(\n ) {\n     let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n-    let ret_layout = fx.layout_of(fn_sig.output());\n-\n-    let output_pass_mode = get_pass_mode(fx.tcx, fx.layout_of(fn_sig.output()));\n-    let return_ptr = match output_pass_mode {\n-        PassMode::NoPass => None,\n-        PassMode::ByRef => match ret_place {\n-            Some(ret_place) => Some(ret_place.to_addr(fx)),\n-            None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)),\n-        },\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n-    };\n-\n     let instance = match fn_ty.sty {\n         ty::FnDef(def_id, substs) => {\n             Some(Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs).unwrap())\n@@ -584,26 +534,30 @@ fn codegen_call_inner<'tcx>(\n         }\n     };\n \n-    let call_args: Vec<Value> = return_ptr\n-        .into_iter()\n-        .chain(first_arg.into_iter())\n-        .chain(\n-            args.into_iter()\n-                .skip(1)\n-                .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n-                .flatten(),\n-        )\n-        .collect::<Vec<_>>();\n-\n-    let call_inst = if let Some(func_ref) = func_ref {\n-        let sig = fx\n-            .bcx\n-            .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig, is_virtual_call));\n-        fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n-    } else {\n-        let func_ref = fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n-        fx.bcx.ins().call(func_ref, &call_args)\n-    };\n+    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n+        let call_args: Vec<Value> = return_ptr\n+            .into_iter()\n+            .chain(first_arg.into_iter())\n+            .chain(\n+                args.into_iter()\n+                    .skip(1)\n+                    .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                    .flatten(),\n+            )\n+            .collect::<Vec<_>>();\n+\n+        let call_inst = if let Some(func_ref) = func_ref {\n+            let sig = fx\n+                .bcx\n+                .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig, is_virtual_call));\n+            fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n+        } else {\n+            let func_ref = fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n+            fx.bcx.ins().call(func_ref, &call_args)\n+        };\n+\n+        (call_inst, call_args)\n+    });\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n@@ -624,24 +578,6 @@ fn codegen_call_inner<'tcx>(\n             .collect::<Vec<AbiParam>>();\n         fx.bcx.func.dfg.signatures[sig_ref].params = abi_params;\n     }\n-\n-    match output_pass_mode {\n-        PassMode::NoPass => {}\n-        PassMode::ByVal(_) => {\n-            if let Some(ret_place) = ret_place {\n-                let ret_val = fx.bcx.inst_results(call_inst)[0];\n-                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n-            }\n-        }\n-        PassMode::ByValPair(_, _) => {\n-            if let Some(ret_place) = ret_place {\n-                let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n-                let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n-                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n-            }\n-        }\n-        PassMode::ByRef => {}\n-    }\n }\n \n pub fn codegen_drop<'tcx>(\n@@ -693,21 +629,3 @@ pub fn codegen_drop<'tcx>(\n         }\n     }\n }\n-\n-pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n-    match get_pass_mode(fx.tcx, fx.return_layout()) {\n-        PassMode::NoPass | PassMode::ByRef => {\n-            fx.bcx.ins().return_(&[]);\n-        }\n-        PassMode::ByVal(_) => {\n-            let place = fx.get_local_place(RETURN_PLACE);\n-            let ret_val = place.to_cvalue(fx).load_scalar(fx);\n-            fx.bcx.ins().return_(&[ret_val]);\n-        }\n-        PassMode::ByValPair(_, _) => {\n-            let place = fx.get_local_place(RETURN_PLACE);\n-            let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n-            fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n-        }\n-    }\n-}"}, {"sha": "45ba48d7c4f99d340dd139065e79075bc3db9749", "filename": "src/abi/returning.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/16593d264c7803b78156c02b2ac596f6d98333c7/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16593d264c7803b78156c02b2ac596f6d98333c7/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=16593d264c7803b78156c02b2ac596f6d98333c7", "patch": "@@ -0,0 +1,111 @@\n+use crate::prelude::*;\n+use crate::abi::pass_mode::*;\n+\n+pub fn codegen_return_param(\n+    fx: &mut FunctionCx<impl Backend>,\n+    ssa_analyzed: &HashMap<Local, crate::analyze::Flags>,\n+    start_ebb: Ebb,\n+) {\n+    let ret_layout = fx.return_layout();\n+    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_layout());\n+\n+    let ret_param = match output_pass_mode {\n+        PassMode::NoPass => {\n+            fx.local_map\n+                .insert(RETURN_PLACE, CPlace::no_place(ret_layout));\n+            Empty\n+        }\n+        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n+            let is_ssa = !ssa_analyzed\n+                .get(&RETURN_PLACE)\n+                .unwrap()\n+                .contains(crate::analyze::Flags::NOT_SSA);\n+\n+            super::local_place(fx, RETURN_PLACE, ret_layout, is_ssa);\n+\n+            Empty\n+        }\n+        PassMode::ByRef => {\n+            let ret_param = fx.bcx.append_ebb_param(start_ebb, fx.pointer_type);\n+            fx.local_map.insert(\n+                RETURN_PLACE,\n+                CPlace::for_addr(ret_param, ret_layout),\n+            );\n+\n+            Single(ret_param)\n+        }\n+    };\n+\n+    #[cfg(debug_assertions)]\n+    {\n+        super::add_arg_comment(\n+            fx,\n+            \"ret\",\n+            RETURN_PLACE,\n+            None,\n+            ret_param,\n+            output_pass_mode,\n+            ssa_analyzed[&RETURN_PLACE],\n+            ret_layout.ty,\n+        );\n+    }\n+}\n+\n+pub fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n+    fx: &mut FunctionCx<'_, 'tcx, B>,\n+    fn_sig: FnSig<'tcx>,\n+    ret_place: Option<CPlace<'tcx>>,\n+    f: impl FnOnce(&mut FunctionCx<'_, 'tcx, B>, Option<Value>) -> (Inst, T),\n+) -> (Inst, T) {\n+    let ret_layout = fx.layout_of(fn_sig.output());\n+\n+    let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n+    let return_ptr = match output_pass_mode {\n+        PassMode::NoPass => None,\n+        PassMode::ByRef => match ret_place {\n+            Some(ret_place) => Some(ret_place.to_addr(fx)),\n+            None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)),\n+        },\n+        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n+    };\n+\n+    let (call_inst, meta) = f(fx, return_ptr);\n+\n+    match output_pass_mode {\n+        PassMode::NoPass => {}\n+        PassMode::ByVal(_) => {\n+            if let Some(ret_place) = ret_place {\n+                let ret_val = fx.bcx.inst_results(call_inst)[0];\n+                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n+            }\n+        }\n+        PassMode::ByValPair(_, _) => {\n+            if let Some(ret_place) = ret_place {\n+                let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n+                let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n+                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n+            }\n+        }\n+        PassMode::ByRef => {}\n+    }\n+\n+    (call_inst, meta)\n+}\n+\n+pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n+    match get_pass_mode(fx.tcx, fx.return_layout()) {\n+        PassMode::NoPass | PassMode::ByRef => {\n+            fx.bcx.ins().return_(&[]);\n+        }\n+        PassMode::ByVal(_) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let ret_val = place.to_cvalue(fx).load_scalar(fx);\n+            fx.bcx.ins().return_(&[ret_val]);\n+        }\n+        PassMode::ByValPair(_, _) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n+            fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n+        }\n+    }\n+}"}]}