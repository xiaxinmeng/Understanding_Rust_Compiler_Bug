{"sha": "a8606e536347d21fa13768354f17048c54d7d89d", "node_id": "C_kwDOAAsO6NoAKGE4NjA2ZTUzNjM0N2QyMWZhMTM3NjgzNTRmMTcwNDhjNTRkN2Q4OWQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-05T13:37:44Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-05T13:37:44Z"}, "message": "Re-use the resolver in InferenceContext instead of rebuilding it on every expression change", "tree": {"sha": "eb824de0316fbeff47334bbde3e514c79c971630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb824de0316fbeff47334bbde3e514c79c971630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8606e536347d21fa13768354f17048c54d7d89d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8606e536347d21fa13768354f17048c54d7d89d", "html_url": "https://github.com/rust-lang/rust/commit/a8606e536347d21fa13768354f17048c54d7d89d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8606e536347d21fa13768354f17048c54d7d89d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6ba791dcecfb2d69e831e204f06f2d3bf86323a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ba791dcecfb2d69e831e204f06f2d3bf86323a", "html_url": "https://github.com/rust-lang/rust/commit/e6ba791dcecfb2d69e831e204f06f2d3bf86323a"}], "stats": {"total": 154, "additions": 116, "deletions": 38}, "files": [{"sha": "cab657b807eb133b543fbdbc40c4ea67754fda5f", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=a8606e536347d21fa13768354f17048c54d7d89d", "patch": "@@ -66,6 +66,7 @@ impl ExprScopes {\n         self.scopes[scope].label.clone()\n     }\n \n+    /// Returns the scopes in ascending order.\n     pub fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n         std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n     }"}, {"sha": "620e9202aad5f7586f4ef031869cfbf98ab3c560", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 96, "deletions": 6, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=a8606e536347d21fa13768354f17048c54d7d89d", "patch": "@@ -1,5 +1,5 @@\n //! Name resolution fa\u00e7ade.\n-use std::{hash::BuildHasherDefault, sync::Arc};\n+use std::{fmt, hash::BuildHasherDefault, sync::Arc};\n \n use base_db::CrateId;\n use hir_expand::name::{name, Name};\n@@ -36,19 +36,34 @@ pub struct Resolver {\n     module_scope: ModuleItemMap,\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n struct ModuleItemMap {\n     def_map: Arc<DefMap>,\n     module_id: LocalModuleId,\n }\n \n-#[derive(Debug, Clone)]\n+impl fmt::Debug for ModuleItemMap {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ModuleItemMap\").field(\"module_id\", &self.module_id).finish()\n+    }\n+}\n+\n+#[derive(Clone)]\n struct ExprScope {\n     owner: DefWithBodyId,\n     expr_scopes: Arc<ExprScopes>,\n     scope_id: ScopeId,\n }\n \n+impl fmt::Debug for ExprScope {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ExprScope\")\n+            .field(\"owner\", &self.owner)\n+            .field(\"scope_id\", &self.scope_id)\n+            .finish()\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n enum Scope {\n     /// All the items and imported names of a module\n@@ -478,8 +493,72 @@ impl Resolver {\n             _ => None,\n         })\n     }\n+    /// `expr_id` is required to be an expression id that comes after the top level expression scope in the given resolver\n+    #[must_use]\n+    pub fn update_to_inner_scope(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        owner: DefWithBodyId,\n+        expr_id: ExprId,\n+    ) -> UpdateGuard {\n+        #[inline(always)]\n+        fn append_expr_scope(\n+            db: &dyn DefDatabase,\n+            resolver: &mut Resolver,\n+            owner: DefWithBodyId,\n+            expr_scopes: &Arc<ExprScopes>,\n+            scope_id: ScopeId,\n+        ) {\n+            resolver.scopes.push(Scope::ExprScope(ExprScope {\n+                owner,\n+                expr_scopes: expr_scopes.clone(),\n+                scope_id,\n+            }));\n+            if let Some(block) = expr_scopes.block(scope_id) {\n+                if let Some(def_map) = db.block_def_map(block) {\n+                    let root = def_map.root();\n+                    resolver\n+                        .scopes\n+                        .push(Scope::BlockScope(ModuleItemMap { def_map, module_id: root }));\n+                    // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n+                    // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n+                    // innermost module scope instead?\n+                }\n+            }\n+        }\n+\n+        let start = self.scopes.len();\n+        let innermost_scope = self.scopes().next();\n+        match innermost_scope {\n+            Some(&Scope::ExprScope(ExprScope { scope_id, ref expr_scopes, owner })) => {\n+                let expr_scopes = expr_scopes.clone();\n+                let scope_chain = expr_scopes\n+                    .scope_chain(expr_scopes.scope_for(expr_id))\n+                    .take_while(|&it| it != scope_id);\n+                for scope_id in scope_chain {\n+                    append_expr_scope(db, self, owner, &expr_scopes, scope_id);\n+                }\n+            }\n+            _ => {\n+                let expr_scopes = db.expr_scopes(owner);\n+                let scope_chain = expr_scopes.scope_chain(expr_scopes.scope_for(expr_id));\n+\n+                for scope_id in scope_chain {\n+                    append_expr_scope(db, self, owner, &expr_scopes, scope_id);\n+                }\n+            }\n+        }\n+        self.scopes[start..].reverse();\n+        UpdateGuard(start)\n+    }\n+\n+    pub fn reset_to_guard(&mut self, UpdateGuard(start): UpdateGuard) {\n+        self.scopes.truncate(start);\n+    }\n }\n \n+pub struct UpdateGuard(usize);\n+\n impl Resolver {\n     fn scopes(&self) -> impl Iterator<Item = &Scope> {\n         self.scopes.iter().rev()\n@@ -576,19 +655,30 @@ impl Scope {\n     }\n }\n \n-// needs arbitrary_self_types to be a method... or maybe move to the def?\n pub fn resolver_for_expr(db: &dyn DefDatabase, owner: DefWithBodyId, expr_id: ExprId) -> Resolver {\n+    let r = owner.resolver(db);\n     let scopes = db.expr_scopes(owner);\n-    resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n+    let scope_id = scopes.scope_for(expr_id);\n+    resolver_for_scope_(db, scopes, scope_id, r, owner)\n }\n \n pub fn resolver_for_scope(\n     db: &dyn DefDatabase,\n     owner: DefWithBodyId,\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n-    let mut r = owner.resolver(db);\n+    let r = owner.resolver(db);\n     let scopes = db.expr_scopes(owner);\n+    resolver_for_scope_(db, scopes, scope_id, r, owner)\n+}\n+\n+fn resolver_for_scope_(\n+    db: &dyn DefDatabase,\n+    scopes: Arc<ExprScopes>,\n+    scope_id: Option<ScopeId>,\n+    mut r: Resolver,\n+    owner: DefWithBodyId,\n+) -> Resolver {\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     r.scopes.reserve(scope_chain.len());\n "}, {"sha": "56ae786193e5f0d37a029e7d716a7c8e2adf0db7", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=a8606e536347d21fa13768354f17048c54d7d89d", "patch": "@@ -706,7 +706,6 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        // FIXME use right resolver for block\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let ty = ctx.lower_ty(type_ref);\n         let ty = self.insert_type_vars(ty);\n@@ -822,12 +821,11 @@ impl<'a> InferenceContext<'a> {\n             Some(path) => path,\n             None => return (self.err_ty(), None),\n         };\n-        let resolver = &self.resolver;\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         let (resolution, unresolved) = if value_ns {\n-            match resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path()) {\n                 Some(ResolveValueResult::ValueNs(value)) => match value {\n                     ValueNs::EnumVariantId(var) => {\n                         let substs = ctx.substs_from_path(path, var.into(), true);\n@@ -848,7 +846,7 @@ impl<'a> InferenceContext<'a> {\n                 None => return (self.err_ty(), None),\n             }\n         } else {\n-            match resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n                 None => return (self.err_ty(), None),\n             }"}, {"sha": "13ca05347228a04b439a4b0e0e6c6a85fff9b56b", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a8606e536347d21fa13768354f17048c54d7d89d", "patch": "@@ -15,7 +15,6 @@ use hir_def::{\n     generics::TypeOrConstParamData,\n     lang_item::LangItem,\n     path::{GenericArg, GenericArgs},\n-    resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n use hir_expand::name::{name, Name};\n@@ -457,9 +456,10 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             Expr::Path(p) => {\n-                // FIXME this could be more efficient...\n-                let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n-                self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or_else(|| self.err_ty())\n+                let g = self.resolver.update_to_inner_scope(self.db.upcast(), self.owner, tgt_expr);\n+                let ty = self.infer_path(p, tgt_expr.into()).unwrap_or_else(|| self.err_ty());\n+                self.resolver.reset_to_guard(g);\n+                ty\n             }\n             Expr::Continue { label } => {\n                 if let None = find_continuable(&mut self.breakables, label.as_ref()) {\n@@ -1168,8 +1168,8 @@ impl<'a> InferenceContext<'a> {\n         expected: &Expectation,\n     ) -> Ty {\n         let coerce_ty = expected.coercion_target_type(&mut self.table);\n-        let old_resolver =\n-            mem::replace(&mut self.resolver, resolver_for_expr(self.db.upcast(), self.owner, expr));\n+        let g = self.resolver.update_to_inner_scope(self.db.upcast(), self.owner, expr);\n+\n         let (break_ty, ty) =\n             self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty.clone()), label, |this| {\n                 for stmt in statements {\n@@ -1256,7 +1256,7 @@ impl<'a> InferenceContext<'a> {\n                     }\n                 }\n             });\n-        self.resolver = old_resolver;\n+        self.resolver.reset_to_guard(g);\n \n         break_ty.unwrap_or(ty)\n     }"}, {"sha": "a7bd009e34bd88c955c773496f1a8b8a6c6fe9cd", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=a8606e536347d21fa13768354f17048c54d7d89d", "patch": "@@ -245,9 +245,8 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_record_pat_like(p.as_deref(), &expected, default_bm, pat, subs)\n             }\n             Pat::Path(path) => {\n-                // FIXME use correct resolver for the surrounding expression\n-                let resolver = self.resolver.clone();\n-                self.infer_path(&resolver, path, pat.into()).unwrap_or_else(|| self.err_ty())\n+                // FIXME update resolver for the surrounding expression\n+                self.infer_path(path, pat.into()).unwrap_or_else(|| self.err_ty())\n             }\n             Pat::Bind { mode, name: _, subpat } => {\n                 return self.infer_bind_pat(pat, *mode, default_bm, *subpat, &expected);"}, {"sha": "93dbd8b3633a7d17cf1377d7687ca77708d2466d", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=a8606e536347d21fa13768354f17048c54d7d89d", "patch": "@@ -3,7 +3,7 @@\n use chalk_ir::cast::Cast;\n use hir_def::{\n     path::{Path, PathSegment},\n-    resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n+    resolver::{ResolveValueResult, TypeNs, ValueNs},\n     AdtId, AssocItemId, EnumVariantId, ItemContainerId, Lookup,\n };\n use hir_expand::name::Name;\n@@ -21,35 +21,25 @@ use crate::{\n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n impl<'a> InferenceContext<'a> {\n-    pub(super) fn infer_path(\n-        &mut self,\n-        resolver: &Resolver,\n-        path: &Path,\n-        id: ExprOrPatId,\n-    ) -> Option<Ty> {\n-        let ty = self.resolve_value_path(resolver, path, id)?;\n+    pub(super) fn infer_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n+        let ty = self.resolve_value_path(path, id)?;\n         let ty = self.insert_type_vars(ty);\n         let ty = self.normalize_associated_types_in(ty);\n         Some(ty)\n     }\n \n-    fn resolve_value_path(\n-        &mut self,\n-        resolver: &Resolver,\n-        path: &Path,\n-        id: ExprOrPatId,\n-    ) -> Option<Ty> {\n+    fn resolve_value_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n         let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n             let Some(last) = path.segments().last() else { return None };\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n-            let ctx = crate::lower::TyLoweringContext::new(self.db, resolver);\n+            let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n             let (ty, _) = ctx.lower_ty_relative_path(ty, None, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(ty, last.name, id)?\n         } else {\n             // FIXME: report error, unresolved first path segment\n             let value_or_partial =\n-                resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n+                self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),"}, {"sha": "bcd63d9472a8102c854790ad722f79558e261b50", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8606e536347d21fa13768354f17048c54d7d89d/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=a8606e536347d21fa13768354f17048c54d7d89d", "patch": "@@ -163,7 +163,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 } else {\n                     ty.display_test(&db).to_string()\n                 };\n-                assert_eq!(actual, expected);\n+                assert_eq!(actual, expected, \"type annotation differs at {:#?}\", range.range);\n             }\n         }\n \n@@ -179,7 +179,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 } else {\n                     ty.display_test(&db).to_string()\n                 };\n-                assert_eq!(actual, expected);\n+                assert_eq!(actual, expected, \"type annotation differs at {:#?}\", range.range);\n             }\n             if let Some(expected) = adjustments.remove(&range) {\n                 let adjustments = inference_result"}]}