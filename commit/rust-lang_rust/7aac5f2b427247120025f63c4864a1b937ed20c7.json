{"sha": "7aac5f2b427247120025f63c4864a1b937ed20c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYWM1ZjJiNDI3MjQ3MTIwMDI1ZjYzYzQ4NjRhMWI5MzdlZDIwYzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-07T12:33:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-07T12:33:08Z"}, "message": "Merge #2492\n\n2492: Refactor generic parameteres lowering r=flodiebold a=matklad\n\nindices and parent params seem to be concerns, specific to `hir_ty`, so move them there. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "51a841eaac9c7416e379b23887ee97ddc541ab5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51a841eaac9c7416e379b23887ee97ddc541ab5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aac5f2b427247120025f63c4864a1b937ed20c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd65wECRBK7hj4Ov3rIwAAdHIIACTC8AebufWLzJWnhDIP2QQV\nU4WIYufDGG4J+Z3JC3buw3XcLfK2cL6A2vBUiRTom8NBeD+RKzq8+6Wf3x/Lhc5S\nLzCLk05FBWnilWmsRx7DWvP14TETVPGEic9EbhaEkF7Dt2EVsuBlavcMH75Yegp5\nQbd4XezVcvf98XHLAjJBrNxZfsY2yLo6iGAFN0U7IePT6jOmwqFN1xTErP1gNVL2\nnNZgG6sQuekLS4giJZOPCLS8EdHYiXloaqLxxvuPi0HGgPfWO3MEbF1Cu8qRMyRd\nAT49GO/XLgQOcXxkeqJAMhpFS6XGWLitR6XSE2NNnUIFqw+mm6xnsxODpx9rdcg=\n=HeJW\n-----END PGP SIGNATURE-----\n", "payload": "tree 51a841eaac9c7416e379b23887ee97ddc541ab5c\nparent 35fc983dd9e904ad4961b9c10be3397bad33da0c\nparent 29b5e1ec2a4bc25daddfe5137503b156b3cd283f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575721988 +0000\ncommitter GitHub <noreply@github.com> 1575721988 +0000\n\nMerge #2492\n\n2492: Refactor generic parameteres lowering r=flodiebold a=matklad\n\nindices and parent params seem to be concerns, specific to `hir_ty`, so move them there. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aac5f2b427247120025f63c4864a1b937ed20c7", "html_url": "https://github.com/rust-lang/rust/commit/7aac5f2b427247120025f63c4864a1b937ed20c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aac5f2b427247120025f63c4864a1b937ed20c7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35fc983dd9e904ad4961b9c10be3397bad33da0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/35fc983dd9e904ad4961b9c10be3397bad33da0c", "html_url": "https://github.com/rust-lang/rust/commit/35fc983dd9e904ad4961b9c10be3397bad33da0c"}, {"sha": "29b5e1ec2a4bc25daddfe5137503b156b3cd283f", "url": "https://api.github.com/repos/rust-lang/rust/commits/29b5e1ec2a4bc25daddfe5137503b156b3cd283f", "html_url": "https://github.com/rust-lang/rust/commit/29b5e1ec2a4bc25daddfe5137503b156b3cd283f"}], "stats": {"total": 393, "additions": 213, "deletions": 180}, "files": [{"sha": "29ace8479dc875d674dfd6c0e2fc69ab046ec483", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -15,7 +15,7 @@ use hir_def::{\n     per_ns::PerNs,\n     resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId,\n+    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericParamId,\n     HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId,\n     Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n@@ -857,8 +857,7 @@ impl Local {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct GenericParam {\n-    pub(crate) parent: GenericDefId,\n-    pub(crate) idx: u32,\n+    pub(crate) id: GenericParamId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "8c4b635d22fc2c48588e39b08498c4374d8ce8ff", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -262,10 +262,7 @@ impl SourceAnalyzer {\n     ) -> Option<PathResolution> {\n         let types = self.resolver.resolve_path_in_type_ns_fully(db, &path).map(|ty| match ty {\n             TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n-            TypeNs::GenericParam(idx) => PathResolution::GenericParam(GenericParam {\n-                parent: self.resolver.generic_def().unwrap(),\n-                idx,\n-            }),\n+            TypeNs::GenericParam(id) => PathResolution::GenericParam(GenericParam { id }),\n             TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n                 PathResolution::Def(Adt::from(it).into())\n             }\n@@ -337,10 +334,7 @@ impl SourceAnalyzer {\n                 resolver::ScopeDef::PerNs(it) => it.into(),\n                 resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                 resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n-                resolver::ScopeDef::GenericParam(idx) => {\n-                    let parent = self.resolver.generic_def().unwrap();\n-                    ScopeDef::GenericParam(GenericParam { parent, idx })\n-                }\n+                resolver::ScopeDef::GenericParam(id) => ScopeDef::GenericParam(GenericParam { id }),\n                 resolver::ScopeDef::Local(pat_id) => {\n                     let parent = self.resolver.body_owner().unwrap().into();\n                     ScopeDef::Local(Local { parent, pat_id })"}, {"sha": "94ce835646c5cf9fd7cd808cae42b2ae7b35edd4", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 23, "deletions": 74, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -5,29 +5,27 @@\n use std::sync::Arc;\n \n use hir_expand::name::{self, AsName, Name};\n+use ra_arena::Arena;\n use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n \n use crate::{\n     db::DefDatabase,\n     src::HasSource,\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AstItemDef, ContainerId, GenericDefId, Lookup,\n+    AdtId, AstItemDef, GenericDefId, LocalGenericParamId, Lookup,\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct GenericParam {\n-    // FIXME: give generic params proper IDs\n-    pub idx: u32,\n+pub struct GenericParamData {\n     pub name: Name,\n     pub default: Option<TypeRef>,\n }\n \n /// Data about the generic parameters of a function, struct, impl, etc.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct GenericParams {\n-    pub parent_params: Option<Arc<GenericParams>>,\n-    pub params: Vec<GenericParam>,\n+    pub params: Arena<LocalGenericParamId, GenericParamData>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n \n@@ -46,51 +44,40 @@ impl GenericParams {\n         db: &impl DefDatabase,\n         def: GenericDefId,\n     ) -> Arc<GenericParams> {\n-        let parent_generics = parent_generic_def(db, def).map(|it| db.generic_params(it));\n-        Arc::new(GenericParams::new(db, def.into(), parent_generics))\n+        Arc::new(GenericParams::new(db, def.into()))\n     }\n \n-    fn new(\n-        db: &impl DefDatabase,\n-        def: GenericDefId,\n-        parent_params: Option<Arc<GenericParams>>,\n-    ) -> GenericParams {\n-        let mut generics =\n-            GenericParams { params: Vec::new(), parent_params, where_predicates: Vec::new() };\n-        let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n+    fn new(db: &impl DefDatabase, def: GenericDefId) -> GenericParams {\n+        let mut generics = GenericParams { params: Arena::default(), where_predicates: Vec::new() };\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n         match def {\n-            GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n-            GenericDefId::AdtId(AdtId::StructId(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value),\n+            GenericDefId::AdtId(AdtId::StructId(it)) => generics.fill(&it.source(db).value),\n+            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.source(db).value),\n+            GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value),\n             GenericDefId::TraitId(it) => {\n                 // traits get the Self type as an implicit first type parameter\n-                generics.params.push(GenericParam {\n-                    idx: start,\n-                    name: name::SELF_TYPE,\n-                    default: None,\n-                });\n-                generics.fill(&it.source(db).value, start + 1);\n+                generics.params.alloc(GenericParamData { name: name::SELF_TYPE, default: None });\n+                generics.fill(&it.source(db).value);\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name::SELF_TYPE.into());\n                 generics.fill_bounds(&it.source(db).value, self_param);\n             }\n-            GenericDefId::TypeAliasId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n+            GenericDefId::TypeAliasId(it) => generics.fill(&it.lookup(db).source(db).value),\n             // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n             // type-parameter, but rather is a type-alias for impl's target\n             // type, so this is handled by the resolver.\n-            GenericDefId::ImplId(it) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::ImplId(it) => generics.fill(&it.source(db).value),\n             GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {}\n         }\n \n         generics\n     }\n \n-    fn fill(&mut self, node: &impl TypeParamsOwner, start: u32) {\n+    fn fill(&mut self, node: &impl TypeParamsOwner) {\n         if let Some(params) = node.type_param_list() {\n-            self.fill_params(params, start)\n+            self.fill_params(params)\n         }\n         if let Some(where_clause) = node.where_clause() {\n             self.fill_where_predicates(where_clause);\n@@ -105,13 +92,13 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n-        for (idx, type_param) in params.type_params().enumerate() {\n+    fn fill_params(&mut self, params: ast::TypeParamList) {\n+        for type_param in params.type_params() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n             let default = type_param.default_type().map(TypeRef::from_ast);\n-            let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };\n-            self.params.push(param);\n+            let param = GenericParamData { name: name.clone(), default };\n+            self.params.alloc(param);\n \n             let type_ref = TypeRef::Path(name.into());\n             self.fill_bounds(&type_param, type_ref);\n@@ -140,45 +127,7 @@ impl GenericParams {\n         self.where_predicates.push(WherePredicate { type_ref, bound });\n     }\n \n-    pub fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n-        self.params.iter().find(|p| &p.name == name)\n-    }\n-\n-    pub fn count_parent_params(&self) -> usize {\n-        self.parent_params.as_ref().map(|p| p.count_params_including_parent()).unwrap_or(0)\n-    }\n-\n-    pub fn count_params_including_parent(&self) -> usize {\n-        let parent_count = self.count_parent_params();\n-        parent_count + self.params.len()\n-    }\n-\n-    fn for_each_param<'a>(&'a self, f: &mut impl FnMut(&'a GenericParam)) {\n-        if let Some(parent) = &self.parent_params {\n-            parent.for_each_param(f);\n-        }\n-        self.params.iter().for_each(f);\n-    }\n-\n-    pub fn params_including_parent(&self) -> Vec<&GenericParam> {\n-        let mut vec = Vec::with_capacity(self.count_params_including_parent());\n-        self.for_each_param(&mut |p| vec.push(p));\n-        vec\n-    }\n-}\n-\n-fn parent_generic_def(db: &impl DefDatabase, def: GenericDefId) -> Option<GenericDefId> {\n-    let container = match def {\n-        GenericDefId::FunctionId(it) => it.lookup(db).container,\n-        GenericDefId::TypeAliasId(it) => it.lookup(db).container,\n-        GenericDefId::ConstId(it) => it.lookup(db).container,\n-        GenericDefId::EnumVariantId(it) => return Some(it.parent.into()),\n-        GenericDefId::AdtId(_) | GenericDefId::TraitId(_) | GenericDefId::ImplId(_) => return None,\n-    };\n-\n-    match container {\n-        ContainerId::ImplId(it) => Some(it.into()),\n-        ContainerId::TraitId(it) => Some(it.into()),\n-        ContainerId::ModuleId(_) => None,\n+    pub fn find_by_name(&self, name: &Name) -> Option<LocalGenericParamId> {\n+        self.params.iter().find_map(|(id, p)| if &p.name == name { Some(id) } else { None })\n     }\n }"}, {"sha": "b8dfc0ab1a977ef6286efa0341c33f8157fbd54c", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -317,6 +317,16 @@ macro_rules! impl_froms {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct GenericParamId {\n+    pub parent: GenericDefId,\n+    pub local_id: LocalGenericParamId,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct LocalGenericParamId(RawId);\n+impl_arena_id!(LocalGenericParamId);\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum ContainerId {\n     ModuleId(ModuleId),"}, {"sha": "e00bd03d54f956c9c28dd4d6310d0d656803ee0b", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -18,12 +18,13 @@ use crate::{\n     path::{Path, PathKind},\n     per_ns::PerNs,\n     AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n-    GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId,\n-    StructId, TraitId, TypeAliasId,\n+    GenericDefId, GenericParamId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n+    StaticId, StructId, TraitId, TypeAliasId,\n };\n \n #[derive(Debug, Clone, Default)]\n pub struct Resolver {\n+    // FIXME: all usages generally call `.rev`, so maybe reverse once in consturciton?\n     scopes: Vec<Scope>,\n }\n \n@@ -58,7 +59,7 @@ enum Scope {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum TypeNs {\n     SelfType(ImplId),\n-    GenericParam(u32),\n+    GenericParam(GenericParamId),\n     AdtId(AdtId),\n     AdtSelfType(AdtId),\n     // Yup, enum variants are added to the types ns, but any usage of variant as\n@@ -152,10 +153,13 @@ impl Resolver {\n                 Scope::ExprScope(_) => continue,\n                 Scope::GenericParams { .. } | Scope::ImplBlockScope(_) if skip_to_mod => continue,\n \n-                Scope::GenericParams { params, .. } => {\n-                    if let Some(param) = params.find_by_name(first_name) {\n+                Scope::GenericParams { params, def } => {\n+                    if let Some(local_id) = params.find_by_name(first_name) {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::GenericParam(param.idx), idx));\n+                        return Some((\n+                            TypeNs::GenericParam(GenericParamId { local_id, parent: *def }),\n+                            idx,\n+                        ));\n                     }\n                 }\n                 Scope::ImplBlockScope(impl_) => {\n@@ -246,9 +250,9 @@ impl Resolver {\n                 }\n                 Scope::ExprScope(_) => continue,\n \n-                Scope::GenericParams { params, .. } if n_segments > 1 => {\n-                    if let Some(param) = params.find_by_name(first_name) {\n-                        let ty = TypeNs::GenericParam(param.idx);\n+                Scope::GenericParams { params, def } if n_segments > 1 => {\n+                    if let Some(local_id) = params.find_by_name(first_name) {\n+                        let ty = TypeNs::GenericParam(GenericParamId { local_id, parent: *def });\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n@@ -368,6 +372,7 @@ impl Resolver {\n     ) -> impl Iterator<Item = &'a crate::generics::WherePredicate> + 'a {\n         self.scopes\n             .iter()\n+            .rev()\n             .filter_map(|scope| match scope {\n                 Scope::GenericParams { params, .. } => Some(params),\n                 _ => None,\n@@ -376,14 +381,14 @@ impl Resolver {\n     }\n \n     pub fn generic_def(&self) -> Option<GenericDefId> {\n-        self.scopes.iter().find_map(|scope| match scope {\n+        self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::GenericParams { def, .. } => Some(*def),\n             _ => None,\n         })\n     }\n \n     pub fn body_owner(&self) -> Option<DefWithBodyId> {\n-        self.scopes.iter().find_map(|scope| match scope {\n+        self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ExprScope(it) => Some(it.owner),\n             _ => None,\n         })\n@@ -394,7 +399,7 @@ pub enum ScopeDef {\n     PerNs(PerNs),\n     ImplSelfType(ImplId),\n     AdtSelfType(AdtId),\n-    GenericParam(u32),\n+    GenericParam(GenericParamId),\n     Local(PatId),\n }\n \n@@ -425,9 +430,12 @@ impl Scope {\n                     });\n                 }\n             }\n-            Scope::GenericParams { params, .. } => {\n-                for param in params.params.iter() {\n-                    f(param.name.clone(), ScopeDef::GenericParam(param.idx))\n+            Scope::GenericParams { params, def } => {\n+                for (local_id, param) in params.params.iter() {\n+                    f(\n+                        param.name.clone(),\n+                        ScopeDef::GenericParam(GenericParamId { local_id, parent: *def }),\n+                    )\n                 }\n             }\n             Scope::ImplBlockScope(i) => {"}, {"sha": "d557962b4fec50fefe45ea52e29b044c9a8d4bf6", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -10,10 +10,10 @@ use hir_expand::name;\n use log::{info, warn};\n use ra_db::CrateId;\n \n-use crate::db::HirDatabase;\n-\n-use super::{\n+use crate::{\n+    db::HirDatabase,\n     traits::{InEnvironment, Solution},\n+    utils::generics,\n     Canonical, Substs, Ty, TypeWalk,\n };\n \n@@ -54,8 +54,8 @@ fn deref_by_trait(\n     };\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name::TARGET_TYPE)?;\n \n-    let generic_params = db.generic_params(target.into());\n-    if generic_params.count_params_including_parent() != 1 {\n+    let generic_params = generics(db, target.into());\n+    if generic_params.len() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,\n         // namely Deref's Self type\n         return None;"}, {"sha": "2c296987c8a612c82196bd89e305c8e22fb382e8", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -6,7 +6,6 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::Signedness,\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n-    generics::GenericParams,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n     AdtId, ContainerId, Lookup, StructFieldId,\n@@ -15,7 +14,11 @@ use hir_expand::name::{self, Name};\n use ra_syntax::ast::RangeOp;\n \n use crate::{\n-    autoderef, db::HirDatabase, method_resolution, op, traits::InEnvironment, utils::variant_data,\n+    autoderef,\n+    db::HirDatabase,\n+    method_resolution, op,\n+    traits::InEnvironment,\n+    utils::{generics, variant_data, Generics},\n     CallableDef, InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n     TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n };\n@@ -596,7 +599,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (ty, self.db.value_ty(func.into()), Some(self.db.generic_params(func.into())))\n+                (ty, self.db.value_ty(func.into()), Some(generics(self.db, func.into())))\n             }\n             None => (receiver_ty, Ty::Unknown, None),\n         };\n@@ -653,16 +656,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn substs_for_method_call(\n         &mut self,\n-        def_generics: Option<Arc<GenericParams>>,\n+        def_generics: Option<Generics>,\n         generic_args: Option<&GenericArgs>,\n         receiver_ty: &Ty,\n     ) -> Substs {\n-        let (parent_param_count, param_count) =\n-            def_generics.as_ref().map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n-        let mut substs = Vec::with_capacity(parent_param_count + param_count);\n+        let (total_len, _parent_len, child_len) =\n+            def_generics.as_ref().map_or((0, 0, 0), |g| g.len_split());\n+        let mut substs = Vec::with_capacity(total_len);\n         // Parent arguments are unknown, except for the receiver type\n-        if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n-            for param in &parent_generics.params {\n+        if let Some(parent_generics) = def_generics.as_ref().map(|p| p.iter_parent()) {\n+            for (_id, param) in parent_generics {\n                 if param.name == name::SELF_TYPE {\n                     substs.push(receiver_ty.clone());\n                 } else {\n@@ -673,7 +676,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args.args.iter().take(param_count) {\n+            for arg in generic_args.args.iter().take(child_len) {\n                 match arg {\n                     GenericArg::Type(type_ref) => {\n                         let ty = self.make_ty(type_ref);\n@@ -683,10 +686,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n         };\n         let supplied_params = substs.len();\n-        for _ in supplied_params..parent_param_count + param_count {\n+        for _ in supplied_params..total_len {\n             substs.push(Ty::Unknown);\n         }\n-        assert_eq!(substs.len(), parent_param_count + param_count);\n+        assert_eq!(substs.len(), total_len);\n         Substs(substs.into())\n     }\n \n@@ -705,11 +708,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     CallableDef::FunctionId(f) => {\n                         if let ContainerId::TraitId(trait_) = f.lookup(self.db).container {\n                             // construct a TraitDef\n-                            let substs = a_ty.parameters.prefix(\n-                                self.db\n-                                    .generic_params(trait_.into())\n-                                    .count_params_including_parent(),\n-                            );\n+                            let substs =\n+                                a_ty.parameters.prefix(generics(self.db, trait_.into()).len());\n                             self.obligations.push(Obligation::Trait(TraitRef {\n                                 trait_: trait_.into(),\n                                 substs,"}, {"sha": "3ad913e55e5121785bd749a7f59226ea998de663", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -44,16 +44,16 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use hir_def::{\n-    expr::ExprId, generics::GenericParams, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId,\n-    GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n+    expr::ExprId, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId, GenericDefId, HasModule,\n+    Lookup, TraitId, TypeAliasId,\n };\n use hir_expand::name::Name;\n use ra_db::{impl_intern_key, salsa, CrateId};\n \n use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy, Uncertain},\n-    utils::make_mut_slice,\n+    utils::{generics, make_mut_slice, Generics},\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -166,16 +166,16 @@ impl TypeCtor {\n             | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n             => 1,\n             TypeCtor::Adt(adt) => {\n-                let generic_params = db.generic_params(AdtId::from(adt).into());\n-                generic_params.count_params_including_parent()\n+                let generic_params = generics(db, AdtId::from(adt).into());\n+                generic_params.len()\n             }\n             TypeCtor::FnDef(callable) => {\n-                let generic_params = db.generic_params(callable.into());\n-                generic_params.count_params_including_parent()\n+                let generic_params = generics(db, callable.into());\n+                generic_params.len()\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n-                let generic_params = db.generic_params(type_alias.into());\n-                generic_params.count_params_including_parent()\n+                let generic_params = generics(db, type_alias.into());\n+                generic_params.len()\n             }\n             TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n             TypeCtor::Tuple { cardinality } => cardinality as usize,\n@@ -364,36 +364,26 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub fn identity(generic_params: &GenericParams) -> Substs {\n+    pub(crate) fn identity(generic_params: &Generics) -> Substs {\n         Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-                .collect(),\n+            generic_params.iter().map(|(idx, p)| Ty::Param { idx, name: p.name.clone() }).collect(),\n         )\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n-    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n-        Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Bound(p.idx))\n-                .collect(),\n-        )\n+    pub(crate) fn bound_vars(generic_params: &Generics) -> Substs {\n+        Substs(generic_params.iter().map(|(idx, _p)| Ty::Bound(idx)).collect())\n     }\n \n     pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n         let def = def.into();\n-        let params = db.generic_params(def);\n-        let param_count = params.count_params_including_parent();\n+        let params = generics(db, def);\n+        let param_count = params.len();\n         Substs::builder(param_count)\n     }\n \n-    pub fn build_for_generics(generic_params: &GenericParams) -> SubstsBuilder {\n-        Substs::builder(generic_params.count_params_including_parent())\n+    pub(crate) fn build_for_generics(generic_params: &Generics) -> SubstsBuilder {\n+        Substs::builder(generic_params.len())\n     }\n \n     pub fn build_for_type_ctor(db: &impl HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {"}, {"sha": "eab91229e3e41f1754cecc508077d9f39bf6f2c1", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -24,7 +24,7 @@ use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy},\n     utils::{\n-        all_super_traits, associated_type_by_name_including_super_traits, make_mut_slice,\n+        all_super_traits, associated_type_by_name_including_super_traits, generics, make_mut_slice,\n         variant_data,\n     },\n     FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n@@ -111,7 +111,9 @@ impl Ty {\n             Some((it, None)) => it,\n             _ => return None,\n         };\n-        if let TypeNs::GenericParam(idx) = resolution {\n+        if let TypeNs::GenericParam(param_id) = resolution {\n+            let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n+            let idx = generics.param_idx(param_id);\n             Some(idx)\n         } else {\n             None\n@@ -174,9 +176,11 @@ impl Ty {\n                     Ty::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n                 };\n             }\n-            TypeNs::GenericParam(idx) => {\n+            TypeNs::GenericParam(param_id) => {\n+                let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n+                let idx = generics.param_idx(param_id);\n                 // FIXME: maybe return name in resolution?\n-                let name = resolved_segment.name.clone();\n+                let name = generics.param_name(param_id);\n                 Ty::Param { idx, name }\n             }\n             TypeNs::SelfType(impl_id) => db.impl_self_ty(impl_id).clone(),\n@@ -315,11 +319,10 @@ pub(super) fn substs_from_path_segment(\n     add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| db.generic_params(def.into()));\n+    let def_generics = def_generic.map(|def| generics(db, def.into()));\n \n-    let (parent_param_count, param_count) =\n-        def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n-    substs.extend(iter::repeat(Ty::Unknown).take(parent_param_count));\n+    let (total_len, parent_len, child_len) = def_generics.map_or((0, 0, 0), |g| g.len_split());\n+    substs.extend(iter::repeat(Ty::Unknown).take(parent_len));\n     if add_self_param {\n         // FIXME this add_self_param argument is kind of a hack: Traits have the\n         // Self type as an implicit first type parameter, but it can't be\n@@ -330,8 +333,8 @@ pub(super) fn substs_from_path_segment(\n     if let Some(generic_args) = &segment.args_and_bindings {\n         // if args are provided, it should be all of them, but we can't rely on that\n         let self_param_correction = if add_self_param { 1 } else { 0 };\n-        let param_count = param_count - self_param_correction;\n-        for arg in generic_args.args.iter().take(param_count) {\n+        let child_len = child_len + self_param_correction;\n+        for arg in generic_args.args.iter().take(child_len) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n                     let ty = Ty::from_hir(db, resolver, type_ref);\n@@ -342,10 +345,10 @@ pub(super) fn substs_from_path_segment(\n     }\n     // add placeholders for args that were not provided\n     let supplied_params = substs.len();\n-    for _ in supplied_params..parent_param_count + param_count {\n+    for _ in supplied_params..total_len {\n         substs.push(Ty::Unknown);\n     }\n-    assert_eq!(substs.len(), parent_param_count + param_count);\n+    assert_eq!(substs.len(), total_len);\n \n     // handle defaults\n     if let Some(def_generic) = def_generic {\n@@ -567,12 +570,11 @@ pub(crate) fn generic_predicates_query(\n /// Resolve the default type params from generics\n pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -> Substs {\n     let resolver = def.resolver(db);\n-    let generic_params = db.generic_params(def.into());\n+    let generic_params = generics(db, def.into());\n \n     let defaults = generic_params\n-        .params_including_parent()\n-        .into_iter()\n-        .map(|p| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n+        .iter()\n+        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n         .collect();\n \n     Substs(defaults)\n@@ -589,7 +591,7 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n-    let generics = db.generic_params(def.into());\n+    let generics = generics(db, def.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n@@ -639,7 +641,7 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Ty {\n     if struct_data.variant_data.is_unit() {\n         return type_for_adt(db, def.into()); // Unit struct\n     }\n-    let generics = db.generic_params(def.into());\n+    let generics = generics(db, def.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n@@ -653,7 +655,7 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n-    let generics = db.generic_params(def.parent.into());\n+    let generics = generics(db, def.parent.into());\n     let substs = Substs::identity(&generics);\n     let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n     FnSig::from_params_and_return(params, ret)\n@@ -666,18 +668,18 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId)\n     if var_data.is_unit() {\n         return type_for_adt(db, def.parent.into()); // Unit variant\n     }\n-    let generics = db.generic_params(def.parent.into());\n+    let generics = generics(db, def.parent.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs)\n }\n \n fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n-    let generics = db.generic_params(adt.into());\n+    let generics = generics(db, adt.into());\n     Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n-    let generics = db.generic_params(t.into());\n+    let generics = generics(db, t.into());\n     let resolver = t.resolver(db);\n     let type_ref = &db.type_alias_data(t).type_ref;\n     let substs = Substs::identity(&generics);"}, {"sha": "1e7ff93d596dec6241537fc7d5f2178f8132f4a7", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -19,8 +19,8 @@ use ra_db::{\n \n use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n-    db::HirDatabase, display::HirDisplay, ApplicationTy, GenericPredicate, ProjectionTy, Substs,\n-    TraitRef, Ty, TypeCtor, TypeWalk,\n+    db::HirDatabase, display::HirDisplay, utils::generics, ApplicationTy, GenericPredicate,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -547,7 +547,7 @@ pub(crate) fn associated_ty_data_query(\n         ContainerId::TraitId(t) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n-    let generic_params = db.generic_params(type_alias.into());\n+    let generic_params = generics(db, type_alias.into());\n     let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n         // FIXME add bounds and where clauses\n         bounds: vec![],\n@@ -557,7 +557,7 @@ pub(crate) fn associated_ty_data_query(\n         trait_id: trait_.to_chalk(db),\n         id,\n         name: lalrpop_intern::intern(&db.type_alias_data(type_alias).name.to_string()),\n-        binders: make_binders(bound_data, generic_params.count_params_including_parent()),\n+        binders: make_binders(bound_data, generic_params.len()),\n     };\n     Arc::new(datum)\n }\n@@ -589,7 +589,7 @@ pub(crate) fn trait_datum_query(\n     let trait_: TraitId = from_chalk(db, trait_id);\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n-    let generic_params = db.generic_params(trait_.into());\n+    let generic_params = generics(db, trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_data.auto,\n@@ -626,7 +626,7 @@ pub(crate) fn struct_datum_query(\n     let where_clauses = type_ctor\n         .as_generic_def()\n         .map(|generic_def| {\n-            let generic_params = db.generic_params(generic_def.into());\n+            let generic_params = generics(db, generic_def.into());\n             let bound_vars = Substs::bound_vars(&generic_params);\n             convert_where_clauses(db, generic_def, &bound_vars)\n         })\n@@ -669,7 +669,7 @@ fn impl_block_datum(\n     let trait_ref = db.impl_trait(impl_id)?;\n     let impl_data = db.impl_data(impl_id);\n \n-    let generic_params = db.generic_params(impl_id.into());\n+    let generic_params = generics(db, impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let trait_ref = trait_ref.subst(&bound_vars);\n     let trait_ = trait_ref.trait_;\n@@ -767,7 +767,7 @@ fn type_alias_associated_ty_value(\n         .trait_data(trait_ref.trait_)\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n-    let generic_params = db.generic_params(impl_id.into());\n+    let generic_params = generics(db, impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let ty = db.ty(type_alias.into()).subst(&bound_vars);\n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };"}, {"sha": "936cfe25e089abbf3f154399268bc16b729c6ac3", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aac5f2b427247120025f63c4864a1b937ed20c7/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=7aac5f2b427247120025f63c4864a1b937ed20c7", "patch": "@@ -5,9 +5,10 @@ use std::sync::Arc;\n use hir_def::{\n     adt::VariantData,\n     db::DefDatabase,\n+    generics::{GenericParamData, GenericParams},\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n-    TraitId, TypeAliasId, VariantId,\n+    ContainerId, GenericDefId, GenericParamId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{self, Name};\n \n@@ -82,3 +83,83 @@ pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n     }\n     Arc::get_mut(a).unwrap()\n }\n+\n+pub(crate) fn generics(db: &impl DefDatabase, def: GenericDefId) -> Generics {\n+    let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n+    Generics { def, params: db.generic_params(def), parent_generics }\n+}\n+\n+pub(crate) struct Generics {\n+    def: GenericDefId,\n+    pub(crate) params: Arc<GenericParams>,\n+    parent_generics: Option<Box<Generics>>,\n+}\n+\n+impl Generics {\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (u32, &'a GenericParamData)> + 'a {\n+        self.parent_generics\n+            .as_ref()\n+            .into_iter()\n+            .flat_map(|it| it.params.params.iter())\n+            .chain(self.params.params.iter())\n+            .enumerate()\n+            .map(|(i, (_local_id, p))| (i as u32, p))\n+    }\n+\n+    pub(crate) fn iter_parent<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (u32, &'a GenericParamData)> + 'a {\n+        self.parent_generics\n+            .as_ref()\n+            .into_iter()\n+            .flat_map(|it| it.params.params.iter())\n+            .enumerate()\n+            .map(|(i, (_local_id, p))| (i as u32, p))\n+    }\n+\n+    pub(crate) fn len(&self) -> usize {\n+        self.len_split().0\n+    }\n+    /// (total, parents, child)\n+    pub(crate) fn len_split(&self) -> (usize, usize, usize) {\n+        let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n+        let child = self.params.params.len();\n+        (parent + child, parent, child)\n+    }\n+    pub(crate) fn param_idx(&self, param: GenericParamId) -> u32 {\n+        self.find_param(param).0\n+    }\n+    pub(crate) fn param_name(&self, param: GenericParamId) -> Name {\n+        self.find_param(param).1.name.clone()\n+    }\n+    fn find_param(&self, param: GenericParamId) -> (u32, &GenericParamData) {\n+        if param.parent == self.def {\n+            let (idx, (_local_id, data)) = self\n+                .params\n+                .params\n+                .iter()\n+                .enumerate()\n+                .find(|(_, (idx, _))| *idx == param.local_id)\n+                .unwrap();\n+            let (_total, parent_len, _child) = self.len_split();\n+            return ((parent_len + idx) as u32, data);\n+        }\n+        self.parent_generics.as_ref().unwrap().find_param(param)\n+    }\n+}\n+\n+fn parent_generic_def(db: &impl DefDatabase, def: GenericDefId) -> Option<GenericDefId> {\n+    let container = match def {\n+        GenericDefId::FunctionId(it) => it.lookup(db).container,\n+        GenericDefId::TypeAliasId(it) => it.lookup(db).container,\n+        GenericDefId::ConstId(it) => it.lookup(db).container,\n+        GenericDefId::EnumVariantId(it) => return Some(it.parent.into()),\n+        GenericDefId::AdtId(_) | GenericDefId::TraitId(_) | GenericDefId::ImplId(_) => return None,\n+    };\n+\n+    match container {\n+        ContainerId::ImplId(it) => Some(it.into()),\n+        ContainerId::TraitId(it) => Some(it.into()),\n+        ContainerId::ModuleId(_) => None,\n+    }\n+}"}]}