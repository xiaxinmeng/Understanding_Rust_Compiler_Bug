{"sha": "45205f2ac18e926ec61f2672d16ec3b955de5652", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MjA1ZjJhYzE4ZTkyNmVjNjFmMjY3MmQxNmVjM2I5NTVkZTU2NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-27T01:02:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-27T01:02:37Z"}, "message": "Auto merge of #56262 - petrochenkov:nabsedihyg, r=petrochenkov\n\n[master] resolve: Implement edition hygiene for imports and absolute paths\n\nForward-port of https://github.com/rust-lang/rust/pull/56053 to master.\n\nr? @ghost", "tree": {"sha": "0be7cc59508af3ad3d97d0c2d0b08e676f122c9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0be7cc59508af3ad3d97d0c2d0b08e676f122c9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45205f2ac18e926ec61f2672d16ec3b955de5652", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45205f2ac18e926ec61f2672d16ec3b955de5652", "html_url": "https://github.com/rust-lang/rust/commit/45205f2ac18e926ec61f2672d16ec3b955de5652", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45205f2ac18e926ec61f2672d16ec3b955de5652/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75d937c49b79dcfb99895470c1fd63cc6f9343a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/75d937c49b79dcfb99895470c1fd63cc6f9343a3", "html_url": "https://github.com/rust-lang/rust/commit/75d937c49b79dcfb99895470c1fd63cc6f9343a3"}, {"sha": "6f13708299c22cf8450e239c4ab06aada2d1cf07", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f13708299c22cf8450e239c4ab06aada2d1cf07", "html_url": "https://github.com/rust-lang/rust/commit/6f13708299c22cf8450e239c4ab06aada2d1cf07"}], "stats": {"total": 1184, "additions": 645, "deletions": 539}, "files": [{"sha": "d383d8375a948dd7b132bf85af124cd0f88ddeed", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -1478,15 +1478,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// done with either: `-Ztwo-phase-borrows`, `#![feature(nll)]`,\n     /// or by opting into an edition after 2015.\n     pub fn two_phase_borrows(self) -> bool {\n-        if self.features().nll || self.sess.opts.debugging_opts.two_phase_borrows {\n-            return true;\n-        }\n-\n-        match self.sess.edition() {\n-            Edition::Edition2015 => false,\n-            Edition::Edition2018 => true,\n-            _ => true,\n-        }\n+        self.sess.rust_2018() || self.features().nll ||\n+        self.sess.opts.debugging_opts.two_phase_borrows\n     }\n \n     /// What mode(s) of borrowck should we run? AST? MIR? both?"}, {"sha": "350e55288ea10a24d716d373f1be9abc652bf567", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -14,7 +14,6 @@ use ty::{self, DefIdTree, Ty, TyCtxt};\n use middle::cstore::{ExternCrate, ExternCrateSource};\n use syntax::ast;\n use syntax::symbol::{keywords, LocalInternedString, Symbol};\n-use syntax_pos::edition::Edition;\n \n use std::cell::Cell;\n use std::fmt::Debug;\n@@ -140,7 +139,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         debug!(\"push_krate_path: name={:?}\", name);\n                         buffer.push(&name);\n                     }\n-                } else if self.sess.edition() == Edition::Edition2018 && !pushed_prelude_crate {\n+                } else if self.sess.rust_2018() && !pushed_prelude_crate {\n                     SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n                         // We only add the `crate::` keyword where appropriate. In particular,\n                         // when we've not previously pushed a prelude crate to this path."}, {"sha": "2966e9ec9d9f1c1ba1ef9e92f288ffc24cd6bc31", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -132,15 +132,21 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // so prefixes are prepended with crate root segment if necessary.\n         // The root is prepended lazily, when the first non-empty prefix or terminating glob\n         // appears, so imports in braced groups can have roots prepended independently.\n+        // 2015 identifiers used on global 2018 edition enter special \"virtual 2015 mode\", don't\n+        // get crate root prepended, but get special treatment during in-scope resolution instead.\n         let is_glob = if let ast::UseTreeKind::Glob = use_tree.kind { true } else { false };\n-        let crate_root = if !self.session.rust_2018() &&\n-                prefix_iter.peek().map_or(is_glob, |seg| !seg.ident.is_path_segment_keyword()) {\n-            Some(Segment::from_ident(Ident::new(\n-                keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo()\n-            )))\n-        } else {\n-            None\n-        };\n+        let crate_root = match prefix_iter.peek() {\n+            Some(seg) if !seg.ident.is_path_segment_keyword() &&\n+                         seg.ident.span.rust_2015() && self.session.rust_2015() => {\n+                Some(seg.ident.span.ctxt())\n+            }\n+            None if is_glob && use_tree.span.rust_2015() => {\n+                Some(use_tree.span.ctxt())\n+            }\n+            _ => None,\n+        }.map(|ctxt| Segment::from_ident(Ident::new(\n+            keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n+        )));\n \n         let prefix = crate_root.into_iter().chain(prefix_iter).collect::<Vec<_>>();\n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);"}, {"sha": "e2a6303f579449e8f60e272c29b1119154c6a709", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -33,7 +33,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             (Some(fst), Some(snd)) if fst.ident.name == keywords::CrateRoot.name() &&\n                                       !snd.ident.is_path_segment_keyword() => {}\n             // `ident::...` on 2018\n-            (Some(fst), _) if self.session.rust_2018() && !fst.ident.is_path_segment_keyword() => {\n+            (Some(fst), _) if fst.ident.span.rust_2018() &&\n+                              !fst.ident.is_path_segment_keyword() => {\n                 // Insert a placeholder that's later replaced by `self`/`super`/etc.\n                 path.insert(0, Segment::from_ident(keywords::Invalid.ident()));\n             }\n@@ -141,7 +142,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n-        if !self.session.rust_2018() {\n+        if path[1].ident.span.rust_2015() {\n             return None;\n         }\n "}, {"sha": "cbf82a80266678f72d33557103e7ab90de619c92", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 113, "deletions": 71, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -13,6 +13,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(crate_visibility_modifier)]\n+#![feature(label_break_value)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n@@ -101,6 +102,13 @@ enum Weak {\n     No,\n }\n \n+enum ScopeSet {\n+    Import(Namespace),\n+    AbsolutePath(Namespace),\n+    Macro(MacroKind),\n+    Module,\n+}\n+\n /// A free importable items suggested in case of resolution failure.\n struct ImportSuggestion {\n     path: Path,\n@@ -996,31 +1004,33 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n-\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-enum UniformRootKind {\n-    CurrentScope,\n-    ExternPrelude,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n enum ModuleOrUniformRoot<'a> {\n     /// Regular module.\n     Module(Module<'a>),\n \n-    /// This \"virtual module\" denotes either resolution in extern prelude\n-    /// for paths starting with `::` on 2018 edition or `extern::`,\n-    /// or resolution in current scope for single-segment imports.\n-    UniformRoot(UniformRootKind),\n+    /// Virtual module that denotes resolution in crate root with fallback to extern prelude.\n+    CrateRootAndExternPrelude,\n+\n+    /// Virtual module that denotes resolution in extern prelude.\n+    /// Used for paths starting with `::` on 2018 edition or `extern::`.\n+    ExternPrelude,\n+\n+    /// Virtual module that denotes resolution in current scope.\n+    /// Used only for resolving single-segment imports. The reason it exists is that import paths\n+    /// are always split into two parts, the first of which should be some kind of module.\n+    CurrentScope,\n }\n \n impl<'a> PartialEq for ModuleOrUniformRoot<'a> {\n     fn eq(&self, other: &Self) -> bool {\n         match (*self, *other) {\n-            (ModuleOrUniformRoot::Module(lhs), ModuleOrUniformRoot::Module(rhs)) =>\n-                ptr::eq(lhs, rhs),\n-            (ModuleOrUniformRoot::UniformRoot(lhs), ModuleOrUniformRoot::UniformRoot(rhs)) =>\n-                lhs == rhs,\n+            (ModuleOrUniformRoot::Module(lhs),\n+             ModuleOrUniformRoot::Module(rhs)) => ptr::eq(lhs, rhs),\n+            (ModuleOrUniformRoot::CrateRootAndExternPrelude,\n+             ModuleOrUniformRoot::CrateRootAndExternPrelude) |\n+            (ModuleOrUniformRoot::ExternPrelude, ModuleOrUniformRoot::ExternPrelude) |\n+            (ModuleOrUniformRoot::CurrentScope, ModuleOrUniformRoot::CurrentScope) => true,\n             _ => false,\n         }\n     }\n@@ -1239,6 +1249,7 @@ struct UseError<'a> {\n #[derive(Clone, Copy, PartialEq, Debug)]\n enum AmbiguityKind {\n     Import,\n+    AbsolutePath,\n     BuiltinAttr,\n     DeriveHelper,\n     LegacyHelperVsPrelude,\n@@ -1254,6 +1265,8 @@ impl AmbiguityKind {\n         match self {\n             AmbiguityKind::Import =>\n                 \"name vs any other name during import resolution\",\n+            AmbiguityKind::AbsolutePath =>\n+                \"name in the crate root vs extern crate during absolute path resolution\",\n             AmbiguityKind::BuiltinAttr =>\n                 \"built-in attribute vs any other name\",\n             AmbiguityKind::DeriveHelper =>\n@@ -1279,6 +1292,7 @@ impl AmbiguityKind {\n /// Miscellaneous bits of metadata for better ambiguity error reporting.\n #[derive(Clone, Copy, PartialEq)]\n enum AmbiguityErrorMisc {\n+    SuggestCrate,\n     SuggestSelf,\n     FromPrelude,\n     None,\n@@ -1757,8 +1771,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 error_callback(self, span, ResolutionError::FailedToResolve(msg));\n                 Def::Err\n             }\n-            PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n-            PathResult::Indeterminate => unreachable!(),\n+            PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n                 error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n                 Def::Err\n@@ -2191,28 +2204,46 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_ident_in_module(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n-        mut ident: Ident,\n+        ident: Ident,\n         ns: Namespace,\n         parent_scope: Option<&ParentScope<'a>>,\n         record_used: bool,\n         path_span: Span\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        ident.span = ident.span.modern();\n+        self.resolve_ident_in_module_ext(\n+            module, ident, ns, parent_scope, record_used, path_span\n+        ).map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    fn resolve_ident_in_module_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: Option<&ParentScope<'a>>,\n+        record_used: bool,\n+        path_span: Span\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let orig_current_module = self.current_module;\n         match module {\n             ModuleOrUniformRoot::Module(module) => {\n+                ident.span = ident.span.modern();\n                 if let Some(def) = ident.span.adjust(module.expansion) {\n                     self.current_module = self.macro_def_scope(def);\n                 }\n             }\n-            ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude) => {\n+            ModuleOrUniformRoot::ExternPrelude => {\n+                ident.span = ident.span.modern();\n                 ident.span.adjust(Mark::root());\n             }\n-            _ => {}\n+            ModuleOrUniformRoot::CrateRootAndExternPrelude |\n+            ModuleOrUniformRoot::CurrentScope => {\n+                // No adjustments\n+            }\n         }\n         let result = self.resolve_ident_in_module_unadjusted_ext(\n             module, ident, ns, parent_scope, false, record_used, path_span,\n-        ).map_err(|(determinacy, _)| determinacy);\n+        );\n         self.current_module = orig_current_module;\n         result\n     }\n@@ -2354,14 +2385,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn future_proof_import(&mut self, use_tree: &ast::UseTree) {\n-        if !self.session.rust_2018() {\n-            return;\n-        }\n-\n         let segments = &use_tree.prefix.segments;\n         if !segments.is_empty() {\n             let ident = segments[0].ident;\n-            if ident.is_path_segment_keyword() {\n+            if ident.is_path_segment_keyword() || ident.span.rust_2015() {\n                 return;\n             }\n \n@@ -3181,10 +3208,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n             let ident = path.last().unwrap().ident;\n-            let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n+            let candidates = this.lookup_import_candidates(ident, ns, is_expected);\n             if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n-                    this.lookup_import_candidates(ident.name, ns, is_enum_variant);\n+                    this.lookup_import_candidates(ident, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n@@ -3653,8 +3680,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 err_path_resolution()\n             }\n-            PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n-            PathResult::Failed(..) => return None,\n+            PathResult::Module(..) | PathResult::Failed(..) => return None,\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n@@ -3772,9 +3798,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                         continue;\n                     }\n                     if name == keywords::Extern.name() ||\n-                       name == keywords::CrateRoot.name() && self.session.rust_2018() {\n-                        module =\n-                            Some(ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude));\n+                       name == keywords::CrateRoot.name() && ident.span.rust_2018() {\n+                        module = Some(ModuleOrUniformRoot::ExternPrelude);\n+                        continue;\n+                    }\n+                    if name == keywords::CrateRoot.name() &&\n+                       ident.span.rust_2015() && self.session.rust_2018() {\n+                        // `::a::b` from 2015 macro on 2018 global edition\n+                        module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n                         continue;\n                     }\n                     if name == keywords::CrateRoot.name() ||\n@@ -3807,9 +3838,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, None, record_used, path_span)\n             } else if opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.early_resolve_ident_in_lexical_scope(ident, ns, None, opt_ns.is_none(),\n-                                                          parent_scope, record_used, record_used,\n-                                                          path_span)\n+                let scopes = if opt_ns.is_none() { ScopeSet::Import(ns) } else { ScopeSet::Module };\n+                self.early_resolve_ident_in_lexical_scope(ident, scopes, parent_scope, record_used,\n+                                                          record_used, path_span)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n@@ -3875,7 +3906,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     let msg = if module_def == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n-                            self.lookup_import_candidates(name, TypeNS, is_mod);\n+                            self.lookup_import_candidates(ident, TypeNS, is_mod);\n                         candidates.sort_by_cached_key(|c| {\n                             (c.path.segments.len(), c.path.to_string())\n                         });\n@@ -3898,8 +3929,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         PathResult::Module(match module {\n             Some(module) => module,\n-            None if path.is_empty() =>\n-                ModuleOrUniformRoot::UniformRoot(UniformRootKind::CurrentScope),\n+            None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n             _ => span_bug!(path_span, \"resolve_path: non-empty path `{:?}` has no module\", path),\n         })\n     }\n@@ -3911,11 +3941,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         second_binding: Option<&NameBinding>,\n     ) {\n-        // In the 2018 edition this lint is a hard error, so nothing to do\n-        if self.session.rust_2018() {\n-            return\n-        }\n-\n         let (diag_id, diag_span) = match crate_lint {\n             CrateLint::No => return,\n             CrateLint::SimplePath(id) => (id, path_span),\n@@ -3924,8 +3949,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         let first_name = match path.get(0) {\n-            Some(ident) => ident.ident.name,\n-            None => return,\n+            // In the 2018 edition this lint is a hard error, so nothing to do\n+            Some(seg) if seg.ident.span.rust_2015() => seg.ident.name,\n+            _ => return,\n         };\n \n         // We're only interested in `use` paths which should start with\n@@ -4507,7 +4533,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n-                                          lookup_name: Name,\n+                                          lookup_ident: Ident,\n                                           namespace: Namespace,\n                                           start_module: &'a ModuleData<'a>,\n                                           crate_name: Ident,\n@@ -4534,11 +4560,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 if !name_binding.is_importable() { return; }\n \n                 // collect results based on the filter function\n-                if ident.name == lookup_name && ns == namespace {\n+                if ident.name == lookup_ident.name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n                         let mut segms = path_segments.clone();\n-                        if self.session.rust_2018() {\n+                        if lookup_ident.span.rust_2018() {\n                             // crate-local absolute paths start with `crate::` in edition 2018\n                             // FIXME: may also be stabilized for Rust 2015 (Issues #45477, #44660)\n                             segms.insert(\n@@ -4572,7 +4598,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n                     let is_extern_crate_that_also_appears_in_prelude =\n                         name_binding.is_extern_crate() &&\n-                        self.session.rust_2018();\n+                        lookup_ident.span.rust_2018();\n \n                     let is_visible_to_user =\n                         !in_module_is_extern || name_binding.vis == ty::Visibility::Public;\n@@ -4599,16 +4625,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     /// NOTE: The method does not look into imports, but this is not a problem,\n     /// since we report the definitions (thus, the de-aliased imports).\n     fn lookup_import_candidates<FilterFn>(&mut self,\n-                                          lookup_name: Name,\n+                                          lookup_ident: Ident,\n                                           namespace: Namespace,\n                                           filter_fn: FilterFn)\n                                           -> Vec<ImportSuggestion>\n         where FilterFn: Fn(Def) -> bool\n     {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n-            lookup_name, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn);\n+            lookup_ident, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn);\n \n-        if self.session.rust_2018() {\n+        if lookup_ident.span.rust_2018() {\n             let extern_prelude_names = self.extern_prelude.clone();\n             for (ident, _) in extern_prelude_names.into_iter() {\n                 if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n@@ -4620,7 +4646,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     self.populate_module_if_necessary(&crate_root);\n \n                     suggestions.extend(self.lookup_import_candidates_from_module(\n-                        lookup_name, namespace, crate_root, ident, &filter_fn));\n+                        lookup_ident, namespace, crate_root, ident, &filter_fn));\n                 }\n             }\n         }\n@@ -4712,19 +4738,26 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n                 // paths\" right now, so on 2018 edition we only allow module-relative paths for now.\n-                let first_ident = path.segments[0].ident;\n-                if self.session.rust_2018() && !first_ident.is_path_segment_keyword() {\n+                // On 2015 edition visibilities are resolved as crate-relative by default,\n+                // so we are prepending a root segment if necessary.\n+                let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n+                let crate_root = if ident.is_path_segment_keyword() {\n+                    None\n+                } else if ident.span.rust_2018() {\n                     let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n-                    self.session.struct_span_err(first_ident.span, msg)\n+                    self.session.struct_span_err(ident.span, msg)\n                                 .span_suggestion(path.span, \"try\", format!(\"crate::{}\", path))\n                                 .emit();\n                     return ty::Visibility::Public;\n-                }\n-                // On 2015 visibilities are resolved as crate-relative by default,\n-                // add starting root segment if necessary.\n-                let segments = path.make_root().iter().chain(path.segments.iter())\n-                    .map(|seg| Segment { ident: seg.ident, id: Some(seg.id) })\n-                    .collect::<Vec<_>>();\n+                } else {\n+                    let ctxt = ident.span.ctxt();\n+                    Some(Segment::from_ident(Ident::new(\n+                        keywords::CrateRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n+                    )))\n+                };\n+\n+                let segments = crate_root.into_iter()\n+                    .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n                 let def = self.smart_resolve_path_fragment(\n                     id,\n                     None,\n@@ -4837,13 +4870,22 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 help_msgs.push(format!(\"consider adding an explicit import of \\\n                                         `{ident}` to disambiguate\", ident = ident))\n             }\n-            if b.is_extern_crate() && self.session.rust_2018() {\n-                help_msgs.push(format!(\"use `::{ident}` to refer to this {thing} unambiguously\",\n-                                       ident = ident, thing = b.descr()))\n-            }\n-            if misc == AmbiguityErrorMisc::SuggestSelf {\n-                help_msgs.push(format!(\"use `self::{ident}` to refer to this {thing} unambiguously\",\n-                                       ident = ident, thing = b.descr()))\n+            if b.is_extern_crate() && ident.span.rust_2018() {\n+                help_msgs.push(format!(\n+                    \"use `::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident, thing = b.descr(),\n+                ))\n+            }\n+            if misc == AmbiguityErrorMisc::SuggestCrate {\n+                help_msgs.push(format!(\n+                    \"use `crate::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident, thing = b.descr(),\n+                ))\n+            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n+                help_msgs.push(format!(\n+                    \"use `self::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident, thing = b.descr(),\n+                ))\n             }\n \n             if b.span.is_dummy() {"}, {"sha": "5db3efee9f6a15ebc724b313998b73a9eea77f10", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 113, "deletions": 51, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, Resolver, ResolutionError, Segment, Weak};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use {CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n use {is_known_tool, resolve_error};\n use ModuleOrUniformRoot;\n-use Namespace::{self, *};\n+use Namespace::*;\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, DefIndex,\n@@ -42,7 +42,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use errors::Applicability;\n \n use std::cell::Cell;\n-use std::mem;\n+use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n #[derive(Clone, Debug)]\n@@ -502,7 +502,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0].ident, MacroNS, Some(kind), false, parent_scope, false, force, path_span\n+                path[0].ident, ScopeSet::Macro(kind), parent_scope, false, force, path_span\n             );\n             match binding {\n                 Ok(..) => {}\n@@ -526,10 +526,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     // `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n     crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n-        mut ident: Ident,\n-        ns: Namespace,\n-        macro_kind: Option<MacroKind>,\n-        is_import: bool,\n+        orig_ident: Ident,\n+        scope_set: ScopeSet,\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         force: bool,\n@@ -582,6 +580,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         enum WhereToResolve<'a> {\n             DeriveHelpers,\n             MacroRules(LegacyScope<'a>),\n+            CrateRoot,\n             Module(Module<'a>),\n             MacroUsePrelude,\n             BuiltinMacros,\n@@ -595,17 +594,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         bitflags! {\n             struct Flags: u8 {\n-                const MACRO_RULES       = 1 << 0;\n-                const MODULE            = 1 << 1;\n-                const PRELUDE           = 1 << 2;\n-                const MISC_SUGGEST_SELF = 1 << 3;\n-                const MISC_FROM_PRELUDE = 1 << 4;\n+                const MACRO_RULES        = 1 << 0;\n+                const MODULE             = 1 << 1;\n+                const PRELUDE            = 1 << 2;\n+                const MISC_SUGGEST_CRATE = 1 << 3;\n+                const MISC_SUGGEST_SELF  = 1 << 4;\n+                const MISC_FROM_PRELUDE  = 1 << 5;\n             }\n         }\n \n         assert!(force || !record_used); // `record_used` implies `force`\n-        assert!(macro_kind.is_none() || !is_import); // `is_import` implies no macro kind\n-        ident = ident.modern();\n+        let mut ident = orig_ident.modern();\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n         if ident.is_path_segment_keyword() {\n@@ -626,10 +625,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<(&NameBinding, Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = if ns == MacroNS {\n-            WhereToResolve::DeriveHelpers\n-        } else {\n-            WhereToResolve::Module(parent_scope.module)\n+        let rust_2015 = orig_ident.span.rust_2015();\n+        let (ns, macro_kind, is_import, is_absolute_path) = match scope_set {\n+            ScopeSet::Import(ns) => (ns, None, true, false),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, false, true),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false, false),\n+            ScopeSet::Module => (TypeNS, None, false, false),\n+        };\n+        let mut where_to_resolve = match ns {\n+            _ if is_absolute_path || is_import && rust_2015 => WhereToResolve::CrateRoot,\n+            TypeNS | ValueNS => WhereToResolve::Module(parent_scope.module),\n+            MacroNS => WhereToResolve::DeriveHelpers,\n         };\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         let mut determinacy = Determinacy::Determined;\n@@ -667,6 +673,26 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n+                WhereToResolve::CrateRoot => {\n+                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_module = self.resolve_crate_root(root_ident);\n+                    let binding = self.resolve_ident_in_module_ext(\n+                        ModuleOrUniformRoot::Module(root_module),\n+                        orig_ident,\n+                        ns,\n+                        None,\n+                        record_used,\n+                        path_span,\n+                    );\n+                    match binding {\n+                        Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n+                        Err((Determinacy::Undetermined, Weak::No)) =>\n+                            return Err(Determinacy::determined(force)),\n+                        Err((Determinacy::Undetermined, Weak::Yes)) =>\n+                            Err(Determinacy::Undetermined),\n+                        Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                    }\n+                }\n                 WhereToResolve::Module(module) => {\n                     let orig_current_module = mem::replace(&mut self.current_module, module);\n                     let binding = self.resolve_ident_in_module_unadjusted_ext(\n@@ -681,7 +707,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.current_module = orig_current_module;\n                     match binding {\n                         Ok(binding) => {\n-                            let misc_flags = if module.is_normal() {\n+                            let misc_flags = if ptr::eq(module, self.graph_root) {\n+                                Flags::MISC_SUGGEST_CRATE\n+                            } else if module.is_normal() {\n                                 Flags::MISC_SUGGEST_SELF\n                             } else {\n                                 Flags::empty()\n@@ -696,7 +724,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n-                    if use_prelude || self.session.rust_2015() {\n+                    if use_prelude || rust_2015 {\n                         match self.macro_use_prelude.get(&ident.name).cloned() {\n                             Some(binding) =>\n                                 Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n@@ -725,7 +753,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n                 WhereToResolve::LegacyPluginHelpers => {\n-                    if (use_prelude || self.session.rust_2015()) &&\n+                    if (use_prelude || rust_2015) &&\n                        self.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == &**name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n@@ -737,7 +765,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n                 WhereToResolve::ExternPrelude => {\n-                    if use_prelude {\n+                    if use_prelude || is_absolute_path {\n                         match self.extern_prelude_get(ident, !record_used) {\n                             Some(binding) => Ok((binding, Flags::PRELUDE)),\n                             None => Err(Determinacy::determined(\n@@ -803,6 +831,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                             let ambiguity_error_kind = if is_import {\n                                 Some(AmbiguityKind::Import)\n+                            } else if is_absolute_path {\n+                                Some(AmbiguityKind::AbsolutePath)\n                             } else if innermost_def == builtin || def == builtin {\n                                 Some(AmbiguityKind::BuiltinAttr)\n                             } else if innermost_def == derive_helper || def == derive_helper {\n@@ -815,7 +845,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             } else if innermost_flags.contains(Flags::MACRO_RULES) &&\n                                       flags.contains(Flags::MODULE) &&\n                                       !self.disambiguate_legacy_vs_modern(innermost_binding,\n-                                                                          binding) {\n+                                                                          binding) ||\n+                                      flags.contains(Flags::MACRO_RULES) &&\n+                                      innermost_flags.contains(Flags::MODULE) &&\n+                                      !self.disambiguate_legacy_vs_modern(binding,\n+                                                                          innermost_binding) {\n                                 Some(AmbiguityKind::LegacyVsModern)\n                             } else if innermost_binding.is_glob_import() {\n                                 Some(AmbiguityKind::GlobVsOuter)\n@@ -826,7 +860,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 None\n                             };\n                             if let Some(kind) = ambiguity_error_kind {\n-                                let misc = |f: Flags| if f.contains(Flags::MISC_SUGGEST_SELF) {\n+                                let misc = |f: Flags| if f.contains(Flags::MISC_SUGGEST_CRATE) {\n+                                    AmbiguityErrorMisc::SuggestCrate\n+                                } else if f.contains(Flags::MISC_SUGGEST_SELF) {\n                                     AmbiguityErrorMisc::SuggestSelf\n                                 } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n                                     AmbiguityErrorMisc::FromPrelude\n@@ -835,7 +871,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 };\n                                 self.ambiguity_errors.push(AmbiguityError {\n                                     kind,\n-                                    ident,\n+                                    ident: orig_ident,\n                                     b1: innermost_binding,\n                                     b2: binding,\n                                     misc1: misc(innermost_flags),\n@@ -866,6 +902,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n                     LegacyScope::Uninitialized => unreachable!(),\n                 }\n+                WhereToResolve::CrateRoot if is_import => match ns {\n+                    TypeNS | ValueNS => WhereToResolve::Module(parent_scope.module),\n+                    MacroNS => WhereToResolve::DeriveHelpers,\n+                }\n+                WhereToResolve::CrateRoot if is_absolute_path => match ns {\n+                    TypeNS => {\n+                        ident.span.adjust(Mark::root());\n+                        WhereToResolve::ExternPrelude\n+                    }\n+                    ValueNS | MacroNS => break,\n+                }\n+                WhereToResolve::CrateRoot => unreachable!(),\n                 WhereToResolve::Module(module) => {\n                     match self.hygienic_lexical_parent(module, &mut ident.span) {\n                         Some(parent_module) => WhereToResolve::Module(parent_module),\n@@ -883,6 +931,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n                 WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n                 WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n+                WhereToResolve::ExternPrelude if is_absolute_path => break,\n                 WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n                 WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n                 WhereToResolve::StdLibPrelude => match ns {\n@@ -898,30 +947,43 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         // The first found solution was the only one, return it.\n         if let Some((binding, flags)) = innermost_result {\n-            if is_import && !self.session.features_untracked().uniform_paths {\n-                // We get to here only if there's no ambiguity, in ambiguous cases an error will\n-                // be reported anyway, so there's no reason to report an additional feature error.\n-                // The `binding` can actually be introduced by something other than `--extern`,\n-                // but its `Def` should coincide with a crate passed with `--extern`\n-                // (otherwise there would be ambiguity) and we can skip feature error in this case.\n-                if ns != TypeNS || !use_prelude ||\n-                   self.extern_prelude_get(ident, true).is_none() {\n-                    let msg = \"imports can only refer to extern crate names \\\n-                               passed with `--extern` on stable channel\";\n-                    let mut err = feature_err(&self.session.parse_sess, \"uniform_paths\",\n-                                              ident.span, GateIssue::Language, msg);\n-\n-                    let what = self.binding_description(binding, ident,\n-                                                        flags.contains(Flags::MISC_FROM_PRELUDE));\n-                    let note_msg = format!(\"this import refers to {what}\", what = what);\n-                    if binding.span.is_dummy() {\n-                        err.note(&note_msg);\n-                    } else {\n-                        err.span_note(binding.span, &note_msg);\n-                        err.span_label(binding.span, \"not an extern crate passed with `--extern`\");\n+            // We get to here only if there's no ambiguity, in ambiguous cases an error will\n+            // be reported anyway, so there's no reason to report an additional feature error.\n+            // The `binding` can actually be introduced by something other than `--extern`,\n+            // but its `Def` should coincide with a crate passed with `--extern`\n+            // (otherwise there would be ambiguity) and we can skip feature error in this case.\n+            'ok: {\n+                if !is_import || self.session.features_untracked().uniform_paths {\n+                    break 'ok;\n+                }\n+                if ns == TypeNS && use_prelude && self.extern_prelude_get(ident, true).is_some() {\n+                    break 'ok;\n+                }\n+                if rust_2015 {\n+                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_module = self.resolve_crate_root(root_ident);\n+                    if self.resolve_ident_in_module_ext(ModuleOrUniformRoot::Module(root_module),\n+                                                        orig_ident, ns, None, false, path_span)\n+                                                        .is_ok() {\n+                        break 'ok;\n                     }\n-                    err.emit();\n                 }\n+\n+                let msg = \"imports can only refer to extern crate names \\\n+                           passed with `--extern` on stable channel\";\n+                let mut err = feature_err(&self.session.parse_sess, \"uniform_paths\",\n+                                          ident.span, GateIssue::Language, msg);\n+\n+                let what = self.binding_description(binding, ident,\n+                                                    flags.contains(Flags::MISC_FROM_PRELUDE));\n+                let note_msg = format!(\"this import refers to {what}\", what = what);\n+                if binding.span.is_dummy() {\n+                    err.note(&note_msg);\n+                } else {\n+                    err.span_note(binding.span, &note_msg);\n+                    err.span_label(binding.span, \"not an extern crate passed with `--extern`\");\n+                }\n+                err.emit();\n             }\n \n             return Ok(binding);\n@@ -998,7 +1060,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let macro_resolutions =\n             mem::replace(&mut *module.single_segment_macro_resolutions.borrow_mut(), Vec::new());\n         for (ident, kind, parent_scope, initial_binding) in macro_resolutions {\n-            match self.early_resolve_ident_in_lexical_scope(ident, MacroNS, Some(kind), false,\n+            match self.early_resolve_ident_in_lexical_scope(ident, ScopeSet::Macro(kind),\n                                                             &parent_scope, true, true, ident.span) {\n                 Ok(binding) => {\n                     let initial_def = initial_binding.map(|initial_binding| {\n@@ -1024,7 +1086,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let builtin_attrs = mem::replace(&mut *module.builtin_attrs.borrow_mut(), Vec::new());\n         for (ident, parent_scope) in builtin_attrs {\n             let _ = self.early_resolve_ident_in_lexical_scope(\n-                ident, MacroNS, Some(MacroKind::Attr), false, &parent_scope, true, true, ident.span\n+                ident, ScopeSet::Macro(MacroKind::Attr), &parent_scope, true, true, ident.span\n             );\n         }\n     }"}, {"sha": "3bfa862f0dc7dc8a355c8914a2e2037ffa278270", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -11,7 +11,7 @@\n use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, Module, ModuleOrUniformRoot, PerNS, UniformRootKind, Weak};\n+use {CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, Weak};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use {Resolver, Segment};\n@@ -162,45 +162,51 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::UniformRoot(uniform_root_kind) => {\n+            ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n                 assert!(!restricted_shadowing);\n-                match uniform_root_kind {\n-                    UniformRootKind::ExternPrelude => {\n-                        return if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n-                            Ok(binding)\n-                        } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n-                            // Macro-expanded `extern crate` items can add names to extern prelude.\n-                            Err((Undetermined, Weak::No))\n-                        } else {\n-                            Err((Determined, Weak::No))\n-                        }\n-                    }\n-                    UniformRootKind::CurrentScope => {\n-                        let parent_scope =\n-                            parent_scope.expect(\"no parent scope for a single-segment import\");\n-\n-                        if ns == TypeNS {\n-                            if ident.name == keywords::Crate.name() ||\n-                               ident.name == keywords::DollarCrate.name() {\n-                                let module = self.resolve_crate_root(ident);\n-                                let binding = (module, ty::Visibility::Public,\n-                                               module.span, Mark::root())\n-                                               .to_name_binding(self.arenas);\n-                                return Ok(binding);\n-                            } else if ident.name == keywords::Super.name() ||\n-                                      ident.name == keywords::SelfValue.name() {\n-                                // FIXME: Implement these with renaming requirements so that e.g.\n-                                // `use super;` doesn't work, but `use super as name;` does.\n-                                // Fall through here to get an error from `early_resolve_...`.\n-                            }\n-                        }\n-\n-                        let binding = self.early_resolve_ident_in_lexical_scope(\n-                            ident, ns, None, true, parent_scope, record_used, record_used, path_span\n-                        );\n-                        return binding.map_err(|determinacy| (determinacy, Weak::No));\n+                let parent_scope = self.dummy_parent_scope();\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident, ScopeSet::AbsolutePath(ns), &parent_scope,\n+                    record_used, record_used, path_span,\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n+            }\n+            ModuleOrUniformRoot::ExternPrelude => {\n+                assert!(!restricted_shadowing);\n+                return if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n+                    Ok(binding)\n+                } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                    // Macro-expanded `extern crate` items can add names to extern prelude.\n+                    Err((Undetermined, Weak::No))\n+                } else {\n+                    Err((Determined, Weak::No))\n+                }\n+            }\n+            ModuleOrUniformRoot::CurrentScope => {\n+                assert!(!restricted_shadowing);\n+                let parent_scope =\n+                    parent_scope.expect(\"no parent scope for a single-segment import\");\n+\n+                if ns == TypeNS {\n+                    if ident.name == keywords::Crate.name() ||\n+                        ident.name == keywords::DollarCrate.name() {\n+                        let module = self.resolve_crate_root(ident);\n+                        let binding = (module, ty::Visibility::Public,\n+                                        module.span, Mark::root())\n+                                        .to_name_binding(self.arenas);\n+                        return Ok(binding);\n+                    } else if ident.name == keywords::Super.name() ||\n+                                ident.name == keywords::SelfValue.name() {\n+                        // FIXME: Implement these with renaming requirements so that e.g.\n+                        // `use super;` doesn't work, but `use super as name;` does.\n+                        // Fall through here to get an error from `early_resolve_...`.\n                     }\n                 }\n+\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident, ScopeSet::Import(ns), parent_scope, record_used, record_used, path_span\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n         };\n \n@@ -333,7 +339,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             }\n             let module = match glob_import.imported_module.get() {\n                 Some(ModuleOrUniformRoot::Module(module)) => module,\n-                Some(ModuleOrUniformRoot::UniformRoot(_)) => continue,\n+                Some(_) => continue,\n                 None => return Err((Undetermined, Weak::Yes)),\n             };\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n@@ -966,9 +972,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) =>\n-                        Some(module.resolutions.borrow()),\n-                    ModuleOrUniformRoot::UniformRoot(_) => None,\n+                    ModuleOrUniformRoot::Module(module) => Some(module.resolutions.borrow()),\n+                    _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n                 let names = resolutions.filter_map(|(&(ref i, _), resolution)| {\n@@ -1006,7 +1011,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                             format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n                         }\n                     }\n-                    ModuleOrUniformRoot::UniformRoot(_) => {\n+                    _ => {\n                         if !ident.is_path_segment_keyword() {\n                             format!(\"no `{}` external crate{}\", ident, lev_suggestion)\n                         } else {\n@@ -1107,9 +1112,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n         let module = match directive.imported_module.get().unwrap() {\n             ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::UniformRoot(_) => {\n-                self.session.span_err(directive.span,\n-                    \"cannot glob-import all possible crates\");\n+            _ => {\n+                self.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n                 return;\n             }\n         };"}, {"sha": "c82ebd6aa5128c32329a575830b25aa07b6e0543", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -43,7 +43,7 @@ use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use source_map::{self, SourceMap, Spanned, respan};\n-use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, edition::Edition};\n+use syntax_pos::{self, Span, MultiSpan, BytePos, FileName};\n use errors::{self, Applicability, DiagnosticBuilder, DiagnosticId};\n use parse::{self, SeqSep, classify, token};\n use parse::lexer::TokenAndSpan;\n@@ -1404,11 +1404,7 @@ impl<'a> Parser<'a> {\n                 // definition...\n \n                 // We don't allow argument names to be left off in edition 2018.\n-                if p.span.edition() >= Edition::Edition2018 {\n-                    p.parse_arg_general(true)\n-                } else {\n-                    p.parse_arg_general(false)\n-                }\n+                p.parse_arg_general(p.span.rust_2018())\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n \n@@ -1601,9 +1597,9 @@ impl<'a> Parser<'a> {\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n         } else if self.check_keyword(keywords::Dyn) &&\n-                  (self.span.edition() == Edition::Edition2018 ||\n+                  (self.span.rust_2018() ||\n                    self.look_ahead(1, |t| t.can_begin_bound() &&\n-                                         !can_continue_type_after_non_fn_ident(t))) {\n+                                          !can_continue_type_after_non_fn_ident(t))) {\n             self.bump(); // `dyn`\n             // Always parse bounds greedily for better error recovery.\n             let bounds = self.parse_generic_bounds()?;\n@@ -2084,8 +2080,9 @@ impl<'a> Parser<'a> {\n \n         let lo = self.meta_var_span.unwrap_or(self.span);\n         let mut segments = Vec::new();\n+        let mod_sep_ctxt = self.span.ctxt();\n         if self.eat(&token::ModSep) {\n-            segments.push(PathSegment::crate_root(lo.shrink_to_lo()));\n+            segments.push(PathSegment::crate_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n         self.parse_path_segments(&mut segments, style, enable_warning)?;\n \n@@ -2423,8 +2420,7 @@ impl<'a> Parser<'a> {\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n-                if self.span.edition() >= Edition::Edition2018 &&\n-                    self.check_keyword(keywords::Async)\n+                if self.span.rust_2018() && self.check_keyword(keywords::Async)\n                 {\n                     if self.is_async_block() { // check for `async {` and `async move {`\n                         return self.parse_async_block(attrs);\n@@ -3440,7 +3436,7 @@ impl<'a> Parser<'a> {\n         } else {\n             Movability::Movable\n         };\n-        let asyncness = if self.span.edition() >= Edition::Edition2018 {\n+        let asyncness = if self.span.rust_2018() {\n             self.parse_asyncness()\n         } else {\n             IsAsync::NotAsync\n@@ -4562,9 +4558,7 @@ impl<'a> Parser<'a> {\n     fn is_try_block(&mut self) -> bool {\n         self.token.is_keyword(keywords::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-\n-        self.span.edition() >= Edition::Edition2018 &&\n-\n+        self.span.rust_2018() &&\n         // prevent `while try {} {}`, `if try {} {} else {}`, etc.\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -7648,8 +7642,11 @@ impl<'a> Parser<'a> {\n                       self.check(&token::BinOp(token::Star)) ||\n                       self.is_import_coupler() {\n             // `use *;` or `use ::*;` or `use {...};` or `use ::{...};`\n+            let mod_sep_ctxt = self.span.ctxt();\n             if self.eat(&token::ModSep) {\n-                prefix.segments.push(PathSegment::crate_root(lo.shrink_to_lo()));\n+                prefix.segments.push(\n+                    PathSegment::crate_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n+                );\n             }\n \n             if self.eat(&token::BinOp(token::Star)) {"}, {"sha": "65f6d27239b83c53c4094fbd6dafecb911f7b155", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -325,6 +325,16 @@ impl Span {\n                                                     |einfo| einfo.edition)\n     }\n \n+    #[inline]\n+    pub fn rust_2015(&self) -> bool {\n+        self.edition() == edition::Edition::Edition2015\n+    }\n+\n+    #[inline]\n+    pub fn rust_2018(&self) -> bool {\n+        self.edition() >= edition::Edition::Edition2018\n+    }\n+\n     /// Return the source callee.\n     ///\n     /// Returns `None` if the supplied span has no expansion trace,"}, {"sha": "e333a4f2176f55b0027dc1987b68fdc5dae5b7ca", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -12,7 +12,6 @@\n //! allows bidirectional lookup; i.e. given a value, one can easily find the\n //! type, and vice versa.\n \n-use edition::Edition;\n use hygiene::SyntaxContext;\n use {Span, DUMMY_SP, GLOBALS};\n \n@@ -444,7 +443,7 @@ impl Ident {\n     pub fn is_unused_keyword(self) -> bool {\n         // Note: `span.edition()` is relatively expensive, don't call it unless necessary.\n         self.name >= keywords::Abstract.name() && self.name <= keywords::Yield.name() ||\n-        self.name.is_unused_keyword_2018() && self.span.edition() == Edition::Edition2018\n+        self.name.is_unused_keyword_2018() && self.span.rust_2018()\n     }\n \n     /// Returns `true` if the token is either a special identifier or a keyword."}, {"sha": "d288d7295120cfc11aea7ef3f51642e22098b3dd", "filename": "src/test/ui-fulldeps/custom-derive/helper-attr-blocked-by-import-ambig.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -14,7 +14,7 @@ note: `helper` could also refer to the attribute macro imported here\n    |\n LL | use plugin::helper;\n    |     ^^^^^^^^^^^^^^\n-   = help: use `self::helper` to refer to this attribute macro unambiguously\n+   = help: use `crate::helper` to refer to this attribute macro unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "79dc922b9db2cc8e95ea9519eb214f246489c9dc", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -16,7 +16,7 @@ note: `repr` could also refer to the attribute macro imported here\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-   = help: use `self::repr` to refer to this attribute macro unambiguously\n+   = help: use `crate::repr` to refer to this attribute macro unambiguously\n \n error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:11:19\n@@ -30,7 +30,7 @@ note: `repr` could also refer to the attribute macro imported here\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-   = help: use `self::repr` to refer to this attribute macro unambiguously\n+   = help: use `crate::repr` to refer to this attribute macro unambiguously\n \n error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:20:34\n@@ -44,7 +44,7 @@ note: `repr` could also refer to the attribute macro imported here\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-   = help: use `self::repr` to refer to this attribute macro unambiguously\n+   = help: use `crate::repr` to refer to this attribute macro unambiguously\n \n error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:22:11\n@@ -58,7 +58,7 @@ note: `repr` could also refer to the attribute macro imported here\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-   = help: use `self::repr` to refer to this attribute macro unambiguously\n+   = help: use `crate::repr` to refer to this attribute macro unambiguously\n \n error[E0659]: `feature` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:3:4\n@@ -72,7 +72,7 @@ note: `feature` could also refer to the attribute macro imported here\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-   = help: use `self::feature` to refer to this attribute macro unambiguously\n+   = help: use `crate::feature` to refer to this attribute macro unambiguously\n \n error: aborting due to 6 previous errors\n "}, {"sha": "5bb818f7d23baedb45e8143997a0949ab5f589db", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/edition-imports-2015.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fedition-imports-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fedition-imports-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fedition-imports-2015.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,19 @@\n+// edition:2015\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Derive2015)]\n+pub fn derive_2015(_: TokenStream) -> TokenStream {\n+    \"\n+    use import::Path;\n+\n+    fn check_absolute() {\n+        let x = ::absolute::Path;\n+    }\n+    \".parse().unwrap()\n+}"}, {"sha": "cc50fefc46453d393defc7bfb7ba3dbc691deed7", "filename": "src/test/ui-fulldeps/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -14,7 +14,7 @@ note: `my_attr` could also refer to the attribute macro imported here\n    |\n LL | use derive_helper_shadowing::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: use `self::my_attr` to refer to this attribute macro unambiguously\n+   = help: use `crate::my_attr` to refer to this attribute macro unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "f8d6bc5e0785dd98e2472683c7dc0a9fbaa98d65", "filename": "src/test/ui-fulldeps/proc-macro/edition-imports-2018.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fedition-imports-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fedition-imports-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fedition-imports-2018.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,24 @@\n+// compile-pass\n+// edition:2018\n+// aux-build:edition-imports-2015.rs\n+\n+#[macro_use]\n+extern crate edition_imports_2015;\n+\n+mod import {\n+    pub struct Path;\n+}\n+mod absolute {\n+    pub struct Path;\n+}\n+\n+mod check {\n+    #[derive(Derive2015)] // OK\n+    struct S;\n+\n+    fn check() {\n+        Path;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d596f97355f4c2dc68efab5aefb36d56d2399b55", "filename": "src/test/ui/editions/auxiliary/absolute.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fabsolute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fabsolute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fabsolute.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1 @@\n+pub struct Path;"}, {"sha": "c72331ca2e119e62c39f3f91b9fcd33363742837", "filename": "src/test/ui/editions/auxiliary/edition-imports-2015.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,31 @@\n+// edition:2015\n+\n+#[macro_export]\n+macro_rules! gen_imports { () => {\n+    use import::Path;\n+    use std::collections::LinkedList;\n+\n+    fn check_absolute() {\n+        ::absolute::Path;\n+        ::std::collections::LinkedList::<u8>::new();\n+    }\n+}}\n+\n+#[macro_export]\n+macro_rules! gen_glob { () => {\n+    use *;\n+}}\n+\n+#[macro_export]\n+macro_rules! gen_gated { () => {\n+    fn check_gated() {\n+        enum E { A }\n+        use E::*;\n+    }\n+}}\n+\n+#[macro_export]\n+macro_rules! gen_ambiguous { () => {\n+    use Ambiguous;\n+    type A = ::edition_imports_2015::Path;\n+}}"}, {"sha": "b08dc499a0dddf16b15646b9d830b28bac86d470", "filename": "src/test/ui/editions/auxiliary/edition-imports-2018.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2018.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+\n+#[macro_export]\n+macro_rules! gen_imports { () => {\n+    use import::Path;\n+    use std::collections::LinkedList;\n+\n+    fn check_absolute() {\n+        ::absolute::Path;\n+        ::std::collections::LinkedList::<u8>::new();\n+    }\n+}}\n+\n+#[macro_export]\n+macro_rules! gen_glob { () => {\n+    use *;\n+}}"}, {"sha": "b89ca28e279db223c19a7b6a516c4e13f7aa4d8c", "filename": "src/test/ui/editions/edition-imports-2015.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,28 @@\n+// edition:2015\n+// compile-flags:--extern absolute\n+// aux-build:edition-imports-2018.rs\n+// aux-build:absolute.rs\n+\n+#![feature(uniform_paths)]\n+\n+#[macro_use]\n+extern crate edition_imports_2018;\n+\n+mod check {\n+    mod import {\n+        pub struct Path;\n+    }\n+\n+    gen_imports!(); // OK\n+\n+    fn check() {\n+        Path;\n+        LinkedList::<u8>::new();\n+    }\n+}\n+\n+mod check_glob {\n+    gen_glob!(); //~ ERROR cannot glob-import all possible crates\n+}\n+\n+fn main() {}"}, {"sha": "fb6b2e64ef5b8ddc27e50a1d561453eba564bea9", "filename": "src/test/ui/editions/edition-imports-2015.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,10 @@\n+error: cannot glob-import all possible crates\n+  --> $DIR/edition-imports-2015.rs:25:5\n+   |\n+LL |     gen_glob!(); //~ ERROR cannot glob-import all possible crates\n+   |     ^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "dcdbf0d050be116f9a8ad1574110d83bc4c5974b", "filename": "src/test/ui/editions/edition-imports-2018.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,27 @@\n+// edition:2018\n+// aux-build:edition-imports-2015.rs\n+\n+#[macro_use]\n+extern crate edition_imports_2015;\n+\n+mod import {\n+    pub struct Path;\n+}\n+mod absolute {\n+    pub struct Path;\n+}\n+\n+mod check {\n+    gen_imports!(); // OK\n+\n+    fn check() {\n+        Path;\n+        LinkedList::<u8>::new();\n+    }\n+}\n+\n+mod check_glob {\n+    gen_glob!(); //~ ERROR cannot glob-import all possible crates\n+}\n+\n+fn main() {}"}, {"sha": "944f42ee0451ba6e2f5fe9170266a68e0b865bad", "filename": "src/test/ui/editions/edition-imports-2018.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,10 @@\n+error: cannot glob-import all possible crates\n+  --> $DIR/edition-imports-2018.rs:24:5\n+   |\n+LL |     gen_glob!(); //~ ERROR cannot glob-import all possible crates\n+   |     ^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "53ec3867f0110966c1fbdd82e70782489383ed7d", "filename": "src/test/ui/editions/edition-imports-virtual-2015-ambiguity.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,20 @@\n+// edition:2018\n+// compile-flags:--extern edition_imports_2015\n+// aux-build:edition-imports-2015.rs\n+\n+mod edition_imports_2015 {\n+    pub struct Path;\n+}\n+\n+pub struct Ambiguous {}\n+\n+mod check {\n+    pub struct Ambiguous {}\n+\n+    fn check() {\n+        edition_imports_2015::gen_ambiguous!(); //~ ERROR `Ambiguous` is ambiguous\n+                                                //~| ERROR `edition_imports_2015` is ambiguous\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ac2bf21c5c0ba95ee157ebd0ed9fc939ee9d3451", "filename": "src/test/ui/editions/edition-imports-virtual-2015-ambiguity.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-ambiguity.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,40 @@\n+error[E0659]: `Ambiguous` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/edition-imports-virtual-2015-ambiguity.rs:15:9\n+   |\n+LL |         edition_imports_2015::gen_ambiguous!(); //~ ERROR `Ambiguous` is ambiguous\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ambiguous name\n+   |\n+note: `Ambiguous` could refer to the struct defined here\n+  --> $DIR/edition-imports-virtual-2015-ambiguity.rs:9:1\n+   |\n+LL | pub struct Ambiguous {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `crate::Ambiguous` to refer to this struct unambiguously\n+note: `Ambiguous` could also refer to the struct defined here\n+  --> $DIR/edition-imports-virtual-2015-ambiguity.rs:12:5\n+   |\n+LL |     pub struct Ambiguous {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::Ambiguous` to refer to this struct unambiguously\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error[E0659]: `edition_imports_2015` is ambiguous (name in the crate root vs extern crate during absolute path resolution)\n+  --> $DIR/edition-imports-virtual-2015-ambiguity.rs:15:9\n+   |\n+LL |         edition_imports_2015::gen_ambiguous!(); //~ ERROR `Ambiguous` is ambiguous\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ambiguous name\n+   |\n+   = note: `edition_imports_2015` could refer to an extern crate passed with `--extern`\n+note: `edition_imports_2015` could also refer to the module defined here\n+  --> $DIR/edition-imports-virtual-2015-ambiguity.rs:5:1\n+   |\n+LL | / mod edition_imports_2015 {\n+LL | |     pub struct Path;\n+LL | | }\n+   | |_^\n+   = help: use `crate::edition_imports_2015` to refer to this module unambiguously\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "a1bf4f5eb51dc58e1edf69f8bab56653ea5b2f3c", "filename": "src/test/ui/editions/edition-imports-virtual-2015-gated.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+// aux-build:edition-imports-2015.rs\n+// error-pattern: imports can only refer to extern crate names passed with `--extern`\n+\n+#[macro_use]\n+extern crate edition_imports_2015;\n+\n+mod check {\n+    gen_gated!();\n+}\n+\n+fn main() {}"}, {"sha": "7c1837e3f56e3e90275e6b6084e5481b63fb68fb", "filename": "src/test/ui/editions/edition-imports-virtual-2015-gated.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -0,0 +1,22 @@\n+error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n+  --> <::edition_imports_2015::gen_gated macros>:1:50\n+   |\n+LL | (  ) => { fn check_gated (  ) { enum E { A } use E :: * ; } }\n+   |                                                  ^\n+   | \n+  ::: $DIR/edition-imports-virtual-2015-gated.rs:9:5\n+   |\n+LL |     gen_gated!();\n+   |     ------------- not an extern crate passed with `--extern`\n+   |\n+   = help: add #![feature(uniform_paths)] to the crate attributes to enable\n+note: this import refers to the enum defined here\n+  --> $DIR/edition-imports-virtual-2015-gated.rs:9:5\n+   |\n+LL |     gen_gated!();\n+   |     ^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "37633c7a4415f0579542640f9629b71c1fd6c199", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -43,6 +43,7 @@ mod inner2 {\n \n fn main() {\n     panic!(); //~ ERROR `panic` is ambiguous\n+              //~| ERROR `panic` is ambiguous\n }\n \n mod inner3 {"}, {"sha": "1978648e206f123c5ef08f04145ded69f1f0fc7d", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.stderr", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -22,7 +22,7 @@ LL | use inner1::*;\n    = help: consider adding an explicit import of `exported` to disambiguate\n \n error[E0659]: `include` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n-  --> $DIR/local-modularized-tricky-fail-1.rs:56:1\n+  --> $DIR/local-modularized-tricky-fail-1.rs:57:1\n    |\n LL | include!(); //~ ERROR `include` is ambiguous\n    | ^^^^^^^ ambiguous name\n@@ -38,7 +38,7 @@ LL | |     }\n ...\n LL |       define_include!();\n    |       ------------------ in this macro invocation\n-   = help: use `self::include` to refer to this macro unambiguously\n+   = help: use `crate::include` to refer to this macro unambiguously\n \n error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/local-modularized-tricky-fail-1.rs:45:5\n@@ -57,13 +57,13 @@ LL | |     }\n ...\n LL |       define_panic!();\n    |       ---------------- in this macro invocation\n-   = help: use `self::panic` to refer to this macro unambiguously\n+   = help: use `crate::panic` to refer to this macro unambiguously\n \n error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n-  --> <::std::macros::panic macros>:1:13\n+  --> $DIR/local-modularized-tricky-fail-1.rs:45:5\n    |\n-LL | (  ) => ( { panic ! ( \"explicit panic\" ) } ) ; ( $ msg : expr ) => (\n-   |             ^^^^^ ambiguous name\n+LL |     panic!(); //~ ERROR `panic` is ambiguous\n+   |     ^^^^^^^^^ ambiguous name\n    |\n    = note: `panic` could refer to a macro from prelude\n note: `panic` could also refer to the macro defined here\n@@ -76,7 +76,8 @@ LL | |     }\n ...\n LL |       define_panic!();\n    |       ---------------- in this macro invocation\n-   = help: use `self::panic` to refer to this macro unambiguously\n+   = help: use `crate::panic` to refer to this macro unambiguously\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "3f481b0cfb0df95e92e3e9099c51acf6f0aca186", "filename": "src/test/ui/imports/macro-paths.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -34,7 +34,7 @@ LL | / pub mod baz {\n LL | |     pub use two_macros::m;\n LL | | }\n    | |_^\n-   = help: use `self::baz` to refer to this module unambiguously\n+   = help: use `crate::baz` to refer to this module unambiguously\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9d61799713b043c99ffbc68b50b5fd0cd63c1f0a", "filename": "src/test/ui/macros/restricted-shadowing-legacy.stderr", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -3,6 +3,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n@@ -26,6 +29,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n@@ -49,6 +55,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n@@ -72,6 +81,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n@@ -95,6 +107,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n@@ -118,6 +133,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n@@ -141,6 +159,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n@@ -164,6 +185,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9"}, {"sha": "398a7660d3093b2fd912d064e5ab4be1620159fa", "filename": "src/test/ui/macros/restricted-shadowing-modern.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -3,6 +3,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |                 m!(); //~ ERROR `m` is ambiguous\n    |                 ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n@@ -26,6 +29,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n    |                                 ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n@@ -49,6 +55,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n@@ -72,6 +81,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n@@ -95,6 +107,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |                 m!(); //~ ERROR `m` is ambiguous\n    |                 ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n@@ -118,6 +133,9 @@ error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name\n    |\n LL |             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n    |                                 ^ ambiguous name\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n    |\n note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9"}, {"sha": "4819711115c27a76a5f25123447bd20bf04cb70b", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros-nested.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// edition:2018\n-\n-// This test is similar to `ambiguity-macros.rs`, but nested in a module.\n-\n-mod foo {\n-    pub use std::io;\n-    //~^ ERROR `std` is ambiguous\n-\n-    macro_rules! m {\n-        () => {\n-            mod std {\n-                pub struct io;\n-            }\n-        }\n-    }\n-    m!();\n-}\n-\n-fn main() {}"}, {"sha": "204e0a7e1411ed4c8437a4c66917e0c6a6913b93", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros-nested.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,23 +0,0 @@\n-error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/ambiguity-macros-nested.rs:16:13\n-   |\n-LL |     pub use std::io;\n-   |             ^^^ ambiguous name\n-   |\n-   = note: `std` could refer to a built-in extern crate\n-   = help: use `::std` to refer to this extern crate unambiguously\n-note: `std` could also refer to the module defined here\n-  --> $DIR/ambiguity-macros-nested.rs:21:13\n-   |\n-LL | /             mod std {\n-LL | |                 pub struct io;\n-LL | |             }\n-   | |_____________^\n-...\n-LL |       m!();\n-   |       ----- in this macro invocation\n-   = help: use `self::std` to refer to this module unambiguously\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0659`."}, {"sha": "148320de556d30d4633d90afacbccedaf4da14ea", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// edition:2018\n-\n-// This test is similar to `ambiguity.rs`, but with macros defining local items.\n-\n-use std::io;\n-//~^ ERROR `std` is ambiguous\n-\n-macro_rules! m {\n-    () => {\n-        mod std {\n-            pub struct io;\n-        }\n-    }\n-}\n-m!();\n-\n-fn main() {}"}, {"sha": "ac8d3b9d0cbe4d0dc347f35a2c901d89e375f29b", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,23 +0,0 @@\n-error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/ambiguity-macros.rs:15:5\n-   |\n-LL | use std::io;\n-   |     ^^^ ambiguous name\n-   |\n-   = note: `std` could refer to a built-in extern crate\n-   = help: use `::std` to refer to this extern crate unambiguously\n-note: `std` could also refer to the module defined here\n-  --> $DIR/ambiguity-macros.rs:20:9\n-   |\n-LL | /         mod std {\n-LL | |             pub struct io;\n-LL | |         }\n-   | |_________^\n-...\n-LL |   m!();\n-   |   ----- in this macro invocation\n-   = help: use `self::std` to refer to this module unambiguously\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0659`."}, {"sha": "2791d4580daf1a476deeff60b98c9cbbe4ab5faf", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-nested.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// edition:2018\n-\n-// This test is similar to `ambiguity.rs`, but nested in a module.\n-\n-mod foo {\n-    pub use std::io;\n-    //~^ ERROR `std` is ambiguous\n-\n-    mod std {\n-        pub struct io;\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "7bcfc563d39fc288da54189a482753efc48e984f", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-nested.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,20 +0,0 @@\n-error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/ambiguity-nested.rs:16:13\n-   |\n-LL |     pub use std::io;\n-   |             ^^^ ambiguous name\n-   |\n-   = note: `std` could refer to a built-in extern crate\n-   = help: use `::std` to refer to this extern crate unambiguously\n-note: `std` could also refer to the module defined here\n-  --> $DIR/ambiguity-nested.rs:19:5\n-   |\n-LL | /     mod std {\n-LL | |         pub struct io;\n-LL | |     }\n-   | |_____^\n-   = help: use `self::std` to refer to this module unambiguously\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0659`."}, {"sha": "2bfbb6b287153ded300d89545cab2ff528019c5e", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// edition:2018\n-\n-use std::io;\n-//~^ ERROR `std` is ambiguous\n-\n-mod std {\n-    pub struct io;\n-}\n-\n-fn main() {}"}, {"sha": "beeb74654e5b5bc7194dc9c2fba8a68703f7834c", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,20 +0,0 @@\n-error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/ambiguity.rs:13:5\n-   |\n-LL | use std::io;\n-   |     ^^^ ambiguous name\n-   |\n-   = note: `std` could refer to a built-in extern crate\n-   = help: use `::std` to refer to this extern crate unambiguously\n-note: `std` could also refer to the module defined here\n-  --> $DIR/ambiguity.rs:16:1\n-   |\n-LL | / mod std {\n-LL | |     pub struct io;\n-LL | | }\n-   | |_^\n-   = help: use `self::std` to refer to this module unambiguously\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0659`."}, {"sha": "2853b4b3a5b3f6c9dc4c242df7efe5ab3c95b389", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/block-scoped-shadow.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// edition:2018\n-\n-struct std;\n-\n-fn main() {\n-    fn std() {}\n-    enum std {}\n-    use std as foo;\n-    //~^ ERROR `std` is ambiguous\n-    //~| ERROR `std` is ambiguous\n-}"}, {"sha": "5d539e2d59f1549ca3ba2498cba8236c33662059", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/block-scoped-shadow.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,39 +0,0 @@\n-error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/block-scoped-shadow.rs:18:9\n-   |\n-LL |     use std as foo;\n-   |         ^^^ ambiguous name\n-   |\n-note: `std` could refer to the enum defined here\n-  --> $DIR/block-scoped-shadow.rs:17:5\n-   |\n-LL |     enum std {}\n-   |     ^^^^^^^^^^^\n-note: `std` could also refer to the struct defined here\n-  --> $DIR/block-scoped-shadow.rs:13:1\n-   |\n-LL | struct std;\n-   | ^^^^^^^^^^^\n-   = help: use `self::std` to refer to this struct unambiguously\n-\n-error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/block-scoped-shadow.rs:18:9\n-   |\n-LL |     use std as foo;\n-   |         ^^^ ambiguous name\n-   |\n-note: `std` could refer to the function defined here\n-  --> $DIR/block-scoped-shadow.rs:16:5\n-   |\n-LL |     fn std() {}\n-   |     ^^^^^^^^^^^\n-note: `std` could also refer to the unit struct defined here\n-  --> $DIR/block-scoped-shadow.rs:13:1\n-   |\n-LL | struct std;\n-   | ^^^^^^^^^^^\n-   = help: use `self::std` to refer to this unit struct unambiguously\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0659`."}, {"sha": "ef2a1e3c70c6f873153f220db5a07d7575df1493", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/issue-54253.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.rs?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// edition:2018\n-\n-// Dummy import that previously introduced uniform path canaries.\n-use std;\n-\n-// fn version() -> &'static str {\"\"}\n-\n-mod foo {\n-    // Error wasn't reported, despite `version` being commented out above.\n-    use crate::version; //~ ERROR unresolved import `crate::version`\n-\n-    fn bar() {\n-        version();\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "6dcc451c60a6125c45150ba350febf7ca78fd3d2", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/issue-54253.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.stderr?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,9 +0,0 @@\n-error[E0432]: unresolved import `crate::version`\n-  --> $DIR/issue-54253.rs:20:9\n-   |\n-LL |     use crate::version; //~ ERROR unresolved import `crate::version`\n-   |         ^^^^^^^^^^^^^^ no `version` in the root\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0432`."}, {"sha": "05048cfd451050e39382c4bf39b22df15476c412", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/redundant.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fredundant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d937c49b79dcfb99895470c1fd63cc6f9343a3/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fredundant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fredundant.rs?ref=75d937c49b79dcfb99895470c1fd63cc6f9343a3", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// run-pass\n-// edition:2018\n-\n-use std;\n-use std::io;\n-\n-mod foo {\n-    pub use std as my_std;\n-}\n-\n-mod bar {\n-    pub use std::{self};\n-}\n-\n-fn main() {\n-    io::stdout();\n-    self::std::io::stdout();\n-    foo::my_std::io::stdout();\n-    bar::std::io::stdout();\n-}"}, {"sha": "a9e6da8f211b31d4ea5b6d080d5ea6e6132d5e4e", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -16,7 +16,7 @@ LL | |         }\n ...\n LL |   m!();\n    |   ----- in this macro invocation\n-   = help: use `self::std` to refer to this module unambiguously\n+   = help: use `crate::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "b1feb82fba90d83f0f8f2be97db14455b69e2f7b", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -13,7 +13,7 @@ LL | / mod std {\n LL | |     pub struct io;\n LL | | }\n    | |_^\n-   = help: use `self::std` to refer to this module unambiguously\n+   = help: use `crate::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "0088296b1a4717217c8bfcca034ae2b978d62a30", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow-nested.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -16,7 +16,7 @@ LL | / mod sub {\n LL | |     pub fn bar() {}\n LL | | }\n    | |_^\n-   = help: use `self::sub` to refer to this module unambiguously\n+   = help: use `crate::sub` to refer to this module unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "213f723385b1c082455ca512d0371c978ea65a78", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45205f2ac18e926ec61f2672d16ec3b955de5652/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr?ref=45205f2ac18e926ec61f2672d16ec3b955de5652", "patch": "@@ -14,7 +14,7 @@ note: `Foo` could also refer to the enum defined here\n    |\n LL | enum Foo {}\n    | ^^^^^^^^^^^\n-   = help: use `self::Foo` to refer to this enum unambiguously\n+   = help: use `crate::Foo` to refer to this enum unambiguously\n \n error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:26:9\n@@ -32,7 +32,7 @@ note: `std` could also refer to the struct defined here\n    |\n LL | struct std;\n    | ^^^^^^^^^^^\n-   = help: use `self::std` to refer to this struct unambiguously\n+   = help: use `crate::std` to refer to this struct unambiguously\n \n error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:26:9\n@@ -50,7 +50,7 @@ note: `std` could also refer to the unit struct defined here\n    |\n LL | struct std;\n    | ^^^^^^^^^^^\n-   = help: use `self::std` to refer to this unit struct unambiguously\n+   = help: use `crate::std` to refer to this unit struct unambiguously\n \n error: aborting due to 3 previous errors\n "}]}