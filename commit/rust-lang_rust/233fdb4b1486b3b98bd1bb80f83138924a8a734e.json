{"sha": "233fdb4b1486b3b98bd1bb80f83138924a8a734e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzM2ZkYjRiMTQ4NmIzYjk4YmQxYmI4MGY4MzEzODkyNGE4YTczNGU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-10-11T23:33:08Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-10-17T00:33:03Z"}, "message": "Some new tests I added.", "tree": {"sha": "aaa3b053510d3375041349cc7e384ccaaa3887d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaa3b053510d3375041349cc7e384ccaaa3887d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/233fdb4b1486b3b98bd1bb80f83138924a8a734e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/233fdb4b1486b3b98bd1bb80f83138924a8a734e", "html_url": "https://github.com/rust-lang/rust/commit/233fdb4b1486b3b98bd1bb80f83138924a8a734e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/233fdb4b1486b3b98bd1bb80f83138924a8a734e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b748434afe19c8ec8091413e843df9b3679da3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b748434afe19c8ec8091413e843df9b3679da3e", "html_url": "https://github.com/rust-lang/rust/commit/5b748434afe19c8ec8091413e843df9b3679da3e"}], "stats": {"total": 1308, "additions": 1308, "deletions": 0}, "files": [{"sha": "d72cc20971b0e3c4a32b381bfa548a2f7e566e1f", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-marks-mut-as-used.ast.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.ast.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,39 @@\n+error[E0381]: use of possibly uninitialized variable: `t.0`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:25:31\n+   |\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                               ^^^ use of possibly uninitialized `t.0`\n+\n+error[E0381]: use of possibly uninitialized variable: `t.1`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:25:36\n+   |\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                                    ^^^ use of possibly uninitialized `t.1`\n+\n+error[E0381]: use of possibly uninitialized variable: `u.0`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:35:31\n+   |\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                               ^^^ use of possibly uninitialized `u.0`\n+\n+error[E0381]: use of possibly uninitialized variable: `u.1`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:35:36\n+   |\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                                    ^^^ use of possibly uninitialized `u.1`\n+\n+error[E0381]: use of possibly uninitialized variable: `v.x`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:45:31\n+   |\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                               ^^^ use of possibly uninitialized `v.x`\n+\n+error[E0381]: use of possibly uninitialized variable: `v.y`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:45:36\n+   |\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                                    ^^^ use of possibly uninitialized `v.y`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "ebc6c7fca62b9a387547b72c04de429d6a5be98f", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-marks-mut-as-used.nll.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.nll.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,21 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:22:9\n+   |\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `u`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:32:9\n+   |\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `u`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `v`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:42:9\n+   |\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `v`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "4358e8e440237a9a63daa0facce066362aff42f3", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-marks-mut-as-used.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.rs?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,49 @@\n+// revisions: ast nll\n+\n+// Since we are testing nll migration explicitly as a separate\n+// revision, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[ast]compile-flags: -Z borrowck=ast\n+//[nll]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+#![warn(unused)]\n+#[derive(Debug)]\n+struct S(i32);\n+\n+type Tuple = (S, i32);\n+struct Tpair(S, i32);\n+struct Spair { x: S, y: i32 }\n+\n+fn main() {\n+    {\n+        let mut t: Tuple;\n+        t.0 = S(1);\n+        //[nll]~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+        t.1 = 2;\n+        println!(\"{:?} {:?}\", t.0, t.1);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `t.0` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `t.1` [E0381]\n+    }\n+\n+    {\n+        let mut u: Tpair;\n+        u.0 = S(1);\n+        //[nll]~^ ERROR assign to part of possibly uninitialized variable: `u` [E0381]\n+        u.1 = 2;\n+        println!(\"{:?} {:?}\", u.0, u.1);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `u.0` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `u.1` [E0381]\n+    }\n+\n+    {\n+        let mut v: Spair;\n+        v.x = S(1);\n+        //[nll]~^ ERROR assign to part of possibly uninitialized variable: `v` [E0381]\n+        v.y = 2;\n+        println!(\"{:?} {:?}\", v.x, v.y);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `v.x` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `v.y` [E0381]\n+    }\n+}"}, {"sha": "e3b5341d2bcff0aa293f3ea8bdc29277ed9c6871", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out-with-mut.ast.stderr", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.ast.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,69 @@\n+error[E0382]: use of moved value: `t.0`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:25:31\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `t.1`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:25:36\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `u.0`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:33:31\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `u.1`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:33:36\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `v.x`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:41:31\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `v.y`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:41:36\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "001ed59059cc89893ca10a4749d32df961408baa", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,33 @@\n+error[E0382]: assign to part of moved value: `t`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:23:9\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `u`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:31:9\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `v`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:39:9\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "b6339c4a3c754a6b18d7bdbc1eec7d2fa4ca8c84", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out-with-mut.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.rs?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,43 @@\n+// revisions: ast nll\n+\n+// Since we are testing nll migration explicitly as a separate\n+// revision, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[ast]compile-flags: -Z borrowck=ast\n+//[nll]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+#![warn(unused)]\n+#[derive(Debug)]\n+struct S(i32);\n+\n+type Tuple = (S, i32);\n+struct Tpair(S, i32);\n+struct Spair { x: S, y: i32 }\n+\n+fn main() {\n+    {\n+        let mut t: Tuple = (S(0), 0);\n+        drop(t);\n+        t.0 = S(1);\n+        t.1 = 2;\n+        println!(\"{:?} {:?}\", t.0, t.1);\n+    }\n+\n+    {\n+        let mut u: Tpair = Tpair(S(0), 0);\n+        drop(u);\n+        u.0 = S(1);\n+        u.1 = 2;\n+        println!(\"{:?} {:?}\", u.0, u.1);\n+    }\n+\n+    {\n+        let mut v: Spair = Spair { x: S(0), y: 0 };\n+        drop(v);\n+        v.x = S(1);\n+        v.y = 2;\n+        println!(\"{:?} {:?}\", v.x, v.y);\n+    }\n+}"}, {"sha": "565272af39049fdc9a8895f9ecd0d1753db0da3c", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out.ast.stderr", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.ast.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,124 @@\n+error[E0594]: cannot assign to field `t.0` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:23:9\n+   |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - help: make this binding mutable: `mut t`\n+LL |         drop(t);\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `t.1` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:27:9\n+   |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - help: make this binding mutable: `mut t`\n+...\n+LL |         t.1 = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `u.0` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:38:9\n+   |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - help: make this binding mutable: `mut u`\n+LL |         drop(u);\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `u.1` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:42:9\n+   |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - help: make this binding mutable: `mut u`\n+...\n+LL |         u.1 = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `v.x` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:53:9\n+   |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - help: make this binding mutable: `mut v`\n+LL |         drop(v);\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `v.y` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:57:9\n+   |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - help: make this binding mutable: `mut v`\n+...\n+LL |         v.y = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0382]: use of moved value: `t.0`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:30:31\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `t.1`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:30:36\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `u.0`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:45:31\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `u.1`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:45:36\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `v.x`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:60:31\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `v.y`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:60:36\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors occurred: E0382, E0594.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "d35d0058027d42ed81a0bd01ebc6a86d41032e12", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out.nll.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,88 @@\n+error[E0594]: cannot assign to `t.0`, as `t` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:23:9\n+   |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - help: consider changing this to be mutable: `mut t`\n+LL |         drop(t);\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ cannot assign\n+\n+error[E0382]: assign to part of moved value: `t`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:23:9\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0594]: cannot assign to `t.1`, as `t` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:27:9\n+   |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - help: consider changing this to be mutable: `mut t`\n+...\n+LL |         t.1 = 2;\n+   |         ^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `u.0`, as `u` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:38:9\n+   |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - help: consider changing this to be mutable: `mut u`\n+LL |         drop(u);\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ cannot assign\n+\n+error[E0382]: assign to part of moved value: `u`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:38:9\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0594]: cannot assign to `u.1`, as `u` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:42:9\n+   |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - help: consider changing this to be mutable: `mut u`\n+...\n+LL |         u.1 = 2;\n+   |         ^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `v.x`, as `v` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:53:9\n+   |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - help: consider changing this to be mutable: `mut v`\n+LL |         drop(v);\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ cannot assign\n+\n+error[E0382]: assign to part of moved value: `v`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:53:9\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error[E0594]: cannot assign to `v.y`, as `v` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:57:9\n+   |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - help: consider changing this to be mutable: `mut v`\n+...\n+LL |         v.y = 2;\n+   |         ^^^^^^^ cannot assign\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors occurred: E0382, E0594.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "b19dcd65a6c7e2afdc1dea76853aacfde6d33f5e", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.rs?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,64 @@\n+// revisions: ast nll\n+\n+// Since we are testing nll migration explicitly as a separate\n+// revision, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[ast]compile-flags: -Z borrowck=ast\n+//[nll]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+#![warn(unused)]\n+#[derive(Debug)]\n+struct S(i32);\n+\n+type Tuple = (S, i32);\n+struct Tpair(S, i32);\n+struct Spair { x: S, y: i32 }\n+\n+fn main() {\n+    {\n+        let t: Tuple = (S(0), 0);\n+        drop(t);\n+        t.0 = S(1);\n+        //[ast]~^ ERROR cannot assign to field `t.0` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of moved value: `t` [E0382]\n+        //[nll]~| ERROR cannot assign to `t.0`, as `t` is not declared as mutable [E0594]\n+        t.1 = 2;\n+        //[ast]~^ ERROR cannot assign to field `t.1` of immutable binding [E0594]\n+        //[nll]~^^ ERROR cannot assign to `t.1`, as `t` is not declared as mutable [E0594]\n+        println!(\"{:?} {:?}\", t.0, t.1);\n+        //[ast]~^ ERROR use of moved value: `t.0` [E0382]\n+        //[ast]~| ERROR use of moved value: `t.1` [E0382]\n+    }\n+\n+    {\n+        let u: Tpair = Tpair(S(0), 0);\n+        drop(u);\n+        u.0 = S(1);\n+        //[ast]~^ ERROR cannot assign to field `u.0` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of moved value: `u` [E0382]\n+        //[nll]~| ERROR cannot assign to `u.0`, as `u` is not declared as mutable [E0594]\n+        u.1 = 2;\n+        //[ast]~^ ERROR cannot assign to field `u.1` of immutable binding [E0594]\n+        //[nll]~^^ ERROR cannot assign to `u.1`, as `u` is not declared as mutable [E0594]\n+        println!(\"{:?} {:?}\", u.0, u.1);\n+        //[ast]~^ ERROR use of moved value: `u.0` [E0382]\n+        //[ast]~| ERROR use of moved value: `u.1` [E0382]\n+    }\n+\n+    {\n+        let v: Spair = Spair { x: S(0), y: 0 };\n+        drop(v);\n+        v.x = S(1);\n+        //[ast]~^ ERROR cannot assign to field `v.x` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of moved value: `v` [E0382]\n+        //[nll]~| ERROR cannot assign to `v.x`, as `v` is not declared as mutable [E0594]\n+        v.y = 2;\n+        //[ast]~^ ERROR cannot assign to field `v.y` of immutable binding [E0594]\n+        //[nll]~^^ ERROR cannot assign to `v.y`, as `v` is not declared as mutable [E0594]\n+        println!(\"{:?} {:?}\", v.x, v.y);\n+        //[ast]~^ ERROR use of moved value: `v.x` [E0382]\n+        //[ast]~| ERROR use of moved value: `v.y` [E0382]\n+    }\n+}"}, {"sha": "ea6b63b7a297dc88c26c455c9dc4f40899d8b8ca", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-never-init.ast.stderr", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.ast.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,91 @@\n+error[E0594]: cannot assign to field `t.0` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:22:9\n+   |\n+LL |         let t: Tuple;\n+   |             - help: make this binding mutable: `mut t`\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `t.1` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:25:9\n+   |\n+LL |         let t: Tuple;\n+   |             - help: make this binding mutable: `mut t`\n+...\n+LL |         t.1 = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `u.0` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:34:9\n+   |\n+LL |         let u: Tpair;\n+   |             - help: make this binding mutable: `mut u`\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `u.1` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:37:9\n+   |\n+LL |         let u: Tpair;\n+   |             - help: make this binding mutable: `mut u`\n+...\n+LL |         u.1 = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `v.x` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:46:9\n+   |\n+LL |         let v: Spair;\n+   |             - help: make this binding mutable: `mut v`\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `v.y` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:49:9\n+   |\n+LL |         let v: Spair;\n+   |             - help: make this binding mutable: `mut v`\n+...\n+LL |         v.y = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0381]: use of possibly uninitialized variable: `t.0`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:27:31\n+   |\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                               ^^^ use of possibly uninitialized `t.0`\n+\n+error[E0381]: use of possibly uninitialized variable: `t.1`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:27:36\n+   |\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                                    ^^^ use of possibly uninitialized `t.1`\n+\n+error[E0381]: use of possibly uninitialized variable: `u.0`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:39:31\n+   |\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                               ^^^ use of possibly uninitialized `u.0`\n+\n+error[E0381]: use of possibly uninitialized variable: `u.1`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:39:36\n+   |\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                                    ^^^ use of possibly uninitialized `u.1`\n+\n+error[E0381]: use of possibly uninitialized variable: `v.x`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:51:31\n+   |\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                               ^^^ use of possibly uninitialized `v.x`\n+\n+error[E0381]: use of possibly uninitialized variable: `v.y`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:51:36\n+   |\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                                    ^^^ use of possibly uninitialized `v.y`\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors occurred: E0381, E0594.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "3dc2b5b3b8f9f0a6786c21f6f763be606a5528d5", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-never-init.nll.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.nll.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,21 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:22:9\n+   |\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `u`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:34:9\n+   |\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `u`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `v`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:46:9\n+   |\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `v`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "03eb9621ee215fed3d0a93301c69e7d9124ed09f", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-never-init.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.rs?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,55 @@\n+// revisions: ast nll\n+\n+// Since we are testing nll migration explicitly as a separate\n+// revision, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[ast]compile-flags: -Z borrowck=ast\n+//[nll]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+#![warn(unused)]\n+#[derive(Debug)]\n+struct S(i32);\n+\n+type Tuple = (S, i32);\n+struct Tpair(S, i32);\n+struct Spair { x: S, y: i32 }\n+\n+fn main() {\n+    {\n+        let t: Tuple;\n+        t.0 = S(1);\n+        //[ast]~^ ERROR cannot assign to field `t.0` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+        t.1 = 2;\n+        //[ast]~^ ERROR cannot assign to field `t.1` of immutable binding [E0594]\n+        println!(\"{:?} {:?}\", t.0, t.1);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `t.0` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `t.1` [E0381]\n+    }\n+\n+    {\n+        let u: Tpair;\n+        u.0 = S(1);\n+        //[ast]~^ ERROR cannot assign to field `u.0` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of possibly uninitialized variable: `u` [E0381]\n+        u.1 = 2;\n+        //[ast]~^ ERROR cannot assign to field `u.1` of immutable binding [E0594]\n+        println!(\"{:?} {:?}\", u.0, u.1);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `u.0` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `u.1` [E0381]\n+    }\n+\n+    {\n+        let v: Spair;\n+        v.x = S(1);\n+        //[ast]~^ ERROR cannot assign to field `v.x` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of possibly uninitialized variable: `v` [E0381]\n+        v.y = 2;\n+        //[ast]~^ ERROR cannot assign to field `v.y` of immutable binding [E0594]\n+        println!(\"{:?} {:?}\", v.x, v.y);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `v.x` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `v.y` [E0381]\n+    }\n+}"}, {"sha": "abafd330573ee8b8dba3e5f551e35d0691271b0e", "filename": "src/test/ui/nll/issue-21232-partial-init-and-erroneous-use.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,66 @@\n+// This test enumerates various cases of interest where a ADT or tuple is\n+// partially initialized and then used in some way that is wrong *even*\n+// after rust-lang/rust#54987 is implemented.\n+//\n+// See rust-lang/rust#21232, rust-lang/rust#54986, and rust-lang/rust#54987.\n+//\n+// See issue-21232-partial-init-and-use.rs for cases of tests that are\n+// meant to compile and run successfully once rust-lang/rust#54987 is\n+// implemented.\n+\n+#![feature(nll)]\n+\n+struct D {\n+    x: u32,\n+    s: S,\n+}\n+\n+struct S {\n+    y: u32,\n+    z: u32,\n+}\n+\n+\n+impl Drop for D {\n+    fn drop(&mut self) { }\n+}\n+\n+fn cannot_partially_init_adt_with_drop() {\n+    let d: D;\n+    d.x = 10;\n+    //~^ ERROR assign of possibly uninitialized variable: `d` [E0381]\n+}\n+\n+fn cannot_partially_init_mutable_adt_with_drop() {\n+    let mut d: D;\n+    d.x = 10;\n+    //~^ ERROR assign of possibly uninitialized variable: `d` [E0381]\n+}\n+\n+fn cannot_partially_reinit_adt_with_drop() {\n+    let mut d = D { x: 0, s: S{ y: 0, z: 0 } };\n+    drop(d);\n+    d.x = 10;\n+    //~^ ERROR assign of moved value: `d` [E0382]\n+}\n+\n+fn cannot_partially_init_inner_adt_via_outer_with_drop() {\n+    let d: D;\n+    d.s.y = 20;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `d` [E0381]\n+}\n+\n+fn cannot_partially_init_inner_adt_via_mutable_outer_with_drop() {\n+    let mut d: D;\n+    d.s.y = 20;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `d` [E0381]\n+}\n+\n+fn cannot_partially_reinit_inner_adt_via_outer_with_drop() {\n+    let mut d = D { x: 0, s: S{ y: 0, z: 0} };\n+    drop(d);\n+    d.s.y = 20;\n+    //~^ ERROR assign to part of moved value: `d` [E0382]\n+}\n+\n+fn main() { }"}, {"sha": "e29c44760a987ecfe39f154a67c6d146b5cde2e8", "filename": "src/test/ui/nll/issue-21232-partial-init-and-erroneous-use.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,48 @@\n+error[E0381]: assign of possibly uninitialized variable: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:30:5\n+   |\n+LL |     d.x = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `d`\n+\n+error[E0381]: assign of possibly uninitialized variable: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:36:5\n+   |\n+LL |     d.x = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `d`\n+\n+error[E0382]: assign of moved value: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:43:5\n+   |\n+LL |     drop(d);\n+   |          - value moved here\n+LL |     d.x = 10;\n+   |     ^^^^^^^^ value assigned here after move\n+   |\n+   = note: move occurs because `d` has type `D`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:49:5\n+   |\n+LL |     d.s.y = 20;\n+   |     ^^^^^^^^^^ use of possibly uninitialized `d.s`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:55:5\n+   |\n+LL |     d.s.y = 20;\n+   |     ^^^^^^^^^^ use of possibly uninitialized `d.s`\n+\n+error[E0382]: assign to part of moved value: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:62:5\n+   |\n+LL |     drop(d);\n+   |          - value moved here\n+LL |     d.s.y = 20;\n+   |     ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `d` has type `D`, which does not implement the `Copy` trait\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors occurred: E0381, E0382.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "e3ae4c0dcbe5725afec62e49a7e3049e2920f2ba", "filename": "src/test/ui/nll/issue-21232-partial-init-and-use.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,311 @@\n+// This test enumerates various cases of interest for partial\n+// [re]initialization of ADTs and tuples.\n+//\n+// See rust-lang/rust#21232, rust-lang/rust#54986, and rust-lang/rust#54987.\n+//\n+// All of tests in this file are expected to change from being\n+// rejected, at least under NLL (by rust-lang/rust#54986) to being\n+// **accepted** when rust-lang/rust#54987 is implemented.\n+// (That's why there are assertions in the code.)\n+//\n+// See issue-21232-partial-init-and-erroneous-use.rs for cases of\n+// tests that are meant to continue failing to compile once\n+// rust-lang/rust#54987 is implemented.\n+\n+#![feature(nll)]\n+\n+struct S<Y> {\n+    x: u32,\n+\n+    // Note that even though `y` may implement `Drop`, under #54987 we\n+    // will still allow partial initialization of `S` itself.\n+    y: Y,\n+}\n+\n+enum Void { }\n+\n+type B = Box<u32>;\n+\n+impl S<B> { fn new() -> Self { S { x: 0, y: Box::new(0) } } }\n+\n+fn borrow_s(s: &S<B>) { assert_eq!(s.x, 10); assert_eq!(*s.y, 20); }\n+fn move_s(s: S<B>) {  assert_eq!(s.x, 10); assert_eq!(*s.y, 20); }\n+fn borrow_field(x: &u32) { assert_eq!(*x, 10); }\n+\n+type T = (u32, B);\n+type Tvoid = (u32, Void);\n+\n+fn borrow_t(t: &T) { assert_eq!(t.0, 10); assert_eq!(*t.1, 20); }\n+fn move_t(t: T) {  assert_eq!(t.0, 10); assert_eq!(*t.1, 20); }\n+\n+struct Q<F> {\n+    v: u32,\n+    r: R<F>,\n+}\n+\n+struct R<F> {\n+    w: u32,\n+    f: F,\n+}\n+\n+impl<F> Q<F> { fn new(f: F) -> Self { Q { v: 0, r: R::new(f) } } }\n+impl<F> R<F> { fn new(f: F) -> Self { R { w: 0, f } } }\n+\n+// Axes to cover:\n+// * local/field: Is the structure in a local or a field\n+// * fully/partial/void: Are we fully initializing it before using any part?\n+//                       Is whole type empty due to a void component?\n+// * init/reinit: First initialization, or did we previously inititalize and then move out?\n+// * struct/tuple: Is this a struct or a (X, Y).\n+//\n+// As a shorthand for the cases above, adding a numeric summary to\n+// each test's fn name to denote each point on each axis.\n+//\n+// E.g. 1000 = field fully init struct; 0211 = local void reinit tuple\n+\n+// It got pretty monotonous writing the same code over and over, and I\n+// feared I would forget details. So I abstracted some desiderata into\n+// macros. But I left the initialization code inline, because that's\n+// where the errors for #54986 will be emited.\n+\n+macro_rules! use_fully {\n+    (struct $s:expr) => { {\n+        borrow_field(& $s.x );\n+        borrow_s(& $s );\n+        move_s( $s );\n+    } };\n+\n+    (tuple $t:expr) => { {\n+        borrow_field(& $t.0 );\n+        borrow_t(& $t );\n+        move_t( $t );\n+    } }\n+}\n+\n+macro_rules! use_part {\n+    (struct $s:expr) => { {\n+        borrow_field(& $s.x );\n+        match $s { S { ref x, y: _ } => { borrow_field(x); } }\n+    } };\n+\n+    (tuple $t:expr) => { {\n+        borrow_field(& $t.0 );\n+        match $t { (ref x, _) => { borrow_field(x); } }\n+    } }\n+}\n+\n+fn test_0000_local_fully_init_and_use_struct() {\n+    let s: S<B>;\n+    s.x = 10; s.y = Box::new(20);\n+    //~^ ERROR assign to part of possibly uninitialized variable: `s` [E0381]\n+    use_fully!(struct s);\n+}\n+\n+fn test_0001_local_fully_init_and_use_tuple() {\n+    let t: T;\n+    t.0 = 10; t.1 = Box::new(20);\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    use_fully!(tuple t);\n+}\n+\n+fn test_0010_local_fully_reinit_and_use_struct() {\n+    let mut s: S<B> = S::new(); drop(s);\n+    s.x = 10; s.y = Box::new(20);\n+    //~^ ERROR assign to part of moved value: `s` [E0382]\n+    use_fully!(struct s);\n+}\n+\n+fn test_0011_local_fully_reinit_and_use_tuple() {\n+    let mut t: T = (0, Box::new(0)); drop(t);\n+    t.0 = 10; t.1 = Box::new(20);\n+    //~^ ERROR assign to part of moved value: `t` [E0382]\n+    use_fully!(tuple t);\n+}\n+\n+fn test_0100_local_partial_init_and_use_struct() {\n+    let s: S<B>;\n+    s.x = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `s` [E0381]\n+    use_part!(struct s);\n+}\n+\n+fn test_0101_local_partial_init_and_use_tuple() {\n+    let t: T;\n+    t.0 = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    use_part!(tuple t);\n+}\n+\n+fn test_0110_local_partial_reinit_and_use_struct() {\n+    let mut s: S<B> = S::new(); drop(s);\n+    s.x = 10;\n+    //~^ ERROR assign to part of moved value: `s` [E0382]\n+    use_part!(struct s);\n+}\n+\n+fn test_0111_local_partial_reinit_and_use_tuple() {\n+    let mut t: T = (0, Box::new(0)); drop(t);\n+    t.0 = 10;\n+    //~^ ERROR assign to part of moved value: `t` [E0382]\n+    use_part!(tuple t);\n+}\n+\n+fn test_0200_local_void_init_and_use_struct() {\n+    let s: S<Void>;\n+    s.x = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `s` [E0381]\n+    use_part!(struct s);\n+}\n+\n+fn test_0201_local_void_init_and_use_tuple() {\n+    let t: Tvoid;\n+    t.0 = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    use_part!(tuple t);\n+}\n+\n+// NOTE: uniform structure of tests here makes n21n (aka combining\n+// Void with Reinit) an (even more) senseless case, as we cannot\n+// safely create initial instance containing Void to move out of and\n+// then reinitialize. While I was tempted to sidestep this via some\n+// unsafe code (eek), lets just instead not encode such tests.\n+\n+// fn test_0210_local_void_reinit_and_use_struct() { unimplemented!() }\n+// fn test_0211_local_void_reinit_and_use_tuple() { unimplemented!() }\n+\n+fn test_1000_field_fully_init_and_use_struct() {\n+    let q: Q<S<B>>;\n+    q.r.f.x = 10; q.r.f.y = Box::new(20);\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_fully!(struct q.r.f);\n+}\n+\n+fn test_1001_field_fully_init_and_use_tuple() {\n+    let q: Q<T>;\n+    q.r.f.0 = 10; q.r.f.1 = Box::new(20);\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_fully!(tuple q.r.f);\n+}\n+\n+fn test_1010_field_fully_reinit_and_use_struct() {\n+    let mut q: Q<S<B>> = Q::new(S::new()); drop(q.r);\n+    q.r.f.x = 10; q.r.f.y = Box::new(20);\n+    //~^ ERROR assign to part of moved value: `q.r` [E0382]\n+    use_fully!(struct q.r.f);\n+}\n+\n+fn test_1011_field_fully_reinit_and_use_tuple() {\n+    let mut q: Q<T> = Q::new((0, Box::new(0))); drop(q.r);\n+    q.r.f.0 = 10; q.r.f.1 = Box::new(20);\n+    //~^ ERROR assign to part of moved value: `q.r` [E0382]\n+    use_fully!(tuple q.r.f);\n+}\n+\n+fn test_1100_field_partial_init_and_use_struct() {\n+    let q: Q<S<B>>;\n+    q.r.f.x = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_part!(struct q.r.f);\n+}\n+\n+fn test_1101_field_partial_init_and_use_tuple() {\n+    let q: Q<T>;\n+    q.r.f.0 = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_part!(tuple q.r.f);\n+}\n+\n+fn test_1110_field_partial_reinit_and_use_struct() {\n+    let mut q: Q<S<B>> = Q::new(S::new()); drop(q.r);\n+    q.r.f.x = 10;\n+    //~^ ERROR assign to part of moved value: `q.r` [E0382]\n+    use_part!(struct q.r.f);\n+}\n+\n+fn test_1111_field_partial_reinit_and_use_tuple() {\n+    let mut q: Q<T> = Q::new((0, Box::new(0))); drop(q.r);\n+    q.r.f.0 = 10;\n+    //~^ ERROR assign to part of moved value: `q.r` [E0382]\n+    use_part!(tuple q.r.f);\n+}\n+\n+fn test_1200_field_void_init_and_use_struct() {\n+    let mut q: Q<S<Void>>;\n+    q.r.f.x = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_part!(struct q.r.f);\n+}\n+\n+fn test_1201_field_void_init_and_use_tuple() {\n+    let mut q: Q<Tvoid>;\n+    q.r.f.0 = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_part!(tuple q.r.f);\n+}\n+\n+// See NOTE abve.\n+\n+// fn test_1210_field_void_reinit_and_use_struct() { unimplemented!() }\n+// fn test_1211_field_void_reinit_and_use_tuple() { unimplemented!() }\n+\n+// The below are some additional cases of interest that have been\n+// transcribed from other bugs based on old erroneous codegen when we\n+// encountered partial writes.\n+\n+fn issue_26996() {\n+    let mut c = (1, \"\".to_owned());\n+    match c {\n+        c2 => {\n+            c.0 = 2; //~ ERROR assign to part of moved value\n+            assert_eq!(c2.0, 1);\n+        }\n+    }\n+}\n+\n+fn issue_27021() {\n+    let mut c = (1, (1, \"\".to_owned()));\n+    match c {\n+        c2 => {\n+            (c.1).0 = 2; //~ ERROR assign to part of moved value\n+            assert_eq!((c2.1).0, 1);\n+        }\n+    }\n+\n+    let mut c = (1, (1, (1, \"\".to_owned())));\n+    match c.1 {\n+        c2 => {\n+            ((c.1).1).0 = 3; //~ ERROR assign to part of moved value\n+            assert_eq!((c2.1).0, 1);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    test_0000_local_fully_init_and_use_struct();\n+    test_0001_local_fully_init_and_use_tuple();\n+    test_0010_local_fully_reinit_and_use_struct();\n+    test_0011_local_fully_reinit_and_use_tuple();\n+    test_0100_local_partial_init_and_use_struct();\n+    test_0101_local_partial_init_and_use_tuple();\n+    test_0110_local_partial_reinit_and_use_struct();\n+    test_0111_local_partial_reinit_and_use_tuple();\n+    test_0200_local_void_init_and_use_struct();\n+    test_0201_local_void_init_and_use_tuple();\n+    // test_0210_local_void_reinit_and_use_struct();\n+    // test_0211_local_void_reinit_and_use_tuple();\n+    test_1000_field_fully_init_and_use_struct();\n+    test_1001_field_fully_init_and_use_tuple();\n+    test_1010_field_fully_reinit_and_use_struct();\n+    test_1011_field_fully_reinit_and_use_tuple();\n+    test_1100_field_partial_init_and_use_struct();\n+    test_1101_field_partial_init_and_use_tuple();\n+    test_1110_field_partial_reinit_and_use_struct();\n+    test_1111_field_partial_reinit_and_use_tuple();\n+    test_1200_field_void_init_and_use_struct();\n+    test_1201_field_void_init_and_use_tuple();\n+    // test_1210_field_void_reinit_and_use_struct();\n+    // test_1211_field_void_reinit_and_use_tuple();\n+\n+    issue_26996();\n+    issue_27021();\n+}"}, {"sha": "aec7f676fcebd6688b2d912f52e398f5f416a1d6", "filename": "src/test/ui/nll/issue-21232-partial-init-and-use.stderr", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233fdb4b1486b3b98bd1bb80f83138924a8a734e/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr?ref=233fdb4b1486b3b98bd1bb80f83138924a8a734e", "patch": "@@ -0,0 +1,186 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:99:5\n+   |\n+LL |     s.x = 10; s.y = Box::new(20);\n+   |     ^^^^^^^^ use of possibly uninitialized `s`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:106:5\n+   |\n+LL |     t.0 = 10; t.1 = Box::new(20);\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0382]: assign to part of moved value: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:113:5\n+   |\n+LL |     let mut s: S<B> = S::new(); drop(s);\n+   |                                      - value moved here\n+LL |     s.x = 10; s.y = Box::new(20);\n+   |     ^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `s` has type `S<std::boxed::Box<u32>>`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:120:5\n+   |\n+LL |     let mut t: T = (0, Box::new(0)); drop(t);\n+   |                                           - value moved here\n+LL |     t.0 = 10; t.1 = Box::new(20);\n+   |     ^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `t` has type `(u32, std::boxed::Box<u32>)`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:127:5\n+   |\n+LL |     s.x = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `s`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:134:5\n+   |\n+LL |     t.0 = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0382]: assign to part of moved value: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:141:5\n+   |\n+LL |     let mut s: S<B> = S::new(); drop(s);\n+   |                                      - value moved here\n+LL |     s.x = 10;\n+   |     ^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `s` has type `S<std::boxed::Box<u32>>`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:148:5\n+   |\n+LL |     let mut t: T = (0, Box::new(0)); drop(t);\n+   |                                           - value moved here\n+LL |     t.0 = 10;\n+   |     ^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `t` has type `(u32, std::boxed::Box<u32>)`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:155:5\n+   |\n+LL |     s.x = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `s`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:162:5\n+   |\n+LL |     t.0 = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:178:5\n+   |\n+LL |     q.r.f.x = 10; q.r.f.y = Box::new(20);\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:185:5\n+   |\n+LL |     q.r.f.0 = 10; q.r.f.1 = Box::new(20);\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0382]: assign to part of moved value: `q.r`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:192:5\n+   |\n+LL |     let mut q: Q<S<B>> = Q::new(S::new()); drop(q.r);\n+   |                                                 --- value moved here\n+LL |     q.r.f.x = 10; q.r.f.y = Box::new(20);\n+   |     ^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `q.r` has type `R<S<std::boxed::Box<u32>>>`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `q.r`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:199:5\n+   |\n+LL |     let mut q: Q<T> = Q::new((0, Box::new(0))); drop(q.r);\n+   |                                                      --- value moved here\n+LL |     q.r.f.0 = 10; q.r.f.1 = Box::new(20);\n+   |     ^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `q.r` has type `R<(u32, std::boxed::Box<u32>)>`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:206:5\n+   |\n+LL |     q.r.f.x = 10;\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:213:5\n+   |\n+LL |     q.r.f.0 = 10;\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0382]: assign to part of moved value: `q.r`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:220:5\n+   |\n+LL |     let mut q: Q<S<B>> = Q::new(S::new()); drop(q.r);\n+   |                                                 --- value moved here\n+LL |     q.r.f.x = 10;\n+   |     ^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `q.r` has type `R<S<std::boxed::Box<u32>>>`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `q.r`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:227:5\n+   |\n+LL |     let mut q: Q<T> = Q::new((0, Box::new(0))); drop(q.r);\n+   |                                                      --- value moved here\n+LL |     q.r.f.0 = 10;\n+   |     ^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `q.r` has type `R<(u32, std::boxed::Box<u32>)>`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:234:5\n+   |\n+LL |     q.r.f.x = 10;\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:241:5\n+   |\n+LL |     q.r.f.0 = 10;\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0382]: assign to part of moved value: `c`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:259:13\n+   |\n+LL |         c2 => {\n+   |         -- value moved here\n+LL |             c.0 = 2; //~ ERROR assign to part of moved value\n+   |             ^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `c` has type `(i32, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `c`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:269:13\n+   |\n+LL |         c2 => {\n+   |         -- value moved here\n+LL |             (c.1).0 = 2; //~ ERROR assign to part of moved value\n+   |             ^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `c` has type `(i32, (i32, std::string::String))`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `c.1`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:277:13\n+   |\n+LL |         c2 => {\n+   |         -- value moved here\n+LL |             ((c.1).1).0 = 3; //~ ERROR assign to part of moved value\n+   |             ^^^^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `c.1` has type `(i32, (i32, std::string::String))`, which does not implement the `Copy` trait\n+\n+error: aborting due to 23 previous errors\n+\n+Some errors occurred: E0381, E0382.\n+For more information about an error, try `rustc --explain E0381`."}]}