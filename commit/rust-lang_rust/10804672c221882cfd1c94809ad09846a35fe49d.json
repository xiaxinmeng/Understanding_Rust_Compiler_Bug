{"sha": "10804672c221882cfd1c94809ad09846a35fe49d", "node_id": "C_kwDOAAsO6NoAKDEwODA0NjcyYzIyMTg4MmNmZDFjOTQ4MDlhZDA5ODQ2YTM1ZmU0OWQ", "commit": {"author": {"name": "Bryanskiy", "email": "ivakin.kir@gmail.com", "date": "2022-08-14T14:04:30Z"}, "committer": {"name": "Bryanskiy", "email": "ivakin.kir@gmail.com", "date": "2022-08-31T11:23:01Z"}, "message": "access_levels.rs refactor", "tree": {"sha": "36c1a5b7428e3a96e4f813d2edbc7abbc94d6dad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36c1a5b7428e3a96e4f813d2edbc7abbc94d6dad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10804672c221882cfd1c94809ad09846a35fe49d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10804672c221882cfd1c94809ad09846a35fe49d", "html_url": "https://github.com/rust-lang/rust/commit/10804672c221882cfd1c94809ad09846a35fe49d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10804672c221882cfd1c94809ad09846a35fe49d/comments", "author": {"login": "Bryanskiy", "id": 65131002, "node_id": "MDQ6VXNlcjY1MTMxMDAy", "avatar_url": "https://avatars.githubusercontent.com/u/65131002?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Bryanskiy", "html_url": "https://github.com/Bryanskiy", "followers_url": "https://api.github.com/users/Bryanskiy/followers", "following_url": "https://api.github.com/users/Bryanskiy/following{/other_user}", "gists_url": "https://api.github.com/users/Bryanskiy/gists{/gist_id}", "starred_url": "https://api.github.com/users/Bryanskiy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Bryanskiy/subscriptions", "organizations_url": "https://api.github.com/users/Bryanskiy/orgs", "repos_url": "https://api.github.com/users/Bryanskiy/repos", "events_url": "https://api.github.com/users/Bryanskiy/events{/privacy}", "received_events_url": "https://api.github.com/users/Bryanskiy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Bryanskiy", "id": 65131002, "node_id": "MDQ6VXNlcjY1MTMxMDAy", "avatar_url": "https://avatars.githubusercontent.com/u/65131002?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Bryanskiy", "html_url": "https://github.com/Bryanskiy", "followers_url": "https://api.github.com/users/Bryanskiy/followers", "following_url": "https://api.github.com/users/Bryanskiy/following{/other_user}", "gists_url": "https://api.github.com/users/Bryanskiy/gists{/gist_id}", "starred_url": "https://api.github.com/users/Bryanskiy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Bryanskiy/subscriptions", "organizations_url": "https://api.github.com/users/Bryanskiy/orgs", "repos_url": "https://api.github.com/users/Bryanskiy/repos", "events_url": "https://api.github.com/users/Bryanskiy/events{/privacy}", "received_events_url": "https://api.github.com/users/Bryanskiy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fce6a7d66ec32e6350aa7f0e3953d64269e857a3", "html_url": "https://github.com/rust-lang/rust/commit/fce6a7d66ec32e6350aa7f0e3953d64269e857a3"}], "stats": {"total": 203, "additions": 80, "deletions": 123}, "files": [{"sha": "c98f7f0ccef44d68c68750dcf84d2d6ba9bc71bc", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 53, "deletions": 105, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/10804672c221882cfd1c94809ad09846a35fe49d/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10804672c221882cfd1c94809ad09846a35fe49d/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=10804672c221882cfd1c94809ad09846a35fe49d", "patch": "@@ -1,25 +1,21 @@\n+use crate::imports::ImportKind;\n+use crate::NameBinding;\n+use crate::NameBindingKind;\n+use crate::Resolver;\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n-use rustc_ast::ForeignMod;\n use rustc_ast::NodeId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_middle::middle::privacy::AccessLevel;\n-use rustc_middle::ty::Visibility;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::sym;\n \n-use crate::imports::ImportKind;\n-use crate::BindingKey;\n-use crate::NameBinding;\n-use crate::NameBindingKind;\n-use crate::Resolver;\n-\n pub struct AccessLevelsVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n-    prev_level: Option<AccessLevel>,\n     changed: bool,\n }\n \n@@ -28,11 +24,10 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n     pub fn compute_access_levels<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n-        let mut visitor =\n-            AccessLevelsVisitor { r, changed: false, prev_level: Some(AccessLevel::Public) };\n+        let mut visitor = AccessLevelsVisitor { r, changed: false };\n \n         visitor.set_access_level_def_id(CRATE_DEF_ID, Some(AccessLevel::Public));\n-        visitor.set_exports_access_level(CRATE_DEF_ID);\n+        visitor.set_bindings_access_level(CRATE_DEF_ID);\n \n         while visitor.changed {\n             visitor.reset();\n@@ -44,15 +39,17 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n \n     fn reset(&mut self) {\n         self.changed = false;\n-        self.prev_level = Some(AccessLevel::Public);\n     }\n \n-    /// Update the access level of the exports of the given module accordingly. The module access\n+    /// Update the access level of the bindings in the given module accordingly. The module access\n     /// level has to be Exported or Public.\n     /// This will also follow `use` chains (see PrivacyVisitor::set_import_binding_access_level).\n-    fn set_exports_access_level(&mut self, module_id: LocalDefId) {\n+    fn set_bindings_access_level(&mut self, module_id: LocalDefId) {\n         assert!(self.r.module_map.contains_key(&&module_id.to_def_id()));\n-\n+        let module_level = self.r.access_levels.map.get(&module_id).copied();\n+        if !module_level.is_some() {\n+            return;\n+        }\n         // Set the given binding access level to `AccessLevel::Public` and\n         // sets the rest of the `use` chain to `AccessLevel::Exported` until\n         // we hit the actual exported item.\n@@ -72,28 +69,20 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n                 }\n             };\n \n-        let module_level = self.r.access_levels.map.get(&module_id).copied();\n-        assert!(module_level >= Some(AccessLevel::Exported));\n-\n-        if let Some(exports) = self.r.reexport_map.get(&module_id) {\n-            let pub_exports = exports\n-                .iter()\n-                .filter(|ex| ex.vis == Visibility::Public)\n-                .cloned()\n-                .collect::<Vec<_>>();\n-\n-            let module = self.r.get_module(module_id.to_def_id()).unwrap();\n-            for export in pub_exports.into_iter() {\n-                if let Some(export_def_id) = export.res.opt_def_id().and_then(|id| id.as_local()) {\n-                    self.set_access_level_def_id(export_def_id, Some(AccessLevel::Exported));\n-                }\n-\n-                if let Some(ns) = export.res.ns() {\n-                    let key = BindingKey { ident: export.ident, ns, disambiguator: 0 };\n-                    let name_res = self.r.resolution(module, key);\n-                    if let Some(binding) = name_res.borrow().binding() {\n-                        set_import_binding_access_level(self, binding, module_level)\n-                    }\n+        let module = self.r.get_module(module_id.to_def_id()).unwrap();\n+        let resolutions = self.r.resolutions(module);\n+\n+        for (.., name_resolution) in resolutions.borrow().iter() {\n+            if let Some(binding) = name_resolution.borrow().binding() && binding.vis.is_public() && !binding.is_ambiguity() {\n+                let access_level = match binding.is_import() {\n+                    true => {\n+                        set_import_binding_access_level(self, binding, module_level);\n+                        Some(AccessLevel::Exported)\n+                    },\n+                    false => module_level,\n+                };\n+                if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n+                    self.set_access_level_def_id(def_id, access_level);\n                 }\n             }\n         }\n@@ -127,97 +116,59 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n \n impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n     fn visit_item(&mut self, item: &'ast ast::Item) {\n-        let inherited_item_level = match item.kind {\n+        let def_id = self.r.local_def_id(item.id);\n+        // Set access level of nested items.\n+        // If it's a mod, also make the visitor walk all of its items\n+        match item.kind {\n             // Resolved in rustc_privacy when types are available\n             ast::ItemKind::Impl(..) => return,\n \n-            // Only exported `macro_rules!` items are public, but they always are\n-            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n-                let is_macro_export =\n-                    item.attrs.iter().any(|attr| attr.has_name(sym::macro_export));\n-                if is_macro_export { Some(AccessLevel::Public) } else { None }\n-            }\n-\n-            // Foreign modules inherit level from parents.\n-            ast::ItemKind::ForeignMod(..) => self.prev_level,\n-\n-            // Other `pub` items inherit levels from parents.\n-            ast::ItemKind::ExternCrate(..)\n-            | ast::ItemKind::Use(..)\n-            | ast::ItemKind::Static(..)\n-            | ast::ItemKind::Const(..)\n-            | ast::ItemKind::Fn(..)\n-            | ast::ItemKind::Mod(..)\n-            | ast::ItemKind::GlobalAsm(..)\n-            | ast::ItemKind::TyAlias(..)\n-            | ast::ItemKind::Enum(..)\n-            | ast::ItemKind::Struct(..)\n-            | ast::ItemKind::Union(..)\n-            | ast::ItemKind::Trait(..)\n-            | ast::ItemKind::TraitAlias(..)\n-            | ast::ItemKind::MacroDef(..) => {\n-                if item.vis.kind.is_pub() {\n-                    self.prev_level\n-                } else {\n-                    None\n-                }\n-            }\n-\n             // Should be unreachable at this stage\n             ast::ItemKind::MacCall(..) => panic!(\n                 \"ast::ItemKind::MacCall encountered, this should not anymore appear at this stage\"\n             ),\n-        };\n \n-        let access_level = self.set_access_level(item.id, inherited_item_level);\n+            // Foreign modules inherit level from parents.\n+            ast::ItemKind::ForeignMod(..) => {\n+                let parent_level =\n+                    self.r.access_levels.map.get(&self.r.local_parent(def_id)).copied();\n+                self.set_access_level(item.id, parent_level);\n+            }\n \n-        // Set access level of nested items.\n-        // If it's a mod, also make the visitor walk all of its items\n-        match item.kind {\n-            ast::ItemKind::Mod(..) => {\n-                if access_level.is_some() {\n-                    self.set_exports_access_level(self.r.local_def_id(item.id));\n+            // Only exported `macro_rules!` items are public, but they always are\n+            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n+                if item.attrs.iter().any(|attr| attr.has_name(sym::macro_export)) {\n+                    self.set_access_level(item.id, Some(AccessLevel::Public));\n                 }\n+            }\n \n-                let orig_level = std::mem::replace(&mut self.prev_level, access_level);\n+            ast::ItemKind::Mod(..) => {\n+                self.set_bindings_access_level(def_id);\n                 visit::walk_item(self, item);\n-                self.prev_level = orig_level;\n             }\n \n-            ast::ItemKind::ForeignMod(ForeignMod { ref items, .. }) => {\n-                for nested in items {\n-                    if nested.vis.kind.is_pub() {\n-                        self.set_access_level(nested.id, access_level);\n-                    }\n-                }\n-            }\n             ast::ItemKind::Enum(EnumDef { ref variants }, _) => {\n+                self.set_bindings_access_level(def_id);\n                 for variant in variants {\n-                    let variant_level = self.set_access_level(variant.id, access_level);\n-                    if let Some(ctor_id) = variant.data.ctor_id() {\n-                        self.set_access_level(ctor_id, access_level);\n-                    }\n-\n+                    let variant_def_id = self.r.local_def_id(variant.id);\n+                    let variant_level = self.r.access_levels.map.get(&variant_def_id).copied();\n                     for field in variant.data.fields() {\n                         self.set_access_level(field.id, variant_level);\n                     }\n                 }\n             }\n-            ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n-                if let Some(ctor_id) = def.ctor_id() {\n-                    self.set_access_level(ctor_id, access_level);\n-                }\n \n+            ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n+                let inherited_level = self.r.access_levels.map.get(&def_id).copied();\n                 for field in def.fields() {\n                     if field.vis.kind.is_pub() {\n-                        self.set_access_level(field.id, access_level);\n+                        self.set_access_level(field.id, inherited_level);\n                     }\n                 }\n             }\n-            ast::ItemKind::Trait(ref trait_kind) => {\n-                for nested in trait_kind.items.iter() {\n-                    self.set_access_level(nested.id, access_level);\n-                }\n+\n+            ast::ItemKind::Trait(..) => {\n+                self.set_bindings_access_level(def_id);\n             }\n \n             ast::ItemKind::ExternCrate(..)\n@@ -229,9 +180,6 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n             | ast::ItemKind::TraitAlias(..)\n             | ast::ItemKind::MacroDef(..)\n             | ast::ItemKind::Fn(..) => return,\n-\n-            // Unreachable kinds\n-            ast::ItemKind::Impl(..) | ast::ItemKind::MacCall(..) => unreachable!(),\n         }\n     }\n }"}, {"sha": "9a2c39fab72fd96d703b7d5c9a3e3cbc467f4d80", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/10804672c221882cfd1c94809ad09846a35fe49d/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10804672c221882cfd1c94809ad09846a35fe49d/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=10804672c221882cfd1c94809ad09846a35fe49d", "patch": "@@ -1135,24 +1135,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         if let Some(def_id) = module.opt_def_id() {\n             let mut reexports = Vec::new();\n \n-            module.for_each_child(self.r, |_, ident, _, binding| {\n-                // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n-                // into the crate root to actual `NameBindingKind::Import`.\n-                if binding.is_import()\n-                    || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n-                {\n-                    let res = binding.res().expect_non_local();\n-                    // Ambiguous imports are treated as errors at this point and are\n-                    // not exposed to other crates (see #36837 for more details).\n-                    if res != def::Res::Err && !binding.is_ambiguity() {\n-                        reexports.push(ModChild {\n-                            ident,\n-                            res,\n-                            vis: binding.vis,\n-                            span: binding.span,\n-                            macro_rules: false,\n-                        });\n-                    }\n+            module.for_each_child(self.r, |this, ident, _, binding| {\n+                if let Some(res) = this.is_reexport(binding) {\n+                    reexports.push(ModChild {\n+                        ident,\n+                        res,\n+                        vis: binding.vis,\n+                        span: binding.span,\n+                        macro_rules: false,\n+                    });\n                 }\n             });\n "}, {"sha": "74f73bbd85cd32db735e648d5cebf1c424a247a0", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10804672c221882cfd1c94809ad09846a35fe49d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10804672c221882cfd1c94809ad09846a35fe49d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=10804672c221882cfd1c94809ad09846a35fe49d", "patch": "@@ -2021,6 +2021,24 @@ impl<'a> Resolver<'a> {\n         }\n         self.main_def = Some(MainDefinition { res, is_import, span });\n     }\n+\n+    // Items that go to reexport table encoded to metadata and visible through it to other crates.\n+    fn is_reexport(&self, binding: &NameBinding<'a>) -> Option<def::Res<!>> {\n+        // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n+        // into the crate root to actual `NameBindingKind::Import`.\n+        if binding.is_import()\n+            || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n+        {\n+            let res = binding.res().expect_non_local();\n+            // Ambiguous imports are treated as errors at this point and are\n+            // not exposed to other crates (see #36837 for more details).\n+            if res != def::Res::Err && !binding.is_ambiguity() {\n+                return Some(res);\n+            }\n+        }\n+\n+        return None;\n+    }\n }\n \n fn names_to_string(names: &[Symbol]) -> String {"}]}