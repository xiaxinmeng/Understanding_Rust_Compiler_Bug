{"sha": "434e5d142204d9b3019cfedc049d39b0affd08e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNGU1ZDE0MjIwNGQ5YjMwMTljZmVkYzA0OWQzOWIwYWZmZDA4ZTc=", "commit": {"author": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-04T23:58:11Z"}, "committer": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-29T14:03:29Z"}, "message": "refactor: moving DrainFilter into drain_filter.rs", "tree": {"sha": "076addd9225a77935d0514d5d372d52f1980caf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/076addd9225a77935d0514d5d372d52f1980caf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/434e5d142204d9b3019cfedc049d39b0affd08e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/434e5d142204d9b3019cfedc049d39b0affd08e7", "html_url": "https://github.com/rust-lang/rust/commit/434e5d142204d9b3019cfedc049d39b0affd08e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/434e5d142204d9b3019cfedc049d39b0affd08e7/comments", "author": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5182776c6ceded22b79adc43e275b6b02111fe5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5182776c6ceded22b79adc43e275b6b02111fe5b", "html_url": "https://github.com/rust-lang/rust/commit/5182776c6ceded22b79adc43e275b6b02111fe5b"}], "stats": {"total": 286, "additions": 148, "deletions": 138}, "files": [{"sha": "9d898c7c756c291a5457090cbafef04b276cee3e", "filename": "library/alloc/src/vec/drain_filter.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/434e5d142204d9b3019cfedc049d39b0affd08e7/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/434e5d142204d9b3019cfedc049d39b0affd08e7/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs?ref=434e5d142204d9b3019cfedc049d39b0affd08e7", "patch": "@@ -0,0 +1,143 @@\n+use core::ptr::{self};\n+use core::slice::{self};\n+use crate::alloc::{Allocator, Global};\n+\n+use super::{Vec};\n+\n+/// An iterator which uses a closure to determine if an element should be removed.\n+///\n+/// This struct is created by [`Vec::drain_filter`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(drain_filter)]\n+///\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::DrainFilter<_, _> = v.drain_filter(|x| *x % 2 == 0);\n+/// ```\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+#[derive(Debug)]\n+pub struct DrainFilter<\n+    'a,\n+    T,\n+    F,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    pub(super) vec: &'a mut Vec<T, A>,\n+    /// The index of the item that will be inspected by the next call to `next`.\n+    pub(super) idx: usize,\n+    /// The number of items that have been drained (removed) thus far.\n+    pub(super) del: usize,\n+    /// The original length of `vec` prior to draining.\n+    pub(super) old_len: usize,\n+    /// The filter test predicate.\n+    pub(super) pred: F,\n+    /// A flag that indicates a panic has occurred in the filter test predicate.\n+    /// This is used as a hint in the drop implementation to prevent consumption\n+    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n+    /// backshifted in the `vec`, but no further items will be dropped or\n+    /// tested by the filter predicate.\n+    pub(super) panic_flag: bool,\n+}\n+\n+impl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\n+    where\n+        F: FnMut(&mut T) -> bool,\n+{\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        self.vec.allocator()\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n+    where\n+        F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            while self.idx < self.old_len {\n+                let i = self.idx;\n+                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n+                self.panic_flag = true;\n+                let drained = (self.pred)(&mut v[i]);\n+                self.panic_flag = false;\n+                // Update the index *after* the predicate is called. If the index\n+                // is updated prior and the predicate panics, the element at this\n+                // index would be leaked.\n+                self.idx += 1;\n+                if drained {\n+                    self.del += 1;\n+                    return Some(ptr::read(&v[i]));\n+                } else if self.del > 0 {\n+                    let del = self.del;\n+                    let src: *const T = &v[i];\n+                    let dst: *mut T = &mut v[i - del];\n+                    ptr::copy_nonoverlapping(src, dst, 1);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n+    where\n+        F: FnMut(&mut T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n+            where\n+                F: FnMut(&mut T) -> bool,\n+        {\n+            drain: &'b mut DrainFilter<'a, T, F, A>,\n+        }\n+\n+        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n+            where\n+                F: FnMut(&mut T) -> bool,\n+        {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n+                        // This is a pretty messed up state, and there isn't really an\n+                        // obviously right thing to do. We don't want to keep trying\n+                        // to execute `pred`, so we just backshift all the unprocessed\n+                        // elements and tell the vec that they still exist. The backshift\n+                        // is required to prevent a double-drop of the last successfully\n+                        // drained item prior to a panic in the predicate.\n+                        let ptr = self.drain.vec.as_mut_ptr();\n+                        let src = ptr.add(self.drain.idx);\n+                        let dst = src.sub(self.drain.del);\n+                        let tail_len = self.drain.old_len - self.drain.idx;\n+                        src.copy_to(dst, tail_len);\n+                    }\n+                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n+                }\n+            }\n+        }\n+\n+        let backshift = BackshiftOnDrop { drain: self };\n+\n+        // Attempt to consume any remaining elements if the filter predicate\n+        // has not yet panicked. We'll backshift any remaining elements\n+        // whether we've already panicked or if the consumption here panics.\n+        if !backshift.drain.panic_flag {\n+            backshift.drain.for_each(drop);\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "2fb1fe0d5cbd88df2b1f4158833922190763f688", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 5, "deletions": 138, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/434e5d142204d9b3019cfedc049d39b0affd08e7/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/434e5d142204d9b3019cfedc049d39b0affd08e7/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=434e5d142204d9b3019cfedc049d39b0affd08e7", "patch": "@@ -74,6 +74,11 @@ use crate::boxed::Box;\n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n \n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+pub use self::drain_filter::DrainFilter;\n+\n+mod drain_filter;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -3585,141 +3590,3 @@ impl<T, A: Allocator> Drain<'_, T, A> {\n         self.tail_start = new_tail_start;\n     }\n }\n-\n-/// An iterator which uses a closure to determine if an element should be removed.\n-///\n-/// This struct is created by [`Vec::drain_filter`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(drain_filter)]\n-///\n-/// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::DrainFilter<_, _> = v.drain_filter(|x| *x % 2 == 0);\n-/// ```\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-#[derive(Debug)]\n-pub struct DrainFilter<\n-    'a,\n-    T,\n-    F,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n-> where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    vec: &'a mut Vec<T, A>,\n-    /// The index of the item that will be inspected by the next call to `next`.\n-    idx: usize,\n-    /// The number of items that have been drained (removed) thus far.\n-    del: usize,\n-    /// The original length of `vec` prior to draining.\n-    old_len: usize,\n-    /// The filter test predicate.\n-    pred: F,\n-    /// A flag that indicates a panic has occurred in the filter test predicate.\n-    /// This is used as a hint in the drop implementation to prevent consumption\n-    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n-    /// backshifted in the `vec`, but no further items will be dropped or\n-    /// tested by the filter predicate.\n-    panic_flag: bool,\n-}\n-\n-impl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        self.vec.allocator()\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            while self.idx < self.old_len {\n-                let i = self.idx;\n-                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n-                self.panic_flag = true;\n-                let drained = (self.pred)(&mut v[i]);\n-                self.panic_flag = false;\n-                // Update the index *after* the predicate is called. If the index\n-                // is updated prior and the predicate panics, the element at this\n-                // index would be leaked.\n-                self.idx += 1;\n-                if drained {\n-                    self.del += 1;\n-                    return Some(ptr::read(&v[i]));\n-                } else if self.del > 0 {\n-                    let del = self.del;\n-                    let src: *const T = &v[i];\n-                    let dst: *mut T = &mut v[i - del];\n-                    ptr::copy_nonoverlapping(src, dst, 1);\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.old_len - self.idx))\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    fn drop(&mut self) {\n-        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            drain: &'b mut DrainFilter<'a, T, F, A>,\n-        }\n-\n-        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            fn drop(&mut self) {\n-                unsafe {\n-                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n-                        // This is a pretty messed up state, and there isn't really an\n-                        // obviously right thing to do. We don't want to keep trying\n-                        // to execute `pred`, so we just backshift all the unprocessed\n-                        // elements and tell the vec that they still exist. The backshift\n-                        // is required to prevent a double-drop of the last successfully\n-                        // drained item prior to a panic in the predicate.\n-                        let ptr = self.drain.vec.as_mut_ptr();\n-                        let src = ptr.add(self.drain.idx);\n-                        let dst = src.sub(self.drain.del);\n-                        let tail_len = self.drain.old_len - self.drain.idx;\n-                        src.copy_to(dst, tail_len);\n-                    }\n-                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n-                }\n-            }\n-        }\n-\n-        let backshift = BackshiftOnDrop { drain: self };\n-\n-        // Attempt to consume any remaining elements if the filter predicate\n-        // has not yet panicked. We'll backshift any remaining elements\n-        // whether we've already panicked or if the consumption here panics.\n-        if !backshift.drain.panic_flag {\n-            backshift.drain.for_each(drop);\n-        }\n-    }\n-}"}]}