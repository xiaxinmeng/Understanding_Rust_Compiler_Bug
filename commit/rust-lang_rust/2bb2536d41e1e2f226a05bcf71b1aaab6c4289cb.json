{"sha": "2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYjI1MzZkNDFlMWUyZjIyNmEwNWJjZjcxYjFhYWFiNmM0Mjg5Y2I=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-24T19:29:46Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-24T19:29:46Z"}, "message": "Merge pull request #4281 from Dretch/io-explicit-self\n\nConvert core::io to use explicit self (for issue #4118 and issue #2004)", "tree": {"sha": "e6f2312b5994336071e7be867d2360b7a80ecfa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6f2312b5994336071e7be867d2360b7a80ecfa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb", "html_url": "https://github.com/rust-lang/rust/commit/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6960edf071053237e4608a3bf2a423d75ff6dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6960edf071053237e4608a3bf2a423d75ff6dc", "html_url": "https://github.com/rust-lang/rust/commit/cd6960edf071053237e4608a3bf2a423d75ff6dc"}, {"sha": "feff3a9c6ccd83d1007d9d04fafe37788d20f548", "url": "https://api.github.com/repos/rust-lang/rust/commits/feff3a9c6ccd83d1007d9d04fafe37788d20f548", "html_url": "https://github.com/rust-lang/rust/commit/feff3a9c6ccd83d1007d9d04fafe37788d20f548"}], "stats": {"total": 374, "additions": 184, "deletions": 190}, "files": [{"sha": "5331019e5f33519b00c27523b371d8a97d0c0fbc", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb", "patch": "@@ -188,11 +188,11 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n }\n \n \n-impl &SipState : io::Writer {\n+impl SipState : io::Writer {\n \n     // Methods for io::writer\n     #[inline(always)]\n-    fn write(msg: &[const u8]) {\n+    fn write(&self, msg: &[const u8]) {\n \n         macro_rules! u8to64_le (\n             ($buf:expr, $i:expr) =>\n@@ -282,16 +282,16 @@ impl &SipState : io::Writer {\n         self.ntail = left;\n     }\n \n-    fn seek(_x: int, _s: io::SeekStyle) {\n+    fn seek(&self, _x: int, _s: io::SeekStyle) {\n         fail;\n     }\n-    fn tell() -> uint {\n+    fn tell(&self) -> uint {\n         self.length\n     }\n-    fn flush() -> int {\n+    fn flush(&self) -> int {\n         0\n     }\n-    fn get_type() -> io::WriterType {\n+    fn get_type(&self) -> io::WriterType {\n         io::File\n     }\n }"}, {"sha": "e76eb9f2f99d81265d4e4e1ba54df577b9fa74d7", "filename": "src/libcore/io.rs", "status": "modified", "additions": 163, "deletions": 169, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb", "patch": "@@ -49,122 +49,122 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n \n     /// Read a single byte, returning a negative value for EOF or read error.\n-    fn read_byte() -> int;\n+    fn read_byte(&self) -> int;\n \n     /// Return whether the stream is currently at EOF position.\n-    fn eof() -> bool;\n+    fn eof(&self) -> bool;\n \n     /// Move the current position within the stream. The second parameter\n     /// determines the position that the first parameter is relative to.\n-    fn seek(position: int, style: SeekStyle);\n+    fn seek(&self, position: int, style: SeekStyle);\n \n     /// Return the current position within the stream.\n-    fn tell() -> uint;\n+    fn tell(&self) -> uint;\n }\n \n /// Generic utility functions defined on readers.\n pub trait ReaderUtil {\n \n     /// Read len bytes into a new vec.\n-    fn read_bytes(len: uint) -> ~[u8];\n+    fn read_bytes(&self, len: uint) -> ~[u8];\n \n     /// Read up until the first '\\n' char (which is not returned), or EOF.\n-    fn read_line() -> ~str;\n+    fn read_line(&self) -> ~str;\n \n     /// Read n utf-8 encoded chars.\n-    fn read_chars(n: uint) -> ~[char];\n+    fn read_chars(&self, n: uint) -> ~[char];\n \n     /// Read a single utf-8 encoded char.\n-    fn read_char() -> char;\n+    fn read_char(&self) -> char;\n \n     /// Read up until the first null byte (which is not returned), or EOF.\n-    fn read_c_str() -> ~str;\n+    fn read_c_str(&self) -> ~str;\n \n     /// Read all the data remaining in the stream in one go.\n-    fn read_whole_stream() -> ~[u8];\n+    fn read_whole_stream(&self) -> ~[u8];\n \n     /// Iterate over every byte until the iterator breaks or EOF.\n-    fn each_byte(it: fn(int) -> bool);\n+    fn each_byte(&self, it: fn(int) -> bool);\n \n     /// Iterate over every char until the iterator breaks or EOF.\n-    fn each_char(it: fn(char) -> bool);\n+    fn each_char(&self, it: fn(char) -> bool);\n \n     /// Iterate over every line until the iterator breaks or EOF.\n-    fn each_line(it: fn(&str) -> bool);\n+    fn each_line(&self, it: fn(&str) -> bool);\n \n     /// Read n (between 1 and 8) little-endian unsigned integer bytes.\n-    fn read_le_uint_n(nbytes: uint) -> u64;\n+    fn read_le_uint_n(&self, nbytes: uint) -> u64;\n \n     /// Read n (between 1 and 8) little-endian signed integer bytes.\n-    fn read_le_int_n(nbytes: uint) -> i64;\n+    fn read_le_int_n(&self, nbytes: uint) -> i64;\n \n     /// Read n (between 1 and 8) big-endian unsigned integer bytes.\n-    fn read_be_uint_n(nbytes: uint) -> u64;\n+    fn read_be_uint_n(&self, nbytes: uint) -> u64;\n \n     /// Read n (between 1 and 8) big-endian signed integer bytes.\n-    fn read_be_int_n(nbytes: uint) -> i64;\n+    fn read_be_int_n(&self, nbytes: uint) -> i64;\n \n     /// Read a little-endian uint (number of bytes depends on system).\n-    fn read_le_uint() -> uint;\n+    fn read_le_uint(&self) -> uint;\n \n     /// Read a little-endian int (number of bytes depends on system).\n-    fn read_le_int() -> int;\n+    fn read_le_int(&self) -> int;\n \n     /// Read a big-endian uint (number of bytes depends on system).\n-    fn read_be_uint() -> uint;\n+    fn read_be_uint(&self) -> uint;\n \n     /// Read a big-endian int (number of bytes depends on system).\n-    fn read_be_int() -> int;\n+    fn read_be_int(&self) -> int;\n \n     /// Read a big-endian u64 (8 bytes).\n-    fn read_be_u64() -> u64;\n+    fn read_be_u64(&self) -> u64;\n \n     /// Read a big-endian u32 (4 bytes).\n-    fn read_be_u32() -> u32;\n+    fn read_be_u32(&self) -> u32;\n \n     /// Read a big-endian u16 (2 bytes).\n-    fn read_be_u16() -> u16;\n+    fn read_be_u16(&self) -> u16;\n \n     /// Read a big-endian i64 (8 bytes).\n-    fn read_be_i64() -> i64;\n+    fn read_be_i64(&self) -> i64;\n \n     /// Read a big-endian i32 (4 bytes).\n-    fn read_be_i32() -> i32;\n+    fn read_be_i32(&self) -> i32;\n \n     /// Read a big-endian i16 (2 bytes).\n-    fn read_be_i16() -> i16;\n+    fn read_be_i16(&self) -> i16;\n \n     /// Read a little-endian u64 (8 bytes).\n-    fn read_le_u64() -> u64;\n+    fn read_le_u64(&self) -> u64;\n \n     /// Read a little-endian u32 (4 bytes).\n-    fn read_le_u32() -> u32;\n+    fn read_le_u32(&self) -> u32;\n \n     /// Read a little-endian u16 (2 bytes).\n-    fn read_le_u16() -> u16;\n+    fn read_le_u16(&self) -> u16;\n \n     /// Read a litle-endian i64 (8 bytes).\n-    fn read_le_i64() -> i64;\n+    fn read_le_i64(&self) -> i64;\n \n     /// Read a litle-endian i32 (4 bytes).\n-    fn read_le_i32() -> i32;\n+    fn read_le_i32(&self) -> i32;\n \n     /// Read a litle-endian i16 (2 bytes).\n-    fn read_le_i16() -> i16;\n+    fn read_le_i16(&self) -> i16;\n \n     /// Read a u8 (1 byte).\n-    fn read_u8() -> u8;\n+    fn read_u8(&self) -> u8;\n \n     /// Read a i8 (1 byte).\n-    fn read_i8() -> i8;\n+    fn read_i8(&self) -> i8;\n }\n \n impl<T: Reader> T : ReaderUtil {\n \n-    fn read_bytes(len: uint) -> ~[u8] {\n+    fn read_bytes(&self,len: uint) -> ~[u8] {\n         let mut bytes = vec::with_capacity(len);\n         unsafe { vec::raw::set_len(&mut bytes, len); }\n \n@@ -174,7 +174,7 @@ impl<T: Reader> T : ReaderUtil {\n         move bytes\n     }\n \n-    fn read_line() -> ~str {\n+    fn read_line(&self) -> ~str {\n         let mut bytes = ~[];\n         loop {\n             let ch = self.read_byte();\n@@ -184,7 +184,7 @@ impl<T: Reader> T : ReaderUtil {\n         str::from_bytes(bytes)\n     }\n \n-    fn read_chars(n: uint) -> ~[char] {\n+    fn read_chars(&self, n: uint) -> ~[char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n         fn chars_from_bytes<T: Reader>(bytes: &~[u8], chars: &mut ~[char])\n             -> (uint, uint) {\n@@ -245,7 +245,7 @@ impl<T: Reader> T : ReaderUtil {\n         move chars\n     }\n \n-    fn read_char() -> char {\n+    fn read_char(&self) -> char {\n         let c = self.read_chars(1);\n         if vec::len(c) == 0 {\n             return -1 as char; // FIXME will this stay valid? // #2004\n@@ -254,7 +254,7 @@ impl<T: Reader> T : ReaderUtil {\n         return c[0];\n     }\n \n-    fn read_c_str() -> ~str {\n+    fn read_c_str(&self) -> ~str {\n         let mut bytes: ~[u8] = ~[];\n         loop {\n             let ch = self.read_byte();\n@@ -263,33 +263,33 @@ impl<T: Reader> T : ReaderUtil {\n         str::from_bytes(bytes)\n     }\n \n-    fn read_whole_stream() -> ~[u8] {\n+    fn read_whole_stream(&self) -> ~[u8] {\n         let mut bytes: ~[u8] = ~[];\n         while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n         move bytes\n     }\n \n-    fn each_byte(it: fn(int) -> bool) {\n+    fn each_byte(&self, it: fn(int) -> bool) {\n         while !self.eof() {\n             if !it(self.read_byte()) { break; }\n         }\n     }\n \n-    fn each_char(it: fn(char) -> bool) {\n+    fn each_char(&self, it: fn(char) -> bool) {\n         while !self.eof() {\n             if !it(self.read_char()) { break; }\n         }\n     }\n \n-    fn each_line(it: fn(s: &str) -> bool) {\n+    fn each_line(&self, it: fn(s: &str) -> bool) {\n         while !self.eof() {\n             if !it(self.read_line()) { break; }\n         }\n     }\n \n     // FIXME int reading methods need to deal with eof - issue #2004\n \n-    fn read_le_uint_n(nbytes: uint) -> u64 {\n+    fn read_le_uint_n(&self, nbytes: uint) -> u64 {\n         assert nbytes > 0 && nbytes <= 8;\n \n         let mut val = 0u64, pos = 0, i = nbytes;\n@@ -301,11 +301,11 @@ impl<T: Reader> T : ReaderUtil {\n         val\n     }\n \n-    fn read_le_int_n(nbytes: uint) -> i64 {\n+    fn read_le_int_n(&self, nbytes: uint) -> i64 {\n         extend_sign(self.read_le_uint_n(nbytes), nbytes)\n     }\n \n-    fn read_be_uint_n(nbytes: uint) -> u64 {\n+    fn read_be_uint_n(&self, nbytes: uint) -> u64 {\n         assert nbytes > 0 && nbytes <= 8;\n \n         let mut val = 0u64, i = nbytes;\n@@ -316,79 +316,79 @@ impl<T: Reader> T : ReaderUtil {\n         val\n     }\n \n-    fn read_be_int_n(nbytes: uint) -> i64 {\n+    fn read_be_int_n(&self, nbytes: uint) -> i64 {\n         extend_sign(self.read_be_uint_n(nbytes), nbytes)\n     }\n \n-    fn read_le_uint() -> uint {\n+    fn read_le_uint(&self) -> uint {\n         self.read_le_uint_n(uint::bytes) as uint\n     }\n \n-    fn read_le_int() -> int {\n+    fn read_le_int(&self) -> int {\n         self.read_le_int_n(int::bytes) as int\n     }\n \n-    fn read_be_uint() -> uint {\n+    fn read_be_uint(&self) -> uint {\n         self.read_be_uint_n(uint::bytes) as uint\n     }\n \n-    fn read_be_int() -> int {\n+    fn read_be_int(&self) -> int {\n         self.read_be_int_n(int::bytes) as int\n     }\n \n-    fn read_be_u64() -> u64 {\n+    fn read_be_u64(&self) -> u64 {\n         self.read_be_uint_n(8) as u64\n     }\n \n-    fn read_be_u32() -> u32 {\n+    fn read_be_u32(&self) -> u32 {\n         self.read_be_uint_n(4) as u32\n     }\n \n-    fn read_be_u16() -> u16 {\n+    fn read_be_u16(&self) -> u16 {\n         self.read_be_uint_n(2) as u16\n     }\n \n-    fn read_be_i64() -> i64 {\n+    fn read_be_i64(&self) -> i64 {\n         self.read_be_int_n(8) as i64\n     }\n \n-    fn read_be_i32() -> i32 {\n+    fn read_be_i32(&self) -> i32 {\n         self.read_be_int_n(4) as i32\n     }\n \n-    fn read_be_i16() -> i16 {\n+    fn read_be_i16(&self) -> i16 {\n         self.read_be_int_n(2) as i16\n     }\n \n-    fn read_le_u64() -> u64 {\n+    fn read_le_u64(&self) -> u64 {\n         self.read_le_uint_n(8) as u64\n     }\n \n-    fn read_le_u32() -> u32 {\n+    fn read_le_u32(&self) -> u32 {\n         self.read_le_uint_n(4) as u32\n     }\n \n-    fn read_le_u16() -> u16 {\n+    fn read_le_u16(&self) -> u16 {\n         self.read_le_uint_n(2) as u16\n     }\n \n-    fn read_le_i64() -> i64 {\n+    fn read_le_i64(&self) -> i64 {\n         self.read_le_int_n(8) as i64\n     }\n \n-    fn read_le_i32() -> i32 {\n+    fn read_le_i32(&self) -> i32 {\n         self.read_le_int_n(4) as i32\n     }\n \n-    fn read_le_i16() -> i16 {\n+    fn read_le_i16(&self) -> i16 {\n         self.read_le_int_n(2) as i16\n     }\n \n-    fn read_u8() -> u8 {\n+    fn read_u8(&self) -> u8 {\n         self.read_byte() as u8\n     }\n \n-    fn read_i8() -> i8 {\n+    fn read_i8(&self) -> i8 {\n         self.read_byte() as i8\n     }\n }\n@@ -409,36 +409,38 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n }\n \n impl *libc::FILE: Reader {\n-    fn read(bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n         do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n             assert buf_len >= len;\n \n             let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n-                                    len as size_t, self);\n+                                    len as size_t, *self);\n \n             count as uint\n         }\n     }\n-    fn read_byte() -> int { return libc::fgetc(self) as int; }\n-    fn eof() -> bool { return libc::feof(self) != 0 as c_int; }\n-    fn seek(offset: int, whence: SeekStyle) {\n-        assert libc::fseek(self, offset as c_long, convert_whence(whence))\n+    fn read_byte(&self) -> int { return libc::fgetc(*self) as int; }\n+    fn eof(&self) -> bool { return libc::feof(*self) != 0 as c_int; }\n+    fn seek(&self, offset: int, whence: SeekStyle) {\n+        assert libc::fseek(*self, offset as c_long, convert_whence(whence))\n             == 0 as c_int;\n     }\n-    fn tell() -> uint { return libc::ftell(self) as uint; }\n+    fn tell(&self) -> uint { return libc::ftell(*self) as uint; }\n }\n \n // A forwarding impl of reader that also holds on to a resource for the\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl<T: Reader, C> {base: T, cleanup: C}: Reader {\n-    fn read(bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n         self.base.read(bytes, len)\n     }\n-    fn read_byte() -> int { self.base.read_byte() }\n-    fn eof() -> bool { self.base.eof() }\n-    fn seek(off: int, whence: SeekStyle) { self.base.seek(off, whence) }\n-    fn tell() -> uint { self.base.tell() }\n+    fn read_byte(&self) -> int { self.base.read_byte() }\n+    fn eof(&self) -> bool { self.base.eof() }\n+    fn seek(&self, off: int, whence: SeekStyle) {\n+        self.base.seek(off, whence)\n+    }\n+    fn tell(&self) -> uint { self.base.tell() }\n }\n \n struct FILERes {\n@@ -487,7 +489,7 @@ pub struct BytesReader {\n }\n \n impl BytesReader: Reader {\n-    fn read(bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - self.pos);\n \n         let view = vec::view(self.bytes, self.pos, self.bytes.len());\n@@ -497,18 +499,18 @@ impl BytesReader: Reader {\n \n         count\n     }\n-    fn read_byte() -> int {\n+    fn read_byte(&self) -> int {\n         if self.pos == self.bytes.len() { return -1; }\n         let b = self.bytes[self.pos];\n         self.pos += 1u;\n         return b as int;\n     }\n-    fn eof() -> bool { self.pos == self.bytes.len() }\n-    fn seek(offset: int, whence: SeekStyle) {\n+    fn eof(&self) -> bool { self.pos == self.bytes.len() }\n+    fn seek(&self, offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n         self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n     }\n-    fn tell() -> uint { self.pos }\n+    fn tell(&self) -> uint { self.pos }\n }\n \n pub pure fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n@@ -532,49 +534,49 @@ pub enum WriterType { Screen, File }\n pub trait Writer {\n \n     /// Write all of the given bytes.\n-    fn write(v: &[const u8]);\n+    fn write(&self, v: &[const u8]);\n \n     /// Move the current position within the stream. The second parameter\n     /// determines the position that the first parameter is relative to.\n-    fn seek(int, SeekStyle);\n+    fn seek(&self, int, SeekStyle);\n \n     /// Return the current position within the stream.\n-    fn tell() -> uint;\n+    fn tell(&self) -> uint;\n \n     /// Flush the output buffer for this stream (if there is one).\n-    fn flush() -> int;\n+    fn flush(&self) -> int;\n \n     /// Determine if this Writer is writing to a file or not.\n-    fn get_type() -> WriterType;\n+    fn get_type(&self) -> WriterType;\n }\n \n impl<T: Writer, C> {base: T, cleanup: C}: Writer {\n-    fn write(bs: &[const u8]) { self.base.write(bs); }\n-    fn seek(off: int, style: SeekStyle) { self.base.seek(off, style); }\n-    fn tell() -> uint { self.base.tell() }\n-    fn flush() -> int { self.base.flush() }\n-    fn get_type() -> WriterType { File }\n+    fn write(&self, bs: &[const u8]) { self.base.write(bs); }\n+    fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n+    fn tell(&self) -> uint { self.base.tell() }\n+    fn flush(&self) -> int { self.base.flush() }\n+    fn get_type(&self) -> WriterType { File }\n }\n \n impl *libc::FILE: Writer {\n-    fn write(v: &[const u8]) {\n+    fn write(&self, v: &[const u8]) {\n         do vec::as_const_buf(v) |vbuf, len| {\n-            let nout = libc::fwrite(vbuf as *c_void, 1, len as size_t, self);\n+            let nout = libc::fwrite(vbuf as *c_void, 1, len as size_t, *self);\n             if nout != len as size_t {\n                 error!(\"error writing buffer\");\n                 log(error, os::last_os_error());\n                 fail;\n             }\n         }\n     }\n-    fn seek(offset: int, whence: SeekStyle) {\n-        assert libc::fseek(self, offset as c_long, convert_whence(whence))\n+    fn seek(&self, offset: int, whence: SeekStyle) {\n+        assert libc::fseek(*self, offset as c_long, convert_whence(whence))\n             == 0 as c_int;\n     }\n-    fn tell() -> uint { libc::ftell(self) as uint }\n-    fn flush() -> int { libc::fflush(self) as int }\n-    fn get_type() -> WriterType {\n-        let fd = libc::fileno(self);\n+    fn tell(&self) -> uint { libc::ftell(*self) as uint }\n+    fn flush(&self) -> int { libc::fflush(*self) as int }\n+    fn get_type(&self) -> WriterType {\n+        let fd = libc::fileno(*self);\n         if libc::isatty(fd) == 0 { File   }\n         else                     { Screen }\n     }\n@@ -589,12 +591,12 @@ pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n }\n \n impl fd_t: Writer {\n-    fn write(v: &[const u8]) {\n+    fn write(&self, v: &[const u8]) {\n         let mut count = 0u;\n         do vec::as_const_buf(v) |vbuf, len| {\n             while count < len {\n                 let vb = ptr::const_offset(vbuf, count) as *c_void;\n-                let nout = libc::write(self, vb, len as size_t);\n+                let nout = libc::write(*self, vb, len as size_t);\n                 if nout < 0 as ssize_t {\n                     error!(\"error writing buffer\");\n                     log(error, os::last_os_error());\n@@ -604,17 +606,17 @@ impl fd_t: Writer {\n             }\n         }\n     }\n-    fn seek(_offset: int, _whence: SeekStyle) {\n+    fn seek(&self, _offset: int, _whence: SeekStyle) {\n         error!(\"need 64-bit foreign calls for seek, sorry\");\n         fail;\n     }\n-    fn tell() -> uint {\n+    fn tell(&self) -> uint {\n         error!(\"need 64-bit foreign calls for tell, sorry\");\n         fail;\n     }\n-    fn flush() -> int { 0 }\n-    fn get_type() -> WriterType {\n-        if libc::isatty(self) == 0 { File } else { Screen }\n+    fn flush(&self) -> int { 0 }\n+    fn get_type(&self) -> WriterType {\n+        if libc::isatty(*self) == 0 { File } else { Screen }\n     }\n }\n \n@@ -752,145 +754,145 @@ pub fn u64_from_be_bytes(data: &[const u8],\n pub trait WriterUtil {\n \n     /// Write a single utf-8 encoded char.\n-    fn write_char(ch: char);\n+    fn write_char(&self, ch: char);\n \n     /// Write every char in the given str, encoded as utf-8.\n-    fn write_str(s: &str);\n+    fn write_str(&self, s: &str);\n \n     /// Write the given str, as utf-8, followed by '\\n'.\n-    fn write_line(s: &str);\n+    fn write_line(&self, s: &str);\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n-    fn write_int(n: int);\n+    fn write_int(&self, n: int);\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n-    fn write_uint(n: uint);\n+    fn write_uint(&self, n: uint);\n \n     /// Write a little-endian uint (number of bytes depends on system).\n-    fn write_le_uint(n: uint);\n+    fn write_le_uint(&self, n: uint);\n \n     /// Write a little-endian int (number of bytes depends on system).\n-    fn write_le_int(n: int);\n+    fn write_le_int(&self, n: int);\n \n     /// Write a big-endian uint (number of bytes depends on system).\n-    fn write_be_uint(n: uint);\n+    fn write_be_uint(&self, n: uint);\n \n     /// Write a big-endian int (number of bytes depends on system).\n-    fn write_be_int(n: int);\n+    fn write_be_int(&self, n: int);\n \n     /// Write a big-endian u64 (8 bytes).\n-    fn write_be_u64(n: u64);\n+    fn write_be_u64(&self, n: u64);\n \n     /// Write a big-endian u32 (4 bytes).\n-    fn write_be_u32(n: u32);\n+    fn write_be_u32(&self, n: u32);\n \n     /// Write a big-endian u16 (2 bytes).\n-    fn write_be_u16(n: u16);\n+    fn write_be_u16(&self, n: u16);\n \n     /// Write a big-endian i64 (8 bytes).\n-    fn write_be_i64(n: i64);\n+    fn write_be_i64(&self, n: i64);\n \n     /// Write a big-endian i32 (4 bytes).\n-    fn write_be_i32(n: i32);\n+    fn write_be_i32(&self, n: i32);\n \n     /// Write a big-endian i16 (2 bytes).\n-    fn write_be_i16(n: i16);\n+    fn write_be_i16(&self, n: i16);\n \n     /// Write a little-endian u64 (8 bytes).\n-    fn write_le_u64(n: u64);\n+    fn write_le_u64(&self, n: u64);\n \n     /// Write a little-endian u32 (4 bytes).\n-    fn write_le_u32(n: u32);\n+    fn write_le_u32(&self, n: u32);\n \n     /// Write a little-endian u16 (2 bytes).\n-    fn write_le_u16(n: u16);\n+    fn write_le_u16(&self, n: u16);\n \n     /// Write a little-endian i64 (8 bytes).\n-    fn write_le_i64(n: i64);\n+    fn write_le_i64(&self, n: i64);\n \n     /// Write a little-endian i32 (4 bytes).\n-    fn write_le_i32(n: i32);\n+    fn write_le_i32(&self, n: i32);\n \n     /// Write a little-endian i16 (2 bytes).\n-    fn write_le_i16(n: i16);\n+    fn write_le_i16(&self, n: i16);\n \n     /// Write a u8 (1 byte).\n-    fn write_u8(n: u8);\n+    fn write_u8(&self, n: u8);\n \n     /// Write a i8 (1 byte).\n-    fn write_i8(n: i8);\n+    fn write_i8(&self, n: i8);\n }\n \n impl<T: Writer> T : WriterUtil {\n-    fn write_char(ch: char) {\n+    fn write_char(&self, ch: char) {\n         if ch as uint < 128u {\n             self.write(&[ch as u8]);\n         } else {\n             self.write_str(str::from_char(ch));\n         }\n     }\n-    fn write_str(s: &str) { str::byte_slice(s, |v| self.write(v)) }\n-    fn write_line(s: &str) {\n+    fn write_str(&self, s: &str) { str::byte_slice(s, |v| self.write(v)) }\n+    fn write_line(&self, s: &str) {\n         self.write_str(s);\n         self.write_str(&\"\\n\");\n     }\n-    fn write_int(n: int) {\n+    fn write_int(&self, n: int) {\n         int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n-    fn write_uint(n: uint) {\n+    fn write_uint(&self, n: uint) {\n         uint::to_str_bytes(false, n, 10u, |bytes| self.write(bytes))\n     }\n-    fn write_le_uint(n: uint) {\n+    fn write_le_uint(&self, n: uint) {\n         u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n     }\n-    fn write_le_int(n: int) {\n+    fn write_le_int(&self, n: int) {\n         u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n     }\n-    fn write_be_uint(n: uint) {\n+    fn write_be_uint(&self, n: uint) {\n         u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n     }\n-    fn write_be_int(n: int) {\n+    fn write_be_int(&self, n: int) {\n         u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n     }\n-    fn write_be_u64(n: u64) {\n+    fn write_be_u64(&self, n: u64) {\n         u64_to_be_bytes(n, 8u, |v| self.write(v))\n     }\n-    fn write_be_u32(n: u32) {\n+    fn write_be_u32(&self, n: u32) {\n         u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n-    fn write_be_u16(n: u16) {\n+    fn write_be_u16(&self, n: u16) {\n         u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n-    fn write_be_i64(n: i64) {\n+    fn write_be_i64(&self, n: i64) {\n         u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n     }\n-    fn write_be_i32(n: i32) {\n+    fn write_be_i32(&self, n: i32) {\n         u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n-    fn write_be_i16(n: i16) {\n+    fn write_be_i16(&self, n: i16) {\n         u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n-    fn write_le_u64(n: u64) {\n+    fn write_le_u64(&self, n: u64) {\n         u64_to_le_bytes(n, 8u, |v| self.write(v))\n     }\n-    fn write_le_u32(n: u32) {\n+    fn write_le_u32(&self, n: u32) {\n         u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n-    fn write_le_u16(n: u16) {\n+    fn write_le_u16(&self, n: u16) {\n         u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n-    fn write_le_i64(n: i64) {\n+    fn write_le_i64(&self, n: i64) {\n         u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n     }\n-    fn write_le_i32(n: i32) {\n+    fn write_le_i32(&self, n: i32) {\n         u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n-    fn write_le_i16(n: i16) {\n+    fn write_le_i16(&self, n: i16) {\n         u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n-    fn write_u8(n: u8) { self.write([n]) }\n-    fn write_i8(n: i8) { self.write([n as u8]) }\n+    fn write_u8(&self, n: u8) { self.write([n]) }\n+    fn write_i8(&self, n: i8) { self.write([n as u8]) }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n@@ -926,7 +928,7 @@ pub struct BytesWriter {\n }\n \n impl BytesWriter: Writer {\n-    fn write(v: &[const u8]) {\n+    fn write(&self, v: &[const u8]) {\n         do self.bytes.swap |bytes| {\n             let mut bytes = move bytes;\n             let v_len = v.len();\n@@ -946,22 +948,14 @@ impl BytesWriter: Writer {\n             move bytes\n         }\n     }\n-    fn seek(offset: int, whence: SeekStyle) {\n+    fn seek(&self, offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n         let len = self.bytes.len();\n         self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n-    fn tell() -> uint { self.pos }\n-    fn flush() -> int { 0 }\n-    fn get_type() -> WriterType { File }\n-}\n-\n-impl @BytesWriter : Writer {\n-    fn write(v: &[const u8]) { (*self).write(v) }\n-    fn seek(offset: int, whence: SeekStyle) { (*self).seek(offset, whence) }\n-    fn tell() -> uint { (*self).tell() }\n-    fn flush() -> int { (*self).flush() }\n-    fn get_type() -> WriterType { (*self).get_type() }\n+    fn tell(&self) -> uint { self.pos }\n+    fn flush(&self) -> int { 0 }\n+    fn get_type(&self) -> WriterType { File }\n }\n \n pub pure fn BytesWriter() -> BytesWriter {\n@@ -1091,7 +1085,7 @@ pub mod fsync {\n     }\n \n     // Type of objects that may want to fsync\n-    pub trait FSyncable { fn fsync(l: Level) -> int; }\n+    pub trait FSyncable { fn fsync(&self, l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n     pub fn obj_sync(o: FSyncable, opt_level: Option<Level>,"}, {"sha": "1617641afe36625e0586d6eebefea5924d7f10b0", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb", "patch": "@@ -646,19 +646,19 @@ mod util {\n     }\n \n     impl BufReader: Reader {\n-        fn read(bytes: &[mut u8], len: uint) -> uint {\n+        fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n             self.as_bytes_reader(|r| r.read(bytes, len) )\n         }\n-        fn read_byte() -> int {\n+        fn read_byte(&self) -> int {\n             self.as_bytes_reader(|r| r.read_byte() )\n         }\n-        fn eof() -> bool {\n+        fn eof(&self) -> bool {\n             self.as_bytes_reader(|r| r.eof() )\n         }\n-        fn seek(offset: int, whence: io::SeekStyle) {\n+        fn seek(&self, offset: int, whence: io::SeekStyle) {\n             self.as_bytes_reader(|r| r.seek(offset, whence) )\n         }\n-        fn tell() -> uint {\n+        fn tell(&self) -> uint {\n             self.as_bytes_reader(|r| r.tell() )\n         }\n     }"}, {"sha": "c888b457356b65f97e8501caf817106c928f0dd4", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=2bb2536d41e1e2f226a05bcf71b1aaab6c4289cb", "patch": "@@ -788,7 +788,7 @@ impl TcpSocket {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint {\n+    fn read(&self, buf: &[mut u8], len: uint) -> uint {\n         // Loop until our buffer has enough data in it for us to read from.\n         while self.data.buf.len() < len {\n             let read_result = read(&self.data.sock, 0u);\n@@ -821,7 +821,7 @@ impl TcpSocketBuf: io::Reader {\n \n         count\n     }\n-    fn read_byte() -> int {\n+    fn read_byte(&self) -> int {\n         let mut bytes = ~[0];\n         if self.read(bytes, 1u) == 0 {\n             if self.end_of_stream {\n@@ -833,21 +833,21 @@ impl TcpSocketBuf: io::Reader {\n             bytes[0] as int\n         }\n     }\n-    fn eof() -> bool {\n+    fn eof(&self) -> bool {\n         self.end_of_stream\n     }\n-    fn seek(dist: int, seek: io::SeekStyle) {\n+    fn seek(&self, dist: int, seek: io::SeekStyle) {\n         log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n-    fn tell() -> uint {\n+    fn tell(&self) -> uint {\n         0u // noop\n     }\n }\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Writer {\n-    pub fn write(data: &[const u8]) unsafe {\n+    pub fn write(&self, data: &[const u8]) unsafe {\n         let socket_data_ptr =\n             ptr::addr_of(&(*((*(self.data)).sock).socket_data));\n         let w_result = write_common_impl(socket_data_ptr,\n@@ -858,17 +858,17 @@ impl TcpSocketBuf: io::Writer {\n                              err_data.err_name, err_data.err_msg));\n         }\n     }\n-    fn seek(dist: int, seek: io::SeekStyle) {\n+    fn seek(&self, dist: int, seek: io::SeekStyle) {\n       log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n-    fn tell() -> uint {\n+    fn tell(&self) -> uint {\n         0u\n     }\n-    fn flush() -> int {\n+    fn flush(&self) -> int {\n         0\n     }\n-    fn get_type() -> io::WriterType {\n+    fn get_type(&self) -> io::WriterType {\n         io::File\n     }\n }"}]}