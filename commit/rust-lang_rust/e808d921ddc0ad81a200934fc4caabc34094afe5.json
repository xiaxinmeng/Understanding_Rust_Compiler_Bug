{"sha": "e808d921ddc0ad81a200934fc4caabc34094afe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MDhkOTIxZGRjMGFkODFhMjAwOTM0ZmM0Y2FhYmMzNDA5NGFmZTU=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-07-05T09:38:40Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-07-05T09:49:30Z"}, "message": "Replace SliceConcatExt trait with inherent methods and SliceConcat helper trait\n\nBefore this change `SliceConcatExt` was an unstable extension trait\nwith stable methods. It was in the libstd prelude, so that its methods\ncould be used on the stable channel.\n\nThis replaces it with inherent methods,\nwhich can be used without any addition to the prelude.\nSince the methods are stable and very generic\n(with for example a return type that depends on the types of parameters),\nan helper trait is still needed.\nBut now that trait does not need to be in scope for the methods to be used.\n\nRemoving this depedency on the libstd prelude allows the methods to be used\nin `#![no_std]` crate that use liballoc, which does not have its own\nimplicitly-imported prelude.", "tree": {"sha": "865fc5b7072b659e512e13e616dcd2b5f193f9a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/865fc5b7072b659e512e13e616dcd2b5f193f9a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e808d921ddc0ad81a200934fc4caabc34094afe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e808d921ddc0ad81a200934fc4caabc34094afe5", "html_url": "https://github.com/rust-lang/rust/commit/e808d921ddc0ad81a200934fc4caabc34094afe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e808d921ddc0ad81a200934fc4caabc34094afe5/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baab1914ec9a9742776a8147780947b48fddf54d", "url": "https://api.github.com/repos/rust-lang/rust/commits/baab1914ec9a9742776a8147780947b48fddf54d", "html_url": "https://github.com/rust-lang/rust/commit/baab1914ec9a9742776a8147780947b48fddf54d"}], "stats": {"total": 150, "additions": 76, "deletions": 74}, "files": [{"sha": "3cb285bf0492f5ccf32252c89547bbe6f6232866", "filename": "src/liballoc/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=e808d921ddc0ad81a200934fc4caabc34094afe5", "patch": "@@ -6,6 +6,5 @@\n \n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::slice::SliceConcatExt;\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;"}, {"sha": "bc4ae167984785a3d1e925f1cc6fedb26b70230d", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 69, "deletions": 60, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=e808d921ddc0ad81a200934fc4caabc34094afe5", "patch": "@@ -484,6 +484,56 @@ impl<T> [T] {\n         }\n         buf\n     }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n+    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn concat<Separator: ?Sized>(&self) -> T::Output\n+        where T: SliceConcat<Separator>\n+    {\n+        SliceConcat::concat(self)\n+    }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n+    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n+    pub fn join<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n+        where T: SliceConcat<Separator>\n+    {\n+        SliceConcat::join(self, sep)\n+    }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![allow(deprecated)]\n+    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n+    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n+    pub fn connect<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n+        where T: SliceConcat<Separator>\n+    {\n+        SliceConcat::join(self, sep)\n+    }\n+\n }\n \n #[lang = \"slice_u8_alloc\"]\n@@ -527,87 +577,46 @@ impl [u8] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-/// An extension trait for concatenating slices\n-///\n-/// While this trait is unstable, the methods are stable. `SliceConcatExt` is\n-/// included in the [standard library prelude], so you can use [`join()`] and\n-/// [`concat()`] as if they existed on `[T]` itself.\n-///\n-/// [standard library prelude]: ../../std/prelude/index.html\n-/// [`join()`]: #tymethod.join\n-/// [`concat()`]: #tymethod.concat\n-pub trait SliceConcatExt<T: ?Sized> {\n-    #[unstable(feature = \"slice_concat_ext\",\n-               reason = \"trait should not have to exist\",\n-               issue = \"27747\")]\n+\n+/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n+/// and [`[T]::join`](../../std/primitive.slice.html#method.join)\n+#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+pub trait SliceConcat<Separator: ?Sized>: Sized {\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n     /// The resulting type after concatenation\n     type Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n-    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn concat(&self) -> Self::Output;\n-\n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n-    /// given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n-    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n-    fn join(&self, sep: &T) -> Self::Output;\n+    /// Implementation of [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    fn concat(slice: &[Self]) -> Self::Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n-    /// given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n-    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n-    fn connect(&self, sep: &T) -> Self::Output {\n-        self.join(sep)\n-    }\n+    /// Implementation of [`[T]::join`](../../std/primitive.slice.html#method.join)\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    fn join(slice: &[Self], sep: &Separator) -> Self::Output;\n }\n \n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\",\n            issue = \"27747\")]\n-impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n+impl<T: Clone, V: Borrow<[T]>> SliceConcat<T> for V {\n     type Output = Vec<T>;\n \n-    fn concat(&self) -> Vec<T> {\n-        let size = self.iter().map(|slice| slice.borrow().len()).sum();\n+    fn concat(slice: &[Self]) -> Vec<T> {\n+        let size = slice.iter().map(|slice| slice.borrow().len()).sum();\n         let mut result = Vec::with_capacity(size);\n-        for v in self {\n+        for v in slice {\n             result.extend_from_slice(v.borrow())\n         }\n         result\n     }\n \n-    fn join(&self, sep: &T) -> Vec<T> {\n-        let mut iter = self.iter();\n+    fn join(slice: &[Self], sep: &T) -> Vec<T> {\n+        let mut iter = slice.iter();\n         let first = match iter.next() {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = self.iter().map(|slice| slice.borrow().len()).sum::<usize>() + self.len() - 1;\n+        let size = slice.iter().map(|slice| slice.borrow().len()).sum::<usize>() + slice.len() - 1;\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n "}, {"sha": "37a1046d0942dd4370159b51babe387798d233fe", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=e808d921ddc0ad81a200934fc4caabc34094afe5", "patch": "@@ -37,7 +37,7 @@ use core::unicode::conversions;\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n-use crate::slice::{SliceConcatExt, SliceIndex};\n+use crate::slice::{SliceConcat, SliceIndex};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -74,16 +74,16 @@ pub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\",\n            issue = \"27747\")]\n-impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n+impl<S: Borrow<str>> SliceConcat<str> for S {\n     type Output = String;\n \n-    fn concat(&self) -> String {\n-        self.join(\"\")\n+    fn concat(slice: &[Self]) -> String {\n+        Self::join(slice, \"\")\n     }\n \n-    fn join(&self, sep: &str) -> String {\n+    fn join(slice: &[Self], sep: &str) -> String {\n         unsafe {\n-            String::from_utf8_unchecked( join_generic_copy(self, sep.as_bytes()) )\n+            String::from_utf8_unchecked( join_generic_copy(slice, sep.as_bytes()) )\n         }\n     }\n }\n@@ -126,7 +126,7 @@ macro_rules! copy_slice_and_advance {\n \n // Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n // Currently (2018-05-13) there is a bug with type inference and specialization (see issue #36262)\n-// For this reason SliceConcatExt<T> is not specialized for T: Copy and SliceConcatExt<str> is the\n+// For this reason SliceConcat<T> is not specialized for T: Copy and SliceConcat<str> is the\n // only user of this function. It is left in place for the time when that is fixed.\n //\n // the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>"}, {"sha": "3085c3d829653b0f6750f476e4a7666ac2be0bbe", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=e808d921ddc0ad81a200934fc4caabc34094afe5", "patch": "@@ -71,9 +71,6 @@\n //! * [`std::result`]::[`Result`]::{`self`, `Ok`, `Err`}. A type for functions\n //!   that may succeed or fail. Like [`Option`], its variants are exported as\n //!   well.\n-//! * [`std::slice`]::[`SliceConcatExt`], a trait that exists for technical\n-//!   reasons, but shouldn't have to exist. It provides a few useful methods on\n-//!   slices.\n //! * [`std::string`]::{[`String`], [`ToString`]}, heap allocated strings.\n //! * [`std::vec`]::[`Vec`](../vec/struct.Vec.html), a growable, heap-allocated\n //!   vector."}, {"sha": "a863bebf4a2648572b9a5abe6ffa62f906138312", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e808d921ddc0ad81a200934fc4caabc34094afe5/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=e808d921ddc0ad81a200934fc4caabc34094afe5", "patch": "@@ -60,9 +60,6 @@ pub use crate::boxed::Box;\n pub use crate::borrow::ToOwned;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::slice::SliceConcatExt;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n pub use crate::string::{String, ToString};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]"}]}