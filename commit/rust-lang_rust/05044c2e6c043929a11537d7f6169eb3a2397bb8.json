{"sha": "05044c2e6c043929a11537d7f6169eb3a2397bb8", "node_id": "C_kwDOAAsO6NoAKDA1MDQ0YzJlNmMwNDM5MjlhMTE1MzdkN2Y2MTY5ZWIzYTIzOTdiYjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-26T19:36:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-26T19:36:00Z"}, "message": "Auto merge of #89144 - sexxi-goose:insig_stdlib, r=nikomatsakis\n\n2229: Mark insignificant dtor in stdlib\n\nI looked at all public [stdlib Drop implementations](https://doc.rust-lang.org/stable/std/ops/trait.Drop.html#implementors) and categorized them into Insigificant/Maybe/Significant Drop.\n\nReasons are noted here: https://docs.google.com/spreadsheets/d/19edb9r5lo2UqMrCOVjV0fwcSdS-R7qvKNL76q7tO8VA/edit#gid=1838773501\n\nOne thing missing from this PR is tagging HashMap as insigificant destructor as that needs some discussion.\n\nr? `@Mark-Simulacrum`\n\ncc `@nikomatsakis`", "tree": {"sha": "ad74f466ebb0a828cf2ef5827c726e7fa41c7c3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad74f466ebb0a828cf2ef5827c726e7fa41c7c3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05044c2e6c043929a11537d7f6169eb3a2397bb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05044c2e6c043929a11537d7f6169eb3a2397bb8", "html_url": "https://github.com/rust-lang/rust/commit/05044c2e6c043929a11537d7f6169eb3a2397bb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05044c2e6c043929a11537d7f6169eb3a2397bb8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c09d6374324ee23cb5a4fe738f74369717dd642d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c09d6374324ee23cb5a4fe738f74369717dd642d", "html_url": "https://github.com/rust-lang/rust/commit/c09d6374324ee23cb5a4fe738f74369717dd642d"}, {"sha": "994793faabba1c490d108504b428ac653433ae44", "url": "https://api.github.com/repos/rust-lang/rust/commits/994793faabba1c490d108504b428ac653433ae44", "html_url": "https://github.com/rust-lang/rust/commit/994793faabba1c490d108504b428ac653433ae44"}], "stats": {"total": 851, "additions": 306, "deletions": 545}, "files": [{"sha": "98415a84c569bc0191dadf2bf06e08f7788a5dae", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -3,6 +3,7 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::Subst;\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::util::{needs_drop_components, AlwaysRequiresDrop};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::Limit;\n@@ -12,7 +13,7 @@ type NeedsDropResult<T> = Result<T, AlwaysRequiresDrop>;\n \n fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let adt_components =\n-        move |adt_def: &ty::AdtDef| tcx.adt_drop_tys(adt_def.did).map(|tys| tys.iter());\n+        move |adt_def: &ty::AdtDef, _| tcx.adt_drop_tys(adt_def.did).map(|tys| tys.iter());\n \n     // If we don't know a type doesn't need drop, for example if it's a type\n     // parameter without a `Copy` bound, then we conservatively return that it\n@@ -28,8 +29,9 @@ fn has_significant_drop_raw<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> bool {\n-    let significant_drop_fields =\n-        move |adt_def: &ty::AdtDef| tcx.adt_significant_drop_tys(adt_def.did).map(|tys| tys.iter());\n+    let significant_drop_fields = move |adt_def: &ty::AdtDef, _| {\n+        tcx.adt_significant_drop_tys(adt_def.did).map(|tys| tys.iter())\n+    };\n     let res = NeedsDropTypes::new(tcx, query.param_env, query.value, significant_drop_fields)\n         .next()\n         .is_some();\n@@ -74,7 +76,7 @@ impl<'tcx, F> NeedsDropTypes<'tcx, F> {\n \n impl<'tcx, F, I> Iterator for NeedsDropTypes<'tcx, F>\n where\n-    F: Fn(&ty::AdtDef) -> NeedsDropResult<I>,\n+    F: Fn(&ty::AdtDef, SubstsRef<'tcx>) -> NeedsDropResult<I>,\n     I: Iterator<Item = Ty<'tcx>>,\n {\n     type Item = NeedsDropResult<Ty<'tcx>>;\n@@ -138,7 +140,7 @@ where\n                     // `ManuallyDrop`. If it's a struct or enum without a `Drop`\n                     // impl then check whether the field types need `Drop`.\n                     ty::Adt(adt_def, substs) => {\n-                        let tys = match (self.adt_components)(adt_def) {\n+                        let tys = match (self.adt_components)(adt_def, substs) {\n                             Err(e) => return Some(Err(e)),\n                             Ok(tys) => tys,\n                         };\n@@ -171,22 +173,44 @@ where\n     }\n }\n \n+enum DtorType {\n+    /// Type has a `Drop` but it is considered insignificant.\n+    /// Check the query `adt_significant_drop_tys` for understanding\n+    /// \"significant\" / \"insignificant\".\n+    Insignificant,\n+\n+    /// Type has a `Drop` implentation.\n+    Significant,\n+}\n+\n // This is a helper function for `adt_drop_tys` and `adt_significant_drop_tys`.\n // Depending on the implentation of `adt_has_dtor`, it is used to check if the\n // ADT has a destructor or if the ADT only has a significant destructor. For\n // understanding significant destructor look at `adt_significant_drop_tys`.\n-fn adt_drop_tys_helper(\n-    tcx: TyCtxt<'_>,\n+fn adt_drop_tys_helper<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    adt_has_dtor: impl Fn(&ty::AdtDef) -> bool,\n-) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n-    let adt_components = move |adt_def: &ty::AdtDef| {\n+    adt_has_dtor: impl Fn(&ty::AdtDef) -> Option<DtorType>,\n+) -> Result<&ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n+    let adt_components = move |adt_def: &ty::AdtDef, substs: SubstsRef<'tcx>| {\n         if adt_def.is_manually_drop() {\n             debug!(\"adt_drop_tys: `{:?}` is manually drop\", adt_def);\n             return Ok(Vec::new().into_iter());\n-        } else if adt_has_dtor(adt_def) {\n-            debug!(\"adt_drop_tys: `{:?}` implements `Drop`\", adt_def);\n-            return Err(AlwaysRequiresDrop);\n+        } else if let Some(dtor_info) = adt_has_dtor(adt_def) {\n+            match dtor_info {\n+                DtorType::Significant => {\n+                    debug!(\"adt_drop_tys: `{:?}` implements `Drop`\", adt_def);\n+                    return Err(AlwaysRequiresDrop);\n+                }\n+                DtorType::Insignificant => {\n+                    debug!(\"adt_drop_tys: `{:?}` drop is insignificant\", adt_def);\n+\n+                    // Since the destructor is insignificant, we just want to make sure all of\n+                    // the passed in type parameters are also insignificant.\n+                    // Eg: Vec<T> dtor is insignificant when T=i32 but significant when T=Mutex.\n+                    return Ok(substs.types().collect::<Vec<Ty<'_>>>().into_iter());\n+                }\n+            }\n         } else if adt_def.is_union() {\n             debug!(\"adt_drop_tys: `{:?}` is a union\", adt_def);\n             return Ok(Vec::new().into_iter());\n@@ -204,7 +228,10 @@ fn adt_drop_tys_helper(\n }\n \n fn adt_drop_tys(tcx: TyCtxt<'_>, def_id: DefId) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n-    let adt_has_dtor = |adt_def: &ty::AdtDef| adt_def.destructor(tcx).is_some();\n+    // This is for the \"needs_drop\" query, that considers all `Drop` impls, therefore all dtors are\n+    // significant.\n+    let adt_has_dtor =\n+        |adt_def: &ty::AdtDef| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n     adt_drop_tys_helper(tcx, def_id, adt_has_dtor)\n }\n \n@@ -213,10 +240,22 @@ fn adt_significant_drop_tys(\n     def_id: DefId,\n ) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n     let adt_has_dtor = |adt_def: &ty::AdtDef| {\n-        adt_def\n-            .destructor(tcx)\n-            .map(|dtor| !tcx.has_attr(dtor.did, sym::rustc_insignificant_dtor))\n-            .unwrap_or(false)\n+        let is_marked_insig = tcx.has_attr(adt_def.did, sym::rustc_insignificant_dtor);\n+        if is_marked_insig {\n+            // In some cases like `std::collections::HashMap` where the struct is a wrapper around\n+            // a type that is a Drop type, and the wrapped type (eg: `hashbrown::HashMap`) lies\n+            // outside stdlib, we might choose to still annotate the the wrapper (std HashMap) with\n+            // `rustc_insignificant_dtor`, even if the type itself doesn't have a `Drop` impl.\n+            Some(DtorType::Insignificant)\n+        } else if adt_def.destructor(tcx).is_some() {\n+            // There is a Drop impl and the type isn't marked insignificant, therefore Drop must be\n+            // significant.\n+            Some(DtorType::Significant)\n+        } else {\n+            // No destructor found nor the type is annotated with `rustc_insignificant_dtor`, we\n+            // treat this as the simple case of Drop impl for type.\n+            None\n+        }\n     };\n     adt_drop_tys_helper(tcx, def_id, adt_has_dtor)\n }"}, {"sha": "3b7c92818f698facd8ae4aea9d7a12f182f80b6e", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -155,6 +155,7 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeMap\")]\n+#[rustc_insignificant_dtor]\n pub struct BTreeMap<K, V> {\n     root: Option<Root<K, V>>,\n     length: usize,\n@@ -331,6 +332,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IterMut<'_, K, V> {\n /// [`into_iter`]: IntoIterator::into_iter\n /// [`IntoIterator`]: core::iter::IntoIterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_insignificant_dtor]\n pub struct IntoIter<K, V> {\n     range: LazyLeafRange<marker::Dying, K, V>,\n     length: usize,"}, {"sha": "a769c558b4fa90f39e7e8ed344c677ae718edc6b", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -46,6 +46,7 @@ mod tests;\n /// [`VecDeque`]: super::vec_deque::VecDeque\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"LinkedList\")]\n+#[rustc_insignificant_dtor]\n pub struct LinkedList<T> {\n     head: Option<NonNull<Node<T>>>,\n     tail: Option<NonNull<Node<T>>>,"}, {"sha": "cae0f29af8327e4340438426dd50b28b9373542f", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -90,6 +90,7 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible\n /// [`make_contiguous`]: VecDeque::make_contiguous\n #[cfg_attr(not(test), rustc_diagnostic_item = \"vecdeque_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_insignificant_dtor]\n pub struct VecDeque<\n     T,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,"}, {"sha": "81e97805a72142a65408b0ebba48e6ad3214bc75", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -305,6 +305,7 @@ struct RcBox<T: ?Sized> {\n /// [get_mut]: Rc::get_mut\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Rc\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_insignificant_dtor]\n pub struct Rc<T: ?Sized> {\n     ptr: NonNull<RcBox<T>>,\n     phantom: PhantomData<RcBox<T>>,"}, {"sha": "4cb0a4b10bd0cdde6f10816f4af69a19fde12db0", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -22,6 +22,7 @@ use core::slice::{self};\n /// let iter: std::vec::IntoIter<_> = v.into_iter();\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_insignificant_dtor]\n pub struct IntoIter<\n     T,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,"}, {"sha": "c37ec37556157648b9986598487b396c1b709130", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -396,6 +396,7 @@ mod spec_extend;\n /// [owned slice]: Box\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"vec_type\")]\n+#[rustc_insignificant_dtor]\n pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n     buf: RawVec<T, A>,\n     len: usize,"}, {"sha": "822747dd0e824ff81736c980325824d278b146ce", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -10,6 +10,7 @@ use crate::{\n \n /// A by-value [array] iterator.\n #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n+#[rustc_insignificant_dtor]\n pub struct IntoIter<T, const N: usize> {\n     /// This is the array we are iterating over.\n     ///"}, {"sha": "f96906be540f99e0abd30348f9835f46f619d10e", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -205,6 +205,7 @@ use crate::sys;\n \n #[cfg_attr(not(test), rustc_diagnostic_item = \"hashmap_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_insignificant_dtor]\n pub struct HashMap<K, V, S = RandomState> {\n     base: base::HashMap<K, V, S>,\n }"}, {"sha": "b0fc5120f08f219783461c3e3e44316ed4323b28", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.fixed", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -4,6 +4,14 @@\n \n use std::thread;\n \n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n /* Test Send Trait Migration */\n struct SendPointer(*mut i32);\n unsafe impl Send for SendPointer {}\n@@ -42,19 +50,19 @@ fn test_sync_trait() {\n }\n \n /* Test Clone Trait Migration */\n-struct S(String);\n+struct S(Foo);\n struct T(i32);\n \n struct U(S, T);\n \n impl Clone for U {\n     fn clone(&self) -> Self {\n-        U(S(String::from(\"Hello World\")), T(0))\n+        U(S(Foo(0)), T(0))\n     }\n }\n \n fn test_clone_trait() {\n-    let f = U(S(String::from(\"Hello World\")), T(0));\n+    let f = U(S(Foo(0)), T(0));\n     let c = || {\n         let _ = &f;\n         //~^ ERROR: `Clone` trait implementation for closure and drop order"}, {"sha": "2bcf9a795edbd8f9fa093efe8b216d76725d777f", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -4,6 +4,14 @@\n \n use std::thread;\n \n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n /* Test Send Trait Migration */\n struct SendPointer(*mut i32);\n unsafe impl Send for SendPointer {}\n@@ -42,19 +50,19 @@ fn test_sync_trait() {\n }\n \n /* Test Clone Trait Migration */\n-struct S(String);\n+struct S(Foo);\n struct T(i32);\n \n struct U(S, T);\n \n impl Clone for U {\n     fn clone(&self) -> Self {\n-        U(S(String::from(\"Hello World\")), T(0))\n+        U(S(Foo(0)), T(0))\n     }\n }\n \n fn test_clone_trait() {\n-    let f = U(S(String::from(\"Hello World\")), T(0));\n+    let f = U(S(Foo(0)), T(0));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure and drop order\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`"}, {"sha": "8d2d3553d4040f2fdbb6027cbe71d5fb5c3fd700", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -1,5 +1,5 @@\n error: changes to closure capture in Rust 2021 will affect `Send` trait implementation for closure\n-  --> $DIR/auto_traits.rs:14:19\n+  --> $DIR/auto_traits.rs:22:19\n    |\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr.0` does not implement `Send`\n@@ -24,7 +24,7 @@ LL |         *fptr.0 = 20;\n  ...\n \n error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n-  --> $DIR/auto_traits.rs:34:19\n+  --> $DIR/auto_traits.rs:42:19\n    |\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n@@ -44,7 +44,7 @@ LL |         *fptr.0.0 = 20;\n  ...\n \n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/auto_traits.rs:58:13\n+  --> $DIR/auto_traits.rs:66:13\n    |\n LL |     let c = || {\n    |             ^^ in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`"}, {"sha": "9a6db588c8bf50f8b9138af373678202242ea632", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.fixed", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -3,6 +3,14 @@\n // check-pass\n #![warn(rust_2021_compatibility)]\n \n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n macro_rules! m {\n     (@ $body:expr) => {{\n         let f = || $body;\n@@ -15,11 +23,11 @@ macro_rules! m {\n }\n \n fn main() {\n-    let a = (1.to_string(), 2.to_string());\n+    let a = (Foo(0), Foo(1));\n     m!({\n         let _ = &a;\n         //~^ HELP: add a dummy\n         let x = a.0;\n-        println!(\"{}\", x);\n+        println!(\"{:?}\", x);\n     });\n }"}, {"sha": "08cc24b4b3fe8f173c066d9a2d481e0c7fe463ff", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -3,6 +3,14 @@\n // check-pass\n #![warn(rust_2021_compatibility)]\n \n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n macro_rules! m {\n     (@ $body:expr) => {{\n         let f = || $body;\n@@ -15,10 +23,10 @@ macro_rules! m {\n }\n \n fn main() {\n-    let a = (1.to_string(), 2.to_string());\n+    let a = (Foo(0), Foo(1));\n     m!({\n         //~^ HELP: add a dummy\n         let x = a.0;\n-        println!(\"{}\", x);\n+        println!(\"{:?}\", x);\n     });\n }"}, {"sha": "a2a9da5f87ced2f9ed3f24fe9ee3cfc45670c485", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -1,5 +1,5 @@\n warning: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/closure-body-macro-fragment.rs:8:17\n+  --> $DIR/closure-body-macro-fragment.rs:16:17\n    |\n LL |           let f = || $body;\n    |  _________________^\n@@ -15,7 +15,7 @@ LL | /     m!({\n LL | |\n LL | |         let x = a.0;\n    | |                 --- in Rust 2018, this closure captures all of `a`, but in Rust 2021, it will only capture `a.0`\n-LL | |         println!(\"{}\", x);\n+LL | |         println!(\"{:?}\", x);\n LL | |     });\n    | |_______- in this macro invocation\n    |"}, {"sha": "2652bf5988e6543472052504c1183f753641be80", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.fixed", "status": "modified", "additions": 27, "deletions": 158, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -1,169 +1,38 @@\n+// run-pass\n // run-rustfix\n \n #![deny(rust_2021_incompatible_closure_captures)]\n-//~^ NOTE: the lint level is defined here\n+#![allow(unused)]\n \n // Test cases for types that implement an insignificant drop (stlib defined)\n \n-// `t` needs Drop because one of its elements needs drop,\n-// therefore precise capture might affect drop ordering\n-fn test1_all_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let t2 = (String::new(), String::new());\n+macro_rules! test_insig_dtor_for_type {\n+    ($t: ty, $disambiguator: ident) => {\n+        mod $disambiguator {\n+            use std::collections::*;\n+            use std::rc::Rc;\n+            use std::sync::Mutex;\n \n-    let c = || {\n-        let _ = (&t, &t1, &t2);\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n+            fn test_for_type(t: $t) {\n+                let tup = (Mutex::new(0), t);\n \n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-        let _t2 = t2.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t2`, but in Rust 2021, it will only capture `t2.0`\n+                let _c = || tup.0;\n+            }\n+        }\n     };\n-\n-    c();\n }\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t2` is dropped here, but in Rust 2021, only `t2.0` will be dropped here as part of the closure\n-\n-// String implements drop and therefore should be migrated.\n-// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n-fn test2_only_precise_paths_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let t2 = (String::new(), String::new());\n-\n-    let c = || {\n-        let _ = (&t, &t1);\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-        let _t2 = t2;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-\n-// If a variable would've not been captured by value then it would've not been\n-// dropped with the closure and therefore doesn't need migration.\n-fn test3_only_by_value_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let c = || {\n-        let _ = &t;\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        println!(\"{}\", t1.1);\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-// Copy types get copied into the closure instead of move. Therefore we don't need to\n-// migrate then as their drop order isn't tied to the closure.\n-fn test4_only_non_copy_types_need_migration() {\n-    let t = (String::new(), String::new());\n-\n-    // `t1` is Copy because all of its elements are Copy\n-    let t1 = (0i32, 0i32);\n-\n-    let c = || {\n-        let _ = &t;\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-fn test5_only_drop_types_need_migration() {\n-    struct S(i32, i32);\n \n-    let t = (String::new(), String::new());\n-\n-    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n-    let s = S(0i32, 0i32);\n-\n-    let c = || {\n-        let _ = &t;\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _s = s.0;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-// Since we are using a move closure here, both `t` and `t1` get moved\n-// even though they are being used by ref inside the closure.\n-fn test6_move_closures_non_copy_types_might_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let c = move || {\n-        let _ = (&t1, &t);\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n-        println!(\"{} {}\", t1.1, t.1);\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.1`\n-        //~| NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.1`\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.1` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.1` will be dropped here as part of the closure\n-\n-// Test migration analysis in case of Drop + Non Drop aggregates.\n-// Note we need migration here only because the non-copy (because Drop type) is captured,\n-// otherwise we won't need to, since we can get away with just by ref capture in that case.\n-fn test7_drop_non_drop_aggregate_need_migration() {\n-    let t = (String::new(), String::new(), 0i32);\n-\n-    let c = || {\n-        let _ = &t;\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-fn main() {\n-    test1_all_need_migration();\n-    test2_only_precise_paths_need_migration();\n-    test3_only_by_value_need_migration();\n-    test4_only_non_copy_types_need_migration();\n-    test5_only_drop_types_need_migration();\n-    test6_move_closures_non_copy_types_might_need_migration();\n-    test7_drop_non_drop_aggregate_need_migration();\n-}\n+test_insig_dtor_for_type!(i32, prim_i32);\n+test_insig_dtor_for_type!(Vec<i32>, vec_i32);\n+test_insig_dtor_for_type!(String, string);\n+test_insig_dtor_for_type!(Vec<String>, vec_string);\n+test_insig_dtor_for_type!(HashMap<String, String>, hash_map);\n+test_insig_dtor_for_type!(BTreeMap<String, i32>, btree_map);\n+test_insig_dtor_for_type!(LinkedList<String>, linked_list);\n+test_insig_dtor_for_type!(Rc<i32>, rc_i32);\n+test_insig_dtor_for_type!(Rc<String>, rc_string);\n+test_insig_dtor_for_type!(std::vec::IntoIter<String>, vec_into_iter);\n+test_insig_dtor_for_type!(btree_map::IntoIter<String, String>, btree_map_into_iter);\n+test_insig_dtor_for_type!(std::array::IntoIter<String, 5>, array_into_iter);\n+\n+fn main() {}"}, {"sha": "2652bf5988e6543472052504c1183f753641be80", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "modified", "additions": 27, "deletions": 151, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -1,162 +1,38 @@\n+// run-pass\n // run-rustfix\n \n #![deny(rust_2021_incompatible_closure_captures)]\n-//~^ NOTE: the lint level is defined here\n+#![allow(unused)]\n \n // Test cases for types that implement an insignificant drop (stlib defined)\n \n-// `t` needs Drop because one of its elements needs drop,\n-// therefore precise capture might affect drop ordering\n-fn test1_all_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let t2 = (String::new(), String::new());\n+macro_rules! test_insig_dtor_for_type {\n+    ($t: ty, $disambiguator: ident) => {\n+        mod $disambiguator {\n+            use std::collections::*;\n+            use std::rc::Rc;\n+            use std::sync::Mutex;\n \n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n+            fn test_for_type(t: $t) {\n+                let tup = (Mutex::new(0), t);\n \n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-        let _t2 = t2.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t2`, but in Rust 2021, it will only capture `t2.0`\n+                let _c = || tup.0;\n+            }\n+        }\n     };\n-\n-    c();\n }\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t2` is dropped here, but in Rust 2021, only `t2.0` will be dropped here as part of the closure\n-\n-// String implements drop and therefore should be migrated.\n-// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n-fn test2_only_precise_paths_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let t2 = (String::new(), String::new());\n-\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-        let _t2 = t2;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-\n-// If a variable would've not been captured by value then it would've not been\n-// dropped with the closure and therefore doesn't need migration.\n-fn test3_only_by_value_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        println!(\"{}\", t1.1);\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-// Copy types get copied into the closure instead of move. Therefore we don't need to\n-// migrate then as their drop order isn't tied to the closure.\n-fn test4_only_non_copy_types_need_migration() {\n-    let t = (String::new(), String::new());\n-\n-    // `t1` is Copy because all of its elements are Copy\n-    let t1 = (0i32, 0i32);\n-\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-fn test5_only_drop_types_need_migration() {\n-    struct S(i32, i32);\n \n-    let t = (String::new(), String::new());\n-\n-    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n-    let s = S(0i32, 0i32);\n-\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _s = s.0;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-// Since we are using a move closure here, both `t` and `t1` get moved\n-// even though they are being used by ref inside the closure.\n-fn test6_move_closures_non_copy_types_might_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let c = move || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n-        println!(\"{} {}\", t1.1, t.1);\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.1`\n-        //~| NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.1`\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.1` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.1` will be dropped here as part of the closure\n-\n-// Test migration analysis in case of Drop + Non Drop aggregates.\n-// Note we need migration here only because the non-copy (because Drop type) is captured,\n-// otherwise we won't need to, since we can get away with just by ref capture in that case.\n-fn test7_drop_non_drop_aggregate_need_migration() {\n-    let t = (String::new(), String::new(), 0i32);\n-\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-fn main() {\n-    test1_all_need_migration();\n-    test2_only_precise_paths_need_migration();\n-    test3_only_by_value_need_migration();\n-    test4_only_non_copy_types_need_migration();\n-    test5_only_drop_types_need_migration();\n-    test6_move_closures_non_copy_types_might_need_migration();\n-    test7_drop_non_drop_aggregate_need_migration();\n-}\n+test_insig_dtor_for_type!(i32, prim_i32);\n+test_insig_dtor_for_type!(Vec<i32>, vec_i32);\n+test_insig_dtor_for_type!(String, string);\n+test_insig_dtor_for_type!(Vec<String>, vec_string);\n+test_insig_dtor_for_type!(HashMap<String, String>, hash_map);\n+test_insig_dtor_for_type!(BTreeMap<String, i32>, btree_map);\n+test_insig_dtor_for_type!(LinkedList<String>, linked_list);\n+test_insig_dtor_for_type!(Rc<i32>, rc_i32);\n+test_insig_dtor_for_type!(Rc<String>, rc_string);\n+test_insig_dtor_for_type!(std::vec::IntoIter<String>, vec_into_iter);\n+test_insig_dtor_for_type!(btree_map::IntoIter<String, String>, btree_map_into_iter);\n+test_insig_dtor_for_type!(std::array::IntoIter<String, 5>, array_into_iter);\n+\n+fn main() {}"}, {"sha": "7989a8fa5ccae1957c7972867e45ac6c54183a6b", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/c09d6374324ee23cb5a4fe738f74369717dd642d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c09d6374324ee23cb5a4fe738f74369717dd642d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=c09d6374324ee23cb5a4fe738f74369717dd642d", "patch": "@@ -1,161 +0,0 @@\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:15:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-LL |\n-LL |         let _t1 = t1.0;\n-   |                   ---- in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-LL |\n-LL |         let _t2 = t2.0;\n-   |                   ---- in Rust 2018, this closure captures all of `t2`, but in Rust 2021, it will only capture `t2.0`\n-...\n-LL | }\n-   | -\n-   | |\n-   | in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   | in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-   | in Rust 2018, `t2` is dropped here, but in Rust 2021, only `t2.0` will be dropped here as part of the closure\n-   |\n-note: the lint level is defined here\n-  --> $DIR/insignificant_drop.rs:3:9\n-   |\n-LL | #![deny(rust_2021_incompatible_closure_captures)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = (&t, &t1, &t2);\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:41:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-LL |\n-LL |         let _t1 = t1.0;\n-   |                   ---- in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-...\n-LL | }\n-   | -\n-   | |\n-   | in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   | in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t`, `t1` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = (&t, &t1);\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:62:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:83:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:104:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:122:13\n-   |\n-LL |     let c = move || {\n-   |             ^^^^^^^\n-...\n-LL |         println!(\"{} {}\", t1.1, t.1);\n-   |                           ----  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.1`\n-   |                           |\n-   |                           in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.1`\n-...\n-LL | }\n-   | -\n-   | |\n-   | in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.1` will be dropped here as part of the closure\n-   | in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.1` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t1`, `t` to be fully captured\n-   |\n-LL ~     let c = move || {\n-LL +         let _ = (&t1, &t);\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:142:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: aborting due to 7 previous errors\n-"}, {"sha": "d985e3bb9ec74131ff59a13d678b0bbdfdf9ea12", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.fixed", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -5,13 +5,15 @@\n #![feature(rustc_attrs)]\n #![allow(unused)]\n \n+use std::sync::Mutex;\n+\n+    #[rustc_insignificant_dtor]\n struct InsignificantDropPoint {\n     x: i32,\n-    y: i32,\n+    y: Mutex<i32>,\n }\n \n impl Drop for InsignificantDropPoint {\n-    #[rustc_insignificant_dtor]\n     fn drop(&mut self) {}\n }\n \n@@ -21,15 +23,15 @@ impl Drop for SigDrop {\n     fn drop(&mut self) {}\n }\n \n+#[rustc_insignificant_dtor]\n struct GenericStruct<T>(T, T);\n \n-struct Wrapper<T>(GenericStruct<T>, i32);\n-\n impl<T> Drop for GenericStruct<T> {\n-    #[rustc_insignificant_dtor]\n     fn drop(&mut self) {}\n }\n \n+struct Wrapper<T>(GenericStruct<T>, i32);\n+\n // `SigDrop` implements drop and therefore needs to be migrated.\n fn significant_drop_needs_migration() {\n     let t = (SigDrop {}, SigDrop {});"}, {"sha": "f95d34eeb299aaf68d60392aae52bf0cac006226", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -5,13 +5,15 @@\n #![feature(rustc_attrs)]\n #![allow(unused)]\n \n+use std::sync::Mutex;\n+\n+    #[rustc_insignificant_dtor]\n struct InsignificantDropPoint {\n     x: i32,\n-    y: i32,\n+    y: Mutex<i32>,\n }\n \n impl Drop for InsignificantDropPoint {\n-    #[rustc_insignificant_dtor]\n     fn drop(&mut self) {}\n }\n \n@@ -21,15 +23,15 @@ impl Drop for SigDrop {\n     fn drop(&mut self) {}\n }\n \n+#[rustc_insignificant_dtor]\n struct GenericStruct<T>(T, T);\n \n-struct Wrapper<T>(GenericStruct<T>, i32);\n-\n impl<T> Drop for GenericStruct<T> {\n-    #[rustc_insignificant_dtor]\n     fn drop(&mut self) {}\n }\n \n+struct Wrapper<T>(GenericStruct<T>, i32);\n+\n // `SigDrop` implements drop and therefore needs to be migrated.\n fn significant_drop_needs_migration() {\n     let t = (SigDrop {}, SigDrop {});"}, {"sha": "832a81711b13775a1f6f516b708ad1ba24b6a77d", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -1,5 +1,5 @@\n error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop_attr_migrations.rs:37:13\n+  --> $DIR/insignificant_drop_attr_migrations.rs:39:13\n    |\n LL |     let c = || {\n    |             ^^\n@@ -23,7 +23,7 @@ LL +         let _ = &t;\n    |\n \n error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop_attr_migrations.rs:57:13\n+  --> $DIR/insignificant_drop_attr_migrations.rs:59:13\n    |\n LL |     let c = move || {\n    |             ^^^^^^^"}, {"sha": "3f184a67fbac93b728fac5ccce07a6a4500cf71f", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_no_migrations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_no_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_no_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_no_migrations.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -3,14 +3,14 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n #![feature(rustc_attrs)]\n #![allow(unused)]\n+#[rustc_insignificant_dtor]\n \n struct InsignificantDropPoint {\n     x: i32,\n     y: i32,\n }\n \n impl Drop for InsignificantDropPoint {\n-    #[rustc_insignificant_dtor]\n     fn drop(&mut self) {}\n }\n "}, {"sha": "31fe494dc795a900620a2ac511adf7963e342b36", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/macro.fixed", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.fixed?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -5,8 +5,17 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n //~^ NOTE: the lint level is defined here\n \n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n fn main() {\n-    let a = (\"hey\".to_string(), \"123\".to_string());\n+    let a = (Foo(0), Foo(1));\n     let _ = || { let _ = &a; dbg!(a.0) };\n     //~^ ERROR: drop order\n     //~| NOTE: will only capture `a.0`"}, {"sha": "0f0c497492290b60fd769e64328d98d686c77970", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/macro.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -5,8 +5,17 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n //~^ NOTE: the lint level is defined here\n \n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n fn main() {\n-    let a = (\"hey\".to_string(), \"123\".to_string());\n+    let a = (Foo(0), Foo(1));\n     let _ = || dbg!(a.0);\n     //~^ ERROR: drop order\n     //~| NOTE: will only capture `a.0`"}, {"sha": "5046a4bcbb4b37fa009b59c965cc11eb93ecbc36", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.stderr?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -1,5 +1,5 @@\n error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/macro.rs:10:13\n+  --> $DIR/macro.rs:19:13\n    |\n LL |     let _ = || dbg!(a.0);\n    |             ^^^^^^^^---^"}, {"sha": "11218eff1337f7f63e779df6b9ec5a7a40fdc429", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.fixed", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -4,7 +4,22 @@\n \n use std::thread;\n \n-struct S(String);\n+#[derive(Debug)]\n+struct Foo(String);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+impl Foo {\n+    fn from(s: &str) -> Self {\n+        Self(String::from(s))\n+    }\n+}\n+\n+\n+struct S(Foo);\n \n #[derive(Clone)]\n struct T(i32);\n@@ -13,13 +28,13 @@ struct U(S, T);\n \n impl Clone for U {\n     fn clone(&self) -> Self {\n-        U(S(String::from(\"Hello World\")), T(0))\n+        U(S(Foo::from(\"Hello World\")), T(0))\n     }\n }\n \n fn test_multi_issues() {\n-    let f1 = U(S(String::from(\"foo\")), T(0));\n-    let f2 = U(S(String::from(\"bar\")), T(0));\n+    let f1 = U(S(Foo::from(\"foo\")), T(0));\n+    let f2 = U(S(Foo::from(\"bar\")), T(0));\n     let c = || {\n         let _ = (&f1, &f2);\n         //~^ ERROR: `Clone` trait implementation for closure and drop order\n@@ -39,7 +54,7 @@ fn test_multi_issues() {\n //~^ NOTE: in Rust 2018, `f2` is dropped here, but in Rust 2021, only `f2.1` will be dropped here as part of the closure\n \n fn test_capturing_all_disjoint_fields_individually() {\n-    let f1 = U(S(String::from(\"foo\")), T(0));\n+    let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let c = || {\n         let _ = &f1;\n         //~^ ERROR: `Clone` trait implementation for closure\n@@ -60,12 +75,12 @@ struct U1(S, T, S);\n \n impl Clone for U1 {\n     fn clone(&self) -> Self {\n-        U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")))\n+        U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")))\n     }\n }\n \n fn test_capturing_several_disjoint_fields_individually_1() {\n-    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         let _ = &f1;\n         //~^ ERROR: `Clone` trait implementation for closure\n@@ -85,7 +100,7 @@ fn test_capturing_several_disjoint_fields_individually_1() {\n }\n \n fn test_capturing_several_disjoint_fields_individually_2() {\n-    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         let _ = &f1;\n         //~^ ERROR: `Clone` trait implementation for closure and drop order"}, {"sha": "02f2faa2e8741615266e5f91687be7713335d207", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -4,7 +4,22 @@\n \n use std::thread;\n \n-struct S(String);\n+#[derive(Debug)]\n+struct Foo(String);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+impl Foo {\n+    fn from(s: &str) -> Self {\n+        Self(String::from(s))\n+    }\n+}\n+\n+\n+struct S(Foo);\n \n #[derive(Clone)]\n struct T(i32);\n@@ -13,13 +28,13 @@ struct U(S, T);\n \n impl Clone for U {\n     fn clone(&self) -> Self {\n-        U(S(String::from(\"Hello World\")), T(0))\n+        U(S(Foo::from(\"Hello World\")), T(0))\n     }\n }\n \n fn test_multi_issues() {\n-    let f1 = U(S(String::from(\"foo\")), T(0));\n-    let f2 = U(S(String::from(\"bar\")), T(0));\n+    let f1 = U(S(Foo::from(\"foo\")), T(0));\n+    let f2 = U(S(Foo::from(\"bar\")), T(0));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure and drop order\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -38,7 +53,7 @@ fn test_multi_issues() {\n //~^ NOTE: in Rust 2018, `f2` is dropped here, but in Rust 2021, only `f2.1` will be dropped here as part of the closure\n \n fn test_capturing_all_disjoint_fields_individually() {\n-    let f1 = U(S(String::from(\"foo\")), T(0));\n+    let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -58,12 +73,12 @@ struct U1(S, T, S);\n \n impl Clone for U1 {\n     fn clone(&self) -> Self {\n-        U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")))\n+        U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")))\n     }\n }\n \n fn test_capturing_several_disjoint_fields_individually_1() {\n-    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -82,7 +97,7 @@ fn test_capturing_several_disjoint_fields_individually_1() {\n }\n \n fn test_capturing_several_disjoint_fields_individually_2() {\n-    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure and drop order\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`"}, {"sha": "d425db5aa998c69394a674441809eef0581660b3", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -1,5 +1,5 @@\n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/multi_diagnostics.rs:23:13\n+  --> $DIR/multi_diagnostics.rs:38:13\n    |\n LL |     let c = || {\n    |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -26,7 +26,7 @@ LL +         let _ = (&f1, &f2);\n    |\n \n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:42:13\n+  --> $DIR/multi_diagnostics.rs:57:13\n    |\n LL |     let c = || {\n    |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -42,7 +42,7 @@ LL +         let _ = &f1;\n    |\n \n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:67:13\n+  --> $DIR/multi_diagnostics.rs:82:13\n    |\n LL |     let c = || {\n    |             ^^\n@@ -64,7 +64,7 @@ LL +         let _ = &f1;\n    |\n \n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/multi_diagnostics.rs:86:13\n+  --> $DIR/multi_diagnostics.rs:101:13\n    |\n LL |     let c = || {\n    |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -89,7 +89,7 @@ LL +         let _ = &f1;\n    |\n \n error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:119:19\n+  --> $DIR/multi_diagnostics.rs:134:19\n    |\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^"}, {"sha": "63e4000e833eb584424d8d52fec54b0f638d0906", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.fixed", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -165,7 +165,7 @@ fn test7_move_closures_non_copy_types_might_need_migration() {\n fn test8_drop_order_and_blocks() {\n     {\n         let tuple =\n-          (String::from(\"foo\"), String::from(\"bar\"));\n+          (Foo(0), Foo(1));\n         {\n             let c = || {\n                 let _ = &tuple;\n@@ -184,7 +184,7 @@ fn test8_drop_order_and_blocks() {\n \n fn test9_drop_order_and_nested_closures() {\n     let tuple =\n-        (String::from(\"foo\"), String::from(\"bar\"));\n+        (Foo(0), Foo(1));\n     let b = || {\n         let c = || {\n             let _ = &tuple;\n@@ -202,6 +202,19 @@ fn test9_drop_order_and_nested_closures() {\n     b();\n }\n \n+// Test that we migrate if drop order of Vec<T> would be affected if T is a significant drop type\n+fn test10_vec_of_significant_drop_type() {\n+\n+        let tup = (Foo(0), vec![Foo(3)]);\n+\n+        let _c = || { let _ = &tup; tup.0 };\n+            //~^ ERROR: drop order\n+            //~| NOTE: for more information, see\n+            //~| HELP: add a dummy let to cause `tup` to be fully captured\n+            //~| NOTE: in Rust 2018, this closure captures all of `tup`, but in Rust 2021, it will only capture `tup.0`\n+}\n+//~^ NOTE: in Rust 2018, `tup` is dropped here, but in Rust 2021, only `tup.0` will be dropped here as part of the closure\n+\n fn main() {\n     test1_all_need_migration();\n     test2_only_precise_paths_need_migration();\n@@ -212,4 +225,5 @@ fn main() {\n     test7_move_closures_non_copy_types_might_need_migration();\n     test8_drop_order_and_blocks();\n     test9_drop_order_and_nested_closures();\n+    test10_vec_of_significant_drop_type();\n }"}, {"sha": "9d9c54298cf112ccb9c838a934fe33320380fa46", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -158,7 +158,7 @@ fn test7_move_closures_non_copy_types_might_need_migration() {\n fn test8_drop_order_and_blocks() {\n     {\n         let tuple =\n-          (String::from(\"foo\"), String::from(\"bar\"));\n+          (Foo(0), Foo(1));\n         {\n             let c = || {\n                 //~^ ERROR: drop order\n@@ -176,7 +176,7 @@ fn test8_drop_order_and_blocks() {\n \n fn test9_drop_order_and_nested_closures() {\n     let tuple =\n-        (String::from(\"foo\"), String::from(\"bar\"));\n+        (Foo(0), Foo(1));\n     let b = || {\n         let c = || {\n             //~^ ERROR: drop order\n@@ -193,6 +193,19 @@ fn test9_drop_order_and_nested_closures() {\n     b();\n }\n \n+// Test that we migrate if drop order of Vec<T> would be affected if T is a significant drop type\n+fn test10_vec_of_significant_drop_type() {\n+\n+        let tup = (Foo(0), vec![Foo(3)]);\n+\n+        let _c = || tup.0;\n+            //~^ ERROR: drop order\n+            //~| NOTE: for more information, see\n+            //~| HELP: add a dummy let to cause `tup` to be fully captured\n+            //~| NOTE: in Rust 2018, this closure captures all of `tup`, but in Rust 2021, it will only capture `tup.0`\n+}\n+//~^ NOTE: in Rust 2018, `tup` is dropped here, but in Rust 2021, only `tup.0` will be dropped here as part of the closure\n+\n fn main() {\n     test1_all_need_migration();\n     test2_only_precise_paths_need_migration();\n@@ -203,4 +216,5 @@ fn main() {\n     test7_move_closures_non_copy_types_might_need_migration();\n     test8_drop_order_and_blocks();\n     test9_drop_order_and_nested_closures();\n+    test10_vec_of_significant_drop_type();\n }"}, {"sha": "fa1f83c37823f5e55f356904f81201cbef636ea6", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05044c2e6c043929a11537d7f6169eb3a2397bb8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr?ref=05044c2e6c043929a11537d7f6169eb3a2397bb8", "patch": "@@ -195,5 +195,22 @@ LL ~         let c = || {\n LL +             let _ = &tuple;\n    |\n \n-error: aborting due to 9 previous errors\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:201:18\n+   |\n+LL |         let _c = || tup.0;\n+   |                  ^^^-----\n+   |                     |\n+   |                     in Rust 2018, this closure captures all of `tup`, but in Rust 2021, it will only capture `tup.0`\n+...\n+LL | }\n+   | - in Rust 2018, `tup` is dropped here, but in Rust 2021, only `tup.0` will be dropped here as part of the closure\n+   |\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `tup` to be fully captured\n+   |\n+LL |         let _c = || { let _ = &tup; tup.0 };\n+   |                     +++++++++++++++       +\n+\n+error: aborting due to 10 previous errors\n "}]}