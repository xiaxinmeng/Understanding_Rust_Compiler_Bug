{"sha": "c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOWIxY2IxYmVkNzhkOTg5YjEwMTFmNTRmNmZlYmI3ZTllNDZkOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-08T07:01:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-08T07:01:41Z"}, "message": "auto merge of #13814 : alexcrichton/rust/read-timeout, r=brson\n\nThis PR is an implementation of `set_timeout`, `set_read_timeout`, and `set_write_timeout` for TCP, UDP, and Unix streams (named pipes on windows).\r\n\r\nThe implementation was much more difficult than I imagined it was going to be throughout the 9 categories ({tcp, udp, unix} x {windows, unix, green}). The major snag is that libuv doesn't support canceling writes, so I chose to word the `set_write_timeout` documentation in such a way that it accomadates the behavior seen when running around with libgreen.\r\n\r\nThe first commit is from #13751, and I just included it to pre-emptively avoid rebase conflicts. The following commits are relevant to this PR. The tests aren't quite passing on windows just yet, but I should have those working by tomorrow once my VM is back up and running. For now, I wanted to see what others' thoughts were on this strategy.", "tree": {"sha": "0f7ecbfb7edaa18fe4c4036a719fd969a076d414", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f7ecbfb7edaa18fe4c4036a719fd969a076d414"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "html_url": "https://github.com/rust-lang/rust/commit/c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26632d541c3f548b064ffea57f0cb2057b48f947", "url": "https://api.github.com/repos/rust-lang/rust/commits/26632d541c3f548b064ffea57f0cb2057b48f947", "html_url": "https://github.com/rust-lang/rust/commit/26632d541c3f548b064ffea57f0cb2057b48f947"}, {"sha": "418f197351fbc570a0e7bbf93d509cd44f988467", "url": "https://api.github.com/repos/rust-lang/rust/commits/418f197351fbc570a0e7bbf93d509cd44f988467", "html_url": "https://github.com/rust-lang/rust/commit/418f197351fbc570a0e7bbf93d509cd44f988467"}], "stats": {"total": 2165, "additions": 1697, "deletions": 468}, "files": [{"sha": "abb22476e5240f4dd0da44aa2e5664fb1acf3b63", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -27,6 +27,13 @@ pub static FIOCLEX: libc::c_ulong = 0x20006601;\n #[cfg(target_os = \"android\")]\n pub static FIOCLEX: libc::c_ulong = 0x5451;\n \n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+pub static MSG_DONTWAIT: libc::c_int = 0x80;\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+pub static MSG_DONTWAIT: libc::c_int = 0x40;\n+\n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n                         tzp: *libc::c_void) -> libc::c_int;"}, {"sha": "151111af3dfede70c89da99ece05772f6926325a", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -18,6 +18,7 @@ pub static WSADESCRIPTION_LEN: uint = 256;\n pub static WSASYS_STATUS_LEN: uint = 128;\n pub static FIONBIO: libc::c_long = 0x8004667e;\n static FD_SETSIZE: uint = 64;\n+pub static MSG_DONTWAIT: libc::c_int = 0;\n \n pub struct WSADATA {\n     pub wVersion: libc::WORD,"}, {"sha": "87225a10e76d50cfda0ae3626cf7c47933a8b236", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -189,6 +189,9 @@ impl rtio::RtioPipe for FileDesc {\n     fn close_write(&mut self) -> Result<(), IoError> {\n         Err(io::standard_error(io::InvalidInput))\n     }\n+    fn set_timeout(&mut self, _t: Option<u64>) {}\n+    fn set_read_timeout(&mut self, _t: Option<u64>) {}\n+    fn set_write_timeout(&mut self, _t: Option<u64>) {}\n }\n \n impl rtio::RtioTTY for FileDesc {"}, {"sha": "282f9c2e343475e2079ec6dce95b068931435090", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -221,6 +221,9 @@ impl rtio::RtioPipe for FileDesc {\n     fn close_write(&mut self) -> IoResult<()> {\n         Err(io::standard_error(io::InvalidInput))\n     }\n+    fn set_timeout(&mut self, _t: Option<u64>) {}\n+    fn set_read_timeout(&mut self, _t: Option<u64>) {}\n+    fn set_write_timeout(&mut self, _t: Option<u64>) {}\n }\n \n impl rtio::RtioTTY for FileDesc {"}, {"sha": "63d57756e5dfd02f45be05fd88ee0781774997a4", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 351, "deletions": 104, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -15,6 +15,7 @@ use std::io;\n use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n+use std::unstable::mutex;\n \n use super::{IoResult, retry, keep_going};\n use super::c;\n@@ -236,22 +237,36 @@ pub fn init() {\n \n pub struct TcpStream {\n     inner: UnsafeArc<Inner>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n }\n \n struct Inner {\n     fd: sock_t,\n+    lock: mutex::NativeMutex,\n+}\n+\n+pub struct Guard<'a> {\n+    pub fd: sock_t,\n+    pub guard: mutex::LockGuard<'a>,\n+}\n+\n+impl Inner {\n+    fn new(fd: sock_t) -> Inner {\n+        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+    }\n }\n \n impl TcpStream {\n     pub fn connect(addr: ip::SocketAddr,\n                    timeout: Option<u64>) -> IoResult<TcpStream> {\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let (addr, len) = addr_to_sockaddr(addr);\n-        let inner = Inner { fd: fd };\n-        let ret = TcpStream { inner: UnsafeArc::new(inner) };\n+        let ret = TcpStream::new(Inner::new(fd));\n \n-        let len = len as libc::socklen_t;\n+        let (addr, len) = addr_to_sockaddr(addr);\n         let addrp = &addr as *_ as *libc::sockaddr;\n+        let len = len as libc::socklen_t;\n+\n         match timeout {\n             Some(timeout) => {\n                 try!(util::connect_timeout(fd, addrp, len, timeout));\n@@ -266,6 +281,14 @@ impl TcpStream {\n         }\n     }\n \n+    fn new(inner: Inner) -> TcpStream {\n+        TcpStream {\n+            inner: UnsafeArc::new(inner),\n+            read_deadline: 0,\n+            write_deadline: 0,\n+        }\n+    }\n+\n     pub fn fd(&self) -> sock_t {\n         // This unsafety is fine because it's just a read-only arc\n         unsafe { (*self.inner.get()).fd }\n@@ -299,40 +322,51 @@ impl TcpStream {\n     fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n         Ok(())\n     }\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn lock_nonblocking(&self) {}\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n+        let ret = Guard {\n+            fd: self.fd(),\n+            guard: unsafe { (*self.inner.get()).lock.lock() },\n+        };\n+        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        ret\n+    }\n }\n \n #[cfg(windows)] type wrlen = libc::c_int;\n #[cfg(not(windows))] type wrlen = libc::size_t;\n \n impl rtio::RtioTcpStream for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| {\n-            unsafe {\n-                libc::recv(self.fd(),\n-                           buf.as_mut_ptr() as *mut libc::c_void,\n-                           buf.len() as wrlen,\n-                           0) as libc::c_int\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let doread = |nb| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::recv(fd,\n+                       buf.as_mut_ptr() as *mut libc::c_void,\n+                       buf.len() as wrlen,\n+                       flags) as libc::c_int\n+        };\n+        read(fd, self.read_deadline, dolock, doread)\n     }\n+\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| unsafe {\n-            libc::send(self.fd(),\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let dowrite = |nb: bool, buf: *u8, len: uint| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::send(fd,\n                        buf as *mut libc::c_void,\n                        len as wrlen,\n-                       0) as i64\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n+                       flags) as i64\n+        };\n+        match write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n+            Ok(_) => Ok(()),\n+            Err(e) => Err(e)\n         }\n     }\n     fn peer_name(&mut self) -> IoResult<ip::SocketAddr> {\n@@ -354,14 +388,29 @@ impl rtio::RtioTcpStream for TcpStream {\n     fn clone(&self) -> Box<rtio::RtioTcpStream:Send> {\n         box TcpStream {\n             inner: self.inner.clone(),\n+            read_deadline: 0,\n+            write_deadline: 0,\n         } as Box<rtio::RtioTcpStream:Send>\n     }\n+\n     fn close_write(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n     }\n     fn close_read(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+        self.read_deadline = deadline;\n+        self.write_deadline = deadline;\n+    }\n+    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n }\n \n impl rtio::RtioSocket for TcpStream {\n@@ -374,6 +423,13 @@ impl Drop for Inner {\n     fn drop(&mut self) { unsafe { close(self.fd); } }\n }\n \n+#[unsafe_destructor]\n+impl<'a> Drop for Guard<'a> {\n+    fn drop(&mut self) {\n+        assert!(util::set_nonblocking(self.fd, false).is_ok());\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // TCP listeners\n ////////////////////////////////////////////////////////////////////////////////\n@@ -384,29 +440,24 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n-        unsafe {\n-            socket(addr, libc::SOCK_STREAM).and_then(|fd| {\n-                let (addr, len) = addr_to_sockaddr(addr);\n-                let addrp = &addr as *libc::sockaddr_storage;\n-                let inner = Inner { fd: fd };\n-                let ret = TcpListener { inner: inner };\n-                // On platforms with Berkeley-derived sockets, this allows\n-                // to quickly rebind a socket, without needing to wait for\n-                // the OS to clean up the previous one.\n-                if cfg!(unix) {\n-                    match setsockopt(fd, libc::SOL_SOCKET,\n-                                     libc::SO_REUSEADDR,\n-                                     1 as libc::c_int) {\n-                        Err(n) => { return Err(n); },\n-                        Ok(..) => { }\n-                    }\n-                }\n-                match libc::bind(fd, addrp as *libc::sockaddr,\n-                                 len as libc::socklen_t) {\n-                    -1 => Err(last_error()),\n-                    _ => Ok(ret),\n-                }\n-            })\n+        let fd = try!(socket(addr, libc::SOCK_STREAM));\n+        let ret = TcpListener { inner: Inner::new(fd) };\n+\n+        let (addr, len) = addr_to_sockaddr(addr);\n+        let addrp = &addr as *_ as *libc::sockaddr;\n+        let len = len as libc::socklen_t;\n+\n+        // On platforms with Berkeley-derived sockets, this allows\n+        // to quickly rebind a socket, without needing to wait for\n+        // the OS to clean up the previous one.\n+        if cfg!(unix) {\n+            try!(setsockopt(fd, libc::SOL_SOCKET, libc::SO_REUSEADDR,\n+                            1 as libc::c_int));\n+        }\n+\n+        match unsafe { libc::bind(fd, addrp, len) } {\n+            -1 => Err(last_error()),\n+            _ => Ok(ret),\n         }\n     }\n \n@@ -444,7 +495,7 @@ impl TcpAcceptor {\n \n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n         if self.deadline != 0 {\n-            try!(util::accept_deadline(self.fd(), self.deadline));\n+            try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n         }\n         unsafe {\n             let mut storage: libc::sockaddr_storage = mem::init();\n@@ -457,7 +508,7 @@ impl TcpAcceptor {\n                              &mut size as *mut libc::socklen_t) as libc::c_int\n             }) as sock_t {\n                 -1 => Err(last_error()),\n-                fd => Ok(TcpStream { inner: UnsafeArc::new(Inner { fd: fd })})\n+                fd => Ok(TcpStream::new(Inner::new(fd))),\n             }\n         }\n     }\n@@ -487,22 +538,26 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n \n pub struct UdpSocket {\n     inner: UnsafeArc<Inner>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n }\n \n impl UdpSocket {\n     pub fn bind(addr: ip::SocketAddr) -> IoResult<UdpSocket> {\n-        unsafe {\n-            socket(addr, libc::SOCK_DGRAM).and_then(|fd| {\n-                let (addr, len) = addr_to_sockaddr(addr);\n-                let addrp = &addr as *libc::sockaddr_storage;\n-                let inner = Inner { fd: fd };\n-                let ret = UdpSocket { inner: UnsafeArc::new(inner) };\n-                match libc::bind(fd, addrp as *libc::sockaddr,\n-                                 len as libc::socklen_t) {\n-                    -1 => Err(last_error()),\n-                    _ => Ok(ret),\n-                }\n-            })\n+        let fd = try!(socket(addr, libc::SOCK_DGRAM));\n+        let ret = UdpSocket {\n+            inner: UnsafeArc::new(Inner::new(fd)),\n+            read_deadline: 0,\n+            write_deadline: 0,\n+        };\n+\n+        let (addr, len) = addr_to_sockaddr(addr);\n+        let addrp = &addr as *_ as *libc::sockaddr;\n+        let len = len as libc::socklen_t;\n+\n+        match unsafe { libc::bind(fd, addrp, len) } {\n+            -1 => Err(last_error()),\n+            _ => Ok(ret),\n         }\n     }\n \n@@ -541,6 +596,19 @@ impl UdpSocket {\n             }\n         }\n     }\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn lock_nonblocking(&self) {}\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n+        let ret = Guard {\n+            fd: self.fd(),\n+            guard: unsafe { (*self.inner.get()).lock.lock() },\n+        };\n+        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        ret\n+    }\n }\n \n impl rtio::RtioSocket for UdpSocket {\n@@ -554,48 +622,54 @@ impl rtio::RtioSocket for UdpSocket {\n \n impl rtio::RtioUdpSocket for UdpSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, ip::SocketAddr)> {\n-        unsafe {\n-            let mut storage: libc::sockaddr_storage = mem::init();\n-            let storagep = &mut storage as *mut libc::sockaddr_storage;\n-            let mut addrlen: libc::socklen_t =\n-                    mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-            let ret = retry(|| {\n-                libc::recvfrom(self.fd(),\n-                               buf.as_ptr() as *mut libc::c_void,\n-                               buf.len() as msglen_t,\n-                               0,\n-                               storagep as *mut libc::sockaddr,\n-                               &mut addrlen) as libc::c_int\n-            });\n-            if ret < 0 { return Err(last_error()) }\n-            sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n-                Ok((ret as uint, addr))\n-            })\n-        }\n+        let fd = self.fd();\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::init() };\n+        let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n+        let mut addrlen: libc::socklen_t =\n+                mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n+\n+        let dolock = || self.lock_nonblocking();\n+        let doread = |nb| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::recvfrom(fd,\n+                           buf.as_mut_ptr() as *mut libc::c_void,\n+                           buf.len() as msglen_t,\n+                           flags,\n+                           storagep,\n+                           &mut addrlen) as libc::c_int\n+        };\n+        let n = try!(read(fd, self.read_deadline, dolock, doread));\n+        sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n+            Ok((n as uint, addr))\n+        })\n     }\n+\n     fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> IoResult<()> {\n-        let (dst, len) = addr_to_sockaddr(dst);\n-        let dstp = &dst as *libc::sockaddr_storage;\n-        unsafe {\n-            let ret = retry(|| {\n-                libc::sendto(self.fd(),\n-                             buf.as_ptr() as *libc::c_void,\n-                             buf.len() as msglen_t,\n-                             0,\n-                             dstp as *libc::sockaddr,\n-                             len as libc::socklen_t) as libc::c_int\n-            });\n-            match ret {\n-                -1 => Err(last_error()),\n-                n if n as uint != buf.len() => {\n-                    Err(io::IoError {\n-                        kind: io::OtherIoError,\n-                        desc: \"couldn't send entire packet at once\",\n-                        detail: None,\n-                    })\n-                }\n-                _ => Ok(())\n-            }\n+        let (dst, dstlen) = addr_to_sockaddr(dst);\n+        let dstp = &dst as *_ as *libc::sockaddr;\n+        let dstlen = dstlen as libc::socklen_t;\n+\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let dowrite = |nb, buf: *u8, len: uint| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::sendto(fd,\n+                         buf as *libc::c_void,\n+                         len as msglen_t,\n+                         flags,\n+                         dstp,\n+                         dstlen) as i64\n+        };\n+\n+        let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n+        if n != buf.len() {\n+            Err(io::IoError {\n+                kind: io::ShortWrite(n),\n+                desc: \"couldn't send entire packet at once\",\n+                detail: None,\n+            })\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -645,6 +719,179 @@ impl rtio::RtioUdpSocket for UdpSocket {\n     fn clone(&self) -> Box<rtio::RtioUdpSocket:Send> {\n         box UdpSocket {\n             inner: self.inner.clone(),\n+            read_deadline: 0,\n+            write_deadline: 0,\n         } as Box<rtio::RtioUdpSocket:Send>\n     }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+        self.read_deadline = deadline;\n+        self.write_deadline = deadline;\n+    }\n+    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Timeout helpers\n+//\n+// The read/write functions below are the helpers for reading/writing a socket\n+// with a possible deadline specified. This is generally viewed as a timed out\n+// I/O operation.\n+//\n+// From the application's perspective, timeouts apply to the I/O object, not to\n+// the underlying file descriptor (it's one timeout per object). This means that\n+// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n+//\n+// The next idea to implement timeouts would be to use nonblocking I/O. An\n+// invocation of select() would wait (with a timeout) for a socket to be ready.\n+// Once its ready, we can perform the operation. Note that the operation *must*\n+// be nonblocking, even though select() says the socket is ready. This is\n+// because some other thread could have come and stolen our data (handles can be\n+// cloned).\n+//\n+// To implement nonblocking I/O, the first option we have is to use the\n+// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n+// I/O objects, so this was initially viewed as unwise.\n+//\n+// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n+// send/recv, but the niftiness wears off once you realize it only works well on\n+// linux [1] [2]. This means that it's pretty easy to get a nonblocking\n+// operation on linux (no flag fidding, no affecting other objects), but not on\n+// other platforms.\n+//\n+// To work around this constraint on other platforms, we end up using the\n+// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n+// could cause other objects' blocking operations to suddenly become\n+// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n+// falls back to using the same code path as nonblocking operations, but with an\n+// infinite timeout (select + send/recv). This helps emulate blocking\n+// reads/writes despite the underlying descriptor being nonblocking, as well as\n+// optimizing the fast path of just hitting one syscall in the good case.\n+//\n+// As a final caveat, this implementation uses a mutex so only one thread is\n+// doing a nonblocking operation at at time. This is the operation that comes\n+// after the select() (at which point we think the socket is ready). This is\n+// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n+// expect (wouldn't want someone turning it on when it should be off!). All\n+// operations performed in the lock are *nonblocking* to avoid holding the mutex\n+// forever.\n+//\n+// So, in summary, linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n+// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n+// reads/writes are still blocking.\n+//\n+// Fun, fun!\n+//\n+// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n+// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n+\n+pub fn read<T>(fd: sock_t,\n+               deadline: u64,\n+               lock: || -> T,\n+               read: |bool| -> libc::c_int) -> IoResult<uint> {\n+    let mut ret = -1;\n+    if deadline == 0 {\n+        ret = retry(|| read(false));\n+    }\n+\n+    if deadline != 0 || (ret == -1 && util::wouldblock()) {\n+        let deadline = match deadline {\n+            0 => None,\n+            n => Some(n),\n+        };\n+        loop {\n+            // With a timeout, first we wait for the socket to become\n+            // readable using select(), specifying the relevant timeout for\n+            // our previously set deadline.\n+            try!(util::await(fd, deadline, util::Readable));\n+\n+            // At this point, we're still within the timeout, and we've\n+            // determined that the socket is readable (as returned by\n+            // select). We must still read the socket in *nonblocking* mode\n+            // because some other thread could come steal our data. If we\n+            // fail to read some data, we retry (hence the outer loop) and\n+            // wait for the socket to become readable again.\n+            let _guard = lock();\n+            match retry(|| read(deadline.is_some())) {\n+                -1 if util::wouldblock() => { assert!(deadline.is_some()); }\n+                -1 => return Err(last_error()),\n+               n => { ret = n; break }\n+            }\n+        }\n+    }\n+\n+    match ret {\n+        0 => Err(io::standard_error(io::EndOfFile)),\n+        n if n < 0 => Err(last_error()),\n+        n => Ok(n as uint)\n+    }\n+}\n+\n+pub fn write<T>(fd: sock_t,\n+                deadline: u64,\n+                buf: &[u8],\n+                write_everything: bool,\n+                lock: || -> T,\n+                write: |bool, *u8, uint| -> i64) -> IoResult<uint> {\n+    let mut ret = -1;\n+    let mut written = 0;\n+    if deadline == 0 {\n+        if write_everything {\n+            ret = keep_going(buf, |inner, len| {\n+                written = buf.len() - len;\n+                write(false, inner, len)\n+            });\n+        } else {\n+            ret = retry(|| {\n+                write(false, buf.as_ptr(), buf.len()) as libc::c_int\n+            }) as i64;\n+            if ret > 0 { written = ret as uint; }\n+        }\n+    }\n+\n+    if deadline != 0 || (ret == -1 && util::wouldblock()) {\n+        let deadline = match deadline {\n+            0 => None,\n+            n => Some(n),\n+        };\n+        while written < buf.len() && (write_everything || written == 0) {\n+            // As with read(), first wait for the socket to be ready for\n+            // the I/O operation.\n+            match util::await(fd, deadline, util::Writable) {\n+                Err(ref e) if e.kind == io::TimedOut && written > 0 => {\n+                    assert!(deadline.is_some());\n+                    return Err(io::IoError {\n+                        kind: io::ShortWrite(written),\n+                        desc: \"short write\",\n+                        detail: None,\n+                    })\n+                }\n+                Err(e) => return Err(e),\n+                Ok(()) => {}\n+            }\n+\n+            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n+            // against unforseen circumstances.\n+            let _guard = lock();\n+            let ptr = buf.slice_from(written).as_ptr();\n+            let len = buf.len() - written;\n+            match retry(|| write(deadline.is_some(), ptr, len) as libc::c_int) {\n+                -1 if util::wouldblock() => {}\n+                -1 => return Err(last_error()),\n+                n => { written += n as uint; }\n+            }\n+        }\n+        ret = 0;\n+    }\n+    if ret < 0 {\n+        Err(last_error())\n+    } else {\n+        Ok(written)\n+    }\n }"}, {"sha": "36ae2ba06d52b562a14e4f9853bc776a1aabbf66", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 70, "deletions": 29, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -16,9 +16,12 @@ use std::io;\n use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n+use std::unstable::mutex;\n \n-use super::{IoResult, retry, keep_going};\n+use super::{IoResult, retry};\n+use super::net;\n use super::util;\n+use super::c;\n use super::file::fd_t;\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n@@ -55,6 +58,13 @@ fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint\n \n struct Inner {\n     fd: fd_t,\n+    lock: mutex::NativeMutex,\n+}\n+\n+impl Inner {\n+    fn new(fd: fd_t) -> Inner {\n+        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+    }\n }\n \n impl Drop for Inner {\n@@ -64,7 +74,7 @@ impl Drop for Inner {\n fn connect(addr: &CString, ty: libc::c_int,\n            timeout: Option<u64>) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n-    let inner = Inner { fd: try!(unix_socket(ty)) };\n+    let inner = Inner::new(try!(unix_socket(ty)));\n     let addrp = &addr as *_ as *libc::sockaddr;\n     let len = len as libc::socklen_t;\n \n@@ -84,7 +94,7 @@ fn connect(addr: &CString, ty: libc::c_int,\n \n fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n-    let inner = Inner { fd: try!(unix_socket(ty)) };\n+    let inner = Inner::new(try!(unix_socket(ty)));\n     let addrp = &addr as *libc::sockaddr_storage;\n     match unsafe {\n         libc::bind(inner.fd, addrp as *libc::sockaddr, len as libc::socklen_t)\n@@ -100,54 +110,74 @@ fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n \n pub struct UnixStream {\n     inner: UnsafeArc<Inner>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n }\n \n impl UnixStream {\n     pub fn connect(addr: &CString,\n                    timeout: Option<u64>) -> IoResult<UnixStream> {\n         connect(addr, libc::SOCK_STREAM, timeout).map(|inner| {\n-            UnixStream { inner: UnsafeArc::new(inner) }\n+            UnixStream::new(UnsafeArc::new(inner))\n         })\n     }\n \n+    fn new(inner: UnsafeArc<Inner>) -> UnixStream {\n+        UnixStream {\n+            inner: inner,\n+            read_deadline: 0,\n+            write_deadline: 0,\n+        }\n+    }\n+\n     fn fd(&self) -> fd_t { unsafe { (*self.inner.get()).fd } }\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn lock_nonblocking(&self) {}\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn lock_nonblocking<'a>(&'a self) -> net::Guard<'a> {\n+        let ret = net::Guard {\n+            fd: self.fd(),\n+            guard: unsafe { (*self.inner.get()).lock.lock() },\n+        };\n+        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        ret\n+    }\n }\n \n impl rtio::RtioPipe for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| unsafe {\n-            libc::recv(self.fd(),\n-                       buf.as_ptr() as *mut libc::c_void,\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let doread = |nb| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::recv(fd,\n+                       buf.as_mut_ptr() as *mut libc::c_void,\n                        buf.len() as libc::size_t,\n-                       0) as libc::c_int\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n+                       flags) as libc::c_int\n+        };\n+        net::read(fd, self.read_deadline, dolock, doread)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| unsafe {\n-            libc::send(self.fd(),\n+        let fd = self.fd();\n+        let dolock = || self.lock_nonblocking();\n+        let dowrite = |nb: bool, buf: *u8, len: uint| unsafe {\n+            let flags = if nb {c::MSG_DONTWAIT} else {0};\n+            libc::send(fd,\n                        buf as *mut libc::c_void,\n                        len as libc::size_t,\n-                       0) as i64\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n+                       flags) as i64\n+        };\n+        match net::write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n+            Ok(_) => Ok(()),\n+            Err(e) => Err(e)\n         }\n     }\n \n     fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n-        box UnixStream {\n-            inner: self.inner.clone(),\n-        } as Box<rtio::RtioPipe:Send>\n+        box UnixStream::new(self.inner.clone()) as Box<rtio::RtioPipe:Send>\n     }\n \n     fn close_write(&mut self) -> IoResult<()> {\n@@ -156,6 +186,17 @@ impl rtio::RtioPipe for UnixStream {\n     fn close_read(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+        self.read_deadline = deadline;\n+        self.write_deadline = deadline;\n+    }\n+    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -202,7 +243,7 @@ impl UnixAcceptor {\n \n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n         if self.deadline != 0 {\n-            try!(util::accept_deadline(self.fd(), self.deadline));\n+            try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n         }\n         let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n         let storagep = &mut storage as *mut libc::sockaddr_storage;\n@@ -214,7 +255,7 @@ impl UnixAcceptor {\n                          &mut size as *mut libc::socklen_t) as libc::c_int\n         }) {\n             -1 => Err(super::last_error()),\n-            fd => Ok(UnixStream { inner: UnsafeArc::new(Inner { fd: fd }) })\n+            fd => Ok(UnixStream::new(UnsafeArc::new(Inner::new(fd))))\n         }\n     }\n }"}, {"sha": "af80c7174f21cba3c3c413ee2ca41dc1e85c9b47", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 69, "deletions": 19, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -169,6 +169,27 @@ unsafe fn pipe(name: *u16, init: bool) -> libc::HANDLE {\n     )\n }\n \n+pub fn await(handle: libc::HANDLE, deadline: u64,\n+             overlapped: &mut libc::OVERLAPPED) -> bool {\n+    if deadline == 0 { return true }\n+\n+    // If we've got a timeout, use WaitForSingleObject in tandem with CancelIo\n+    // to figure out if we should indeed get the result.\n+    let now = ::io::timer::now();\n+    let timeout = deadline < now || unsafe {\n+        let ms = (deadline - now) as libc::DWORD;\n+        let r = libc::WaitForSingleObject(overlapped.hEvent,\n+                                          ms);\n+        r != libc::WAIT_OBJECT_0\n+    };\n+    if timeout {\n+        unsafe { let _ = c::CancelIo(handle); }\n+        false\n+    } else {\n+        true\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Unix Streams\n ////////////////////////////////////////////////////////////////////////////////\n@@ -177,6 +198,8 @@ pub struct UnixStream {\n     inner: UnsafeArc<Inner>,\n     write: Option<Event>,\n     read: Option<Event>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n }\n \n impl UnixStream {\n@@ -253,6 +276,8 @@ impl UnixStream {\n                                 inner: UnsafeArc::new(inner),\n                                 read: None,\n                                 write: None,\n+                                read_deadline: 0,\n+                                write_deadline: 0,\n                             })\n                         }\n                     }\n@@ -358,6 +383,10 @@ impl rtio::RtioPipe for UnixStream {\n         // sleep.\n         drop(guard);\n         loop {\n+            // Process a timeout if one is pending\n+            let succeeded = await(self.handle(), self.read_deadline,\n+                                  &mut overlapped);\n+\n             let ret = unsafe {\n                 libc::GetOverlappedResult(self.handle(),\n                                           &mut overlapped,\n@@ -373,6 +402,9 @@ impl rtio::RtioPipe for UnixStream {\n \n             // If the reading half is now closed, then we're done. If we woke up\n             // because the writing half was closed, keep trying.\n+            if !succeeded {\n+                return Err(io::standard_error(io::TimedOut))\n+            }\n             if self.read_closed() {\n                 return Err(io::standard_error(io::EndOfFile))\n             }\n@@ -408,12 +440,16 @@ impl rtio::RtioPipe for UnixStream {\n                                 &mut bytes_written,\n                                 &mut overlapped)\n             };\n+            let err = os::errno();\n             drop(guard);\n \n             if ret == 0 {\n-                if os::errno() != libc::ERROR_IO_PENDING as uint {\n-                    return Err(super::last_error())\n+                if err != libc::ERROR_IO_PENDING as uint {\n+                    return Err(io::IoError::from_errno(err, true));\n                 }\n+                // Process a timeout if one is pending\n+                let succeeded = await(self.handle(), self.write_deadline,\n+                                      &mut overlapped);\n                 let ret = unsafe {\n                     libc::GetOverlappedResult(self.handle(),\n                                               &mut overlapped,\n@@ -427,10 +463,22 @@ impl rtio::RtioPipe for UnixStream {\n                     if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n                         return Err(super::last_error())\n                     }\n+                    if !succeeded {\n+                        let amt = offset + bytes_written as uint;\n+                        return if amt > 0 {\n+                            Err(io::IoError {\n+                                kind: io::ShortWrite(amt),\n+                                desc: \"short write during write\",\n+                                detail: None,\n+                            })\n+                        } else {\n+                            Err(util::timeout(\"write timed out\"))\n+                        }\n+                    }\n                     if self.write_closed() {\n                         return Err(io::standard_error(io::BrokenPipe))\n                     }\n-                    continue; // retry\n+                    continue // retry\n                 }\n             }\n             offset += bytes_written as uint;\n@@ -443,6 +491,8 @@ impl rtio::RtioPipe for UnixStream {\n             inner: self.inner.clone(),\n             read: None,\n             write: None,\n+            read_deadline: 0,\n+            write_deadline: 0,\n         } as Box<rtio::RtioPipe:Send>\n     }\n \n@@ -475,6 +525,18 @@ impl rtio::RtioPipe for UnixStream {\n         unsafe { (*self.inner.get()).write_closed.store(true, atomics::SeqCst) }\n         self.cancel_io()\n     }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+        self.read_deadline = deadline;\n+        self.write_deadline = deadline;\n+    }\n+    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n+    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -577,22 +639,8 @@ impl UnixAcceptor {\n             let mut err = unsafe { libc::GetLastError() };\n \n             if err == libc::ERROR_IO_PENDING as libc::DWORD {\n-                // If we've got a timeout, use WaitForSingleObject in tandem\n-                // with CancelIo to figure out if we should indeed get the\n-                // result.\n-                if self.deadline != 0 {\n-                    let now = ::io::timer::now();\n-                    let timeout = self.deadline < now || unsafe {\n-                        let ms = (self.deadline - now) as libc::DWORD;\n-                        let r = libc::WaitForSingleObject(overlapped.hEvent,\n-                                                          ms);\n-                        r != libc::WAIT_OBJECT_0\n-                    };\n-                    if timeout {\n-                        unsafe { let _ = c::CancelIo(handle); }\n-                        return Err(util::timeout(\"accept timed out\"))\n-                    }\n-                }\n+                // Process a timeout if one is pending\n+                let _ = await(handle, self.deadline, &mut overlapped);\n \n                 // This will block until the overlapped I/O is completed. The\n                 // timeout was previously handled, so this will either block in\n@@ -638,6 +686,8 @@ impl UnixAcceptor {\n             inner: UnsafeArc::new(Inner::new(handle)),\n             read: None,\n             write: None,\n+            read_deadline: 0,\n+            write_deadline: 0,\n         })\n     }\n }"}, {"sha": "0d032f9f4bcda7dd09abf9ec1712f79ad0e2371c", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -12,12 +12,19 @@ use libc;\n use std::io::IoResult;\n use std::io;\n use std::mem;\n+use std::os;\n use std::ptr;\n \n use super::c;\n use super::net;\n use super::{retry, last_error};\n \n+#[deriving(Show)]\n+pub enum SocketStatus {\n+    Readable,\n+    Writable,\n+}\n+\n pub fn timeout(desc: &'static str) -> io::IoError {\n     io::IoError {\n         kind: io::TimedOut,\n@@ -33,6 +40,34 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n     }\n }\n \n+#[cfg(unix)]\n+pub fn wouldblock() -> bool {\n+    let err = os::errno();\n+    err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n+}\n+\n+#[cfg(windows)]\n+pub fn wouldblock() -> bool {\n+    let err = os::errno();\n+    err == libc::WSAEWOULDBLOCK as uint\n+}\n+\n+#[cfg(unix)]\n+pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n+    let set = nb as libc::c_int;\n+    super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n+}\n+\n+#[cfg(windows)]\n+pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n+    let mut set = nb as libc::c_ulong;\n+    if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n // See http://developerweb.net/viewtopic.php?id=3196 for where this is\n // derived from.\n pub fn connect_timeout(fd: net::sock_t,\n@@ -79,22 +114,6 @@ pub fn connect_timeout(fd: net::sock_t,\n     try!(set_nonblocking(fd, false));\n     return ret;\n \n-    #[cfg(unix)]\n-    fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n-        let set = nb as libc::c_int;\n-        super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n-    }\n-\n-    #[cfg(windows)]\n-    fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n-        let mut set = nb as libc::c_ulong;\n-        if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n-            Err(last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n     #[cfg(unix)]\n     fn await(fd: net::sock_t, set: &mut c::fd_set,\n              timeout: u64) -> libc::c_int {\n@@ -116,21 +135,34 @@ pub fn connect_timeout(fd: net::sock_t,\n     }\n }\n \n-pub fn accept_deadline(fd: net::sock_t, deadline: u64) -> IoResult<()> {\n+pub fn await(fd: net::sock_t, deadline: Option<u64>,\n+             status: SocketStatus) -> IoResult<()> {\n     let mut set: c::fd_set = unsafe { mem::init() };\n     c::fd_set(&mut set, fd);\n+    let (read, write) = match status {\n+        Readable => (&set as *_, ptr::null()),\n+        Writable => (ptr::null(), &set as *_),\n+    };\n+    let mut tv: libc::timeval = unsafe { mem::init() };\n \n     match retry(|| {\n-        // If we're past the deadline, then pass a 0 timeout to select() so\n-        // we can poll the status of the socket.\n         let now = ::io::timer::now();\n-        let ms = if deadline < now {0} else {deadline - now};\n-        let tv = ms_to_timeval(ms);\n+        let tvp = match deadline {\n+            None => ptr::null(),\n+            Some(deadline) => {\n+                // If we're past the deadline, then pass a 0 timeout to\n+                // select() so we can poll the status\n+                let ms = if deadline < now {0} else {deadline - now};\n+                tv = ms_to_timeval(ms);\n+                &tv as *_\n+            }\n+        };\n         let n = if cfg!(windows) {1} else {fd as libc::c_int + 1};\n-        unsafe { c::select(n, &set, ptr::null(), ptr::null(), &tv) }\n+        let r = unsafe { c::select(n, read, write, ptr::null(), tvp) };\n+        r\n     }) {\n         -1 => Err(last_error()),\n-        0 => Err(timeout(\"accept timed out\")),\n-        _ => return Ok(()),\n+        0 => Err(timeout(\"timed out\")),\n+        _ => Ok(()),\n     }\n }"}, {"sha": "433073b43c44a2e681fe77a02f24e308704c07df", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -31,7 +31,7 @@ pub struct Guard<'a> {\n }\n \n struct Inner {\n-    queue: Vec<BlockedTask>,\n+    queue: Vec<(BlockedTask, uint)>,\n     held: bool,\n     closed: bool,\n }\n@@ -47,16 +47,17 @@ impl Access {\n         }\n     }\n \n-    pub fn grant<'a>(&'a mut self, missile: HomingMissile) -> Guard<'a> {\n+    pub fn grant<'a>(&'a mut self, token: uint,\n+                     missile: HomingMissile) -> Guard<'a> {\n         // This unsafety is actually OK because the homing missile argument\n         // guarantees that we're on the same event loop as all the other objects\n         // attempting to get access granted.\n-        let inner: &mut Inner = unsafe { cast::transmute(self.inner.get()) };\n+        let inner: &mut Inner = unsafe { &mut *self.inner.get() };\n \n         if inner.held {\n             let t: Box<Task> = Local::take();\n             t.deschedule(1, |task| {\n-                inner.queue.push(task);\n+                inner.queue.push((task, token));\n                 Ok(())\n             });\n             assert!(inner.held);\n@@ -75,6 +76,17 @@ impl Access {\n         // necessary synchronization to be running on this thread.\n         unsafe { (*self.inner.get()).closed = true; }\n     }\n+\n+    // Dequeue a blocked task with a specified token. This is unsafe because it\n+    // is only safe to invoke while on the home event loop, and there is no\n+    // guarantee that this i being invoked on the home event loop.\n+    pub unsafe fn dequeue(&mut self, token: uint) -> Option<BlockedTask> {\n+        let inner: &mut Inner = &mut *self.inner.get();\n+        match inner.queue.iter().position(|&(_, t)| t == token) {\n+            Some(i) => Some(inner.queue.remove(i).unwrap().val0()),\n+            None => None,\n+        }\n+    }\n }\n \n impl Clone for Access {\n@@ -111,9 +123,9 @@ impl<'a> Drop for Guard<'a> {\n             // scheduled on this scheduler. Because we might be woken up on some\n             // other scheduler, we drop our homing missile before we reawaken\n             // the task.\n-            Some(task) => {\n+            Some((task, _)) => {\n                 drop(self.missile.take());\n-                let _ = task.wake().map(|t| t.reawaken());\n+                task.reawaken();\n             }\n             None => { inner.held = false; }\n         }"}, {"sha": "968029a6edc8cebbe765e866044d5bcb9b0463bd", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -84,6 +84,7 @@ fn start(argc: int, argv: **u8) -> int {\n mod macros;\n \n mod access;\n+mod timeout;\n mod homing;\n mod queue;\n mod rc;"}, {"sha": "999da1cfda718f7fa3a1c456a30f6797e6a12db2", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 154, "deletions": 229, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -12,21 +12,20 @@ use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use libc;\n use std::cast;\n use std::io;\n-use std::io::{IoError, IoResult};\n+use std::io::IoError;\n use std::io::net::ip;\n use std::mem;\n use std::ptr;\n use std::rt::rtio;\n use std::rt::task::BlockedTask;\n \n-use access::Access;\n use homing::{HomingIO, HomeHandle};\n use rc::Refcount;\n use stream::StreamWatcher;\n use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n             wait_until_woken_after, wakeup};\n-use timer::TimerWatcher;\n+use timeout::{AccessTimeout, AcceptTimeout, ConnectCtx};\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -146,190 +145,6 @@ fn socket_name(sk: SocketNameKind,\n         n => Err(uv_error_to_io_error(UvError(n)))\n     }\n }\n-////////////////////////////////////////////////////////////////////////////////\n-// Helpers for handling timeouts, shared for pipes/tcp\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct ConnectCtx {\n-    pub status: c_int,\n-    pub task: Option<BlockedTask>,\n-    pub timer: Option<Box<TimerWatcher>>,\n-}\n-\n-pub struct AcceptTimeout {\n-    timer: Option<TimerWatcher>,\n-    timeout_tx: Option<Sender<()>>,\n-    timeout_rx: Option<Receiver<()>>,\n-}\n-\n-impl ConnectCtx {\n-    pub fn connect<T>(\n-        mut self, obj: T, timeout: Option<u64>, io: &mut UvIoFactory,\n-        f: |&Request, &T, uvll::uv_connect_cb| -> libc::c_int\n-    ) -> Result<T, UvError> {\n-        let mut req = Request::new(uvll::UV_CONNECT);\n-        let r = f(&req, &obj, connect_cb);\n-        return match r {\n-            0 => {\n-                req.defuse(); // uv callback now owns this request\n-                match timeout {\n-                    Some(t) => {\n-                        let mut timer = TimerWatcher::new(io);\n-                        timer.start(timer_cb, t, 0);\n-                        self.timer = Some(timer);\n-                    }\n-                    None => {}\n-                }\n-                wait_until_woken_after(&mut self.task, &io.loop_, || {\n-                    let data = &self as *_;\n-                    match self.timer {\n-                        Some(ref mut timer) => unsafe { timer.set_data(data) },\n-                        None => {}\n-                    }\n-                    req.set_data(data);\n-                });\n-                // Make sure an erroneously fired callback doesn't have access\n-                // to the context any more.\n-                req.set_data(0 as *int);\n-\n-                // If we failed because of a timeout, drop the TcpWatcher as\n-                // soon as possible because it's data is now set to null and we\n-                // want to cancel the callback ASAP.\n-                match self.status {\n-                    0 => Ok(obj),\n-                    n => { drop(obj); Err(UvError(n)) }\n-                }\n-            }\n-            n => Err(UvError(n))\n-        };\n-\n-        extern fn timer_cb(handle: *uvll::uv_timer_t) {\n-            // Don't close the corresponding tcp request, just wake up the task\n-            // and let RAII take care of the pending watcher.\n-            let cx: &mut ConnectCtx = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(handle) as *mut ConnectCtx)\n-            };\n-            cx.status = uvll::ECANCELED;\n-            wakeup(&mut cx.task);\n-        }\n-\n-        extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n-            // This callback can be invoked with ECANCELED if the watcher is\n-            // closed by the timeout callback. In that case we just want to free\n-            // the request and be along our merry way.\n-            let req = Request::wrap(req);\n-            if status == uvll::ECANCELED { return }\n-\n-            // Apparently on windows when the handle is closed this callback may\n-            // not be invoked with ECANCELED but rather another error code.\n-            // Either ways, if the data is null, then our timeout has expired\n-            // and there's nothing we can do.\n-            let data = unsafe { uvll::get_data_for_req(req.handle) };\n-            if data.is_null() { return }\n-\n-            let cx: &mut ConnectCtx = unsafe { &mut *(data as *mut ConnectCtx) };\n-            cx.status = status;\n-            match cx.timer {\n-                Some(ref mut t) => t.stop(),\n-                None => {}\n-            }\n-            // Note that the timer callback doesn't cancel the connect request\n-            // (that's the job of uv_close()), so it's possible for this\n-            // callback to get triggered after the timeout callback fires, but\n-            // before the task wakes up. In that case, we did indeed\n-            // successfully connect, but we don't need to wake someone up. We\n-            // updated the status above (correctly so), and the task will pick\n-            // up on this when it wakes up.\n-            if cx.task.is_some() {\n-                wakeup(&mut cx.task);\n-            }\n-        }\n-    }\n-}\n-\n-impl AcceptTimeout {\n-    pub fn new() -> AcceptTimeout {\n-        AcceptTimeout { timer: None, timeout_tx: None, timeout_rx: None }\n-    }\n-\n-    pub fn accept<T: Send>(&mut self, c: &Receiver<IoResult<T>>) -> IoResult<T> {\n-        match self.timeout_rx {\n-            None => c.recv(),\n-            Some(ref rx) => {\n-                use std::comm::Select;\n-\n-                // Poll the incoming channel first (don't rely on the order of\n-                // select just yet). If someone's pending then we should return\n-                // them immediately.\n-                match c.try_recv() {\n-                    Ok(data) => return data,\n-                    Err(..) => {}\n-                }\n-\n-                // Use select to figure out which channel gets ready first. We\n-                // do some custom handling of select to ensure that we never\n-                // actually drain the timeout channel (we'll keep seeing the\n-                // timeout message in the future).\n-                let s = Select::new();\n-                let mut timeout = s.handle(rx);\n-                let mut data = s.handle(c);\n-                unsafe {\n-                    timeout.add();\n-                    data.add();\n-                }\n-                if s.wait() == timeout.id() {\n-                    Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-                } else {\n-                    c.recv()\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn clear(&mut self) {\n-        // Clear any previous timeout by dropping the timer and transmission\n-        // channels\n-        drop((self.timer.take(),\n-              self.timeout_tx.take(),\n-              self.timeout_rx.take()))\n-    }\n-\n-    pub fn set_timeout<U, T: UvHandle<U> + HomingIO>(\n-        &mut self, ms: u64, t: &mut T\n-    ) {\n-        // If we have a timeout, lazily initialize the timer which will be used\n-        // to fire when the timeout runs out.\n-        if self.timer.is_none() {\n-            let _m = t.fire_homing_missile();\n-            let loop_ = Loop::wrap(unsafe {\n-                uvll::get_loop_for_uv_handle(t.uv_handle())\n-            });\n-            let mut timer = TimerWatcher::new_home(&loop_, t.home().clone());\n-            unsafe {\n-                timer.set_data(self as *mut _ as *AcceptTimeout);\n-            }\n-            self.timer = Some(timer);\n-        }\n-\n-        // Once we've got a timer, stop any previous timeout, reset it for the\n-        // current one, and install some new channels to send/receive data on\n-        let timer = self.timer.get_mut_ref();\n-        timer.stop();\n-        timer.start(timer_cb, ms, 0);\n-        let (tx, rx) = channel();\n-        self.timeout_tx = Some(tx);\n-        self.timeout_rx = Some(rx);\n-\n-        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n-            let acceptor: &mut AcceptTimeout = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(timer) as *mut AcceptTimeout)\n-            };\n-            // This send can never fail because if this timer is active then the\n-            // receiving channel is guaranteed to be alive\n-            acceptor.timeout_tx.get_ref().send(());\n-        }\n-    }\n-}\n \n ////////////////////////////////////////////////////////////////////////////////\n /// TCP implementation\n@@ -345,8 +160,8 @@ pub struct TcpWatcher {\n     // stream object, so we use these access guards in order to arbitrate among\n     // multiple concurrent reads and writes. Note that libuv *can* read and\n     // write simultaneously, it just can't read and read simultaneously.\n-    read_access: Access,\n-    write_access: Access,\n+    read_access: AccessTimeout,\n+    write_access: AccessTimeout,\n }\n \n pub struct TcpListener {\n@@ -380,8 +195,8 @@ impl TcpWatcher {\n             handle: handle,\n             stream: StreamWatcher::new(handle),\n             refcount: Refcount::new(),\n-            read_access: Access::new(),\n-            write_access: Access::new(),\n+            read_access: AccessTimeout::new(),\n+            write_access: AccessTimeout::new(),\n         }\n     }\n \n@@ -412,10 +227,10 @@ impl rtio::RtioSocket for TcpWatcher {\n impl rtio::RtioTcpStream for TcpWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let m = self.fire_homing_missile();\n-        let access = self.read_access.grant(m);\n+        let guard = try!(self.read_access.grant(m));\n \n         // see comments in close_read about this check\n-        if access.is_closed() {\n+        if guard.access.is_closed() {\n             return Err(io::standard_error(io::EndOfFile))\n         }\n \n@@ -424,8 +239,8 @@ impl rtio::RtioTcpStream for TcpWatcher {\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let m = self.fire_homing_missile();\n-        let _g = self.write_access.grant(m);\n-        self.stream.write(buf).map_err(uv_error_to_io_error)\n+        let guard = try!(self.write_access.grant(m));\n+        self.stream.write(buf, guard.can_timeout).map_err(uv_error_to_io_error)\n     }\n \n     fn peer_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n@@ -468,23 +283,55 @@ impl rtio::RtioTcpStream for TcpWatcher {\n             stream: StreamWatcher::new(self.handle),\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n-            write_access: self.write_access.clone(),\n             read_access: self.read_access.clone(),\n+            write_access: self.write_access.clone(),\n         } as Box<rtio::RtioTcpStream:Send>\n     }\n \n     fn close_read(&mut self) -> Result<(), IoError> {\n         // see comments in PipeWatcher::close_read\n-        let m = self.fire_homing_missile();\n-        self.read_access.close(&m);\n-        self.stream.cancel_read(m);\n+        let task = {\n+            let m = self.fire_homing_missile();\n+            self.read_access.access.close(&m);\n+    self.stream.cancel_read(uvll::EOF as libc::ssize_t)\n+        };\n+        let _ = task.map(|t| t.reawaken());\n         Ok(())\n     }\n \n     fn close_write(&mut self) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         shutdown(self.handle, &self.uv_loop())\n     }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.set_read_timeout(timeout);\n+        self.set_write_timeout(timeout);\n+    }\n+\n+    fn set_read_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.read_access.set_timeout(ms, &self.home, &loop_, cancel_read,\n+                                     &self.stream as *_ as uint);\n+\n+        fn cancel_read(stream: uint) -> Option<BlockedTask> {\n+            let stream: &mut StreamWatcher = unsafe { cast::transmute(stream) };\n+            stream.cancel_read(uvll::ECANCELED as ssize_t)\n+        }\n+    }\n+\n+    fn set_write_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.write_access.set_timeout(ms, &self.home, &loop_, cancel_write,\n+                                      &self.stream as *_ as uint);\n+\n+        fn cancel_write(stream: uint) -> Option<BlockedTask> {\n+            let stream: &mut StreamWatcher = unsafe { cast::transmute(stream) };\n+            stream.cancel_write()\n+        }\n+    }\n }\n \n impl UvHandle<uvll::uv_tcp_t> for TcpWatcher {\n@@ -618,6 +465,7 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     }\n \n     fn set_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n         match ms {\n             None => self.timeout.clear(),\n             Some(ms) => self.timeout.set_timeout(ms, &mut *self.listener),\n@@ -635,8 +483,22 @@ pub struct UdpWatcher {\n \n     // See above for what these fields are\n     refcount: Refcount,\n-    read_access: Access,\n-    write_access: Access,\n+    read_access: AccessTimeout,\n+    write_access: AccessTimeout,\n+\n+    blocked_sender: Option<BlockedTask>,\n+}\n+\n+struct UdpRecvCtx {\n+    task: Option<BlockedTask>,\n+    buf: Option<Buf>,\n+    result: Option<(ssize_t, Option<ip::SocketAddr>)>,\n+}\n+\n+struct UdpSendCtx {\n+    result: c_int,\n+    data: Option<Vec<u8>>,\n+    udp: *mut UdpWatcher,\n }\n \n impl UdpWatcher {\n@@ -646,8 +508,9 @@ impl UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n             home: io.make_handle(),\n             refcount: Refcount::new(),\n-            read_access: Access::new(),\n-            write_access: Access::new(),\n+            read_access: AccessTimeout::new(),\n+            write_access: AccessTimeout::new(),\n+            blocked_sender: None,\n         };\n         assert_eq!(unsafe {\n             uvll::uv_udp_init(io.uv_loop(), udp.handle)\n@@ -683,20 +546,15 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     fn recvfrom(&mut self, buf: &mut [u8])\n         -> Result<(uint, ip::SocketAddr), IoError>\n     {\n-        struct Ctx {\n-            task: Option<BlockedTask>,\n-            buf: Option<Buf>,\n-            result: Option<(ssize_t, Option<ip::SocketAddr>)>,\n-        }\n         let loop_ = self.uv_loop();\n         let m = self.fire_homing_missile();\n-        let _g = self.read_access.grant(m);\n+        let _guard = try!(self.read_access.grant(m));\n \n         return match unsafe {\n             uvll::uv_udp_recv_start(self.handle, alloc_cb, recv_cb)\n         } {\n             0 => {\n-                let mut cx = Ctx {\n+                let mut cx = UdpRecvCtx {\n                     task: None,\n                     buf: Some(slice_to_uv_buf(buf)),\n                     result: None,\n@@ -718,7 +576,8 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                            _suggested_size: size_t,\n                            buf: *mut Buf) {\n             unsafe {\n-                let cx = &mut *(uvll::get_data_for_uv_handle(handle) as *mut Ctx);\n+                let cx = uvll::get_data_for_uv_handle(handle);\n+                let cx = &mut *(cx as *mut UdpRecvCtx);\n                 *buf = cx.buf.take().expect(\"recv alloc_cb called more than once\")\n             }\n         }\n@@ -727,7 +586,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                           addr: *libc::sockaddr, _flags: c_uint) {\n             assert!(nread != uvll::ECANCELED as ssize_t);\n             let cx = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(handle) as *mut Ctx)\n+                &mut *(uvll::get_data_for_uv_handle(handle) as *mut UdpRecvCtx)\n             };\n \n             // When there's no data to read the recv callback can be a no-op.\n@@ -751,42 +610,68 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     }\n \n     fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> Result<(), IoError> {\n-        struct Ctx { task: Option<BlockedTask>, result: c_int }\n-\n         let m = self.fire_homing_missile();\n         let loop_ = self.uv_loop();\n-        let _g = self.write_access.grant(m);\n+        let guard = try!(self.write_access.grant(m));\n \n         let mut req = Request::new(uvll::UV_UDP_SEND);\n-        let buf = slice_to_uv_buf(buf);\n         let (addr, _len) = addr_to_sockaddr(dst);\n-        let result = unsafe {\n-            let addr_p = &addr as *libc::sockaddr_storage;\n-            uvll::uv_udp_send(req.handle, self.handle, [buf],\n-                              addr_p as *libc::sockaddr, send_cb)\n+        let addr_p = &addr as *_ as *libc::sockaddr;\n+\n+        // see comments in StreamWatcher::write for why we may allocate a buffer\n+        // here.\n+        let data = if guard.can_timeout {Some(Vec::from_slice(buf))} else {None};\n+        let uv_buf = if guard.can_timeout {\n+            slice_to_uv_buf(data.get_ref().as_slice())\n+        } else {\n+            slice_to_uv_buf(buf)\n         };\n \n-        return match result {\n+        return match unsafe {\n+            uvll::uv_udp_send(req.handle, self.handle, [uv_buf], addr_p, send_cb)\n+        } {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n-                let mut cx = Ctx { task: None, result: 0 };\n-                wait_until_woken_after(&mut cx.task, &loop_, || {\n+                let mut cx = UdpSendCtx {\n+                    result: uvll::ECANCELED, data: data, udp: self as *mut _\n+                };\n+                wait_until_woken_after(&mut self.blocked_sender, &loop_, || {\n                     req.set_data(&cx);\n                 });\n-                match cx.result {\n-                    0 => Ok(()),\n-                    n => Err(uv_error_to_io_error(UvError(n)))\n+\n+                if cx.result != uvll::ECANCELED {\n+                    return match cx.result {\n+                        0 => Ok(()),\n+                        n => Err(uv_error_to_io_error(UvError(n)))\n+                    }\n                 }\n+                let new_cx = box UdpSendCtx {\n+                    result: 0,\n+                    udp: 0 as *mut UdpWatcher,\n+                    data: cx.data.take(),\n+                };\n+                unsafe {\n+                    req.set_data(&*new_cx);\n+                    cast::forget(new_cx);\n+                }\n+                Err(uv_error_to_io_error(UvError(cx.result)))\n             }\n             n => Err(uv_error_to_io_error(UvError(n)))\n         };\n \n+        // This function is the same as stream::write_cb, but adapted for udp\n+        // instead of streams.\n         extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n             let req = Request::wrap(req);\n-            assert!(status != uvll::ECANCELED);\n-            let cx: &mut Ctx = unsafe { req.get_data() };\n+            let cx: &mut UdpSendCtx = unsafe { req.get_data() };\n             cx.result = status;\n-            wakeup(&mut cx.task);\n+\n+            if cx.udp as uint != 0 {\n+                let udp: &mut UdpWatcher = unsafe { &mut *cx.udp };\n+                wakeup(&mut udp.blocked_sender);\n+            } else {\n+                let _cx: Box<UdpSendCtx> = unsafe { cast::transmute(cx) };\n+            }\n         }\n     }\n \n@@ -866,8 +751,48 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             refcount: self.refcount.clone(),\n             write_access: self.write_access.clone(),\n             read_access: self.read_access.clone(),\n+            blocked_sender: None,\n         } as Box<rtio::RtioUdpSocket:Send>\n     }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.set_read_timeout(timeout);\n+        self.set_write_timeout(timeout);\n+    }\n+\n+    fn set_read_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.read_access.set_timeout(ms, &self.home, &loop_, cancel_read,\n+                                     self.handle as uint);\n+\n+        fn cancel_read(stream: uint) -> Option<BlockedTask> {\n+            // This method is quite similar to StreamWatcher::cancel_read, see\n+            // there for more information\n+            let handle = stream as *uvll::uv_udp_t;\n+            assert_eq!(unsafe { uvll::uv_udp_recv_stop(handle) }, 0);\n+            let data = unsafe {\n+                let data = uvll::get_data_for_uv_handle(handle);\n+                if data.is_null() { return None }\n+                uvll::set_data_for_uv_handle(handle, 0 as *int);\n+                &mut *(data as *mut UdpRecvCtx)\n+            };\n+            data.result = Some((uvll::ECANCELED as ssize_t, None));\n+            data.task.take()\n+        }\n+    }\n+\n+    fn set_write_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.write_access.set_timeout(ms, &self.home, &loop_, cancel_write,\n+                                      self as *mut _ as uint);\n+\n+        fn cancel_write(stream: uint) -> Option<BlockedTask> {\n+            let stream: &mut UdpWatcher = unsafe { cast::transmute(stream) };\n+            stream.blocked_sender.take()\n+        }\n+    }\n }\n \n impl Drop for UdpWatcher {"}, {"sha": "76bf92bd5557ca8e08788bac0621161f98917457", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -10,16 +10,18 @@\n \n use libc;\n use std::c_str::CString;\n+use std::cast;\n use std::io::IoError;\n use std::io;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n+use std::rt::task::BlockedTask;\n \n-use access::Access;\n use homing::{HomingIO, HomeHandle};\n use net;\n use rc::Refcount;\n use stream::StreamWatcher;\n use super::{Loop, UvError, UvHandle, uv_error_to_io_error};\n+use timeout::{AcceptTimeout, ConnectCtx, AccessTimeout};\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -30,8 +32,8 @@ pub struct PipeWatcher {\n     refcount: Refcount,\n \n     // see comments in TcpWatcher for why these exist\n-    write_access: Access,\n-    read_access: Access,\n+    write_access: AccessTimeout,\n+    read_access: AccessTimeout,\n }\n \n pub struct PipeListener {\n@@ -43,7 +45,7 @@ pub struct PipeListener {\n \n pub struct PipeAcceptor {\n     listener: Box<PipeListener>,\n-    timeout: net::AcceptTimeout,\n+    timeout: AcceptTimeout,\n }\n \n // PipeWatcher implementation and traits\n@@ -70,8 +72,8 @@ impl PipeWatcher {\n             home: home,\n             defused: false,\n             refcount: Refcount::new(),\n-            read_access: Access::new(),\n-            write_access: Access::new(),\n+            read_access: AccessTimeout::new(),\n+            write_access: AccessTimeout::new(),\n         }\n     }\n \n@@ -89,7 +91,7 @@ impl PipeWatcher {\n         -> Result<PipeWatcher, UvError>\n     {\n         let pipe = PipeWatcher::new(io, false);\n-        let cx = net::ConnectCtx { status: -1, task: None, timer: None };\n+        let cx = ConnectCtx { status: -1, task: None, timer: None };\n         cx.connect(pipe, timeout, io, |req, pipe, cb| {\n             unsafe {\n                 uvll::uv_pipe_connect(req.handle, pipe.handle(),\n@@ -112,10 +114,10 @@ impl PipeWatcher {\n impl RtioPipe for PipeWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let m = self.fire_homing_missile();\n-        let access = self.read_access.grant(m);\n+        let guard = try!(self.read_access.grant(m));\n \n         // see comments in close_read about this check\n-        if access.is_closed() {\n+        if guard.access.is_closed() {\n             return Err(io::standard_error(io::EndOfFile))\n         }\n \n@@ -124,8 +126,8 @@ impl RtioPipe for PipeWatcher {\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let m = self.fire_homing_missile();\n-        let _g = self.write_access.grant(m);\n-        self.stream.write(buf).map_err(uv_error_to_io_error)\n+        let guard = try!(self.write_access.grant(m));\n+        self.stream.write(buf, guard.can_timeout).map_err(uv_error_to_io_error)\n     }\n \n     fn clone(&self) -> Box<RtioPipe:Send> {\n@@ -157,16 +159,48 @@ impl RtioPipe for PipeWatcher {\n         // ordering is crucial because we could in theory be rescheduled during\n         // the uv_read_stop which means that another read invocation could leak\n         // in before we set the flag.\n-        let m = self.fire_homing_missile();\n-        self.read_access.close(&m);\n-        self.stream.cancel_read(m);\n+        let task = {\n+            let m = self.fire_homing_missile();\n+            self.read_access.access.close(&m);\n+            self.stream.cancel_read(uvll::EOF as libc::ssize_t)\n+        };\n+        let _ = task.map(|t| t.reawaken());\n         Ok(())\n     }\n \n     fn close_write(&mut self) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         net::shutdown(self.stream.handle, &self.uv_loop())\n     }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.set_read_timeout(timeout);\n+        self.set_write_timeout(timeout);\n+    }\n+\n+    fn set_read_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.read_access.set_timeout(ms, &self.home, &loop_, cancel_read,\n+                                     &self.stream as *_ as uint);\n+\n+        fn cancel_read(stream: uint) -> Option<BlockedTask> {\n+            let stream: &mut StreamWatcher = unsafe { cast::transmute(stream) };\n+            stream.cancel_read(uvll::ECANCELED as libc::ssize_t)\n+        }\n+    }\n+\n+    fn set_write_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.write_access.set_timeout(ms, &self.home, &loop_, cancel_write,\n+                                      &self.stream as *_ as uint);\n+\n+        fn cancel_write(stream: uint) -> Option<BlockedTask> {\n+            let stream: &mut StreamWatcher = unsafe { cast::transmute(stream) };\n+            stream.cancel_write()\n+        }\n+    }\n }\n \n impl HomingIO for PipeWatcher {\n@@ -219,7 +253,7 @@ impl RtioUnixListener for PipeListener {\n         // create the acceptor object from ourselves\n         let mut acceptor = box PipeAcceptor {\n             listener: self,\n-            timeout: net::AcceptTimeout::new(),\n+            timeout: AcceptTimeout::new(),\n         };\n \n         let _m = acceptor.fire_homing_missile();"}, {"sha": "36b6ed09ca5668033c1e9bdf35adc48b3ea4fea1", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 93, "deletions": 25, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -14,7 +14,6 @@ use std::ptr;\n use std::rt::task::BlockedTask;\n \n use Loop;\n-use homing::HomingMissile;\n use super::{UvError, Buf, slice_to_uv_buf, Request, wait_until_woken_after,\n             ForbidUnwind, wakeup};\n use uvll;\n@@ -31,6 +30,8 @@ pub struct StreamWatcher {\n     // structure, but currently we don't have mappings for all the structures\n     // defined in libuv, so we're foced to malloc this.\n     last_write_req: Option<Request>,\n+\n+    blocked_writer: Option<BlockedTask>,\n }\n \n struct ReadContext {\n@@ -41,7 +42,8 @@ struct ReadContext {\n \n struct WriteContext {\n     result: c_int,\n-    task: Option<BlockedTask>,\n+    stream: *mut StreamWatcher,\n+    data: Option<Vec<u8>>,\n }\n \n impl StreamWatcher {\n@@ -62,6 +64,7 @@ impl StreamWatcher {\n         StreamWatcher {\n             handle: stream,\n             last_write_req: None,\n+            blocked_writer: None,\n         }\n     }\n \n@@ -74,7 +77,7 @@ impl StreamWatcher {\n             buf: Some(slice_to_uv_buf(buf)),\n             // if the read is canceled, we'll see eof, otherwise this will get\n             // overwritten\n-            result: uvll::EOF as ssize_t,\n+            result: 0,\n             task: None,\n         };\n         // When reading a TTY stream on windows, libuv will invoke alloc_cb\n@@ -104,27 +107,22 @@ impl StreamWatcher {\n         return ret;\n     }\n \n-    pub fn cancel_read(&mut self, m: HomingMissile) {\n+    pub fn cancel_read(&mut self, reason: ssize_t) -> Option<BlockedTask> {\n         // When we invoke uv_read_stop, it cancels the read and alloc\n         // callbacks. We need to manually wake up a pending task (if one was\n-        // present). Note that we wake up the task *outside* the homing missile\n-        // to ensure that we don't switch schedulers when we're not supposed to.\n+        // present).\n         assert_eq!(unsafe { uvll::uv_read_stop(self.handle) }, 0);\n         let data = unsafe {\n             let data = uvll::get_data_for_uv_handle(self.handle);\n-            if data.is_null() { return }\n+            if data.is_null() { return None }\n             uvll::set_data_for_uv_handle(self.handle, 0 as *int);\n             &mut *(data as *mut ReadContext)\n         };\n-        let task = data.task.take();\n-        drop(m);\n-        match task {\n-            Some(task) => { let _ = task.wake().map(|t| t.reawaken()); }\n-            None => {}\n-        }\n+        data.result = reason;\n+        data.task.take()\n     }\n \n-    pub fn write(&mut self, buf: &[u8]) -> Result<(), UvError> {\n+    pub fn write(&mut self, buf: &[u8], may_timeout: bool) -> Result<(), UvError> {\n         // The ownership of the write request is dubious if this function\n         // unwinds. I believe that if the write_cb fails to re-schedule the task\n         // then the write request will be leaked.\n@@ -137,30 +135,94 @@ impl StreamWatcher {\n         };\n         req.set_data(ptr::null::<()>());\n \n+        // And here's where timeouts get a little interesting. Currently, libuv\n+        // does not support canceling an in-flight write request. Consequently,\n+        // when a write timeout expires, there's not much we can do other than\n+        // detach the sleeping task from the write request itself. Semantically,\n+        // this means that the write request will complete asynchronously, but\n+        // the calling task will return error (because the write timed out).\n+        //\n+        // There is special wording in the documentation of set_write_timeout()\n+        // indicating that this is a plausible failure scenario, and this\n+        // function is why that wording exists.\n+        //\n+        // Implementation-wise, we must be careful when passing a buffer down to\n+        // libuv. Most of this implementation avoids allocations becuase of the\n+        // blocking guarantee (all stack local variables are valid for the\n+        // entire read/write request). If our write request can be timed out,\n+        // however, we must heap allocate the data and pass that to the libuv\n+        // functions instead. The reason for this is that if we time out and\n+        // return, there's no guarantee that `buf` is a valid buffer any more.\n+        //\n+        // To do this, the write context has an optionally owned vector of\n+        // bytes.\n+        let data = if may_timeout {Some(Vec::from_slice(buf))} else {None};\n+        let uv_buf = if may_timeout {\n+            slice_to_uv_buf(data.get_ref().as_slice())\n+        } else {\n+            slice_to_uv_buf(buf)\n+        };\n+\n         // Send off the request, but be careful to not block until we're sure\n         // that the write reqeust is queued. If the reqeust couldn't be queued,\n         // then we should return immediately with an error.\n         match unsafe {\n-            uvll::uv_write(req.handle, self.handle, [slice_to_uv_buf(buf)],\n-                           write_cb)\n+            uvll::uv_write(req.handle, self.handle, [uv_buf], write_cb)\n         } {\n             0 => {\n-                let mut wcx = WriteContext { result: 0, task: None, };\n+                let mut wcx = WriteContext {\n+                    result: uvll::ECANCELED,\n+                    stream: self as *mut _,\n+                    data: data,\n+                };\n                 req.defuse(); // uv callback now owns this request\n \n                 let loop_ = unsafe { uvll::get_loop_for_uv_handle(self.handle) };\n-                wait_until_woken_after(&mut wcx.task, &Loop::wrap(loop_), || {\n+                wait_until_woken_after(&mut self.blocked_writer,\n+                                       &Loop::wrap(loop_), || {\n                     req.set_data(&wcx);\n                 });\n-                self.last_write_req = Some(Request::wrap(req.handle));\n-                match wcx.result {\n-                    0 => Ok(()),\n-                    n => Err(UvError(n)),\n+\n+                if wcx.result != uvll::ECANCELED {\n+                    self.last_write_req = Some(Request::wrap(req.handle));\n+                    return match wcx.result {\n+                        0 => Ok(()),\n+                        n => Err(UvError(n)),\n+                    }\n                 }\n+\n+                // This is the second case where canceling an in-flight write\n+                // gets interesting. If we've been canceled (no one reset our\n+                // result), then someone still needs to free the request, and\n+                // someone still needs to free the allocate buffer.\n+                //\n+                // To take care of this, we swap out the stack-allocated write\n+                // context for a heap-allocated context, transferring ownership\n+                // of everything to the write_cb. Libuv guarantees that this\n+                // callback will be invoked at some point, and the callback will\n+                // be responsible for deallocating these resources.\n+                //\n+                // Note that we don't cache this write request back in the\n+                // stream watcher because we no longer have ownership of it, and\n+                // we never will.\n+                let new_wcx = box WriteContext {\n+                    result: 0,\n+                    stream: 0 as *mut StreamWatcher,\n+                    data: wcx.data.take(),\n+                };\n+                unsafe {\n+                    req.set_data(&*new_wcx);\n+                    cast::forget(new_wcx);\n+                }\n+                Err(UvError(wcx.result))\n             }\n             n => Err(UvError(n)),\n         }\n     }\n+\n+    pub fn cancel_write(&mut self) -> Option<BlockedTask> {\n+        self.blocked_writer.take()\n+    }\n }\n \n // This allocation callback expects to be invoked once and only once. It will\n@@ -198,12 +260,18 @@ extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: *Buf) {\n // away the error code as a result.\n extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n     let mut req = Request::wrap(req);\n-    assert!(status != uvll::ECANCELED);\n     // Remember to not free the request because it is re-used between writes on\n     // the same stream.\n     let wcx: &mut WriteContext = unsafe { req.get_data() };\n     wcx.result = status;\n-    req.defuse();\n \n-    wakeup(&mut wcx.task);\n+    // If the stream is present, we haven't timed out, otherwise we acquire\n+    // ownership of everything and then deallocate it all at once.\n+    if wcx.stream as uint != 0 {\n+        req.defuse();\n+        let stream: &mut StreamWatcher = unsafe { &mut *wcx.stream };\n+        wakeup(&mut stream.blocked_writer);\n+    } else {\n+        let _wcx: Box<WriteContext> = unsafe { cast::transmute(wcx) };\n+    }\n }"}, {"sha": "3dbb34bb17a871f1290d874f92c7033fca022fcb", "filename": "src/librustuv/timeout.rs", "status": "added", "additions": 394, "deletions": 0, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -0,0 +1,394 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::c_int;\n+use std::cast;\n+use std::io::IoResult;\n+use std::mem;\n+use std::rt::task::BlockedTask;\n+\n+use access;\n+use homing::{HomeHandle, HomingMissile, HomingIO};\n+use timer::TimerWatcher;\n+use uvll;\n+use uvio::UvIoFactory;\n+use {Loop, UvError, uv_error_to_io_error, Request, wakeup};\n+use {UvHandle, wait_until_woken_after};\n+\n+/// Managment of a timeout when gaining access to a portion of a duplex stream.\n+pub struct AccessTimeout {\n+    state: TimeoutState,\n+    timer: Option<Box<TimerWatcher>>,\n+    pub access: access::Access,\n+}\n+\n+pub struct Guard<'a> {\n+    state: &'a mut TimeoutState,\n+    pub access: access::Guard<'a>,\n+    pub can_timeout: bool,\n+}\n+\n+#[deriving(Eq)]\n+enum TimeoutState {\n+    NoTimeout,\n+    TimeoutPending(ClientState),\n+    TimedOut,\n+}\n+\n+#[deriving(Eq)]\n+enum ClientState {\n+    NoWaiter,\n+    AccessPending,\n+    RequestPending,\n+}\n+\n+struct TimerContext {\n+    timeout: *mut AccessTimeout,\n+    callback: fn(uint) -> Option<BlockedTask>,\n+    payload: uint,\n+}\n+\n+impl AccessTimeout {\n+    pub fn new() -> AccessTimeout {\n+        AccessTimeout {\n+            state: NoTimeout,\n+            timer: None,\n+            access: access::Access::new(),\n+        }\n+    }\n+\n+    /// Grants access to half of a duplex stream, timing out if necessary.\n+    ///\n+    /// On success, Ok(Guard) is returned and access has been granted to the\n+    /// stream. If a timeout occurs, then Err is returned with an appropriate\n+    /// error.\n+    pub fn grant<'a>(&'a mut self, m: HomingMissile) -> IoResult<Guard<'a>> {\n+        // First, flag that we're attempting to acquire access. This will allow\n+        // us to cancel the pending grant if we timeout out while waiting for a\n+        // grant.\n+        match self.state {\n+            NoTimeout => {},\n+            TimeoutPending(ref mut client) => *client = AccessPending,\n+            TimedOut => return Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+        }\n+        let access = self.access.grant(self as *mut _ as uint, m);\n+\n+        // After acquiring the grant, we need to flag ourselves as having a\n+        // pending request so the timeout knows to cancel the request.\n+        let can_timeout = match self.state {\n+            NoTimeout => false,\n+            TimeoutPending(ref mut client) => { *client = RequestPending; true }\n+            TimedOut => return Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+        };\n+\n+        Ok(Guard {\n+            access: access,\n+            state: &mut self.state,\n+            can_timeout: can_timeout\n+        })\n+    }\n+\n+    /// Sets the pending timeout to the value specified.\n+    ///\n+    /// The home/loop variables are used to construct a timer if one has not\n+    /// been previously constructed.\n+    ///\n+    /// The callback will be invoked if the timeout elapses, and the data of\n+    /// the time will be set to `data`.\n+    pub fn set_timeout(&mut self, ms: Option<u64>,\n+                       home: &HomeHandle,\n+                       loop_: &Loop,\n+                       cb: fn(uint) -> Option<BlockedTask>,\n+                       data: uint) {\n+        self.state = NoTimeout;\n+        let ms = match ms {\n+            Some(ms) => ms,\n+            None => return match self.timer {\n+                Some(ref mut t) => t.stop(),\n+                None => {}\n+            }\n+        };\n+\n+        // If we have a timeout, lazily initialize the timer which will be used\n+        // to fire when the timeout runs out.\n+        if self.timer.is_none() {\n+            let mut timer = box TimerWatcher::new_home(loop_, home.clone());\n+            let cx = box TimerContext {\n+                timeout: self as *mut _,\n+                callback: cb,\n+                payload: data,\n+            };\n+            unsafe {\n+                timer.set_data(&*cx);\n+                cast::forget(cx);\n+            }\n+            self.timer = Some(timer);\n+        }\n+\n+        let timer = self.timer.get_mut_ref();\n+        unsafe {\n+            let cx = uvll::get_data_for_uv_handle(timer.handle);\n+            let cx = cx as *mut TimerContext;\n+            (*cx).callback = cb;\n+            (*cx).payload = data;\n+        }\n+        timer.stop();\n+        timer.start(timer_cb, ms, 0);\n+        self.state = TimeoutPending(NoWaiter);\n+\n+        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n+            let cx: &TimerContext = unsafe {\n+                &*(uvll::get_data_for_uv_handle(timer) as *TimerContext)\n+            };\n+            let me = unsafe { &mut *cx.timeout };\n+\n+            match mem::replace(&mut me.state, TimedOut) {\n+                TimedOut | NoTimeout => unreachable!(),\n+                TimeoutPending(NoWaiter) => {}\n+                TimeoutPending(AccessPending) => {\n+                    match unsafe { me.access.dequeue(me as *mut _ as uint) } {\n+                        Some(task) => task.reawaken(),\n+                        None => unreachable!(),\n+                    }\n+                }\n+                TimeoutPending(RequestPending) => {\n+                    match (cx.callback)(cx.payload) {\n+                        Some(task) => task.reawaken(),\n+                        None => unreachable!(),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Clone for AccessTimeout {\n+    fn clone(&self) -> AccessTimeout {\n+        AccessTimeout {\n+            access: self.access.clone(),\n+            state: NoTimeout,\n+            timer: None,\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for Guard<'a> {\n+    fn drop(&mut self) {\n+        match *self.state {\n+            TimeoutPending(NoWaiter) | TimeoutPending(AccessPending) =>\n+                unreachable!(),\n+\n+            NoTimeout | TimedOut => {}\n+            TimeoutPending(RequestPending) => {\n+                *self.state = TimeoutPending(NoWaiter);\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for AccessTimeout {\n+    fn drop(&mut self) {\n+        match self.timer {\n+            Some(ref timer) => unsafe {\n+                let data = uvll::get_data_for_uv_handle(timer.handle);\n+                let _data: Box<TimerContext> = cast::transmute(data);\n+            },\n+            None => {}\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Connect timeouts\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct ConnectCtx {\n+    pub status: c_int,\n+    pub task: Option<BlockedTask>,\n+    pub timer: Option<Box<TimerWatcher>>,\n+}\n+\n+pub struct AcceptTimeout {\n+    timer: Option<TimerWatcher>,\n+    timeout_tx: Option<Sender<()>>,\n+    timeout_rx: Option<Receiver<()>>,\n+}\n+\n+impl ConnectCtx {\n+    pub fn connect<T>(\n+        mut self, obj: T, timeout: Option<u64>, io: &mut UvIoFactory,\n+        f: |&Request, &T, uvll::uv_connect_cb| -> c_int\n+    ) -> Result<T, UvError> {\n+        let mut req = Request::new(uvll::UV_CONNECT);\n+        let r = f(&req, &obj, connect_cb);\n+        return match r {\n+            0 => {\n+                req.defuse(); // uv callback now owns this request\n+                match timeout {\n+                    Some(t) => {\n+                        let mut timer = TimerWatcher::new(io);\n+                        timer.start(timer_cb, t, 0);\n+                        self.timer = Some(timer);\n+                    }\n+                    None => {}\n+                }\n+                wait_until_woken_after(&mut self.task, &io.loop_, || {\n+                    let data = &self as *_;\n+                    match self.timer {\n+                        Some(ref mut timer) => unsafe { timer.set_data(data) },\n+                        None => {}\n+                    }\n+                    req.set_data(data);\n+                });\n+                // Make sure an erroneously fired callback doesn't have access\n+                // to the context any more.\n+                req.set_data(0 as *int);\n+\n+                // If we failed because of a timeout, drop the TcpWatcher as\n+                // soon as possible because it's data is now set to null and we\n+                // want to cancel the callback ASAP.\n+                match self.status {\n+                    0 => Ok(obj),\n+                    n => { drop(obj); Err(UvError(n)) }\n+                }\n+            }\n+            n => Err(UvError(n))\n+        };\n+\n+        extern fn timer_cb(handle: *uvll::uv_timer_t) {\n+            // Don't close the corresponding tcp request, just wake up the task\n+            // and let RAII take care of the pending watcher.\n+            let cx: &mut ConnectCtx = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(handle) as *mut ConnectCtx)\n+            };\n+            cx.status = uvll::ECANCELED;\n+            wakeup(&mut cx.task);\n+        }\n+\n+        extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n+            // This callback can be invoked with ECANCELED if the watcher is\n+            // closed by the timeout callback. In that case we just want to free\n+            // the request and be along our merry way.\n+            let req = Request::wrap(req);\n+            if status == uvll::ECANCELED { return }\n+\n+            // Apparently on windows when the handle is closed this callback may\n+            // not be invoked with ECANCELED but rather another error code.\n+            // Either ways, if the data is null, then our timeout has expired\n+            // and there's nothing we can do.\n+            let data = unsafe { uvll::get_data_for_req(req.handle) };\n+            if data.is_null() { return }\n+\n+            let cx: &mut ConnectCtx = unsafe { &mut *(data as *mut ConnectCtx) };\n+            cx.status = status;\n+            match cx.timer {\n+                Some(ref mut t) => t.stop(),\n+                None => {}\n+            }\n+            // Note that the timer callback doesn't cancel the connect request\n+            // (that's the job of uv_close()), so it's possible for this\n+            // callback to get triggered after the timeout callback fires, but\n+            // before the task wakes up. In that case, we did indeed\n+            // successfully connect, but we don't need to wake someone up. We\n+            // updated the status above (correctly so), and the task will pick\n+            // up on this when it wakes up.\n+            if cx.task.is_some() {\n+                wakeup(&mut cx.task);\n+            }\n+        }\n+    }\n+}\n+\n+impl AcceptTimeout {\n+    pub fn new() -> AcceptTimeout {\n+        AcceptTimeout { timer: None, timeout_tx: None, timeout_rx: None }\n+    }\n+\n+    pub fn accept<T: Send>(&mut self, c: &Receiver<IoResult<T>>) -> IoResult<T> {\n+        match self.timeout_rx {\n+            None => c.recv(),\n+            Some(ref rx) => {\n+                use std::comm::Select;\n+\n+                // Poll the incoming channel first (don't rely on the order of\n+                // select just yet). If someone's pending then we should return\n+                // them immediately.\n+                match c.try_recv() {\n+                    Ok(data) => return data,\n+                    Err(..) => {}\n+                }\n+\n+                // Use select to figure out which channel gets ready first. We\n+                // do some custom handling of select to ensure that we never\n+                // actually drain the timeout channel (we'll keep seeing the\n+                // timeout message in the future).\n+                let s = Select::new();\n+                let mut timeout = s.handle(rx);\n+                let mut data = s.handle(c);\n+                unsafe {\n+                    timeout.add();\n+                    data.add();\n+                }\n+                if s.wait() == timeout.id() {\n+                    Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+                } else {\n+                    c.recv()\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        match self.timeout_rx {\n+            Some(ref t) => { let _ = t.try_recv(); }\n+            None => {}\n+        }\n+        match self.timer {\n+            Some(ref mut t) => t.stop(),\n+            None => {}\n+        }\n+    }\n+\n+    pub fn set_timeout<U, T: UvHandle<U> + HomingIO>(\n+        &mut self, ms: u64, t: &mut T\n+    ) {\n+        // If we have a timeout, lazily initialize the timer which will be used\n+        // to fire when the timeout runs out.\n+        if self.timer.is_none() {\n+            let loop_ = Loop::wrap(unsafe {\n+                uvll::get_loop_for_uv_handle(t.uv_handle())\n+            });\n+            let mut timer = TimerWatcher::new_home(&loop_, t.home().clone());\n+            unsafe {\n+                timer.set_data(self as *mut _ as *AcceptTimeout);\n+            }\n+            self.timer = Some(timer);\n+        }\n+\n+        // Once we've got a timer, stop any previous timeout, reset it for the\n+        // current one, and install some new channels to send/receive data on\n+        let timer = self.timer.get_mut_ref();\n+        timer.stop();\n+        timer.start(timer_cb, ms, 0);\n+        let (tx, rx) = channel();\n+        self.timeout_tx = Some(tx);\n+        self.timeout_rx = Some(rx);\n+\n+        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n+            let acceptor: &mut AcceptTimeout = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(timer) as *mut AcceptTimeout)\n+            };\n+            // This send can never fail because if this timer is active then the\n+            // receiving channel is guaranteed to be alive\n+            acceptor.timeout_tx.get_ref().send(());\n+        }\n+    }\n+}"}, {"sha": "525539f8b36f9965699cd11f07676170499994f0", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -18,7 +18,7 @@ use uvio::UvIoFactory;\n use uvll;\n \n pub struct TimerWatcher {\n-    handle: *uvll::uv_timer_t,\n+    pub handle: *uvll::uv_timer_t,\n     home: HomeHandle,\n     action: Option<NextAction>,\n     blocker: Option<BlockedTask>,"}, {"sha": "f70c3b4c1bd7528bf8d8388a75ddfe0c013bc743", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -87,7 +87,7 @@ impl RtioTTY for TtyWatcher {\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n-        self.stream.write(buf).map_err(uv_error_to_io_error)\n+        self.stream.write(buf, false).map_err(uv_error_to_io_error)\n     }\n \n     fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {"}, {"sha": "a89af05c50ae6a0f4ba6c797601bb891a197895b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -326,6 +326,8 @@ impl IoError {\n                 libc::WSAEADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n                 libc::WSAEADDRINUSE => (ConnectionRefused, \"address in use\"),\n                 libc::ERROR_BROKEN_PIPE => (EndOfFile, \"the pipe has ended\"),\n+                libc::ERROR_OPERATION_ABORTED =>\n+                    (TimedOut, \"operation timed out\"),\n \n                 // libuv maps this error code to EISDIR. we do too. if it is found\n                 // to be incorrect, we can add in some more machinery to only\n@@ -434,6 +436,17 @@ pub enum IoErrorKind {\n     InvalidInput,\n     /// The I/O operation's timeout expired, causing it to be canceled.\n     TimedOut,\n+    /// This write operation failed to write all of its data.\n+    ///\n+    /// Normally the write() method on a Writer guarantees that all of its data\n+    /// has been written, but some operations may be terminated after only\n+    /// partially writing some data. An example of this is a timed out write\n+    /// which successfully wrote a known number of bytes, but bailed out after\n+    /// doing so.\n+    ///\n+    /// The payload contained as part of this variant is the number of bytes\n+    /// which are known to have been successfully written.\n+    ShortWrite(uint),\n }\n \n /// A trait for objects which are byte-oriented streams. Readers are defined by\n@@ -1429,7 +1442,8 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n         PathDoesntExist => \"no such file\",\n         MismatchedFileTypeForOperation => \"mismatched file type\",\n         ResourceUnavailable => \"resource unavailable\",\n-        TimedOut => \"operation timed out\"\n+        TimedOut => \"operation timed out\",\n+        ShortWrite(..) => \"short write\",\n     };\n     IoError {\n         kind: kind,"}, {"sha": "89141155ae4caef1d0094232e15d73b9f8bf0aa5", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -151,6 +151,69 @@ impl TcpStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n+\n+    /// Sets a timeout, in milliseconds, for blocking operations on this stream.\n+    ///\n+    /// This function will set a timeout for all blocking operations (including\n+    /// reads and writes) on this stream. The timeout specified is a relative\n+    /// time, in milliseconds, into the future after which point operations will\n+    /// time out. This means that the timeout must be reset periodically to keep\n+    /// it from expiring. Specifying a value of `None` will clear the timeout\n+    /// for this stream.\n+    ///\n+    /// The timeout on this stream is local to this stream only. Setting a\n+    /// timeout does not affect any other cloned instances of this stream, nor\n+    /// does the timeout propagated to cloned handles of this stream. Setting\n+    /// this timeout will override any specific read or write timeouts\n+    /// previously set for this stream.\n+    ///\n+    /// For clarification on the semantics of interrupting a read and a write,\n+    /// take a look at `set_read_timeout` and `set_write_timeout`.\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the timeout for read operations on this stream.\n+    ///\n+    /// See documentation in `set_timeout` for the semantics of this read time.\n+    /// This will overwrite any previous read timeout set through either this\n+    /// function or `set_timeout`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// When this timeout expires, if there is no pending read operation, no\n+    /// action is taken. Otherwise, the read operation will be scheduled to\n+    /// promptly return. If a timeout error is returned, then no data was read\n+    /// during the timeout period.\n+    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_read_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the timeout for write operations on this stream.\n+    ///\n+    /// See documentation in `set_timeout` for the semantics of this write time.\n+    /// This will overwrite any previous write timeout set through either this\n+    /// function or `set_timeout`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// When this timeout expires, if there is no pending write operation, no\n+    /// action is taken. Otherwise, the pending write operation will be\n+    /// scheduled to promptly return. The actual state of the underlying stream\n+    /// is not specified.\n+    ///\n+    /// The write operation may return an error of type `ShortWrite` which\n+    /// indicates that the object is known to have written an exact number of\n+    /// bytes successfully during the timeout period, and the remaining bytes\n+    /// were never written.\n+    ///\n+    /// If the write operation returns `TimedOut`, then it the timeout primitive\n+    /// does not know how many bytes were written as part of the timeout\n+    /// operation. It may be the case that bytes continue to be written in an\n+    /// asynchronous fashion after the call to write returns.\n+    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_write_timeout(timeout_ms)\n+    }\n }\n \n impl Clone for TcpStream {\n@@ -892,6 +955,7 @@ mod test {\n                 Err(ref e) if e.kind == TimedOut => {}\n                 Err(e) => fail!(\"error: {}\", e),\n             }\n+            ::task::deschedule();\n             if i == 1000 { fail!(\"should have a pending connection\") }\n         }\n         drop(l);\n@@ -964,4 +1028,118 @@ mod test {\n         // this test will never finish if the child doesn't wake up\n         rx.recv();\n     })\n+\n+    iotest!(fn readwrite_timeouts() {\n+        let addr = next_test_ip6();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+\n+        s.set_timeout(Some(20));\n+        for i in range(0, 1001) {\n+            match s.write([0, .. 128 * 1024]) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"{}\", e),\n+           }\n+           if i == 1000 { fail!(\"should have filled up?!\"); }\n+        }\n+        assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        s.set_timeout(None);\n+        assert_eq!(s.read([0, 0]), Ok(1));\n+    })\n+\n+    iotest!(fn read_timeouts() {\n+        let addr = next_test_ip6();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr).unwrap();\n+            rx.recv();\n+            let mut amt = 0;\n+            while amt < 100 * 128 * 1024 {\n+                match s.read([0, ..128 * 1024]) {\n+                    Ok(n) => { amt += n; }\n+                    Err(e) => fail!(\"{}\", e),\n+                }\n+            }\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_read_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        for _ in range(0, 100) {\n+            assert!(s.write([0, ..128 * 1024]).is_ok());\n+        }\n+    })\n+\n+    iotest!(fn write_timeouts() {\n+        let addr = next_test_ip6();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_write_timeout(Some(20));\n+        for i in range(0, 1001) {\n+            match s.write([0, .. 128 * 1024]) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"{}\", e),\n+           }\n+           if i == 1000 { fail!(\"should have filled up?!\"); }\n+        }\n+        assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        assert!(s.read([0]).is_ok());\n+    })\n+\n+    iotest!(fn timeout_concurrent_read() {\n+        let addr = next_test_ip6();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr).unwrap();\n+            rx.recv();\n+            assert_eq!(s.write([0]), Ok(()));\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        let s2 = s.clone();\n+        let (tx2, rx2) = channel();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            assert_eq!(s2.read([0]), Ok(1));\n+            tx2.send(());\n+        });\n+\n+        s.set_read_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        tx.send(());\n+\n+        rx2.recv();\n+    })\n }"}, {"sha": "45da872ca119836ae2c0b540f03fbaa0042e6296", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -20,6 +20,7 @@ use io::net::ip::{SocketAddr, IpAddr};\n use io::{Reader, Writer, IoResult};\n use kinds::Send;\n use owned::Box;\n+use option::Option;\n use result::{Ok, Err};\n use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n \n@@ -142,6 +143,27 @@ impl UdpSocket {\n             self.obj.ignore_broadcasts()\n         }\n     }\n+\n+    /// Sets the read/write timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the read timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_read_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the write timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_write_timeout(timeout_ms)\n+    }\n }\n \n impl Clone for UdpSocket {\n@@ -485,4 +507,56 @@ mod test {\n         rx.recv();\n         serv_rx.recv();\n     })\n+\n+    iotest!(fn recvfrom_timeout() {\n+        let addr1 = next_test_ip4();\n+        let addr2 = next_test_ip4();\n+        let mut a = UdpSocket::bind(addr1).unwrap();\n+\n+        let (tx, rx) = channel();\n+        let (tx2, rx2) = channel();\n+        spawn(proc() {\n+            let mut a = UdpSocket::bind(addr2).unwrap();\n+            assert_eq!(a.recvfrom([0]), Ok((1, addr1)));\n+            assert_eq!(a.sendto([0], addr1), Ok(()));\n+            rx.recv();\n+            assert_eq!(a.sendto([0], addr1), Ok(()));\n+\n+            tx2.send(());\n+        });\n+\n+        // Make sure that reads time out, but writes can continue\n+        a.set_read_timeout(Some(20));\n+        assert_eq!(a.recvfrom([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(a.recvfrom([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(a.sendto([0], addr2), Ok(()));\n+\n+        // Cloned handles should be able to block\n+        let mut a2 = a.clone();\n+        assert_eq!(a2.recvfrom([0]), Ok((1, addr2)));\n+\n+        // Clearing the timeout should allow for receiving\n+        a.set_timeout(None);\n+        tx.send(());\n+        assert_eq!(a2.recvfrom([0]), Ok((1, addr2)));\n+\n+        // Make sure the child didn't die\n+        rx2.recv();\n+    })\n+\n+    iotest!(fn sendto_timeout() {\n+        let addr1 = next_test_ip4();\n+        let addr2 = next_test_ip4();\n+        let mut a = UdpSocket::bind(addr1).unwrap();\n+        let _b = UdpSocket::bind(addr2).unwrap();\n+\n+        a.set_write_timeout(Some(1000));\n+        for _ in range(0, 100) {\n+            match a.sendto([0, ..4*1024], addr2) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"other error: {}\", e),\n+            }\n+        }\n+    })\n }"}, {"sha": "ac7a0f5cdce72a79f991d03af1a4cb5f23720fcb", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 144, "deletions": 14, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -61,21 +61,11 @@ impl UnixStream {\n         })\n     }\n \n-    /// Connect to a pipe named by `path`. This will attempt to open a\n-    /// connection to the underlying socket.\n-    ///\n-    /// The returned stream will be closed when the object falls out of scope.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![allow(unused_must_use)]\n-    /// use std::io::net::unix::UnixStream;\n+    /// Connect to a pipe named by `path`, timing out if the specified number of\n+    /// milliseconds.\n     ///\n-    /// let server = Path::new(\"path/to/my/socket\");\n-    /// let mut stream = UnixStream::connect(&server);\n-    /// stream.write([1, 2, 3]);\n-    /// ```\n+    /// This function is similar to `connect`, except that if `timeout_ms`\n+    /// elapses the function will return an error of kind `TimedOut`.\n     #[experimental = \"the timeout argument is likely to change types\"]\n     pub fn connect_timeout<P: ToCStr>(path: &P,\n                                       timeout_ms: u64) -> IoResult<UnixStream> {\n@@ -103,6 +93,27 @@ impl UnixStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n+\n+    /// Sets the read/write timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the read timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_read_timeout(timeout_ms)\n+    }\n+\n+    /// Sets the write timeout for this socket.\n+    ///\n+    /// For more information, see `TcpStream::set_timeout`\n+    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_write_timeout(timeout_ms)\n+    }\n }\n \n impl Clone for UnixStream {\n@@ -457,6 +468,7 @@ mod tests {\n                 Err(ref e) if e.kind == TimedOut => {}\n                 Err(e) => fail!(\"error: {}\", e),\n             }\n+            ::task::deschedule();\n             if i == 1000 { fail!(\"should have a pending connection\") }\n         }\n         drop(l);\n@@ -541,4 +553,122 @@ mod tests {\n         // this test will never finish if the child doesn't wake up\n         rx.recv();\n     })\n+\n+    iotest!(fn readwrite_timeouts() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+\n+        s.set_timeout(Some(20));\n+        for i in range(0, 1001) {\n+            match s.write([0, .. 128 * 1024]) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"{}\", e),\n+           }\n+           if i == 1000 { fail!(\"should have filled up?!\"); }\n+        }\n+\n+        // I'm not sure as to why, but apparently the write on windows always\n+        // succeeds after the previous timeout. Who knows?\n+        if !cfg!(windows) {\n+            assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+        }\n+\n+        tx.send(());\n+        s.set_timeout(None);\n+        assert_eq!(s.read([0, 0]), Ok(1));\n+    })\n+\n+    iotest!(fn read_timeouts() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr).unwrap();\n+            rx.recv();\n+            let mut amt = 0;\n+            while amt < 100 * 128 * 1024 {\n+                match s.read([0, ..128 * 1024]) {\n+                    Ok(n) => { amt += n; }\n+                    Err(e) => fail!(\"{}\", e),\n+                }\n+            }\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_read_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+\n+        tx.send(());\n+        for _ in range(0, 100) {\n+            assert!(s.write([0, ..128 * 1024]).is_ok());\n+        }\n+    })\n+\n+    iotest!(fn write_timeouts() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        s.set_write_timeout(Some(20));\n+        for i in range(0, 1001) {\n+            match s.write([0, .. 128 * 1024]) {\n+                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n+                Err(IoError { kind: TimedOut, .. }) => break,\n+                Err(e) => fail!(\"{}\", e),\n+           }\n+           if i == 1000 { fail!(\"should have filled up?!\"); }\n+        }\n+\n+        tx.send(());\n+        assert!(s.read([0]).is_ok());\n+    })\n+\n+    iotest!(fn timeout_concurrent_read() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).listen().unwrap();\n+        let (tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr).unwrap();\n+            rx.recv();\n+            assert!(s.write([0]).is_ok());\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = a.accept().unwrap();\n+        let s2 = s.clone();\n+        let (tx2, rx2) = channel();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            assert!(s2.read([0]).is_ok());\n+            tx2.send(());\n+        });\n+\n+        s.set_read_timeout(Some(20));\n+        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        tx.send(());\n+\n+        rx2.recv();\n+    })\n }"}, {"sha": "16882624ab71aa8b656d0856cfa0f0a84c4885cf", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -222,6 +222,9 @@ pub trait RtioTcpStream : RtioSocket {\n     fn clone(&self) -> Box<RtioTcpStream:Send>;\n     fn close_write(&mut self) -> IoResult<()>;\n     fn close_read(&mut self) -> IoResult<()>;\n+    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n }\n \n pub trait RtioSocket {\n@@ -245,6 +248,9 @@ pub trait RtioUdpSocket : RtioSocket {\n     fn ignore_broadcasts(&mut self) -> IoResult<()>;\n \n     fn clone(&self) -> Box<RtioUdpSocket:Send>;\n+    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n }\n \n pub trait RtioTimer {\n@@ -278,6 +284,9 @@ pub trait RtioPipe {\n \n     fn close_write(&mut self) -> IoResult<()>;\n     fn close_read(&mut self) -> IoResult<()>;\n+    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n+    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n }\n \n pub trait RtioUnixListener {"}, {"sha": "8924ed7cfd2936d4d8589e53d5e63341b47432b5", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39b1cb1bed78d989b1011f54f6febb7e9e46d94/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=c39b1cb1bed78d989b1011f54f6febb7e9e46d94", "patch": "@@ -323,6 +323,12 @@ impl BlockedTask {\n         }\n     }\n \n+    /// Reawakens this task if ownership is acquired. If finer-grained control\n+    /// is desired, use `wake` instead.\n+    pub fn reawaken(self) {\n+        self.wake().map(|t| t.reawaken());\n+    }\n+\n     // This assertion has two flavours because the wake involves an atomic op.\n     // In the faster version, destructors will fail dramatically instead.\n     #[cfg(not(test))] pub fn trash(self) { }"}]}