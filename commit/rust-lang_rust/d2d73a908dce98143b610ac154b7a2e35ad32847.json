{"sha": "d2d73a908dce98143b610ac154b7a2e35ad32847", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZDczYTkwOGRjZTk4MTQzYjYxMGFjMTU0YjdhMmUzNWFkMzI4NDc=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-27T08:14:53Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-27T08:14:53Z"}, "message": "reintroduce Lvalue and LvalueExtra", "tree": {"sha": "4bb1a1bd9c2887db2d5529784ad56bd2589bc64c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bb1a1bd9c2887db2d5529784ad56bd2589bc64c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2d73a908dce98143b610ac154b7a2e35ad32847", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX6ip9AAoJEFbW7qD8Z6xGr8UP/i9J8SNexnPNlIizL0Rn9jVl\nwk6oAzH92cgAQkM8jYmKvY4ypwBoPQDjmevVyBFgffD9+HQz1fvmnK5DNybdNWkv\nTXkF/5a+2hyNWBCKewwLcyZOvQ219Wo0eL230AO9UMZO+Fs8OjEZ22kKLVLCc2Dh\n++MsfLe6rLZ/rul1IJ2FAwx3DUxMV+qMw64w8ZzJfXOgkmBoCbpjo8y+hz5XeHSA\nS/HjX5dppg3tDjykzr/Ww1QA7QAXqvI7wjGOUZIHg78EFOYoGwHB2RAjPmqokjwK\nDGvMJdYoQ1sVR0c/Gs6MGzhL5wF8zeCYv/UbMZtvj75YMbhomzh+S+TougbMbGzM\ntD/t0oNRBbfyRdZ5mJREsCG1GPdPpdxGMydLW9av0lfncLpviFeJym/7QYe01a4d\n5wdQvvSig48kLdeIodinc/oRGP/cPUxa7FNbkn4glwFub3bk3XORsbZHTt6Hp1Xc\nKVXuHeypIqy/m34IaBc0j4x1s/AVvJsAbnyfC+IECvU73Ck6DmhOwNEnIDd9ApAi\nrTo3GS63C5LjeWmTtW9H9h6/wvufRGRGIgqwL4b6pkday/IqyPseIFRaGsfRYRv/\nkfzGb2Q3ujqWXwHl/vsf9fe8WdrmCy7zq5Lxs0UVX0/ghl9H2iBZHgjH7L9Oxyaf\n6eqWjfSQ20oKyEiuA6nV\n=9YRV\n-----END PGP SIGNATURE-----", "payload": "tree 4bb1a1bd9c2887db2d5529784ad56bd2589bc64c\nparent e28f87375660ca0491a57bc3af0e3da98a9cf270\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474964093 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474964093 +0200\n\nreintroduce Lvalue and LvalueExtra"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d73a908dce98143b610ac154b7a2e35ad32847", "html_url": "https://github.com/rust-lang/rust/commit/d2d73a908dce98143b610ac154b7a2e35ad32847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2d73a908dce98143b610ac154b7a2e35ad32847/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e28f87375660ca0491a57bc3af0e3da98a9cf270", "url": "https://api.github.com/repos/rust-lang/rust/commits/e28f87375660ca0491a57bc3af0e3da98a9cf270", "html_url": "https://github.com/rust-lang/rust/commit/e28f87375660ca0491a57bc3af0e3da98a9cf270"}], "stats": {"total": 176, "additions": 80, "deletions": 96}, "files": [{"sha": "96cc8a4e8b9d7494324477908a5b50224d425318", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 78, "deletions": 73, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d2d73a908dce98143b610ac154b7a2e35ad32847/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d73a908dce98143b610ac154b7a2e35ad32847/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=d2d73a908dce98143b610ac154b7a2e35ad32847", "patch": "@@ -101,6 +101,20 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub stmt: usize,\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+struct Lvalue {\n+    ptr: Pointer,\n+    extra: LvalueExtra,\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+enum LvalueExtra {\n+    None,\n+    Length(u64),\n+    Vtable(Pointer),\n+    DowncastVariant(usize),\n+}\n+\n #[derive(Clone)]\n pub enum CachedMir<'mir, 'tcx: 'mir> {\n     Ref(&'mir mir::Mir<'tcx>),\n@@ -553,8 +567,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = self.lvalue_ty(lvalue);\n                 match ty.sty {\n                     ty::TyArray(_, n) => self.memory.write_usize(dest, n as u64)?,\n-                    ty::TySlice(_) => if let Value::ByValPair(_, len) = src {\n-                        self.memory.write_primval(dest, len)?;\n+                    ty::TySlice(_) => if let LvalueExtra::Length(len) = src.extra {\n+                        self.memory.write_usize(dest, len)?;\n                     } else {\n                         bug!(\"Rvalue::Len of a slice given non-slice pointer: {:?}\", src);\n                     },\n@@ -563,10 +577,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Ref(_, _, ref lvalue) => {\n-                match self.eval_lvalue(lvalue)? {\n-                    Value::ByRef(ptr) => self.memory.write_ptr(dest, ptr)?,\n-                    Value::ByVal(..) => bug!(\"cannot take reference of immediate\"),\n-                    pair @ Value::ByValPair(..) => self.write_value(pair, dest, dest_ty)?,\n+                let lvalue = self.eval_lvalue(lvalue)?;\n+                self.memory.write_ptr(dest, lvalue.ptr)?;\n+                let extra_ptr = dest.offset(self.memory.pointer_size() as isize);\n+                match lvalue.extra {\n+                    LvalueExtra::None => {},\n+                    LvalueExtra::Length(len) => self.memory.write_usize(extra_ptr, len)?,\n+                    LvalueExtra::Vtable(ptr) => self.memory.write_ptr(extra_ptr, ptr)?,\n+                    LvalueExtra::DowncastVariant(..) =>\n+                        bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 }\n             }\n \n@@ -762,7 +781,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n-            Consume(ref lvalue) => self.eval_lvalue(lvalue),\n+            Consume(ref lvalue) => Ok(Value::ByRef(self.eval_lvalue(lvalue)?.to_ptr())),\n \n             Constant(mir::Constant { ref literal, ty, .. }) => {\n                 use rustc::mir::repr::Literal;\n@@ -802,14 +821,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n-        let value = match *lvalue {\n-            ReturnPointer => Value::ByRef(self.frame().return_ptr\n-                .expect(\"ReturnPointer used in a function with no return value\")),\n-            Arg(i) => Value::ByRef(self.frame().locals[i.index()]),\n-            Var(i) => Value::ByRef(self.frame().locals[self.frame().var_offset + i.index()]),\n-            Temp(i) => Value::ByRef(self.frame().locals[self.frame().temp_offset + i.index()]),\n+        let ptr = match *lvalue {\n+            ReturnPointer => self.frame().return_ptr\n+                .expect(\"ReturnPointer used in a function with no return value\"),\n+            Arg(i) => self.frame().locals[i.index()],\n+            Var(i) => self.frame().locals[self.frame().var_offset + i.index()],\n+            Temp(i) => self.frame().locals[self.frame().temp_offset + i.index()],\n \n             Static(def_id) => {\n                 let substs = subst::Substs::empty(self.tcx);\n@@ -818,17 +837,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     substs: substs,\n                     kind: ConstantKind::Global,\n                 };\n-                Value::ByRef(*self.statics.get(&cid).expect(\"static should have been cached (lvalue)\"))\n+                *self.statics.get(&cid).expect(\"static should have been cached (lvalue)\")\n             },\n \n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n-                trace!(\"projection base: {:?}\", base);\n-                trace!(\"projection: {:?}\", proj.elem);\n-                match base {\n-                    Value::ByRef(ptr) => self.memory.dump(ptr.alloc_id),\n-                    _ => {},\n-                }\n                 let base_ty = self.lvalue_ty(&proj.base);\n                 let base_layout = self.type_layout(base_ty);\n \n@@ -840,12 +853,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let variant = match *base_layout {\n                             Univariant { ref variant, .. } => variant,\n                             General { ref variants, .. } => {\n-                                if let Value::ByValPair(PrimVal::Ptr(ptr), variant_idx) = base {\n-                                    // early exit, because enum variant field access is passed\n-                                    // as a non-fat-pointer ByValPair\n-                                    let idx = variant_idx.expect_uint(\"enum variant id not integral\") as usize;\n-                                    let offset = variants[idx].field_offset(field.index()).bytes() as isize;\n-                                    return Ok(ByRef(ptr.offset(offset)));\n+                                if let LvalueExtra::DowncastVariant(variant_idx) = base.extra {\n+                                    &variants[variant_idx]\n                                 } else {\n                                     bug!(\"field access on enum had no variant index\");\n                                 }\n@@ -858,36 +867,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n                         };\n \n-                        let offset = variant.field_offset(field.index()).bytes() as isize;\n-                        use self::value::Value::*;\n-                        match base {\n-                            ByRef(ptr) => if self.type_is_fat_ptr(field_ty) {\n-                                self.read_value(ptr.offset(offset), field_ty)?\n-                            } else {\n-                                ByRef(ptr.offset(offset))\n-                            },\n-                            // indexing into a field of an unsized struct\n-                            ByValPair(PrimVal::Ptr(ptr), extra) => if self.type_is_sized(field_ty) {\n-                                ByRef(ptr.offset(offset))\n-                            } else {\n-                                ByValPair(PrimVal::Ptr(ptr.offset(offset)), extra)\n-                            },\n-                            other => bug!(\"expected thin ptr, got: {:?}\", other),\n+                        let offset = variant.field_offset(field.index()).bytes();\n+                        let ptr = base.ptr.offset(offset as isize);\n+                        trace!(\"{:?}\", base);\n+                        trace!(\"{:?}\", field_ty);\n+                        if self.type_is_sized(field_ty) {\n+                            ptr\n+                        } else {\n+                            match base.extra {\n+                                LvalueExtra::None => bug!(\"expected fat pointer\"),\n+                                LvalueExtra::DowncastVariant(..) => bug!(\"Rust doesn't support unsized fields in enum variants\"),\n+                                LvalueExtra::Vtable(_) |\n+                                LvalueExtra::Length(_) => {},\n+                            }\n+                            return Ok(Lvalue {\n+                                ptr: ptr,\n+                                extra: base.extra,\n+                            });\n                         }\n                     },\n \n                     Downcast(_, variant) => {\n                         use rustc::ty::layout::Layout::*;\n                         match *base_layout {\n                             General { ref variants, .. } => {\n-                                use self::value::Value::*;\n-                                match base {\n-                                    ByRef(ptr) => return Ok(ByValPair(\n-                                        PrimVal::Ptr(ptr.offset(variants[variant].field_offset(1).bytes() as isize)),\n-                                        PrimVal::U64(variant as u64),\n-                                    )),\n-                                    other => bug!(\"bad downcast base: {:?}\", other),\n-                                }\n+                                return Ok(Lvalue {\n+                                    ptr: base.ptr.offset(variants[variant].field_offset(1).bytes() as isize),\n+                                    extra: LvalueExtra::DowncastVariant(variant),\n+                                });\n                             }\n                             RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n                                 return Ok(base);\n@@ -896,14 +903,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                     },\n \n-                    Deref => match self.follow_ref(base, base_ty)? {\n-                        Value::ByRef(..) => bug!(\"follow_ref broken\"),\n-                        // magical deref\n-                        Value::ByVal(PrimVal::Ptr(ptr)) => Value::ByRef(ptr),\n-                        Value::ByVal(..) => bug!(\"can't deref non pointer types\"),\n-                        // deref ops on fat pointers are no-ops\n-                        pair @ Value::ByValPair(..) => pair,\n-                    },\n+                    Deref => {\n+                        use primval::PrimVal::*;\n+                        use interpreter::value::Value::*;\n+                        let (ptr, extra) = match self.read_value(base.ptr, base_ty)? {\n+                            ByValPair(Ptr(ptr), Ptr(vptr)) => (ptr, LvalueExtra::Vtable(vptr)),\n+                            ByValPair(Ptr(ptr), n) => (ptr, LvalueExtra::Length(n.expect_uint(\"slice length\"))),\n+                            ByVal(Ptr(ptr)) => (ptr, LvalueExtra::None),\n+                            _ => bug!(\"can't deref non pointer types\"),\n+                        };\n+                        return Ok(Lvalue { ptr: ptr, extra: extra });\n+                    }\n \n                     Index(ref operand) => {\n                         let elem_size = match base_ty.sty {\n@@ -914,20 +924,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let n_ptr = self.eval_operand(operand)?;\n                         let usize = self.tcx.types.usize;\n                         let n = self.value_to_primval(n_ptr, usize)?.expect_uint(\"Projection::Index expected usize\");\n-                        match base {\n-                            Value::ByRef(ptr) |\n-                            Value::ByValPair(PrimVal::Ptr(ptr), _) |\n-                            Value::ByVal(PrimVal::Ptr(ptr)) => Value::ByRef(ptr.offset(n as isize * elem_size as isize)),\n-                            other => bug!(\"index op on {:?}\", other),\n-                        }\n+                        base.ptr.offset(n as isize * elem_size as isize)\n                     }\n \n                     ConstantIndex { .. } => unimplemented!(),\n                     Subslice { .. } => unimplemented!(),\n                 }\n             }\n         };\n-        Ok(value)\n+\n+        Ok(Lvalue { ptr: ptr, extra: LvalueExtra::None })\n     }\n \n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n@@ -1002,14 +1008,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    // ensures that this value isn't a `ByRef` anymore\n-    fn follow_ref(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        match value {\n-            Value::ByRef(ptr) => self.read_value(ptr, ty),\n-            other => Ok(other),\n-        }\n-    }\n-\n     fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         use syntax::ast::{IntTy, UintTy, FloatTy};\n         let val = match &ty.sty {\n@@ -1112,6 +1110,13 @@ fn pointee_type(ptr_ty: ty::Ty) -> Option<ty::Ty> {\n     }\n }\n \n+impl Lvalue {\n+    fn to_ptr(self) -> Pointer {\n+        assert_eq!(self.extra, LvalueExtra::None);\n+        self.ptr\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n     type Target = mir::Mir<'tcx>;\n     fn deref(&self) -> &mir::Mir<'tcx> {"}, {"sha": "6e2f138119369cf19a5bc59eab6925bf1c3468c9", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2d73a908dce98143b610ac154b7a2e35ad32847/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d73a908dce98143b610ac154b7a2e35ad32847/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=d2d73a908dce98143b610ac154b7a2e35ad32847", "patch": "@@ -43,13 +43,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                let discr_ptr = self.eval_lvalue(discr)?;\n+                let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n                 let discr_ty = self.lvalue_ty(discr);\n                 let discr_size = self\n                     .type_layout(discr_ty)\n                     .size(&self.tcx.data_layout)\n                     .bytes() as usize;\n-                let discr_val = discr_ptr.read_uint(&self.memory, discr_size)?;\n+                let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n                 if let ty::TyChar = discr_ty.sty {\n                     if ::std::char::from_u32(discr_val as u32).is_none() {\n                         return Err(EvalError::InvalidChar(discr_val as u64));"}, {"sha": "87a0e15cf75e7ef5d1d0cbe0da5022d0c29109be", "filename": "src/interpreter/value.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2d73a908dce98143b610ac154b7a2e35ad32847/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d73a908dce98143b610ac154b7a2e35ad32847/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=d2d73a908dce98143b610ac154b7a2e35ad32847", "patch": "@@ -30,27 +30,6 @@ impl Value {\n         }\n     }\n \n-    pub(super) fn read_uint<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>, size: usize) -> EvalResult<'tcx, u64> {\n-        use self::Value::*;\n-        match *self {\n-            ByRef(ptr) => mem.read_uint(ptr, size),\n-            ByVal(PrimVal::U8(u)) => Ok(u as u64),\n-            ByVal(PrimVal::U16(u)) => Ok(u as u64),\n-            ByVal(PrimVal::U32(u)) => Ok(u as u64),\n-            ByVal(PrimVal::U64(u)) => Ok(u as u64),\n-            ByValPair(..) => unimplemented!(),\n-            ByVal(_other) => unimplemented!(),\n-        }\n-    }\n-\n-    pub(super) fn to_ptr(&self) -> Pointer {\n-        use self::Value::*;\n-        match *self {\n-            ByRef(ptr) => ptr,\n-            other => bug!(\"expected pointer, got {:?}\", other),\n-        }\n-    }\n-\n     pub(super) fn expect_vtable<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {"}]}