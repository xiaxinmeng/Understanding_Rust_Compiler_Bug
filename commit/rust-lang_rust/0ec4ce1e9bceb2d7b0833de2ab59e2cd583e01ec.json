{"sha": "0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYzRjZTFlOWJjZWIyZDdiMDgzM2RlMmFiNTllMmNkNTgzZTAxZWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-23T11:03:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-23T11:03:18Z"}, "message": "Merge #8938\n\n8938: internal: Fix #8931 r=flodiebold a=flodiebold\n\n  - and add some better checking for similar bugs\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "56ee0561e7f7240a0571e0c1be484c83bf985541", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56ee0561e7f7240a0571e0c1be484c83bf985541"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgqjZ2CRBK7hj4Ov3rIwAAGcUIACnTaCHY6cgJwNM13+bpBWms\nGH3r4EAW8pidTcxUz4K/xZhssAA1p+BXN+SKBlqasXCslkFU8/lJ8r3I+ZH+MknO\naunbSyK3JX5mRE4N048R+qN1DW2Jqm8KiranK32TJ95MqZb+/W02fq+O+mZtQKgN\niwkReKELgpoJQeN47xiuuiap2VKPzNnp/WdBgQOP5QmyIZODQr2UTjk1hM2alttr\ny3vvF/5gSkT4asOsZlG5qWN5dDylbQH2ZTsgHq3mzWI0cnLjaxJXUthpE6IuvH7H\nispL65gkEW96Pt8ndqsBAiFb8lSRFjLwvk/2ULLKELFi0PbuJFbbbpW2+XMg68Q=\n=3sRT\n-----END PGP SIGNATURE-----\n", "payload": "tree 56ee0561e7f7240a0571e0c1be484c83bf985541\nparent 808ebe4b865176dcc394ea4adcb3a24f60955734\nparent 34a3bc4196db302ea5b31c51b6d555336965be5f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621767798 +0000\ncommitter GitHub <noreply@github.com> 1621767798 +0000\n\nMerge #8938\n\n8938: internal: Fix #8931 r=flodiebold a=flodiebold\n\n  - and add some better checking for similar bugs\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec", "html_url": "https://github.com/rust-lang/rust/commit/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "808ebe4b865176dcc394ea4adcb3a24f60955734", "url": "https://api.github.com/repos/rust-lang/rust/commits/808ebe4b865176dcc394ea4adcb3a24f60955734", "html_url": "https://github.com/rust-lang/rust/commit/808ebe4b865176dcc394ea4adcb3a24f60955734"}, {"sha": "34a3bc4196db302ea5b31c51b6d555336965be5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/34a3bc4196db302ea5b31c51b6d555336965be5f", "html_url": "https://github.com/rust-lang/rust/commit/34a3bc4196db302ea5b31c51b6d555336965be5f"}], "stats": {"total": 133, "additions": 118, "deletions": 15}, "files": [{"sha": "800101c91968f879d6b331f242bfe5ea7c3bcfb7", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec", "patch": "@@ -2053,7 +2053,7 @@ impl Type {\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n-        let canonical = hir_ty::replace_errors_with_variables(self.ty.clone());\n+        let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n \n         let env = self.env.clone();\n         let krate = krate.id;\n@@ -2222,7 +2222,7 @@ impl Type {\n     }\n \n     pub fn could_unify_with(&self, db: &dyn HirDatabase, other: &Type) -> bool {\n-        let tys = hir_ty::replace_errors_with_variables((self.ty.clone(), other.ty.clone()));\n+        let tys = hir_ty::replace_errors_with_variables(&(self.ty.clone(), other.ty.clone()));\n         could_unify(db, self.env.clone(), &tys)\n     }\n }"}, {"sha": "1b5064b5a20d6203149ec7ca935db60c25596d6a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec", "patch": "@@ -505,9 +505,10 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n-        // FIXME: this erases Substs\n+        // FIXME: this erases Substs, we should instead record the correct\n+        // substitution during inference and use that\n         let func = self.resolve_method_call(call)?;\n-        let (ty, _) = self.db.value_ty(func.into()).into_value_and_skipped_binders();\n+        let ty = hir_ty::TyBuilder::value_ty(self.db, func.into()).fill_with_unknown().build();\n         let resolver = self.analyze(call.syntax()).resolver;\n         let ty = Type::new_with_resolver(self.db, &resolver, ty)?;\n         let mut res = ty.as_callable(self.db)?;"}, {"sha": "ef021978aded67a22552bbfc15737f4eabb67302", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 83, "deletions": 11, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec", "patch": "@@ -43,7 +43,6 @@ use hir_def::{\n     type_ref::{ConstScalar, Rawness},\n     TypeParamId,\n };\n-use stdx::always;\n \n use crate::{db::HirDatabase, utils::generics};\n \n@@ -329,14 +328,17 @@ pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n     t.fold_with(&mut TyFolder(f), binders).expect(\"fold failed unexpectedly\")\n }\n \n-pub fn replace_errors_with_variables<T>(t: T) -> Canonical<T::Result>\n+/// 'Canonicalizes' the `t` by replacing any errors with new variables. Also\n+/// ensures there are no unbound variables or inference variables anywhere in\n+/// the `t`.\n+pub fn replace_errors_with_variables<T>(t: &T) -> Canonical<T::Result>\n where\n-    T: HasInterner<Interner = Interner> + Fold<Interner>,\n+    T: HasInterner<Interner = Interner> + Fold<Interner> + Clone,\n     T::Result: HasInterner<Interner = Interner>,\n {\n     use chalk_ir::{\n         fold::{Folder, SuperFold},\n-        Fallible,\n+        Fallible, NoSolution,\n     };\n     struct ErrorReplacer {\n         vars: usize,\n@@ -363,18 +365,88 @@ where\n \n         fn fold_inference_ty(\n             &mut self,\n-            var: InferenceVar,\n-            kind: TyVariableKind,\n+            _var: InferenceVar,\n+            _kind: TyVariableKind,\n+            _outer_binder: DebruijnIndex,\n+        ) -> Fallible<Ty> {\n+            if cfg!(debug_assertions) {\n+                // we don't want to just panic here, because then the error message\n+                // won't contain the whole thing, which would not be very helpful\n+                Err(NoSolution)\n+            } else {\n+                Ok(TyKind::Error.intern(&Interner))\n+            }\n+        }\n+\n+        fn fold_free_var_ty(\n+            &mut self,\n+            _bound_var: BoundVar,\n             _outer_binder: DebruijnIndex,\n         ) -> Fallible<Ty> {\n-            always!(false);\n-            Ok(TyKind::InferenceVar(var, kind).intern(&Interner))\n+            if cfg!(debug_assertions) {\n+                // we don't want to just panic here, because then the error message\n+                // won't contain the whole thing, which would not be very helpful\n+                Err(NoSolution)\n+            } else {\n+                Ok(TyKind::Error.intern(&Interner))\n+            }\n+        }\n+\n+        fn fold_inference_const(\n+            &mut self,\n+            _ty: Ty,\n+            _var: InferenceVar,\n+            _outer_binder: DebruijnIndex,\n+        ) -> Fallible<Const> {\n+            if cfg!(debug_assertions) {\n+                Err(NoSolution)\n+            } else {\n+                Ok(dummy_usize_const())\n+            }\n+        }\n+\n+        fn fold_free_var_const(\n+            &mut self,\n+            _ty: Ty,\n+            _bound_var: BoundVar,\n+            _outer_binder: DebruijnIndex,\n+        ) -> Fallible<Const> {\n+            if cfg!(debug_assertions) {\n+                Err(NoSolution)\n+            } else {\n+                Ok(dummy_usize_const())\n+            }\n+        }\n+\n+        fn fold_inference_lifetime(\n+            &mut self,\n+            _var: InferenceVar,\n+            _outer_binder: DebruijnIndex,\n+        ) -> Fallible<Lifetime> {\n+            if cfg!(debug_assertions) {\n+                Err(NoSolution)\n+            } else {\n+                Ok(static_lifetime())\n+            }\n+        }\n+\n+        fn fold_free_var_lifetime(\n+            &mut self,\n+            _bound_var: BoundVar,\n+            _outer_binder: DebruijnIndex,\n+        ) -> Fallible<Lifetime> {\n+            if cfg!(debug_assertions) {\n+                Err(NoSolution)\n+            } else {\n+                Ok(static_lifetime())\n+            }\n         }\n     }\n     let mut error_replacer = ErrorReplacer { vars: 0 };\n-    let value = t\n-        .fold_with(&mut error_replacer, DebruijnIndex::INNERMOST)\n-        .expect(\"fold failed unexpectedly\");\n+    let value = match t.clone().fold_with(&mut error_replacer, DebruijnIndex::INNERMOST) {\n+        Ok(t) => t,\n+        Err(_) => panic!(\"Encountered unbound or inference vars in {:?}\", t),\n+    };\n     let kinds = (0..error_replacer.vars).map(|_| {\n         chalk_ir::CanonicalVarKind::new(\n             chalk_ir::VariableKind::Ty(TyVariableKind::General),"}, {"sha": "fd97387437be4cda7b81463f03df62d40a233465", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=0ec4ce1e9bceb2d7b0833de2ab59e2cd583e01ec", "patch": "@@ -454,4 +454,34 @@ mod foo {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn issue_8931() {\n+        check(\n+            r#\"\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+struct S;\n+\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) -> &[u8] { loop {} }\n+}\n+\n+impl S {\n+    fn indented(&mut self, f: impl FnOnce(&mut Self)) {\n+    }\n+\n+    fn f(&mut self, v: Foo) {\n+        self.indented(|this| v.$0)\n+    }\n+}\n+        \"#,\n+            expect![[r#\"\n+                me foo() fn(&self) -> &[u8]\n+            \"#]],\n+        );\n+    }\n }"}]}