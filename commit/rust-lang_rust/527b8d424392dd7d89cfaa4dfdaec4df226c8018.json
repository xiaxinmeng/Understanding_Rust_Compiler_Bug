{"sha": "527b8d424392dd7d89cfaa4dfdaec4df226c8018", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyN2I4ZDQyNDM5MmRkN2Q4OWNmYWE0ZGZkYWVjNGRmMjI2YzgwMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-18T11:34:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-18T11:34:11Z"}, "message": "Auto merge of #57065 - Zoxc:graph-tweaks, r=michaelwoerister\n\nOptimize try_mark_green and eliminate the lock on dep node colors\n\nBlocked on https://github.com/rust-lang/rust/pull/56614\n\nr? @michaelwoerister", "tree": {"sha": "e8b13998619187e3cd143cf6f964e75b16f35c16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8b13998619187e3cd143cf6f964e75b16f35c16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/527b8d424392dd7d89cfaa4dfdaec4df226c8018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/527b8d424392dd7d89cfaa4dfdaec4df226c8018", "html_url": "https://github.com/rust-lang/rust/commit/527b8d424392dd7d89cfaa4dfdaec4df226c8018", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/527b8d424392dd7d89cfaa4dfdaec4df226c8018/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38650b69cafbff61d71a275ced1e9866a08a36c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/38650b69cafbff61d71a275ced1e9866a08a36c0", "html_url": "https://github.com/rust-lang/rust/commit/38650b69cafbff61d71a275ced1e9866a08a36c0"}, {"sha": "13136787849c960db824b2ad15d227dc15fadd70", "url": "https://api.github.com/repos/rust-lang/rust/commits/13136787849c960db824b2ad15d227dc15fadd70", "html_url": "https://github.com/rust-lang/rust/commit/13136787849c960db824b2ad15d227dc15fadd70"}], "stats": {"total": 230, "additions": 117, "deletions": 113}, "files": [{"sha": "0a0dff05cb1ab71a4f6892c9b926ffb428828822", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 99, "deletions": 63, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/527b8d424392dd7d89cfaa4dfdaec4df226c8018/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527b8d424392dd7d89cfaa4dfdaec4df226c8018/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=527b8d424392dd7d89cfaa4dfdaec4df226c8018", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n-use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, Ordering};\n use std::env;\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n@@ -58,7 +58,7 @@ struct DepGraphData {\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n     previous: PreviousDepGraph,\n \n-    colors: Lock<DepNodeColorMap>,\n+    colors: DepNodeColorMap,\n \n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n@@ -84,7 +84,7 @@ impl DepGraph {\n                 dep_node_debug: Default::default(),\n                 current: Lock::new(CurrentDepGraph::new(prev_graph_node_count)),\n                 previous: prev_graph,\n-                colors: Lock::new(DepNodeColorMap::new(prev_graph_node_count)),\n+                colors: DepNodeColorMap::new(prev_graph_node_count),\n                 loaded_from_cache: Default::default(),\n             })),\n         }\n@@ -282,12 +282,11 @@ impl DepGraph {\n                     DepNodeColor::Red\n                 };\n \n-                let mut colors = data.colors.borrow_mut();\n-                debug_assert!(colors.get(prev_index).is_none(),\n+                debug_assert!(data.colors.get(prev_index).is_none(),\n                               \"DepGraph::with_task() - Duplicate DepNodeColor \\\n                                insertion for {:?}\", key);\n \n-                colors.insert(prev_index, color);\n+                data.colors.insert(prev_index, color);\n             }\n \n             (result, dep_node_index)\n@@ -502,7 +501,7 @@ impl DepGraph {\n     pub fn node_color(&self, dep_node: &DepNode) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n             if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n-                return data.colors.borrow().get(prev_index)\n+                return data.colors.get(prev_index)\n             } else {\n                 // This is a node that did not exist in the previous compilation\n                 // session, so we consider it to be red.\n@@ -513,56 +512,89 @@ impl DepGraph {\n         None\n     }\n \n-    pub fn try_mark_green<'tcx>(&self,\n-                                tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                                dep_node: &DepNode)\n-                                -> Option<DepNodeIndex> {\n-        debug!(\"try_mark_green({:?}) - BEGIN\", dep_node);\n-        let data = self.data.as_ref().unwrap();\n+    /// Try to read a node index for the node dep_node.\n+    /// A node will have an index, when it's already been marked green, or when we can mark it\n+    /// green. This function will mark the current task as a reader of the specified node, when\n+    /// a node index can be found for that node.\n+    pub fn try_mark_green_and_read(\n+        &self,\n+        tcx: TyCtxt<'_, '_, '_>,\n+        dep_node: &DepNode\n+    ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n+        self.try_mark_green(tcx, dep_node).map(|(prev_index, dep_node_index)| {\n+            debug_assert!(self.is_green(&dep_node));\n+            self.read_index(dep_node_index);\n+            (prev_index, dep_node_index)\n+        })\n+    }\n \n-        #[cfg(not(parallel_queries))]\n-        debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n-\n-        if dep_node.kind.is_input() {\n-            // We should only hit try_mark_green() for inputs that do not exist\n-            // anymore in the current compilation session. Existing inputs are\n-            // eagerly marked as either red/green before any queries are\n-            // executed.\n-            debug_assert!(dep_node.extract_def_id(tcx).is_none());\n-            debug!(\"try_mark_green({:?}) - END - DepNode is deleted input\", dep_node);\n-            return None;\n-        }\n+    pub fn try_mark_green(\n+        &self,\n+        tcx: TyCtxt<'_, '_, '_>,\n+        dep_node: &DepNode\n+    ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n+        debug_assert!(!dep_node.kind.is_input());\n+\n+        // Return None if the dep graph is disabled\n+        let data = self.data.as_ref()?;\n+\n+        // Return None if the dep node didn't exist in the previous session\n+        let prev_index = data.previous.node_to_index_opt(dep_node)?;\n \n-        let (prev_deps, prev_dep_node_index) = match data.previous.edges_from(dep_node) {\n-            Some(prev) => {\n+        match data.colors.get(prev_index) {\n+            Some(DepNodeColor::Green(dep_node_index)) => Some((prev_index, dep_node_index)),\n+            Some(DepNodeColor::Red) => None,\n+            None => {\n                 // This DepNode and the corresponding query invocation existed\n                 // in the previous compilation session too, so we can try to\n                 // mark it as green by recursively marking all of its\n                 // dependencies green.\n-                prev\n-            }\n-            None => {\n-                // This DepNode did not exist in the previous compilation session,\n-                // so we cannot mark it as green.\n-                debug!(\"try_mark_green({:?}) - END - DepNode does not exist in \\\n-                        current compilation session anymore\", dep_node);\n-                return None\n+                self.try_mark_previous_green(\n+                    tcx.global_tcx(),\n+                    data,\n+                    prev_index,\n+                    &dep_node\n+                ).map(|dep_node_index| {\n+                    (prev_index, dep_node_index)\n+                })\n             }\n-        };\n+        }\n+    }\n+\n+    /// Try to mark a dep-node which existed in the previous compilation session as green\n+    fn try_mark_previous_green<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        data: &DepGraphData,\n+        prev_dep_node_index: SerializedDepNodeIndex,\n+        dep_node: &DepNode\n+    ) -> Option<DepNodeIndex> {\n+        debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n \n-        debug_assert!(data.colors.borrow().get(prev_dep_node_index).is_none());\n+        #[cfg(not(parallel_queries))]\n+        {\n+            debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n+            debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n+        }\n+\n+        // We never try to mark inputs as green\n+        debug_assert!(!dep_node.kind.is_input());\n+\n+        debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n+\n+        let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n         let mut current_deps = SmallVec::new();\n \n         for &dep_dep_node_index in prev_deps {\n-            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n+            let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n             match dep_dep_node_color {\n                 Some(DepNodeColor::Green(node_index)) => {\n                     // This dependency has been marked as green before, we are\n                     // still fine and can continue with checking the other\n                     // dependencies.\n-                    debug!(\"try_mark_green({:?}) --- found dependency {:?} to \\\n+                    debug!(\"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n                             be immediately green\",\n                             dep_node,\n                             data.previous.index_to_node(dep_dep_node_index));\n@@ -573,7 +605,7 @@ impl DepGraph {\n                     // compared to the previous compilation session. We cannot\n                     // mark the DepNode as green and also don't need to bother\n                     // with checking any of the other dependencies.\n-                    debug!(\"try_mark_green({:?}) - END - dependency {:?} was \\\n+                    debug!(\"try_mark_previous_green({:?}) - END - dependency {:?} was \\\n                             immediately red\",\n                             dep_node,\n                             data.previous.index_to_node(dep_dep_node_index));\n@@ -585,12 +617,18 @@ impl DepGraph {\n                     // We don't know the state of this dependency. If it isn't\n                     // an input node, let's try to mark it green recursively.\n                     if !dep_dep_node.kind.is_input() {\n-                         debug!(\"try_mark_green({:?}) --- state of dependency {:?} \\\n+                         debug!(\"try_mark_previous_green({:?}) --- state of dependency {:?} \\\n                                  is unknown, trying to mark it green\", dep_node,\n                                  dep_dep_node);\n \n-                        if let Some(node_index) = self.try_mark_green(tcx, dep_dep_node) {\n-                            debug!(\"try_mark_green({:?}) --- managed to MARK \\\n+                        let node_index = self.try_mark_previous_green(\n+                            tcx,\n+                            data,\n+                            dep_dep_node_index,\n+                            dep_dep_node\n+                        );\n+                        if let Some(node_index) = node_index {\n+                            debug!(\"try_mark_previous_green({:?}) --- managed to MARK \\\n                                     dependency {:?} as green\", dep_node, dep_dep_node);\n                             current_deps.push(node_index);\n                             continue;\n@@ -620,28 +658,28 @@ impl DepGraph {\n                     }\n \n                     // We failed to mark it green, so we try to force the query.\n-                    debug!(\"try_mark_green({:?}) --- trying to force \\\n+                    debug!(\"try_mark_previous_green({:?}) --- trying to force \\\n                             dependency {:?}\", dep_node, dep_dep_node);\n                     if ::ty::query::force_from_dep_node(tcx, dep_dep_node) {\n-                        let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n+                        let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n                             Some(DepNodeColor::Green(node_index)) => {\n-                                debug!(\"try_mark_green({:?}) --- managed to \\\n+                                debug!(\"try_mark_previous_green({:?}) --- managed to \\\n                                         FORCE dependency {:?} to green\",\n                                         dep_node, dep_dep_node);\n                                 current_deps.push(node_index);\n                             }\n                             Some(DepNodeColor::Red) => {\n-                                debug!(\"try_mark_green({:?}) - END - \\\n+                                debug!(\"try_mark_previous_green({:?}) - END - \\\n                                         dependency {:?} was red after forcing\",\n                                        dep_node,\n                                        dep_dep_node);\n                                 return None\n                             }\n                             None => {\n                                 if !tcx.sess.has_errors() {\n-                                    bug!(\"try_mark_green() - Forcing the DepNode \\\n+                                    bug!(\"try_mark_previous_green() - Forcing the DepNode \\\n                                           should have set its color\")\n                                 } else {\n                                     // If the query we just forced has resulted\n@@ -653,7 +691,7 @@ impl DepGraph {\n                         }\n                     } else {\n                         // The DepNode could not be forced.\n-                        debug!(\"try_mark_green({:?}) - END - dependency {:?} \\\n+                        debug!(\"try_mark_previous_green({:?}) - END - dependency {:?} \\\n                                 could not be forced\", dep_node, dep_dep_node);\n                         return None\n                     }\n@@ -705,16 +743,15 @@ impl DepGraph {\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n-        let mut colors = data.colors.borrow_mut();\n         // Multiple threads can all write the same color here\n         #[cfg(not(parallel_queries))]\n-        debug_assert!(colors.get(prev_dep_node_index).is_none(),\n-                      \"DepGraph::try_mark_green() - Duplicate DepNodeColor \\\n+        debug_assert!(data.colors.get(prev_dep_node_index).is_none(),\n+                      \"DepGraph::try_mark_previous_green() - Duplicate DepNodeColor \\\n                       insertion for {:?}\", dep_node);\n \n-        colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n+        data.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n \n-        debug!(\"try_mark_green({:?}) - END - successfully marked as green\", dep_node);\n+        debug!(\"try_mark_previous_green({:?}) - END - successfully marked as green\", dep_node);\n         Some(dep_node_index)\n     }\n \n@@ -735,9 +772,8 @@ impl DepGraph {\n     pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let green_nodes: Vec<DepNode> = {\n             let data = self.data.as_ref().unwrap();\n-            let colors = data.colors.borrow();\n-            colors.values.indices().filter_map(|prev_index| {\n-                match colors.get(prev_index) {\n+            data.colors.values.indices().filter_map(|prev_index| {\n+                match data.colors.get(prev_index) {\n                     Some(DepNodeColor::Green(_)) => {\n                         let dep_node = data.previous.index_to_node(prev_index);\n                         if dep_node.cache_on_disk(tcx) {\n@@ -1035,7 +1071,7 @@ pub struct TaskDeps {\n // A data structure that stores Option<DepNodeColor> values as a contiguous\n // array, using one u32 per entry.\n struct DepNodeColorMap {\n-    values: IndexVec<SerializedDepNodeIndex, u32>,\n+    values: IndexVec<SerializedDepNodeIndex, AtomicU32>,\n }\n \n const COMPRESSED_NONE: u32 = 0;\n@@ -1045,12 +1081,12 @@ const COMPRESSED_FIRST_GREEN: u32 = 2;\n impl DepNodeColorMap {\n     fn new(size: usize) -> DepNodeColorMap {\n         DepNodeColorMap {\n-            values: IndexVec::from_elem_n(COMPRESSED_NONE, size)\n+            values: (0..size).map(|_| AtomicU32::new(COMPRESSED_NONE)).collect(),\n         }\n     }\n \n     fn get(&self, index: SerializedDepNodeIndex) -> Option<DepNodeColor> {\n-        match self.values[index] {\n+        match self.values[index].load(Ordering::Acquire) {\n             COMPRESSED_NONE => None,\n             COMPRESSED_RED => Some(DepNodeColor::Red),\n             value => Some(DepNodeColor::Green(DepNodeIndex::from_u32(\n@@ -1059,10 +1095,10 @@ impl DepNodeColorMap {\n         }\n     }\n \n-    fn insert(&mut self, index: SerializedDepNodeIndex, color: DepNodeColor) {\n-        self.values[index] = match color {\n+    fn insert(&self, index: SerializedDepNodeIndex, color: DepNodeColor) {\n+        self.values[index].store(match color {\n             DepNodeColor::Red => COMPRESSED_RED,\n             DepNodeColor::Green(index) => index.as_u32() + COMPRESSED_FIRST_GREEN,\n-        }\n+        }, Ordering::Release)\n     }\n }"}, {"sha": "ea5350ac97fee46fc87c922ef6ac48337a7ff27a", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/527b8d424392dd7d89cfaa4dfdaec4df226c8018/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527b8d424392dd7d89cfaa4dfdaec4df226c8018/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=527b8d424392dd7d89cfaa4dfdaec4df226c8018", "patch": "@@ -19,14 +19,11 @@ impl PreviousDepGraph {\n     }\n \n     #[inline]\n-    pub fn edges_from(&self,\n-                      dep_node: &DepNode)\n-                      -> Option<(&[SerializedDepNodeIndex], SerializedDepNodeIndex)> {\n-        self.index\n-            .get(dep_node)\n-            .map(|&node_index| {\n-                (self.data.edge_targets_from(node_index), node_index)\n-            })\n+    pub fn edge_targets_from(\n+        &self,\n+        dep_node_index: SerializedDepNodeIndex\n+    ) -> &[SerializedDepNodeIndex] {\n+        self.data.edge_targets_from(dep_node_index)\n     }\n \n     #[inline]"}, {"sha": "5d827e07c5997d7394cd792acb5c2e4d3593d133", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/527b8d424392dd7d89cfaa4dfdaec4df226c8018/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527b8d424392dd7d89cfaa4dfdaec4df226c8018/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=527b8d424392dd7d89cfaa4dfdaec4df226c8018", "patch": "@@ -2,7 +2,7 @@\n //! that generate the actual methods on tcx which find and execute the\n //! provider, manage the caches, and so forth.\n \n-use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n+use dep_graph::{DepNodeIndex, DepNode, DepKind, SerializedDepNodeIndex};\n use errors::DiagnosticBuilder;\n use errors::Level;\n use errors::Diagnostic;\n@@ -335,40 +335,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         eprintln!(\"end of query stack\");\n     }\n \n-    /// Try to read a node index for the node dep_node.\n-    /// A node will have an index, when it's already been marked green, or when we can mark it\n-    /// green. This function will mark the current task as a reader of the specified node, when\n-    /// a node index can be found for that node.\n-    pub(super) fn try_mark_green_and_read(self, dep_node: &DepNode) -> Option<DepNodeIndex> {\n-        match self.dep_graph.node_color(dep_node) {\n-            Some(DepNodeColor::Green(dep_node_index)) => {\n-                self.dep_graph.read_index(dep_node_index);\n-                Some(dep_node_index)\n-            }\n-            Some(DepNodeColor::Red) => {\n-                None\n-            }\n-            None => {\n-                // try_mark_green (called below) will panic when full incremental\n-                // compilation is disabled. If that's the case, we can't try to mark nodes\n-                // as green anyway, so we can safely return None here.\n-                if !self.dep_graph.is_fully_enabled() {\n-                    return None;\n-                }\n-                match self.dep_graph.try_mark_green(self.global_tcx(), &dep_node) {\n-                    Some(dep_node_index) => {\n-                        debug_assert!(self.dep_graph.is_green(&dep_node));\n-                        self.dep_graph.read_index(dep_node_index);\n-                        Some(dep_node_index)\n-                    }\n-                    None => {\n-                        None\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     #[inline(never)]\n     fn try_get_with<Q: QueryDescription<'gcx>>(\n         self,\n@@ -435,10 +401,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if !dep_node.kind.is_input() {\n-            if let Some(dep_node_index) = self.try_mark_green_and_read(&dep_node) {\n+            if let Some((prev_dep_node_index,\n+                         dep_node_index)) = self.dep_graph.try_mark_green_and_read(self,\n+                                                                                   &dep_node) {\n                 return Ok(self.load_from_disk_and_cache_in_memory::<Q>(\n                     key,\n                     job,\n+                    prev_dep_node_index,\n                     dep_node_index,\n                     &dep_node\n                 ))\n@@ -454,6 +423,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         key: Q::Key,\n         job: JobOwner<'a, 'gcx, Q>,\n+        prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node_index: DepNodeIndex,\n         dep_node: &DepNode\n     ) -> Q::Value\n@@ -466,10 +436,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // First we try to load the result from the on-disk cache\n         let result = if Q::cache_on_disk(key.clone()) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n-            let prev_dep_node_index =\n-                self.dep_graph.prev_dep_node_index_of(dep_node);\n-            let result = Q::try_load_from_disk(self.global_tcx(),\n-                                               prev_dep_node_index);\n+            let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n \n             // We always expect to find a cached result for things that\n             // can be forced from DepNode.\n@@ -624,7 +591,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Ensuring an \"input\" or anonymous query makes no sense\n         assert!(!dep_node.kind.is_anon());\n         assert!(!dep_node.kind.is_input());\n-        if self.try_mark_green_and_read(&dep_node).is_none() {\n+        if self.dep_graph.try_mark_green_and_read(self, &dep_node).is_none() {\n             // A None return from `try_mark_green_and_read` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n             // Either way, we can't call `dep_graph.read()` as we don't have the"}, {"sha": "0253eef4dfa3aae0a6475f43a906c358c9dbd17d", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/527b8d424392dd7d89cfaa4dfdaec4df226c8018/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527b8d424392dd7d89cfaa4dfdaec4df226c8018/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=527b8d424392dd7d89cfaa4dfdaec4df226c8018", "patch": "@@ -70,6 +70,7 @@ cfg_if! {\n         pub struct Atomic<T: Copy>(Cell<T>);\n \n         impl<T: Copy> Atomic<T> {\n+            #[inline]\n             pub fn new(v: T) -> Self {\n                 Atomic(Cell::new(v))\n             }\n@@ -80,10 +81,12 @@ cfg_if! {\n                 self.0.into_inner()\n             }\n \n+            #[inline]\n             pub fn load(&self, _: Ordering) -> T {\n                 self.0.get()\n             }\n \n+            #[inline]\n             pub fn store(&self, val: T, _: Ordering) {\n                 self.0.set(val)\n             }\n@@ -118,6 +121,7 @@ cfg_if! {\n \n         pub type AtomicUsize = Atomic<usize>;\n         pub type AtomicBool = Atomic<bool>;\n+        pub type AtomicU32 = Atomic<u32>;\n         pub type AtomicU64 = Atomic<u64>;\n \n         pub use self::serial_join as join;\n@@ -223,7 +227,7 @@ cfg_if! {\n         pub use parking_lot::MutexGuard as LockGuard;\n         pub use parking_lot::MappedMutexGuard as MappedLockGuard;\n \n-        pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU64};\n+        pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n \n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;"}]}