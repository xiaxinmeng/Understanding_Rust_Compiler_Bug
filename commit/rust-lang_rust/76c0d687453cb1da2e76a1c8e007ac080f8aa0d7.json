{"sha": "76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzBkNjg3NDUzY2IxZGEyZTc2YTFjOGUwMDdhYzA4MGY4YWEwZDc=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-02-23T17:48:54Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:19:04Z"}, "message": "Rename \"parameter\" to \"arg\"", "tree": {"sha": "3808eb6cc3f7fd9128488f3fca580e50f6702ff3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3808eb6cc3f7fd9128488f3fca580e50f6702ff3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "html_url": "https://github.com/rust-lang/rust/commit/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e89753283a3d08704ab293b337d255e5d5e5210", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e89753283a3d08704ab293b337d255e5d5e5210", "html_url": "https://github.com/rust-lang/rust/commit/3e89753283a3d08704ab293b337d255e5d5e5210"}], "stats": {"total": 597, "additions": 242, "deletions": 355}, "files": [{"sha": "fef33939fac6a3c91802ee169d3c313774c05d03", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -648,15 +648,15 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n     visitor.visit_name(path_span, segment.name);\n-    if let Some(ref parameters) = segment.parameters {\n-        visitor.visit_generic_args(path_span, parameters);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(path_span, args);\n     }\n }\n \n pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                 _path_span: Span,\n                                                 generic_args: &'v GenericArgs) {\n-    walk_list!(visitor, visit_generic_arg, &generic_args.parameters);\n+    walk_list!(visitor, visit_generic_arg, &generic_args.args);\n     walk_list!(visitor, visit_assoc_type_binding, &generic_args.bindings);\n }\n "}, {"sha": "831a689a349979b123f2a8fc7008e5a223007114", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -59,6 +59,7 @@ use std::fmt::Debug;\n use std::iter;\n use std::mem;\n use syntax::attr;\n+use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n@@ -1039,14 +1040,14 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_generic_arg(&mut self,\n-                        p: &AngleBracketedParam,\n+                        p: &ast::GenericArg,\n                         itctx: ImplTraitContext)\n-                        -> GenericArg {\n+                        -> hir::GenericArg {\n         match p {\n-            AngleBracketedParam::Lifetime(lt) => {\n+            ast::GenericArg::Lifetime(lt) => {\n                 GenericArg::Lifetime(self.lower_lifetime(&lt))\n             }\n-            AngleBracketedParam::Type(ty) => {\n+            ast::GenericArg::Type(ty) => {\n                 GenericArg::Type(self.lower_ty(&ty, itctx))\n             }\n         }\n@@ -1684,8 +1685,7 @@ impl<'a> LoweringContext<'a> {\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n         itctx: ImplTraitContext,\n     ) -> hir::PathSegment {\n-        let (mut generic_args, infer_types) =\n-            if let Some(ref generic_args) = segment.parameters {\n+        let (mut generic_args, infer_types) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized parameters may only be used with a trait\";\n             match **generic_args {\n                 GenericArgs::AngleBracketed(ref data) => {\n@@ -1715,27 +1715,30 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         if !generic_args.parenthesized && generic_args.lifetimes().count() == 0 {\n-            generic_args.parameters = (0..expected_lifetimes).map(|_| {\n-                GenericArg::Lifetime(self.elided_lifetime(path_span))\n-            }).chain(generic_args.parameters.into_iter()).collect();\n+            generic_args.args =\n+                self.elided_path_lifetimes(path_span, expected_lifetimes)\n+                    .into_iter()\n+                    .map(|lt| GenericArg::Lifetime(lt))\n+                    .chain(generic_args.args.into_iter())\n+                    .collect();\n         }\n \n         hir::PathSegment::new(\n-            self.lower_ident(segment.identifier),\n+            self.lower_ident(segment.ident),\n             generic_args,\n             infer_types\n         )\n     }\n \n     fn lower_angle_bracketed_parameter_data(\n         &mut self,\n-        data: &AngleBracketedParameterData,\n+        data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n         itctx: ImplTraitContext,\n     ) -> (hir::GenericArgs, bool) {\n-        let &AngleBracketedParameterData { ref parameters, ref bindings, .. } = data;\n+        let &AngleBracketedArgs { ref args, ref bindings, .. } = data;\n         (hir::GenericArgs {\n-            parameters: parameters.iter().map(|p| self.lower_generic_arg(p, itctx)).collect(),\n+            args: args.iter().map(|p| self.lower_generic_arg(p, itctx)).collect(),\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx)).collect(),\n             parenthesized: false,\n         },\n@@ -1755,23 +1758,11 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::PassThrough,\n             |this| {\n                 const DISALLOWED: ImplTraitContext = ImplTraitContext::Disallowed;\n-                let &ParenthesizedParameterData {\n-                    ref inputs,\n-                    ref output,\n-                    span,\n-                } = data;\n-                let inputs = inputs\n-                    .iter()\n-                    .map(|ty| this.lower_ty(ty, DISALLOWED))\n-                    .collect();\n+                let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n+                let inputs = inputs.iter().map(|ty| this.lower_ty(ty, DISALLOWED)).collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                    P(hir::Ty {\n-                        node: hir::TyTup(tys),\n-                        id: node_id,\n-                        hir_id,\n-                        span,\n-                    })\n+                    P(hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span })\n                 };\n \n                 ("}, {"sha": "729ac17ae099131a7c91c55f15e29064e670f029", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -327,7 +327,7 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub parameters: Option<P<GenericArgs>>,\n+    pub args: Option<P<GenericArgs>>,\n \n     /// Whether to infer remaining type parameters, if any.\n     /// This only applies to expression and pattern paths, and\n@@ -342,30 +342,30 @@ impl PathSegment {\n         PathSegment {\n             name,\n             infer_types: true,\n-            parameters: None\n+            args: None,\n         }\n     }\n \n-    pub fn new(name: Name, parameters: GenericArgs, infer_types: bool) -> Self {\n+    pub fn new(name: Name, args: GenericArgs, infer_types: bool) -> Self {\n         PathSegment {\n             name,\n             infer_types,\n-            parameters: if parameters.is_empty() {\n+            args: if args.is_empty() {\n                 None\n             } else {\n-                Some(P(parameters))\n+                Some(P(args))\n             }\n         }\n     }\n \n     // FIXME: hack required because you can't create a static\n     // GenericArgs, so you can't just return a &GenericArgs.\n-    pub fn with_parameters<F, R>(&self, f: F) -> R\n+    pub fn with_args<F, R>(&self, f: F) -> R\n         where F: FnOnce(&GenericArgs) -> R\n     {\n         let dummy = GenericArgs::none();\n-        f(if let Some(ref params) = self.parameters {\n-            &params\n+        f(if let Some(ref args) = self.args {\n+            &args\n         } else {\n             &dummy\n         })\n@@ -380,12 +380,12 @@ pub enum GenericArg {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct GenericArgs {\n-    /// The generic parameters for this path segment.\n-    pub parameters: HirVec<GenericArg>,\n+    /// The generic arguments for this path segment.\n+    pub args: HirVec<GenericArg>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n-    /// Were parameters written in parenthesized form `Fn(T) -> U`?\n+    /// Were arguments written in parenthesized form `Fn(T) -> U`?\n     /// This is required mostly for pretty-printing and diagnostics,\n     /// but also for changing lifetime elision rules to be \"function-like\".\n     pub parenthesized: bool,\n@@ -394,14 +394,14 @@ pub struct GenericArgs {\n impl GenericArgs {\n     pub fn none() -> Self {\n         Self {\n-            parameters: HirVec::new(),\n+            args: HirVec::new(),\n             bindings: HirVec::new(),\n             parenthesized: false,\n         }\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        self.parameters.is_empty() && self.bindings.is_empty() && !self.parenthesized\n+        self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n     }\n \n     pub fn inputs(&self) -> &[P<Ty>] {\n@@ -416,7 +416,7 @@ impl GenericArgs {\n     }\n \n     pub fn lifetimes(&self) -> impl DoubleEndedIterator<Item = &Lifetime> {\n-        self.parameters.iter().filter_map(|p| {\n+        self.args.iter().filter_map(|p| {\n             if let GenericArg::Lifetime(lt) = p {\n                 Some(lt)\n             } else {\n@@ -426,7 +426,7 @@ impl GenericArgs {\n     }\n \n     pub fn types(&self) -> impl DoubleEndedIterator<Item = &P<Ty>> {\n-        self.parameters.iter().filter_map(|p| {\n+        self.args.iter().filter_map(|p| {\n             if let GenericArg::Type(ty) = p {\n                 Some(ty)\n             } else {"}, {"sha": "c12d258b6c7c99841c41871d2cc007b79509267d", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -1269,11 +1269,11 @@ impl<'a> State<'a> {\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n \n-        segment.with_parameters(|parameters| {\n-            if !parameters.parameters.is_empty() ||\n-                !parameters.bindings.is_empty()\n+        segment.with_args(|args| {\n+            if !args.args.is_empty() ||\n+                !args.bindings.is_empty()\n             {\n-                self.print_generic_args(&parameters, segment.infer_types, true)\n+                self.print_generic_args(&args, segment.infer_types, true)\n             } else {\n                 Ok(())\n             }\n@@ -1641,7 +1641,7 @@ impl<'a> State<'a> {\n             if segment.name != keywords::CrateRoot.name() &&\n                segment.name != keywords::DollarCrate.name() {\n                self.print_name(segment.name)?;\n-               segment.with_parameters(|parameters| {\n+               segment.with_args(|parameters| {\n                    self.print_generic_args(parameters,\n                                               segment.infer_types,\n                                               colons_before_params)\n@@ -1673,7 +1673,7 @@ impl<'a> State<'a> {\n                     if segment.name != keywords::CrateRoot.name() &&\n                        segment.name != keywords::DollarCrate.name() {\n                         self.print_name(segment.name)?;\n-                        segment.with_parameters(|parameters| {\n+                        segment.with_args(|parameters| {\n                             self.print_generic_args(parameters,\n                                                        segment.infer_types,\n                                                        colons_before_params)\n@@ -1685,7 +1685,7 @@ impl<'a> State<'a> {\n                 self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_name(item_segment.name)?;\n-                item_segment.with_parameters(|parameters| {\n+                item_segment.with_args(|parameters| {\n                     self.print_generic_args(parameters,\n                                                item_segment.infer_types,\n                                                colons_before_params)\n@@ -1697,7 +1697,7 @@ impl<'a> State<'a> {\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 self.print_name(item_segment.name)?;\n-                item_segment.with_parameters(|parameters| {\n+                item_segment.with_args(|parameters| {\n                     self.print_generic_args(parameters,\n                                                item_segment.infer_types,\n                                                colons_before_params)\n@@ -1734,7 +1734,7 @@ impl<'a> State<'a> {\n             let elide_lifetimes = generic_args.lifetimes().all(|lt| lt.is_elided());\n             if !elide_lifetimes {\n                 start_or_comma(self)?;\n-                self.commasep(Inconsistent, &generic_args.parameters, |s, p| {\n+                self.commasep(Inconsistent, &generic_args.args, |s, p| {\n                     match p {\n                         GenericArg::Lifetime(lt) => s.print_lifetime(lt),\n                         GenericArg::Type(ty) => s.print_type(ty),"}, {"sha": "871e399b4f2592d2f233a632e6d5eff098b907d0", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -177,7 +177,7 @@ impl_stable_hash_for!(struct hir::Path {\n impl_stable_hash_for!(struct hir::PathSegment {\n     name,\n     infer_types,\n-    parameters\n+    args\n });\n \n impl_stable_hash_for!(enum hir::GenericArg {\n@@ -186,7 +186,7 @@ impl_stable_hash_for!(enum hir::GenericArg {\n });\n \n impl_stable_hash_for!(struct hir::GenericArgs {\n-    parameters,\n+    args,\n     bindings,\n     parenthesized\n });"}, {"sha": "39dfa77ea677ee75f0b5289066fff1bb670410a2", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -28,7 +28,6 @@ use rustc_data_structures::sync::Lrc;\n use session::Session;\n use std::cell::Cell;\n use std::mem::replace;\n-use std::slice;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n@@ -155,11 +154,10 @@ impl Region {\n         }\n     }\n \n-    fn subst(self, params: Vec<&hir::Lifetime>, map: &NamedRegionMap) -> Option<Region> {\n+    fn subst<'a, L>(self, mut params: L, map: &NamedRegionMap) -> Option<Region>\n+            where L: Iterator<Item = &'a hir::Lifetime>  {\n         if let Region::EarlyBound(index, _, _) = self {\n-            params\n-                .get(index as usize)\n-                .and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n+            params.nth(index as usize).and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -603,7 +601,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // resolved the same as the `'_` in `&'_ Foo`.\n                         //\n                         // cc #48468\n-                        self.resolve_elided_lifetimes(slice::from_ref(lifetime), false)\n+                        self.resolve_elided_lifetimes(vec![lifetime], false)\n                     }\n                     LifetimeName::Fresh(_) | LifetimeName::Static | LifetimeName::Name(_) => {\n                         // If the user wrote an explicit name, use that.\n@@ -833,8 +831,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n-            if let Some(ref parameters) = segment.parameters {\n-                self.visit_segment_parameters(path.def, depth, parameters);\n+            if let Some(ref args) = segment.args {\n+                self.visit_segment_args(path.def, depth, args);\n             }\n         }\n     }\n@@ -1599,24 +1597,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_segment_parameters(\n+    fn visit_segment_args(\n         &mut self,\n         def: Def,\n         depth: usize,\n-        params: &'tcx hir::GenericArgs,\n+        args: &'tcx hir::GenericArgs,\n     ) {\n-        if params.parenthesized {\n+        if args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n-            self.visit_fn_like_elision(params.inputs(), Some(&params.bindings[0].ty));\n+            self.visit_fn_like_elision(args.inputs(), Some(&args.bindings[0].ty));\n             self.is_in_fn_syntax = was_in_fn_syntax;\n             return;\n         }\n \n-        if params.lifetimes().all(|l| l.is_elided()) {\n-            self.resolve_elided_lifetimes(params.lifetimes().collect(), true);\n+        if args.lifetimes().all(|l| l.is_elided()) {\n+            self.resolve_elided_lifetimes(args.lifetimes().collect(), true);\n         } else {\n-            for l in params.lifetimes() {\n+            for l in args.lifetimes() {\n                 self.visit_lifetime(l);\n             }\n         }\n@@ -1688,13 +1686,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     } else {\n                         Some(Region::Static)\n                     },\n-                    Set1::One(r) => r.subst(params.lifetimes().collect(), map),\n+                    Set1::One(r) => r.subst(args.lifetimes(), map),\n                     Set1::Many => None,\n                 })\n                 .collect()\n         });\n \n-        for (i, ty) in params.types().enumerate() {\n+        for (i, ty) in args.types().enumerate() {\n             if let Some(&lt) = object_lifetime_defaults.get(i) {\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: lt,\n@@ -1706,7 +1704,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        for b in &params.bindings {\n+        for b in &args.bindings {\n             self.visit_assoc_type_binding(b);\n         }\n     }"}, {"sha": "8b1c31deb1377d20431a5c762d5e41776b461c4c", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs, TyCtxt};\n+use ty::subst::Kind;\n use traits;\n use rustc_target::spec::abi::Abi;\n use util::ppaux;"}, {"sha": "4f5f0c9d740cc8c0429b43d1861af779f5a1ec5d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -885,73 +885,6 @@ pub struct GenericParamCount {\n     pub types: usize,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum GenericParam {\n-    Lifetime(RegionParameterDef),\n-    Type(TypeParameterDef),\n-}\n-\n-impl GenericParam {\n-    pub fn index(&self) -> u32 {\n-        match self {\n-            GenericParam::Lifetime(lt) => lt.index,\n-            GenericParam::Type(ty)     => ty.index,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum KindIndex {\n-    Lifetime,\n-    Type,\n-}\n-\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct KindIndexed<L, T> {\n-    pub lt: L,\n-    pub ty: T,\n-}\n-\n-impl<T> KindIndexed<T, T> {\n-    pub fn get(&self, idx: KindIndex) -> &T {\n-        match idx {\n-            KindIndex::Lifetime => &self.lt,\n-            KindIndex::Type     => &self.ty,\n-        }\n-    }\n-\n-    pub fn iter(&self) -> KindIndexIterator<T> {\n-        KindIndexIterator {\n-            index: self,\n-            next: Some(KindIndex::Lifetime),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct KindIndexIterator<'a, T: 'a> {\n-    pub index: &'a KindIndexed<T, T>,\n-    pub next: Option<KindIndex>,\n-}\n-\n-impl<'a, T> Iterator for KindIndexIterator<'a, T> {\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.next {\n-            Some(KindIndex::Lifetime) => {\n-                self.next = Some(KindIndex::Type);\n-                Some(&self.index.lt)\n-            }\n-            Some(KindIndex::Type) => {\n-                self.next = None;\n-                Some(&self.index.ty)\n-            },\n-            None => None,\n-        }\n-    }\n-}\n-\n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to hir::Generics.\n ///\n@@ -1009,34 +942,6 @@ impl<'a, 'gcx, 'tcx> Generics {\n         }\n     }\n \n-    pub fn lifetimes(&self) -> impl DoubleEndedIterator<Item = &RegionParameterDef> {\n-        self.parameters.iter().filter_map(|p| {\n-            if let GenericParam::Lifetime(lt) = p {\n-                Some(lt)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    pub fn types(&self) -> impl DoubleEndedIterator<Item = &TypeParameterDef> {\n-        self.parameters.iter().filter_map(|p| {\n-            if let GenericParam::Type(ty) = p {\n-                Some(ty)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    pub fn parent_lifetimes(&self) -> u32 {\n-        *self.parent_params.get(KindIndex::Lifetime)\n-    }\n-\n-    pub fn parent_types(&self) -> u32 {\n-        *self.parent_params.get(KindIndex::Type)\n-    }\n-\n     pub fn region_param(&'tcx self,\n                         param: &EarlyBoundRegion,\n                         tcx: TyCtxt<'a, 'gcx, 'tcx>)"}, {"sha": "7c8ba63c15eb9812d0e125cfdb1bd18aceb87bc8", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -40,6 +40,7 @@ use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Kind;\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::ty::query::Providers;\n use rustc::dep_graph::{DepNode, DepConstructor};"}, {"sha": "7468f01de705fd659875f16741f0262ddf609428", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -677,7 +677,7 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n                     ast::TyKind::Paren(ref subty) => involves_impl_trait(subty),\n                     ast::TyKind::Tup(ref tys) => any_involves_impl_trait(tys.iter()),\n                     ast::TyKind::Path(_, ref path) => path.segments.iter().any(|seg| {\n-                        match seg.parameters.as_ref().map(|p| &**p) {\n+                        match seg.args.as_ref().map(|p| &**p) {\n                             None => false,\n                             Some(&ast::GenericArgs::AngleBracketed(ref data)) =>\n                                 any_involves_impl_trait(data.types().into_iter()) ||"}, {"sha": "2c58bd8e79b08ac7d4de1c7d4fb3c71577de9d83", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             );\n             let label_msg = match pat.node {\n                 PatKind::Path(hir::QPath::Resolved(None, ref path))\n-                        if path.segments.len() == 1 && path.segments[0].parameters.is_none() => {\n+                        if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as a {} pattern, not new variable\", path.def.kind_name())\n                 }\n                 _ => format!(\"pattern `{}` not covered\", pattern_string),"}, {"sha": "3afe9991c68d076d545d002375b201b52d183d17", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -13,6 +13,7 @@ use rustc::middle::lang_items::DropInPlaceFnLangItem;\n use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Kind;\n \n pub use rustc::ty::Instance;\n pub use self::item::{MonoItem, MonoItemExt};"}, {"sha": "63c8bd3d1f77a2945a028340ff90cff318ac4275", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -230,9 +230,9 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         // }\n         // foo!(bar::baz<T>);\n         use_tree.prefix.segments.iter().find(|segment| {\n-            segment.parameters.is_some()\n+            segment.args.is_some()\n         }).map(|segment| {\n-            self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n+            self.err_handler().span_err(segment.args.as_ref().unwrap().span(),\n                                         \"generic arguments in import path\");\n         });\n \n@@ -398,8 +398,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_vis(&mut self, vis: &'a Visibility) {\n         match vis.node {\n             VisibilityKind::Restricted { ref path, .. } => {\n-                path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n-                    self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n+                path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n+                    self.err_handler().span_err(segment.args.as_ref().unwrap().span(),\n                                                 \"generic arguments in visibility path\");\n                 });\n             }\n@@ -521,10 +521,10 @@ impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n             visit::walk_ty(self, t);\n         }\n     }\n-    fn visit_path_parameters(&mut self, _: Span, path_parameters: &'a PathParameters) {\n-        match *path_parameters {\n-            PathParameters::AngleBracketed(ref params) => {\n-                for type_ in &params.types {\n+    fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n+        match *generic_args {\n+            GenericArgs::AngleBracketed(ref params) => {\n+                for type_ in params.types() {\n                     self.visit_ty(type_);\n                 }\n                 for type_binding in &params.bindings {\n@@ -533,7 +533,7 @@ impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n                     self.with_impl_trait(None, |this| visit::walk_ty(this, &type_binding.ty));\n                 }\n             }\n-            PathParameters::Parenthesized(ref params) => {\n+            GenericArgs::Parenthesized(ref params) => {\n                 for type_ in &params.inputs {\n                     self.visit_ty(type_);\n                 }\n@@ -590,7 +590,7 @@ impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n                 //\n                 // To implement this, we disallow `impl Trait` from `qself`\n                 // (for cases like `<impl Trait>::Foo>`)\n-                // but we allow `impl Trait` in `PathParameters`\n+                // but we allow `impl Trait` in `GenericArgs`\n                 // iff there are no more PathSegments.\n                 if let Some(ref qself) = *qself {\n                     // `impl Trait` in `qself` is always illegal"}, {"sha": "649e8858b0971b4b45a25690ed4fa74be2216ce3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -437,8 +437,8 @@ impl<'a> Resolver<'a> {\n         let def = self.resolve_macro_to_def_inner(scope, path, kind, force);\n         if def != Err(Determinacy::Undetermined) {\n             // Do not report duplicated errors on every undetermined resolution.\n-            path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n-                self.session.span_err(segment.parameters.as_ref().unwrap().span(),\n+            path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n+                self.session.span_err(segment.args.as_ref().unwrap().span(),\n                                       \"generic arguments in macro path\");\n             });\n         }"}, {"sha": "fa055d246f30ac903efd56ab4da5731bf2131ba9", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -818,10 +818,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n         self.dump_path_ref(id, path);\n \n-        // Type parameters\n+        // Type arguments\n         for seg in &path.segments {\n-            if let Some(ref params) = seg.parameters {\n-                match **params {\n+            if let Some(ref args) = seg.args {\n+                match **args {\n                     ast::GenericArgs::AngleBracketed(ref data) => for t in data.types() {\n                         self.visit_ty(t);\n                     },\n@@ -905,8 +905,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n \n         // Explicit types in the turbo-fish.\n-        if let Some(ref params) = seg.parameters {\n-            if let ast::GenericArgs::AngleBracketed(ref data) = **params {\n+        if let Some(ref args) = seg.args {\n+            if let ast::GenericArgs::AngleBracketed(ref data) = **args {\n                 for t in data.types() {\n                     self.visit_ty(t);\n                 }"}, {"sha": "4f03698d9b17c64cacac0ca4151f530ff56f17d7", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -692,8 +692,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             if path.segments.len() != 1 {\n                 return false;\n             }\n-            if let Some(ref params) = path.segments[0].parameters {\n-                if let ast::GenericArgs::Parenthesized(_) = **params {\n+            if let Some(ref args) = path.segments[0].args {\n+                if let ast::GenericArgs::Parenthesized(_) = **args {\n                     return true;\n                 }\n             }"}, {"sha": "be4c423e959bbc7c9aa4ddb032acbe72afe763fe", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -177,11 +177,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     {\n \n         let (substs, assoc_bindings) =\n-            item_segment.with_parameters(|parameters| {\n+            item_segment.with_args(|args| {\n                 self.create_substs_for_ast_path(\n                     span,\n                     def_id,\n-                    parameters,\n+                    args,\n                     item_segment.infer_types,\n                     None)\n             });\n@@ -199,23 +199,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn create_substs_for_ast_path(&self,\n         span: Span,\n         def_id: DefId,\n-        parameters: &hir::GenericArgs,\n+        args: &hir::GenericArgs,\n         infer_types: bool,\n         self_ty: Option<Ty<'tcx>>)\n         -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n         let tcx = self.tcx();\n \n         debug!(\"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n-               parameters={:?})\",\n-               def_id, self_ty, parameters);\n+               args={:?})\",\n+               def_id, self_ty, args);\n \n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n         let decl_generics = tcx.generics_of(def_id);\n-        let ty_provided = parameters.types().len();\n-        let lt_provided = parameters.lifetimes().len();\n+        let ty_provided = args.types().count();\n+        let lt_provided = args.lifetimes().count();\n \n         let mut lt_accepted = 0;\n         let mut ty_params = ParamRange { required: 0, accepted: 0 };\n@@ -269,7 +269,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n                     let i = param.index as usize - own_self;\n-                    if let Some(lifetime) = parameters.lifetimes().get(i) {\n+                    if let Some(lifetime) = args.lifetimes().nth(i) {\n                         self.ast_region_to_region(lifetime, Some(param)).into()\n                     } else {\n                         tcx.types.re_static.into()\n@@ -286,7 +286,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     let i = i - (lt_accepted + own_self);\n                     if i < ty_provided {\n                         // A provided type parameter.\n-                        self.ast_ty_to_ty(&parameters.types()[i]).into()\n+                        self.ast_ty_to_ty(&args.types().nth(i).unwrap()).into()\n                     } else if infer_types {\n                         // No type parameters were provided, we can infer all.\n                         if !default_needs_object_self(param) {\n@@ -330,7 +330,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         });\n \n-        let assoc_bindings = parameters.bindings.iter().map(|binding| {\n+        let assoc_bindings = args.bindings.iter().map(|binding| {\n             ConvertedBinding {\n                 item_name: binding.name,\n                 ty: self.ast_ty_to_ty(&binding.ty),\n@@ -451,7 +451,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n         if !self.tcx().features().unboxed_closures &&\n-           trait_segment.with_parameters(|p| p.parenthesized) != trait_def.paren_sugar {\n+           trait_segment.with_args(|p| p.parenthesized) != trait_def.paren_sugar {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let msg = if trait_def.paren_sugar {\n                 \"the precise format of `Fn`-family traits' type parameters is subject to change. \\\n@@ -463,7 +463,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                              span, GateIssue::Language, msg);\n         }\n \n-        trait_segment.with_parameters(|parameters| {\n+        trait_segment.with_args(|parameters| {\n             self.create_substs_for_ast_path(span,\n                                             trait_def_id,\n                                             parameters,\n@@ -970,8 +970,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n-            segment.with_parameters(|params| {\n-                for p in &params.parameters {\n+            segment.with_args(|params| {\n+                for p in &params.args {\n                     let (mut span_err, span, kind) = match p {\n                         hir::GenericArg::Lifetime(lt) => {\n                             (struct_span_err!(self.tcx().sess, lt.span, E0110,"}, {"sha": "bb5bdd4dc7791ae1243b17ba9f0a7d3cd941903e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             \"confirm(unadjusted_self_ty={:?}, pick={:?}, generic_args={:?})\",\n             unadjusted_self_ty,\n             pick,\n-            segment.parameters,\n+            segment.args,\n         );\n \n         let mut confirm_cx = ConfirmContext::new(self, span, self_expr, call_expr);\n@@ -321,7 +321,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n         assert_eq!(method_generics.parent_count, parent_substs.len());\n-        let provided = &segment.parameters;\n+        let provided = &segment.args;\n         let own_counts = method_generics.own_counts();\n         Substs::for_item(self.tcx, pick.item.def_id, |param, _| {\n             let i = param.index as usize;\n@@ -331,23 +331,22 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n                         if let Some(lifetime) = provided.as_ref().and_then(|p| {\n-                            p.lifetimes().get(i - parent_substs.len())\n+                            p.lifetimes().nth(i - parent_substs.len())\n                         }) {\n                             return AstConv::ast_region_to_region(\n                                 self.fcx, lifetime, Some(param)).into();\n                         }\n                     }\n                     GenericParamDefKind::Type {..} => {\n                         if let Some(ast_ty) = provided.as_ref().and_then(|p| {\n-                            p.types().get(i - parent_substs.len() - own_counts.lifetimes)\n+                            p.types().nth(i - parent_substs.len() - own_counts.lifetimes)\n                         }) {\n                             return self.to_ty(ast_ty).into();\n                         }\n                     }\n                 }\n                 self.var_for_def(self.span, param)\n             }\n-            self.type_var_for_def(self.span, def, cur_substs)\n         })\n     }\n "}, {"sha": "5af3d2fc42c9ec96e2a93c968ba61fa70f512381", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -4834,7 +4834,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n                     let lifetimes = segment.map_or(vec![], |(s, _)| {\n-                        s.parameters.as_ref().map_or(vec![], |p| p.lifetimes())\n+                        s.args.as_ref().map_or(vec![], |p| p.lifetimes().collect())\n                     });\n \n                     if let Some(lifetime) = lifetimes.get(i) {\n@@ -4845,7 +4845,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 GenericParamDefKind::Type {..} => {\n                     let (types, infer_types) = segment.map_or((vec![], true), |(s, _)| {\n-                        (s.parameters.as_ref().map_or(vec![], |p| |p| p.types()), s.infer_types)\n+                        (s.args.as_ref().map_or(vec![], |p| p.types().collect()), s.infer_types)\n                     });\n \n                     // Skip over the lifetimes in the same segment.\n@@ -4962,7 +4962,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   supress_mismatch_error: bool) {\n         let (lifetimes, types, infer_types, bindings) = segment.map_or(\n             (vec![], vec![], true, &[][..]),\n-            |(s, _)| s.parameters.as_ref().map_or(\n+            |(s, _)| s.args.as_ref().map_or(\n                 (vec![], vec![], s.infer_types, &[][..]),\n                 |p| (p.lifetimes().collect(), p.types().collect(),\n                      s.infer_types, &p.bindings[..])));"}, {"sha": "58e804fc13f2d8c9497f04672c4b528fa0fada04", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -973,13 +973,6 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       .map(|param| (param.def_id, param.index))\n                                       .collect();\n \n-    let parent_params = ty::KindIndexed { lt: parent_regions, ty: parent_types };\n-    let lifetimes: Vec<ty::GenericParam> =\n-        regions.into_iter().map(|lt| ty::GenericParam::Lifetime(lt)).collect();\n-    let types: Vec<ty::GenericParam> =\n-        types.into_iter().map(|ty| ty::GenericParam::Type(ty)).collect();\n-    let parameters = lifetimes.into_iter().chain(types.into_iter()).collect();\n-\n     tcx.alloc_generics(ty::Generics {\n         parent: parent_def_id,\n         parent_count,"}, {"sha": "4418c107223083845b48413fdfb4f32a4c5ba388", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -244,9 +244,8 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         None\n     }\n \n-    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::PathParameters {\n-        let mut lifetimes = vec![];\n-        let mut types = vec![];\n+    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n+        let mut args = vec![];\n \n         for param in generics.params.iter() {\n             match param.kind {\n@@ -257,21 +256,20 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         hir::LifetimeName::Name(param.name.as_symbol())\n                     };\n \n-                    lifetimes.push(hir::Lifetime {\n+                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n                         id: ast::DUMMY_NODE_ID,\n                         span: DUMMY_SP,\n                         name,\n-                    });\n+                    }));\n                 }\n                 ty::GenericParamDefKind::Type {..} => {\n-                    types.push(P(self.ty_param_to_ty(param.clone())));\n+                    args.push(hir::GenericArg::Type(P(self.ty_param_to_ty(param.clone()))));\n                 }\n             }\n         }\n \n-        hir::PathParameters {\n-            lifetimes: HirVec::from_vec(lifetimes),\n-            types: HirVec::from_vec(types),\n+        hir::GenericArgs {\n+            args: HirVec::from_vec(args),\n             bindings: HirVec::new(),\n             parenthesized: false,\n         }\n@@ -555,9 +553,9 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                             let mut new_path = path.clone();\n                             let last_segment = new_path.segments.pop().unwrap();\n \n-                            let (old_input, old_output) = match last_segment.params {\n-                                PathParameters::AngleBracketed { types, .. } => (types, None),\n-                                PathParameters::Parenthesized { inputs, output, .. } => {\n+                            let (old_input, old_output) = match last_segment.args {\n+                                GenericArgs::AngleBracketed { types, .. } => (types, None),\n+                                GenericArgs::Parenthesized { inputs, output, .. } => {\n                                     (inputs, output)\n                                 }\n                             };\n@@ -569,14 +567,14 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                 );\n                             }\n \n-                            let new_params = PathParameters::Parenthesized {\n+                            let new_params = GenericArgs::Parenthesized {\n                                 inputs: old_input,\n                                 output,\n                             };\n \n                             new_path.segments.push(PathSegment {\n                                 name: last_segment.name,\n-                                params: new_params,\n+                                args: new_params,\n                             });\n \n                             Type::ResolvedPath {\n@@ -793,13 +791,13 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n                                     // FIXME: Remove this scope when NLL lands\n                                     {\n-                                        let params =\n-                                            &mut new_trait_path.segments.last_mut().unwrap().params;\n+                                        let args =\n+                                            &mut new_trait_path.segments.last_mut().unwrap().args;\n \n-                                        match params {\n+                                        match args {\n                                             // Convert somethiung like '<T as Iterator::Item> = u8'\n                                             // to 'T: Iterator<Item=u8>'\n-                                            &mut PathParameters::AngleBracketed {\n+                                            &mut GenericArgs::AngleBracketed {\n                                                 ref mut bindings,\n                                                 ..\n                                             } => {\n@@ -808,7 +806,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                                     ty: rhs,\n                                                 });\n                                             }\n-                                            &mut PathParameters::Parenthesized { .. } => {\n+                                            &mut GenericArgs::Parenthesized { .. } => {\n                                                 existing_predicates.push(\n                                                     WherePredicate::EqPredicate {\n                                                         lhs: lhs.clone(),"}, {"sha": "793a8a7f110356aac61c1f34bcfb4d2cf7393bc0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -1607,7 +1607,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n         def: Def::Err,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            params: external_generic_args(cx, trait_did, has_self, bindings, substs)\n+            args: external_generic_args(cx, trait_did, has_self, bindings, substs)\n         }],\n     }\n }\n@@ -2656,7 +2656,7 @@ impl Type {\n         match *self {\n             ResolvedPath { ref path, .. } => {\n                 path.segments.last().and_then(|seg| {\n-                    if let GenericArgs::AngleBracketed { ref types, .. } = seg.params {\n+                    if let GenericArgs::AngleBracketed { ref types, .. } = seg.args {\n                         Some(&**types)\n                     } else {\n                         None\n@@ -2851,16 +2851,16 @@ impl Clean<Type> for hir::Ty {\n                     let provided_params = &path.segments.last().unwrap();\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n-                    provided_params.with_parameters(|provided_params| {\n+                    provided_params.with_args(|provided_params| {\n                         let mut indices = GenericParamCount {\n                             lifetimes: 0,\n                             types: 0\n                         };\n                         for param in generics.params.iter() {\n                             match param {\n                                 hir::GenericParam::Lifetime(lt_param) => {\n-                                    if let Some(lt) = provided_params.lifetimes\n-                                        .get(indices.lifetimes).cloned() {\n+                                    if let Some(lt) = provided_params.lifetimes()\n+                                        .nth(indices.lifetimes).cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id =\n                                                 cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n@@ -2872,8 +2872,8 @@ impl Clean<Type> for hir::Ty {\n                                 hir::GenericParam::Type(ty_param) => {\n                                     let ty_param_def =\n                                         Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n-                                    if let Some(ty) = provided_params.types\n-                                        .get(indices.types).cloned() {\n+                                    if let Some(ty) = provided_params.types()\n+                                        .nth(indices.types).cloned() {\n                                         ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n                                     } else if let Some(default) = ty_param.default.clone() {\n                                         ty_substs.insert(ty_param_def,\n@@ -3447,7 +3447,7 @@ impl Path {\n             def: Def::Err,\n             segments: vec![PathSegment {\n                 name,\n-                params: GenericArgs::AngleBracketed {\n+                args: GenericArgs::AngleBracketed {\n                     lifetimes: Vec::new(),\n                     types: Vec::new(),\n                     bindings: Vec::new(),\n@@ -3471,7 +3471,7 @@ impl Clean<Path> for hir::Path {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eg, Debug, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum GenericArgs {\n     AngleBracketed {\n         lifetimes: Vec<Lifetime>,\n@@ -3509,14 +3509,14 @@ impl Clean<GenericArgs> for hir::GenericArgs {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct PathSegment {\n     pub name: String,\n-    pub params: GenericArgs,\n+    pub args: GenericArgs,\n }\n \n impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n             name: self.name.clean(cx),\n-            params: self.with_parameters(|parameters| parameters.clean(cx))\n+            args: self.with_args(|args| args.clean(cx))\n         }\n     }\n }\n@@ -3550,7 +3550,7 @@ fn strip_path(path: &Path) -> Path {\n     let segments = path.segments.iter().map(|s| {\n         PathSegment {\n             name: s.name.clone(),\n-            params: PathParameters::AngleBracketed {\n+            args: GenericArgs::AngleBracketed {\n                 lifetimes: Vec::new(),\n                 types: Vec::new(),\n                 bindings: Vec::new(),\n@@ -4365,7 +4365,7 @@ where F: Fn(DefId) -> Def {\n         def: def_ctor(def_id),\n         segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n             name: ast::Name::intern(&s),\n-            parameters: None,\n+            args: None,\n             infer_types: false,\n         }).collect())\n     }"}, {"sha": "ac1952a4babbf3eb134622fb0546658c0f7e1ec8", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -97,7 +97,7 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n                 return false\n             }\n             let last = path.segments.last_mut().unwrap();\n-            match last.params {\n+            match last.args {\n                 PP::AngleBracketed { ref mut bindings, .. } => {\n                     bindings.push(clean::TypeBinding {\n                         name: name.clone(),"}, {"sha": "d2d068e520957efd9dd040988e32c726a12b7ce4", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -369,9 +369,9 @@ impl fmt::Display for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&self.name)?;\n         if f.alternate() {\n-            write!(f, \"{:#}\", self.params)\n+            write!(f, \"{:#}\", self.args)\n         } else {\n-            write!(f, \"{}\", self.params)\n+            write!(f, \"{}\", self.args)\n         }\n     }\n }\n@@ -447,7 +447,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n+        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.args)?;\n     } else {\n         let path = if use_absolute {\n             match href(did) {\n@@ -461,7 +461,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         } else {\n             format!(\"{}\", HRef::new(did, &last.name))\n         };\n-        write!(w, \"{}{}\", path, last.params)?;\n+        write!(w, \"{}{}\", path, last.args)?;\n     }\n     Ok(())\n }\n@@ -757,7 +757,7 @@ fn fmt_impl(i: &clean::Impl,\n                 clean::ResolvedPath { typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n-                    fmt::Display::fmt(&last.params, f)?;\n+                    fmt::Display::fmt(&last.args, f)?;\n                 }\n                 _ => unreachable!(),\n             }"}, {"sha": "7ff00123624f6e979c17c5dba571a69c4a98e657", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -135,27 +135,27 @@ pub struct PathSegment {\n     /// `Some` means that parameter list is supplied (`Path<X, Y>`)\n     /// but it can be empty (`Path<>`).\n     /// `P` is used as a size optimization for the common case with no parameters.\n-    pub parameters: Option<P<GenericArgs>>,\n+    pub args: Option<P<GenericArgs>>,\n }\n \n impl PathSegment {\n     pub fn from_ident(ident: Ident) -> Self {\n-        PathSegment { ident, parameters: None }\n+        PathSegment { ident, args: None }\n     }\n     pub fn crate_root(span: Span) -> Self {\n         PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span))\n     }\n }\n \n-/// Parameters of a path segment.\n+/// Arguments of a path segment.\n ///\n /// E.g. `<A, B>` as in `Foo<A, B>` or `(A, B)` as in `Foo(A, B)`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericArgs {\n     /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n-    AngleBracketed(AngleBracketedParameterData),\n+    AngleBracketed(AngleBracketedArgs),\n     /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n-    Parenthesized(ParenthesizedParameterData),\n+    Parenthesized(ParenthesizedArgData),\n }\n \n impl GenericArgs {\n@@ -168,28 +168,28 @@ impl GenericArgs {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum AngleBracketedParam {\n+pub enum GenericArg {\n     Lifetime(Lifetime),\n     Type(P<Ty>),\n }\n \n /// A path like `Foo<'a, T>`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n-pub struct AngleBracketedParameterData {\n+pub struct AngleBracketedArgs {\n     /// Overall span\n     pub span: Span,\n-    /// The parameters for this path segment.\n-    pub parameters: Vec<AngleBracketedParam>,\n+    /// The arguments for this path segment.\n+    pub args: Vec<GenericArg>,\n     /// Bindings (equality constraints) on associated types, if present.\n     ///\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: Vec<TypeBinding>,\n }\n \n-impl AngleBracketedParameterData {\n+impl AngleBracketedArgs {\n     pub fn lifetimes(&self) -> impl DoubleEndedIterator<Item = &Lifetime> {\n-        self.parameters.iter().filter_map(|p| {\n-            if let AngleBracketedParam::Lifetime(lt) = p {\n+        self.args.iter().filter_map(|p| {\n+            if let GenericArg::Lifetime(lt) = p {\n                 Some(lt)\n             } else {\n                 None\n@@ -198,8 +198,8 @@ impl AngleBracketedParameterData {\n     }\n \n     pub fn types(&self) -> impl DoubleEndedIterator<Item = &P<Ty>> {\n-        self.parameters.iter().filter_map(|p| {\n-            if let AngleBracketedParam::Type(ty) = p {\n+        self.args.iter().filter_map(|p| {\n+            if let GenericArg::Type(ty) = p {\n                 Some(ty)\n             } else {\n                 None\n@@ -208,21 +208,21 @@ impl AngleBracketedParameterData {\n     }\n }\n \n-impl Into<Option<P<GenericArgs>>> for AngleBracketedParameterData {\n+impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n     fn into(self) -> Option<P<GenericArgs>> {\n         Some(P(GenericArgs::AngleBracketed(self)))\n     }\n }\n \n-impl Into<Option<P<GenericArgs>>> for ParenthesizedParameterData {\n+impl Into<Option<P<GenericArgs>>> for ParenthesizedArgData {\n     fn into(self) -> Option<P<GenericArgs>> {\n         Some(P(GenericArgs::Parenthesized(self)))\n     }\n }\n \n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct ParenthesizedParameterData {\n+pub struct ParenthesizedArgData {\n     /// Overall span\n     pub span: Span,\n "}, {"sha": "05a345fb2a1759c119e46c8e8b4de0398b3b4ba4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -31,7 +31,7 @@ pub trait AstBuilder {\n     fn path_all(&self, sp: Span,\n                 global: bool,\n                 idents: Vec<ast::Ident>,\n-                parameters: Vec<ast::AngleBracketedParam>,\n+                parameters: Vec<ast::GenericArg>,\n                 bindings: Vec<ast::TypeBinding>)\n         -> ast::Path;\n \n@@ -42,7 +42,7 @@ pub trait AstBuilder {\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n                 trait_path: ast::Path,\n                 ident: ast::Ident,\n-                parameters: Vec<ast::AngleBracketedParam>,\n+                parameters: Vec<ast::GenericArg>,\n                 bindings: Vec<ast::TypeBinding>)\n                 -> (ast::QSelf, ast::Path);\n \n@@ -314,7 +314,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 span: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n-                parameters: Vec<ast::AngleBracketedParam>,\n+                args: Vec<ast::GenericArg>,\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n         let last_ident = idents.pop().unwrap();\n@@ -323,12 +323,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         segments.extend(idents.into_iter().map(|ident| {\n             ast::PathSegment::from_ident(ident.with_span_pos(span))\n         }));\n-        let parameters = if !parameters.is_empty() !bindings.is_empty() {\n-            ast::AngleBracketedParameterData { parameters, bindings, span }.into()\n+        let args = if !args.is_empty() || !bindings.is_empty() {\n+            ast::AngleBracketedArgs { args, bindings, span }.into()\n         } else {\n             None\n         };\n-        segments.push(ast::PathSegment { ident: last_ident.with_span_pos(span), parameters });\n+        segments.push(ast::PathSegment { ident: last_ident.with_span_pos(span), args });\n         let mut path = ast::Path { span, segments };\n         if global {\n             if let Some(seg) = path.make_root() {\n@@ -356,16 +356,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  self_type: P<ast::Ty>,\n                  trait_path: ast::Path,\n                  ident: ast::Ident,\n-                 parameters: Vec<ast::AngleBracketedParam>,\n+                 args: Vec<ast::GenericArg>,\n                  bindings: Vec<ast::TypeBinding>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n-        let parameters = if !parameters.is_empty() || !bindings.is_empty() {\n-            ast::AngleBracketedParameterData { parameters, bindings, span: ident.span }.into()\n+        let args = if !args.is_empty() || !bindings.is_empty() {\n+            ast::AngleBracketedArgs { args, bindings, span: ident.span }.into()\n         } else {\n             None\n         };\n-        path.segments.push(ast::PathSegment { ident, parameters });\n+        path.segments.push(ast::PathSegment { ident, args });\n \n         (ast::QSelf {\n             ty: self_type,\n@@ -424,7 +424,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             self.path_all(DUMMY_SP,\n                           true,\n                           self.std_path(&[\"option\", \"Option\"]),\n-                          vec![ ast::AngleBracketedParam::Type(ty) ],\n+                          vec![ ast::GenericArg::Type(ty) ],\n                           Vec::new()))\n     }\n "}, {"sha": "dc23ed19d1bee52fcbd95d16dbe94965d7c67603", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -132,11 +132,11 @@ pub trait Folder : Sized {\n         noop_fold_exprs(es, self)\n     }\n \n-    fn fold_param(&mut self, p: AngleBracketedParam) -> AngleBracketedParam {\n+    fn fold_param(&mut self, p: GenericArg) -> GenericArg {\n         match p {\n-            AngleBracketedParam::Lifetime(lt) =>\n-                AngleBracketedParam::Lifetime(self.fold_lifetime(lt)),\n-            AngleBracketedParam::Type(ty) => AngleBracketedParam::Type(self.fold_ty(ty)),\n+            GenericArg::Lifetime(lt) =>\n+                GenericArg::Lifetime(self.fold_lifetime(lt)),\n+            GenericArg::Type(ty) => GenericArg::Type(self.fold_ty(ty)),\n         }\n     }\n \n@@ -184,14 +184,14 @@ pub trait Folder : Sized {\n         noop_fold_generic_args(p, self)\n     }\n \n-    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedParameterData)\n-                                           -> AngleBracketedParameterData\n+    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedArgs)\n+                                           -> AngleBracketedArgs\n     {\n         noop_fold_angle_bracketed_parameter_data(p, self)\n     }\n \n-    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedParameterData)\n-                                         -> ParenthesizedParameterData\n+    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedArgData)\n+                                         -> ParenthesizedArgData\n     {\n         noop_fold_parenthesized_parameter_data(p, self)\n     }\n@@ -441,9 +441,9 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment {ident, parameters}| PathSegment {\n+        segments: segments.move_map(|PathSegment {ident, args}| PathSegment {\n             ident: fld.fold_ident(ident),\n-            parameters: parameters.map(|ps| ps.map(|ps| fld.fold_generic_args(ps))),\n+            args: args.map(|ps| ps.map(|ps| fld.fold_generic_args(ps))),\n         }),\n         span: fld.new_span(span)\n     }\n@@ -473,22 +473,22 @@ pub fn noop_fold_generic_args<T: Folder>(generic_args: GenericArgs, fld: &mut T)\n     }\n }\n \n-pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n+pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedArgs,\n                                                            fld: &mut T)\n-                                                           -> AngleBracketedParameterData\n+                                                           -> AngleBracketedArgs\n {\n-    let AngleBracketedParameterData { parameters, bindings, span } = data;\n-    AngleBracketedParameterData { parameters: parameters.move_map(|p| fld.fold_param(p)),\n+    let AngleBracketedArgs { args, bindings, span } = data;\n+    AngleBracketedArgs { args: args.move_map(|p| fld.fold_param(p)),\n                                   bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n                                   span: fld.new_span(span) }\n }\n \n-pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n+pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedArgData,\n                                                          fld: &mut T)\n-                                                         -> ParenthesizedParameterData\n+                                                         -> ParenthesizedArgData\n {\n-    let ParenthesizedParameterData { inputs, output, span } = data;\n-    ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n+    let ParenthesizedArgData { inputs, output, span } = data;\n+    ParenthesizedArgData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n                                  output: output.map(|ty| fld.fold_ty(ty)),\n                                  span: fld.new_span(span) }\n }\n@@ -1191,7 +1191,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::MethodCall(\n                     PathSegment {\n                         ident: folder.fold_ident(seg.ident),\n-                        parameters: seg.parameters.map(|ps| {\n+                        args: seg.args.map(|ps| {\n                             ps.map(|ps| folder.fold_generic_args(ps))\n                         }),\n                     },"}, {"sha": "a51b3bc0ae41cc879c933bf699128f94be48598f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc_target::spec::abi::{self, Abi};\n-use ast::{AngleBracketedParameterData, ParenthesizedParameterData, AttrStyle, BareFnTy};\n+use ast::{AngleBracketedArgs, ParenthesizedArgData, AttrStyle, BareFnTy};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Unsafety;\n use ast::{Mod, AnonConst, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n@@ -22,7 +22,7 @@ use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use ast::GenericParam;\n-use ast::AngleBracketedParam;\n+use ast::GenericArg;\n use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n use ast::{Label, Lifetime, LifetimeDef, Lit, LitKind};\n use ast::Local;\n@@ -1895,7 +1895,7 @@ impl<'a> Parser<'a> {\n                              -> PResult<'a, ast::Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod &&\n-               path.segments.iter().any(|segment| segment.parameters.is_some()) {\n+               path.segments.iter().any(|segment| segment.args.is_some()) {\n                 self.diagnostic().span_err(path.span, \"unexpected generic arguments in path\");\n             }\n             path\n@@ -1970,12 +1970,12 @@ impl<'a> Parser<'a> {\n                                  .span_label(self.prev_span, \"try removing `::`\").emit();\n             }\n \n-            let parameters = if self.eat_lt() {\n+            let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n-                let (parameters, bindings) = self.parse_generic_args()?;\n+                let (args, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n                 let span = lo.to(self.prev_span);\n-                AngleBracketedParameterData { parameters, bindings, span }.into()\n+                AngleBracketedArgs { args, bindings, span }.into()\n             } else {\n                 // `(T, U) -> R`\n                 self.bump(); // `(`\n@@ -1991,10 +1991,10 @@ impl<'a> Parser<'a> {\n                     None\n                 };\n                 let span = lo.to(self.prev_span);\n-                ParenthesizedParameterData { inputs, output, span }.into()\n+                ParenthesizedArgData { inputs, output, span }.into()\n             };\n \n-            PathSegment { ident, parameters }\n+            PathSegment { ident, args }\n         } else {\n             // Generic arguments are not found.\n             PathSegment::from_ident(ident)\n@@ -2544,8 +2544,8 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 // Field access `expr.f`\n-                if let Some(parameters) = segment.parameters {\n-                    self.span_err(parameters.span(),\n+                if let Some(args) = segment.args {\n+                    self.span_err(args.span(),\n                                   \"field expressions may not have generic arguments\");\n                 }\n \n@@ -4938,15 +4938,15 @@ impl<'a> Parser<'a> {\n     /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n     /// possibly including trailing comma.\n     fn parse_generic_args(&mut self)\n-                          -> PResult<'a, (Vec<AngleBracketedParam>, Vec<TypeBinding>)> {\n-        let mut parameters = Vec::new();\n+                          -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n+        let mut args = Vec::new();\n         let mut bindings = Vec::new();\n         let mut seen_type = false;\n         let mut seen_binding = false;\n         loop {\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 // Parse lifetime argument.\n-                parameters.push(AngleBracketedParam::Lifetime(self.expect_lifetime()));\n+                args.push(GenericArg::Lifetime(self.expect_lifetime()));\n                 if seen_type || seen_binding {\n                     self.span_err(self.prev_span,\n                         \"lifetime parameters must be declared prior to type parameters\");\n@@ -4971,7 +4971,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(ty_param.span,\n                         \"type parameters must be declared prior to associated type bindings\");\n                 }\n-                parameters.push(AngleBracketedParam::Type(ty_param));\n+                args.push(GenericArg::Type(ty_param));\n                 seen_type = true;\n             } else {\n                 break\n@@ -4981,7 +4981,7 @@ impl<'a> Parser<'a> {\n                 break\n             }\n         }\n-        Ok((parameters, bindings))\n+        Ok((args, bindings))\n     }\n \n     /// Parses an optional `where` clause and places it in `generics`."}, {"sha": "3b487430c52a54aae84ad9844d24d1808ff0d488", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -13,7 +13,7 @@ pub use self::AnnNode::*;\n use rustc_target::spec::abi::{self, Abi};\n use ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{Attribute, MacDelimiter, AngleBracketedParam};\n+use ast::{Attribute, MacDelimiter, GenericArg};\n use util::parser::{self, AssocOp, Fixity};\n use attr;\n use codemap::{self, CodeMap};\n@@ -1017,10 +1017,10 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_param(&mut self, param: &AngleBracketedParam) -> io::Result<()> {\n+    pub fn print_param(&mut self, param: &GenericArg) -> io::Result<()> {\n         match param {\n-            AngleBracketedParam::Lifetime(lt) => self.print_lifetime(lt),\n-            AngleBracketedParam::Type(ty) => self.print_type(ty),\n+            GenericArg::Lifetime(lt) => self.print_lifetime(lt),\n+            GenericArg::Type(ty) => self.print_type(ty),\n         }\n     }\n \n@@ -1991,8 +1991,8 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_ident(segment.ident)?;\n-        if let Some(ref parameters) = segment.parameters {\n-            self.print_generic_args(parameters, true)?;\n+        if let Some(ref args) = segment.args {\n+            self.print_generic_args(args, true)?;\n         }\n         self.print_call_post(base_args)\n     }\n@@ -2435,8 +2435,8 @@ impl<'a> State<'a> {\n         if segment.ident.name != keywords::CrateRoot.name() &&\n            segment.ident.name != keywords::DollarCrate.name() {\n             self.print_ident(segment.ident)?;\n-            if let Some(ref parameters) = segment.parameters {\n-                self.print_generic_args(parameters, colons_before_params)?;\n+            if let Some(ref args) = segment.args {\n+                self.print_generic_args(args, colons_before_params)?;\n             }\n         } else if segment.ident.name == keywords::DollarCrate.name() {\n             self.print_dollar_crate(segment.ident.span.ctxt())?;\n@@ -2462,28 +2462,28 @@ impl<'a> State<'a> {\n         self.s.word(\"::\")?;\n         let item_segment = path.segments.last().unwrap();\n         self.print_ident(item_segment.ident)?;\n-        match item_segment.parameters {\n-            Some(ref parameters) => self.print_generic_args(parameters, colons_before_params),\n+        match item_segment.args {\n+            Some(ref args) => self.print_generic_args(args, colons_before_params),\n             None => Ok(()),\n         }\n     }\n \n     fn print_generic_args(&mut self,\n-                             parameters: &ast::GenericArgs,\n+                             args: &ast::GenericArgs,\n                              colons_before_params: bool)\n                              -> io::Result<()>\n     {\n         if colons_before_params {\n             self.s.word(\"::\")?\n         }\n \n-        match *parameters {\n+        match *args {\n             ast::GenericArgs::AngleBracketed(ref data) => {\n                 self.s.word(\"<\")?;\n \n-                self.commasep(Inconsistent, &data.parameters, |s, p| s.print_param(p))?;\n+                self.commasep(Inconsistent, &data.args, |s, p| s.print_param(p))?;\n \n-                let mut comma = data.parameters.len() != 0;\n+                let mut comma = data.args.len() != 0;\n \n                 for binding in data.bindings.iter() {\n                     if comma {"}, {"sha": "906f1941cd6a740b567a77288e8a87d76e86330f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -131,10 +131,10 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_generic_args(&mut self, path_span: Span, generic_args: &'ast GenericArgs) {\n         walk_generic_args(self, path_span, generic_args)\n     }\n-    fn visit_angle_bracketed_param(&mut self, param: &'ast AngleBracketedParam) {\n+    fn visit_angle_bracketed_param(&mut self, param: &'ast GenericArg) {\n         match param {\n-            AngleBracketedParam::Lifetime(lt) => self.visit_lifetime(lt),\n-            AngleBracketedParam::Type(ty)     => self.visit_ty(ty),\n+            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n+            GenericArg::Type(ty)     => self.visit_ty(ty),\n         }\n     }\n     fn visit_assoc_type_binding(&mut self, type_binding: &'ast TypeBinding) {\n@@ -381,8 +381,8 @@ pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'a PathSegment) {\n     visitor.visit_ident(segment.ident);\n-    if let Some(ref parameters) = segment.parameters {\n-        visitor.visit_generic_args(path_span, parameters);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(path_span, args);\n     }\n }\n \n@@ -393,7 +393,7 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V,\n {\n     match *generic_args {\n         GenericArgs::AngleBracketed(ref data) => {\n-            walk_list!(visitor, visit_angle_bracketed_param, &data.parameters);\n+            walk_list!(visitor, visit_angle_bracketed_param, &data.args);\n             walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n         }\n         GenericArgs::Parenthesized(ref data) => {"}, {"sha": "504c3f8e91349a938837fa352572497a1931a9a7", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -13,7 +13,7 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n-use syntax::ast::AngleBracketedParam;\n+use syntax::ast::GenericArg;\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n@@ -124,7 +124,7 @@ fn cs_clone_shallow(name: &str,\n         let span = span.with_ctxt(cx.backtrace());\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"clone\", helper_name]),\n-                                        vec![AngleBracketedParam::Type(ty)], vec![]);\n+                                        vec![GenericArg::Type(ty)], vec![]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {"}, {"sha": "00ab39032acbd2489dbdc6273ca1812d1a8f9259", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -12,7 +12,7 @@ use deriving::path_std;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{self, Expr, MetaItem, AngleBracketedParam};\n+use syntax::ast::{self, Expr, MetaItem, GenericArg};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n@@ -62,7 +62,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         let span = span.with_ctxt(cx.backtrace());\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"cmp\", helper_name]),\n-                                        vec![AngleBracketedParam::Type(ty)], vec![]);\n+                                        vec![GenericArg::Type(ty)], vec![]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &ast::VariantData) {"}, {"sha": "299c53f31011431c9757cc8284948fef40322f6d", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -193,7 +193,7 @@ use std::vec;\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, BinOpKind, EnumDef, Expr, GenericParam, Generics, Ident, PatKind};\n-use syntax::ast::{VariantData, AngleBracketedParam};\n+use syntax::ast::{VariantData, GenericArg};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n@@ -683,9 +683,9 @@ impl<'a> TraitDef<'a> {\n             .collect();\n \n         let self_params = self_lifetimes.into_iter()\n-                                        .map(|lt| AngleBracketedParam::Lifetime(lt))\n+                                        .map(|lt| GenericArg::Lifetime(lt))\n                                         .chain(self_ty_params.into_iter().map(|ty|\n-                                            AngleBracketedParam::Type(ty)))\n+                                            GenericArg::Type(ty)))\n                                         .collect();\n \n         // Create the type of `self`."}, {"sha": "7e6dd5fad2583437d2010d35b5faa8a861010528", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -15,7 +15,7 @@ pub use self::PtrTy::*;\n pub use self::Ty::*;\n \n use syntax::ast;\n-use syntax::ast::{Expr, GenericParam, Generics, Ident, SelfKind, AngleBracketedParam};\n+use syntax::ast::{Expr, GenericParam, Generics, Ident, SelfKind, GenericArg};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{respan, DUMMY_SP};\n@@ -89,8 +89,8 @@ impl<'a> Path<'a> {\n         let tys: Vec<P<ast::Ty>> =\n             self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n         let params = lt.into_iter()\n-                       .map(|lt| AngleBracketedParam::Lifetime(lt))\n-                       .chain(tys.into_iter().map(|ty| AngleBracketedParam::Type(ty)))\n+                       .map(|lt| GenericArg::Lifetime(lt))\n+                       .chain(tys.into_iter().map(|ty| GenericArg::Type(ty)))\n                        .collect();\n \n         match self.kind {\n@@ -206,9 +206,9 @@ impl<'a> Ty<'a> {\n                     .collect();\n \n                 let params = lifetimes.into_iter()\n-                                      .map(|lt| AngleBracketedParam::Lifetime(lt))\n+                                      .map(|lt| GenericArg::Lifetime(lt))\n                                       .chain(ty_params.into_iter().map(|ty|\n-                                            AngleBracketedParam::Type(ty)))\n+                                            GenericArg::Type(ty)))\n                                       .collect();\n \n                 cx.path_all(span,"}, {"sha": "5c3080260ccd5de184e81af303ba08c7ee31ad1c", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c0d687453cb1da2e76a1c8e007ac080f8aa0d7/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=76c0d687453cb1da2e76a1c8e007ac080f8aa0d7", "patch": "@@ -13,7 +13,7 @@\n // interface.\n //\n \n-use syntax::ast::{self, Ident, AngleBracketedParam};\n+use syntax::ast::{self, Ident, GenericArg};\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n@@ -39,10 +39,10 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n                                      cx.std_path(&[\"option\", \"Option\", \"None\"]),\n-                                     vec![AngleBracketedParam::Type(cx.ty_rptr(sp,\n+                                     vec![GenericArg::Type(cx.ty_rptr(sp,\n                                                      cx.ty_ident(sp, Ident::from_str(\"str\")),\n                                                      Some(lt),\n-                                                     ast::Mutability::Immutable)],\n+                                                     ast::Mutability::Immutable))],\n                                      Vec::new()))\n         }\n         Ok(s) => {"}]}