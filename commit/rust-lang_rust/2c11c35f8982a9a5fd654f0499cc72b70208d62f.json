{"sha": "2c11c35f8982a9a5fd654f0499cc72b70208d62f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMTFjMzVmODk4MmE5YTVmZDY1NGYwNDk5Y2M3MmI3MDIwOGQ2MmY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-06-11T17:48:46Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-06-11T21:40:40Z"}, "message": "Explain move errors that occur due to method calls involving `self`", "tree": {"sha": "81be04481e09e4ad96d7894e27e2fda642c53dd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81be04481e09e4ad96d7894e27e2fda642c53dd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c11c35f8982a9a5fd654f0499cc72b70208d62f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl7ipNgACgkQtAh+UQ6Y\nsWTv2Q/7BjLKEFy/+nQM4XCNKy6pVCEaioL5C6bWSXs8yxrNPiY/LmrDzUD05SWc\n6iLjeT37tbh7gPOdFZp6S71Iy1Ie4cwOCgM4Aq/vxCbbS7/11KpZ8aJe7QP7jorF\nvlydxCf3XvGuIAcXrL0vI4Td5DxjRPGg9TQV8CYqlD9KwrddJ9LNH6hDiRtAj+pG\n4wPOYMz2FnAmG9AvpNl+cvSMn5vlcd97TsSb1vM7z6JABhBUyn+Q2uk8d/NQQfs+\nrXkMpDDGvi8/24P1FMTNBIA0Ge9B93OMoMvdCRLcq/YHDT557uYGyKP4xwcDr9ac\nTdnYvzwSTnbpgwTZW8DxO2TmuQN7VS+WsoJFQs1b0rgjlM/h38f2iUbLwVA+Ac9g\nosl3rTorb9QjrRuaQwXkGoxxMoATcUqJmLpP7OAt/szg5ZwXg2V/TodVYw7TBR/L\nnoARvKpMJD49ha3lo29ZKUnjxWKgrdsg2j9B3qatbpcDkqgx/iq7aI/A+5Marhk0\nXEst8iRFZXO56rpqMm2dNXgb71v9MrP3+/qB39eayk3XYyow8IAh29hyPr1NgCTA\nUcYfKV51aMH9i9Ba78Nkz5fEwBJG3V/65l/u48hSyus/ZKnqLnuZU8J1O65DTGhK\niJNDyUpLlBu7Ys3mEP/D4I8l2YAHz4V0kbKolYQ8S3TePsBisLQ=\n=h1M8\n-----END PGP SIGNATURE-----", "payload": "tree 81be04481e09e4ad96d7894e27e2fda642c53dd8\nparent 754da8849c18c45ff2fd2e77213f8371de488f80\nauthor Aaron Hill <aa1ronham@gmail.com> 1591897726 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1591911640 -0400\n\nExplain move errors that occur due to method calls involving `self`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c11c35f8982a9a5fd654f0499cc72b70208d62f", "html_url": "https://github.com/rust-lang/rust/commit/2c11c35f8982a9a5fd654f0499cc72b70208d62f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c11c35f8982a9a5fd654f0499cc72b70208d62f/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "754da8849c18c45ff2fd2e77213f8371de488f80", "url": "https://api.github.com/repos/rust-lang/rust/commits/754da8849c18c45ff2fd2e77213f8371de488f80", "html_url": "https://github.com/rust-lang/rust/commit/754da8849c18c45ff2fd2e77213f8371de488f80"}], "stats": {"total": 779, "additions": 697, "deletions": 82}, "files": [{"sha": "e59cacfffc9264b60f7e29ee54168771feb29d31", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n+use rustc_span::source_map::{respan, DesugaringKind, ForLoopLoc, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n@@ -25,6 +25,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n+        let mut span = e.span;\n         ensure_sufficient_stack(|| {\n             let kind = match e.kind {\n                 ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n@@ -53,6 +54,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args, span)\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+                    span = self.mark_span_with_reason(DesugaringKind::Operator, e.span, None);\n                     let binop = self.lower_binop(binop);\n                     let lhs = self.lower_expr(lhs);\n                     let rhs = self.lower_expr(rhs);\n@@ -222,7 +224,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::Expr {\n                 hir_id: self.lower_node_id(e.id),\n                 kind,\n-                span: e.span,\n+                span,\n                 attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n             }\n         })\n@@ -237,6 +239,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_binop(&mut self, b: BinOp) -> hir::BinOp {\n+        let span = self.mark_span_with_reason(DesugaringKind::Operator, b.span, None);\n         Spanned {\n             node: match b.node {\n                 BinOpKind::Add => hir::BinOpKind::Add,\n@@ -258,7 +261,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 BinOpKind::Ge => hir::BinOpKind::Ge,\n                 BinOpKind::Gt => hir::BinOpKind::Gt,\n             },\n-            span: b.span,\n+            span,\n         }\n     }\n \n@@ -1360,9 +1363,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::Expr<'hir> {\n+        let orig_head_span = head.span;\n         // expand <head>\n         let mut head = self.lower_expr_mut(head);\n-        let desugared_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n+        let desugared_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::Head),\n+            orig_head_span,\n+            None,\n+        );\n         head.span = desugared_span;\n \n         let iter = Ident::with_dummy_span(sym::iter);\n@@ -1457,10 +1465,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n \n+        let into_iter_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::IntoIter),\n+            orig_head_span,\n+            None,\n+        );\n+\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            self.expr_call_std_path(desugared_span, into_iter_path, arena_vec![self; head])\n+            self.expr_call_std_path(into_iter_span, into_iter_path, arena_vec![self; head])\n         };\n \n         let match_expr = self.arena.alloc(self.expr_match("}, {"sha": "1361d5bede63bcb0b863ee9be66e56f47c7c30d1", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -455,7 +455,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n                     None => format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    Some(DesugaringKind::ForLoop) => {\n+                    Some(DesugaringKind::ForLoop(_)) => {\n                         \"the element type for this iterator is not specified\".to_string()\n                     }\n                     _ => format!(\"this needs {}\", suffix),"}, {"sha": "923119e359c4749c00556006bfcabb991969c816", "filename": "src/librustc_middle/lint.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_middle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_middle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flint.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -339,7 +339,9 @@ pub fn struct_lint_level<'s, 'd>(\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n-        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n+        ExpnKind::Root\n+        | ExpnKind::Desugaring(DesugaringKind::ForLoop(_))\n+        | ExpnKind::Desugaring(DesugaringKind::Operator) => false,\n         ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             // Dummy span for the `def_site` means it's an external macro."}, {"sha": "9fdce13c4dca93bb92936a670577e3759f876201", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -24,7 +24,8 @@ use crate::borrow_check::{\n };\n \n use super::{\n-    explain_borrow::BorrowExplanation, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    explain_borrow::BorrowExplanation, FnSelfUseKind, IncludingDowncast, RegionName,\n+    RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -150,13 +151,70 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n                     );\n                 } else {\n-                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                    move_spans.var_span_label(\n-                        &mut err,\n-                        format!(\"variable moved due to use{}\", move_spans.describe()),\n-                    );\n+                    if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } =\n+                        move_spans\n+                    {\n+                        let place_name = self\n+                            .describe_place(moved_place.as_ref())\n+                            .map(|n| format!(\"`{}`\", n))\n+                            .unwrap_or_else(|| \"value\".to_owned());\n+                        match kind {\n+                            FnSelfUseKind::FnOnceCall => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to this call\", place_name),\n+                                );\n+                                err.span_note(\n+                                    var_span,\n+                                    \"this value implements `FnOnce`, which causes it to be moved when called\",\n+                                );\n+                            }\n+                            FnSelfUseKind::Operator { self_arg } => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to usage in operator\", place_name),\n+                                );\n+                                if self.fn_self_span_reported.insert(fn_span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        \"calling this operator moves the left-hand side\",\n+                                    );\n+                                }\n+                            }\n+                            FnSelfUseKind::Normal { self_arg, implicit_into_iter } => {\n+                                if implicit_into_iter {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\n+                                            \"{} moved due to this implicit call to `.into_iter()`\",\n+                                            place_name\n+                                        ),\n+                                    );\n+                                } else {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\"{} moved due to this method call\", place_name),\n+                                    );\n+                                }\n+                                // Avoid pointing to the same function in multiple different\n+                                // error messages\n+                                if self.fn_self_span_reported.insert(self_arg.span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        &format!(\"this function consumes the receiver `self` by taking ownership of it, which moves {}\", place_name)\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                        move_spans.var_span_label(\n+                            &mut err,\n+                            format!(\"variable moved due to use{}\", move_spans.describe()),\n+                        );\n+                    }\n                 }\n-                if Some(DesugaringKind::ForLoop) == move_span.desugaring_kind() {\n+                if let Some(DesugaringKind::ForLoop(_)) = move_span.desugaring_kind() {\n                     let sess = self.infcx.tcx.sess;\n                     if let Ok(snippet) = sess.source_map().span_to_snippet(move_span) {\n                         err.span_suggestion("}, {"sha": "d04059ff0fc7ffc405a82505b7fe26462b338102", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -509,7 +509,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Used in a closure.\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n-            UseSpans::OtherUse(span) => {\n+            UseSpans::OtherUse(span) | UseSpans::FnSelfUse { var_span: span, .. } => {\n                 let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {"}, {"sha": "2e49b2b58e85e4a938362d6eb7d388b3e0342867", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 132, "deletions": 20, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -11,7 +11,11 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n-use rustc_span::{symbol::sym, Span};\n+use rustc_span::{\n+    hygiene::{DesugaringKind, ForLoopLoc},\n+    symbol::sym,\n+    Span,\n+};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -33,6 +37,7 @@ crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n+use rustc_span::symbol::Ident;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -529,33 +534,58 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-// The span(s) associated to a use of a place.\n+/// The span(s) associated to a use of a place.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub(super) enum UseSpans {\n-    // The access is caused by capturing a variable for a closure.\n+    /// The access is caused by capturing a variable for a closure.\n     ClosureUse {\n-        // This is true if the captured variable was from a generator.\n+        /// This is true if the captured variable was from a generator.\n         generator_kind: Option<GeneratorKind>,\n-        // The span of the args of the closure, including the `move` keyword if\n-        // it's present.\n+        /// The span of the args of the closure, including the `move` keyword if\n+        /// it's present.\n         args_span: Span,\n-        // The span of the first use of the captured variable inside the closure.\n+        /// The span of the first use of the captured variable inside the closure.\n+        var_span: Span,\n+    },\n+    /// The access is caused by using a variable as the receiver of a method\n+    /// that takes 'self'\n+    FnSelfUse {\n+        /// The span of the variable being moved\n         var_span: Span,\n+        /// The span of the method call on the variable\n+        fn_call_span: Span,\n+        /// The definition span of the method being called\n+        fn_span: Span,\n+        kind: FnSelfUseKind,\n     },\n     // This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub(super) enum FnSelfUseKind {\n+    /// A normal method call of the form `receiver.foo(a, b, c)`\n+    Normal { self_arg: Ident, implicit_into_iter: bool },\n+    /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n+    FnOnceCall,\n+    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n+    Operator { self_arg: Ident },\n+}\n+\n impl UseSpans {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n-            UseSpans::ClosureUse { args_span: span, .. } | UseSpans::OtherUse(span) => span,\n+            UseSpans::ClosureUse { args_span: span, .. }\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n+            | UseSpans::OtherUse(span) => span,\n         }\n     }\n \n     pub(super) fn var_or_use(self) -> Span {\n         match self {\n-            UseSpans::ClosureUse { var_span: span, .. } | UseSpans::OtherUse(span) => span,\n+            UseSpans::ClosureUse { var_span: span, .. }\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n+            | UseSpans::OtherUse(span) => span,\n         }\n     }\n \n@@ -624,6 +654,7 @@ impl UseSpans {\n     {\n         match self {\n             closure @ UseSpans::ClosureUse { .. } => closure,\n+            fn_self @ UseSpans::FnSelfUse { .. } => fn_self,\n             UseSpans::OtherUse(_) => if_other(),\n         }\n     }\n@@ -727,21 +758,102 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n         if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            let def_id = match kind {\n+            match kind {\n                 box AggregateKind::Closure(def_id, _)\n-                | box AggregateKind::Generator(def_id, _, _) => def_id,\n-                _ => return OtherUse(stmt.source_info.span),\n-            };\n-\n-            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-            if let Some((args_span, generator_kind, var_span)) =\n-                self.closure_span(*def_id, moved_place, places)\n-            {\n-                return ClosureUse { generator_kind, args_span, var_span };\n+                | box AggregateKind::Generator(def_id, _, _) => {\n+                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+                    if let Some((args_span, generator_kind, var_span)) =\n+                        self.closure_span(*def_id, moved_place, places)\n+                    {\n+                        return ClosureUse { generator_kind, args_span, var_span };\n+                    }\n+                }\n+                _ => {}\n             }\n         }\n \n-        OtherUse(stmt.source_info.span)\n+        let normal_ret = OtherUse(stmt.source_info.span);\n+\n+        // We are trying to find MIR of the form:\n+        // ```\n+        // _temp = _moved_val;\n+        // ...\n+        // FnSelfCall(_temp, ...)\n+        // ```\n+        //\n+        // where `_moved_val` is the place we generated the move error for,\n+        // `_temp` is some other local, and `FnSelfCall` is a function\n+        // that has a `self` parameter.\n+\n+        let target_temp = match stmt.kind {\n+            StatementKind::Assign(box (temp, _)) if temp.as_local().is_some() => {\n+                temp.as_local().unwrap()\n+            }\n+            _ => return normal_ret,\n+        };\n+\n+        debug!(\"move_spans: target_temp = {:?}\", target_temp);\n+\n+        if let Some(Terminator {\n+            kind: TerminatorKind::Call { func, args, .. },\n+            source_info: term_source_info,\n+        }) = &self.body[location.block].terminator\n+        {\n+            let mut method_did = None;\n+            if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n+                if let ty::FnDef(def_id, _) = ty.kind {\n+                    debug!(\"move_spans: fn = {:?}\", def_id);\n+                    if let Some(ty::AssocItem { fn_has_self_parameter, .. }) =\n+                        self.infcx.tcx.opt_associated_item(def_id)\n+                    {\n+                        if *fn_has_self_parameter {\n+                            method_did = Some(def_id);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            let tcx = self.infcx.tcx;\n+            let method_did = if let Some(did) = method_did { did } else { return normal_ret };\n+\n+            if let [Operand::Move(self_place), ..] = **args {\n+                if self_place.as_local() == Some(target_temp) {\n+                    let is_fn_once = tcx.parent(method_did) == tcx.lang_items().fn_once_trait();\n+                    let fn_call_span = term_source_info.span;\n+\n+                    let self_arg = tcx.fn_arg_names(method_did)[0];\n+\n+                    let kind = if is_fn_once {\n+                        FnSelfUseKind::FnOnceCall\n+                    } else if fn_call_span.is_desugaring(DesugaringKind::Operator) {\n+                        FnSelfUseKind::Operator { self_arg }\n+                    } else {\n+                        debug!(\n+                            \"move_spans: method_did={:?}, fn_call_span={:?}\",\n+                            method_did, fn_call_span\n+                        );\n+                        let implicit_into_iter = matches!(\n+                            fn_call_span.desugaring_kind(),\n+                            Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n+                        );\n+                        FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n+                    };\n+\n+                    return FnSelfUse {\n+                        var_span: stmt.source_info.span,\n+                        fn_call_span,\n+                        fn_span: self\n+                            .infcx\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .guess_head_span(self.infcx.tcx.def_span(method_did)),\n+                        kind,\n+                    };\n+                }\n+            }\n+        }\n+        return normal_ret;\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)"}, {"sha": "4883b08e424423a71265093c884a7d3e069d3476", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     format!(\"{}.as_ref()\", snippet),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if span.is_desugaring(DesugaringKind::ForLoop)\n+            } else if matches!(span.desugaring_kind(), Some(DesugaringKind::ForLoop(_)))\n                 && self.infcx.tcx.is_diagnostic_item(Symbol::intern(\"vec_type\"), def_id)\n             {\n                 // FIXME: suggest for anything that implements `IntoIterator`."}, {"sha": "b4bc89e827daa7010b7608ab5b68ee73abb8a98b", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n                                 match opt_desugaring_kind {\n                                     // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => Some((\n+                                    Some(DesugaringKind::ForLoop(_)) => Some((\n                                         false,\n                                         opt_assignment_rhs_span.unwrap(),\n                                         format!("}, {"sha": "6729822e55fed75968f631c2d2233c84bc6523f4", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -277,6 +277,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n+                fn_self_span_reported: Default::default(),\n                 locals_are_invalidated_at_exit,\n                 access_place_error_reported: Default::default(),\n                 reservation_error_reported: Default::default(),\n@@ -310,6 +311,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         location_table,\n         movable_generator,\n         locals_are_invalidated_at_exit,\n+        fn_self_span_reported: Default::default(),\n         access_place_error_reported: Default::default(),\n         reservation_error_reported: Default::default(),\n         reservation_warnings: Default::default(),\n@@ -486,6 +488,10 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     // but it is currently inconvenient to track down the `BorrowIndex`\n     // at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    /// This fields keeps track of the `Span`s that we have\n+    /// used to report extra information for `FnSelfUse`, to avoid\n+    /// unnecessarily verbose errors.\n+    fn_self_span_reported: FxHashSet<Span>,\n     /// Migration warnings to be reported for #56254. We delay reporting these\n     /// so that we can suppress the warning if there's a corresponding error\n     /// for the activation of the borrow."}, {"sha": "72db35de408c67cb84d81731e726bde9ad9c9895", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -511,6 +511,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // This is basically `force_bits`.\n             let r_bits = r_bits.and_then(|r| r.to_bits_or_ptr(right_size, &self.tcx).ok());\n             if r_bits.map_or(false, |b| b >= left_size_bits as u128) {\n+                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n                     source_info,"}, {"sha": "f2c9f8055b9756d05a4435a9d61311a6ab0e3e3d", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -822,7 +822,15 @@ pub enum DesugaringKind {\n     OpaqueTy,\n     Async,\n     Await,\n-    ForLoop,\n+    ForLoop(ForLoopLoc),\n+    Operator,\n+}\n+\n+/// A location in the desugaring of a `for` loop\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+pub enum ForLoopLoc {\n+    Head,\n+    IntoIter,\n }\n \n impl DesugaringKind {\n@@ -835,7 +843,8 @@ impl DesugaringKind {\n             DesugaringKind::QuestionMark => \"operator `?`\",\n             DesugaringKind::TryBlock => \"`try` block\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n-            DesugaringKind::ForLoop => \"`for` loop\",\n+            DesugaringKind::ForLoop(_) => \"`for` loop\",\n+            DesugaringKind::Operator => \"operator\",\n         }\n     }\n }"}, {"sha": "3cb51beaf693042aa9be5b0c84b84ec0f17d30ca", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -31,7 +31,9 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n use hygiene::Transparency;\n-pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, MacroKind, SyntaxContext};\n+pub use hygiene::{\n+    DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind, SyntaxContext,\n+};\n pub mod def_id;\n use def_id::{CrateNum, DefId, LOCAL_CRATE};\n mod span_encoding;"}, {"sha": "addc8a0efe1aa51c0cc1b9521507b2571a2a25ee", "filename": "src/test/ui/binop/binop-consume-args.stderr", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -4,10 +4,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs + rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn add<A: Add<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -35,10 +40,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs - rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn sub(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn sub<A: Sub<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -66,10 +76,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs * rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn mul(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn mul<A: Mul<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -97,10 +112,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs / rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn div(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn div<A: Div<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -128,10 +148,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs % rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn rem(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn rem<A: Rem<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -159,10 +184,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs & rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitand(self, rhs: Rhs) -> Self::Output;\n+   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitand<A: BitAnd<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -190,10 +220,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                     --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs | rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitor(self, rhs: Rhs) -> Self::Output;\n+   |              ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitor<A: BitOr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -221,10 +256,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs ^ rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitxor(self, rhs: Rhs) -> Self::Output;\n+   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitxor<A: BitXor<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -252,10 +292,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs << rhs;\n-   |     --- value moved here\n+   |     ---------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn shl(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shl<A: Shl<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -283,10 +328,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs >> rhs;\n-   |     --- value moved here\n+   |     ---------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn shr(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shr<A: Shr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {"}, {"sha": "97b70efe20e79d25d468c52c36e2f011b92e92cc", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -1,14 +1,21 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/binop-move-semantics.rs:8:5\n    |\n-LL | fn double_move<T: Add<Output=()>>(x: T) {\n-   |                                   - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n-LL |     x\n-   |     - value moved here\n-LL |     +\n-LL |     x;\n-   |     ^ value used here after move\n+LL |   fn double_move<T: Add<Output=()>>(x: T) {\n+   |                                     - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+LL | /     x\n+LL | |     +\n+LL | |     x;\n+   | |     ^\n+   | |     |\n+   | |_____value used here after move\n+   |       `x` moved due to usage in operator\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n    |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn double_move<T: Add<Output=()> + Copy>(x: T) {"}, {"sha": "bc1721944fbbb6de8b7b1da9112928d3782de7fe", "filename": "src/test/ui/borrowck/borrowck-unboxed-closures.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -22,10 +22,15 @@ error[E0382]: use of moved value: `f`\n LL | fn c<F:FnOnce(isize, isize) -> isize>(f: F) {\n    |                                       - move occurs because `f` has type `F`, which does not implement the `Copy` trait\n LL |     f(1, 2);\n-   |     - value moved here\n+   |     ------- `f` moved due to this call\n LL |     f(1, 2);\n    |     ^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/borrowck-unboxed-closures.rs:11:5\n+   |\n+LL |     f(1, 2);\n+   |     ^\n help: consider further restricting this bound\n    |\n LL | fn c<F:FnOnce(isize, isize) -> isize + Copy>(f: F) {"}, {"sha": "896bb6dc6bee8a8cfca5c73ef4d84479b85f5bc6", "filename": "src/test/ui/closure_context/issue-42065.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `debug_dump_dict`\n   --> $DIR/issue-42065.rs:11:5\n    |\n LL |     debug_dump_dict();\n-   |     --------------- value moved here\n+   |     ----------------- `debug_dump_dict` moved due to this call\n LL |     debug_dump_dict();\n    |     ^^^^^^^^^^^^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `di\n    |\n LL |         for (key, value) in dict {\n    |                             ^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/issue-42065.rs:10:5\n+   |\n+LL |     debug_dump_dict();\n+   |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b8abee670ef03ff55d1e0624ce2b3ada75e243be", "filename": "src/test/ui/codemap_tests/tab_3.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -4,10 +4,16 @@ error[E0382]: borrow of moved value: `some_vec`\n LL |     let some_vec = vec![\"hi\"];\n    |         -------- move occurs because `some_vec` has type `std::vec::Vec<&str>`, which does not implement the `Copy` trait\n LL |     some_vec.into_iter();\n-   |     -------- value moved here\n+   |     -------------------- `some_vec` moved due to this method call\n LL |     {\n LL |         println!(\"{:?}\", some_vec);\n    |                          ^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `some_vec`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "064dc6c262c88462e64b6ce6ecfb36b5ff4a5e7e", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -6,14 +6,15 @@\n \n static CMP: () = {\n     let x = &0 as *const _;\n-    let _v = x == x;\n+    let _v = x == x; //~ NOTE in this\n     //~^ ERROR could not evaluate static initializer\n     //~| NOTE pointer arithmetic or comparison\n+    //~| NOTE in this\n };\n \n static INT_PTR_ARITH: () = unsafe {\n     let x: usize = std::mem::transmute(&0);\n-    let _v = x + 0;\n+    let _v = x + 0; //~ NOTE in this\n     //~^ ERROR could not evaluate static initializer\n     //~| NOTE pointer-to-integer cast\n };"}, {"sha": "4b3fe9957002e8f359116f6029328841ef67ae79", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -5,7 +5,7 @@ LL |     let _v = x == x;\n    |              ^^^^^^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:16:14\n+  --> $DIR/ptr_arith.rs:17:14\n    |\n LL |     let _v = x + 0;\n    |              ^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n@@ -18,7 +18,7 @@ help: skipping check for `const_compare_raw_pointers` feature\n LL |     let _v = x == x;\n    |              ^^^^^^\n help: skipping check that does not even have a feature gate\n-  --> $DIR/ptr_arith.rs:15:20\n+  --> $DIR/ptr_arith.rs:16:20\n    |\n LL |     let x: usize = std::mem::transmute(&0);\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "fc5ed724e3c67ff03139865769833af7cbfd68f6", "filename": "src/test/ui/hygiene/unpretty-debug.stdout", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -18,8 +18,12 @@ fn y /* 0#0 */() { }\n Expansions:\n 0: parent: ExpnId(0), call_site_ctxt: #0, kind: Root\n 1: parent: ExpnId(0), call_site_ctxt: #0, kind: Macro(Bang, \"foo\")\n+2: parent: ExpnId(0), call_site_ctxt: #1, kind: Desugaring(Operator)\n+3: parent: ExpnId(0), call_site_ctxt: #1, kind: Desugaring(Operator)\n \n SyntaxContexts:\n #0: parent: #0, outer_mark: (ExpnId(0), Opaque)\n #1: parent: #0, outer_mark: (ExpnId(1), SemiTransparent)\n+#2: parent: #1, outer_mark: (ExpnId(2), Transparent)\n+#3: parent: #1, outer_mark: (ExpnId(3), Transparent)\n */"}, {"sha": "b759aa45e3eb707d2a8074447cb22038cf2980bf", "filename": "src/test/ui/issues/issue-12127.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -2,10 +2,15 @@ error[E0382]: use of moved value: `f`\n   --> $DIR/issue-12127.rs:11:9\n    |\n LL |         f();\n-   |         - value moved here\n+   |         --- `f` moved due to this call\n LL |         f();\n    |         ^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/issue-12127.rs:10:9\n+   |\n+LL |         f();\n+   |         ^\n    = note: move occurs because `f` has type `[closure@$DIR/issue-12127.rs:8:24: 8:41 x:std::boxed::Box<isize>]`, which does not implement the `Copy` trait\n \n error: aborting due to previous error"}, {"sha": "4fb805b37e03f02330f2bc77637b0a231b539b80", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -3,4 +3,5 @@ use std::collections::HashMap;\n fn main() {\n     for _ in HashMap::new().iter().cloned() {} //~ ERROR type mismatch\n     //~^ ERROR type mismatch\n+    //~| ERROR type mismatch\n }"}, {"sha": "20335d2cdd684c6b6d681ce29790b4106a22c2fc", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -17,6 +17,16 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n            found reference `&_`\n    = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n \n-error: aborting due to 2 previous errors\n+error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as std::iter::Iterator>::Item == &_`\n+  --> $DIR/issue-33941.rs:4:14\n+   |\n+LL |     for _ in HashMap::new().iter().cloned() {}\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found reference\n+   |\n+   = note:  expected tuple `(&_, &_)`\n+           found reference `&_`\n+   = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "2ce0786e831556dabbd7ef301cbbc7353034c35f", "filename": "src/test/ui/issues/issue-34721.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -5,14 +5,19 @@ LL |     pub fn baz<T: Foo>(x: T) -> T {\n    |                        - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n LL |         if 0 == 1 {\n LL |             bar::bar(x.zero())\n-   |                      - value moved here\n+   |                      -------- `x` moved due to this method call\n LL |         } else {\n LL |             x.zero()\n-   |             - value moved here\n+   |             -------- `x` moved due to this method call\n LL |         };\n LL |         x.zero()\n    |         ^ value used here after move\n    |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $DIR/issue-34721.rs:4:13\n+   |\n+LL |     fn zero(self) -> Self;\n+   |             ^^^^\n help: consider further restricting this bound\n    |\n LL |     pub fn baz<T: Foo + Copy>(x: T) -> T {"}, {"sha": "ba43f2d33ee4463058c536652a9dab4aed06fa2e", "filename": "src/test/ui/issues/issue-61108.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -6,11 +6,17 @@ LL |     let mut bad_letters = vec!['e', 't', 'o', 'i'];\n LL |     for l in bad_letters {\n    |              -----------\n    |              |\n-   |              value moved here\n+   |              `bad_letters` moved due to this implicit call to `.into_iter()`\n    |              help: consider borrowing to avoid moving into the for loop: `&bad_letters`\n ...\n LL |     bad_letters.push('s');\n    |     ^^^^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `bad_letters`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2c337bae130171454088824186eee57106c70202", "filename": "src/test/ui/issues/issue-64559.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -6,12 +6,18 @@ LL |     let orig = vec![true];\n LL |     for _val in orig {}\n    |                 ----\n    |                 |\n-   |                 value moved here\n+   |                 `orig` moved due to this implicit call to `.into_iter()`\n    |                 help: consider borrowing to avoid moving into the for loop: `&orig`\n LL |     let _closure = || orig;\n    |                    ^^ ---- use occurs due to use in closure\n    |                    |\n    |                    value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `orig`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6107f53fa19606b20fcfa967a3401fb4cf2310f1", "filename": "src/test/ui/moves/move-fn-self-receiver.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -0,0 +1,74 @@\n+use std::pin::Pin;\n+use std::rc::Rc;\n+use std::ops::Add;\n+\n+struct Foo;\n+\n+impl Add for Foo {\n+    type Output = ();\n+    fn add(self, _rhs: Self) -> () {}\n+}\n+\n+impl Foo {\n+    fn use_self(self) {}\n+    fn use_box_self(self: Box<Self>) {}\n+    fn use_pin_box_self(self: Pin<Box<Self>>) {}\n+    fn use_rc_self(self: Rc<Self>) {}\n+    fn use_mut_self(&mut self) -> &mut Self { self }\n+}\n+\n+struct Container(Vec<bool>);\n+\n+impl Container {\n+    fn custom_into_iter(self) -> impl Iterator<Item = bool> {\n+        self.0.into_iter()\n+    }\n+}\n+\n+fn move_out(val: Container) {\n+    val.0.into_iter().next();\n+    val.0; //~ ERROR use of moved\n+\n+    let foo = Foo;\n+    foo.use_self();\n+    foo; //~ ERROR use of moved\n+\n+    let second_foo = Foo;\n+    second_foo.use_self();\n+    second_foo; //~ ERROR use of moved\n+\n+    let boxed_foo = Box::new(Foo);\n+    boxed_foo.use_box_self();\n+    boxed_foo; //~ ERROR use of moved\n+\n+    let pin_box_foo = Box::pin(Foo);\n+    pin_box_foo.use_pin_box_self();\n+    pin_box_foo; //~ ERROR use of moved\n+\n+    let mut mut_foo = Foo;\n+    let ret = mut_foo.use_mut_self();\n+    mut_foo; //~ ERROR cannot move out\n+    ret;\n+\n+    let rc_foo = Rc::new(Foo);\n+    rc_foo.use_rc_self();\n+    rc_foo; //~ ERROR use of moved\n+\n+    let foo_add = Foo;\n+    foo_add + Foo;\n+    foo_add; //~ ERROR use of moved\n+\n+    let implicit_into_iter = vec![true];\n+    for _val in implicit_into_iter {}\n+    implicit_into_iter; //~ ERROR use of moved\n+\n+    let explicit_into_iter = vec![true];\n+    for _val in explicit_into_iter.into_iter() {}\n+    explicit_into_iter; //~ ERROR use of moved\n+\n+    let container = Container(vec![]);\n+    for _val in container.custom_into_iter() {}\n+    container; //~ ERROR use of moved\n+}\n+\n+fn main() {}"}, {"sha": "def4f3244833f06c113cbdd2750a5f1273b433b4", "filename": "src/test/ui/moves/move-fn-self-receiver.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -0,0 +1,158 @@\n+error[E0382]: use of moved value: `val.0`\n+  --> $DIR/move-fn-self-receiver.rs:30:5\n+   |\n+LL |     val.0.into_iter().next();\n+   |     ----------------- `val.0` moved due to this method call\n+LL |     val.0;\n+   |     ^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `val.0`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n+   = note: move occurs because `val.0` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `foo`\n+  --> $DIR/move-fn-self-receiver.rs:34:5\n+   |\n+LL |     let foo = Foo;\n+   |         --- move occurs because `foo` has type `Foo`, which does not implement the `Copy` trait\n+LL |     foo.use_self();\n+   |     -------------- `foo` moved due to this method call\n+LL |     foo;\n+   |     ^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `foo`\n+  --> $DIR/move-fn-self-receiver.rs:13:17\n+   |\n+LL |     fn use_self(self) {}\n+   |                 ^^^^\n+\n+error[E0382]: use of moved value: `second_foo`\n+  --> $DIR/move-fn-self-receiver.rs:38:5\n+   |\n+LL |     let second_foo = Foo;\n+   |         ---------- move occurs because `second_foo` has type `Foo`, which does not implement the `Copy` trait\n+LL |     second_foo.use_self();\n+   |     --------------------- `second_foo` moved due to this method call\n+LL |     second_foo;\n+   |     ^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `boxed_foo`\n+  --> $DIR/move-fn-self-receiver.rs:42:5\n+   |\n+LL |     let boxed_foo = Box::new(Foo);\n+   |         --------- move occurs because `boxed_foo` has type `std::boxed::Box<Foo>`, which does not implement the `Copy` trait\n+LL |     boxed_foo.use_box_self();\n+   |     ------------------------ `boxed_foo` moved due to this method call\n+LL |     boxed_foo;\n+   |     ^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `boxed_foo`\n+  --> $DIR/move-fn-self-receiver.rs:14:21\n+   |\n+LL |     fn use_box_self(self: Box<Self>) {}\n+   |                     ^^^^\n+\n+error[E0382]: use of moved value: `pin_box_foo`\n+  --> $DIR/move-fn-self-receiver.rs:46:5\n+   |\n+LL |     let pin_box_foo = Box::pin(Foo);\n+   |         ----------- move occurs because `pin_box_foo` has type `std::pin::Pin<std::boxed::Box<Foo>>`, which does not implement the `Copy` trait\n+LL |     pin_box_foo.use_pin_box_self();\n+   |     ------------------------------ `pin_box_foo` moved due to this method call\n+LL |     pin_box_foo;\n+   |     ^^^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `pin_box_foo`\n+  --> $DIR/move-fn-self-receiver.rs:15:25\n+   |\n+LL |     fn use_pin_box_self(self: Pin<Box<Self>>) {}\n+   |                         ^^^^\n+\n+error[E0505]: cannot move out of `mut_foo` because it is borrowed\n+  --> $DIR/move-fn-self-receiver.rs:50:5\n+   |\n+LL |     let ret = mut_foo.use_mut_self();\n+   |               ------- borrow of `mut_foo` occurs here\n+LL |     mut_foo;\n+   |     ^^^^^^^ move out of `mut_foo` occurs here\n+LL |     ret;\n+   |     --- borrow later used here\n+\n+error[E0382]: use of moved value: `rc_foo`\n+  --> $DIR/move-fn-self-receiver.rs:55:5\n+   |\n+LL |     let rc_foo = Rc::new(Foo);\n+   |         ------ move occurs because `rc_foo` has type `std::rc::Rc<Foo>`, which does not implement the `Copy` trait\n+LL |     rc_foo.use_rc_self();\n+   |     -------------------- `rc_foo` moved due to this method call\n+LL |     rc_foo;\n+   |     ^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `rc_foo`\n+  --> $DIR/move-fn-self-receiver.rs:16:20\n+   |\n+LL |     fn use_rc_self(self: Rc<Self>) {}\n+   |                    ^^^^\n+\n+error[E0382]: use of moved value: `foo_add`\n+  --> $DIR/move-fn-self-receiver.rs:59:5\n+   |\n+LL |     let foo_add = Foo;\n+   |         ------- move occurs because `foo_add` has type `Foo`, which does not implement the `Copy` trait\n+LL |     foo_add + Foo;\n+   |     ------------- `foo_add` moved due to usage in operator\n+LL |     foo_add;\n+   |     ^^^^^^^ value used here after move\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n+\n+error[E0382]: use of moved value: `implicit_into_iter`\n+  --> $DIR/move-fn-self-receiver.rs:63:5\n+   |\n+LL |     let implicit_into_iter = vec![true];\n+   |         ------------------ move occurs because `implicit_into_iter` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+LL |     for _val in implicit_into_iter {}\n+   |                 ------------------\n+   |                 |\n+   |                 `implicit_into_iter` moved due to this implicit call to `.into_iter()`\n+   |                 help: consider borrowing to avoid moving into the for loop: `&implicit_into_iter`\n+LL |     implicit_into_iter;\n+   |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `explicit_into_iter`\n+  --> $DIR/move-fn-self-receiver.rs:67:5\n+   |\n+LL |     let explicit_into_iter = vec![true];\n+   |         ------------------ move occurs because `explicit_into_iter` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+LL |     for _val in explicit_into_iter.into_iter() {}\n+   |                 ------------------------------ `explicit_into_iter` moved due to this method call\n+LL |     explicit_into_iter;\n+   |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `container`\n+  --> $DIR/move-fn-self-receiver.rs:71:5\n+   |\n+LL |     let container = Container(vec![]);\n+   |         --------- move occurs because `container` has type `Container`, which does not implement the `Copy` trait\n+LL |     for _val in container.custom_into_iter() {}\n+   |                 ---------------------------- `container` moved due to this method call\n+LL |     container;\n+   |     ^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `container`\n+  --> $DIR/move-fn-self-receiver.rs:23:25\n+   |\n+LL |     fn custom_into_iter(self) -> impl Iterator<Item = bool> {\n+   |                         ^^^^\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors have detailed explanations: E0382, E0505.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "f76b7a6f68f9b384a1141577a204d32467353e60", "filename": "src/test/ui/moves/moves-based-on-type-access-to-field.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -4,9 +4,15 @@ error[E0382]: borrow of moved value: `x`\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     consume(x.into_iter().next().unwrap());\n-   |             - value moved here\n+   |             ------------- `x` moved due to this method call\n LL |     touch(&x[0]);\n    |            ^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f55854ccf090e1cec6ef123c98d51b79d5cdb394", "filename": "src/test/ui/moves/moves-based-on-type-exprs.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -104,19 +104,31 @@ error[E0382]: borrow of moved value: `x`\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = x.into_iter().next().unwrap();\n-   |              - value moved here\n+   |              ------------- `x` moved due to this method call\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:83:11\n    |\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = [x.into_iter().next().unwrap(); 1];\n-   |               - value moved here\n+   |               ------------- `x` moved due to this method call\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to 11 previous errors\n "}, {"sha": "8761b5261d51bab1ebf7b6a2fd2cedcd6680df98", "filename": "src/test/ui/once-cant-call-twice-on-heap.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -4,10 +4,15 @@ error[E0382]: use of moved value: `blk`\n LL | fn foo<F:FnOnce()>(blk: F) {\n    |                    --- move occurs because `blk` has type `F`, which does not implement the `Copy` trait\n LL |     blk();\n-   |     --- value moved here\n+   |     ----- `blk` moved due to this call\n LL |     blk();\n    |     ^^^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/once-cant-call-twice-on-heap.rs:8:5\n+   |\n+LL |     blk();\n+   |     ^^^\n help: consider further restricting this bound\n    |\n LL | fn foo<F:FnOnce() + Copy>(blk: F) {"}, {"sha": "ab6f06518467c9bacaa471e69fb0562f96a987b9", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-call-twice.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tick`\n   --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:10:5\n    |\n LL |     tick();\n-   |     ---- value moved here\n+   |     ------ `tick` moved due to this call\n LL |     tick();\n    |     ^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `co\n    |\n LL |     let tick = || mem::drop(counter);\n    |                             ^^^^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:9:5\n+   |\n+LL |     tick();\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8d70a2b17602b1508e8018239048f850a07bf7a2", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-move-call-twice.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tick`\n   --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:10:5\n    |\n LL |     tick();\n-   |     ---- value moved here\n+   |     ------ `tick` moved due to this call\n LL |     tick();\n    |     ^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `co\n    |\n LL |     let tick = move || mem::drop(counter);\n    |                                  ^^^^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:9:5\n+   |\n+LL |     tick();\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "7e9c8559a4b39f01317ccf14b9011f0a2f79af60", "filename": "src/test/ui/unop-move-semantics.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -4,11 +4,16 @@ error[E0382]: borrow of moved value: `x`\n LL | fn move_then_borrow<T: Not<Output=T> + Clone>(x: T) {\n    |                                               - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n LL |     !x;\n-   |      - value moved here\n+   |     -- `x` moved due to this method call\n LL | \n LL |     x.clone();\n    |     ^ value borrowed here after move\n    |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn not(self) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn move_then_borrow<T: Not<Output=T> + Clone + Copy>(x: T) {"}, {"sha": "d3f59db043686e088cb1ab012db1c0752622ea36", "filename": "src/test/ui/unsized-locals/borrow-after-move.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -37,10 +37,16 @@ error[E0382]: borrow of moved value: `y`\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n-   |         - value moved here\n+   |         ------- `y` moved due to this method call\n ...\n LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n+  --> $DIR/borrow-after-move.rs:4:12\n+   |\n+LL |     fn foo(self) -> String;\n+   |            ^^^^\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrow-after-move.rs:39:24"}, {"sha": "01a08ba9944e9ff18ee065877d311a0c01024b09", "filename": "src/test/ui/unsized-locals/double-move.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -34,9 +34,15 @@ error[E0382]: use of moved value: `y`\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n-   |         - value moved here\n+   |         ------- `y` moved due to this method call\n LL |         y.foo();\n    |         ^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n+  --> $DIR/double-move.rs:4:12\n+   |\n+LL |     fn foo(self) -> String;\n+   |            ^^^^\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/double-move.rs:45:9"}, {"sha": "0b3ee040d3572f47b8103fb0cb3ca6426f41dfbc", "filename": "src/test/ui/use/use-after-move-self-based-on-type.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -4,9 +4,15 @@ error[E0382]: use of moved value: `self`\n LL |     pub fn foo(self) -> isize {\n    |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n-   |         ---- value moved here\n+   |         ---------- `self` moved due to this method call\n LL |         return self.x;\n    |                ^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `self`\n+  --> $DIR/use-after-move-self-based-on-type.rs:15:16\n+   |\n+LL |     pub fn bar(self) {}\n+   |                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e156a3f699b726f97234ae9e9533d59f51a167a3", "filename": "src/test/ui/use/use-after-move-self.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -4,9 +4,15 @@ error[E0382]: use of moved value: `self`\n LL |     pub fn foo(self) -> isize {\n    |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n-   |         ---- value moved here\n+   |         ---------- `self` moved due to this method call\n LL |         return *self.x;\n    |                ^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `self`\n+  --> $DIR/use-after-move-self.rs:13:16\n+   |\n+LL |     pub fn bar(self) {}\n+   |                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2534c29c18d03c47a7b5291d6355bf867116dd51", "filename": "src/test/ui/walk-struct-literal-with.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c11c35f8982a9a5fd654f0499cc72b70208d62f/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr?ref=2c11c35f8982a9a5fd654f0499cc72b70208d62f", "patch": "@@ -4,9 +4,15 @@ error[E0382]: borrow of moved value: `start`\n LL |     let start = Mine{test:\"Foo\".to_string(), other_val:0};\n    |         ----- move occurs because `start` has type `Mine`, which does not implement the `Copy` trait\n LL |     let end = Mine{other_val:1, ..start.make_string_bar()};\n-   |                                   ----- value moved here\n+   |                                   ----------------------- `start` moved due to this method call\n LL |     println!(\"{}\", start.test);\n    |                    ^^^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `start`\n+  --> $DIR/walk-struct-literal-with.rs:7:28\n+   |\n+LL |     fn make_string_bar(mut self) -> Mine{\n+   |                            ^^^^\n \n error: aborting due to previous error\n "}]}