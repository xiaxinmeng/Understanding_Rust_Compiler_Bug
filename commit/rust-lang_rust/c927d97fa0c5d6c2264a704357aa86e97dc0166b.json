{"sha": "c927d97fa0c5d6c2264a704357aa86e97dc0166b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MjdkOTdmYTBjNWQ2YzIyNjRhNzA0MzU3YWE4NmU5N2RjMDE2NmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T00:02:51Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:09:08Z"}, "message": "rustc: Convert attribute in the AST to interior vectors", "tree": {"sha": "b6addf1fc4cfa751d58ee6e0d96a280c6e16a54c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6addf1fc4cfa751d58ee6e0d96a280c6e16a54c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c927d97fa0c5d6c2264a704357aa86e97dc0166b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c927d97fa0c5d6c2264a704357aa86e97dc0166b", "html_url": "https://github.com/rust-lang/rust/commit/c927d97fa0c5d6c2264a704357aa86e97dc0166b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c927d97fa0c5d6c2264a704357aa86e97dc0166b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1591955adfb54354bcdb04712e561951d371002a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1591955adfb54354bcdb04712e561951d371002a", "html_url": "https://github.com/rust-lang/rust/commit/1591955adfb54354bcdb04712e561951d371002a"}], "stats": {"total": 150, "additions": 75, "deletions": 75}, "files": [{"sha": "fe014fd27da357fc0811861bd09ce09cb3afc035", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=c927d97fa0c5d6c2264a704357aa86e97dc0166b", "patch": "@@ -1,5 +1,6 @@\n // Functions dealing with attributes and meta_items\n \n+import std::ivec;\n import std::vec;\n import std::str;\n import std::map;\n@@ -28,7 +29,7 @@ export mk_attr;\n \n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n-fn find_linkage_metas(vec[ast::attribute] attrs) -> vec[@ast::meta_item] {\n+fn find_linkage_metas(&ast::attribute[] attrs) -> vec[@ast::meta_item] {\n     let vec[@ast::meta_item] metas = [];\n     for (ast::attribute attr in find_attrs_by_name(attrs, \"link\")) {\n         alt (attr.node.value.node) {\n@@ -44,8 +45,8 @@ fn find_linkage_metas(vec[ast::attribute] attrs) -> vec[@ast::meta_item] {\n }\n \n // Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(vec[ast::attribute] attrs,\n-                      ast::ident name) -> vec[ast::attribute] {\n+fn find_attrs_by_name(&ast::attribute[] attrs,\n+                      ast::ident name) -> ast::attribute[] {\n     auto filter = bind fn(&ast::attribute a,\n                           ast::ident name) -> option::t[ast::attribute] {\n         if (get_attr_name(a) == name) {\n@@ -54,7 +55,7 @@ fn find_attrs_by_name(vec[ast::attribute] attrs,\n             option::none\n         }\n     } (_, name);\n-    ret vec::filter_map(filter, attrs);\n+    ret ivec::filter_map(filter, attrs);\n }\n \n fn get_attr_name(&ast::attribute attr) -> ast::ident {\n@@ -101,8 +102,10 @@ fn get_meta_item_value_str(&@ast::meta_item meta) -> option::t[str] {\n fn attr_meta(&ast::attribute attr) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(&vec[ast::attribute] attrs) -> vec[@ast::meta_item] {\n-    ret vec::map(attr_meta, attrs);\n+fn attr_metas(&ast::attribute[] attrs) -> vec[@ast::meta_item] {\n+    auto mitems = [];\n+    for (ast::attribute a in attrs) { mitems += [attr_meta(a)]; }\n+    ret mitems;\n }\n \n fn eq(@ast::meta_item a, @ast::meta_item b) -> bool {"}, {"sha": "b8351282bec06894772153fd9eac28f7595bea8a", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=c927d97fa0c5d6c2264a704357aa86e97dc0166b", "patch": "@@ -1,3 +1,4 @@\n+import std::ivec;\n import std::option;\n import std::vec;\n import syntax::ast;\n@@ -97,11 +98,11 @@ fn native_item_in_cfg(&ast::crate_cfg cfg, &@ast::native_item item) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(&ast::crate_cfg cfg, &vec[ast::attribute] attrs) -> bool {\n+fn in_cfg(&ast::crate_cfg cfg, &ast::attribute[] attrs) -> bool {\n \n     // The \"cfg\" attributes on the item\n     auto item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n-    auto item_has_cfg_attrs = vec::len(item_cfg_attrs) > 0u;\n+    auto item_has_cfg_attrs = ivec::len(item_cfg_attrs) > 0u;\n     if (!item_has_cfg_attrs) { ret true; }\n \n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,"}, {"sha": "a9df1a99d066c2265a74ab79763d9fc2c74053b1", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=c927d97fa0c5d6c2264a704357aa86e97dc0166b", "patch": "@@ -290,8 +290,8 @@ fn get_meta_items(&ebml::doc md) -> vec[@ast::meta_item] {\n     ret items;\n }\n \n-fn get_attributes(&ebml::doc md) -> vec[ast::attribute] {\n-    let vec[ast::attribute] attrs = [];\n+fn get_attributes(&ebml::doc md) -> ast::attribute[] {\n+    let ast::attribute[] attrs = ~[];\n     alt (ebml::maybe_get_doc(md, tag_attributes)) {\n         case (option::some(?attrs_d)) {\n             for each (ebml::doc attr_doc in\n@@ -301,9 +301,9 @@ fn get_attributes(&ebml::doc md) -> vec[ast::attribute] {\n                 // an attribute\n                 assert (vec::len(meta_items) == 1u);\n                 auto meta_item = meta_items.(0);\n-                attrs += [rec(node=rec(style=ast::attr_outer,\n-                                       value=*meta_item),\n-                              span=rec(lo=0u, hi=0u))];\n+                attrs += ~[rec(node=rec(style=ast::attr_outer,\n+                                        value=*meta_item),\n+                               span=rec(lo=0u, hi=0u))];\n             }\n         }\n         case (option::none) { }\n@@ -327,7 +327,7 @@ fn list_crate_attributes(&ebml::doc md, io::writer out) {\n     out.write_str(\"\\n\\n\");\n }\n \n-fn get_crate_attributes(&vec[u8] data) -> vec[ast::attribute] {\n+fn get_crate_attributes(&vec[u8] data) -> ast::attribute[] {\n     ret get_attributes(ebml::new_doc(data));\n }\n "}, {"sha": "f92c77a7778d971c5926d715efb23c3a14bd66dc", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=c927d97fa0c5d6c2264a704357aa86e97dc0166b", "patch": "@@ -87,13 +87,13 @@ type crate = spanned[crate_];\n \n type crate_ = rec(vec[@crate_directive] directives,\n                   _mod module,\n-                  vec[attribute] attrs,\n+                  attribute[] attrs,\n                   crate_cfg config);\n \n tag crate_directive_ {\n-    cdir_src_mod(ident, option::t[filename], vec[attribute]);\n+    cdir_src_mod(ident, option::t[filename], attribute[]);\n     cdir_dir_mod(ident, option::t[filename],\n-                 vec[@crate_directive], vec[attribute]);\n+                 vec[@crate_directive], attribute[]);\n     cdir_view_item(@view_item);\n     cdir_syntax(path);\n     cdir_auth(path, _auth);\n@@ -526,7 +526,7 @@ tag attr_style { attr_outer; attr_inner; }\n type attribute_ = rec(attr_style style, meta_item value);\n \n type item = rec(ident ident,\n-                vec[attribute] attrs,\n+                attribute[] attrs,\n                 node_id id, // For objs and resources, this is the type def_id\n                 item_ node,\n                 span span);\n@@ -544,7 +544,7 @@ tag item_ {\n }\n \n type native_item = rec(ident ident,\n-                       vec[attribute] attrs,\n+                       attribute[] attrs,\n                        native_item_ node,\n                        node_id id,\n                        span span);"}, {"sha": "102815b5b1342500557d8b2665ec4c7d7d755c1e", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=c927d97fa0c5d6c2264a704357aa86e97dc0166b", "patch": "@@ -131,10 +131,10 @@ fn noop_fold_crate(&crate_ c, ast_fold fld) -> crate_ {\n     auto fold_meta_item = bind fold_meta_item_(_,fld);\n     auto fold_attribute = bind fold_attribute_(_,fold_meta_item);\n \n-    ret rec(directives=map(fld.fold_crate_directive, c.directives),\n+    ret rec(directives=vec::map(fld.fold_crate_directive, c.directives),\n             module=fld.fold_mod(c.module),\n-            attrs=map(fold_attribute, c.attrs),\n-            config=map(fold_meta_item, c.config));\n+            attrs=ivec::map(fold_attribute, c.attrs),\n+            config=vec::map(fold_meta_item, c.config));\n }\n \n fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld) \n@@ -166,7 +166,7 @@ fn noop_fold_native_item(&@native_item ni, ast_fold fld) -> @native_item {\n     auto fold_attribute = bind fold_attribute_(_,fold_meta_item);\n \n     ret @rec(ident=fld.fold_ident(ni.ident),\n-             attrs=map(fold_attribute, ni.attrs),\n+             attrs=ivec::map(fold_attribute, ni.attrs),\n              node=alt (ni.node) {\n                  case (native_item_ty) { native_item_ty }\n                  case (native_item_fn(?st, ?fdec, ?typms)) {\n@@ -188,7 +188,7 @@ fn noop_fold_item(&@item i, ast_fold fld) -> @item {\n     auto fold_attribute = bind fold_attribute_(_,fold_meta_item);\n \n     ret @rec(ident=fld.fold_ident(i.ident),\n-             attrs=map(fold_attribute,i.attrs),\n+             attrs=ivec::map(fold_attribute,i.attrs),\n              id=i.id, node=fld.fold_item_underscore(i.node),\n              span=i.span);\n }"}, {"sha": "a9189900470b1d449e9bc0ad0624b8ef066624ea", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=c927d97fa0c5d6c2264a704357aa86e97dc0166b", "patch": "@@ -1480,7 +1480,7 @@ fn parse_stmt(&parser p) -> @ast::stmt {\n }\n \n fn parse_crate_stmt(&parser p) -> @ast::stmt {\n-    auto cdir = parse_crate_directive(p, []);\n+    auto cdir = parse_crate_directive(p, ~[]);\n     ret @spanned(cdir.span.lo, cdir.span.hi,\n                  ast::stmt_crate_directive(@cdir));\n }\n@@ -1498,7 +1498,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n         auto item_attrs;\n         alt (parse_outer_attrs_or_ext(p)) {\n             case (none) {\n-                item_attrs = [];\n+                item_attrs = ~[];\n             }\n             case (some(left(?attrs))) {\n                 item_attrs = attrs;\n@@ -1512,7 +1512,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n         auto maybe_item = parse_item(p, item_attrs);\n \n         // If we have attributes then we should have an item\n-        if (vec::len(item_attrs) > 0u) {\n+        if (ivec::len(item_attrs) > 0u) {\n             alt (maybe_item) {\n                 case (got_item(_)) { /* fallthrough */ }\n                 case (_) {\n@@ -1718,7 +1718,7 @@ fn parse_fn_header(&parser p) -> tup(ast::ident, vec[ast::ty_param]) {\n }\n \n fn mk_item(&parser p, uint lo, uint hi, &ast::ident ident, &ast::item_ node,\n-           &vec[ast::attribute] attrs) -> @ast::item {\n+           &ast::attribute[] attrs) -> @ast::item {\n     ret @rec(ident=ident,\n              attrs=attrs,\n              id=p.get_id(),\n@@ -1727,7 +1727,7 @@ fn mk_item(&parser p, uint lo, uint hi, &ast::ident ident, &ast::item_ node,\n }\n \n fn parse_item_fn_or_iter(&parser p, ast::purity purity, ast::proto proto,\n-                         vec[ast::attribute] attrs) -> @ast::item {\n+                         &ast::attribute[] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto f = parse_fn(p, proto, purity);\n@@ -1778,7 +1778,7 @@ fn parse_dtor(&parser p) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, m);\n }\n \n-fn parse_item_obj(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n+fn parse_item_obj(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n    @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_value_ident(p);\n@@ -1801,7 +1801,7 @@ fn parse_item_obj(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n                                                 p.get_id()), attrs);\n }\n \n-fn parse_item_res(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n+fn parse_item_res(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n    @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_value_ident(p);\n@@ -1823,8 +1823,8 @@ fn parse_item_res(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n }\n \n fn parse_mod_items(&parser p, token::token term,\n-                   vec[ast::attribute] first_item_attrs) -> ast::_mod {\n-    auto view_items = if (vec::len(first_item_attrs) == 0u) {\n+                   &ast::attribute[] first_item_attrs) -> ast::_mod {\n+    auto view_items = if (ivec::len(first_item_attrs) == 0u) {\n         parse_view(p)\n     } else {\n         // Shouldn't be any view items since we've already parsed an item attr\n@@ -1834,7 +1834,7 @@ fn parse_mod_items(&parser p, token::token term,\n     auto initial_attrs = first_item_attrs;\n     while (p.peek() != term) {\n         auto attrs = initial_attrs + parse_outer_attributes(p);\n-        initial_attrs = [];\n+        initial_attrs = ~[];\n         alt (parse_item(p, attrs)) {\n             case (got_item(?i)) { vec::push(items, i); }\n             case (_) {\n@@ -1846,7 +1846,7 @@ fn parse_mod_items(&parser p, token::token term,\n     ret rec(view_items=view_items, items=items);\n }\n \n-fn parse_item_const(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n+fn parse_item_const(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ty = parse_ty(p);\n     auto id = parse_value_ident(p);\n@@ -1857,21 +1857,20 @@ fn parse_item_const(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_const(ty, e), attrs);\n }\n \n-fn parse_item_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n+fn parse_item_mod(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     expect(p, token::LBRACE);\n     auto inner_attrs = parse_inner_attrs_and_next(p);\n     auto first_item_outer_attrs = inner_attrs._1;\n-    auto m = parse_mod_items(p, token::RBRACE,\n-                             first_item_outer_attrs);\n+    auto m = parse_mod_items(p, token::RBRACE, first_item_outer_attrs);\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n     ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs._0);\n }\n \n-fn parse_item_native_type(&parser p,\n-                          &vec[ast::attribute] attrs) -> @ast::native_item {\n+fn parse_item_native_type(&parser p, &ast::attribute[] attrs)\n+        -> @ast::native_item {\n     auto t = parse_type_decl(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n@@ -1882,8 +1881,8 @@ fn parse_item_native_type(&parser p,\n              span=rec(lo=t._0, hi=hi));\n }\n \n-fn parse_item_native_fn(&parser p,\n-                        &vec[ast::attribute] attrs) -> @ast::native_item {\n+fn parse_item_native_fn(&parser p, &ast::attribute[] attrs)\n+        -> @ast::native_item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto decl = parse_fn_decl(p, ast::impure_fn);\n@@ -1901,8 +1900,8 @@ fn parse_item_native_fn(&parser p,\n              span=rec(lo=lo, hi=hi));\n }\n \n-fn parse_native_item(&parser p,\n-                     &vec[ast::attribute] attrs) -> @ast::native_item {\n+fn parse_native_item(&parser p, &ast::attribute[] attrs)\n+        -> @ast::native_item {\n     parse_layer(p);\n     if (eat_word(p, \"type\")) {\n         ret parse_item_native_type(p, attrs);\n@@ -1912,9 +1911,9 @@ fn parse_native_item(&parser p,\n }\n \n fn parse_native_mod_items(&parser p, &str native_name, ast::native_abi abi,\n-                          &vec[ast::attribute] first_item_attrs) ->\n-   ast::native_mod {\n-    auto view_items = if (vec::len(first_item_attrs) == 0u) {\n+                          &ast::attribute[] first_item_attrs)\n+        -> ast::native_mod {\n+    auto view_items = if (ivec::len(first_item_attrs) == 0u) {\n         parse_native_view(p)\n     } else {\n         // Shouldn't be any view items since we've already parsed an item attr\n@@ -1924,7 +1923,7 @@ fn parse_native_mod_items(&parser p, &str native_name, ast::native_abi abi,\n     auto initial_attrs = first_item_attrs;\n     while (p.peek() != token::RBRACE) {\n         auto attrs = initial_attrs + parse_outer_attributes(p);\n-        initial_attrs = [];\n+        initial_attrs = ~[];\n         items += [parse_native_item(p, attrs)];\n     }\n     ret rec(native_name=native_name,\n@@ -1933,7 +1932,7 @@ fn parse_native_mod_items(&parser p, &str native_name, ast::native_abi abi,\n             items=items);\n }\n \n-fn parse_item_native_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n+fn parse_item_native_mod(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto abi = ast::native_abi_cdecl;\n     if (!is_word(p, \"mod\")) {\n@@ -1973,7 +1972,7 @@ fn parse_type_decl(&parser p) -> tup(uint, ast::ident) {\n     ret tup(lo, id);\n }\n \n-fn parse_item_type(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n+fn parse_item_type(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto t = parse_type_decl(p);\n     auto tps = parse_ty_params(p);\n     expect(p, token::EQ);\n@@ -1983,7 +1982,7 @@ fn parse_item_type(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     ret mk_item(p, t._0, hi, t._1, ast::item_ty(ty, tps), attrs);\n }\n \n-fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n+fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n@@ -2062,7 +2061,7 @@ fn parse_auth(&parser p) -> ast::_auth {\n \n tag parsed_item { got_item(@ast::item); no_item; fn_no_item; }\n \n-fn parse_item(&parser p, vec[ast::attribute] attrs) -> parsed_item {\n+fn parse_item(&parser p, &ast::attribute[] attrs) -> parsed_item {\n     if (eat_word(p, \"const\")) {\n         ret got_item(parse_item_const(p, attrs));\n     } else if (eat_word(p, \"fn\")) {\n@@ -2096,16 +2095,15 @@ fn parse_item(&parser p, vec[ast::attribute] attrs) -> parsed_item {\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option::t[either::t[vec[ast::attribute],\n-                                       @ast::expr]];\n+type attr_or_ext = option::t[either::t[ast::attribute[], @ast::expr]];\n \n fn parse_outer_attrs_or_ext(&parser p) -> attr_or_ext {\n     if (p.peek() == token::POUND) {\n         auto lo = p.get_lo_pos();\n         p.bump();\n         if (p.peek() == token::LBRACKET) {\n             auto first_attr = parse_attribute_naked(p, ast::attr_outer, lo);\n-            ret some(left([first_attr] + parse_outer_attributes(p)));\n+            ret some(left(~[first_attr] + parse_outer_attributes(p)));\n         } else {\n             ret some(right(parse_syntax_ext_naked(p, lo)));\n         }\n@@ -2115,10 +2113,10 @@ fn parse_outer_attrs_or_ext(&parser p) -> attr_or_ext {\n }\n \n // Parse attributes that appear before an item\n-fn parse_outer_attributes(&parser p) -> vec[ast::attribute] {\n-    let vec[ast::attribute] attrs = [];\n+fn parse_outer_attributes(&parser p) -> ast::attribute[] {\n+    let ast::attribute[] attrs = ~[];\n     while (p.peek() == token::POUND) {\n-        attrs += [parse_attribute(p, ast::attr_outer)];\n+        attrs += ~[parse_attribute(p, ast::attr_outer)];\n     }\n     ret attrs;\n }\n@@ -2144,22 +2142,22 @@ fn parse_attribute_naked(&parser p, ast::attr_style style,\n // next item (since we can't know whether the attribute is an inner attribute\n // of the containing item or an outer attribute of the first contained item\n // until we see the semi).\n-fn parse_inner_attrs_and_next(&parser p) -> tup(vec[ast::attribute],\n-                                                vec[ast::attribute]) {\n-    let vec[ast::attribute] inner_attrs = [];\n-    let vec[ast::attribute] next_outer_attrs = [];\n+fn parse_inner_attrs_and_next(&parser p) -> tup(ast::attribute[],\n+                                                ast::attribute[]) {\n+    let ast::attribute[] inner_attrs = ~[];\n+    let ast::attribute[] next_outer_attrs = ~[];\n     while (p.peek() == token::POUND) {\n         auto attr = parse_attribute(p, ast::attr_inner);\n         if (p.peek() == token::SEMI) {\n             p.bump();\n-            inner_attrs += [attr];\n+            inner_attrs += ~[attr];\n         } else {\n             // It's not really an inner attribute\n             auto outer_attr = spanned(attr.span.lo,\n                                       attr.span.hi,\n                                       rec(style=ast::attr_outer,\n                                           value=attr.node.value));\n-            next_outer_attrs += [outer_attr];\n+            next_outer_attrs += ~[outer_attr];\n             break;\n         }\n     }\n@@ -2340,8 +2338,7 @@ fn parse_crate_from_source_file(&str input, &ast::crate_cfg cfg,\n     auto first_item_outer_attrs = crate_attrs._1;\n     auto m = parse_mod_items(p, token::EOF,\n                              first_item_outer_attrs);\n-    let vec[@ast::crate_directive] cdirs = [];\n-    ret @spanned(lo, p.get_lo_pos(), rec(directives=cdirs,\n+    ret @spanned(lo, p.get_lo_pos(), rec(directives=[],\n                                          module=m,\n                                          attrs=crate_attrs._0,\n                                          config=p.get_cfg()));\n@@ -2362,14 +2359,13 @@ fn parse_str(&parser p) -> ast::ident {\n // Each crate file is a sequence of directives.\n //\n // Each directive imperatively extends its environment with 0 or more items.\n-fn parse_crate_directive(&parser p, vec[ast::attribute] first_outer_attr)\n+fn parse_crate_directive(&parser p, &ast::attribute[] first_outer_attr)\n     -> ast::crate_directive {\n \n     // Collect the next attributes\n-    auto outer_attrs = first_outer_attr\n-        + parse_outer_attributes(p);\n+    auto outer_attrs = first_outer_attr + parse_outer_attributes(p);\n     // In a crate file outer attributes are only going to apply to mods\n-    auto expect_mod = vec::len(outer_attrs) > 0u;\n+    auto expect_mod = ivec::len(outer_attrs) > 0u;\n \n     auto lo = p.get_lo_pos();\n     if (expect_mod || is_word(p, \"mod\")) {\n@@ -2424,13 +2420,13 @@ fn parse_crate_directive(&parser p, vec[ast::attribute] first_outer_attr)\n }\n \n fn parse_crate_directives(&parser p, token::token term,\n-                          vec[ast::attribute] first_outer_attr) ->\n+                          &ast::attribute[] first_outer_attr) ->\n    vec[@ast::crate_directive] {\n \n     // This is pretty ugly. If we have an outer attribute then we can't accept\n     // seeing the terminator next, so if we do see it then fail the same way\n     // parse_crate_directive would\n-    if (vec::len(first_outer_attr) > 0u && p.peek() == term) {\n+    if (ivec::len(first_outer_attr) > 0u && p.peek() == term) {\n         expect_word(p, \"mod\");\n     }\n "}, {"sha": "a928976c4a8324f1588fc8fca9803b53cb6235ec", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c927d97fa0c5d6c2264a704357aa86e97dc0166b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=c927d97fa0c5d6c2264a704357aa86e97dc0166b", "patch": "@@ -242,7 +242,7 @@ fn commasep_exprs(&ps s, breaks b, vec[@ast::expr] exprs) {\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-fn print_mod(&ps s, ast::_mod _mod, &vec[ast::attribute] attrs) {\n+fn print_mod(&ps s, ast::_mod _mod, &ast::attribute[] attrs) {\n     print_inner_attributes(s, attrs);\n     for (@ast::view_item vitem in _mod.view_items) {\n         print_view_item(s, vitem);\n@@ -533,7 +533,7 @@ fn print_item(&ps s, &@ast::item item) {\n     s.ann.post(ann_node);\n }\n \n-fn print_outer_attributes(&ps s, vec[ast::attribute] attrs) {\n+fn print_outer_attributes(&ps s, &ast::attribute[] attrs) {\n     auto count = 0;\n     for (ast::attribute attr in attrs) {\n         alt (attr.node.style) {\n@@ -544,7 +544,7 @@ fn print_outer_attributes(&ps s, vec[ast::attribute] attrs) {\n     if (count > 0) { hardbreak_if_not_bol(s); }\n }\n \n-fn print_inner_attributes(&ps s, vec[ast::attribute] attrs) {\n+fn print_inner_attributes(&ps s, &ast::attribute[] attrs) {\n     auto count = 0;\n     for (ast::attribute attr in attrs) {\n         alt (attr.node.style) {"}]}