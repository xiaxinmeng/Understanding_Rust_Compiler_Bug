{"sha": "09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4", "node_id": "C_kwDOAAsO6NoAKDA5ZjRmN2M4ZjBiMGUxMWM3YmRmMzVlNzNiYjIyZjkwZTU4YjFjYTQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-01T08:42:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-01T08:42:27Z"}, "message": "Rollup merge of #103759 - cjgillot:adt-collect, r=davidtwco\n\nUse `adt_def` during type collection.\n\nThis removes a wrapper which is close to what `adt_def` does.", "tree": {"sha": "1264259b24a4d004526b5c57b1330388d2d94933", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1264259b24a4d004526b5c57b1330388d2d94933"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjYNvzCRBK7hj4Ov3rIwAAP+gIAIpoHaYMR8m2U10eSq/I5VCg\nEmbOx6V1EIWCgsNY295adFEif0Zy9G2WH1tn2JNqh62+sMeu0LzQ8GNJwEI1+gyU\nqy6Or3DDclORvtLMxu4EvPwe2pughruDuWwf0vxDxzvyVR9GjqYDhF5GvQQ5NjOw\nLUwrKHYBeyvhuIlmDrk6zZ0Qdicj6nXqHUpfkCNzY4akBphwhXJpPbCyOzLG6d55\nyUzcpJgkIzNS7UuhcOz5/NVhLiDLr9J0tMY35Ba/Oa7oiIAYF0GeYq2h7GQ/qsCR\nGcpGLL7oaD71J40csCrwbO4xkchN/OZKUzP6nWAg3M1aJFXM2/HDys12LOvEiQI=\n=uDiD\n-----END PGP SIGNATURE-----\n", "payload": "tree 1264259b24a4d004526b5c57b1330388d2d94933\nparent 20528baac4f676c8cbc969ab390e12d8039711aa\nparent abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1667292147 +0530\ncommitter GitHub <noreply@github.com> 1667292147 +0530\n\nRollup merge of #103759 - cjgillot:adt-collect, r=davidtwco\n\nUse `adt_def` during type collection.\n\nThis removes a wrapper which is close to what `adt_def` does.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4", "html_url": "https://github.com/rust-lang/rust/commit/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20528baac4f676c8cbc969ab390e12d8039711aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/20528baac4f676c8cbc969ab390e12d8039711aa", "html_url": "https://github.com/rust-lang/rust/commit/20528baac4f676c8cbc969ab390e12d8039711aa"}, {"sha": "abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e", "url": "https://api.github.com/repos/rust-lang/rust/commits/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e", "html_url": "https://github.com/rust-lang/rust/commit/abc1ad71062dd8e2b7ae97ada736f2d0c0b2344e"}], "stats": {"total": 277, "additions": 113, "deletions": 164}, "files": [{"sha": "133bbd52b9142c3249d634c057088df2953bfef9", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 62, "deletions": 59, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4", "patch": "@@ -6,7 +6,7 @@ use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n@@ -75,15 +75,15 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         check_simd(tcx, span, def_id);\n     }\n \n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_packed(tcx, span, def);\n }\n \n fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def);\n }\n@@ -506,11 +506,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             tcx.ensure().typeck(id.owner_id.def_id);\n         }\n         DefKind::Enum => {\n-            let item = tcx.hir().item(id);\n-            let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n-                return;\n-            };\n-            check_enum(tcx, &enum_definition.variants, item.owner_id.def_id);\n+            check_enum(tcx, id.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n@@ -1026,7 +1022,7 @@ pub(super) fn check_packed_inner(\n     None\n }\n \n-pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtDef<'tcx>) {\n+pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     if !adt.repr().transparent() {\n         return;\n     }\n@@ -1035,14 +1031,14 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         feature_err(\n             &tcx.sess.parse_sess,\n             sym::transparent_unions,\n-            sp,\n+            tcx.def_span(adt.did()),\n             \"transparent unions are unstable\",\n         )\n         .emit();\n     }\n \n     if adt.variants().len() != 1 {\n-        bad_variant_count(tcx, adt, sp, adt.did());\n+        bad_variant_count(tcx, adt, tcx.def_span(adt.did()), adt.did());\n         if adt.variants().is_empty() {\n             // Don't bother checking the fields. No variants (and thus no fields) exist.\n             return;\n@@ -1103,7 +1099,7 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         .filter_map(|(span, zst, _align1, _non_exhaustive)| if !zst { Some(span) } else { None });\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count >= 2 {\n-        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, tcx.def_span(adt.did()));\n     }\n     let incompatible_zst_fields =\n         field_infos.clone().filter(|(_, _, _, opt)| opt.is_some()).count();\n@@ -1143,20 +1139,19 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n }\n \n #[allow(trivial_numeric_casts)]\n-fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: LocalDefId) {\n+fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n-    let sp = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n \n-    if vs.is_empty() {\n+    if def.variants().is_empty() {\n         if let Some(attr) = tcx.get_attrs(def_id.to_def_id(), sym::repr).next() {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,\n                 E0084,\n                 \"unsupported representation for zero-variant enum\"\n             )\n-            .span_label(sp, \"zero-variant enum\")\n+            .span_label(tcx.def_span(def_id), \"zero-variant enum\")\n             .emit();\n         }\n     }\n@@ -1167,88 +1162,96 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n             feature_err(\n                 &tcx.sess.parse_sess,\n                 sym::repr128,\n-                sp,\n+                tcx.def_span(def_id),\n                 \"repr with 128-bit type is unstable\",\n             )\n             .emit();\n         }\n     }\n \n-    for v in vs {\n-        if let Some(ref e) = v.disr_expr {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(e.hir_id));\n+    for v in def.variants() {\n+        if let ty::VariantDiscr::Explicit(discr_def_id) = v.discr {\n+            tcx.ensure().typeck(discr_def_id.expect_local());\n         }\n     }\n \n-    if tcx.adt_def(def_id).repr().int.is_none() {\n-        let is_unit = |var: &hir::Variant<'_>| matches!(var.data, hir::VariantData::Unit(..));\n+    if def.repr().int.is_none() {\n+        let is_unit = |var: &ty::VariantDef| matches!(var.ctor_kind, CtorKind::Const);\n+        let has_disr = |var: &ty::VariantDef| matches!(var.discr, ty::VariantDiscr::Explicit(_));\n \n-        let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n-        let has_non_units = vs.iter().any(|var| !is_unit(var));\n-        let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n-        let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n+        let has_non_units = def.variants().iter().any(|var| !is_unit(var));\n+        let disr_units = def.variants().iter().any(|var| is_unit(&var) && has_disr(&var));\n+        let disr_non_unit = def.variants().iter().any(|var| !is_unit(&var) && has_disr(&var));\n \n         if disr_non_unit || (disr_units && has_non_units) {\n-            let mut err =\n-                struct_span_err!(tcx.sess, sp, E0732, \"`#[repr(inttype)]` must be specified\");\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                tcx.def_span(def_id),\n+                E0732,\n+                \"`#[repr(inttype)]` must be specified\"\n+            );\n             err.emit();\n         }\n     }\n \n-    detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n-\n-    check_transparent(tcx, sp, def);\n+    detect_discriminant_duplicate(tcx, def);\n+    check_transparent(tcx, def);\n }\n \n /// Part of enum check. Given the discriminants of an enum, errors if two or more discriminants are equal\n-fn detect_discriminant_duplicate<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mut discrs: Vec<(VariantIdx, Discr<'tcx>)>,\n-    vs: &'tcx [hir::Variant<'tcx>],\n-    self_span: Span,\n-) {\n+fn detect_discriminant_duplicate<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     // Helper closure to reduce duplicate code. This gets called everytime we detect a duplicate.\n     // Here `idx` refers to the order of which the discriminant appears, and its index in `vs`\n-    let report = |dis: Discr<'tcx>, idx: usize, err: &mut Diagnostic| {\n-        let var = &vs[idx]; // HIR for the duplicate discriminant\n-        let (span, display_discr) = match var.disr_expr {\n-            Some(ref expr) => {\n+    let report = |dis: Discr<'tcx>, idx, err: &mut Diagnostic| {\n+        let var = adt.variant(idx); // HIR for the duplicate discriminant\n+        let (span, display_discr) = match var.discr {\n+            ty::VariantDiscr::Explicit(discr_def_id) => {\n                 // In the case the discriminant is both a duplicate and overflowed, let the user know\n-                if let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n+                if let hir::Node::AnonConst(expr) = tcx.hir().get_by_def_id(discr_def_id.expect_local())\n+                    && let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n                     && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n                     && *lit_value != dis.val\n                 {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n-                // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n                 } else {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}`\"))\n+                    // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}`\"))\n                 }\n             }\n-            None => {\n+            // This should not happen.\n+            ty::VariantDiscr::Relative(0) => (tcx.def_span(var.def_id), format!(\"`{dis}`\")),\n+            ty::VariantDiscr::Relative(distance_to_explicit) => {\n                 // At this point we know this discriminant is a duplicate, and was not explicitly\n                 // assigned by the user. Here we iterate backwards to fetch the HIR for the last\n                 // explicitly assigned discriminant, and letting the user know that this was the\n                 // increment startpoint, and how many steps from there leading to the duplicate\n-                if let Some((n, hir::Variant { span, ident, .. })) =\n-                    vs[..idx].iter().rev().enumerate().find(|v| v.1.disr_expr.is_some())\n+                if let Some(explicit_idx) =\n+                    idx.as_u32().checked_sub(distance_to_explicit).map(VariantIdx::from_u32)\n                 {\n-                    let ve_ident = var.ident;\n-                    let n = n + 1;\n-                    let sp = if n > 1 { \"variants\" } else { \"variant\" };\n+                    let explicit_variant = adt.variant(explicit_idx);\n+                    let ve_ident = var.name;\n+                    let ex_ident = explicit_variant.name;\n+                    let sp = if distance_to_explicit > 1 { \"variants\" } else { \"variant\" };\n \n                     err.span_label(\n-                        *span,\n-                        format!(\"discriminant for `{ve_ident}` incremented from this startpoint (`{ident}` + {n} {sp} later => `{ve_ident}` = {dis})\"),\n+                        tcx.def_span(explicit_variant.def_id),\n+                        format!(\n+                            \"discriminant for `{ve_ident}` incremented from this startpoint \\\n+                            (`{ex_ident}` + {distance_to_explicit} {sp} later \\\n+                             => `{ve_ident}` = {dis})\"\n+                        ),\n                     );\n                 }\n \n-                (vs[idx].span, format!(\"`{dis}`\"))\n+                (tcx.def_span(var.def_id), format!(\"`{dis}`\"))\n             }\n         };\n \n         err.span_label(span, format!(\"{display_discr} assigned here\"));\n     };\n \n+    let mut discrs = adt.discriminants(tcx).collect::<Vec<_>>();\n+\n     // Here we loop through the discriminants, comparing each discriminant to another.\n     // When a duplicate is detected, we instantiate an error and point to both\n     // initial and duplicate value. The duplicate discriminant is then discarded by swapping\n@@ -1257,29 +1260,29 @@ fn detect_discriminant_duplicate<'tcx>(\n     // style as we are mutating `discrs` on the fly).\n     let mut i = 0;\n     while i < discrs.len() {\n-        let hir_var_i_idx = discrs[i].0.index();\n+        let var_i_idx = discrs[i].0;\n         let mut error: Option<DiagnosticBuilder<'_, _>> = None;\n \n         let mut o = i + 1;\n         while o < discrs.len() {\n-            let hir_var_o_idx = discrs[o].0.index();\n+            let var_o_idx = discrs[o].0;\n \n             if discrs[i].1.val == discrs[o].1.val {\n                 let err = error.get_or_insert_with(|| {\n                     let mut ret = struct_span_err!(\n                         tcx.sess,\n-                        self_span,\n+                        tcx.def_span(adt.did()),\n                         E0081,\n                         \"discriminant value `{}` assigned more than once\",\n                         discrs[i].1,\n                     );\n \n-                    report(discrs[i].1, hir_var_i_idx, &mut ret);\n+                    report(discrs[i].1, var_i_idx, &mut ret);\n \n                     ret\n                 });\n \n-                report(discrs[o].1, hir_var_o_idx, err);\n+                report(discrs[o].1, var_o_idx, err);\n \n                 // Safe to unwrap here, as we wouldn't reach this point if `discrs` was empty\n                 discrs[o] = *discrs.last().unwrap();"}, {"sha": "99d0beacfa0a1b9a7b5fee2815d696375591bfef", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 28, "deletions": 79, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4", "patch": "@@ -218,19 +218,16 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, def_id, ty.span, false);\n         }\n-        hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, false, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Struct(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, false);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Union(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| wfcx.enum_variants(enum_def));\n-\n+        hir::ItemKind::Enum(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Trait(..) => {\n@@ -1037,35 +1034,33 @@ fn item_adt_kind(kind: &ItemKind<'_>) -> Option<AdtKind> {\n }\n \n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-fn check_type_defn<'tcx, F>(\n-    tcx: TyCtxt<'tcx>,\n-    item: &hir::Item<'tcx>,\n-    all_sized: bool,\n-    mut lookup_fields: F,\n-) where\n-    F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n-{\n+fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: bool) {\n     let _ = tcx.representability(item.owner_id.def_id);\n+    let adt_def = tcx.adt_def(item.owner_id);\n \n     enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n-        let variants = lookup_fields(wfcx);\n-        let packed = tcx.adt_def(item.owner_id).repr().packed();\n+        let variants = adt_def.variants();\n+        let packed = adt_def.repr().packed();\n \n-        for variant in &variants {\n+        for variant in variants.iter() {\n             // All field types must be well-formed.\n             for field in &variant.fields {\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n-                    field.span,\n-                    Some(WellFormedLoc::Ty(field.def_id)),\n-                    field.ty.into(),\n+                    hir_ty.span,\n+                    Some(WellFormedLoc::Ty(field_id)),\n+                    ty.into(),\n                 )\n             }\n \n             // For DST, or when drop needs to copy things around, all\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n-                    let ty = variant.fields.last().unwrap().ty;\n+                    let ty = tcx.type_of(variant.fields.last().unwrap().did);\n                     let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n                         tcx.sess\n@@ -1084,27 +1079,31 @@ fn check_type_defn<'tcx, F>(\n                 variant.fields[..variant.fields.len() - unsized_len].iter().enumerate()\n             {\n                 let last = idx == variant.fields.len() - 1;\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new(\n-                        field.span,\n+                        hir_ty.span,\n                         wfcx.body_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n                                 None => bug!(),\n                             },\n-                            span: field.span,\n+                            span: hir_ty.span,\n                             last,\n                         },\n                     ),\n                     wfcx.param_env,\n-                    field.ty,\n+                    ty,\n                     tcx.require_lang_item(LangItem::Sized, None),\n                 );\n             }\n \n             // Explicit `enum` discriminant values must const-evaluate successfully.\n-            if let Some(discr_def_id) = variant.explicit_discr {\n+            if let ty::VariantDiscr::Explicit(discr_def_id) = variant.discr {\n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n                     wfcx.body_id,\n@@ -1114,7 +1113,7 @@ fn check_type_defn<'tcx, F>(\n                     cause,\n                     wfcx.param_env,\n                     ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(\n-                        ty::Const::from_anon_const(tcx, discr_def_id),\n+                        ty::Const::from_anon_const(tcx, discr_def_id.expect_local()),\n                     ))\n                     .to_predicate(tcx),\n                 ));\n@@ -1925,56 +1924,6 @@ fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n     items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// ADT\n-\n-// FIXME(eddyb) replace this with getting fields/discriminants through `ty::AdtDef`.\n-struct AdtVariant<'tcx> {\n-    /// Types of fields in the variant, that must be well-formed.\n-    fields: Vec<AdtField<'tcx>>,\n-\n-    /// Explicit discriminant of this variant (e.g. `A = 123`),\n-    /// that must evaluate to a constant value.\n-    explicit_discr: Option<LocalDefId>,\n-}\n-\n-struct AdtField<'tcx> {\n-    ty: Ty<'tcx>,\n-    def_id: LocalDefId,\n-    span: Span,\n-}\n-\n-impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n-    // FIXME(eddyb) replace this with getting fields through `ty::AdtDef`.\n-    fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n-        let fields = struct_def\n-            .fields()\n-            .iter()\n-            .map(|field| {\n-                let def_id = self.tcx().hir().local_def_id(field.hir_id);\n-                let field_ty = self.tcx().type_of(def_id);\n-                let field_ty = self.normalize(field.ty.span, None, field_ty);\n-                debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n-                AdtField { ty: field_ty, span: field.ty.span, def_id }\n-            })\n-            .collect();\n-        AdtVariant { fields, explicit_discr: None }\n-    }\n-\n-    fn enum_variants(&self, enum_def: &hir::EnumDef<'_>) -> Vec<AdtVariant<'tcx>> {\n-        enum_def\n-            .variants\n-            .iter()\n-            .map(|variant| AdtVariant {\n-                fields: self.non_enum_variant(&variant.data).fields,\n-                explicit_discr: variant\n-                    .disr_expr\n-                    .map(|explicit_discr| self.tcx().hir().local_def_id(explicit_discr.hir_id)),\n-            })\n-            .collect()\n-    }\n-}\n-\n fn error_392(\n     tcx: TyCtxt<'_>,\n     span: Span,"}, {"sha": "46db0f74d4d5f5b936c0b529aa22246564493007", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4", "patch": "@@ -604,11 +604,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                 }\n             }\n         }\n-        hir::ItemKind::Enum(ref enum_definition, _) => {\n+        hir::ItemKind::Enum(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            convert_enum_variant_types(tcx, def_id.to_def_id(), enum_definition.variants);\n+            convert_enum_variant_types(tcx, def_id.to_def_id());\n         }\n         hir::ItemKind::Impl { .. } => {\n             tcx.ensure().generics_of(def_id);\n@@ -640,7 +640,8 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             }\n \n             if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                convert_variant_ctor(tcx, ctor_hir_id);\n+                let ctor_def_id = tcx.hir().local_def_id(ctor_hir_id);\n+                convert_variant_ctor(tcx, ctor_def_id);\n             }\n         }\n \n@@ -750,55 +751,51 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n     }\n }\n \n-fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id(ctor_id);\n+fn convert_variant_ctor(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::Variant<'_>]) {\n+fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr().discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_discr = None::<Discr<'_>>;\n \n     // fill the discriminant values and field types\n-    for variant in variants {\n+    for variant in def.variants() {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n-            if let Some(ref e) = variant.disr_expr {\n-                let expr_did = tcx.hir().local_def_id(e.hir_id);\n-                def.eval_explicit_discr(tcx, expr_did.to_def_id())\n+            if let ty::VariantDiscr::Explicit(const_def_id) = variant.discr {\n+                def.eval_explicit_discr(tcx, const_def_id)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n             } else {\n-                struct_span_err!(tcx.sess, variant.span, E0370, \"enum discriminant overflowed\")\n-                    .span_label(\n-                        variant.span,\n-                        format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n-                    )\n+                let span = tcx.def_span(variant.def_id);\n+                struct_span_err!(tcx.sess, span, E0370, \"enum discriminant overflowed\")\n+                    .span_label(span, format!(\"overflowed on value after {}\", prev_discr.unwrap()))\n                     .note(&format!(\n                         \"explicitly set `{} = {}` if that is desired outcome\",\n-                        variant.ident, wrapped_discr\n+                        tcx.item_name(variant.def_id),\n+                        wrapped_discr\n                     ))\n                     .emit();\n                 None\n             }\n             .unwrap_or(wrapped_discr),\n         );\n \n-        for f in variant.data.fields() {\n-            let def_id = tcx.hir().local_def_id(f.hir_id);\n-            tcx.ensure().generics_of(def_id);\n-            tcx.ensure().type_of(def_id);\n-            tcx.ensure().predicates_of(def_id);\n+        for f in &variant.fields {\n+            tcx.ensure().generics_of(f.did);\n+            tcx.ensure().type_of(f.did);\n+            tcx.ensure().predicates_of(f.did);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-            convert_variant_ctor(tcx, ctor_hir_id);\n+        if let Some(ctor_def_id) = variant.ctor_def_id {\n+            convert_variant_ctor(tcx, ctor_def_id.expect_local());\n         }\n     }\n }"}, {"sha": "d4b21f6893b43295b023ff2de1dab074617f02e0", "filename": "src/test/ui/error-codes/E0081.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr?ref=09f4f7c8f0b0e11c7bdf35e73bb22f90e58b1ca4", "patch": "@@ -32,7 +32,7 @@ LL |     First = -1,\n    |             -- `-1` assigned here\n LL |\n LL |     Second = -2,\n-   |     ----------- discriminant for `Last` incremented from this startpoint (`Second` + 1 variant later => `Last` = -1)\n+   |     ------ discriminant for `Last` incremented from this startpoint (`Second` + 1 variant later => `Last` = -1)\n LL |\n LL |     Last,\n    |     ---- `-1` assigned here\n@@ -53,7 +53,7 @@ LL |     V4 = 0,\n    |          - `0` assigned here\n LL |\n LL |     V5 = -2,\n-   |     ------- discriminant for `V7` incremented from this startpoint (`V5` + 2 variants later => `V7` = 0)\n+   |     -- discriminant for `V7` incremented from this startpoint (`V5` + 2 variants later => `V7` = 0)\n ...\n LL |     V7,\n    |     -- `0` assigned here\n@@ -68,7 +68,7 @@ LL |     V5 = -2,\n    |          -- `-2` assigned here\n ...\n LL |     V8 = -3,\n-   |     ------- discriminant for `V9` incremented from this startpoint (`V8` + 1 variant later => `V9` = -2)\n+   |     -- discriminant for `V9` incremented from this startpoint (`V8` + 1 variant later => `V9` = -2)\n LL |\n LL |     V9,\n    |     -- `-2` assigned here"}]}