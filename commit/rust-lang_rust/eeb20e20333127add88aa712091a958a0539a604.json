{"sha": "eeb20e20333127add88aa712091a958a0539a604", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYjIwZTIwMzMzMTI3YWRkODhhYTcxMjA5MWE5NThhMDUzOWE2MDQ=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-20T12:34:19Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-20T13:35:16Z"}, "message": "Refactor rewrite for ast::Block", "tree": {"sha": "83b61f3b3c0152f0146a4ef6247baa8ac1c083fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83b61f3b3c0152f0146a4ef6247baa8ac1c083fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb20e20333127add88aa712091a958a0539a604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb20e20333127add88aa712091a958a0539a604", "html_url": "https://github.com/rust-lang/rust/commit/eeb20e20333127add88aa712091a958a0539a604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb20e20333127add88aa712091a958a0539a604/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90251c32ff4b52e3f3ac466d1b16bb91366d21a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/90251c32ff4b52e3f3ac466d1b16bb91366d21a3", "html_url": "https://github.com/rust-lang/rust/commit/90251c32ff4b52e3f3ac466d1b16bb91366d21a3"}], "stats": {"total": 187, "additions": 109, "deletions": 78}, "files": [{"sha": "ebf9d5c1baac474947cb25f2718e81bc8f1584dd", "filename": "src/expr.rs", "status": "modified", "additions": 109, "deletions": 78, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/eeb20e20333127add88aa712091a958a0539a604/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb20e20333127add88aa712091a958a0539a604/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=eeb20e20333127add88aa712091a958a0539a604", "patch": "@@ -290,7 +290,9 @@ fn format_expr(\n             )\n         }\n         ast::ExprKind::Catch(ref block) => {\n-            if let rewrite @ Some(_) = try_one_line_block(context, shape, \"do catch \", block) {\n+            if let rewrite @ Some(_) =\n+                rewrite_single_line_block(context, \"do catch \", block, shape)\n+            {\n                 return rewrite;\n             }\n             // 9 = `do catch `\n@@ -315,23 +317,6 @@ fn format_expr(\n     }\n }\n \n-fn try_one_line_block(\n-    context: &RewriteContext,\n-    shape: Shape,\n-    prefix: &str,\n-    block: &ast::Block,\n-) -> Option<String> {\n-    if is_simple_block(block, context.codemap) {\n-        let expr_shape = Shape::legacy(shape.width - prefix.len(), shape.indent);\n-        let expr_str = try_opt!(block.stmts[0].rewrite(context, expr_shape));\n-        let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n-        if result.len() <= shape.width && !result.contains('\\n') {\n-            return Some(result);\n-        }\n-    }\n-    None\n-}\n-\n pub fn rewrite_pair<LHS, RHS>(\n     lhs: &LHS,\n     rhs: &RHS,\n@@ -763,78 +748,124 @@ fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String\n     })\n }\n \n-impl Rewrite for ast::Block {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        // shape.width is used only for the single line case: either the empty block `{}`,\n-        // or an unsafe expression `unsafe { e }`.\n+fn rewrite_empty_block(\n+    context: &RewriteContext,\n+    block: &ast::Block,\n+    shape: Shape,\n+) -> Option<String> {\n+    if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) &&\n+        shape.width >= 2\n+    {\n+        return Some(\"{}\".to_owned());\n+    }\n \n-        if self.stmts.is_empty() && !block_contains_comment(self, context.codemap) &&\n-            shape.width >= 2\n+    // If a block contains only a single-line comment, then leave it on one line.\n+    let user_str = context.snippet(block.span);\n+    let user_str = user_str.trim();\n+    if user_str.starts_with('{') && user_str.ends_with('}') {\n+        let comment_str = user_str[1..user_str.len() - 1].trim();\n+        if block.stmts.is_empty() && !comment_str.contains('\\n') &&\n+            !comment_str.starts_with(\"//\") && comment_str.len() + 4 <= shape.width\n         {\n-            return Some(\"{}\".to_owned());\n+            return Some(format!(\"{{ {} }}\", comment_str));\n         }\n+    }\n \n-        // If a block contains only a single-line comment, then leave it on one line.\n-        let user_str = context.snippet(self.span);\n-        let user_str = user_str.trim();\n-        if user_str.starts_with('{') && user_str.ends_with('}') {\n-            let comment_str = user_str[1..user_str.len() - 1].trim();\n-            if self.stmts.is_empty() && !comment_str.contains('\\n') &&\n-                !comment_str.starts_with(\"//\") &&\n-                comment_str.len() + 4 <= shape.width\n-            {\n-                return Some(format!(\"{{ {} }}\", comment_str));\n+    None\n+}\n+\n+fn block_prefix(context: &RewriteContext, block: &ast::Block, shape: Shape) -> Option<String> {\n+    Some(match block.rules {\n+        ast::BlockCheckMode::Unsafe(..) => {\n+            let snippet = context.snippet(block.span);\n+            let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n+            // Extract comment between unsafe and block start.\n+            let trimmed = &snippet[6..open_pos].trim();\n+\n+            if !trimmed.is_empty() {\n+                // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n+                let budget = try_opt!(shape.width.checked_sub(9));\n+                format!(\n+                    \"unsafe {} \",\n+                    try_opt!(rewrite_comment(\n+                        trimmed,\n+                        true,\n+                        Shape::legacy(budget, shape.indent + 7),\n+                        context.config,\n+                    ))\n+                )\n+            } else {\n+                \"unsafe \".to_owned()\n             }\n         }\n+        ast::BlockCheckMode::Default => String::new(),\n+    })\n+}\n \n-        let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n-        visitor.block_indent = shape.indent;\n-        visitor.is_if_else_block = context.is_if_else_block;\n+fn rewrite_single_line_block(\n+    context: &RewriteContext,\n+    prefix: &str,\n+    block: &ast::Block,\n+    shape: Shape,\n+) -> Option<String> {\n+    if is_simple_block(block, context.codemap) {\n+        let expr_shape = Shape::legacy(shape.width - prefix.len(), shape.indent);\n+        let expr_str = try_opt!(block.stmts[0].rewrite(context, expr_shape));\n+        let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n+        if result.len() <= shape.width && !result.contains('\\n') {\n+            return Some(result);\n+        }\n+    }\n+    None\n+}\n \n-        let prefix = match self.rules {\n-            ast::BlockCheckMode::Unsafe(..) => {\n-                let snippet = context.snippet(self.span);\n-                let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n-                visitor.last_pos = self.span.lo + BytePos(open_pos as u32);\n+fn rewrite_block_with_visitor(\n+    context: &RewriteContext,\n+    prefix: &str,\n+    block: &ast::Block,\n+    shape: Shape,\n+) -> Option<String> {\n+    if let rw @ Some(_) = rewrite_empty_block(context, block, shape) {\n+        return rw;\n+    }\n \n-                // Extract comment between unsafe and block start.\n-                let trimmed = &snippet[6..open_pos].trim();\n+    let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n+    visitor.block_indent = shape.indent;\n+    visitor.is_if_else_block = context.is_if_else_block;\n+    match block.rules {\n+        ast::BlockCheckMode::Unsafe(..) => {\n+            let snippet = context.snippet(block.span);\n+            let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n+            visitor.last_pos = block.span.lo + BytePos(open_pos as u32)\n+        }\n+        ast::BlockCheckMode::Default => visitor.last_pos = block.span.lo,\n+    }\n \n-                let prefix = if !trimmed.is_empty() {\n-                    // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n-                    let budget = try_opt!(shape.width.checked_sub(9));\n-                    format!(\n-                        \"unsafe {} \",\n-                        try_opt!(rewrite_comment(\n-                            trimmed,\n-                            true,\n-                            Shape::legacy(budget, shape.indent + 7),\n-                            context.config,\n-                        ))\n-                    )\n-                } else {\n-                    \"unsafe \".to_owned()\n-                };\n-                if let result @ Some(_) = try_one_line_block(context, shape, &prefix, self) {\n-                    return result;\n-                }\n-                prefix\n-            }\n-            ast::BlockCheckMode::Default => {\n-                visitor.last_pos = self.span.lo;\n-                String::new()\n-            }\n-        };\n+    visitor.visit_block(block);\n+    if visitor.failed && shape.indent.alignment != 0 {\n+        block.rewrite(\n+            context,\n+            Shape::indented(shape.indent.block_only(), context.config),\n+        )\n+    } else {\n+        Some(format!(\"{}{}\", prefix, visitor.buffer))\n+    }\n+}\n \n-        visitor.visit_block(self);\n-        if visitor.failed && shape.indent.alignment != 0 {\n-            self.rewrite(\n-                context,\n-                Shape::indented(shape.indent.block_only(), context.config),\n-            )\n-        } else {\n-            Some(format!(\"{}{}\", prefix, visitor.buffer))\n+impl Rewrite for ast::Block {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        // shape.width is used only for the single line case: either the empty block `{}`,\n+        // or an unsafe expression `unsafe { e }`.\n+        if let rw @ Some(_) = rewrite_empty_block(context, self, shape) {\n+            return rw;\n         }\n+\n+        let prefix = try_opt!(block_prefix(context, self, shape));\n+        if let rw @ Some(_) = rewrite_single_line_block(context, &prefix, self, shape) {\n+            return rw;\n+        }\n+\n+        rewrite_block_with_visitor(context, &prefix, self, shape)\n     }\n }\n "}]}