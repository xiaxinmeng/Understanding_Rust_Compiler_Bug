{"sha": "7b377305985c0e9712cc48ccfd565ce3161f027d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMzc3MzA1OTg1YzBlOTcxMmNjNDhjY2ZkNTY1Y2UzMTYxZjAyN2Q=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-08T03:53:45Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-08T04:38:40Z"}, "message": "Make short flags with a single-char arg work in getopts\n\nThis looks like a big patch, but it's mostly just modernization.\nThe real change is in the fn called `getopts`, the line\n                       if arg_follows && j < curlen {\n\nMinor bugfix, no review.\n\nCloses #2822", "tree": {"sha": "b13dddfcc76222419332761770283bdaf6db598e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b13dddfcc76222419332761770283bdaf6db598e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b377305985c0e9712cc48ccfd565ce3161f027d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b377305985c0e9712cc48ccfd565ce3161f027d", "html_url": "https://github.com/rust-lang/rust/commit/7b377305985c0e9712cc48ccfd565ce3161f027d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b377305985c0e9712cc48ccfd565ce3161f027d/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98fdcb0b9d8b66a5feef1e45c06aeec93919d254", "url": "https://api.github.com/repos/rust-lang/rust/commits/98fdcb0b9d8b66a5feef1e45c06aeec93919d254", "html_url": "https://github.com/rust-lang/rust/commit/98fdcb0b9d8b66a5feef1e45c06aeec93919d254"}], "stats": {"total": 71, "additions": 37, "deletions": 34}, "files": [{"sha": "584fbc4b45b3370f268fa3e7e750d1ade7a8d773", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7b377305985c0e9712cc48ccfd565ce3161f027d/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b377305985c0e9712cc48ccfd565ce3161f027d/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=7b377305985c0e9712cc48ccfd565ce3161f027d", "patch": "@@ -21,7 +21,8 @@\n  * Single-character options are expected to appear on the command line with a\n  * single preceding dash; multiple-character options are expected to be\n  * proceeded by two dashes. Options that expect an argument accept their\n- * argument following either a space or an equals sign.\n+ * argument following either a space or an equals sign. Single-character\n+ * options don't require the space.\n  *\n  * # Example\n  *\n@@ -203,7 +204,7 @@ impl Matches : Eq {\n }\n \n fn is_arg(arg: &str) -> bool {\n-    return arg.len() > 1u && arg[0] == '-' as u8;\n+    return arg.len() > 1 && arg[0] == '-' as u8;\n }\n \n fn name_str(nm: &Name) -> ~str {\n@@ -293,38 +294,37 @@ pub type Result = result::Result<Matches, Fail_>;\n  * Use <fail_str> to get an error message.\n  */\n pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n-    let n_opts = vec::len::<Opt>(opts);\n+    let n_opts = opts.len();\n     fn f(_x: uint) -> ~[Optval] { return ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n     let mut free: ~[~str] = ~[];\n-    let l = vec::len(args);\n-    let mut i = 0u;\n+    let l = args.len();\n+    let mut i = 0;\n     while i < l {\n         let cur = args[i];\n         let curlen = cur.len();\n         if !is_arg(cur) {\n             free.push(cur);\n         } else if cur == ~\"--\" {\n-            let mut j = i + 1u;\n-            while j < l { free.push(args[j]); j += 1u; }\n+            let mut j = i + 1;\n+            while j < l { free.push(args[j]); j += 1; }\n             break;\n         } else {\n             let mut names;\n-            let mut i_arg = option::None::<~str>;\n+            let mut i_arg = None;\n             if cur[1] == '-' as u8 {\n-                let tail = str::slice(cur, 2u, curlen);\n-                let tail_eq = str::splitn_char(tail, '=', 1u);\n-                if vec::len(tail_eq) <= 1u {\n+                let tail = str::slice(cur, 2, curlen);\n+                let tail_eq = str::splitn_char(tail, '=', 1);\n+                if tail_eq.len() <= 1 {\n                     names = ~[Long(tail)];\n                 } else {\n                     names =\n                         ~[Long(tail_eq[0])];\n-                    i_arg =\n-                        option::Some::<~str>(tail_eq[1]);\n+                    i_arg = Some(tail_eq[1]);\n                 }\n             } else {\n-                let mut j = 1u;\n-                let mut last_valid_opt_id = option::None;\n+                let mut j = 1;\n+                let mut last_valid_opt_id = None;\n                 names = ~[];\n                 while j < curlen {\n                     let range = str::char_range_at(cur, j);\n@@ -338,7 +338,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                     */\n \n                     match find_opt(opts, opt) {\n-                      Some(id) => last_valid_opt_id = option::Some(id),\n+                      Some(id) => last_valid_opt_id = Some(id),\n                       None => {\n                         let arg_follows =\n                             last_valid_opt_id.is_some() &&\n@@ -348,21 +348,21 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                               Yes | Maybe => true,\n                               No => false\n                             };\n-                        if arg_follows && j + 1 < curlen {\n-                            i_arg = option::Some(str::slice(cur, j, curlen));\n+                        if arg_follows && j < curlen {\n+                            i_arg = Some(cur.slice(j, curlen));\n                             break;\n                         } else {\n-                            last_valid_opt_id = option::None;\n+                            last_valid_opt_id = None;\n                         }\n                       }\n                     }\n                     names.push(opt);\n                     j = range.next;\n                 }\n             }\n-            let mut name_pos = 0u;\n-            for vec::each(names) |nm| {\n-                name_pos += 1u;\n+            let mut name_pos = 0;\n+            for names.each() |nm| {\n+                name_pos += 1;\n                 let optid = match find_opt(opts, *nm) {\n                   Some(id) => id,\n                   None => return Err(UnrecognizedOption(name_str(nm)))\n@@ -377,38 +377,38 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                   Maybe => {\n                     if !i_arg.is_none() {\n                         vals[optid].push(Val(i_arg.get()));\n-                    } else if name_pos < vec::len::<Name>(names) ||\n-                                  i + 1u == l || is_arg(args[i + 1u]) {\n+                    } else if name_pos < names.len() ||\n+                                  i + 1 == l || is_arg(args[i + 1]) {\n                         vals[optid].push(Given);\n-                    } else { i += 1u; vals[optid].push(Val(args[i])); }\n+                    } else { i += 1; vals[optid].push(Val(args[i])); }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n                         vals[optid].push(Val(i_arg.get()));\n-                    } else if i + 1u == l {\n+                    } else if i + 1 == l {\n                         return Err(ArgumentMissing(name_str(nm)));\n-                    } else { i += 1u; vals[optid].push(Val(args[i])); }\n+                    } else { i += 1; vals[optid].push(Val(args[i])); }\n                   }\n                 }\n             }\n         }\n-        i += 1u;\n+        i += 1;\n     }\n     i = 0u;\n     while i < n_opts {\n-        let n = vec::len::<Optval>(vals[i]);\n+        let n = vals[i].len();\n         let occ = opts[i].occur;\n         if occ == Req {\n-            if n == 0u {\n+            if n == 0 {\n                 return Err(OptionMissing(name_str(&(opts[i].name))));\n             }\n         }\n         if occ != Multi {\n-            if n > 1u {\n+            if n > 1 {\n                 return Err(OptionDuplicated(name_str(&(opts[i].name))));\n             }\n         }\n-        i += 1u;\n+        i += 1;\n     }\n     return Ok({opts: vec::from_slice(opts),\n                vals: vec::from_mut(move vals),\n@@ -1275,14 +1275,17 @@ mod tests {\n \n     #[test]\n     fn test_nospace() {\n-        let args = ~[~\"-Lfoo\"];\n-        let opts = ~[optmulti(~\"L\")];\n+        let args = ~[~\"-Lfoo\", ~\"-M.\"];\n+        let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(move m) => m,\n           result::Err(_) => fail\n         };\n         assert opts_present(matches, ~[~\"L\"]);\n         assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";\n+        assert opts_present(matches, ~[~\"M\"]);\n+        assert opts_str(matches, ~[~\"M\"]) == ~\".\";\n+\n     }\n \n     #[test]"}]}