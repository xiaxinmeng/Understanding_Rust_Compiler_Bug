{"sha": "48e5866d11c6bdff9e1d55ad53c758e2fcdddcb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZTU4NjZkMTFjNmJkZmY5ZTFkNTVhZDUzYzc1OGUyZmNkZGRjYjE=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2021-01-29T01:43:59Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2021-02-12T20:14:17Z"}, "message": "Initialize BTree nodes directly in the heap", "tree": {"sha": "55c25f7acaf103c2114ac4e203fb81791a4227fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55c25f7acaf103c2114ac4e203fb81791a4227fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48e5866d11c6bdff9e1d55ad53c758e2fcdddcb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48e5866d11c6bdff9e1d55ad53c758e2fcdddcb1", "html_url": "https://github.com/rust-lang/rust/commit/48e5866d11c6bdff9e1d55ad53c758e2fcdddcb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48e5866d11c6bdff9e1d55ad53c758e2fcdddcb1/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d416093209d0dd77a4cdeb5a2f1b5de1316787ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/d416093209d0dd77a4cdeb5a2f1b5de1316787ec", "html_url": "https://github.com/rust-lang/rust/commit/d416093209d0dd77a4cdeb5a2f1b5de1316787ec"}], "stats": {"total": 48, "additions": 30, "deletions": 18}, "files": [{"sha": "c326a9bc775237740786e54784c6c42b50c03408", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/48e5866d11c6bdff9e1d55ad53c758e2fcdddcb1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e5866d11c6bdff9e1d55ad53c758e2fcdddcb1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=48e5866d11c6bdff9e1d55ad53c758e2fcdddcb1", "patch": "@@ -67,17 +67,24 @@ struct LeafNode<K, V> {\n }\n \n impl<K, V> LeafNode<K, V> {\n-    /// Creates a new `LeafNode`. Unsafe because all nodes should really be hidden behind\n+    /// Initializes a new `LeafNode` in-place.\n+    unsafe fn init(this: *mut Self) {\n+        // As a general policy, we leave fields uninitialized if they can be, as this should\n+        // be both slightly faster and easier to track in Valgrind.\n+        unsafe {\n+            // parent_idx, keys, and vals are all MaybeUninit\n+            (&raw mut (*this).parent).write(None);\n+            (&raw mut (*this).len).write(0);\n+        }\n+    }\n+\n+    /// Creates a new boxed `LeafNode`. Unsafe because all nodes should really be hidden behind\n     /// `BoxedNode`, preventing accidental dropping of uninitialized keys and values.\n-    unsafe fn new() -> Self {\n-        LeafNode {\n-            // As a general policy, we leave fields uninitialized if they can be, as this should\n-            // be both slightly faster and easier to track in Valgrind.\n-            keys: MaybeUninit::uninit_array(),\n-            vals: MaybeUninit::uninit_array(),\n-            parent: None,\n-            parent_idx: MaybeUninit::uninit(),\n-            len: 0,\n+    unsafe fn new() -> Box<Self> {\n+        unsafe {\n+            let mut leaf = Box::new_uninit();\n+            LeafNode::init(leaf.as_mut_ptr());\n+            leaf.assume_init()\n         }\n     }\n }\n@@ -99,15 +106,20 @@ struct InternalNode<K, V> {\n }\n \n impl<K, V> InternalNode<K, V> {\n-    /// Creates a new `InternalNode`.\n+    /// Creates a new boxed `InternalNode`.\n     ///\n-    /// This is unsafe for two reasons. First, it returns an `InternalNode` by value, risking\n+    /// This is unsafe for two reasons. First, it returns an owned `InternalNode` in a box, risking\n     /// dropping of uninitialized fields. Second, an invariant of internal nodes is that `len + 1`\n     /// edges are initialized and valid, meaning that even when the node is empty (having a\n     /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n     /// such an edge.\n-    unsafe fn new() -> Self {\n-        InternalNode { data: unsafe { LeafNode::new() }, edges: MaybeUninit::uninit_array() }\n+    unsafe fn new() -> Box<Self> {\n+        unsafe {\n+            let mut node = Box::<Self>::new_uninit();\n+            // We only need to initialize the data; the edges are MaybeUninit.\n+            LeafNode::init(&raw mut (*node.as_mut_ptr()).data);\n+            node.assume_init()\n+        }\n     }\n }\n \n@@ -133,7 +145,7 @@ impl<K, V> Root<K, V> {\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     fn new_leaf() -> Self {\n-        Self::from_new_leaf(Box::new(unsafe { LeafNode::new() }))\n+        Self::from_new_leaf(unsafe { LeafNode::new() })\n     }\n \n     fn from_new_leaf(leaf: Box<LeafNode<K, V>>) -> Self {\n@@ -143,7 +155,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     fn new_internal(child: Root<K, V>) -> Self {\n-        let mut new_node = Box::new(unsafe { InternalNode::new() });\n+        let mut new_node = unsafe { InternalNode::new() };\n         new_node.edges[0].write(child.node);\n         NodeRef::from_new_internal(new_node, child.height + 1)\n     }\n@@ -1075,7 +1087,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     ///   allocated node.\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Leaf> {\n         unsafe {\n-            let mut new_node = Box::new(LeafNode::new());\n+            let mut new_node = LeafNode::new();\n \n             let kv = self.split_leaf_data(&mut new_node);\n \n@@ -1110,7 +1122,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Internal> {\n         let old_len = self.node.len();\n         unsafe {\n-            let mut new_node = Box::new(InternalNode::new());\n+            let mut new_node = InternalNode::new();\n             let kv = self.split_leaf_data(&mut new_node.data);\n             let new_len = usize::from(new_node.data.len);\n             move_to_slice("}]}