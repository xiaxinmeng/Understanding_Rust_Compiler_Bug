{"sha": "0f1aaef7e9a1776a81819ef4ae05b508fb12d572", "node_id": "C_kwDOAAsO6NoAKDBmMWFhZWY3ZTlhMTc3NmE4MTgxOWVmNGFlMDViNTA4ZmIxMmQ1NzI", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-03T17:40:46Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-06T19:20:54Z"}, "message": "rustdoc: convert `if let Some()` that always matches to variable", "tree": {"sha": "3c8fb13157be92b70c5169df54789dd760fcce3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c8fb13157be92b70c5169df54789dd760fcce3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f1aaef7e9a1776a81819ef4ae05b508fb12d572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f1aaef7e9a1776a81819ef4ae05b508fb12d572", "html_url": "https://github.com/rust-lang/rust/commit/0f1aaef7e9a1776a81819ef4ae05b508fb12d572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f1aaef7e9a1776a81819ef4ae05b508fb12d572/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3572d7451d1062e8bccf310af6bbf6255091d296", "url": "https://api.github.com/repos/rust-lang/rust/commits/3572d7451d1062e8bccf310af6bbf6255091d296", "html_url": "https://github.com/rust-lang/rust/commit/3572d7451d1062e8bccf310af6bbf6255091d296"}], "stats": {"total": 46, "additions": 28, "deletions": 18}, "files": [{"sha": "22c8cc092438cdb264f5900f35b995dfc0131ff5", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0f1aaef7e9a1776a81819ef4ae05b508fb12d572/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1aaef7e9a1776a81819ef4ae05b508fb12d572/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0f1aaef7e9a1776a81819ef4ae05b508fb12d572", "patch": "@@ -14,7 +14,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use std::{iter, mem};\n+use std::mem;\n \n use crate::clean::{cfg::Cfg, reexport_chain, AttributesExt, NestedAttributesExt};\n use crate::core;\n@@ -291,27 +291,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         if !please_inline {\n             let inherits_hidden = inherits_doc_hidden(tcx, res_did, None);\n             // Only inline if requested or if the item would otherwise be stripped.\n-            //\n-            // If it's a doc hidden module, we need to keep it in case some of its inner items\n-            // are re-exported.\n             if (!is_private && !inherits_hidden) || (\n                 is_hidden &&\n+                // If it's a doc hidden module, we need to keep it in case some of its inner items\n+                // are re-exported.\n                 !matches!(item, Node::Item(&hir::Item { kind: hir::ItemKind::Mod(_), .. }))\n-            ) {\n-                return false;\n-            } else if let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n-                .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n-                .chain(iter::once(res_did)).nth(1) &&\n-                item_def_id != def_id &&\n-                self\n-                    .cx\n-                    .cache\n-                    .effective_visibilities\n-                    .is_directly_public(tcx, item_def_id.to_def_id()) &&\n-                !tcx.is_doc_hidden(item_def_id) &&\n-                !inherits_doc_hidden(tcx, item_def_id, None)\n-            {\n+            ) ||\n                 // The imported item is public and not `doc(hidden)` so no need to inline it.\n+                self.reexport_public_and_not_hidden(def_id, res_did)\n+            {\n                 return false;\n             }\n         }\n@@ -359,6 +347,28 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n+    /// Returns `true` if the item is visible, meaning it's not `#[doc(hidden)]` or private.\n+    ///\n+    /// This function takes into account the entire re-export `use` chain, so it needs the\n+    /// ID of the \"leaf\" `use` and the ID of the \"root\" item.\n+    fn reexport_public_and_not_hidden(\n+        &self,\n+        import_def_id: LocalDefId,\n+        target_def_id: LocalDefId,\n+    ) -> bool {\n+        let tcx = self.cx.tcx;\n+        let item_def_id = reexport_chain(tcx, import_def_id, target_def_id)\n+            .iter()\n+            .flat_map(|reexport| reexport.id())\n+            .map(|id| id.expect_local())\n+            .nth(1)\n+            .unwrap_or(target_def_id);\n+        item_def_id != import_def_id\n+            && self.cx.cache.effective_visibilities.is_directly_public(tcx, item_def_id.to_def_id())\n+            && !tcx.is_doc_hidden(item_def_id)\n+            && !inherits_doc_hidden(tcx, item_def_id, None)\n+    }\n+\n     #[inline]\n     fn add_to_current_mod(\n         &mut self,"}]}