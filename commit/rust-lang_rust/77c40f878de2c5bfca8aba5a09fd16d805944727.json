{"sha": "77c40f878de2c5bfca8aba5a09fd16d805944727", "node_id": "C_kwDOAAsO6NoAKDc3YzQwZjg3OGRlMmM1YmZjYThhYmE1YTA5ZmQxNmQ4MDU5NDQ3Mjc", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-09-06T08:48:06Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-09-12T17:42:52Z"}, "message": "Implement type inference for generator and yield expressions", "tree": {"sha": "63dc4b1dc31ab0855f4924464473c6384713fc1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63dc4b1dc31ab0855f4924464473c6384713fc1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77c40f878de2c5bfca8aba5a09fd16d805944727", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmMfb5wACgkQ4laYqTBY\nYXGE0Q/8C26XL0VZs54/290hLTO2CH6H3kcX52pUx5dLNrq3l+U9TOV/VKTMiCQP\nmqK7T1auUuuoUNCahWFkkfTn/oUW+uFTOZdUDW7O/qqlLvkrSnKafk8rGJGs0GSf\nAE65pvhqcVIMKaebzy2y2TvaRhmpidgiMtUrQqxX7OdyG2Ez6HZWRtDuDqeM8ZyL\nExk/V09mB0SSd6caryzfi2sx/V7RMdT0CGKbWaosES8MsGCr8hOpNEWPboZS74NB\ne79Me5SYWYL2SUCnFhTxsOWwCtnpm882rNaWI6ITZkCrTFYf8SrWRr2Ps+tSKFoP\n8goAdLaT697r7BJ8azAoPdMt2rfDccyYXq46mcg5qwpYSePqw2QvrZhgEMye1oy1\nMGAHJbLeWpW0BEfZ+VKu2hoYu33qCuO+ToqFNly3SpLbwt/u95EMh8mxWnjZ0+Pb\n375xfqVe3ZJprRyrfzLz9VMEJm9mC1hLepbg363vXpJSHIPqLjvSLCa+epOeFVj1\nJ5rB664D5zoT9d0aFzU6gX99uHjJ7j3xBYjBdW7ZU52uMeZpnTqD+FvZssXImIyK\n2TdKzFuflhmzpn5j2k7LU5+FreGxCTjRmtksYeZeBPYNZw8cJ5nyvJZMx8AZNn+H\nm5cGrT4zMQXyAv03D0I8Fuu/sSaM9H4S2xhgeKjsW4anZ0E4OEE=\n=woJF\n-----END PGP SIGNATURE-----", "payload": "tree 63dc4b1dc31ab0855f4924464473c6384713fc1d\nparent aeeb9e08b252b24c7cdba0a30e8dd153231c082d\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1662454086 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1663004572 +0900\n\nImplement type inference for generator and yield expressions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77c40f878de2c5bfca8aba5a09fd16d805944727", "html_url": "https://github.com/rust-lang/rust/commit/77c40f878de2c5bfca8aba5a09fd16d805944727", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77c40f878de2c5bfca8aba5a09fd16d805944727/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeeb9e08b252b24c7cdba0a30e8dd153231c082d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeeb9e08b252b24c7cdba0a30e8dd153231c082d", "html_url": "https://github.com/rust-lang/rust/commit/aeeb9e08b252b24c7cdba0a30e8dd153231c082d"}], "stats": {"total": 96, "additions": 78, "deletions": 18}, "files": [{"sha": "c4f7685cd140a30609f889104b52fd3af24812dc", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=77c40f878de2c5bfca8aba5a09fd16d805944727", "patch": "@@ -116,6 +116,8 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn intern_impl_trait_id(&self, id: ImplTraitId) -> InternedOpaqueTyId;\n     #[salsa::interned]\n     fn intern_closure(&self, id: (DefWithBodyId, ExprId)) -> InternedClosureId;\n+    #[salsa::interned]\n+    fn intern_generator(&self, id: (DefWithBodyId, ExprId)) -> InternedGeneratorId;\n \n     #[salsa::invoke(chalk_db::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_db::AssocTypeId) -> Arc<chalk_db::AssociatedTyDatum>;\n@@ -218,6 +220,10 @@ impl_intern_key!(InternedOpaqueTyId);\n pub struct InternedClosureId(salsa::InternId);\n impl_intern_key!(InternedClosureId);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct InternedGeneratorId(salsa::InternId);\n+impl_intern_key!(InternedGeneratorId);\n+\n /// This exists just for Chalk, because Chalk just has a single `FnDefId` where\n /// we have different IDs for struct and enum variant constructors.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]"}, {"sha": "d351eb599ce468930af9187e335a29db79008f43", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=77c40f878de2c5bfca8aba5a09fd16d805944727", "patch": "@@ -332,7 +332,7 @@ pub struct InferenceResult {\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n-    /// Interned Unknown to return references to.\n+    /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n     /// Stores the types which were implicitly dereferenced in pattern binding modes.\n     pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n@@ -412,6 +412,8 @@ pub(crate) struct InferenceContext<'a> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n+    /// The resume type and the yield type, respectively, of the generator being inferred.\n+    resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n     breakables: Vec<BreakableContext>,\n }\n@@ -476,6 +478,7 @@ impl<'a> InferenceContext<'a> {\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n             trait_env,\n             return_ty: TyKind::Error.intern(Interner), // set in collect_fn_signature\n+            resume_yield_tys: None,\n             db,\n             owner,\n             body,"}, {"sha": "094e460dbf79b0b08b35f2911c0bf83d78d8faca", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=77c40f878de2c5bfca8aba5a09fd16d805944727", "patch": "@@ -12,6 +12,7 @@ use crate::{\n use super::{Expectation, InferenceContext};\n \n impl InferenceContext<'_> {\n+    // This function handles both closures and generators.\n     pub(super) fn deduce_closure_type_from_expectations(\n         &mut self,\n         closure_expr: ExprId,\n@@ -27,6 +28,11 @@ impl InferenceContext<'_> {\n         // Deduction from where-clauses in scope, as well as fn-pointer coercion are handled here.\n         let _ = self.coerce(Some(closure_expr), closure_ty, &expected_ty);\n \n+        // Generators are not Fn* so return early.\n+        if matches!(closure_ty.kind(Interner), TyKind::Generator(..)) {\n+            return;\n+        }\n+\n         // Deduction based on the expected `dyn Fn` is done separately.\n         if let TyKind::Dyn(dyn_ty) = expected_ty.kind(Interner) {\n             if let Some(sig) = self.deduce_sig_from_dyn_ty(dyn_ty) {"}, {"sha": "e3d6be23e6586e33f1895ad81e650430552e4d53", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=77c40f878de2c5bfca8aba5a09fd16d805944727", "patch": "@@ -10,7 +10,10 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, LabelId, Literal, Statement, UnaryOp},\n+    expr::{\n+        ArithOp, Array, BinaryOp, ClosureKind, CmpOp, Expr, ExprId, LabelId, Literal, Statement,\n+        UnaryOp,\n+    },\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n@@ -216,7 +219,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::Closure { body, args, ret_type, arg_types, closure_kind: _ } => {\n+            Expr::Closure { body, args, ret_type, arg_types, closure_kind } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n                 let mut sig_tys = Vec::new();\n@@ -244,20 +247,40 @@ impl<'a> InferenceContext<'a> {\n                     ),\n                 })\n                 .intern(Interner);\n-                let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n-                let closure_ty =\n-                    TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n-                        .intern(Interner);\n+\n+                let (ty, resume_yield_tys) = if matches!(closure_kind, ClosureKind::Generator(_)) {\n+                    // FIXME: report error when there are more than 1 parameter.\n+                    let resume_ty = match sig_tys.first() {\n+                        // When `sig_tys.len() == 1` the first type is the return type, not the\n+                        // first parameter type.\n+                        Some(ty) if sig_tys.len() > 1 => ty.clone(),\n+                        _ => self.result.standard_types.unit.clone(),\n+                    };\n+                    let yield_ty = self.table.new_type_var();\n+\n+                    let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n+                        .push(resume_ty.clone())\n+                        .push(yield_ty.clone())\n+                        .push(ret_ty.clone())\n+                        .build();\n+\n+                    let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n+                    let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n+\n+                    (generator_ty, Some((resume_ty, yield_ty)))\n+                } else {\n+                    let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n+                    let closure_ty =\n+                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n+                            .intern(Interner);\n+\n+                    (closure_ty, None)\n+                };\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                self.deduce_closure_type_from_expectations(\n-                    tgt_expr,\n-                    &closure_ty,\n-                    &sig_ty,\n-                    expected,\n-                );\n+                self.deduce_closure_type_from_expectations(tgt_expr, &ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n@@ -266,15 +289,18 @@ impl<'a> InferenceContext<'a> {\n \n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_resume_yield_tys =\n+                    mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n                 self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n                     this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n                 });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.resume_yield_tys = prev_resume_yield_tys;\n \n-                closure_ty\n+                ty\n             }\n             Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n@@ -423,11 +449,18 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Never.intern(Interner)\n             }\n             Expr::Yield { expr } => {\n-                // FIXME: track yield type for coercion\n-                if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::none());\n+                if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n+                    if let Some(expr) = expr {\n+                        self.infer_expr_coerce(*expr, &Expectation::has_type(yield_ty));\n+                    } else {\n+                        let unit = self.result.standard_types.unit.clone();\n+                        let _ = self.coerce(Some(tgt_expr), &unit, &yield_ty);\n+                    }\n+                    resume_ty\n+                } else {\n+                    // FIXME: report error (yield expr in non-generator)\n+                    TyKind::Error.intern(Interner)\n                 }\n-                TyKind::Never.intern(Interner)\n             }\n             Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);"}, {"sha": "f80fb39c1f84e24854bfecbe3fd06a06786f86b2", "filename": "crates/hir-ty/src/mapping.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c40f878de2c5bfca8aba5a09fd16d805944727/crates%2Fhir-ty%2Fsrc%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmapping.rs?ref=77c40f878de2c5bfca8aba5a09fd16d805944727", "patch": "@@ -103,6 +103,18 @@ impl From<crate::db::InternedClosureId> for chalk_ir::ClosureId<Interner> {\n     }\n }\n \n+impl From<chalk_ir::GeneratorId<Interner>> for crate::db::InternedGeneratorId {\n+    fn from(id: chalk_ir::GeneratorId<Interner>) -> Self {\n+        Self::from_intern_id(id.0)\n+    }\n+}\n+\n+impl From<crate::db::InternedGeneratorId> for chalk_ir::GeneratorId<Interner> {\n+    fn from(id: crate::db::InternedGeneratorId) -> Self {\n+        chalk_ir::GeneratorId(id.as_intern_id())\n+    }\n+}\n+\n pub fn to_foreign_def_id(id: TypeAliasId) -> ForeignDefId {\n     chalk_ir::ForeignDefId(salsa::InternKey::as_intern_id(&id))\n }"}]}