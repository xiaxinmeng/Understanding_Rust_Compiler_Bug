{"sha": "154be2c98cf348de080ce951df3f73649e8bb1a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NGJlMmM5OGNmMzQ4ZGUwODBjZTk1MWRmM2Y3MzY0OWU4YmIxYTY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-18T04:21:41Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-18T06:41:27Z"}, "message": "Use `HybridBitSet` for rows within `SparseBitMatrix`.\n\nThis requires adding a few extra methods to `HybridBitSet`. (These are\ntested in a new unit test.)\n\nThis commit reduces the `max-rss` for `nll-check` builds of `html5ever`\nby 46%, `ucd` by 45%, `clap-rs` by 23%, `inflate` by 14%. And the\nresults for the `unic-ucd-name` crate are even more impressive: a 21%\nreduction in instructions, a 60% reduction in wall-time, a 96%\nreduction in `max-rss`, and a 97% reduction in faults!\n\nFixes #52028.", "tree": {"sha": "cce7968ee76b89da3371ec8fe07e47348b5507be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cce7968ee76b89da3371ec8fe07e47348b5507be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154be2c98cf348de080ce951df3f73649e8bb1a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154be2c98cf348de080ce951df3f73649e8bb1a6", "html_url": "https://github.com/rust-lang/rust/commit/154be2c98cf348de080ce951df3f73649e8bb1a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154be2c98cf348de080ce951df3f73649e8bb1a6/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "687cc292fd681be9739dc973acd5eaa5f73a5ce7", "url": "https://api.github.com/repos/rust-lang/rust/commits/687cc292fd681be9739dc973acd5eaa5f73a5ce7", "html_url": "https://github.com/rust-lang/rust/commit/687cc292fd681be9739dc973acd5eaa5f73a5ce7"}], "stats": {"total": 215, "additions": 179, "deletions": 36}, "files": [{"sha": "9eb8d0afd46ecf9d7e00e06b5d259928d50eed93", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 167, "deletions": 24, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/154be2c98cf348de080ce951df3f73649e8bb1a6/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154be2c98cf348de080ce951df3f73649e8bb1a6/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=154be2c98cf348de080ce951df3f73649e8bb1a6", "patch": "@@ -337,6 +337,10 @@ impl<T: Idx> SparseBitSet<T> {\n         self.0.len()\n     }\n \n+    fn is_empty(&self) -> bool {\n+        self.0.len() == 0\n+    }\n+\n     fn contains(&self, elem: T) -> bool {\n         self.0.contains(&elem)\n     }\n@@ -417,15 +421,28 @@ pub enum HybridBitSet<T: Idx> {\n }\n \n impl<T: Idx> HybridBitSet<T> {\n+    // FIXME: This function is used in conjunction with `mem::replace()` in\n+    // several pieces of awful code below. I can't work out how else to appease\n+    // the borrow checker.\n+    fn dummy() -> Self {\n+        // The cheapest HybridBitSet to construct, which is only used to get\n+        // around the borrow checker.\n+        HybridBitSet::Sparse(SparseBitSet::new_empty(), 0)\n+    }\n+\n     pub fn new_empty(domain_size: usize) -> Self {\n         HybridBitSet::Sparse(SparseBitSet::new_empty(), domain_size)\n     }\n \n-    pub fn clear(&mut self) {\n-        let domain_size = match *self {\n+    pub fn domain_size(&self) -> usize {\n+        match *self {\n             HybridBitSet::Sparse(_, size) => size,\n             HybridBitSet::Dense(_, size) => size,\n-        };\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        let domain_size = self.domain_size();\n         *self = HybridBitSet::new_empty(domain_size);\n     }\n \n@@ -436,6 +453,22 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n+    pub fn superset(&self, other: &HybridBitSet<T>) -> bool {\n+        match (self, other) {\n+            (HybridBitSet::Dense(self_dense, _), HybridBitSet::Dense(other_dense, _)) => {\n+                self_dense.superset(other_dense)\n+            }\n+            _ => other.iter().all(|elem| self.contains(elem)),\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(sparse, _) => sparse.is_empty(),\n+            HybridBitSet::Dense(dense, _) => dense.is_empty(),\n+        }\n+    }\n+\n     pub fn insert(&mut self, elem: T) -> bool {\n         match self {\n             HybridBitSet::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n@@ -449,26 +482,33 @@ impl<T: Idx> HybridBitSet<T> {\n             }\n             HybridBitSet::Sparse(_, _) => {\n                 // The set is sparse and full. Convert to a dense set.\n-                //\n-                // FIXME: This code is awful, but I can't work out how else to\n-                //        appease the borrow checker.\n-                let dummy = HybridBitSet::Sparse(SparseBitSet::new_empty(), 0);\n-                match mem::replace(self, dummy) {\n+                match mem::replace(self, HybridBitSet::dummy()) {\n                     HybridBitSet::Sparse(sparse, domain_size) => {\n                         let mut dense = sparse.to_dense(domain_size);\n                         let changed = dense.insert(elem);\n                         assert!(changed);\n-                        mem::replace(self, HybridBitSet::Dense(dense, domain_size));\n+                        *self = HybridBitSet::Dense(dense, domain_size);\n                         changed\n                     }\n-                    _ => panic!(\"impossible\"),\n+                    _ => unreachable!()\n                 }\n             }\n \n             HybridBitSet::Dense(dense, _) => dense.insert(elem),\n         }\n     }\n \n+    pub fn insert_all(&mut self) {\n+        let domain_size = self.domain_size();\n+        match self {\n+            HybridBitSet::Sparse(_, _) => {\n+                let dense = BitSet::new_filled(domain_size);\n+                *self = HybridBitSet::Dense(dense, domain_size);\n+            }\n+            HybridBitSet::Dense(dense, _) => dense.insert_all(),\n+        }\n+    }\n+\n     pub fn remove(&mut self, elem: T) -> bool {\n         // Note: we currently don't bother going from Dense back to Sparse.\n         match self {\n@@ -477,6 +517,42 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n+    pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(_, _) => {\n+                match other {\n+                    HybridBitSet::Sparse(other_sparse, _) => {\n+                        // Both sets are sparse. Add the elements in\n+                        // `other_sparse` to `self_hybrid` one at a time. This\n+                        // may or may not cause `self_hybrid` to be densified.\n+                        let mut self_hybrid = mem::replace(self, HybridBitSet::dummy());\n+                        let mut changed = false;\n+                        for elem in other_sparse.iter() {\n+                            changed |= self_hybrid.insert(*elem);\n+                        }\n+                        *self = self_hybrid;\n+                        changed\n+                    }\n+                    HybridBitSet::Dense(other_dense, _) => {\n+                        // `self` is sparse and `other` is dense. Densify\n+                        // `self` and then do the bitwise union.\n+                        match mem::replace(self, HybridBitSet::dummy()) {\n+                            HybridBitSet::Sparse(self_sparse, self_domain_size) => {\n+                                let mut new_dense = self_sparse.to_dense(self_domain_size);\n+                                let changed = new_dense.union(other_dense);\n+                                *self = HybridBitSet::Dense(new_dense, self_domain_size);\n+                                changed\n+                            }\n+                            _ => unreachable!()\n+                        }\n+                    }\n+                }\n+            }\n+\n+            HybridBitSet::Dense(self_dense, _) => self_dense.union(other),\n+        }\n+    }\n+\n     /// Converts to a dense set, consuming itself in the process.\n     pub fn to_dense(self) -> BitSet<T> {\n         match self {\n@@ -687,11 +763,10 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n /// sparse representation.\n ///\n /// Initially, every row has no explicit representation. If any bit within a\n-/// row is set, the entire row is instantiated as\n-/// `Some(<full-column-width-BitSet>)`. Furthermore, any previously\n-/// uninstantiated rows prior to it will be instantiated as `None`. Those prior\n-/// rows may themselves become fully instantiated later on if any of their bits\n-/// are set.\n+/// row is set, the entire row is instantiated as `Some(<HybridBitSet>)`.\n+/// Furthermore, any previously uninstantiated rows prior to it will be\n+/// instantiated as `None`. Those prior rows may themselves become fully\n+/// instantiated later on if any of their bits are set.\n ///\n /// `R` and `C` are index types used to identify rows and columns respectively;\n /// typically newtyped `usize` wrappers, but they can also just be `usize`.\n@@ -702,7 +777,7 @@ where\n     C: Idx,\n {\n     num_columns: usize,\n-    rows: IndexVec<R, Option<BitSet<C>>>,\n+    rows: IndexVec<R, Option<HybridBitSet<C>>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n@@ -714,14 +789,14 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    fn ensure_row(&mut self, row: R) -> &mut BitSet<C> {\n+    fn ensure_row(&mut self, row: R) -> &mut HybridBitSet<C> {\n         // Instantiate any missing rows up to and including row `row` with an\n-        // empty BitSet.\n+        // empty HybridBitSet.\n         self.rows.ensure_contains_elem(row, || None);\n \n-        // Then replace row `row` with a full BitSet if necessary.\n+        // Then replace row `row` with a full HybridBitSet if necessary.\n         let num_columns = self.num_columns;\n-        self.rows[row].get_or_insert_with(|| BitSet::new_empty(num_columns))\n+        self.rows[row].get_or_insert_with(|| HybridBitSet::new_empty(num_columns))\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n@@ -760,8 +835,8 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    /// Merge a row, `from`, into the `into` row.\n-    pub fn union_into_row(&mut self, into: R, from: &BitSet<C>) -> bool {\n+    /// Union a row, `from`, into the `into` row.\n+    pub fn union_into_row(&mut self, into: R, from: &HybridBitSet<C>) -> bool {\n         self.ensure_row(into).union(from)\n     }\n \n@@ -780,7 +855,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         self.row(row).into_iter().flat_map(|r| r.iter())\n     }\n \n-    pub fn row(&self, row: R) -> Option<&BitSet<C>> {\n+    pub fn row(&self, row: R) -> Option<&HybridBitSet<C>> {\n         if let Some(Some(row)) = self.rows.get(row) {\n             Some(row)\n         } else {\n@@ -871,7 +946,7 @@ fn bitset_iter_works_2() {\n }\n \n #[test]\n-fn union_two_vecs() {\n+fn union_two_sets() {\n     let mut set1: BitSet<usize> = BitSet::new_empty(65);\n     let mut set2: BitSet<usize> = BitSet::new_empty(65);\n     assert!(set1.insert(3));\n@@ -887,6 +962,74 @@ fn union_two_vecs() {\n     assert!(set1.contains(64));\n }\n \n+#[test]\n+fn hybrid_bitset() {\n+    let mut sparse038: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    assert!(sparse038.is_empty());\n+    assert!(sparse038.insert(0));\n+    assert!(sparse038.insert(1));\n+    assert!(sparse038.insert(8));\n+    assert!(sparse038.insert(3));\n+    assert!(!sparse038.insert(3));\n+    assert!(sparse038.remove(1));\n+    assert!(!sparse038.is_empty());\n+    assert_eq!(sparse038.iter().collect::<Vec<_>>(), [0, 3, 8]);\n+\n+    for i in 0..256 {\n+        if i == 0 || i == 3 || i == 8 {\n+            assert!(sparse038.contains(i));\n+        } else {\n+            assert!(!sparse038.contains(i));\n+        }\n+    }\n+\n+    let mut sparse01358 = sparse038.clone();\n+    assert!(sparse01358.insert(1));\n+    assert!(sparse01358.insert(5));\n+    assert_eq!(sparse01358.iter().collect::<Vec<_>>(), [0, 1, 3, 5, 8]);\n+\n+    let mut dense10 = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(dense10.insert(i));\n+    }\n+    assert!(!dense10.is_empty());\n+    assert_eq!(dense10.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut dense256 = HybridBitSet::new_empty(256);\n+    assert!(dense256.is_empty());\n+    dense256.insert_all();\n+    assert!(!dense256.is_empty());\n+    for i in 0..256 {\n+        assert!(dense256.contains(i));\n+    }\n+\n+    assert!(sparse038.superset(&sparse038));    // sparse + sparse (self)\n+    assert!(sparse01358.superset(&sparse038));  // sparse + sparse\n+    assert!(dense10.superset(&sparse038));      // dense + sparse\n+    assert!(dense10.superset(&dense10));        // dense + dense (self)\n+    assert!(dense256.superset(&dense10));       // dense + dense\n+\n+    let mut hybrid = sparse038;\n+    assert!(!sparse01358.union(&hybrid));       // no change\n+    assert!(hybrid.union(&sparse01358));\n+    assert!(hybrid.superset(&sparse01358) && sparse01358.superset(&hybrid));\n+    assert!(!dense10.union(&sparse01358));\n+    assert!(!dense256.union(&dense10));\n+    let mut dense = dense10;\n+    assert!(dense.union(&dense256));\n+    assert!(dense.superset(&dense256) && dense256.superset(&dense));\n+    assert!(hybrid.union(&dense256));\n+    assert!(hybrid.superset(&dense256) && dense256.superset(&hybrid));\n+\n+    assert_eq!(dense256.iter().count(), 256);\n+    let mut dense0 = dense256;\n+    for i in 0..256 {\n+        assert!(dense0.remove(i));\n+    }\n+    assert!(!dense0.remove(0));\n+    assert!(dense0.is_empty());\n+}\n+\n #[test]\n fn grow() {\n     let mut set: GrowableBitSet<usize> = GrowableBitSet::with_capacity(65);"}, {"sha": "8dc41a9b2d32d13df61fc6af0403527c6b51a8d9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154be2c98cf348de080ce951df3f73649e8bb1a6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154be2c98cf348de080ce951df3f73649e8bb1a6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=154be2c98cf348de080ce951df3f73649e8bb1a6", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::{self, RegionVid};\n-use rustc_data_structures::bit_set::{BitSet, SparseBitMatrix};\n+use rustc_data_structures::bit_set::{HybridBitSet, SparseBitMatrix};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -184,7 +184,7 @@ impl<N: Idx> LivenessValues<N> {\n \n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns true if any of them are newly added.\n-    crate fn add_elements(&mut self, row: N, locations: &BitSet<PointIndex>) -> bool {\n+    crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n         self.points.union_into_row(row, locations)\n     }"}, {"sha": "47e6ce05cec1ff9cdc9485ba0d8d8796300b0ee7", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/154be2c98cf348de080ce951df3f73649e8bb1a6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154be2c98cf348de080ce951df3f73649e8bb1a6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=154be2c98cf348de080ce951df3f73649e8bb1a6", "patch": "@@ -22,7 +22,7 @@ use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n-use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::bit_set::HybridBitSet;\n use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n use util::liveness::LiveVariableMap;\n@@ -121,16 +121,16 @@ where\n     cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>,\n \n     /// Set of points that define the current local.\n-    defs: BitSet<PointIndex>,\n+    defs: HybridBitSet<PointIndex>,\n \n     /// Points where the current variable is \"use live\" -- meaning\n     /// that there is a future \"full use\" that may use its value.\n-    use_live_at: BitSet<PointIndex>,\n+    use_live_at: HybridBitSet<PointIndex>,\n \n     /// Points where the current variable is \"drop live\" -- meaning\n     /// that there is no future \"full use\" that may use its value, but\n     /// there is a future drop.\n-    drop_live_at: BitSet<PointIndex>,\n+    drop_live_at: HybridBitSet<PointIndex>,\n \n     /// Locations where drops may occur.\n     drop_locations: Vec<Location>,\n@@ -144,9 +144,9 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n         let num_points = cx.elements.num_points();\n         LivenessResults {\n             cx,\n-            defs: BitSet::new_empty(num_points),\n-            use_live_at: BitSet::new_empty(num_points),\n-            drop_live_at: BitSet::new_empty(num_points),\n+            defs: HybridBitSet::new_empty(num_points),\n+            use_live_at: HybridBitSet::new_empty(num_points),\n+            drop_live_at: HybridBitSet::new_empty(num_points),\n             drop_locations: vec![],\n             stack: vec![],\n         }\n@@ -448,7 +448,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n     fn add_use_live_facts_for(\n         &mut self,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &BitSet<PointIndex>,\n+        live_at: &HybridBitSet<PointIndex>,\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n@@ -465,7 +465,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         dropped_local: Local,\n         dropped_ty: Ty<'tcx>,\n         drop_locations: &[Location],\n-        live_at: &BitSet<PointIndex>,\n+        live_at: &HybridBitSet<PointIndex>,\n     ) {\n         debug!(\n             \"add_drop_live_constraint(\\\n@@ -508,7 +508,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         elements: &RegionValueElements,\n         typeck: &mut TypeChecker<'_, '_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &BitSet<PointIndex>,\n+        live_at: &HybridBitSet<PointIndex>,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);\n         debug!("}]}