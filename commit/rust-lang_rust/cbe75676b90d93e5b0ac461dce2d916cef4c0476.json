{"sha": "cbe75676b90d93e5b0ac461dce2d916cef4c0476", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZTc1Njc2YjkwZDkzZTViMGFjNDYxZGNlMmQ5MTZjZWY0YzA0NzY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-11T14:49:55Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-11T14:56:36Z"}, "message": "Add support for inline bounds\n\nE.g. impl<T: Clone> Foo for T.", "tree": {"sha": "50999df2191aa13204ca05f255ebe2b2105a1832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50999df2191aa13204ca05f255ebe2b2105a1832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbe75676b90d93e5b0ac461dce2d916cef4c0476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe75676b90d93e5b0ac461dce2d916cef4c0476", "html_url": "https://github.com/rust-lang/rust/commit/cbe75676b90d93e5b0ac461dce2d916cef4c0476", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbe75676b90d93e5b0ac461dce2d916cef4c0476/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6dc75f9f22b73faf8c526be69ca43e52d6db1bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6dc75f9f22b73faf8c526be69ca43e52d6db1bf", "html_url": "https://github.com/rust-lang/rust/commit/d6dc75f9f22b73faf8c526be69ca43e52d6db1bf"}], "stats": {"total": 76, "additions": 60, "deletions": 16}, "files": [{"sha": "c29b96f508adf8576b7a1659a77283a6233f02d5", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cbe75676b90d93e5b0ac461dce2d916cef4c0476/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe75676b90d93e5b0ac461dce2d916cef4c0476/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=cbe75676b90d93e5b0ac461dce2d916cef4c0476", "patch": "@@ -90,8 +90,17 @@ impl GenericParams {\n     fn fill_params(&mut self, params: &ast::TypeParamList, start: u32) {\n         for (idx, type_param) in params.type_params().enumerate() {\n             let name = type_param.name().map(AsName::as_name).unwrap_or_else(Name::missing);\n-            let param = GenericParam { idx: idx as u32 + start, name };\n+            let param = GenericParam { idx: idx as u32 + start, name: name.clone() };\n             self.params.push(param);\n+\n+            let type_ref = TypeRef::Path(name.into());\n+            for bound in type_param\n+                .type_bound_list()\n+                .iter()\n+                .flat_map(|type_bound_list| type_bound_list.bounds())\n+            {\n+                self.add_where_predicate_from_bound(bound, type_ref.clone());\n+            }\n         }\n     }\n \n@@ -101,26 +110,28 @@ impl GenericParams {\n                 Some(type_ref) => type_ref,\n                 None => continue,\n             };\n+            let type_ref = TypeRef::from_ast(type_ref);\n             for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n-                let path = bound\n-                    .type_ref()\n-                    .and_then(|tr| match tr.kind() {\n-                        ast::TypeRefKind::PathType(path) => path.path(),\n-                        _ => None,\n-                    })\n-                    .and_then(Path::from_ast);\n-                let path = match path {\n-                    Some(p) => p,\n-                    None => continue,\n-                };\n-                self.where_predicates.push(WherePredicate {\n-                    type_ref: TypeRef::from_ast(type_ref),\n-                    trait_ref: path,\n-                });\n+                self.add_where_predicate_from_bound(bound, type_ref.clone());\n             }\n         }\n     }\n \n+    fn add_where_predicate_from_bound(&mut self, bound: &ast::TypeBound, type_ref: TypeRef) {\n+        let path = bound\n+            .type_ref()\n+            .and_then(|tr| match tr.kind() {\n+                ast::TypeRefKind::PathType(path) => path.path(),\n+                _ => None,\n+            })\n+            .and_then(Path::from_ast);\n+        let path = match path {\n+            Some(p) => p,\n+            None => return,\n+        };\n+        self.where_predicates.push(WherePredicate { type_ref, trait_ref: path });\n+    }\n+\n     pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n         self.params.iter().find(|p| &p.name == name)\n     }"}, {"sha": "59c85daed7e43e9dfb50cb99e9549449be31ec28", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cbe75676b90d93e5b0ac461dce2d916cef4c0476/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe75676b90d93e5b0ac461dce2d916cef4c0476/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=cbe75676b90d93e5b0ac461dce2d916cef4c0476", "patch": "@@ -2535,6 +2535,22 @@ fn test() { (&S).foo()<|>; }\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+fn method_resolution_where_clause_inline_not_met() {\n+    // The blanket impl shouldn't apply because we can't prove S: Clone\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T: Clone> Trait for T {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n #[test]\n fn method_resolution_where_clause_1() {\n     let t = type_at(\n@@ -2568,6 +2584,23 @@ fn test() { S2.into()<|>; }\n     assert_eq!(t, \"S1\");\n }\n \n+#[test]\n+fn method_resolution_where_clause_inline() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Into<T> { fn into(self) -> T; }\n+trait From<T> { fn from(other: T) -> Self; }\n+struct S1;\n+struct S2;\n+impl From<S2> for S1 {};\n+impl<T, U: From<T>> Into<U> for T {}\n+fn test() { S2.into()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"S1\");\n+}\n+\n #[test]\n fn method_resolution_encountering_fn_type() {\n     covers!(trait_resolution_on_fn_type);"}]}