{"sha": "c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YzFmY2I4ZTkwMmFkY2M3ODc5OTk2ZmE3ZjUzMjAwZmIzNmNlMzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-10T21:28:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-10T21:28:14Z"}, "message": "Merge #9206\n\n9206: minor: Speed up fst items lookup during completions r=SomeoneToIgnore a=SomeoneToIgnore\n\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/7542\r\n\r\nA number of profile calls added for `import_on_the_fly` contents.\r\nBefore:\r\n<img width=\"606\" alt=\"Screenshot 2021-06-11 at 00 19 13\" src=\"https://user-images.githubusercontent.com/2690773/121598998-22321e80-ca4b-11eb-9a3d-dc9cb2936705.png\">\r\n\r\nAfter:\r\n<img width=\"859\" alt=\"Screenshot 2021-06-11 at 00 19 27\" src=\"https://user-images.githubusercontent.com/2690773/121599022-2a8a5980-ca4b-11eb-82b6-13ab0ed56d58.png\">\r\n\r\nAs a result, low hanging fruit was spotted: crazy amount of `fst_path` calls. Reducing that won ~200ms in the `import_on_the_fly @ sel` case in the `integrated_completion_benchmark`:\r\n\r\n<img width=\"861\" alt=\"Screenshot 2021-06-11 at 00 19 38\" src=\"https://user-images.githubusercontent.com/2690773/121599277-7d641100-ca4b-11eb-8667-53206994de27.png\">\r\n\r\nI'm not sure how to proceed with the remaining `???` marks in such methods as `collect_import_map` though: there's nothing but library calls in cycles, but maybe I'll come up with something later.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "47210c5b426680b218362ca4dd58f2ee79cf6244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47210c5b426680b218362ca4dd58f2ee79cf6244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgwoPuCRBK7hj4Ov3rIwAAEEYIAJse7ntCnvCtGQekJaDJIR3c\nPacQ8Tv2+muQaAMJ0+EJUOWmNiwAndjNPKaK4J78fp2ftMUGJrJyiDYBijwCKZUN\nKUEo7Z7WgE7UcHnrjcY+87VzTyJxfsdbXS+So3Xl7CiMm0BpfRurBqpQfk8ZSQBj\neHNpmt2a41FMB6LFe+h84ERq9n+IqrUBZHi4GZY7EDOK+oy6mg4hHte4te1llCjx\nkUv+rF1k+gu7q+C4LnLiqDpL0h3ofbv8t7pAqKWpwGlXq1eO738gvlIoki3bwtc+\nTXISXLjdMWZGP7bpLOygHoOOGNC9znvxyLpXhZfZtVRHYMvOFAaDOJzWIx6ZEWg=\n=Lix9\n-----END PGP SIGNATURE-----\n", "payload": "tree 47210c5b426680b218362ca4dd58f2ee79cf6244\nparent f4da4de7cdd4a7dfe40a417b0100b83ec50d1e1d\nparent 690cd953273317ee4f3eaefd95bbd3538e929522\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623360494 +0000\ncommitter GitHub <noreply@github.com> 1623360494 +0000\n\nMerge #9206\n\n9206: minor: Speed up fst items lookup during completions r=SomeoneToIgnore a=SomeoneToIgnore\n\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/7542\r\n\r\nA number of profile calls added for `import_on_the_fly` contents.\r\nBefore:\r\n<img width=\"606\" alt=\"Screenshot 2021-06-11 at 00 19 13\" src=\"https://user-images.githubusercontent.com/2690773/121598998-22321e80-ca4b-11eb-9a3d-dc9cb2936705.png\">\r\n\r\nAfter:\r\n<img width=\"859\" alt=\"Screenshot 2021-06-11 at 00 19 27\" src=\"https://user-images.githubusercontent.com/2690773/121599022-2a8a5980-ca4b-11eb-82b6-13ab0ed56d58.png\">\r\n\r\nAs a result, low hanging fruit was spotted: crazy amount of `fst_path` calls. Reducing that won ~200ms in the `import_on_the_fly @ sel` case in the `integrated_completion_benchmark`:\r\n\r\n<img width=\"861\" alt=\"Screenshot 2021-06-11 at 00 19 38\" src=\"https://user-images.githubusercontent.com/2690773/121599277-7d641100-ca4b-11eb-8667-53206994de27.png\">\r\n\r\nI'm not sure how to proceed with the remaining `???` marks in such methods as `collect_import_map` though: there's nothing but library calls in cycles, but maybe I'll come up with something later.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "html_url": "https://github.com/rust-lang/rust/commit/c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4da4de7cdd4a7dfe40a417b0100b83ec50d1e1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4da4de7cdd4a7dfe40a417b0100b83ec50d1e1d", "html_url": "https://github.com/rust-lang/rust/commit/f4da4de7cdd4a7dfe40a417b0100b83ec50d1e1d"}, {"sha": "690cd953273317ee4f3eaefd95bbd3538e929522", "url": "https://api.github.com/repos/rust-lang/rust/commits/690cd953273317ee4f3eaefd95bbd3538e929522", "html_url": "https://github.com/rust-lang/rust/commit/690cd953273317ee4f3eaefd95bbd3538e929522"}], "stats": {"total": 179, "additions": 97, "deletions": 82}, "files": [{"sha": "54baa3a63305a40f8bd55dd04011345f2533c820", "filename": "crates/base_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "patch": "@@ -120,6 +120,7 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     }\n \n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+        let _p = profile::span(\"relevant_crates\");\n         let source_root = self.0.file_source_root(file_id);\n         self.0.source_root_crates(source_root)\n     }"}, {"sha": "b9c1dc44df0806bf738a6340726dde4e79b3dfaa", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "patch": "@@ -191,6 +191,7 @@ impl Crate {\n         db: &dyn DefDatabase,\n         query: import_map::Query,\n     ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+        let _p = profile::span(\"query_external_importables\");\n         import_map::search_dependencies(db, self.into(), query).into_iter().map(|item| match item {\n             ItemInNs::Types(mod_id) | ItemInNs::Values(mod_id) => Either::Left(mod_id.into()),\n             ItemInNs::Macros(mac_id) => Either::Right(mac_id.into()),\n@@ -2185,6 +2186,7 @@ impl Type {\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n+        let _p = profile::span(\"iterate_method_candidates\");\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n@@ -2218,6 +2220,7 @@ impl Type {\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n+        let _p = profile::span(\"iterate_path_candidates\");\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n \n         let env = self.env.clone();\n@@ -2255,6 +2258,7 @@ impl Type {\n         &'a self,\n         db: &'a dyn HirDatabase,\n     ) -> impl Iterator<Item = Trait> + 'a {\n+        let _p = profile::span(\"applicable_inherent_traits\");\n         self.autoderef(db)\n             .filter_map(|derefed_type| derefed_type.ty.dyn_trait())\n             .flat_map(move |dyn_trait_id| hir_ty::all_super_traits(db.upcast(), dyn_trait_id))"}, {"sha": "404e3e15394da9bd13607d839a91af6bde16755d", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 87, "deletions": 82, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "patch": "@@ -1,6 +1,6 @@\n //! A map of all publicly exported items in a crate.\n \n-use std::{cmp::Ordering, fmt, hash::BuildHasherDefault, sync::Arc};\n+use std::{fmt, hash::BuildHasherDefault, sync::Arc};\n \n use base_db::CrateId;\n use fst::{self, Streamer};\n@@ -69,95 +69,25 @@ pub struct ImportMap {\n impl ImportMap {\n     pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n         let _p = profile::span(\"import_map_query\");\n-        let def_map = db.crate_def_map(krate);\n-        let mut import_map = Self::default();\n-\n-        // We look only into modules that are public(ly reexported), starting with the crate root.\n-        let empty = ImportPath { segments: vec![] };\n-        let root = def_map.module_id(def_map.root());\n-        let mut worklist = vec![(root, empty)];\n-        while let Some((module, mod_path)) = worklist.pop() {\n-            let ext_def_map;\n-            let mod_data = if module.krate == krate {\n-                &def_map[module.local_id]\n-            } else {\n-                // The crate might reexport a module defined in another crate.\n-                ext_def_map = module.def_map(db);\n-                &ext_def_map[module.local_id]\n-            };\n-\n-            let visible_items = mod_data.scope.entries().filter_map(|(name, per_ns)| {\n-                let per_ns = per_ns.filter_visibility(|vis| vis == Visibility::Public);\n-                if per_ns.is_none() {\n-                    None\n-                } else {\n-                    Some((name, per_ns))\n-                }\n-            });\n-\n-            for (name, per_ns) in visible_items {\n-                let mk_path = || {\n-                    let mut path = mod_path.clone();\n-                    path.segments.push(name.clone());\n-                    path\n-                };\n-\n-                for item in per_ns.iter_items() {\n-                    let path = mk_path();\n-                    let path_len = path.len();\n-                    let import_info =\n-                        ImportInfo { path, container: module, is_trait_assoc_item: false };\n-\n-                    if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n-                        import_map.collect_trait_assoc_items(\n-                            db,\n-                            tr,\n-                            matches!(item, ItemInNs::Types(_)),\n-                            &import_info,\n-                        );\n-                    }\n \n-                    match import_map.map.entry(item) {\n-                        Entry::Vacant(entry) => {\n-                            entry.insert(import_info);\n-                        }\n-                        Entry::Occupied(mut entry) => {\n-                            // If the new path is shorter, prefer that one.\n-                            if path_len < entry.get().path.len() {\n-                                *entry.get_mut() = import_info;\n-                            } else {\n-                                continue;\n-                            }\n-                        }\n-                    }\n-\n-                    // If we've just added a path to a module, descend into it. We might traverse\n-                    // modules multiple times, but only if the new path to it is shorter than the\n-                    // first (else we `continue` above).\n-                    if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n-                        worklist.push((mod_id, mk_path()));\n-                    }\n-                }\n-            }\n-        }\n+        let mut import_map = collect_import_map(db, krate);\n \n         let mut importables = import_map.map.iter().collect::<Vec<_>>();\n-\n-        importables.sort_by(cmp);\n+        importables.sort_by_cached_key(|(_, import_info)| fst_path(&import_info.path));\n \n         // Build the FST, taking care not to insert duplicate values.\n \n         let mut builder = fst::MapBuilder::memory();\n         let mut last_batch_start = 0;\n \n         for idx in 0..importables.len() {\n-            if let Some(next_item) = importables.get(idx + 1) {\n-                if cmp(&importables[last_batch_start], next_item) == Ordering::Equal {\n+            let key = fst_path(&importables[last_batch_start].1.path);\n+            if let Some((_, next_import_info)) = importables.get(idx + 1) {\n+                if key == fst_path(&next_import_info.path) {\n                     continue;\n                 }\n             }\n \n-            let key = fst_path(&importables[last_batch_start].1.path);\n             builder.insert(key, last_batch_start as u64).unwrap();\n \n             last_batch_start = idx + 1;\n@@ -185,6 +115,7 @@ impl ImportMap {\n         is_type_in_ns: bool,\n         original_import_info: &ImportInfo,\n     ) {\n+        let _p = profile::span(\"collect_trait_assoc_items\");\n         for (assoc_item_name, item) in &db.trait_data(tr).items {\n             let module_def_id = match item {\n                 AssocItemId::FunctionId(f) => ModuleDefId::from(*f),\n@@ -210,6 +141,84 @@ impl ImportMap {\n     }\n }\n \n+fn collect_import_map(db: &dyn DefDatabase, krate: CrateId) -> ImportMap {\n+    let _p = profile::span(\"collect_import_map\");\n+\n+    let def_map = db.crate_def_map(krate);\n+    let mut import_map = ImportMap::default();\n+\n+    // We look only into modules that are public(ly reexported), starting with the crate root.\n+    let empty = ImportPath { segments: vec![] };\n+    let root = def_map.module_id(def_map.root());\n+    let mut worklist = vec![(root, empty)];\n+    while let Some((module, mod_path)) = worklist.pop() {\n+        let ext_def_map;\n+        let mod_data = if module.krate == krate {\n+            &def_map[module.local_id]\n+        } else {\n+            // The crate might reexport a module defined in another crate.\n+            ext_def_map = module.def_map(db);\n+            &ext_def_map[module.local_id]\n+        };\n+\n+        let visible_items = mod_data.scope.entries().filter_map(|(name, per_ns)| {\n+            let per_ns = per_ns.filter_visibility(|vis| vis == Visibility::Public);\n+            if per_ns.is_none() {\n+                None\n+            } else {\n+                Some((name, per_ns))\n+            }\n+        });\n+\n+        for (name, per_ns) in visible_items {\n+            let mk_path = || {\n+                let mut path = mod_path.clone();\n+                path.segments.push(name.clone());\n+                path\n+            };\n+\n+            for item in per_ns.iter_items() {\n+                let path = mk_path();\n+                let path_len = path.len();\n+                let import_info =\n+                    ImportInfo { path, container: module, is_trait_assoc_item: false };\n+\n+                if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n+                    import_map.collect_trait_assoc_items(\n+                        db,\n+                        tr,\n+                        matches!(item, ItemInNs::Types(_)),\n+                        &import_info,\n+                    );\n+                }\n+\n+                match import_map.map.entry(item) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(import_info);\n+                    }\n+                    Entry::Occupied(mut entry) => {\n+                        // If the new path is shorter, prefer that one.\n+                        if path_len < entry.get().path.len() {\n+                            *entry.get_mut() = import_info;\n+                        } else {\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n+                // If we've just added a path to a module, descend into it. We might traverse\n+                // modules multiple times, but only if the new path to it is shorter than the\n+                // first (else we `continue` above).\n+                if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n+                    worklist.push((mod_id, mk_path()));\n+                }\n+            }\n+        }\n+    }\n+\n+    import_map\n+}\n+\n impl PartialEq for ImportMap {\n     fn eq(&self, other: &Self) -> bool {\n         // `fst` and `importables` are built from `map`, so we don't need to compare them.\n@@ -240,17 +249,12 @@ impl fmt::Debug for ImportMap {\n }\n \n fn fst_path(path: &ImportPath) -> String {\n+    let _p = profile::span(\"fst_path\");\n     let mut s = path.to_string();\n     s.make_ascii_lowercase();\n     s\n }\n \n-fn cmp((_, lhs): &(&ItemInNs, &ImportInfo), (_, rhs): &(&ItemInNs, &ImportInfo)) -> Ordering {\n-    let lhs_str = fst_path(&lhs.path);\n-    let rhs_str = fst_path(&rhs.path);\n-    lhs_str.cmp(&rhs_str)\n-}\n-\n #[derive(Debug, Eq, PartialEq, Hash)]\n pub enum ImportKind {\n     Module,\n@@ -338,6 +342,7 @@ impl Query {\n     }\n \n     fn import_matches(&self, import: &ImportInfo, enforce_lowercase: bool) -> bool {\n+        let _p = profile::span(\"import_map::Query::import_matches\");\n         if import.is_trait_assoc_item {\n             if self.exclude_import_kinds.contains(&ImportKind::AssociatedItem) {\n                 return false;"}, {"sha": "3a45cbfa1217855a368588441fe42c61b4175b31", "filename": "crates/hir_def/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fhir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fhir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flang_item.rs?ref=c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "patch": "@@ -141,6 +141,7 @@ impl LangItems {\n     ) where\n         T: Into<AttrDefId> + Copy,\n     {\n+        let _p = profile::span(\"collect_lang_item\");\n         if let Some(lang_item_name) = lang_attr(db, item) {\n             self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n         }"}, {"sha": "a9f13cb82085ec4346531d98a08a8627d8e4be65", "filename": "crates/hir_def/src/per_ns.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fhir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fhir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fper_ns.rs?ref=c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "patch": "@@ -62,6 +62,7 @@ impl PerNs {\n     }\n \n     pub fn filter_visibility(self, mut f: impl FnMut(Visibility) -> bool) -> PerNs {\n+        let _p = profile::span(\"PerNs::filter_visibility\");\n         PerNs {\n             types: self.types.filter(|(_, v)| f(*v)),\n             values: self.values.filter(|(_, v)| f(*v)),\n@@ -86,6 +87,7 @@ impl PerNs {\n     }\n \n     pub fn iter_items(self) -> impl Iterator<Item = ItemInNs> {\n+        let _p = profile::span(\"PerNs::iter_items\");\n         self.types\n             .map(|it| ItemInNs::Types(it.0))\n             .into_iter()"}, {"sha": "000f87a8588c2b870d5397e3f51ac608fdce90bb", "filename": "crates/ide_db/src/symbol_index.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c1fcb8e902adcc7879996fa7f53200fb36ce33/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=c4c1fcb8e902adcc7879996fa7f53200fb36ce33", "patch": "@@ -197,6 +197,7 @@ pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n }\n \n pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<FileSymbol> {\n+    let _p = profile::span(\"crate_symbols\").detail(|| format!(\"{:?}\", query));\n     // FIXME(#4842): This now depends on CrateDefMap, why not build the entire symbol index from\n     // that instead?\n \n@@ -321,6 +322,7 @@ impl SymbolIndex {\n \n impl Query {\n     pub(crate) fn search(self, indices: &[&SymbolIndex]) -> Vec<FileSymbol> {\n+        let _p = profile::span(\"symbol_index::Query::search\");\n         let mut op = fst::map::OpBuilder::new();\n         for file_symbols in indices.iter() {\n             let automaton = fst::automaton::Subsequence::new(&self.lowercased);"}]}