{"sha": "3456e2eec7c1e18734f8fa41924a83b4c676dc00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NTZlMmVlYzdjMWUxODczNGY4ZmE0MTkyNGE4M2I0YzY3NmRjMDA=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-07-31T02:31:53Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-08-16T14:26:16Z"}, "message": "Add new method to Semantics, method_receiver_kind, which returns the kind of self\n\nThe options are Shared, Mutable, Consuming, and Copied. Use this to add proper\nhighlighting to methods based on usage.", "tree": {"sha": "22c470056daeb136c64966cc4f4c976a8f45bf00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22c470056daeb136c64966cc4f4c976a8f45bf00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3456e2eec7c1e18734f8fa41924a83b4c676dc00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3456e2eec7c1e18734f8fa41924a83b4c676dc00", "html_url": "https://github.com/rust-lang/rust/commit/3456e2eec7c1e18734f8fa41924a83b4c676dc00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3456e2eec7c1e18734f8fa41924a83b4c676dc00/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a044ff0138d6bff9406b94de89fde43e7672ee1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a044ff0138d6bff9406b94de89fde43e7672ee1b", "html_url": "https://github.com/rust-lang/rust/commit/a044ff0138d6bff9406b94de89fde43e7672ee1b"}], "stats": {"total": 251, "additions": 181, "deletions": 70}, "files": [{"sha": "fc1c1ccd3d43d526b317e6706d124b1dad8c52a5", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=3456e2eec7c1e18734f8fa41924a83b4c676dc00", "patch": "@@ -38,7 +38,7 @@ pub use crate::{\n         Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n     has_source::HasSource,\n-    semantics::{original_range, PathResolution, Semantics, SemanticsScope},\n+    semantics::{original_range, PathResolution, SelfKind, Semantics, SemanticsScope},\n };\n \n pub use hir_def::{"}, {"sha": "aff0e73da7ebcc64b792a4fd1086e331e670d259", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=3456e2eec7c1e18734f8fa41924a83b4c676dc00", "patch": "@@ -6,16 +6,18 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use base_db::{FileId, FileRange};\n use hir_def::{\n+    lang_item::LangItemTarget,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n-    AsMacroCall, FunctionId, TraitId, VariantId,\n+    src::HasSource,\n+    AsMacroCall, FunctionId, Lookup, TraitId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{\n     algo::{find_node_at_offset, skip_trivia_token},\n-    ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    ast, AstNode, Direction, SmolStr, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::{\n@@ -79,6 +81,13 @@ impl PathResolution {\n     }\n }\n \n+pub enum SelfKind {\n+    Shared,\n+    Mutable,\n+    Consuming,\n+    Copied,\n+}\n+\n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,\n@@ -188,6 +197,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.type_of_self(param)\n     }\n \n+    pub fn method_reciever_kind(&self, call: &ast::MethodCallExpr) -> Option<SelfKind> {\n+        self.imp.method_receiver_kind(call)\n+    }\n+\n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n         self.imp.resolve_method_call(call).map(Function::from)\n     }\n@@ -410,6 +423,35 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(param.syntax()).type_of_self(self.db, &param)\n     }\n \n+    fn method_receiver_kind(&self, call: &ast::MethodCallExpr) -> Option<SelfKind> {\n+        self.resolve_method_call(call).and_then(|func| {\n+            let lookup = func.lookup(self.db.upcast());\n+            let src = lookup.source(self.db.upcast());\n+            let param_list = src.value.param_list()?;\n+            let self_param = param_list.self_param()?;\n+            if self_param.amp_token().is_some() {\n+                return Some(if self_param.mut_token().is_some() {\n+                    SelfKind::Mutable\n+                } else {\n+                    SelfKind::Shared\n+                });\n+            }\n+\n+            let ty = self.type_of_expr(&call.expr()?)?;\n+            let krate = Function::from(func).krate(self.db)?;\n+            let lang_item = self.db.lang_item(krate.id, SmolStr::new(\"copy\"));\n+            let copy_trait = match lang_item? {\n+                LangItemTarget::TraitId(copy_trait) => Trait::from(copy_trait),\n+                _ => return None,\n+            };\n+            Some(if ty.impls_trait(self.db, copy_trait, &[]) {\n+                SelfKind::Copied\n+            } else {\n+                SelfKind::Consuming\n+            })\n+        })\n+    }\n+\n     fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<FunctionId> {\n         self.analyze(call.syntax()).resolve_method_call(self.db, call)\n     }"}, {"sha": "9827c68afbd0bff3d93fc0ba038b5c146ce4e758", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 74, "deletions": 65, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=3456e2eec7c1e18734f8fa41924a83b4c676dc00", "patch": "@@ -4,7 +4,7 @@ mod injection;\n #[cfg(test)]\n mod tests;\n \n-use hir::{Mutability, Name, Semantics, VariantDef};\n+use hir::{Mutability, Name, SelfKind, Semantics, VariantDef};\n use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n     RootDatabase,\n@@ -519,27 +519,29 @@ fn highlight_element(\n         }\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n-            let possibly_unsafe = is_possibly_unsafe(&name_ref);\n-            match classify_name_ref(sema, &name_ref) {\n-                Some(name_kind) => match name_kind {\n-                    NameRefClass::ExternCrate(_) => HighlightTag::Module.into(),\n-                    NameRefClass::Definition(def) => {\n-                        if let Definition::Local(local) = &def {\n-                            if let Some(name) = local.name(db) {\n-                                let shadow_count =\n-                                    bindings_shadow_count.entry(name.clone()).or_default();\n-                                binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n-                            }\n-                        };\n-                        highlight_name(sema, db, def, Some(name_ref), possibly_unsafe)\n+            highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n+                let possibly_unsafe = is_possibly_unsafe(&name_ref);\n+                match classify_name_ref(sema, &name_ref) {\n+                    Some(name_kind) => match name_kind {\n+                        NameRefClass::ExternCrate(_) => HighlightTag::Module.into(),\n+                        NameRefClass::Definition(def) => {\n+                            if let Definition::Local(local) = &def {\n+                                if let Some(name) = local.name(db) {\n+                                    let shadow_count =\n+                                        bindings_shadow_count.entry(name.clone()).or_default();\n+                                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+                                }\n+                            };\n+                            highlight_name(sema, db, def, Some(name_ref), possibly_unsafe)\n+                        }\n+                        NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n+                    },\n+                    None if syntactic_name_ref_highlighting => {\n+                        highlight_name_ref_by_syntax(name_ref, sema)\n                     }\n-                    NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n-                },\n-                None if syntactic_name_ref_highlighting => {\n-                    highlight_name_ref_by_syntax(name_ref, sema)\n+                    None => HighlightTag::UnresolvedReference.into(),\n                 }\n-                None => HighlightTag::UnresolvedReference.into(),\n-            }\n+            })\n         }\n \n         // Simple token-based highlighting\n@@ -700,6 +702,35 @@ fn is_child_of_impl(element: &SyntaxElement) -> bool {\n     }\n }\n \n+fn highlight_func_by_name_ref(\n+    sema: &Semantics<RootDatabase>,\n+    name_ref: &ast::NameRef,\n+) -> Option<Highlight> {\n+    let parent = name_ref.syntax().parent()?;\n+    let method_call = ast::MethodCallExpr::cast(parent)?;\n+    highlight_method_call(sema, &method_call)\n+}\n+\n+fn highlight_method_call(\n+    sema: &Semantics<RootDatabase>,\n+    method_call: &ast::MethodCallExpr,\n+) -> Option<Highlight> {\n+    let func = sema.resolve_method_call(&method_call)?;\n+    let mut h = HighlightTag::Function.into();\n+    if func.is_unsafe(sema.db) || sema.is_unsafe_method_call(&method_call) {\n+        h |= HighlightModifier::Unsafe;\n+    }\n+\n+    sema.method_reciever_kind(&method_call)\n+        .map(|self_kind| match self_kind {\n+            SelfKind::Shared => h,\n+            SelfKind::Mutable => h | HighlightModifier::Mutable,\n+            SelfKind::Consuming => h | HighlightModifier::Consuming,\n+            SelfKind::Copied => h,\n+        })\n+        .or_else(|| Some(h))\n+}\n+\n fn highlight_name(\n     sema: &Semantics<RootDatabase>,\n     db: &RootDatabase,\n@@ -722,30 +753,26 @@ fn highlight_name(\n         Definition::ModuleDef(def) => match def {\n             hir::ModuleDef::Module(_) => HighlightTag::Module,\n             hir::ModuleDef::Function(func) => {\n-                let mut h = HighlightTag::Function.into();\n-                if func.is_unsafe(db) {\n-                    h |= HighlightModifier::Unsafe;\n-                } else {\n-                    let is_unsafe = name_ref\n-                        .and_then(|name_ref| name_ref.syntax().parent())\n-                        .and_then(ast::MethodCallExpr::cast)\n-                        .map(|method_call_expr| sema.is_unsafe_method_call(&method_call_expr))\n-                        .unwrap_or(false);\n-                    if is_unsafe {\n-                        h |= HighlightModifier::Unsafe;\n-                    }\n-                }\n-                return if func.has_self_param(db) {\n-                    match func.mutability_of_self_param(db) {\n-                        Some(mutability) => match mutability {\n-                            Mutability::Mut => h | HighlightModifier::Mutable,\n-                            Mutability::Shared => h,\n-                        },\n-                        None => h | HighlightModifier::Consuming,\n-                    }\n-                } else {\n-                    h\n-                };\n+                return name_ref\n+                    .and_then(|name_ref| highlight_func_by_name_ref(sema, &name_ref))\n+                    .unwrap_or_else(|| {\n+                        let mut h = HighlightTag::Function.into();\n+                        if func.is_unsafe(db) {\n+                            h |= HighlightModifier::Unsafe;\n+                        }\n+\n+                        return if func.has_self_param(db) {\n+                            match func.mutability_of_self_param(db) {\n+                                Some(mutability) => match mutability {\n+                                    Mutability::Mut => h | HighlightModifier::Mutable,\n+                                    Mutability::Shared => h,\n+                                },\n+                                None => h,\n+                            }\n+                        } else {\n+                            h\n+                        };\n+                    });\n             }\n             hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HighlightTag::Struct,\n             hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HighlightTag::Enum,\n@@ -817,27 +844,9 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n \n     match parent.kind() {\n         METHOD_CALL_EXPR => {\n-            let mut h = Highlight::new(HighlightTag::Function);\n-            ast::MethodCallExpr::cast(parent)\n-                .and_then(|method_call_expr| {\n-                    if sema.is_unsafe_method_call(&method_call_expr) {\n-                        h |= HighlightModifier::Unsafe;\n-                    }\n-\n-                    let func = sema.resolve_method_call(&method_call_expr)?;\n-                    if !func.has_self_param(sema.db) {\n-                        return Some(h);\n-                    }\n-\n-                    Some(match func.mutability_of_self_param(sema.db) {\n-                        Some(mutability) => match mutability {\n-                            Mutability::Mut => h | HighlightModifier::Mutable,\n-                            Mutability::Shared => h,\n-                        },\n-                        None => h | HighlightModifier::Consuming,\n-                    })\n-                })\n-                .unwrap_or_else(|| h)\n+            return ast::MethodCallExpr::cast(parent)\n+                .and_then(|method_call| highlight_method_call(sema, &method_call))\n+                .unwrap_or_else(|| HighlightTag::Function.into());\n         }\n         FIELD_EXPR => {\n             let h = HighlightTag::Field;"}, {"sha": "ccb76f5529377cfbce0513c6ed7f122a0870149d", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=3456e2eec7c1e18734f8fa41924a83b4c676dc00", "patch": "@@ -12,6 +12,12 @@ fn test_highlighting() {\n use inner::{self as inner_mod};\n mod inner {}\n \n+// Needed for function consuming vs normal\n+pub mod marker {\n+    #[lang = \"copy\"]\n+    pub trait Copy {}\n+}\n+\n #[derive(Clone, Debug)]\n struct Foo {\n     pub x: i32,\n@@ -42,6 +48,25 @@ impl Foo {\n     }\n }\n \n+#[derive(Copy, Clone)]\n+struct FooCopy {\n+    x: u32,\n+}\n+\n+impl FooCopy {\n+    fn baz(self) -> u32 {\n+        self.x\n+    }\n+\n+    fn qux(&mut self) {\n+        self.x = 0;\n+    }\n+\n+    fn quop(&self) -> u32 {\n+        self.x\n+    }\n+}\n+\n static mut STATIC_MUT: i32 = 0;\n \n fn foo<'a, T>() -> T {\n@@ -96,6 +121,11 @@ fn main() {\n     foo.quop();\n     foo.qux();\n     foo.baz();\n+\n+    let mut copy = FooCopy { x };\n+    copy.quop();\n+    copy.qux();\n+    copy.baz();\n }\n \n enum Option<T> {"}, {"sha": "a6b79589bf72b443930e7861a9fd3d4a0f19a916", "filename": "crates/ide/test_data/highlighting.html", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fide%2Ftest_data%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/3456e2eec7c1e18734f8fa41924a83b4c676dc00/crates%2Fide%2Ftest_data%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Ftest_data%2Fhighlighting.html?ref=3456e2eec7c1e18734f8fa41924a83b4c676dc00", "patch": "@@ -38,6 +38,12 @@\n <pre><code><span class=\"keyword\">use</span> <span class=\"module\">inner</span><span class=\"operator\">::</span><span class=\"punctuation\">{</span><span class=\"self_keyword\">self</span> <span class=\"keyword\">as</span> <span class=\"module declaration\">inner_mod</span><span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n <span class=\"keyword\">mod</span> <span class=\"module declaration\">inner</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n \n+<span class=\"comment\">// Needed for function consuming vs normal</span>\n+<span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> <span class=\"module declaration\">marker</span> <span class=\"punctuation\">{</span>\n+    <span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">lang</span><span class=\"attribute\"> </span><span class=\"operator\">=</span><span class=\"attribute\"> </span><span class=\"string_literal\">\"copy\"</span><span class=\"attribute\">]</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Copy</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span>\n+\n <span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">derive</span><span class=\"punctuation\">(</span><span class=\"attribute\">Clone</span><span class=\"punctuation\">,</span><span class=\"attribute\"> Debug</span><span class=\"punctuation\">)</span><span class=\"attribute\">]</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span> <span class=\"punctuation\">{</span>\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">x</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">i32</span><span class=\"punctuation\">,</span>\n@@ -55,7 +61,7 @@\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function declaration consuming\">baz</span><span class=\"punctuation\">(</span><span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">baz</span><span class=\"punctuation\">(</span><span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"punctuation\">{</span>\n         <span class=\"self_keyword\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span>\n     <span class=\"punctuation\">}</span>\n \n@@ -68,6 +74,25 @@\n     <span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span>\n \n+<span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">derive</span><span class=\"punctuation\">(</span><span class=\"attribute\">Copy</span><span class=\"punctuation\">,</span><span class=\"attribute\"> Clone</span><span class=\"punctuation\">)</span><span class=\"attribute\">]</span>\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">FooCopy</span> <span class=\"punctuation\">{</span>\n+    <span class=\"field declaration\">x</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">u32</span><span class=\"punctuation\">,</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">impl</span> <span class=\"struct\">FooCopy</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">baz</span><span class=\"punctuation\">(</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">u32</span> <span class=\"punctuation\">{</span>\n+        <span class=\"self_keyword\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span>\n+    <span class=\"punctuation\">}</span>\n+\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration mutable\">qux</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n+        <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"punctuation\">;</span>\n+    <span class=\"punctuation\">}</span>\n+\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">quop</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">u32</span> <span class=\"punctuation\">{</span>\n+        <span class=\"self_keyword\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span>\n+    <span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span>\n+\n <span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable unsafe\">STATIC_MUT</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">i32</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"punctuation\">;</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span><span class=\"punctuation\">&lt;</span><span class=\"lifetime declaration\">'a</span><span class=\"punctuation\">,</span> <span class=\"type_param declaration\">T</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"type_param\">T</span> <span class=\"punctuation\">{</span>\n@@ -122,6 +147,11 @@\n     <span class=\"variable mutable\">foo</span><span class=\"punctuation\">.</span><span class=\"function\">quop</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n     <span class=\"variable mutable\">foo</span><span class=\"punctuation\">.</span><span class=\"function mutable\">qux</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n     <span class=\"variable mutable\">foo</span><span class=\"punctuation\">.</span><span class=\"function consuming\">baz</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">copy</span> <span class=\"operator\">=</span> <span class=\"struct\">FooCopy</span> <span class=\"punctuation\">{</span> <span class=\"field\">x</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function\">quop</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function mutable\">qux</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function\">baz</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">enum</span> <span class=\"enum declaration\">Option</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">T</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span>\n@@ -131,7 +161,7 @@\n <span class=\"keyword\">use</span> <span class=\"enum\">Option</span><span class=\"operator\">::</span><span class=\"punctuation\">*</span><span class=\"punctuation\">;</span>\n \n <span class=\"keyword\">impl</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">T</span><span class=\"punctuation\">&gt;</span> <span class=\"enum\">Option</span><span class=\"punctuation\">&lt;</span><span class=\"type_param\">T</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function declaration consuming\">and</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">U</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">(</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">,</span> <span class=\"value_param declaration\">other</span><span class=\"punctuation\">:</span> <span class=\"enum\">Option</span><span class=\"punctuation\">&lt;</span><span class=\"type_param\">U</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"enum\">Option</span><span class=\"punctuation\">&lt;</span><span class=\"punctuation\">(</span><span class=\"type_param\">T</span><span class=\"punctuation\">,</span> <span class=\"type_param\">U</span><span class=\"punctuation\">)</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">and</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">U</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">(</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">,</span> <span class=\"value_param declaration\">other</span><span class=\"punctuation\">:</span> <span class=\"enum\">Option</span><span class=\"punctuation\">&lt;</span><span class=\"type_param\">U</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"enum\">Option</span><span class=\"punctuation\">&lt;</span><span class=\"punctuation\">(</span><span class=\"type_param\">T</span><span class=\"punctuation\">,</span> <span class=\"type_param\">U</span><span class=\"punctuation\">)</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span>\n         <span class=\"keyword control\">match</span> <span class=\"value_param\">other</span> <span class=\"punctuation\">{</span>\n             <span class=\"enum_variant\">None</span> <span class=\"operator\">=&gt;</span> <span class=\"macro\">unimplemented!</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span>\n             <span class=\"variable declaration\">Nope</span> <span class=\"operator\">=&gt;</span> <span class=\"variable\">Nope</span><span class=\"punctuation\">,</span>"}]}