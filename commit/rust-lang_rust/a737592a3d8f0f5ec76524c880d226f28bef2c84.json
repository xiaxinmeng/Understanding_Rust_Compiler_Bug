{"sha": "a737592a3d8f0f5ec76524c880d226f28bef2c84", "node_id": "C_kwDOAAsO6NoAKGE3Mzc1OTJhM2Q4ZjBmNWVjNzY1MjRjODgwZDIyNmYyOGJlZjJjODQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-13T10:35:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-13T10:35:28Z"}, "message": "Auto merge of #91654 - nikic:llvmbc-section-flags, r=nagisa\n\nUse module inline assembly to embed bitcode\n\nIn LLVM 14, our current method of setting section flags to avoid\nembedding the `.llvmbc` section into final compilation artifacts\nwill no longer work, see issue #90326. The upstream recommendation\nis to instead embed the entire bitcode using module-level inline\nassembly, which is what this change does.\n\nI've kept the existing code for platforms where we do not need to\nset section flags, but possibly we should always be using the\ninline asm approach (which would have to look a bit different for MachO).\n\nr? `@nagisa`", "tree": {"sha": "ab4c9d5372b5ee45a48a21b0a1e8a8aa08c384a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab4c9d5372b5ee45a48a21b0a1e8a8aa08c384a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a737592a3d8f0f5ec76524c880d226f28bef2c84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a737592a3d8f0f5ec76524c880d226f28bef2c84", "html_url": "https://github.com/rust-lang/rust/commit/a737592a3d8f0f5ec76524c880d226f28bef2c84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a737592a3d8f0f5ec76524c880d226f28bef2c84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d6d0899c8bf9d321ffa12426ca7ae7e3e15478a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d6d0899c8bf9d321ffa12426ca7ae7e3e15478a", "html_url": "https://github.com/rust-lang/rust/commit/6d6d0899c8bf9d321ffa12426ca7ae7e3e15478a"}, {"sha": "509dedccacbce22c291da3bf85468fcdb92303d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/509dedccacbce22c291da3bf85468fcdb92303d4", "html_url": "https://github.com/rust-lang/rust/commit/509dedccacbce22c291da3bf85468fcdb92303d4"}], "stats": {"total": 102, "additions": 60, "deletions": 42}, "files": [{"sha": "3fceb2ac4ed83e120ec8fdc4848aed5e68e08bea", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a737592a3d8f0f5ec76524c880d226f28bef2c84/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a737592a3d8f0f5ec76524c880d226f28bef2c84/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=a737592a3d8f0f5ec76524c880d226f28bef2c84", "patch": "@@ -950,6 +950,29 @@ pub(crate) unsafe fn codegen(\n     ))\n }\n \n+fn create_section_with_flags_asm(section_name: &str, section_flags: &str, data: &[u8]) -> Vec<u8> {\n+    let mut asm = format!(\".section {},\\\"{}\\\"\\n\", section_name, section_flags).into_bytes();\n+    asm.extend_from_slice(b\".ascii \\\"\");\n+    asm.reserve(data.len());\n+    for &byte in data {\n+        if byte == b'\\\\' || byte == b'\"' {\n+            asm.push(b'\\\\');\n+            asm.push(byte);\n+        } else if byte < 0x20 || byte >= 0x80 {\n+            // Avoid non UTF-8 inline assembly. Use octal escape sequence, because it is fixed\n+            // width, while hex escapes will consume following characters.\n+            asm.push(b'\\\\');\n+            asm.push(b'0' + ((byte >> 6) & 0x7));\n+            asm.push(b'0' + ((byte >> 3) & 0x7));\n+            asm.push(b'0' + ((byte >> 0) & 0x7));\n+        } else {\n+            asm.push(byte);\n+        }\n+    }\n+    asm.extend_from_slice(b\"\\\"\\n\");\n+    asm\n+}\n+\n /// Embed the bitcode of an LLVM module in the LLVM module itself.\n ///\n /// This is done primarily for iOS where it appears to be standard to compile C\n@@ -975,34 +998,6 @@ unsafe fn embed_bitcode(\n     cmdline: &str,\n     bitcode: &[u8],\n ) {\n-    let llconst = common::bytes_in_context(llcx, bitcode);\n-    let llglobal = llvm::LLVMAddGlobal(\n-        llmod,\n-        common::val_ty(llconst),\n-        \"rustc.embedded.module\\0\".as_ptr().cast(),\n-    );\n-    llvm::LLVMSetInitializer(llglobal, llconst);\n-\n-    let is_apple = cgcx.opts.target_triple.triple().contains(\"-ios\")\n-        || cgcx.opts.target_triple.triple().contains(\"-darwin\")\n-        || cgcx.opts.target_triple.triple().contains(\"-tvos\");\n-\n-    let section = if is_apple { \"__LLVM,__bitcode\\0\" } else { \".llvmbc\\0\" };\n-    llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n-    llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n-    llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n-\n-    let llconst = common::bytes_in_context(llcx, cmdline.as_bytes());\n-    let llglobal = llvm::LLVMAddGlobal(\n-        llmod,\n-        common::val_ty(llconst),\n-        \"rustc.embedded.cmdline\\0\".as_ptr().cast(),\n-    );\n-    llvm::LLVMSetInitializer(llglobal, llconst);\n-    let section = if is_apple { \"__LLVM,__cmdline\\0\" } else { \".llvmcmd\\0\" };\n-    llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n-    llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n-\n     // We're adding custom sections to the output object file, but we definitely\n     // do not want these custom sections to make their way into the final linked\n     // executable. The purpose of these custom sections is for tooling\n@@ -1024,31 +1019,54 @@ unsafe fn embed_bitcode(\n     // * COFF - if we don't do anything the linker will by default copy all\n     //   these sections to the output artifact, not what we want! To subvert\n     //   this we want to flag the sections we inserted here as\n-    //   `IMAGE_SCN_LNK_REMOVE`. Unfortunately though LLVM has no native way to\n-    //   do this. Thankfully though we can do this with some inline assembly,\n-    //   which is easy enough to add via module-level global inline asm.\n+    //   `IMAGE_SCN_LNK_REMOVE`.\n     //\n     // * ELF - this is very similar to COFF above. One difference is that these\n     //   sections are removed from the output linked artifact when\n     //   `--gc-sections` is passed, which we pass by default. If that flag isn't\n     //   passed though then these sections will show up in the final output.\n     //   Additionally the flag that we need to set here is `SHF_EXCLUDE`.\n+    //\n+    // Unfortunately, LLVM provides no way to set custom section flags. For ELF\n+    // and COFF we emit the sections using module level inline assembly for that\n+    // reason (see issue #90326 for historical background).\n+    let is_apple = cgcx.opts.target_triple.triple().contains(\"-ios\")\n+        || cgcx.opts.target_triple.triple().contains(\"-darwin\")\n+        || cgcx.opts.target_triple.triple().contains(\"-tvos\");\n     if is_apple\n         || cgcx.opts.target_triple.triple().starts_with(\"wasm\")\n         || cgcx.opts.target_triple.triple().starts_with(\"asmjs\")\n     {\n-        // nothing to do here\n-    } else if cgcx.is_pe_coff {\n-        let asm = \"\n-            .section .llvmbc,\\\"n\\\"\n-            .section .llvmcmd,\\\"n\\\"\n-        \";\n-        llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n+        // We don't need custom section flags, create LLVM globals.\n+        let llconst = common::bytes_in_context(llcx, bitcode);\n+        let llglobal = llvm::LLVMAddGlobal(\n+            llmod,\n+            common::val_ty(llconst),\n+            \"rustc.embedded.module\\0\".as_ptr().cast(),\n+        );\n+        llvm::LLVMSetInitializer(llglobal, llconst);\n+\n+        let section = if is_apple { \"__LLVM,__bitcode\\0\" } else { \".llvmbc\\0\" };\n+        llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n+        llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n+        llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n+\n+        let llconst = common::bytes_in_context(llcx, cmdline.as_bytes());\n+        let llglobal = llvm::LLVMAddGlobal(\n+            llmod,\n+            common::val_ty(llconst),\n+            \"rustc.embedded.cmdline\\0\".as_ptr().cast(),\n+        );\n+        llvm::LLVMSetInitializer(llglobal, llconst);\n+        let section = if is_apple { \"__LLVM,__cmdline\\0\" } else { \".llvmcmd\\0\" };\n+        llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n+        llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     } else {\n-        let asm = \"\n-            .section .llvmbc,\\\"e\\\"\n-            .section .llvmcmd,\\\"e\\\"\n-        \";\n+        // We need custom section flags, so emit module-level inline assembly.\n+        let section_flags = if cgcx.is_pe_coff { \"n\" } else { \"e\" };\n+        let asm = create_section_with_flags_asm(\".llvmbc\", section_flags, bitcode);\n+        llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n+        let asm = create_section_with_flags_asm(\".llvmcmd\", section_flags, cmdline.as_bytes());\n         llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n     }\n }"}]}