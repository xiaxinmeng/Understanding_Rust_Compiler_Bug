{"sha": "9daea5b6393af6706dd50a48d4bf8e6eeaff9860", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYWVhNWI2MzkzYWY2NzA2ZGQ1MGE0OGQ0YmY4ZTZlZWFmZjk4NjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-15T15:04:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T19:21:59Z"}, "message": "Add a comment, remove Deref/DerefMut\n\nThe comment explains the `index-builder` pattern. We no longer need the\n`Deref/DerefMut` relationship, and it seems nicer without it.", "tree": {"sha": "30d238c042b1294f7d3291a8e0bf54207b1a20c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30d238c042b1294f7d3291a8e0bf54207b1a20c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9daea5b6393af6706dd50a48d4bf8e6eeaff9860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9daea5b6393af6706dd50a48d4bf8e6eeaff9860", "html_url": "https://github.com/rust-lang/rust/commit/9daea5b6393af6706dd50a48d4bf8e6eeaff9860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9daea5b6393af6706dd50a48d4bf8e6eeaff9860/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a91e67614b7f4a93bb128ca4f25889b25e22b99", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a91e67614b7f4a93bb128ca4f25889b25e22b99", "html_url": "https://github.com/rust-lang/rust/commit/1a91e67614b7f4a93bb128ca4f25889b25e22b99"}], "stats": {"total": 112, "additions": 79, "deletions": 33}, "files": [{"sha": "7f7b87fb880b4998ed7172faf8578dc018ed4028", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9daea5b6393af6706dd50a48d4bf8e6eeaff9860/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9daea5b6393af6706dd50a48d4bf8e6eeaff9860/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9daea5b6393af6706dd50a48d4bf8e6eeaff9860", "patch": "@@ -415,7 +415,7 @@ fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     fn encode_fields(&mut self,\n                      adt_def_id: DefId) {\n-        let def = self.ecx.tcx.lookup_adt_def(adt_def_id);\n+        let def = self.ecx().tcx.lookup_adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n@@ -1155,7 +1155,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self,\n                                  item: &hir::Item) {\n-        let def_id = self.ecx.tcx.map.local_def_id(item.id);\n+        let def_id = self.ecx().tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemStatic(..) |\n             hir::ItemConst(..) |\n@@ -1187,7 +1187,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                                def_id: DefId,\n                                struct_node_id: ast::NodeId,\n                                item: &hir::Item) {\n-        let ecx = self.ecx;\n+        let ecx = self.ecx();\n         let def = ecx.tcx.lookup_adt_def(def_id);\n         let variant = def.struct_variant();\n \n@@ -1213,7 +1213,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                              def_id: DefId,\n                              impl_id: ast::NodeId,\n                              ast_items: &[hir::ImplItem]) {\n-        let ecx = self.ecx;\n+        let ecx = self.ecx();\n         let impl_items = ecx.tcx.impl_items.borrow();\n         let items = &impl_items[&def_id];\n \n@@ -1240,7 +1240,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                               def_id: DefId,\n                               trait_items: &[hir::TraitItem]) {\n         // Now output the trait item info for each trait item.\n-        let tcx = self.ecx.tcx;\n+        let tcx = self.ecx().tcx;\n         let r = tcx.trait_item_def_ids(def_id);\n         for (item_def_id, trait_item) in r.iter().zip(trait_items) {\n             let item_def_id = item_def_id.def_id();\n@@ -1311,7 +1311,7 @@ impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, '\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.index.ecx.tcx.map.local_def_id(item.id);\n+        let def_id = self.index.ecx().tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => (), // ignore these\n             _ => self.index.record(def_id,\n@@ -1322,7 +1322,7 @@ impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, '\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.ecx.tcx.map.local_def_id(ni.id);\n+        let def_id = self.index.ecx().tcx.map.local_def_id(ni.id);\n         self.index.record(def_id,\n                           ItemContentBuilder::encode_info_for_foreign_item,\n                           (def_id, ni));"}, {"sha": "37f29696808ef2f7a8dd81ce3a4c7cb0301124bf", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9daea5b6393af6706dd50a48d4bf8e6eeaff9860/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9daea5b6393af6706dd50a48d4bf8e6eeaff9860/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=9daea5b6393af6706dd50a48d4bf8e6eeaff9860", "patch": "@@ -8,6 +8,60 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Builder types for generating the \"item data\" section of the\n+//! metadata. This section winds up looking like this:\n+//!\n+//! ```\n+//! <common::data> // big list of item-like things...\n+//!    <common::data_item> // ...for most def-ids, there is an entry.\n+//!    </common::data_item>\n+//! </common::data>\n+//! ```\n+//!\n+//! As we generate this listing, we collect the offset of each\n+//! `data_item` entry and store it in an index. Then, when we load the\n+//! metadata, we can skip right to the metadata for a particular item.\n+//!\n+//! In addition to the offset, we need to track the data that was used\n+//! to generate the contents of each `data_item`. This is so that we\n+//! can figure out which HIR nodes contributors to that data for\n+//! incremental compilation purposes.\n+//!\n+//! The `IndexBuilder` facilitates with both of these. It is created\n+//! with an RBML encoder isntance (`rbml_w`) along with an\n+//! `EncodingContext` (`ecx`), which it encapsulates. It has one main\n+//! method, `record()`. You invoke `record` like so to create a new\n+//! `data_item` element in the list:\n+//!\n+//! ```\n+//! index.record(some_def_id, callback_fn, data)\n+//! ```\n+//!\n+//! What record will do is to (a) record the current offset, (b) emit\n+//! the `common::data_item` tag, and then call `callback_fn` with the\n+//! given data as well as an `ItemContentBuilder`. Once `callback_fn`\n+//! returns, the `common::data_item` tag will be closed.\n+//!\n+//! The `ItemContentBuilder` is another type that just offers access\n+//! to the `ecx` and `rbml_w` that were given in, as well as\n+//! maintaining a list of `xref` instances, which are used to extract\n+//! common data so it is not re-serialized.\n+//!\n+//! `ItemContentBuilder` is a distinct type which does not offer the\n+//! `record` method, so that we can ensure that `common::data_item` elements\n+//! are never nested.\n+//!\n+//! In addition, while the `callback_fn` is executing, we will push a\n+//! task `MetaData(some_def_id)`, which can then observe the\n+//! reads/writes that occur in the task. For this reason, the `data`\n+//! argument that is given to the `callback_fn` must implement the\n+//! trait `DepGraphRead`, which indicates how to register reads on the\n+//! data in this new task (note that many types of data, such as\n+//! `DefId`, do not currently require any reads to be registered,\n+//! since they are not derived from a HIR node). This is also why we\n+//! give a callback fn, rather than taking a closure: it allows us to\n+//! easily control precisely what data is given to that fn.\n+\n use common::tag_items_data_item;\n use encoder::EncodeContext;\n use index::IndexData;\n@@ -18,7 +72,6 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fnv::FnvHashMap;\n use syntax::ast;\n-use std::ops::{Deref, DerefMut};\n \n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n@@ -53,6 +106,10 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         }\n     }\n \n+    pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n+        self.builder.ecx()\n+    }\n+\n     /// Emit the data for a def-id to the metadata. The function to\n     /// emit the data is `op`, and it will be given `data` as\n     /// arguments. This `record` function will start/end an RBML tag\n@@ -76,34 +133,20 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                         data: DATA)\n         where DATA: DepGraphRead\n     {\n-        let position = self.rbml_w.mark_stable_position();\n+        let position = self.builder.rbml_w.mark_stable_position();\n         self.items.record(id, position);\n-        let _task = self.ecx.tcx.dep_graph.in_task(DepNode::MetaData(id));\n-        self.rbml_w.start_tag(tag_items_data_item).unwrap();\n-        data.read(self.ecx.tcx);\n-        op(self, data);\n-        self.rbml_w.end_tag().unwrap();\n+        let _task = self.ecx().tcx.dep_graph.in_task(DepNode::MetaData(id));\n+        self.builder.rbml_w.start_tag(tag_items_data_item).unwrap();\n+        data.read(self.ecx().tcx);\n+        op(&mut self.builder, data);\n+        self.builder.rbml_w.end_tag().unwrap();\n     }\n \n     pub fn into_fields(self) -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n         (self.items, self.builder.xrefs)\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> Deref for IndexBuilder<'a, 'tcx, 'encoder> {\n-    type Target = ItemContentBuilder<'a, 'tcx, 'encoder>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.builder\n-    }\n-}\n-\n-impl<'a, 'tcx, 'encoder> DerefMut for IndexBuilder<'a, 'tcx, 'encoder> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.builder\n-    }\n-}\n-\n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n         self.ecx\n@@ -115,9 +158,10 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n-/// Trait that registers reads for types that are tracked in the\n-/// dep-graph. Mostly it is implemented for indices like DefId etc\n-/// which do not need to register a read.\n+/// Trait used for data that can be passed from outside a dep-graph\n+/// task.  The data must either be of some safe type, such as a\n+/// `DefId` index, or implement the `read` method so that it can add\n+/// a read of whatever dep-graph nodes are appropriate.\n pub trait DepGraphRead {\n     fn read(&self, tcx: TyCtxt);\n }\n@@ -185,8 +229,10 @@ read_hir!(hir::ImplItem);\n read_hir!(hir::TraitItem);\n read_hir!(hir::ForeignItem);\n \n-/// You can use `FromId(X, ...)` to indicate that `...` came from node\n-/// `X`; so we will add a read from the suitable `Hir` node.\n+/// Newtype that can be used to package up misc data extracted from a\n+/// HIR node that doesn't carry its own id. This will allow an\n+/// arbitrary `T` to be passed in, but register a read on the given\n+/// node-id.\n pub struct FromId<T>(pub ast::NodeId, pub T);\n \n impl<T> DepGraphRead for FromId<T> {"}]}