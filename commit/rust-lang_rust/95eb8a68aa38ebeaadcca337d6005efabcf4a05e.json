{"sha": "95eb8a68aa38ebeaadcca337d6005efabcf4a05e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZWI4YTY4YWEzOGViZWFhZGNjYTMzN2Q2MDA1ZWZhYmNmNGEwNWU=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-02T07:03:55Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-02T11:47:11Z"}, "message": "Slim down `rustdoc::html::render::Context`\n\nLike the comment on `Context` explains, `Context` is supposed to be\nlightweight, so we're putting everything that's immutable after\ncreation of the Context behind an `Arc<SharedContext>`.", "tree": {"sha": "ef8aaaf9262b2ba69197ae14c16b6a669e385d72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef8aaaf9262b2ba69197ae14c16b6a669e385d72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95eb8a68aa38ebeaadcca337d6005efabcf4a05e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95eb8a68aa38ebeaadcca337d6005efabcf4a05e", "html_url": "https://github.com/rust-lang/rust/commit/95eb8a68aa38ebeaadcca337d6005efabcf4a05e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95eb8a68aa38ebeaadcca337d6005efabcf4a05e/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef85c1e6a573d736592f00402456616a25eee0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef85c1e6a573d736592f00402456616a25eee0f", "html_url": "https://github.com/rust-lang/rust/commit/0ef85c1e6a573d736592f00402456616a25eee0f"}], "stats": {"total": 87, "additions": 47, "deletions": 40}, "files": [{"sha": "78dd14766e7422e9144f349ee085ba24c4859a9b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/95eb8a68aa38ebeaadcca337d6005efabcf4a05e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95eb8a68aa38ebeaadcca337d6005efabcf4a05e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=95eb8a68aa38ebeaadcca337d6005efabcf4a05e", "patch": "@@ -91,12 +91,20 @@ pub struct Context {\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     pub root_path: String,\n-    /// The path to the crate root source minus the file name.\n-    /// Used for simplifying paths to the highlighted source code files.\n-    pub src_root: PathBuf,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: PathBuf,\n+    /// A flag, which when `true`, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    pub render_redirect_pages: bool,\n+    pub shared: Arc<SharedContext>,\n+}\n+\n+pub struct SharedContext {\n+    /// The path to the crate root source minus the file name.\n+    /// Used for simplifying paths to the highlighted source code files.\n+    pub src_root: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n     pub layout: layout::Layout,\n@@ -106,10 +114,6 @@ pub struct Context {\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n     pub local_sources: HashMap<PathBuf, String>,\n-    /// A flag, which when turned off, will render pages which redirect to the\n-    /// real location of an item. This is used to allow external links to\n-    /// publicly reused items to redirect to the right location.\n-    pub render_redirect_pages: bool,\n     /// All the passes that were run on this crate.\n     pub passes: HashSet<String>,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n@@ -259,7 +263,7 @@ pub struct Cache {\n \n /// Helper struct to render all source code to HTML pages\n struct SourceCollector<'a> {\n-    cx: &'a mut Context,\n+    scx: &'a mut SharedContext,\n \n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n@@ -412,43 +416,37 @@ pub fn run(mut krate: clean::Crate,\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n     };\n-    let mut cx = Context {\n-        dst: dst,\n+    let mut scx = SharedContext {\n         src_root: src_root,\n         passes: passes,\n-        current: Vec::new(),\n-        root_path: String::new(),\n+        include_sources: true,\n+        local_sources: HashMap::new(),\n+        issue_tracker_base_url: None,\n         layout: layout::Layout {\n             logo: \"\".to_string(),\n             favicon: \"\".to_string(),\n             external_html: external_html.clone(),\n             krate: krate.name.clone(),\n             playground_url: \"\".to_string(),\n         },\n-        include_sources: true,\n-        local_sources: HashMap::new(),\n-        render_redirect_pages: false,\n-        issue_tracker_base_url: None,\n     };\n \n-    try_err!(mkdir(&cx.dst), &cx.dst);\n-\n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| m.attrs.list(\"doc\")) {\n         for attr in attrs {\n             match *attr {\n                 clean::NameValue(ref x, ref s)\n                         if \"html_favicon_url\" == *x => {\n-                    cx.layout.favicon = s.to_string();\n+                    scx.layout.favicon = s.to_string();\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"html_logo_url\" == *x => {\n-                    cx.layout.logo = s.to_string();\n+                    scx.layout.logo = s.to_string();\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"html_playground_url\" == *x => {\n-                    cx.layout.playground_url = s.to_string();\n+                    scx.layout.playground_url = s.to_string();\n                     markdown::PLAYGROUND_KRATE.with(|slot| {\n                         if slot.borrow().is_none() {\n                             let name = krate.name.clone();\n@@ -458,16 +456,25 @@ pub fn run(mut krate: clean::Crate,\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"issue_tracker_base_url\" == *x => {\n-                    cx.issue_tracker_base_url = Some(s.to_string());\n+                    scx.issue_tracker_base_url = Some(s.to_string());\n                 }\n                 clean::Word(ref x)\n                         if \"html_no_source\" == *x => {\n-                    cx.include_sources = false;\n+                    scx.include_sources = false;\n                 }\n                 _ => {}\n             }\n         }\n     }\n+    try_err!(mkdir(&dst), &dst);\n+    krate = render_sources(&dst, &mut scx, krate)?;\n+    let cx = Context {\n+        current: Vec::new(),\n+        root_path: String::new(),\n+        dst: dst,\n+        render_redirect_pages: false,\n+        shared: Arc::new(scx),\n+    };\n \n     // Crawl the crate to build various caches used for the output\n     let analysis = ::ANALYSISKEY.with(|a| a.clone());\n@@ -538,7 +545,6 @@ pub fn run(mut krate: clean::Crate,\n     CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n     write_shared(&cx, &krate, &*cache, index)?;\n-    let krate = render_sources(&mut cx, krate)?;\n \n     // And finally render the whole crate's documentation\n     cx.krate(krate)\n@@ -760,16 +766,16 @@ fn write_shared(cx: &Context,\n     Ok(())\n }\n \n-fn render_sources(cx: &mut Context,\n+fn render_sources(dst: &Path, scx: &mut SharedContext,\n                   krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n-    let dst = cx.dst.join(\"src\");\n+    let dst = dst.join(\"src\");\n     try_err!(mkdir(&dst), &dst);\n     let dst = dst.join(&krate.name);\n     try_err!(mkdir(&dst), &dst);\n     let mut folder = SourceCollector {\n         dst: dst,\n-        cx: cx,\n+        scx: scx,\n     };\n     Ok(folder.fold_crate(krate))\n }\n@@ -847,7 +853,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem\n-        if self.cx.include_sources\n+        if self.scx.include_sources\n             // skip all invalid spans\n             && item.source.filename != \"\"\n             // macros from other libraries get special filenames which we can\n@@ -860,7 +866,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.cx\n+            self.scx\n                 .include_sources = match self.emit_source(&item.source.filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n@@ -880,7 +886,7 @@ impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n         let p = PathBuf::from(filename);\n-        if self.cx.local_sources.contains_key(&p) {\n+        if self.scx.local_sources.contains_key(&p) {\n             // We've already emitted this source\n             return Ok(());\n         }\n@@ -901,7 +907,7 @@ impl<'a> SourceCollector<'a> {\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n         let mut href = String::new();\n-        clean_srcpath(&self.cx.src_root, &p, false, |component| {\n+        clean_srcpath(&self.scx.src_root, &p, false, |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n@@ -925,10 +931,10 @@ impl<'a> SourceCollector<'a> {\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n         };\n-        layout::render(&mut w, &self.cx.layout,\n+        layout::render(&mut w, &self.scx.layout,\n                        &page, &(\"\"), &Source(contents))?;\n         w.flush()?;\n-        self.cx.local_sources.insert(p, href);\n+        self.scx.local_sources.insert(p, href);\n         Ok(())\n     }\n }\n@@ -1265,10 +1271,10 @@ impl Context {\n             let tyname = shortty(it).to_static_str();\n             let desc = if it.is_crate() {\n                 format!(\"API documentation for the Rust `{}` crate.\",\n-                        cx.layout.krate)\n+                        cx.shared.layout.krate)\n             } else {\n                 format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.as_ref().unwrap(), tyname, cx.layout.krate)\n+                        it.name.as_ref().unwrap(), tyname, cx.shared.layout.krate)\n             };\n             let keywords = make_item_keywords(it);\n             let page = layout::Page {\n@@ -1286,7 +1292,7 @@ impl Context {\n             // write syscall all the time.\n             let mut writer = BufWriter::new(w);\n             if !cx.render_redirect_pages {\n-                layout::render(&mut writer, &cx.layout, &page,\n+                layout::render(&mut writer, &cx.shared.layout, &page,\n                                &Sidebar{ cx: cx, item: it },\n                                &Item{ cx: cx, item: it })?;\n \n@@ -1434,10 +1440,11 @@ impl<'a> Item<'a> {\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n         } else if self.item.def_id.is_local() {\n-            self.cx.local_sources.get(&PathBuf::from(&self.item.source.filename)).map(|path| {\n+            let path = PathBuf::from(&self.item.source.filename);\n+            self.cx.shared.local_sources.get(&path).map(|path| {\n                 format!(\"{root}src/{krate}/{path}#{href}\",\n                         root = self.cx.root_path,\n-                        krate = self.cx.layout.krate,\n+                        krate = self.cx.shared.layout.krate,\n                         path = path,\n                         href = href)\n             })\n@@ -1520,7 +1527,7 @@ impl<'a> fmt::Display for Item<'a> {\n         // [src] link in the downstream documentation will actually come back to\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n-        if self.cx.include_sources && !is_primitive {\n+        if self.cx.shared.include_sources && !is_primitive {\n             if let Some(l) = self.href() {\n                 write!(fmt, \"<a id='src-{}' class='srclink' \\\n                               href='{}' title='{}'>[src]</a>\",\n@@ -1752,7 +1759,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n             format!(\"Deprecated{}{}\", since, Markdown(&reason))\n         } else if stab.level == stability::Unstable {\n             let unstable_extra = if show_reason {\n-                match (!stab.feature.is_empty(), &cx.issue_tracker_base_url, stab.issue) {\n+                match (!stab.feature.is_empty(), &cx.shared.issue_tracker_base_url, stab.issue) {\n                     (true, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n                         format!(\" (<code>{}</code> <a href=\\\"{}{}\\\">#{}</a>)\",\n                                 Escape(&stab.feature), tracker_url, issue_no, issue_no),"}]}