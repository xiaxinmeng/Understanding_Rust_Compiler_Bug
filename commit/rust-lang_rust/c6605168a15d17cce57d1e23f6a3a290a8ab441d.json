{"sha": "c6605168a15d17cce57d1e23f6a3a290a8ab441d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NjA1MTY4YTE1ZDE3Y2NlNTdkMWUyM2Y2YTNhMjkwYThhYjQ0MWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-26T23:26:19Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-26T23:46:54Z"}, "message": "libcore: De-export logging and pipes", "tree": {"sha": "7c3aa408cfeae91ec1f25d7a332d9215289002fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c3aa408cfeae91ec1f25d7a332d9215289002fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6605168a15d17cce57d1e23f6a3a290a8ab441d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6605168a15d17cce57d1e23f6a3a290a8ab441d", "html_url": "https://github.com/rust-lang/rust/commit/c6605168a15d17cce57d1e23f6a3a290a8ab441d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6605168a15d17cce57d1e23f6a3a290a8ab441d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "html_url": "https://github.com/rust-lang/rust/commit/2891f5abe3c7f455d16930a35bfc8d8d623de0ff"}], "stats": {"total": 128, "additions": 53, "deletions": 75}, "files": [{"sha": "cd7321bf0d305b8fe4fff4f45c3f2532cb8bdff4", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6605168a15d17cce57d1e23f6a3a290a8ab441d/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6605168a15d17cce57d1e23f6a3a290a8ab441d/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=c6605168a15d17cce57d1e23f6a3a290a8ab441d", "patch": "@@ -6,8 +6,6 @@\n \n use cast::transmute;\n \n-export console_on, console_off, log_type;\n-\n #[nolink]\n extern mod rustrt {\n     #[legacy_exports];\n@@ -17,7 +15,7 @@ extern mod rustrt {\n }\n \n /// Turns on logging to stdout globally\n-fn console_on() {\n+pub fn console_on() {\n     rustrt::rust_log_console_on();\n }\n \n@@ -28,7 +26,7 @@ fn console_on() {\n  * runtime environment's logging spec, e.g. by setting\n  * the RUST_LOG environment variable\n  */\n-fn console_off() {\n+pub fn console_off() {\n     rustrt::rust_log_console_off();\n }\n "}, {"sha": "bbabceafe8ebcc058250f14ed6ecdacfd2e0b0e3", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 51, "deletions": 71, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c6605168a15d17cce57d1e23f6a3a290a8ab441d/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6605168a15d17cce57d1e23f6a3a290a8ab441d/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=c6605168a15d17cce57d1e23f6a3a290a8ab441d", "patch": "@@ -81,26 +81,6 @@ use cast::{forget, reinterpret_cast, transmute};\n use either::{Either, Left, Right};\n use option::unwrap;\n \n-// Things used by code generated by the pipe compiler.\n-export entangle, get_buffer, drop_buffer;\n-export SendPacketBuffered, RecvPacketBuffered;\n-export Packet, packet, mk_packet, entangle_buffer, HasBuffer, BufferHeader;\n-\n-// export these so we can find them in the buffer_resource\n-// destructor. This is probably a symptom of #3005.\n-export atomic_add_acq, atomic_sub_rel;\n-\n-// User-level things\n-export SendPacket, RecvPacket, send, recv, try_recv, peek;\n-export select, select2, selecti, select2i, selectable;\n-export spawn_service, spawn_service_recv;\n-export stream, Port, Chan, SharedChan, PortSet, Channel;\n-export oneshot, ChanOne, PortOne;\n-export recv_one, try_recv_one, send_one, try_send_one;\n-\n-// Functions used by the protocol compiler\n-export rt;\n-\n #[doc(hidden)]\n const SPIN_COUNT: uint = 0;\n \n@@ -123,7 +103,7 @@ impl State : Eq {\n     pure fn ne(other: &State) -> bool { !self.eq(other) }\n }\n \n-struct BufferHeader {\n+pub struct BufferHeader {\n     // Tracks whether this buffer needs to be freed. We can probably\n     // get away with restricting it to 0 or 1, if we're careful.\n     mut ref_count: int,\n@@ -195,13 +175,13 @@ impl PacketHeader {\n }\n \n #[doc(hidden)]\n-type Packet<T: Send> = {\n+pub type Packet<T: Send> = {\n     header: PacketHeader,\n     mut payload: Option<T>,\n };\n \n #[doc(hidden)]\n-trait HasBuffer {\n+pub trait HasBuffer {\n     // XXX This should not have a trailing underscore\n     fn set_buffer_(b: *libc::c_void);\n }\n@@ -213,7 +193,7 @@ impl<T: Send> Packet<T>: HasBuffer {\n }\n \n #[doc(hidden)]\n-fn mk_packet<T: Send>() -> Packet<T> {\n+pub fn mk_packet<T: Send>() -> Packet<T> {\n     {\n         header: PacketHeader(),\n         mut payload: None\n@@ -237,7 +217,7 @@ fn unibuffer<T: Send>() -> ~Buffer<Packet<T>> {\n }\n \n #[doc(hidden)]\n-fn packet<T: Send>() -> *Packet<T> {\n+pub fn packet<T: Send>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(b.data);\n     // We'll take over memory management from here.\n@@ -246,7 +226,7 @@ fn packet<T: Send>() -> *Packet<T> {\n }\n \n #[doc(hidden)]\n-fn entangle_buffer<T: Send, Tstart: Send>(\n+pub fn entangle_buffer<T: Send, Tstart: Send>(\n     +buffer: ~Buffer<T>,\n     init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n@@ -286,22 +266,22 @@ extern mod rusti {\n // If I call the rusti versions directly from a polymorphic function,\n // I get link errors. This is a bug that needs investigated more.\n #[doc(hidden)]\n-fn atomic_xchng_rel(dst: &mut int, src: int) -> int {\n+pub fn atomic_xchng_rel(dst: &mut int, src: int) -> int {\n     rusti::atomic_xchg_rel(dst, src)\n }\n \n #[doc(hidden)]\n-fn atomic_add_acq(dst: &mut int, src: int) -> int {\n+pub fn atomic_add_acq(dst: &mut int, src: int) -> int {\n     rusti::atomic_xadd_acq(dst, src)\n }\n \n #[doc(hidden)]\n-fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n+pub fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n     rusti::atomic_xsub_rel(dst, src)\n }\n \n #[doc(hidden)]\n-fn swap_task(+dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n+pub fn swap_task(+dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n     unsafe {\n@@ -355,7 +335,7 @@ fn swap_state_rel(+dst: &mut State, src: State) -> State {\n }\n \n #[doc(hidden)]\n-unsafe fn get_buffer<T: Send>(p: *PacketHeader) -> ~Buffer<T> {\n+pub unsafe fn get_buffer<T: Send>(p: *PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n@@ -391,8 +371,8 @@ fn BufferResource<T: Send>(+b: ~Buffer<T>) -> BufferResource<T> {\n }\n \n #[doc(hidden)]\n-fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n-                                +payload: T) -> bool {\n+pub fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n+                                    +payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n@@ -435,7 +415,7 @@ fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n Fails if the sender closes the connection.\n \n */\n-fn recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>) -> T {\n+pub fn recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>) -> T {\n     option::unwrap_expect(try_recv(move p), \"connection closed\")\n }\n \n@@ -445,7 +425,7 @@ Returns `none` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n+pub fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n     -> Option<T>\n {\n     let p_ = p.unwrap();\n@@ -539,7 +519,7 @@ fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pure fn peek<T: Send, Tb: Send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n+pub pure fn peek<T: Send, Tb: Send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       Empty => false,\n       Blocked => fail ~\"peeking on blocked packet\",\n@@ -691,7 +671,7 @@ Sometimes messages will be available on both endpoints at once. In\n this case, `select2` may return either `left` or `right`.\n \n */\n-fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n+pub fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n     +a: RecvPacketBuffered<A, Ab>,\n     +b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n@@ -716,12 +696,13 @@ impl *PacketHeader: Selectable {\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n-fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n+pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n     wait_many(endpoints)\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) -> Either<(), ()> {\n+pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n+        Either<(), ()> {\n     match wait_many([a.header(), b.header()]/_) {\n       0 => Left(()),\n       1 => Right(()),\n@@ -733,7 +714,7 @@ fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) -> Either<(), ()> {\n  list of the remaining endpoints.\n \n */\n-fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n+pub fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n@@ -747,14 +728,14 @@ fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n message.\n \n */\n-type SendPacket<T: Send> = SendPacketBuffered<T, Packet<T>>;\n+pub type SendPacket<T: Send> = SendPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-fn SendPacket<T: Send>(p: *Packet<T>) -> SendPacket<T> {\n+pub fn SendPacket<T: Send>(p: *Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n-struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n+pub struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n     drop {\n@@ -773,7 +754,7 @@ struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n     }\n }\n \n-fn SendPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n+pub fn SendPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n     -> SendPacketBuffered<T, Tbuffer> {\n         //debug!(\"take send %?\", p);\n     SendPacketBuffered {\n@@ -814,14 +795,14 @@ impl<T: Send, Tbuffer: Send> SendPacketBuffered<T, Tbuffer> {\n \n /// Represents the receive end of a pipe. It can receive exactly one\n /// message.\n-type RecvPacket<T: Send> = RecvPacketBuffered<T, Packet<T>>;\n+pub type RecvPacket<T: Send> = RecvPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-fn RecvPacket<T: Send>(p: *Packet<T>) -> RecvPacket<T> {\n+pub fn RecvPacket<T: Send>(p: *Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n \n-struct RecvPacketBuffered<T: Send, Tbuffer: Send> {\n+pub struct RecvPacketBuffered<T: Send, Tbuffer: Send> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n     drop {\n@@ -867,7 +848,7 @@ impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> : Selectable {\n     }\n }\n \n-fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n+pub fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n     -> RecvPacketBuffered<T, Tbuffer> {\n     //debug!(\"take recv %?\", p);\n     RecvPacketBuffered {\n@@ -880,7 +861,7 @@ fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n }\n \n #[doc(hidden)]\n-fn entangle<T: Send>() -> (SendPacket<T>, RecvPacket<T>) {\n+pub fn entangle<T: Send>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();\n     (SendPacket(p), RecvPacket(p))\n }\n@@ -892,7 +873,7 @@ endpoint. The send endpoint is returned to the caller and the receive\n endpoint is passed to the new task.\n \n */\n-fn spawn_service<T: Send, Tb: Send>(\n+pub fn spawn_service<T: Send, Tb: Send>(\n     init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                           RecvPacketBuffered<T, Tb>),\n     +service: fn~(+v: RecvPacketBuffered<T, Tb>))\n@@ -916,7 +897,7 @@ fn spawn_service<T: Send, Tb: Send>(\n receive state.\n \n */\n-fn spawn_service_recv<T: Send, Tb: Send>(\n+pub fn spawn_service_recv<T: Send, Tb: Send>(\n     init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                           SendPacketBuffered<T, Tb>),\n     +service: fn~(+v: SendPacketBuffered<T, Tb>))\n@@ -945,7 +926,7 @@ proto! streamp (\n )\n \n /// A trait for things that can send multiple messages.\n-trait Channel<T: Send> {\n+pub trait Channel<T: Send> {\n     // It'd be nice to call this send, but it'd conflict with the\n     // built in send kind.\n \n@@ -957,7 +938,7 @@ trait Channel<T: Send> {\n }\n \n /// A trait for things that can receive multiple messages.\n-trait Recv<T: Send> {\n+pub trait Recv<T: Send> {\n     /// Receives a message, or fails if the connection closes.\n     fn recv() -> T;\n \n@@ -978,15 +959,15 @@ trait Recv<T: Send> {\n type Chan_<T:Send> = { mut endp: Option<streamp::client::Open<T>> };\n \n /// An endpoint that can send many messages.\n-enum Chan<T:Send> {\n+pub enum Chan<T:Send> {\n     Chan_(Chan_<T>)\n }\n \n #[doc(hidden)]\n type Port_<T:Send> = { mut endp: Option<streamp::server::Open<T>> };\n \n /// An endpoint that can receive many messages.\n-enum Port<T:Send> {\n+pub enum Port<T:Send> {\n     Port_(Port_<T>)\n }\n \n@@ -995,7 +976,7 @@ enum Port<T:Send> {\n These allow sending or receiving an unlimited number of messages.\n \n */\n-fn stream<T:Send>() -> (Chan<T>, Port<T>) {\n+pub fn stream<T:Send>() -> (Chan<T>, Port<T>) {\n     let (c, s) = streamp::init();\n \n     (Chan_({ mut endp: Some(move c) }), Port_({ mut endp: Some(move s) }))\n@@ -1065,11 +1046,11 @@ impl<T: Send> Port<T>: Selectable {\n }\n \n /// Treat many ports as one.\n-struct PortSet<T: Send> {\n+pub struct PortSet<T: Send> {\n     mut ports: ~[pipes::Port<T>],\n }\n \n-fn PortSet<T: Send>() -> PortSet<T>{\n+pub fn PortSet<T: Send>() -> PortSet<T>{\n     PortSet {\n         ports: ~[]\n     }\n@@ -1124,7 +1105,7 @@ impl<T: Send> PortSet<T> : Recv<T> {\n }\n \n /// A channel that can be shared between many senders.\n-type SharedChan<T: Send> = private::Exclusive<Chan<T>>;\n+pub type SharedChan<T: Send> = private::Exclusive<Chan<T>>;\n \n impl<T: Send> SharedChan<T>: Channel<T> {\n     fn send(+x: T) {\n@@ -1152,7 +1133,7 @@ fn SharedChan<T:Send>(+c: Chan<T>) -> SharedChan<T> {\n }\n \n /// Receive a message from one of two endpoints.\n-trait Select2<T: Send, U: Send> {\n+pub trait Select2<T: Send, U: Send> {\n     /// Receive a message or return `none` if a connection closes.\n     fn try_select() -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n@@ -1188,26 +1169,26 @@ proto! oneshot (\n )\n \n /// The send end of a oneshot pipe.\n-type ChanOne<T: Send> = oneshot::client::Oneshot<T>;\n+pub type ChanOne<T: Send> = oneshot::client::Oneshot<T>;\n /// The receive end of a oneshot pipe.\n-type PortOne<T: Send> = oneshot::server::Oneshot<T>;\n+pub type PortOne<T: Send> = oneshot::server::Oneshot<T>;\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>) {\n+pub fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>) {\n     oneshot::init()\n }\n \n /**\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n-fn recv_one<T: Send>(+port: PortOne<T>) -> T {\n+pub fn recv_one<T: Send>(+port: PortOne<T>) -> T {\n     let oneshot::send(message) = recv(move port);\n     move message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n-fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n+pub fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n     let message = try_recv(move port);\n \n     if message.is_none() { None }\n@@ -1218,15 +1199,15 @@ fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n-fn send_one<T: Send>(+chan: ChanOne<T>, +data: T) {\n+pub fn send_one<T: Send>(+chan: ChanOne<T>, +data: T) {\n     oneshot::client::send(move chan, move data);\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-fn try_send_one<T: Send>(+chan: ChanOne<T>, +data: T)\n+pub fn try_send_one<T: Send>(+chan: ChanOne<T>, +data: T)\n         -> bool {\n     oneshot::client::try_send(move chan, move data).is_some()\n }\n@@ -1240,10 +1221,9 @@ mod rt {\n }\n \n #[cfg(test)]\n-mod test {\n-    #[legacy_exports];\n+pub mod test {\n     #[test]\n-    fn test_select2() {\n+    pub fn test_select2() {\n         let (c1, p1) = pipes::stream();\n         let (c2, p2) = pipes::stream();\n \n@@ -1258,7 +1238,7 @@ mod test {\n     }\n \n     #[test]\n-    fn test_oneshot() {\n+    pub fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n         oneshot::client::send(c, ());"}]}