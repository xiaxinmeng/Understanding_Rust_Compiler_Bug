{"sha": "c731157395f7a02138d5531041578983a66f6f42", "node_id": "C_kwDOAAsO6NoAKGM3MzExNTczOTVmN2EwMjEzOGQ1NTMxMDQxNTc4OTgzYTY2ZjZmNDI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-30T05:56:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-30T05:56:47Z"}, "message": "Rollup merge of #95376 - WaffleLapkin:drain_keep_rest, r=dtolnay\n\nAdd `vec::Drain{,Filter}::keep_rest`\n\nThis PR adds `keep_rest` methods to `vec::Drain` and `vec::DrainFilter` under `drain_keep_rest` feature gate:\n```rust\n// mod alloc::vec\n\nimpl<T, A: Allocator> Drain<'_, T, A> {\n    pub fn keep_rest(self);\n}\n\nimpl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    pub fn keep_rest(self);\n}\n```\n\nBoth these methods cancel draining of elements that were not yet yielded from the iterators. While this needs more testing & documentation, I want at least start the discussion. This may be a potential way out of the \"should `DrainFilter` exhaust itself on drop?\" argument.", "tree": {"sha": "ae5a37661f482432d0e5574e231e290d4bfcb322", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae5a37661f482432d0e5574e231e290d4bfcb322"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c731157395f7a02138d5531041578983a66f6f42", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDaafCRBK7hj4Ov3rIwAAZxAIAEAUQwxIQobrUuR2CY4E2D2P\nUQ27U0t7sR2ht2TinG4AQw1xDdWMJXAk0ZH4fEWRdBpFlBE6fhvUPy+imLH0gSL7\nG3gjt2Rc+M3U8k7H3JRWnjPkpBOeEc7Y+KSHL+dovYPTk42/DJkt1uLU2UliY1z6\nViRqdAXshi0iXJHCza9K6DaVam94jeT5XxeMiN2BrIBJucmnCFVyqm6d2SxfPgCq\nDpDxGTxUDxeAeFPsyLQkZk8tKMG/l+YH2dSfZxcllrSxlXSlnnPU3MJHO9AmPxA2\n1SIYo25+KkMyVacI81UAc4XuGwCJuw3bPDGDOXCvY9f8Lkm7BuapIi1Og5PpStc=\n=ezQ4\n-----END PGP SIGNATURE-----\n", "payload": "tree ae5a37661f482432d0e5574e231e290d4bfcb322\nparent 9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8\nparent 7a433e4d00969afe562d46e5314372f6d331d953\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661839007 +0530\ncommitter GitHub <noreply@github.com> 1661839007 +0530\n\nRollup merge of #95376 - WaffleLapkin:drain_keep_rest, r=dtolnay\n\nAdd `vec::Drain{,Filter}::keep_rest`\n\nThis PR adds `keep_rest` methods to `vec::Drain` and `vec::DrainFilter` under `drain_keep_rest` feature gate:\n```rust\n// mod alloc::vec\n\nimpl<T, A: Allocator> Drain<'_, T, A> {\n    pub fn keep_rest(self);\n}\n\nimpl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    pub fn keep_rest(self);\n}\n```\n\nBoth these methods cancel draining of elements that were not yet yielded from the iterators. While this needs more testing & documentation, I want at least start the discussion. This may be a potential way out of the \"should `DrainFilter` exhaust itself on drop?\" argument.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c731157395f7a02138d5531041578983a66f6f42", "html_url": "https://github.com/rust-lang/rust/commit/c731157395f7a02138d5531041578983a66f6f42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c731157395f7a02138d5531041578983a66f6f42/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "html_url": "https://github.com/rust-lang/rust/commit/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8"}, {"sha": "7a433e4d00969afe562d46e5314372f6d331d953", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a433e4d00969afe562d46e5314372f6d331d953", "html_url": "https://github.com/rust-lang/rust/commit/7a433e4d00969afe562d46e5314372f6d331d953"}], "stats": {"total": 193, "additions": 190, "deletions": 3}, "files": [{"sha": "5b73906a1c97c125961240910511ae13ac521d86", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c731157395f7a02138d5531041578983a66f6f42/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c731157395f7a02138d5531041578983a66f6f42/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=c731157395f7a02138d5531041578983a66f6f42", "patch": "@@ -1,7 +1,7 @@\n use crate::alloc::{Allocator, Global};\n use core::fmt;\n use core::iter::{FusedIterator, TrustedLen};\n-use core::mem;\n+use core::mem::{self, ManuallyDrop};\n use core::ptr::{self, NonNull};\n use core::slice::{self};\n \n@@ -65,6 +65,77 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n     pub fn allocator(&self) -> &A {\n         unsafe { self.vec.as_ref().allocator() }\n     }\n+\n+    /// Keep unyielded elements in the source `Vec`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(drain_keep_rest)]\n+    ///\n+    /// let mut vec = vec!['a', 'b', 'c'];\n+    /// let mut drain = vec.drain(..);\n+    ///\n+    /// assert_eq!(drain.next().unwrap(), 'a');\n+    ///\n+    /// // This call keeps 'b' and 'c' in the vec.\n+    /// drain.keep_rest();\n+    ///\n+    /// // If we wouldn't call `keep_rest()`,\n+    /// // `vec` would be empty.\n+    /// assert_eq!(vec, ['b', 'c']);\n+    /// ```\n+    #[unstable(feature = \"drain_keep_rest\", issue = \"101122\")]\n+    pub fn keep_rest(self) {\n+        // At this moment layout looks like this:\n+        //\n+        // [head] [yielded by next] [unyielded] [yielded by next_back] [tail]\n+        //        ^-- start         \\_________/-- unyielded_len        \\____/-- self.tail_len\n+        //                          ^-- unyielded_ptr                  ^-- tail\n+        //\n+        // Normally `Drop` impl would drop [unyielded] and then move [tail] to the `start`.\n+        // Here we want to\n+        // 1. Move [unyielded] to `start`\n+        // 2. Move [tail] to a new start at `start + len(unyielded)`\n+        // 3. Update length of the original vec to `len(head) + len(unyielded) + len(tail)`\n+        //    a. In case of ZST, this is the only thing we want to do\n+        // 4. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n+        let mut this = ManuallyDrop::new(self);\n+\n+        unsafe {\n+            let source_vec = this.vec.as_mut();\n+\n+            let start = source_vec.len();\n+            let tail = this.tail_start;\n+\n+            let unyielded_len = this.iter.len();\n+            let unyielded_ptr = this.iter.as_slice().as_ptr();\n+\n+            // ZSTs have no identity, so we don't need to move them around.\n+            let needs_move = mem::size_of::<T>() != 0;\n+\n+            if needs_move {\n+                let start_ptr = source_vec.as_mut_ptr().add(start);\n+\n+                // memmove back unyielded elements\n+                if unyielded_ptr != start_ptr {\n+                    let src = unyielded_ptr;\n+                    let dst = start_ptr;\n+\n+                    ptr::copy(src, dst, unyielded_len);\n+                }\n+\n+                // memmove back untouched tail\n+                if tail != (start + unyielded_len) {\n+                    let src = source_vec.as_ptr().add(tail);\n+                    let dst = start_ptr.add(unyielded_len);\n+                    ptr::copy(src, dst, this.tail_len);\n+                }\n+            }\n+\n+            source_vec.set_len(start + unyielded_len + this.tail_len);\n+        }\n+    }\n }\n \n #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]"}, {"sha": "8c03f1692d940643a1bd1cad768e44112120b3cf", "filename": "library/alloc/src/vec/drain_filter.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c731157395f7a02138d5531041578983a66f6f42/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c731157395f7a02138d5531041578983a66f6f42/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs?ref=c731157395f7a02138d5531041578983a66f6f42", "patch": "@@ -1,6 +1,7 @@\n use crate::alloc::{Allocator, Global};\n-use core::ptr::{self};\n-use core::slice::{self};\n+use core::mem::{self, ManuallyDrop};\n+use core::ptr;\n+use core::slice;\n \n use super::Vec;\n \n@@ -54,6 +55,61 @@ where\n     pub fn allocator(&self) -> &A {\n         self.vec.allocator()\n     }\n+\n+    /// Keep unyielded elements in the source `Vec`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(drain_filter)]\n+    /// #![feature(drain_keep_rest)]\n+    ///\n+    /// let mut vec = vec!['a', 'b', 'c'];\n+    /// let mut drain = vec.drain_filter(|_| true);\n+    ///\n+    /// assert_eq!(drain.next().unwrap(), 'a');\n+    ///\n+    /// // This call keeps 'b' and 'c' in the vec.\n+    /// drain.keep_rest();\n+    ///\n+    /// // If we wouldn't call `keep_rest()`,\n+    /// // `vec` would be empty.\n+    /// assert_eq!(vec, ['b', 'c']);\n+    /// ```\n+    #[unstable(feature = \"drain_keep_rest\", issue = \"101122\")]\n+    pub fn keep_rest(self) {\n+        // At this moment layout looks like this:\n+        //\n+        //  _____________________/-- old_len\n+        // /                     \\\n+        // [kept] [yielded] [tail]\n+        //        \\_______/ ^-- idx\n+        //                \\-- del\n+        //\n+        // Normally `Drop` impl would drop [tail] (via .for_each(drop), ie still calling `pred`)\n+        //\n+        // 1. Move [tail] after [kept]\n+        // 2. Update length of the original vec to `old_len - del`\n+        //    a. In case of ZST, this is the only thing we want to do\n+        // 3. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n+        let mut this = ManuallyDrop::new(self);\n+\n+        unsafe {\n+            // ZSTs have no identity, so we don't need to move them around.\n+            let needs_move = mem::size_of::<T>() != 0;\n+\n+            if needs_move && this.idx < this.old_len && this.del > 0 {\n+                let ptr = this.vec.as_mut_ptr();\n+                let src = ptr.add(this.idx);\n+                let dst = src.sub(this.del);\n+                let tail_len = this.old_len - this.idx;\n+                src.copy_to(dst, tail_len);\n+            }\n+\n+            let new_len = this.old_len - this.del;\n+            this.vec.set_len(new_len);\n+        }\n+    }\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]"}, {"sha": "490c0d8f76cdaf64860e6972bd93b28b010596ae", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c731157395f7a02138d5531041578983a66f6f42/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c731157395f7a02138d5531041578983a66f6f42/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=c731157395f7a02138d5531041578983a66f6f42", "patch": "@@ -44,6 +44,7 @@\n #![feature(bench_black_box)]\n #![feature(strict_provenance)]\n #![feature(once_cell)]\n+#![feature(drain_keep_rest)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "4c118455a3fc39dd0f65742b75037c1ebece8f7d", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c731157395f7a02138d5531041578983a66f6f42/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c731157395f7a02138d5531041578983a66f6f42/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=c731157395f7a02138d5531041578983a66f6f42", "patch": "@@ -839,6 +839,36 @@ fn test_drain_leak() {\n     assert_eq!(v, vec![D(0, false), D(1, false), D(6, false),]);\n }\n \n+#[test]\n+fn test_drain_keep_rest() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    let mut drain = v.drain(1..6);\n+    assert_eq!(drain.next(), Some(1));\n+    assert_eq!(drain.next_back(), Some(5));\n+    assert_eq!(drain.next(), Some(2));\n+\n+    drain.keep_rest();\n+    assert_eq!(v, &[0, 3, 4, 6]);\n+}\n+\n+#[test]\n+fn test_drain_keep_rest_all() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    v.drain(1..6).keep_rest();\n+    assert_eq!(v, &[0, 1, 2, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn test_drain_keep_rest_none() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    let mut drain = v.drain(1..6);\n+\n+    drain.by_ref().for_each(drop);\n+\n+    drain.keep_rest();\n+    assert_eq!(v, &[0, 6]);\n+}\n+\n #[test]\n fn test_splice() {\n     let mut v = vec![1, 2, 3, 4, 5];\n@@ -1533,6 +1563,35 @@ fn drain_filter_unconsumed() {\n     assert_eq!(vec, [2, 4]);\n }\n \n+#[test]\n+fn test_drain_filter_keep_rest() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    let mut drain = v.drain_filter(|&mut x| x % 2 == 0);\n+    assert_eq!(drain.next(), Some(0));\n+    assert_eq!(drain.next(), Some(2));\n+\n+    drain.keep_rest();\n+    assert_eq!(v, &[1, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn test_drain_filter_keep_rest_all() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    v.drain_filter(|_| true).keep_rest();\n+    assert_eq!(v, &[0, 1, 2, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn test_drain_filter_keep_rest_none() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    let mut drain = v.drain_filter(|_| true);\n+\n+    drain.by_ref().for_each(drop);\n+\n+    drain.keep_rest();\n+    assert_eq!(v, &[]);\n+}\n+\n #[test]\n fn test_reserve_exact() {\n     // This is all the same as test_reserve"}]}