{"sha": "3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNDljM2JkOWM2ZmVjNTI1NzRmZGM3YjdlMDBjYmZhNzZmMjllN2Q=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-25T04:57:24Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-25T04:57:24Z"}, "message": "Rollup merge of #22785 - nikomatsakis:issue-21750-normalization-with-regions, r=pnkfelix\n\n Two changes:\n\n1. Make traits with assoc types invariant w/r/t their inputs.\n2. Fully normalize parameter environments, including any region variables (which were being overlooked).\n\nThe former supports the latter, but also just seems like a reasonably good idea.\n\nFixes #21750\n\ncc @edwardw\nr? @pnkfelix", "tree": {"sha": "9f7127047523588454a98e53ac8a01282b959178", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f7127047523588454a98e53ac8a01282b959178"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d", "html_url": "https://github.com/rust-lang/rust/commit/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267c5873e221cce9b3e5fb2f17257d22c0fc587c", "url": "https://api.github.com/repos/rust-lang/rust/commits/267c5873e221cce9b3e5fb2f17257d22c0fc587c", "html_url": "https://github.com/rust-lang/rust/commit/267c5873e221cce9b3e5fb2f17257d22c0fc587c"}, {"sha": "206c2546c03c5d28aea3752f5746c9e161ee3692", "url": "https://api.github.com/repos/rust-lang/rust/commits/206c2546c03c5d28aea3752f5746c9e161ee3692", "html_url": "https://github.com/rust-lang/rust/commit/206c2546c03c5d28aea3752f5746c9e161ee3692"}], "stats": {"total": 187, "additions": 134, "deletions": 53}, "files": [{"sha": "b782a655d89ff11155bf156793000776a9c6bbed", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d", "patch": "@@ -265,13 +265,7 @@ pub trait Combine<'tcx> : Sized {\n             Err(ty::terr_projection_name_mismatched(\n                 expected_found(self, a.item_name, b.item_name)))\n         } else {\n-            // Note that the trait refs for the projection must be\n-            // *equal*. This is because there is no inherent\n-            // relationship between `<T as Foo>::Bar` and `<U as\n-            // Foo>::Bar` that we can derive based on how `T` relates\n-            // to `U`. Issue #21726 contains further discussion and\n-            // in-depth examples.\n-            let trait_ref = try!(self.equate().trait_refs(&*a.trait_ref, &*b.trait_ref));\n+            let trait_ref = try!(self.trait_refs(&*a.trait_ref, &*b.trait_ref));\n             Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n         }\n     }"}, {"sha": "62b81f0ebe7dba8b98e7d4368d755f4aba55da64", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d", "patch": "@@ -52,9 +52,16 @@ fn overlap(selcx: &mut SelectionContext,\n            b_def_id: ast::DefId)\n            -> bool\n {\n+    debug!(\"overlap(a_def_id={}, b_def_id={})\",\n+           a_def_id.repr(selcx.tcx()),\n+           b_def_id.repr(selcx.tcx()));\n+\n     let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx, a_def_id);\n     let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx, b_def_id);\n \n+    debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr(selcx.tcx()));\n+    debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr(selcx.tcx()));\n+\n     // Does `a <: b` hold? If not, no overlap.\n     if let Err(_) = infer::mk_sub_poly_trait_refs(selcx.infcx(),\n                                                   true,\n@@ -64,10 +71,20 @@ fn overlap(selcx: &mut SelectionContext,\n         return false;\n     }\n \n+    debug!(\"overlap: subtraitref check succeeded\");\n+\n     // Are any of the obligations unsatisfiable? If so, no overlap.\n-    a_obligations.iter()\n-                 .chain(b_obligations.iter())\n-                 .all(|o| selcx.evaluate_obligation(o))\n+    let opt_failing_obligation =\n+        a_obligations.iter()\n+                     .chain(b_obligations.iter())\n+                     .find(|o| !selcx.evaluate_obligation(o));\n+\n+    if let Some(failing_obligation) = opt_failing_obligation {\n+        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(selcx.tcx()));\n+        return false;\n+    }\n+\n+    true\n }\n \n /// Instantiate fresh variables for all bound parameters of the impl"}, {"sha": "5a5639c701291f54716eba3b701e76f8bc825786", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d", "patch": "@@ -18,7 +18,7 @@ pub use self::ObligationCauseCode::*;\n use middle::subst;\n use middle::ty::{self, HasProjectionTypes, Ty};\n use middle::ty_fold::TypeFoldable;\n-use middle::infer::{self, InferCtxt};\n+use middle::infer::{self, fixup_err_to_string, InferCtxt};\n use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n@@ -395,53 +395,64 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     }\n }\n \n+/// Normalizes the parameter environment, reporting errors if they occur.\n pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvironment<'a,'tcx>,\n                                              cause: ObligationCause<'tcx>)\n                                              -> ty::ParameterEnvironment<'a,'tcx>\n {\n-    match normalize_param_env(&unnormalized_env, cause) {\n-        Ok(p) => p,\n+    // I'm not wild about reporting errors here; I'd prefer to\n+    // have the errors get reported at a defined place (e.g.,\n+    // during typeck). Instead I have all parameter\n+    // environments, in effect, going through this function\n+    // and hence potentially reporting errors. This ensurse of\n+    // course that we never forget to normalize (the\n+    // alternative seemed like it would involve a lot of\n+    // manual invocations of this fn -- and then we'd have to\n+    // deal with the errors at each of those sites).\n+    //\n+    // In any case, in practice, typeck constructs all the\n+    // parameter environments once for every fn as it goes,\n+    // and errors will get reported then; so after typeck we\n+    // can be sure that no errors should occur.\n+\n+    let tcx = unnormalized_env.tcx;\n+    let span = cause.span;\n+    let body_id = cause.body_id;\n+\n+    debug!(\"normalize_param_env_or_error(unnormalized_env={})\",\n+           unnormalized_env.repr(tcx));\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let predicates = match fully_normalize(&infcx, &unnormalized_env, cause,\n+                                           &unnormalized_env.caller_bounds) {\n+        Ok(predicates) => predicates,\n         Err(errors) => {\n-            // I'm not wild about reporting errors here; I'd prefer to\n-            // have the errors get reported at a defined place (e.g.,\n-            // during typeck). Instead I have all parameter\n-            // environments, in effect, going through this function\n-            // and hence potentially reporting errors. This ensurse of\n-            // course that we never forget to normalize (the\n-            // alternative seemed like it would involve a lot of\n-            // manual invocations of this fn -- and then we'd have to\n-            // deal with the errors at each of those sites).\n-            //\n-            // In any case, in practice, typeck constructs all the\n-            // parameter environments once for every fn as it goes,\n-            // and errors will get reported then; so after typeck we\n-            // can be sure that no errors should occur.\n-            let infcx = infer::new_infer_ctxt(unnormalized_env.tcx);\n             report_fulfillment_errors(&infcx, &errors);\n-\n-            // Normalized failed? use what they gave us, it's better than nothing.\n-            unnormalized_env\n+            return unnormalized_env; // an unnormalized env is better than nothing\n         }\n-    }\n-}\n-\n-pub fn normalize_param_env<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n-                                    cause: ObligationCause<'tcx>)\n-                                    -> Result<ty::ParameterEnvironment<'a,'tcx>,\n-                                              Vec<FulfillmentError<'tcx>>>\n-{\n-    let tcx = param_env.tcx;\n-\n-    debug!(\"normalize_param_env(param_env={})\",\n-           param_env.repr(tcx));\n+    };\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n-    let predicates = try!(fully_normalize(&infcx, param_env, cause, &param_env.caller_bounds));\n+    infcx.resolve_regions_and_report_errors(body_id);\n+    let predicates = match infcx.fully_resolve(&predicates) {\n+        Ok(predicates) => predicates,\n+        Err(fixup_err) => {\n+            // If we encounter a fixup error, it means that some type\n+            // variable wound up unconstrained. I actually don't know\n+            // if this can happen, and I certainly don't expect it to\n+            // happen often, but if it did happen it probably\n+            // represents a legitimate failure due to some kind of\n+            // unconstrained variable, and it seems better not to ICE,\n+            // all things considered.\n+            let err_msg = fixup_err_to_string(fixup_err);\n+            tcx.sess.span_err(span, &err_msg);\n+            return unnormalized_env; // an unnormalized env is better than nothing\n+        }\n+    };\n \n-    debug!(\"normalize_param_env: predicates={}\",\n+    debug!(\"normalize_param_env_or_error: predicates={}\",\n            predicates.repr(tcx));\n \n-    Ok(param_env.with_caller_bounds(predicates))\n+    unnormalized_env.with_caller_bounds(predicates)\n }\n \n pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n@@ -453,8 +464,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n {\n     let tcx = closure_typer.tcx();\n \n-    debug!(\"normalize_param_env(value={})\",\n-           value.repr(tcx));\n+    debug!(\"normalize_param_env(value={})\", value.repr(tcx));\n \n     let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n     let mut fulfill_cx = FulfillmentContext::new();\n@@ -468,8 +478,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     }\n     try!(fulfill_cx.select_all_or_error(infcx, closure_typer));\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n-    debug!(\"normalize_param_env: resolved_value={}\",\n-           resolved_value.repr(tcx));\n+    debug!(\"normalize_param_env: resolved_value={}\", resolved_value.repr(tcx));\n     Ok(resolved_value)\n }\n "}, {"sha": "1fba4a21ccd376a61ab08fbc52609e1cb9b32b50", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=3a49c3bd9c6fec52574fdc7b7e00cbfa76f29e7d", "patch": "@@ -203,6 +203,56 @@\n //! failure, but rather because the target type `Foo<Y>` is itself just\n //! not well-formed. Basically we get to assume well-formedness of all\n //! types involved before considering variance.\n+//!\n+//! ### Associated types\n+//!\n+//! Any trait with an associated type is invariant with respect to all\n+//! of its inputs. To see why this makes sense, consider what\n+//! subtyping for a trait reference means:\n+//!\n+//!    <T as Trait> <: <U as Trait>\n+//!\n+//! means that if I know that `T as Trait`,\n+//! I also know that `U as\n+//! Trait`. Moreover, if you think of it as\n+//! dictionary passing style, it means that\n+//! a dictionary for `<T as Trait>` is safe\n+//! to use where a dictionary for `<U as\n+//! Trait>` is expected.\n+//!\n+//! The problem is that when you can\n+//! project types out from `<T as Trait>`,\n+//! the relationship to types projected out\n+//! of `<U as Trait>` is completely unknown\n+//! unless `T==U` (see #21726 for more\n+//! details). Making `Trait` invariant\n+//! ensures that this is true.\n+//!\n+//! *Historical note: we used to preserve this invariant another way,\n+//! by tweaking the subtyping rules and requiring that when a type `T`\n+//! appeared as part of a projection, that was considered an invariant\n+//! location, but this version does away with the need for those\n+//! somewhat \"special-case-feeling\" rules.*\n+//!\n+//! Another related reason is that if we didn't make traits with\n+//! associated types invariant, then projection is no longer a\n+//! function with a single result. Consider:\n+//!\n+//! ```\n+//! trait Identity { type Out; fn foo(&self); }\n+//! impl<T> Identity for T { type Out = T; ... }\n+//! ```\n+//!\n+//! Now if I have `<&'static () as Identity>::Out`, this can be\n+//! validly derived as `&'a ()` for any `'a`:\n+//!\n+//!    <&'a () as Identity> <: <&'static () as Identity>\n+//!    if &'static () < : &'a ()   -- Identity is contravariant in Self\n+//!    if 'static : 'a             -- Subtyping rules for relations\n+//!\n+//! This change otoh means that `<'static () as Identity>::Out` is\n+//! always `&'static ()` (which might then be upcast to `'a ()`,\n+//! separately). This was helpful in solving #21750.\n \n use self::VarianceTerm::*;\n use self::ParamKind::*;\n@@ -613,7 +663,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                                 &method.fty.sig,\n                                 self.covariant);\n                         }\n-                        ty::TypeTraitItem(_) => {}\n+                        ty::TypeTraitItem(ref data) => {\n+                            // Any trait with an associated type is\n+                            // invariant with respect to all of its\n+                            // inputs. See length discussion in the comment\n+                            // on this module.\n+                            let projection_ty = ty::mk_projection(tcx,\n+                                                                  trait_def.trait_ref.clone(),\n+                                                                  data.name);\n+                            self.add_constraints_from_ty(&trait_def.generics,\n+                                                         projection_ty,\n+                                                         self.invariant);\n+                        }\n                     }\n                 }\n             }\n@@ -893,7 +954,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     trait_def.generics.types.as_slice(),\n                     trait_def.generics.regions.as_slice(),\n                     trait_ref.substs,\n-                    self.invariant);\n+                    variance);\n             }\n \n             ty::ty_trait(ref data) => {"}]}