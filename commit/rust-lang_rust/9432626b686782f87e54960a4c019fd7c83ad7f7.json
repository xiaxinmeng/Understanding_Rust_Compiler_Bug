{"sha": "9432626b686782f87e54960a4c019fd7c83ad7f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MzI2MjZiNjg2NzgyZjg3ZTU0OTYwYTRjMDE5ZmQ3YzgzYWQ3Zjc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-05T13:03:37Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-05T18:19:43Z"}, "message": "Eradicate fold from capture.rs\n\nThe pass now uses walk.", "tree": {"sha": "e066f8222590e985d890be4ba622d924cde7627d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e066f8222590e985d890be4ba622d924cde7627d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9432626b686782f87e54960a4c019fd7c83ad7f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9432626b686782f87e54960a4c019fd7c83ad7f7", "html_url": "https://github.com/rust-lang/rust/commit/9432626b686782f87e54960a4c019fd7c83ad7f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9432626b686782f87e54960a4c019fd7c83ad7f7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b2cfcaab9cb55f8d0840d42ba5f337b14eace21", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b2cfcaab9cb55f8d0840d42ba5f337b14eace21", "html_url": "https://github.com/rust-lang/rust/commit/0b2cfcaab9cb55f8d0840d42ba5f337b14eace21"}], "stats": {"total": 113, "additions": 54, "deletions": 59}, "files": [{"sha": "024315805ddcf5624031ebb1ba6c96e48a1ba24d", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9432626b686782f87e54960a4c019fd7c83ad7f7/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9432626b686782f87e54960a4c019fd7c83ad7f7/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=9432626b686782f87e54960a4c019fd7c83ad7f7", "patch": "@@ -5,107 +5,102 @@ import std.option;\n import std.option.some;\n import std.option.none;\n import std._int;\n+import std._vec;\n import util.common;\n \n type fn_id_of_local = std.map.hashmap[ast.def_id, ast.def_id];\n-type env = rec(option.t[ast.def_id] current_context, // fn or obj\n+type env = rec(mutable vec[ast.def_id] current_context, // fn or obj\n                fn_id_of_local idmap,\n                session.session sess);\n \n-fn update_env_for_item(&env e, @ast.item i) -> env {\n+fn current_context(&env e) -> ast.def_id {\n+    ret e.current_context.(_vec.len(e.current_context) - 1u);\n+}\n+\n+fn enter_item(@env e, @ast.item i) {\n     alt (i.node) {\n         case (ast.item_fn(?name, _, _, ?id, _)) {\n-            ret rec(current_context = some(id) with e);\n+            _vec.push(e.current_context, id);\n         }\n         case (ast.item_obj(_, _, _, ?ids, _)) {\n-            ret rec(current_context = some(ids.ty) with e);\n+            _vec.push(e.current_context, ids.ty);\n+        }\n+        case (_) {}\n+    }\n+}\n+\n+fn leave_item(@env e, @ast.item i) {\n+    alt (i.node) {\n+        case (ast.item_fn(?name, _, _, ?id, _)) {\n+            _vec.pop(e.current_context);\n         }\n-        case (_) {\n-            ret e;\n+        case (ast.item_obj(_, _, _, ?ids, _)) {\n+            _vec.pop(e.current_context);\n         }\n+        case (_) {}\n     }\n }\n \n-fn update_env_for_expr(&env e, @ast.expr x) -> env {\n+fn walk_expr(@env e, @ast.expr x) {\n     alt (x.node) {\n         case (ast.expr_for(?d, _, _, _)) {\n             alt (d.node) {\n                 case (ast.decl_local(?local)) {\n-                    auto curr_context =\n-                        option.get[ast.def_id](e.current_context);\n-                    e.idmap.insert(local.id, curr_context);\n-                }\n-                case (_) {\n+                    e.idmap.insert(local.id, current_context(*e));\n                 }\n+                case (_) { }\n             }\n         }\n         case (ast.expr_for_each(?d, _, _, _)) {\n             alt (d.node) {\n                 case (ast.decl_local(?local)) {\n-                    auto curr_context =\n-                        option.get[ast.def_id](e.current_context);\n-                    e.idmap.insert(local.id, curr_context);\n-                }\n-                case (_) {\n+                    e.idmap.insert(local.id, current_context(*e));\n                 }\n+                case (_) { }\n+            }\n+        }\n+        case (ast.expr_path(_, ?def, _)) {\n+            auto local_id;\n+            alt (option.get(def)) {\n+                case (ast.def_local(?id)) { local_id = id; }\n+                case (_) { ret; }\n+            }\n+\n+            auto df = ast.def_id_of_def(option.get(def));\n+            auto def_context = option.get(e.idmap.find(df));\n+\n+            if (current_context(*e) != def_context) {\n+                e.sess.span_err(x.span,\n+                                \"attempted dynamic environment-capture\");\n             }\n         }\n         case (_) { }\n     }\n-    ret e;\n }\n \n-fn update_env_for_block(&env e, &ast.block b) -> env {\n-    auto curr_context = option.get[ast.def_id](e.current_context);\n-\n+fn walk_block(@env e, &ast.block b) {\n     for each (@tup(ast.ident, ast.block_index_entry) it in\n               b.node.index.items()) {\n         alt (it._1) {\n             case (ast.bie_local(?local)) {\n-                e.idmap.insert(local.id, curr_context);\n-            }\n-            case (_) {\n+                e.idmap.insert(local.id, current_context(*e));\n             }\n+            case (_) { }\n         }\n     }\n-\n-    ret e;\n-}\n-\n-fn fold_expr_path(&env e, &ast.span sp, &ast.path p, &option.t[ast.def] d,\n-                  ast.ann a) -> @ast.expr {\n-    auto local_id;\n-    alt (option.get[ast.def](d)) {\n-        case (ast.def_local(?id)) {\n-            local_id = id;\n-        }\n-        case (_) {\n-            ret @fold.respan[ast.expr_](sp, ast.expr_path(p, d, a));\n-        }\n-    }\n-\n-    auto curr_context = option.get[ast.def_id](e.current_context);\n-    auto x = ast.def_id_of_def(option.get[ast.def](d));\n-    auto def_context = option.get[ast.def_id](e.idmap.find(x));\n-\n-    if (curr_context != def_context) {\n-        e.sess.span_err(sp, \"attempted dynamic environment-capture\");\n-    }\n-\n-    ret @fold.respan[ast.expr_](sp, ast.expr_path(p, d, a));\n }\n \n fn check_for_captures(session.session sess, @ast.crate crate) {\n-    let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n-    fld = @rec( update_env_for_item = bind update_env_for_item(_,_),\n-                update_env_for_block = bind update_env_for_block(_,_),\n-                update_env_for_expr = bind update_env_for_expr(_,_),\n-                fold_expr_path = bind fold_expr_path(_,_,_,_,_)\n-                with *fld);\n-    auto idmap = common.new_def_hash[ast.def_id]();\n-    auto e = rec(current_context = none[ast.def_id], idmap = idmap,\n-                 sess = sess);\n-    fold.fold_crate[env](e, fld, crate);\n+    let vec[ast.def_id] curctx = vec();\n+    auto env = @rec(mutable current_context = curctx,\n+                    idmap = common.new_def_hash[ast.def_id](),\n+                    sess = sess);\n+    auto visitor = rec(visit_item_pre = bind enter_item(env, _),\n+                       visit_item_post = bind leave_item(env, _),\n+                       visit_block_pre = bind walk_block(env, _),\n+                       visit_expr_pre = bind walk_expr(env, _)\n+                       with walk.default_visitor());\n+    walk.walk_crate(visitor, *crate);\n }\n \n // Local Variables:"}]}