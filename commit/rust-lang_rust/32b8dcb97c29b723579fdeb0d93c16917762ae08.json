{"sha": "32b8dcb97c29b723579fdeb0d93c16917762ae08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYjhkY2I5N2MyOWI3MjM1NzlmZGViMGQ5M2MxNjkxNzc2MmFlMDg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T20:58:13Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T20:58:13Z"}, "message": "rustc: Factor out the code that interns types into an \"interner\" data structure", "tree": {"sha": "08072f5337debd3fcb516cbda7d09cc13bff495f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08072f5337debd3fcb516cbda7d09cc13bff495f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32b8dcb97c29b723579fdeb0d93c16917762ae08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32b8dcb97c29b723579fdeb0d93c16917762ae08", "html_url": "https://github.com/rust-lang/rust/commit/32b8dcb97c29b723579fdeb0d93c16917762ae08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32b8dcb97c29b723579fdeb0d93c16917762ae08/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3760bfab87498d71f9341ffac1aa027f26028656", "url": "https://api.github.com/repos/rust-lang/rust/commits/3760bfab87498d71f9341ffac1aa027f26028656", "html_url": "https://github.com/rust-lang/rust/commit/3760bfab87498d71f9341ffac1aa027f26028656"}], "stats": {"total": 97, "additions": 61, "deletions": 36}, "files": [{"sha": "1c947e693efdd3de0b5e031fa124e42922c2d3a3", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/32b8dcb97c29b723579fdeb0d93c16917762ae08/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b8dcb97c29b723579fdeb0d93c16917762ae08/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=32b8dcb97c29b723579fdeb0d93c16917762ae08", "patch": "@@ -33,6 +33,8 @@ import util::common::new_def_hash;\n import util::common::span;\n import util::typestate_ann::ts_ann;\n \n+import util::interner;\n+\n // Data types\n \n tag mode {\n@@ -159,19 +161,14 @@ const uint idx_native   = 18u;\n const uint idx_type     = 19u;\n const uint idx_first_others = 20u;\n \n-type type_store = rec(mutable vec[raw_t] others,\n-                      hashmap[raw_t,uint] other_structural);\n+type type_store = interner::interner[raw_t];\n \n type ty_param_substs_opt_and_ty = tup(option::t[vec[ty::t]], ty::t);\n type node_type_table =\n     @mutable vec[mutable option::t[ty::ty_param_substs_opt_and_ty]];\n \n fn mk_type_store() -> @type_store {\n-    let vec[raw_t] others = vec();\n-    let hashmap[raw_t,uint] ost =\n-        map::mk_hashmap[raw_t,uint](hash_raw_ty, eq_raw_ty);\n-\n-    auto ts = @rec(mutable others=others, other_structural=ost);\n+    auto ts = @interner::mk_interner[raw_t](hash_raw_ty, eq_raw_ty);\n \n     intern(ts, ty_nil, none[str]);\n     intern(ts, ty_bool, none[str]);\n@@ -194,7 +191,7 @@ fn mk_type_store() -> @type_store {\n     intern(ts, ty_native, none[str]);\n     intern(ts, ty_type, none[str]);\n \n-    assert _vec::len(ts.others) == idx_first_others;\n+    assert _vec::len(ts.vect) == idx_first_others;\n \n     ret ts;\n }\n@@ -240,7 +237,7 @@ fn mk_raw_ty(&@type_store ts, &sty st, &option::t[str] cname) -> raw_t {\n                       &mutable bool has_vars,\n                       &mutable bool has_locals,\n                       &t tt) {\n-        auto rt = ts.others.(tt);\n+        auto rt = interner::get[raw_t](*ts, tt);\n         has_params = has_params || rt.has_params;\n         has_bound_params = has_bound_params || rt.has_bound_params;\n         has_vars = has_vars || rt.has_vars;\n@@ -355,32 +352,13 @@ fn mk_raw_ty(&@type_store ts, &sty st, &option::t[str] cname) -> raw_t {\n             has_locals = has_locals);\n }\n \n-fn intern_raw_ty(&@type_store ts, &raw_t rt) {\n-    auto type_num = _vec::len[raw_t](ts.others);\n-    ts.others += vec(rt);\n-    ts.other_structural.insert(rt, type_num);\n-}\n-\n fn intern(&@type_store ts, &sty st, &option::t[str] cname) {\n-    intern_raw_ty(ts, mk_raw_ty(ts, st, cname));\n+    interner::intern[raw_t](*ts, mk_raw_ty(ts, st, cname));\n }\n \n fn gen_ty_full(&ctxt cx, &sty st, &option::t[str] cname) -> t {\n     auto raw_type = mk_raw_ty(cx.ts, st, cname);\n-\n-    // Is it interned?\n-    alt (cx.ts.other_structural.find(raw_type)) {\n-        case (some[t](?typ)) {\n-            ret typ;\n-        }\n-        case (none[t]) {\n-            // Nope: Insert it and return.\n-            auto type_num = _vec::len[raw_t](cx.ts.others);\n-            intern_raw_ty(cx.ts, raw_type);\n-            // log_err \"added: \" + ty_to_str(tystore, raw_type);\n-            ret type_num;\n-        }\n-    }\n+    ret interner::intern[raw_t](*cx.ts, raw_type);\n }\n \n // These are private constructors to this module. External users should always\n@@ -484,10 +462,14 @@ fn mk_native(&ctxt cx) -> t  { ret idx_native; }\n \n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(&ctxt cx, &t typ) -> sty { ret cx.ts.others.(typ).struct; }\n+fn struct(&ctxt cx, &t typ) -> sty {\n+    ret interner::get[raw_t](*cx.ts, typ).struct;\n+}\n \n // Returns the canonical name of the given type.\n-fn cname(&ctxt cx, &t typ) -> option::t[str] { ret cx.ts.others.(typ).cname; }\n+fn cname(&ctxt cx, &t typ) -> option::t[str] {\n+    ret interner::get[raw_t](*cx.ts, typ).cname;\n+}\n \n \n // Stringification\n@@ -1525,19 +1507,19 @@ fn count_ty_params(ctxt cx, t ty) -> uint {\n }\n \n fn type_contains_vars(&ctxt cx, &t typ) -> bool {\n-    ret cx.ts.others.(typ).has_vars;\n+    ret interner::get[raw_t](*cx.ts, typ).has_vars;\n }\n \n fn type_contains_locals(&ctxt cx, &t typ) -> bool {\n-    ret cx.ts.others.(typ).has_locals;\n+    ret interner::get[raw_t](*cx.ts, typ).has_locals;\n }\n \n fn type_contains_params(&ctxt cx, &t typ) -> bool {\n-    ret cx.ts.others.(typ).has_params;\n+    ret interner::get[raw_t](*cx.ts, typ).has_params;\n }\n \n fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n-    ret cx.ts.others.(typ).has_bound_params;\n+    ret interner::get[raw_t](*cx.ts, typ).has_bound_params;\n }\n \n // Type accessors for substructures of types"}, {"sha": "78c228c5bb2b18a1ac6c068f9f096bd4fe9fd871", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32b8dcb97c29b723579fdeb0d93c16917762ae08/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/32b8dcb97c29b723579fdeb0d93c16917762ae08/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=32b8dcb97c29b723579fdeb0d93c16917762ae08", "patch": "@@ -52,6 +52,7 @@ mod driver {\n \n mod util {\n     mod common;\n+    mod interner;\n     mod typestate_ann;\n }\n "}, {"sha": "a9bf9bc4e33314535a2914e1d32cfea99282cf3a", "filename": "src/comp/util/interner.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/32b8dcb97c29b723579fdeb0d93c16917762ae08/src%2Fcomp%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b8dcb97c29b723579fdeb0d93c16917762ae08/src%2Fcomp%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Finterner.rs?ref=32b8dcb97c29b723579fdeb0d93c16917762ae08", "patch": "@@ -0,0 +1,42 @@\n+// An \"interner\" is a data structure that associates values with uint tags and\n+// allows bidirectional lookup; i.e. given a value, one can easily find the\n+// type, and vice versa.\n+\n+import std::_vec;\n+import std::map;\n+import std::map::hashmap;\n+import std::map::hashfn;\n+import std::map::eqfn;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+\n+type interner[T] = rec(\n+    hashmap[T,uint] map,\n+    mutable vec[T] vect,\n+    hashfn[T] hasher,\n+    eqfn[T] eqer\n+);\n+\n+fn mk_interner[T](hashfn[T] hasher, eqfn[T] eqer) -> interner[T] {\n+    auto m = map::mk_hashmap[T,uint](hasher, eqer);\n+    let vec[T] vect = vec();\n+    ret rec(map=m, mutable vect=vect, hasher=hasher, eqer=eqer);\n+}\n+\n+fn intern[T](&interner[T] itr, &T val) -> uint {\n+    alt (itr.map.find(val)) {\n+        case (some[uint](?idx)) { ret idx; }\n+        case (none[uint]) {\n+            auto new_idx = _vec::len[T](itr.vect);\n+            itr.map.insert(val, new_idx);\n+            itr.vect += vec(val);\n+            ret new_idx;\n+        }\n+    }\n+}\n+\n+fn get[T](&interner[T] itr, uint idx) -> T {\n+    ret itr.vect.(idx);\n+}\n+"}]}