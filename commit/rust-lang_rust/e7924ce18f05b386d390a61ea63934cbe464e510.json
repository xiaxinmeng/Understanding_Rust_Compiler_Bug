{"sha": "e7924ce18f05b386d390a61ea63934cbe464e510", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3OTI0Y2UxOGYwNWIzODZkMzkwYTYxZWE2MzkzNGNiZTQ2NGU1MTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-22T02:27:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-22T02:27:32Z"}, "message": "auto merge of #5076 : pcwalton/rust/demuting, r=pcwalton", "tree": {"sha": "5b3611b98be0fd9f5ee8f6dd2a2b7453a7417fa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b3611b98be0fd9f5ee8f6dd2a2b7453a7417fa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7924ce18f05b386d390a61ea63934cbe464e510", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7924ce18f05b386d390a61ea63934cbe464e510", "html_url": "https://github.com/rust-lang/rust/commit/e7924ce18f05b386d390a61ea63934cbe464e510", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7924ce18f05b386d390a61ea63934cbe464e510/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5cc0b98308531db44a5c1cb15c08f4fc909c41c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5cc0b98308531db44a5c1cb15c08f4fc909c41c", "html_url": "https://github.com/rust-lang/rust/commit/f5cc0b98308531db44a5c1cb15c08f4fc909c41c"}, {"sha": "91479363ccc4ee26aadfb3d2bc3b4868ba426ebd", "url": "https://api.github.com/repos/rust-lang/rust/commits/91479363ccc4ee26aadfb3d2bc3b4868ba426ebd", "html_url": "https://github.com/rust-lang/rust/commit/91479363ccc4ee26aadfb3d2bc3b4868ba426ebd"}], "stats": {"total": 644, "additions": 354, "deletions": 290}, "files": [{"sha": "9c5e4b9f0e08638f14df88dcae041499dbaef7e3", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 223, "deletions": 173, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -150,7 +150,7 @@ pub enum NamespaceResult {\n     UnboundResult,\n     /// Means that resolve has determined that the name is bound in the Module\n     /// argument, and specified by the NameBindings argument.\n-    BoundResult(@Module, @mut NameBindings)\n+    BoundResult(@mut Module, @mut NameBindings)\n }\n \n pub impl NamespaceResult {\n@@ -196,7 +196,7 @@ pub enum ImportDirectiveSubclass {\n \n /// The context that we thread through while building the reduced graph.\n pub enum ReducedGraphParent {\n-    ModuleReducedGraphParent(@Module)\n+    ModuleReducedGraphParent(@mut Module)\n }\n \n pub enum ResolveResult<T> {\n@@ -293,7 +293,7 @@ pub enum SearchThroughModulesFlag {\n \n pub enum ModulePrefixResult {\n     NoPrefixFound,\n-    PrefixFound(@Module, uint)\n+    PrefixFound(@mut Module, uint)\n }\n \n #[deriving_eq]\n@@ -368,11 +368,13 @@ pub fn ImportDirective(privacy: Privacy,\n \n /// The item that an import resolves to.\n pub struct Target {\n-    target_module: @Module,\n+    target_module: @mut Module,\n     bindings: @mut NameBindings,\n }\n \n-pub fn Target(target_module: @Module, bindings: @mut NameBindings) -> Target {\n+pub fn Target(target_module: @mut Module,\n+              bindings: @mut NameBindings)\n+           -> Target {\n     Target {\n         target_module: target_module,\n         bindings: bindings\n@@ -435,8 +437,8 @@ pub fn ImportState() -> ImportState {\n /// The link from a module up to its nearest parent node.\n pub enum ParentLink {\n     NoParentLink,\n-    ModuleParentLink(@Module, ident),\n-    BlockParentLink(@Module, node_id)\n+    ModuleParentLink(@mut Module, ident),\n+    BlockParentLink(@mut Module, node_id)\n }\n \n /// The type of module this is.\n@@ -450,11 +452,11 @@ pub enum ModuleKind {\n /// One node in the tree of modules.\n pub struct Module {\n     parent_link: ParentLink,\n-    mut def_id: Option<def_id>,\n+    def_id: Option<def_id>,\n     kind: ModuleKind,\n \n-    children: HashMap<ident,@mut NameBindings>,\n-    imports: DVec<@ImportDirective>,\n+    children: @HashMap<ident,@mut NameBindings>,\n+    imports: @DVec<@ImportDirective>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -471,16 +473,16 @@ pub struct Module {\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n \n-    anonymous_children: HashMap<node_id,@Module>,\n+    anonymous_children: @HashMap<node_id,@mut Module>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: HashMap<ident,@mut ImportResolution>,\n+    import_resolutions: @HashMap<ident,@mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n-    mut glob_count: uint,\n+    glob_count: uint,\n \n     // The index of the import we're resolving.\n-    mut resolved_import_count: uint,\n+    resolved_import_count: uint,\n }\n \n pub fn Module(parent_link: ParentLink,\n@@ -491,10 +493,10 @@ pub fn Module(parent_link: ParentLink,\n         parent_link: parent_link,\n         def_id: def_id,\n         kind: kind,\n-        children: HashMap(),\n-        imports: DVec(),\n-        anonymous_children: HashMap(),\n-        import_resolutions: HashMap(),\n+        children: @HashMap(),\n+        imports: @DVec(),\n+        anonymous_children: @HashMap(),\n+        import_resolutions: @HashMap(),\n         glob_count: 0,\n         resolved_import_count: 0\n     }\n@@ -519,7 +521,7 @@ pub fn unused_import_lint_level(session: Session) -> level {\n // Records a possibly-private type definition.\n pub struct TypeNsDef {\n     privacy: Privacy,\n-    module_def: Option<@Module>,\n+    module_def: Option<@mut Module>,\n     type_def: Option<def>\n }\n \n@@ -550,7 +552,7 @@ pub impl NameBindings {\n                      kind: ModuleKind,\n                      sp: span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let module_ = @Module(parent_link, def_id, kind);\n+        let module_ = @mut Module(parent_link, def_id, kind);\n         match self.type_def {\n             None => {\n                 self.type_def = Some(TypeNsDef {\n@@ -599,7 +601,7 @@ pub impl NameBindings {\n     }\n \n     /// Returns the module node if applicable.\n-    fn get_module_if_available() -> Option<@Module> {\n+    fn get_module_if_available() -> Option<@mut Module> {\n         match self.type_def {\n             Some(ref type_def) => (*type_def).module_def,\n             None => None\n@@ -610,7 +612,7 @@ pub impl NameBindings {\n      * Returns the module node. Fails if this node does not have a module\n      * definition.\n      */\n-    fn get_module(@mut self) -> @Module {\n+    fn get_module(@mut self) -> @mut Module {\n         match self.get_module_if_available() {\n             None => {\n                 fail!(~\"get_module called on a node with no module \\\n@@ -759,7 +761,7 @@ pub fn Resolver(session: Session,\n     let current_module = graph_root.get_module();\n \n     let self = Resolver {\n-        session: session,\n+        session: @session,\n         lang_items: copy lang_items,\n         crate: crate,\n \n@@ -770,8 +772,8 @@ pub fn Resolver(session: Session,\n \n         unused_import_lint_level: unused_import_lint_level(session),\n \n-        trait_info: HashMap(),\n-        structs: HashMap(),\n+        trait_info: @HashMap(),\n+        structs: @HashMap(),\n \n         unresolved_imports: 0,\n \n@@ -794,8 +796,8 @@ pub fn Resolver(session: Session,\n         attr_main_fn: None,\n         main_fns: ~[],\n \n-        def_map: HashMap(),\n-        export_map2: HashMap(),\n+        def_map: @HashMap(),\n+        export_map2: @HashMap(),\n         trait_map: @HashMap(),\n \n         intr: session.intr()\n@@ -806,7 +808,7 @@ pub fn Resolver(session: Session,\n \n /// The main resolver class.\n pub struct Resolver {\n-    session: Session,\n+    session: @Session,\n     lang_items: LanguageItems,\n     crate: @crate,\n \n@@ -816,14 +818,14 @@ pub struct Resolver {\n \n     unused_import_lint_level: level,\n \n-    trait_info: HashMap<def_id,@HashMap<ident,()>>,\n-    structs: HashMap<def_id,()>,\n+    trait_info: @HashMap<def_id,@HashMap<ident,()>>,\n+    structs: @HashMap<def_id,()>,\n \n     // The number of imports that are currently unresolved.\n-    mut unresolved_imports: uint,\n+    unresolved_imports: uint,\n \n     // The module that represents the current item scope.\n-    mut current_module: @Module,\n+    current_module: @mut Module,\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n@@ -837,10 +839,10 @@ pub struct Resolver {\n \n     // Whether the current context is an X-ray context. An X-ray context is\n     // allowed to access private names of any module.\n-    mut xray_context: XrayFlag,\n+    xray_context: XrayFlag,\n \n     // The trait that the current context can refer to.\n-    mut current_trait_refs: Option<@DVec<def_id>>,\n+    current_trait_refs: Option<@DVec<def_id>>,\n \n     // The ident for the keyword \"self\".\n     self_ident: ident,\n@@ -854,19 +856,19 @@ pub struct Resolver {\n     namespaces: ~[Namespace],\n \n     // The function that has attribute named 'main'\n-    mut attr_main_fn: Option<(node_id, span)>,\n+    attr_main_fn: Option<(node_id, span)>,\n     // The functions named 'main'\n-    mut main_fns: ~[Option<(node_id, span)>],\n+    main_fns: ~[Option<(node_id, span)>],\n \n-    def_map: DefMap,\n-    export_map2: ExportMap2,\n+    def_map: @DefMap,\n+    export_map2: @ExportMap2,\n     trait_map: TraitMap,\n }\n \n pub impl Resolver {\n     /// The main name resolution procedure.\n-    fn resolve(@self, this: @Resolver) {\n-        self.build_reduced_graph(this);\n+    fn resolve(@mut self) {\n+        self.build_reduced_graph();\n         self.session.abort_if_errors();\n \n         self.resolve_imports();\n@@ -890,25 +892,25 @@ pub impl Resolver {\n     //\n \n     /// Constructs the reduced graph for the entire crate.\n-    fn build_reduced_graph(this: @Resolver) {\n+    fn build_reduced_graph(@mut self) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n         visit_crate(*self.crate, initial_parent, mk_vt(@Visitor {\n             visit_item: |item, context, visitor|\n-                (*this).build_reduced_graph_for_item(item, context, visitor),\n+                self.build_reduced_graph_for_item(item, context, visitor),\n \n             visit_foreign_item: |foreign_item, context, visitor|\n-                (*this).build_reduced_graph_for_foreign_item(foreign_item,\n+                self.build_reduced_graph_for_foreign_item(foreign_item,\n                                                              context,\n                                                              visitor),\n \n             visit_view_item: |view_item, context, visitor|\n-                (*this).build_reduced_graph_for_view_item(view_item,\n+                self.build_reduced_graph_for_view_item(view_item,\n                                                           context,\n                                                           visitor),\n \n             visit_block: |block, context, visitor|\n-                (*this).build_reduced_graph_for_block(block,\n+                self.build_reduced_graph_for_block(block,\n                                                       context,\n                                                       visitor),\n \n@@ -917,8 +919,9 @@ pub impl Resolver {\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n-    fn get_module_from_parent(reduced_graph_parent: ReducedGraphParent)\n-                           -> @Module {\n+    fn get_module_from_parent(@mut self,\n+                              reduced_graph_parent: ReducedGraphParent)\n+                           -> @mut Module {\n         match reduced_graph_parent {\n             ModuleReducedGraphParent(module_) => {\n                 return module_;\n@@ -936,7 +939,8 @@ pub impl Resolver {\n      * If this node does not have a module definition and we are not inside\n      * a block, fails.\n      */\n-    fn add_child(name: ident,\n+    fn add_child(@mut self,\n+                 name: ident,\n                  reduced_graph_parent: ReducedGraphParent,\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n@@ -1023,7 +1027,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn block_needs_anonymous_module(block: blk) -> bool {\n+    fn block_needs_anonymous_module(@mut self, block: blk) -> bool {\n         // If the block has view items, we need an anonymous module.\n         if block.node.view_items.len() > 0 {\n             return true;\n@@ -1054,8 +1058,10 @@ pub impl Resolver {\n         return false;\n     }\n \n-    fn get_parent_link(parent: ReducedGraphParent,\n-                       name: ident) -> ParentLink {\n+    fn get_parent_link(@mut self,\n+                       parent: ReducedGraphParent,\n+                       name: ident)\n+                    -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n                 return ModuleParentLink(module_, name);\n@@ -1064,7 +1070,8 @@ pub impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(item: @item,\n+    fn build_reduced_graph_for_item(@mut self,\n+                                    item: @item,\n                                     parent: ReducedGraphParent,\n                                     &&visitor: vt<ReducedGraphParent>) {\n         let ident = item.ident;\n@@ -1339,12 +1346,12 @@ pub impl Resolver {\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n     // type and/or value namespaces.\n-    fn build_reduced_graph_for_variant(variant: variant,\n+    fn build_reduced_graph_for_variant(@mut self,\n+                                       variant: variant,\n                                        item_id: def_id,\n                                        +parent_privacy: Privacy,\n                                        parent: ReducedGraphParent,\n                                        &&visitor: vt<ReducedGraphParent>) {\n-\n         let ident = variant.node.name;\n         let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                         variant.span);\n@@ -1387,7 +1394,8 @@ pub impl Resolver {\n      * Constructs the reduced graph for one 'view item'. View items consist\n      * of imports and use directives.\n      */\n-    fn build_reduced_graph_for_view_item(view_item: @view_item,\n+    fn build_reduced_graph_for_view_item(@mut self,\n+                                         view_item: @view_item,\n                                          parent: ReducedGraphParent,\n                                          &&_visitor: vt<ReducedGraphParent>) {\n         let privacy = visibility_to_privacy(view_item.vis);\n@@ -1495,11 +1503,11 @@ pub impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(foreign_item: @foreign_item,\n+    fn build_reduced_graph_for_foreign_item(@mut self,\n+                                            foreign_item: @foreign_item,\n                                             parent: ReducedGraphParent,\n                                             &&visitor:\n                                                 vt<ReducedGraphParent>) {\n-\n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n             self.add_child(name, parent, ForbidDuplicateValues,\n@@ -1525,10 +1533,10 @@ pub impl Resolver {\n         }\n     }\n \n-    fn build_reduced_graph_for_block(block: blk,\n+    fn build_reduced_graph_for_block(@mut self,\n+                                     block: blk,\n                                      parent: ReducedGraphParent,\n                                      &&visitor: vt<ReducedGraphParent>) {\n-\n         let mut new_parent;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n@@ -1538,9 +1546,10 @@ pub impl Resolver {\n                    block_id);\n \n             let parent_module = self.get_module_from_parent(parent);\n-            let new_module = @Module(BlockParentLink(parent_module, block_id),\n-                                     None,\n-                                     AnonymousModuleKind);\n+            let new_module = @mut Module(\n+                BlockParentLink(parent_module, block_id),\n+                None,\n+                AnonymousModuleKind);\n             parent_module.anonymous_children.insert(block_id, new_module);\n             new_parent = ModuleReducedGraphParent(new_module);\n         } else {\n@@ -1550,8 +1559,9 @@ pub impl Resolver {\n         visit_block(block, new_parent, visitor);\n     }\n \n-    fn handle_external_def(def: def,\n-                           modules: HashMap<def_id, @Module>,\n+    fn handle_external_def(@mut self,\n+                           def: def,\n+                           modules: HashMap<def_id, @mut Module>,\n                            child_name_bindings: @mut NameBindings,\n                            final_ident: &str,\n                            ident: ident,\n@@ -1671,7 +1681,7 @@ pub impl Resolver {\n      * Builds the reduced graph rooted at the 'use' directive for an external\n      * crate.\n      */\n-    fn build_reduced_graph_for_external_crate(root: @Module) {\n+    fn build_reduced_graph_for_external_crate(@mut self, root: @mut Module) {\n         let modules = HashMap();\n \n         // Create all the items reachable by paths.\n@@ -1842,8 +1852,9 @@ pub impl Resolver {\n     }\n \n     /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(privacy: Privacy,\n-                              module_: @Module,\n+    fn build_import_directive(@mut self,\n+                              privacy: Privacy,\n+                              module_: @mut Module,\n                               module_path: @DVec<ident>,\n                               subclass: @ImportDirectiveSubclass,\n                               span: span,\n@@ -1908,7 +1919,7 @@ pub impl Resolver {\n      * Resolves all imports for the crate. This method performs the fixed-\n      * point iteration.\n      */\n-    fn resolve_imports() {\n+    fn resolve_imports(@mut self) {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n@@ -1938,7 +1949,7 @@ pub impl Resolver {\n      * Attempts to resolve imports for the given module and all of its\n      * submodules.\n      */\n-    fn resolve_imports_for_module_subtree(module_: @Module) {\n+    fn resolve_imports_for_module_subtree(@mut self, module_: @mut Module) {\n         debug!(\"(resolving imports for module subtree) resolving %s\",\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n@@ -1960,7 +1971,7 @@ pub impl Resolver {\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(module_: @Module) {\n+    fn resolve_imports_for_module(@mut self, module_: @mut Module) {\n         if (*module_).all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for \\\n                    %s\",\n@@ -1994,23 +2005,26 @@ pub impl Resolver {\n         }\n     }\n \n-    fn idents_to_str(idents: ~[ident]) -> ~str {\n+    fn idents_to_str(@mut self, idents: ~[ident]) -> ~str {\n         let ident_strs = do idents.map |ident| {\n             /*bad*/ copy *self.session.str_of(*ident)\n         };\n         str::connect(ident_strs, \"::\")\n     }\n \n-    fn import_directive_subclass_to_str(subclass: ImportDirectiveSubclass)\n-                                                                    -> @~str {\n+    fn import_directive_subclass_to_str(@mut self,\n+                                        subclass: ImportDirectiveSubclass)\n+                                     -> @~str {\n         match subclass {\n             SingleImport(_target, source, _ns) => self.session.str_of(source),\n             GlobImport => @~\"*\"\n         }\n     }\n \n-    fn import_path_to_str(idents: ~[ident], subclass: ImportDirectiveSubclass)\n-                                                                    -> @~str {\n+    fn import_path_to_str(@mut self,\n+                          idents: ~[ident],\n+                          subclass: ImportDirectiveSubclass)\n+                       -> @~str {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n@@ -2027,10 +2041,10 @@ pub impl Resolver {\n      * currently-unresolved imports, or success if we know the name exists.\n      * If successful, the resolved bindings are written into the module.\n      */\n-    fn resolve_import_for_module(module_: @Module,\n+    fn resolve_import_for_module(@mut self,\n+                                 module_: @mut Module,\n                                  import_directive: @ImportDirective)\n                               -> ResolveResult<()> {\n-\n         let mut resolution_result;\n         let module_path = import_directive.module_path;\n \n@@ -2122,12 +2136,12 @@ pub impl Resolver {\n         return resolution_result;\n     }\n \n-    fn resolve_single_import(module_: @Module,\n-                             containing_module: @Module,\n+    fn resolve_single_import(@mut self,\n+                             module_: @mut Module,\n+                             containing_module: @mut Module,\n                              target: ident,\n                              source: ident)\n                           -> ResolveResult<()> {\n-\n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n                *self.session.str_of(target),\n@@ -2314,12 +2328,12 @@ pub impl Resolver {\n         return Success(());\n     }\n \n-    fn resolve_single_module_import(module_: @Module,\n-                                    containing_module: @Module,\n+    fn resolve_single_module_import(@mut self,\n+                                    module_: @mut Module,\n+                                    containing_module: @mut Module,\n                                     target: ident,\n                                     source: ident)\n                                  -> ResolveResult<()> {\n-\n         debug!(\"(resolving single module import) resolving `%s` = `%s::%s` \\\n                 from `%s`\",\n                *self.session.str_of(target),\n@@ -2443,9 +2457,10 @@ pub impl Resolver {\n      * succeeds or bails out (as importing * from an empty module or a module\n      * that exports nothing is valid).\n      */\n-    fn resolve_glob_import(privacy: Privacy,\n-                           module_: @Module,\n-                           containing_module: @Module,\n+    fn resolve_glob_import(@mut self,\n+                           privacy: Privacy,\n+                           module_: @mut Module,\n+                           containing_module: @mut Module,\n                            span: span)\n                         -> ResolveResult<()> {\n         // This function works in a highly imperative manner; it eagerly adds\n@@ -2557,11 +2572,12 @@ pub impl Resolver {\n         return Success(());\n     }\n \n-    fn resolve_module_path_from_root(module_: @Module,\n+    fn resolve_module_path_from_root(@mut self,\n+                                     module_: @mut Module,\n                                      module_path: @DVec<ident>,\n                                      index: uint,\n                                      span: span)\n-                                  -> ResolveResult<@Module> {\n+                                  -> ResolveResult<@mut Module> {\n         let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = (*module_path).len();\n@@ -2629,12 +2645,12 @@ pub impl Resolver {\n      * Attempts to resolve the module part of an import directive or path\n      * rooted at the given module.\n      */\n-    fn resolve_module_path_for_import(module_: @Module,\n+    fn resolve_module_path_for_import(@mut self,\n+                                      module_: @mut Module,\n                                       module_path: @DVec<ident>,\n                                       use_lexical_scope: UseLexicalScopeFlag,\n                                       span: span)\n-                                   -> ResolveResult<@Module> {\n-\n+                                   -> ResolveResult<@mut Module> {\n         let module_path_len = (*module_path).len();\n         assert module_path_len > 0;\n \n@@ -2708,13 +2724,13 @@ pub impl Resolver {\n                                                   span);\n     }\n \n-    fn resolve_item_in_lexical_scope(module_: @Module,\n+    fn resolve_item_in_lexical_scope(@mut self,\n+                                     module_: @mut Module,\n                                      name: ident,\n                                      namespace: Namespace,\n                                      search_through_modules:\n                                         SearchThroughModulesFlag)\n                                   -> ResolveResult<Target> {\n-\n         debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n                *self.session.str_of(name),\n@@ -2822,8 +2838,10 @@ pub impl Resolver {\n     }\n \n     /** Resolves a module name in the current lexical scope. */\n-    fn resolve_module_in_lexical_scope(module_: @Module, name: ident)\n-                                    -> ResolveResult<@Module> {\n+    fn resolve_module_in_lexical_scope(@mut self,\n+                                       module_: @mut Module,\n+                                       name: ident)\n+                                    -> ResolveResult<@mut Module> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n         let resolve_result = self.resolve_item_in_lexical_scope(\n@@ -2867,7 +2885,8 @@ pub impl Resolver {\n     /**\n      * Returns the nearest normal module parent of the given module.\n      */\n-    fn get_nearest_normal_module_parent(module_: @Module) -> Option<@Module> {\n+    fn get_nearest_normal_module_parent(@mut self, module_: @mut Module)\n+                                     -> Option<@mut Module> {\n         let mut module_ = module_;\n         loop {\n             match module_.parent_link {\n@@ -2889,7 +2908,9 @@ pub impl Resolver {\n      * Returns the nearest normal module parent of the given module, or the\n      * module itself if it is a normal module.\n      */\n-    fn get_nearest_normal_module_parent_or_self(module_: @Module) -> @Module {\n+    fn get_nearest_normal_module_parent_or_self(@mut self,\n+                                                module_: @mut Module)\n+                                             -> @mut Module {\n         match module_.kind {\n             NormalModuleKind => return module_,\n             ExternModuleKind | TraitModuleKind | AnonymousModuleKind => {\n@@ -2905,7 +2926,8 @@ pub impl Resolver {\n      * Resolves a \"module prefix\". A module prefix is one of (a) `self::`;\n      * (b) some chain of `super::`.\n      */\n-    fn resolve_module_prefix(module_: @Module,\n+    fn resolve_module_prefix(@mut self,\n+                             module_: @mut Module,\n                              module_path: @DVec<ident>)\n                           -> ResolveResult<ModulePrefixResult> {\n         let interner = self.session.parse_sess.interner;\n@@ -2951,7 +2973,8 @@ pub impl Resolver {\n      * given namespace. If successful, returns the target corresponding to\n      * the name.\n      */\n-    fn resolve_name_in_module(module_: @Module,\n+    fn resolve_name_in_module(@mut self,\n+                              module_: @mut Module,\n                               name: ident,\n                               namespace: Namespace,\n                               allow_globs: bool)\n@@ -3020,10 +3043,10 @@ pub impl Resolver {\n      * This needs special handling, as, unlike all of the other imports, it\n      * needs to look in the scope chain for modules and non-modules alike.\n      */\n-    fn resolve_one_level_renaming_import(module_: @Module,\n+    fn resolve_one_level_renaming_import(@mut self,\n+                                         module_: @mut Module,\n                                          import_directive: @ImportDirective)\n                                       -> ResolveResult<()> {\n-\n         let mut target_name;\n         let mut source_name;\n         let allowable_namespaces;\n@@ -3177,7 +3200,7 @@ pub impl Resolver {\n         return Success(());\n     }\n \n-    fn report_unresolved_imports(module_: @Module) {\n+    fn report_unresolved_imports(@mut self, module_: @mut Module) {\n         let index = module_.resolved_import_count;\n         let import_count = module_.imports.len();\n         if index != import_count {\n@@ -3211,12 +3234,12 @@ pub impl Resolver {\n     // Then this operation can simply be performed as part of item (or import)\n     // processing.\n \n-    fn record_exports() {\n+    fn record_exports(@mut self) {\n         let root_module = self.graph_root.get_module();\n         self.record_exports_for_module_subtree(root_module);\n     }\n \n-    fn record_exports_for_module_subtree(module_: @Module) {\n+    fn record_exports_for_module_subtree(@mut self, module_: @mut Module) {\n         // If this isn't a local crate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n@@ -3258,7 +3281,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn record_exports_for_module(module_: @Module) {\n+    fn record_exports_for_module(@mut self, module_: @mut Module) {\n         let mut exports2 = ~[];\n \n         self.add_exports_for_module(&mut exports2, module_);\n@@ -3272,8 +3295,8 @@ pub impl Resolver {\n         }\n     }\n \n-\n-    fn add_exports_of_namebindings(exports2: &mut ~[Export2],\n+    fn add_exports_of_namebindings(@mut self,\n+                                   exports2: &mut ~[Export2],\n                                    ident: ident,\n                                    namebindings: @mut NameBindings,\n                                    ns: Namespace,\n@@ -3300,7 +3323,9 @@ pub impl Resolver {\n         }\n     }\n \n-    fn add_exports_for_module(exports2: &mut ~[Export2], module_: @Module) {\n+    fn add_exports_for_module(@mut self,\n+                              exports2: &mut ~[Export2],\n+                              module_: @mut Module) {\n         for module_.children.each |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    *self.session.str_of(*ident));\n@@ -3357,7 +3382,7 @@ pub impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(name: Option<ident>, f: fn()) {\n+    fn with_scope(@mut self, name: Option<ident>, f: fn()) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3397,10 +3422,13 @@ pub impl Resolver {\n     // Wraps the given definition in the appropriate number of `def_upvar`\n     // wrappers.\n \n-    fn upvarify(ribs: @DVec<@Rib>, rib_index: uint, def_like: def_like,\n-                span: span, allow_capturing_self: AllowCapturingSelfFlag)\n+    fn upvarify(@mut self,\n+                ribs: @DVec<@Rib>,\n+                rib_index: uint,\n+                def_like: def_like,\n+                span: span,\n+                allow_capturing_self: AllowCapturingSelfFlag)\n              -> Option<def_like> {\n-\n         let mut def;\n         let mut is_ty_param;\n \n@@ -3504,10 +3532,12 @@ pub impl Resolver {\n         return Some(dl_def(def));\n     }\n \n-    fn search_ribs(ribs: @DVec<@Rib>, name: ident, span: span,\n+    fn search_ribs(@mut self,\n+                   ribs: @DVec<@Rib>,\n+                   name: ident,\n+                   span: span,\n                    allow_capturing_self: AllowCapturingSelfFlag)\n                 -> Option<def_like> {\n-\n         // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n@@ -3529,7 +3559,7 @@ pub impl Resolver {\n         return None;\n     }\n \n-    fn resolve_crate(@self) {\n+    fn resolve_crate(@mut self) {\n         debug!(\"(resolving crate) starting\");\n \n         visit_crate(*self.crate, (), mk_vt(@Visitor {\n@@ -3549,7 +3579,7 @@ pub impl Resolver {\n         }));\n     }\n \n-    fn resolve_item(item: @item, visitor: ResolveVisitor) {\n+    fn resolve_item(@mut self, item: @item, visitor: ResolveVisitor) {\n         debug!(\"(resolving item) resolving %s\",\n                *self.session.str_of(item.ident));\n \n@@ -3777,7 +3807,9 @@ pub impl Resolver {\n         self.xray_context = orig_xray_flag;\n     }\n \n-    fn with_type_parameter_rib(type_parameters: TypeParameters, f: fn()) {\n+    fn with_type_parameter_rib(@mut self,\n+                               type_parameters: TypeParameters,\n+                               f: fn()) {\n         match type_parameters {\n             HasTypeParameters(type_parameters, node_id, initial_index,\n                               rib_kind) => {\n@@ -3818,19 +3850,20 @@ pub impl Resolver {\n         }\n     }\n \n-    fn with_label_rib(f: fn()) {\n+    fn with_label_rib(@mut self, f: fn()) {\n         (*self.label_ribs).push(@Rib(NormalRibKind));\n         f();\n         (*self.label_ribs).pop();\n     }\n-    fn with_constant_rib(f: fn()) {\n+\n+    fn with_constant_rib(@mut self, f: fn()) {\n         (*self.value_ribs).push(@Rib(ConstantItemRibKind));\n         f();\n         (*self.value_ribs).pop();\n     }\n \n-\n-    fn resolve_function(rib_kind: RibKind,\n+    fn resolve_function(@mut self,\n+                        rib_kind: RibKind,\n                         optional_declaration: Option<@fn_decl>,\n                         type_parameters: TypeParameters,\n                         block: blk,\n@@ -3906,7 +3939,8 @@ pub impl Resolver {\n         (*self.value_ribs).pop();\n     }\n \n-    fn resolve_type_parameters(type_parameters: ~[ty_param],\n+    fn resolve_type_parameters(@mut self,\n+                               type_parameters: ~[ty_param],\n                                visitor: ResolveVisitor) {\n         for type_parameters.each |type_parameter| {\n             for type_parameter.bounds.each |&bound| {\n@@ -3918,11 +3952,12 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_struct(id: node_id,\n-                     type_parameters: @~[ty_param],\n-                     fields: ~[@struct_field],\n-                     optional_destructor: Option<struct_dtor>,\n-                     visitor: ResolveVisitor) {\n+    fn resolve_struct(@mut self,\n+                      id: node_id,\n+                      type_parameters: @~[ty_param],\n+                      fields: ~[@struct_field],\n+                      optional_destructor: Option<struct_dtor>,\n+                      visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n@@ -3959,7 +3994,8 @@ pub impl Resolver {\n \n     // Does this really need to take a RibKind or is it always going\n     // to be NormalRibKind?\n-    fn resolve_method(rib_kind: RibKind,\n+    fn resolve_method(@mut self,\n+                      rib_kind: RibKind,\n                       method: @method,\n                       outer_type_parameter_count: uint,\n                       visitor: ResolveVisitor) {\n@@ -3984,7 +4020,8 @@ pub impl Resolver {\n                               visitor);\n     }\n \n-    fn resolve_implementation(id: node_id,\n+    fn resolve_implementation(@mut self,\n+                              id: node_id,\n                               span: span,\n                               type_parameters: ~[ty_param],\n                               opt_trait_reference: Option<@trait_ref>,\n@@ -4060,15 +4097,18 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_module(module_: _mod, span: span, _name: ident, id: node_id,\n+    fn resolve_module(@mut self,\n+                      module_: _mod,\n+                      span: span,\n+                      _name: ident,\n+                      id: node_id,\n                       visitor: ResolveVisitor) {\n-\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID %d\", id);\n         visit_mod(module_, span, id, (), visitor);\n     }\n \n-    fn resolve_local(local: @local, visitor: ResolveVisitor) {\n+    fn resolve_local(@mut self, local: @local, visitor: ResolveVisitor) {\n         let mutability = if local.node.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n@@ -4089,9 +4129,9 @@ pub impl Resolver {\n                              None, visitor);\n     }\n \n-    fn binding_mode_map(pat: @pat) -> BindingMap {\n+    fn binding_mode_map(@mut self, pat: @pat) -> BindingMap {\n         let result = HashMap();\n-        do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n+        do pat_bindings(*self.def_map, pat) |binding_mode, _id, sp, path| {\n             let ident = path_to_ident(path);\n             result.insert(ident,\n                           binding_info {span: sp,\n@@ -4100,7 +4140,7 @@ pub impl Resolver {\n         return result;\n     }\n \n-    fn check_consistent_bindings(arm: arm) {\n+    fn check_consistent_bindings(@mut self, arm: arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n         for arm.pats.eachi() |i, p| {\n@@ -4139,7 +4179,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_arm(arm: arm, visitor: ResolveVisitor) {\n+    fn resolve_arm(@mut self, arm: arm, visitor: ResolveVisitor) {\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n         let bindings_list = HashMap();\n@@ -4158,7 +4198,7 @@ pub impl Resolver {\n         (*self.value_ribs).pop();\n     }\n \n-    fn resolve_block(block: blk, visitor: ResolveVisitor) {\n+    fn resolve_block(@mut self, block: blk, visitor: ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n@@ -4183,7 +4223,7 @@ pub impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    fn resolve_type(ty: @Ty, visitor: ResolveVisitor) {\n+    fn resolve_type(@mut self, ty: @Ty, visitor: ResolveVisitor) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n@@ -4256,14 +4296,14 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_pattern(pattern: @pat,\n+    fn resolve_pattern(@mut self,\n+                       pattern: @pat,\n                        mode: PatternBindingMode,\n                        mutability: Mutability,\n                        // Maps idents to the node ID for the (outermost)\n                        // pattern that binds them\n                        bindings_list: Option<HashMap<ident,node_id>>,\n                        visitor: ResolveVisitor) {\n-\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n             match pattern.node {\n@@ -4463,7 +4503,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_bare_identifier_pattern(name: ident)\n+    fn resolve_bare_identifier_pattern(@mut self, name: ident)\n                                     -> BareIdentifierPatternResolution {\n         match self.resolve_item_in_lexical_scope(self.current_module,\n                                                  name,\n@@ -4505,7 +4545,8 @@ pub impl Resolver {\n      * If `check_ribs` is true, checks the local definitions first; i.e.\n      * doesn't skip straight to the containing module.\n      */\n-    fn resolve_path(path: @path,\n+    fn resolve_path(@mut self,\n+                    path: @path,\n                     namespace: Namespace,\n                     check_ribs: bool,\n                     visitor: ResolveVisitor)\n@@ -4533,12 +4574,12 @@ pub impl Resolver {\n                                        path.span);\n     }\n \n-    fn resolve_identifier(identifier: ident,\n+    fn resolve_identifier(@mut self,\n+                          identifier: ident,\n                           namespace: Namespace,\n                           check_ribs: bool,\n                           span: span)\n                        -> Option<def> {\n-\n         if check_ribs {\n             match self.resolve_identifier_in_local_ribs(identifier,\n                                                       namespace,\n@@ -4557,12 +4598,12 @@ pub impl Resolver {\n     }\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n-    fn resolve_definition_of_name_in_module(containing_module: @Module,\n+    fn resolve_definition_of_name_in_module(@mut self,\n+                                            containing_module: @mut Module,\n                                             name: ident,\n                                             namespace: Namespace,\n                                             xray: XrayFlag)\n                                          -> NameDefinition {\n-\n         // First, search children.\n         match containing_module.children.find(&name) {\n             Some(child_name_bindings) => {\n@@ -4619,7 +4660,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn intern_module_part_of_path(path: @path) -> @DVec<ident> {\n+    fn intern_module_part_of_path(@mut self, path: @path) -> @DVec<ident> {\n         let module_path_idents = @DVec();\n         for path.idents.eachi |index, ident| {\n             if index == path.idents.len() - 1 {\n@@ -4632,11 +4673,11 @@ pub impl Resolver {\n         return module_path_idents;\n     }\n \n-    fn resolve_module_relative_path(path: @path,\n+    fn resolve_module_relative_path(@mut self,\n+                                    path: @path,\n                                     +xray: XrayFlag,\n                                     namespace: Namespace)\n                                  -> Option<def> {\n-\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let mut containing_module;\n@@ -4676,11 +4717,11 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_crate_relative_path(path: @path,\n+    fn resolve_crate_relative_path(@mut self,\n+                                   path: @path,\n                                    +xray: XrayFlag,\n                                    namespace: Namespace)\n                                 -> Option<def> {\n-\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let root_module = self.graph_root.get_module();\n@@ -4723,7 +4764,8 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_identifier_in_local_ribs(ident: ident,\n+    fn resolve_identifier_in_local_ribs(@mut self,\n+                                        ident: ident,\n                                         namespace: Namespace,\n                                         span: span)\n                                      -> Option<def> {\n@@ -4754,7 +4796,8 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_item_by_identifier_in_lexical_scope(ident: ident,\n+    fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n+                                                   ident: ident,\n                                                    namespace: Namespace)\n                                                 -> Option<def> {\n         // Check the items.\n@@ -4786,7 +4829,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn name_exists_in_scope_struct(name: &str) -> bool {\n+    fn name_exists_in_scope_struct(@mut self, name: &str) -> bool {\n         let mut i = self.type_ribs.len();\n         while i != 0 {\n           i -= 1;\n@@ -4819,7 +4862,7 @@ pub impl Resolver {\n       return false;\n     }\n \n-    fn resolve_expr(expr: @expr, visitor: ResolveVisitor) {\n+    fn resolve_expr(@mut self, expr: @expr, visitor: ResolveVisitor) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -4928,7 +4971,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn record_candidate_traits_for_expr_if_necessary(expr: @expr) {\n+    fn record_candidate_traits_for_expr_if_necessary(@mut self, expr: @expr) {\n         match expr.node {\n             expr_field(_, ident, _) => {\n                 let traits = self.search_for_traits_containing_method(ident);\n@@ -5005,7 +5048,9 @@ pub impl Resolver {\n         }\n     }\n \n-    fn search_for_traits_containing_method(name: ident) -> @DVec<def_id> {\n+    fn search_for_traits_containing_method(@mut self,\n+                                           name: ident)\n+                                        -> @DVec<def_id> {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                *self.session.str_of(name));\n \n@@ -5095,10 +5140,11 @@ pub impl Resolver {\n         return found_traits;\n     }\n \n-    fn add_trait_info_if_containing_method(found_traits: @DVec<def_id>,\n+    fn add_trait_info_if_containing_method(@mut self,\n+                                           found_traits: @DVec<def_id>,\n                                            trait_def_id: def_id,\n-                                           name: ident) -> bool {\n-\n+                                           name: ident)\n+                                        -> bool {\n         debug!(\"(adding trait info if containing method) trying trait %d:%d \\\n                 for method '%s'\",\n                trait_def_id.crate,\n@@ -5121,18 +5167,21 @@ pub impl Resolver {\n         }\n     }\n \n-    fn add_fixed_trait_for_expr(expr_id: node_id, +trait_id: def_id) {\n+    fn add_fixed_trait_for_expr(@mut self,\n+                                expr_id: node_id,\n+                                +trait_id: def_id) {\n         let traits = @DVec();\n         traits.push(trait_id);\n         self.trait_map.insert(expr_id, traits);\n     }\n \n-    fn record_def(node_id: node_id, def: def) {\n+    fn record_def(@mut self, node_id: node_id, def: def) {\n         debug!(\"(recording def) recording %? for %?\", def, node_id);\n         self.def_map.insert(node_id, def);\n     }\n \n-    fn enforce_default_binding_mode(pat: @pat,\n+    fn enforce_default_binding_mode(@mut self,\n+                                    pat: @pat,\n                                     pat_binding_mode: binding_mode,\n                                     descr: &str) {\n         match pat_binding_mode {\n@@ -5157,7 +5206,7 @@ pub impl Resolver {\n     //\n     // be sure that there is only one main function\n     //\n-    fn check_duplicate_main() {\n+    fn check_duplicate_main(@mut self) {\n         if self.attr_main_fn.is_none() {\n             if self.main_fns.len() >= 1u {\n                 let mut i = 1u;\n@@ -5183,7 +5232,7 @@ pub impl Resolver {\n     // resolve data structures.\n     //\n \n-    fn check_for_unused_imports_if_necessary() {\n+    fn check_for_unused_imports_if_necessary(@mut self) {\n         if self.unused_import_lint_level == allow {\n             return;\n         }\n@@ -5192,7 +5241,8 @@ pub impl Resolver {\n         self.check_for_unused_imports_in_module_subtree(root_module);\n     }\n \n-    fn check_for_unused_imports_in_module_subtree(module_: @Module) {\n+    fn check_for_unused_imports_in_module_subtree(@mut self,\n+                                                  module_: @mut Module) {\n         // If this isn't a local crate, then bail out. We don't need to check\n         // for unused imports in external crates.\n \n@@ -5231,7 +5281,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn check_for_unused_imports_in_module(module_: @Module) {\n+    fn check_for_unused_imports_in_module(@mut self, module_: @mut Module) {\n         for module_.import_resolutions.each_value |&import_resolution| {\n             // Ignore dummy spans for things like automatically injected\n             // imports for the prelude, and also don't warn about the same\n@@ -5268,7 +5318,7 @@ pub impl Resolver {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_str(module_: @Module) -> ~str {\n+    fn module_to_str(@mut self, module_: @mut Module) -> ~str {\n         let idents = DVec();\n         let mut current_module = module_;\n         loop {\n@@ -5293,7 +5343,7 @@ pub impl Resolver {\n         return self.idents_to_str(vec::reversed(idents.get()));\n     }\n \n-    fn dump_module(module_: @Module) {\n+    fn dump_module(@mut self, module_: @mut Module) {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");\n@@ -5338,11 +5388,11 @@ pub fn resolve_crate(session: Session,\n                      lang_items: LanguageItems,\n                      crate: @crate)\n                   -> CrateMap {\n-    let resolver = @Resolver(session, lang_items, crate);\n-    resolver.resolve(resolver);\n+    let resolver = @mut Resolver(session, lang_items, crate);\n+    resolver.resolve();\n     CrateMap {\n-        def_map: resolver.def_map,\n-        exp_map2: resolver.export_map2,\n+        def_map: *resolver.def_map,\n+        exp_map2: *resolver.export_map2,\n         trait_map: resolver.trait_map\n     }\n }"}, {"sha": "df6073f9339b4ee12dfda251f4e4db1feddc47df", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -831,7 +831,7 @@ pub fn extract_variant_args(bcx: block,\n                          -> ExtractedBlock {\n     let (enm, evar) = vdefs;\n     let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n-    let ccx = bcx.fcx.ccx;\n+    let ccx = *bcx.fcx.ccx;\n     let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n       ty::ty_enum(id, ref substs) => {\n         assert id == enm;\n@@ -1272,7 +1272,7 @@ pub fn compile_submatch(bcx: block,\n \n     let vals_left = vec::append(vec::slice(vals, 0u, col).to_vec(),\n                                 vec::slice(vals, col + 1u, vals.len()));\n-    let ccx = bcx.fcx.ccx;\n+    let ccx = *bcx.fcx.ccx;\n     let mut pat_id = 0;\n     for vec::each(m) |br| {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -1710,7 +1710,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             binding_mode: IrrefutablePatternBindingMode)\n                          -> block {\n     let _icx = bcx.insn_ctxt(\"match::bind_irrefutable_pat\");\n-    let ccx = bcx.fcx.ccx;\n+    let ccx = *bcx.fcx.ccx;\n     let mut bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_match"}, {"sha": "cadbe1208ad2b37320a0a057874c2cab07ea1c91", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 59, "deletions": 47, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -866,8 +866,8 @@ pub fn need_invoke(bcx: block) -> bool {\n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n     loop {\n-        match cur.kind {\n-          block_scope(ref inf) => {\n+        match *cur.kind {\n+          block_scope(ref mut inf) => {\n             for vec::each((*inf).cleanups) |cleanup| {\n                 match *cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n@@ -898,16 +898,21 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: block, f: fn(&mut scope_info)) {\n     let mut bcx = bcx;\n     loop {\n-        match bcx.kind {\n-          block_scope(ref inf) => {\n-            if (*inf).cleanups.len() > 0u || bcx.parent.is_none() {\n-                f((*inf)); return;\n+        {\n+            // XXX: Borrow check bug workaround.\n+            let kind: &mut block_kind = &mut *bcx.kind;\n+            match *kind {\n+                block_scope(ref mut inf) => {\n+                    if inf.cleanups.len() > 0u || bcx.parent.is_none() {\n+                        f(inf);\n+                        return;\n+                    }\n+                }\n+                _ => ()\n             }\n-          }\n-          _ => ()\n         }\n         bcx = block_parent(bcx);\n     }\n@@ -1157,7 +1162,7 @@ pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n                         }\n                     }\n                 }\n-                ast::decl_item(i) => trans_item(cx.fcx.ccx, *i)\n+                ast::decl_item(i) => trans_item(*cx.fcx.ccx, *i)\n             }\n         }\n         ast::stmt_mac(*) => cx.tcx().sess.bug(~\"unexpanded macro\")\n@@ -1198,9 +1203,9 @@ pub fn simple_block_scope() -> block_kind {\n     block_scope(scope_info {\n         loop_break: None,\n         loop_label: None,\n-        mut cleanups: ~[],\n-        mut cleanup_paths: ~[],\n-        mut landing_pad: None\n+        cleanups: ~[],\n+        cleanup_paths: ~[],\n+        landing_pad: None\n     })\n }\n \n@@ -1226,9 +1231,9 @@ pub fn loop_scope_block(bcx: block,\n     return new_block(bcx.fcx, Some(bcx), block_scope(scope_info {\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n-        mut cleanups: ~[],\n-        mut cleanup_paths: ~[],\n-        mut landing_pad: None\n+        cleanups: ~[],\n+        cleanup_paths: ~[],\n+        landing_pad: None\n     }), bcx.is_lpad, n, opt_node_info);\n }\n \n@@ -1301,23 +1306,30 @@ pub fn cleanup_and_leave(bcx: block,\n                 @fmt!(\"cleanup_and_leave(%s)\", cur.to_str()));\n         }\n \n-        match cur.kind {\n-          block_scope(ref inf) if !inf.cleanups.is_empty() => {\n-            for vec::find((*inf).cleanup_paths,\n-                          |cp| cp.target == leave).each |cp| {\n-                Br(bcx, cp.dest);\n-                return;\n+        {\n+            // XXX: Borrow check bug workaround.\n+            let kind: &mut block_kind = &mut *cur.kind;\n+            match *kind {\n+              block_scope(ref mut inf) if !inf.cleanups.is_empty() => {\n+                for vec::find((*inf).cleanup_paths,\n+                              |cp| cp.target == leave).each |cp| {\n+                    Br(bcx, cp.dest);\n+                    return;\n+                }\n+                let sub_cx = sub_block(bcx, ~\"cleanup\");\n+                Br(bcx, sub_cx.llbb);\n+                inf.cleanup_paths.push(cleanup_path {\n+                    target: leave,\n+                    dest: sub_cx.llbb\n+                });\n+                bcx = trans_block_cleanups_(sub_cx,\n+                                            block_cleanups(cur),\n+                                            is_lpad);\n+              }\n+              _ => ()\n             }\n-            let sub_cx = sub_block(bcx, ~\"cleanup\");\n-            Br(bcx, sub_cx.llbb);\n-            (*inf).cleanup_paths.push(cleanup_path {\n-                target: leave,\n-                dest: sub_cx.llbb\n-            });\n-            bcx = trans_block_cleanups_(sub_cx, block_cleanups(cur), is_lpad);\n-          }\n-          _ => ()\n         }\n+\n         match upto {\n           Some(bb) => { if cur.llbb == bb { break; } }\n           _ => ()\n@@ -1572,25 +1584,25 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         param_substs: Option<@param_substs>,\n                         sp: Option<span>) -> fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n-    return @fn_ctxt_ {\n+    return @mut fn_ctxt_ {\n           llfn: llfndecl,\n           llenv: unsafe { llvm::LLVMGetParam(llfndecl, 1u as c_uint) },\n           llretptr: unsafe { llvm::LLVMGetParam(llfndecl, 0u as c_uint) },\n-          mut llstaticallocas: llbbs.sa,\n-          mut llloadenv: None,\n-          mut llreturn: llbbs.rt,\n-          mut llself: None,\n-          mut personality: None,\n-          mut loop_ret: None,\n-          llargs: HashMap(),\n-          lllocals: HashMap(),\n-          llupvars: HashMap(),\n+          llstaticallocas: llbbs.sa,\n+          llloadenv: None,\n+          llreturn: llbbs.rt,\n+          llself: None,\n+          personality: None,\n+          loop_ret: None,\n+          llargs: @HashMap(),\n+          lllocals: @HashMap(),\n+          llupvars: @HashMap(),\n           id: id,\n           impl_id: impl_id,\n           param_substs: param_substs,\n           span: sp,\n           path: path,\n-          ccx: ccx\n+          ccx: @ccx\n     };\n }\n \n@@ -1780,7 +1792,7 @@ pub fn trans_closure(ccx: @CrateContext,\n                 llvm::LLVMSetGC(fcx.llfn, strategy);\n             }\n         }\n-        ccx.uses_gc = true;\n+        *ccx.uses_gc = true;\n     }\n \n     // Create the first basic block in the function and keep a handle on it to\n@@ -2803,7 +2815,7 @@ pub fn trap(bcx: block) {\n }\n \n pub fn decl_gc_metadata(ccx: @CrateContext, llmod_id: ~str) {\n-    if !ccx.sess.opts.gc || !ccx.uses_gc {\n+    if !ccx.sess.opts.gc || !*ccx.uses_gc {\n         return;\n     }\n \n@@ -3038,7 +3050,7 @@ pub fn trans_crate(sess: session::Session,\n               discrims: HashMap(),\n               discrim_symbols: HashMap(),\n               tydescs: ty::new_ty_hash(),\n-              mut finished_tydescs: false,\n+              finished_tydescs: @mut false,\n               external: HashMap(),\n               monomorphized: HashMap(),\n               monomorphizing: HashMap(),\n@@ -3080,9 +3092,9 @@ pub fn trans_crate(sess: session::Session,\n               builder: BuilderRef_res(unsafe { llvm::LLVMCreateBuilder() }),\n               shape_cx: mk_ctxt(llmod),\n               crate_map: crate_map,\n-              mut uses_gc: false,\n+              uses_gc: @mut false,\n               dbg_cx: dbg_cx,\n-              mut do_not_commit_warning_issued: false\n+              do_not_commit_warning_issued: @mut false\n         };\n \n         {"}, {"sha": "8bd85be0f70824815dd41f7c68f29d7fb3560007", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -175,7 +175,7 @@ pub struct CrateContext {\n      tydescs: HashMap<ty::t, @mut tydesc_info>,\n      // Set when running emit_tydescs to enforce that no more tydescs are\n      // created.\n-     mut finished_tydescs: bool,\n+     finished_tydescs: @mut bool,\n      // Track mapping of external ids to local items imported for inlining\n      external: HashMap<ast::def_id, Option<ast::node_id>>,\n      // Cache instances of monomorphized functions\n@@ -224,9 +224,9 @@ pub struct CrateContext {\n      // Set when at least one function uses GC. Needed so that\n      // decl_gc_metadata knows whether to link to the module metadata, which\n      // is not emitted by LLVM's GC pass when no functions use GC.\n-     mut uses_gc: bool,\n+     uses_gc: @mut bool,\n      dbg_cx: Option<debuginfo::DebugContext>,\n-     mut do_not_commit_warning_issued: bool\n+     do_not_commit_warning_issued: @mut bool\n }\n \n // Types used for llself.\n@@ -273,34 +273,34 @@ pub struct fn_ctxt_ {\n     // the function, due to LLVM's quirks.\n     // A block for all the function's static allocas, so that LLVM\n     // will coalesce them into a single alloca call.\n-    mut llstaticallocas: BasicBlockRef,\n+    llstaticallocas: BasicBlockRef,\n     // A block containing code that copies incoming arguments to space\n     // already allocated by code in one of the llallocas blocks.\n     // (LLVM requires that arguments be copied to local allocas before\n     // allowing most any operation to be performed on them.)\n-    mut llloadenv: Option<BasicBlockRef>,\n-    mut llreturn: BasicBlockRef,\n+    llloadenv: Option<BasicBlockRef>,\n+    llreturn: BasicBlockRef,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n     //\n     // NB: This is the type of the self *variable*, not the self *type*. The\n     // self type is set only for default methods, while the self variable is\n     // set for all methods.\n-    mut llself: Option<ValSelfData>,\n+    llself: Option<ValSelfData>,\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n-    mut personality: Option<ValueRef>,\n+    personality: Option<ValueRef>,\n     // If this is a for-loop body that returns, this holds the pointers needed\n     // for that (flagptr, retptr)\n-    mut loop_ret: Option<(ValueRef, ValueRef)>,\n+    loop_ret: Option<(ValueRef, ValueRef)>,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: HashMap<ast::node_id, local_val>,\n+    llargs: @HashMap<ast::node_id, local_val>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: HashMap<ast::node_id, local_val>,\n+    lllocals: @HashMap<ast::node_id, local_val>,\n     // Same as above, but for closure upvars\n-    llupvars: HashMap<ast::node_id, ValueRef>,\n+    llupvars: @HashMap<ast::node_id, ValueRef>,\n \n     // The node_id of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n@@ -319,14 +319,14 @@ pub struct fn_ctxt_ {\n     path: path,\n \n     // This function's enclosing crate context.\n-    ccx: @CrateContext\n+    ccx: @@CrateContext\n }\n \n-pub type fn_ctxt = @fn_ctxt_;\n+pub type fn_ctxt = @mut fn_ctxt_;\n \n pub fn warn_not_to_commit(ccx: @CrateContext, msg: ~str) {\n-    if !ccx.do_not_commit_warning_issued {\n-        ccx.do_not_commit_warning_issued = true;\n+    if !*ccx.do_not_commit_warning_issued {\n+        *ccx.do_not_commit_warning_issued = true;\n         ccx.sess.warn(msg + ~\" -- do not commit like this!\");\n     }\n }\n@@ -355,7 +355,7 @@ pub struct cleanup_path {\n     dest: BasicBlockRef\n }\n \n-pub fn scope_clean_changed(scope_info: scope_info) {\n+pub fn scope_clean_changed(scope_info: &mut scope_info) {\n     if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n     scope_info.landing_pad = None;\n }\n@@ -498,9 +498,9 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n }\n \n pub fn block_cleanups(bcx: block) -> ~[cleanup] {\n-    match bcx.kind {\n+    match *bcx.kind {\n        block_non_scope  => ~[],\n-       block_scope(ref inf) => /*bad*/copy inf.cleanups\n+       block_scope(ref mut inf) => /*bad*/copy inf.cleanups\n     }\n }\n \n@@ -524,12 +524,12 @@ pub struct scope_info {\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block.\n-    mut cleanups: ~[cleanup],\n+    cleanups: ~[cleanup],\n     // Existing cleanup paths that may be reused, indexed by destination and\n     // cleared when the set of cleanups changes.\n-    mut cleanup_paths: ~[cleanup_path],\n+    cleanup_paths: ~[cleanup_path],\n     // Unwinding landing pad. Also cleared when cleanups change.\n-    mut landing_pad: Option<BasicBlockRef>,\n+    landing_pad: Option<BasicBlockRef>,\n }\n \n pub trait get_node_info {\n@@ -574,11 +574,11 @@ pub struct block_ {\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n     llbb: BasicBlockRef,\n-    mut terminated: bool,\n-    mut unreachable: bool,\n+    terminated: bool,\n+    unreachable: bool,\n     parent: Option<block>,\n     // The 'kind' of basic block this is.\n-    kind: block_kind,\n+    kind: @mut block_kind,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n@@ -597,21 +597,19 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n         terminated: false,\n         unreachable: false,\n         parent: parent,\n-        kind: kind,\n+        kind: @mut kind,\n         is_lpad: is_lpad,\n         node_info: node_info,\n         fcx: fcx\n     }\n }\n \n-/* This must be enum and not type, or trans goes into an infinite loop (#2572)\n- */\n-pub enum block = @block_;\n+pub type block = @mut block_;\n \n pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n             is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block {\n-    block(@block_(llbb, parent, kind, is_lpad, node_info, fcx))\n+    @mut block_(llbb, parent, kind, is_lpad, node_info, fcx)\n }\n \n // First two args are retptr, env\n@@ -660,17 +658,21 @@ pub fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     }\n }\n \n-pub fn in_scope_cx(cx: block, f: fn(scope_info)) {\n+pub fn in_scope_cx(cx: block, f: &fn(&mut scope_info)) {\n     let mut cur = cx;\n     loop {\n-        match cur.kind {\n-          block_scope(ref inf) => {\n-              debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n-                     cur.to_str(), cx.to_str());\n-              f((*inf));\n-              return;\n-          }\n-          _ => ()\n+        {\n+            // XXX: Borrow check bug workaround.\n+            let kind: &mut block_kind = &mut *cur.kind;\n+            match *kind {\n+              block_scope(ref mut inf) => {\n+                  debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                         cur.to_str(), cx.to_str());\n+                  f(inf);\n+                  return;\n+              }\n+              _ => ()\n+            }\n         }\n         cur = block_parent(cur);\n     }\n@@ -687,7 +689,7 @@ pub fn block_parent(cx: block) -> block {\n // Accessors\n \n pub impl block {\n-    pure fn ccx() -> @CrateContext { self.fcx.ccx }\n+    pure fn ccx() -> @CrateContext { *self.fcx.ccx }\n     pure fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n     pure fn sess() -> Session { self.fcx.ccx.sess }\n "}, {"sha": "4cf12576a78ee7a4634c2b47b71582b4615e6477", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -237,7 +237,7 @@ pub fn trans_break_cont(bcx: block,\n     let mut unwind = bcx;\n     let mut target;\n     loop {\n-        match unwind.kind {\n+        match *unwind.kind {\n           block_scope(scope_info {\n             loop_break: Some(brk),\n             loop_label: l,"}, {"sha": "8a28769756e6eb19f9568e525753f8f145d3c969", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -778,7 +778,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     -> Option<@Metadata<ArgumentMetadata>> {\n     unsafe {\n-        let fcx = bcx.fcx, cx = fcx.ccx;\n+        let fcx = bcx.fcx, cx = *fcx.ccx;\n         let cache = get_cache(cx);\n         let tg = ArgVariableTag;\n         match cached_metadata::<@Metadata<ArgumentMetadata>>(\n@@ -845,7 +845,7 @@ pub fn update_source_pos(cx: block, s: span) {\n }\n \n pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n-    let cx = fcx.ccx;\n+    let cx = *fcx.ccx;\n     let dbg_cx = (/*bad*/copy cx.dbg_cx).get();\n \n     debug!(\"~~\");"}, {"sha": "ad171a44859d19b5834acabbc91a32cd24ad1c5a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -944,10 +944,10 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             }\n         }\n         ast::def_arg(nid, _, _) => {\n-            take_local(bcx, bcx.fcx.llargs, nid)\n+            take_local(bcx, *bcx.fcx.llargs, nid)\n         }\n         ast::def_local(nid, _) | ast::def_binding(nid, _) => {\n-            take_local(bcx, bcx.fcx.lllocals, nid)\n+            take_local(bcx, *bcx.fcx.lllocals, nid)\n         }\n         ast::def_self(nid, _) => {\n             let self_info: ValSelfData = match bcx.fcx.llself {"}, {"sha": "bbe80431c07fb715832ac7db86d12af462ef86fa", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -654,7 +654,7 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n-    assert !ccx.finished_tydescs;\n+    assert !*ccx.finished_tydescs;\n \n     let llty = type_of(ccx, t);\n \n@@ -761,7 +761,7 @@ pub fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n pub fn emit_tydescs(ccx: @CrateContext) {\n     let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n-    ccx.finished_tydescs = true;\n+    *ccx.finished_tydescs = true;\n     for ccx.tydescs.each_value |&val| {\n         let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n         let ti = val;"}, {"sha": "79061dbb66c7d0af91387856dc5d0a16ecd4e51a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -230,7 +230,7 @@ pub type ctxt = @ctxt_;\n struct ctxt_ {\n     diag: syntax::diagnostic::span_handler,\n     interner: HashMap<intern_key, t_box>,\n-    mut next_id: uint,\n+    next_id: @mut uint,\n     vecs_implicitly_copyable: bool,\n     legacy_modes: bool,\n     cstore: @mut metadata::cstore::CStore,\n@@ -260,7 +260,7 @@ struct ctxt_ {\n     short_names_cache: HashMap<t, @~str>,\n     needs_drop_cache: HashMap<t, bool>,\n     needs_unwind_cleanup_cache: HashMap<t, bool>,\n-    mut tc_cache: LinearMap<uint, TypeContents>,\n+    tc_cache: @mut LinearMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: HashMap<node_id, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: HashMap<def_id, @~[VariantInfo]>,\n     trait_method_cache: HashMap<def_id, @~[method]>,\n@@ -804,7 +804,7 @@ pub fn mk_ctxt(s: session::Session,\n     @ctxt_ {\n         diag: s.diagnostic(),\n         interner: interner,\n-        mut next_id: 0u,\n+        next_id: @mut 0,\n         vecs_implicitly_copyable: vecs_implicitly_copyable,\n         legacy_modes: legacy_modes,\n         cstore: s.cstore,\n@@ -823,7 +823,7 @@ pub fn mk_ctxt(s: session::Session,\n         short_names_cache: new_ty_hash(),\n         needs_drop_cache: new_ty_hash(),\n         needs_unwind_cleanup_cache: new_ty_hash(),\n-        tc_cache: LinearMap::new(),\n+        tc_cache: @mut LinearMap::new(),\n         ast_ty_to_ty_cache: HashMap(),\n         enum_var_cache: HashMap(),\n         trait_method_cache: HashMap(),\n@@ -912,7 +912,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n \n     let t = @t_box_ {\n         sty: st,\n-        id: cx.next_id,\n+        id: *cx.next_id,\n         flags: flags,\n         o_def_id: o_def_id\n     };\n@@ -923,7 +923,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n \n     cx.interner.insert(key, t);\n \n-    cx.next_id += 1u;\n+    *cx.next_id += 1;\n     unsafe { cast::reinterpret_cast(&t) }\n }\n "}, {"sha": "eb92b23c9d7e73d8516e0bd1f7dc843af734f274", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -196,7 +196,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n     struct CtxtRepr {\n         parse_sess: @mut parse::ParseSess,\n         cfg: ast::crate_cfg,\n-        backtrace: Option<@ExpnInfo>,\n+        backtrace: @mut Option<@ExpnInfo>,\n         mod_path: ~[ast::ident],\n         trace_mac: bool\n     }\n@@ -205,33 +205,33 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n         fn parse_sess(@mut self) -> @mut parse::ParseSess { self.parse_sess }\n         fn cfg(@mut self) -> ast::crate_cfg { self.cfg }\n         fn call_site(@mut self) -> span {\n-            match self.backtrace {\n+            match *self.backtrace {\n                 Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n                 None => self.bug(~\"missing top span\")\n             }\n         }\n         fn print_backtrace(@mut self) { }\n-        fn backtrace(@mut self) -> Option<@ExpnInfo> { self.backtrace }\n+        fn backtrace(@mut self) -> Option<@ExpnInfo> { *self.backtrace }\n         fn mod_push(@mut self, i: ast::ident) { self.mod_path.push(i); }\n         fn mod_pop(@mut self) { self.mod_path.pop(); }\n         fn mod_path(@mut self) -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(@mut self, ei: codemap::ExpnInfo) {\n             match ei {\n               ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n-                self.backtrace =\n+                *self.backtrace =\n                     Some(@ExpandedFrom(CallInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: self.backtrace},\n+                                         expn_info: *self.backtrace},\n                         callee: (*callee)}));\n               }\n             }\n         }\n         fn bt_pop(@mut self) {\n-            match self.backtrace {\n+            match *self.backtrace {\n               Some(@ExpandedFrom(CallInfo {\n                   call_site: span {expn_info: prev, _}, _\n               })) => {\n-                self.backtrace = prev\n+                *self.backtrace = prev\n               }\n               _ => self.bug(~\"tried to pop without a push\")\n             }\n@@ -280,7 +280,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n     let imp: @mut CtxtRepr = @mut CtxtRepr {\n         parse_sess: parse_sess,\n         cfg: cfg,\n-        backtrace: None,\n+        backtrace: @mut None,\n         mod_path: ~[],\n         trace_mac: false\n     };"}, {"sha": "3817f89b8173fc66ac96c9eeb545c15c7dc6557a", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7924ce18f05b386d390a61ea63934cbe464e510/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e7924ce18f05b386d390a61ea63934cbe464e510", "patch": "@@ -28,7 +28,7 @@ use std::oldmap::HashMap;\n    `~` */\n ///an unzipping of `token_tree`s\n struct TtFrame {\n-    readme: ~[ast::token_tree],\n+    readme: @mut ~[ast::token_tree],\n     idx: uint,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n@@ -60,7 +60,7 @@ pub fn new_tt_reader(sp_diag: span_handler,\n         sp_diag: sp_diag,\n         interner: itr,\n         mut cur: @mut TtFrame {\n-            readme: src,\n+            readme: @mut src,\n             idx: 0u,\n             dotdotdoted: false,\n             sep: None,\n@@ -82,7 +82,7 @@ pub fn new_tt_reader(sp_diag: span_handler,\n \n pure fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     @mut TtFrame {\n-        readme: f.readme,\n+        readme: @mut (copy *f.readme),\n         idx: f.idx,\n         dotdotdoted: f.dotdotdoted,\n         sep: f.sep,\n@@ -199,9 +199,9 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         match r.cur.readme[r.cur.idx] {\n-          tt_delim(copy tts) => {\n+          tt_delim(tts) => {\n             r.cur = @mut TtFrame {\n-                readme: tts,\n+                readme: @mut copy tts,\n                 idx: 0u,\n                 dotdotdoted: false,\n                 sep: None,\n@@ -242,7 +242,7 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n                     r.repeat_len.push(len);\n                     r.repeat_idx.push(0u);\n                     r.cur = @mut TtFrame {\n-                        readme: tts,\n+                        readme: @mut copy tts,\n                         idx: 0u,\n                         dotdotdoted: true,\n                         sep: sep,"}]}