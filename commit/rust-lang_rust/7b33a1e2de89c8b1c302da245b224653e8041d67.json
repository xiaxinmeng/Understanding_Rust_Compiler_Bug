{"sha": "7b33a1e2de89c8b1c302da245b224653e8041d67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMzNhMWUyZGU4OWM4YjFjMzAyZGEyNDViMjI0NjUzZTgwNDFkNjc=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-31T01:47:02Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-31T01:47:02Z"}, "message": "frob emphasis", "tree": {"sha": "f2b8f87b9cadf47f65f2c971a172b561fe303b62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b8f87b9cadf47f65f2c971a172b561fe303b62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b33a1e2de89c8b1c302da245b224653e8041d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b33a1e2de89c8b1c302da245b224653e8041d67", "html_url": "https://github.com/rust-lang/rust/commit/7b33a1e2de89c8b1c302da245b224653e8041d67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b33a1e2de89c8b1c302da245b224653e8041d67/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66ba6924cbcad746252759010b5a44129016b0e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/66ba6924cbcad746252759010b5a44129016b0e3", "html_url": "https://github.com/rust-lang/rust/commit/66ba6924cbcad746252759010b5a44129016b0e3"}], "stats": {"total": 256, "additions": 132, "deletions": 124}, "files": [{"sha": "e4a46827f46b4a8f4c0d67485b8d8ccd7715fa68", "filename": "src/doc/tarpl/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FREADME.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -9,15 +9,15 @@ nitty-gritty details of the language. You want to know those weird corner-cases.\n You want to know what the heck `unsafe` really means, and how to properly use\n it. This is the book for you.\n \n-To be clear, this book goes into *serious* detail. We're going to dig into\n+To be clear, this book goes into serious detail. We're going to dig into\n exception-safety and pointer aliasing. We're going to talk about memory\n models. We're even going to do some type-theory. This is stuff that you\n-absolutely *don't* need to know to write fast and safe Rust programs.\n+absolutely don't need to know to write fast and safe Rust programs.\n You could probably close this book *right now* and still have a productive\n and happy career in Rust.\n \n-However if you intend to write unsafe code -- or just *really* want to dig into\n-the guts of the language -- this book contains *invaluable* information.\n+However if you intend to write unsafe code -- or just really want to dig into\n+the guts of the language -- this book contains invaluable information.\n \n Unlike TRPL we will be assuming considerable prior knowledge. In particular, you\n should be comfortable with basic systems programming and basic Rust. If you"}, {"sha": "2d567e39f8fda66a51cca49d9db2ac662c3d2409", "filename": "src/doc/tarpl/atomics.md", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fatomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fatomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fatomics.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -17,7 +17,7 @@ face.\n The C11 memory model is fundamentally about trying to bridge the gap between the\n semantics we want, the optimizations compilers want, and the inconsistent chaos\n our hardware wants. *We* would like to just write programs and have them do\n-exactly what we said but, you know, *fast*. Wouldn't that be great?\n+exactly what we said but, you know, fast. Wouldn't that be great?\n \n \n \n@@ -35,20 +35,20 @@ y = 3;\n x = 2;\n ```\n \n-The compiler may conclude that it would *really* be best if your program did\n+The compiler may conclude that it would be best if your program did\n \n ```rust,ignore\n x = 2;\n y = 3;\n ```\n \n-This has inverted the order of events *and* completely eliminated one event.\n+This has inverted the order of events and completely eliminated one event.\n From a single-threaded perspective this is completely unobservable: after all\n the statements have executed we are in exactly the same state. But if our\n-program is multi-threaded, we may have been relying on `x` to *actually* be\n-assigned to 1 before `y` was assigned. We would *really* like the compiler to be\n+program is multi-threaded, we may have been relying on `x` to actually be\n+assigned to 1 before `y` was assigned. We would like the compiler to be\n able to make these kinds of optimizations, because they can seriously improve\n-performance. On the other hand, we'd really like to be able to depend on our\n+performance. On the other hand, we'd also like to be able to depend on our\n program *doing the thing we said*.\n \n \n@@ -57,15 +57,15 @@ program *doing the thing we said*.\n # Hardware Reordering\n \n On the other hand, even if the compiler totally understood what we wanted and\n-respected our wishes, our *hardware* might instead get us in trouble. Trouble\n+respected our wishes, our hardware might instead get us in trouble. Trouble\n comes from CPUs in the form of memory hierarchies. There is indeed a global\n shared memory space somewhere in your hardware, but from the perspective of each\n CPU core it is *so very far away* and *so very slow*. Each CPU would rather work\n-with its local cache of the data and only go through all the *anguish* of\n-talking to shared memory *only* when it doesn't actually have that memory in\n+with its local cache of the data and only go through all the anguish of\n+talking to shared memory only when it doesn't actually have that memory in\n cache.\n \n-After all, that's the whole *point* of the cache, right? If every read from the\n+After all, that's the whole point of the cache, right? If every read from the\n cache had to run back to shared memory to double check that it hadn't changed,\n what would the point be? The end result is that the hardware doesn't guarantee\n that events that occur in the same order on *one* thread, occur in the same\n@@ -99,13 +99,13 @@ provides weak ordering guarantees. This has two consequences for concurrent\n programming:\n \n * Asking for stronger guarantees on strongly-ordered hardware may be cheap or\n-  even *free* because they already provide strong guarantees unconditionally.\n+  even free because they already provide strong guarantees unconditionally.\n   Weaker guarantees may only yield performance wins on weakly-ordered hardware.\n \n-* Asking for guarantees that are *too* weak on strongly-ordered hardware   is\n+* Asking for guarantees that are too weak on strongly-ordered hardware is\n   more likely to *happen* to work, even though your program is strictly\n-  incorrect. If possible, concurrent algorithms should be tested on   weakly-\n-  ordered hardware.\n+  incorrect. If possible, concurrent algorithms should be tested on\n+  weakly-ordered hardware.\n \n \n \n@@ -115,10 +115,10 @@ programming:\n \n The C11 memory model attempts to bridge the gap by allowing us to talk about the\n *causality* of our program. Generally, this is by establishing a *happens\n-before* relationships between parts of the program and the threads that are\n+before* relationship between parts of the program and the threads that are\n running them. This gives the hardware and compiler room to optimize the program\n more aggressively where a strict happens-before relationship isn't established,\n-but forces them to be more careful where one *is* established. The way we\n+but forces them to be more careful where one is established. The way we\n communicate these relationships are through *data accesses* and *atomic\n accesses*.\n \n@@ -130,8 +130,10 @@ propagate the changes made in data accesses to other threads as lazily and\n inconsistently as it wants. Mostly critically, data accesses are how data races\n happen. Data accesses are very friendly to the hardware and compiler, but as\n we've seen they offer *awful* semantics to try to write synchronized code with.\n-Actually, that's too weak. *It is literally impossible to write correct\n-synchronized code using only data accesses*.\n+Actually, that's too weak.\n+\n+**It is literally impossible to write correct synchronized code using only data\n+accesses.**\n \n Atomic accesses are how we tell the hardware and compiler that our program is\n multi-threaded. Each atomic access can be marked with an *ordering* that\n@@ -141,7 +143,10 @@ they *can't* do. For the compiler, this largely revolves around re-ordering of\n instructions. For the hardware, this largely revolves around how writes are\n propagated to other threads. The set of orderings Rust exposes are:\n \n-* Sequentially Consistent (SeqCst) Release Acquire Relaxed\n+* Sequentially Consistent (SeqCst)\n+* Release\n+* Acquire\n+* Relaxed\n \n (Note: We explicitly do not expose the C11 *consume* ordering)\n \n@@ -154,13 +159,13 @@ synchronize\"\n \n Sequentially Consistent is the most powerful of all, implying the restrictions\n of all other orderings. Intuitively, a sequentially consistent operation\n-*cannot* be reordered: all accesses on one thread that happen before and after a\n-SeqCst access *stay* before and after it. A data-race-free program that uses\n+cannot be reordered: all accesses on one thread that happen before and after a\n+SeqCst access stay before and after it. A data-race-free program that uses\n only sequentially consistent atomics and data accesses has the very nice\n property that there is a single global execution of the program's instructions\n that all threads agree on. This execution is also particularly nice to reason\n about: it's just an interleaving of each thread's individual executions. This\n-*does not* hold if you start using the weaker atomic orderings.\n+does not hold if you start using the weaker atomic orderings.\n \n The relative developer-friendliness of sequential consistency doesn't come for\n free. Even on strongly-ordered platforms sequential consistency involves\n@@ -170,8 +175,8 @@ In practice, sequential consistency is rarely necessary for program correctness.\n However sequential consistency is definitely the right choice if you're not\n confident about the other memory orders. Having your program run a bit slower\n than it needs to is certainly better than it running incorrectly! It's also\n-*mechanically* trivial to downgrade atomic operations to have a weaker\n-consistency later on. Just change `SeqCst` to e.g. `Relaxed` and you're done! Of\n+mechanically trivial to downgrade atomic operations to have a weaker\n+consistency later on. Just change `SeqCst` to `Relaxed` and you're done! Of\n course, proving that this transformation is *correct* is a whole other matter.\n \n \n@@ -183,15 +188,15 @@ Acquire and Release are largely intended to be paired. Their names hint at their\n use case: they're perfectly suited for acquiring and releasing locks, and\n ensuring that critical sections don't overlap.\n \n-Intuitively, an acquire access ensures that every access after it *stays* after\n+Intuitively, an acquire access ensures that every access after it stays after\n it. However operations that occur before an acquire are free to be reordered to\n occur after it. Similarly, a release access ensures that every access before it\n-*stays* before it. However operations that occur after a release are free to be\n+stays before it. However operations that occur after a release are free to be\n reordered to occur before it.\n \n When thread A releases a location in memory and then thread B subsequently\n acquires *the same* location in memory, causality is established. Every write\n-that happened *before* A's release will be observed by B *after* its release.\n+that happened before A's release will be observed by B after its release.\n However no causality is established with any other threads. Similarly, no\n causality is established if A and B access *different* locations in memory.\n \n@@ -230,7 +235,7 @@ weakly-ordered platforms.\n # Relaxed\n \n Relaxed accesses are the absolute weakest. They can be freely re-ordered and\n-provide no happens-before relationship. Still, relaxed operations *are* still\n+provide no happens-before relationship. Still, relaxed operations are still\n atomic. That is, they don't count as data accesses and any read-modify-write\n operations done to them occur atomically. Relaxed operations are appropriate for\n things that you definitely want to happen, but don't particularly otherwise care"}, {"sha": "da484385788079fc25992deca7890691c63535ac", "filename": "src/doc/tarpl/borrow-splitting.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -2,7 +2,7 @@\n \n The mutual exclusion property of mutable references can be very limiting when\n working with a composite structure. The borrow checker understands some basic\n-stuff, but will fall over pretty easily. It *does* understand structs\n+stuff, but will fall over pretty easily. It does understand structs\n sufficiently to know that it's possible to borrow disjoint fields of a struct\n simultaneously. So this works today:\n \n@@ -50,7 +50,7 @@ to the same value.\n \n In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n to unsafe code. For instance, mutable slices expose a `split_at_mut` function\n-that consumes the slice and returns *two* mutable slices. One for everything to\n+that consumes the slice and returns two mutable slices. One for everything to\n the left of the index, and one for everything to the right. Intuitively we know\n this is safe because the slices don't overlap, and therefore alias. However\n the implementation requires some unsafety:\n@@ -93,10 +93,10 @@ completely incompatible with this API, as it would produce multiple mutable\n references to the same object!\n \n However it actually *does* work, exactly because iterators are one-shot objects.\n-Everything an IterMut yields will be yielded *at most* once, so we don't\n-*actually* ever yield multiple mutable references to the same piece of data.\n+Everything an IterMut yields will be yielded at most once, so we don't\n+actually ever yield multiple mutable references to the same piece of data.\n \n-Perhaps surprisingly, mutable iterators *don't* require unsafe code to be\n+Perhaps surprisingly, mutable iterators don't require unsafe code to be\n implemented for many types!\n \n For instance here's a singly linked list:"}, {"sha": "5f07709cf4542efbd6a46bb3ce16eac783fd3b52", "filename": "src/doc/tarpl/casts.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcasts.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -1,13 +1,13 @@\n % Casts\n \n Casts are a superset of coercions: every coercion can be explicitly\n-invoked via a cast. However some conversions *require* a cast.\n+invoked via a cast. However some conversions require a cast.\n While coercions are pervasive and largely harmless, these \"true casts\"\n are rare and potentially dangerous. As such, casts must be explicitly invoked\n using the `as` keyword: `expr as Type`.\n \n True casts generally revolve around raw pointers and the primitive numeric\n-types. Even though they're dangerous, these casts are *infallible* at runtime.\n+types. Even though they're dangerous, these casts are infallible at runtime.\n If a cast triggers some subtle corner case no indication will be given that\n this occurred. The cast will simply succeed. That said, casts must be valid\n at the type level, or else they will be prevented statically. For instance,"}, {"sha": "f7c4482a4abf8adad7c79075759552dab1d324f8", "filename": "src/doc/tarpl/checked-uninit.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -80,7 +80,7 @@ loop {\n     // because it relies on actual values.\n     if true {\n         // But it does understand that it will only be taken once because\n-        // we *do* unconditionally break out of it. Therefore `x` doesn't\n+        // we unconditionally break out of it. Therefore `x` doesn't\n         // need to be marked as mutable.\n         x = 0;\n         break;"}, {"sha": "9dcbecdd5b329c0d78d2fb315b7c9c64adc6bcd3", "filename": "src/doc/tarpl/concurrency.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconcurrency.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -2,12 +2,12 @@\n \n Rust as a language doesn't *really* have an opinion on how to do concurrency or\n parallelism. The standard library exposes OS threads and blocking sys-calls\n-because *everyone* has those, and they're uniform enough that you can provide\n+because everyone has those, and they're uniform enough that you can provide\n an abstraction over them in a relatively uncontroversial way. Message passing,\n green threads, and async APIs are all diverse enough that any abstraction over\n them tends to involve trade-offs that we weren't willing to commit to for 1.0.\n \n However the way Rust models concurrency makes it relatively easy design your own\n-concurrency paradigm as a library and have *everyone else's* code Just Work\n+concurrency paradigm as a library and have everyone else's code Just Work\n with yours. Just require the right lifetimes and Send and Sync where appropriate\n-and you're off to the races. Or rather, off to the... not... having... races.\n\\ No newline at end of file\n+and you're off to the races. Or rather, off to the... not... having... races."}, {"sha": "97817cd1f9080bae4790ad3a452d6f42f75c88e1", "filename": "src/doc/tarpl/constructors.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fconstructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fconstructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconstructors.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -37,14 +37,14 @@ blindly memcopied to somewhere else in memory. This means pure on-the-stack-but-\n still-movable intrusive linked lists are simply not happening in Rust (safely).\n \n Assignment and copy constructors similarly don't exist because move semantics\n-are the *only* semantics in Rust. At most `x = y` just moves the bits of y into\n-the x variable. Rust *does* provide two facilities for providing C++'s copy-\n+are the only semantics in Rust. At most `x = y` just moves the bits of y into\n+the x variable. Rust does provide two facilities for providing C++'s copy-\n oriented semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\n constructor, but it's never implicitly invoked. You have to explicitly call\n `clone` on an element you want to be cloned. Copy is a special case of Clone\n where the implementation is just \"copy the bits\". Copy types *are* implicitly\n cloned whenever they're moved, but because of the definition of Copy this just\n-means *not* treating the old copy as uninitialized -- a no-op.\n+means not treating the old copy as uninitialized -- a no-op.\n \n While Rust provides a `Default` trait for specifying the moral equivalent of a\n default constructor, it's incredibly rare for this trait to be used. This is"}, {"sha": "b099a789ec352b0d0b363cc16c42c07876f32f14", "filename": "src/doc/tarpl/conversions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconversions.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -8,7 +8,7 @@ a different type. Because Rust encourages encoding important properties in the\n type system, these problems are incredibly pervasive. As such, Rust\n consequently gives you several ways to solve them.\n \n-First we'll look at the ways that *Safe Rust* gives you to reinterpret values.\n+First we'll look at the ways that Safe Rust gives you to reinterpret values.\n The most trivial way to do this is to just destructure a value into its\n constituent parts and then build a new type out of them. e.g.\n "}, {"sha": "d0a796b7f0bbaaa08ae768c8766a5b0b4bb9aa5f", "filename": "src/doc/tarpl/data.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdata.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -1,5 +1,5 @@\n % Data Representation in Rust\n \n-Low-level programming cares a lot about data layout. It's a big deal. It also pervasively\n-influences the rest of the language, so we're going to start by digging into how data is\n-represented in Rust.\n+Low-level programming cares a lot about data layout. It's a big deal. It also\n+pervasively influences the rest of the language, so we're going to start by\n+digging into how data is represented in Rust."}, {"sha": "568f7c07f59ef88d0a648532c8e8e1fc36243ed2", "filename": "src/doc/tarpl/destructors.md", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdestructors.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -7,16 +7,19 @@ What the language *does* provide is full-blown automatic destructors through the\n fn drop(&mut self);\n ```\n \n-This method gives the type time to somehow finish what it was doing. **After\n-`drop` is run, Rust will recursively try to drop all of the fields of `self`**.\n+This method gives the type time to somehow finish what it was doing.\n+\n+**After `drop` is run, Rust will recursively try to drop all of the fields\n+of `self`.**\n+\n This is a convenience feature so that you don't have to write \"destructor\n boilerplate\" to drop children. If a struct has no special logic for being\n dropped other than dropping its children, then it means `Drop` doesn't need to\n be implemented at all!\n \n-**There is no stable way to prevent this behaviour in Rust 1.0.\n+**There is no stable way to prevent this behaviour in Rust 1.0.**\n \n-Note that taking `&mut self` means that even if you *could* suppress recursive\n+Note that taking `&mut self` means that even if you could suppress recursive\n Drop, Rust will prevent you from e.g. moving fields out of self. For most types,\n this is totally fine.\n \n@@ -90,7 +93,7 @@ After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n happily proceed to tell the box to Drop itself and everything will blow up with\n use-after-frees and double-frees.\n \n-Note that the recursive drop behaviour applies to *all* structs and enums\n+Note that the recursive drop behaviour applies to all structs and enums\n regardless of whether they implement Drop. Therefore something like\n \n ```rust\n@@ -114,7 +117,7 @@ enum Link {\n }\n ```\n \n-will have its inner Box field dropped *if and only if* an instance stores the\n+will have its inner Box field dropped if and only if an instance stores the\n Next variant.\n \n In general this works really nice because you don't need to worry about\n@@ -165,7 +168,7 @@ impl<T> Drop for SuperBox<T> {\n ```\n \n However this has fairly odd semantics: you're saying that a field that *should*\n-always be Some may be None, just because that happens in the destructor. Of\n+always be Some *may* be None, just because that happens in the destructor. Of\n course this conversely makes a lot of sense: you can call arbitrary methods on\n self during the destructor, and this should prevent you from ever doing so after\n deinitializing the field. Not that it will prevent you from producing any other"}, {"sha": "1e81c97479b8fd05950748268c7621c137d829f6", "filename": "src/doc/tarpl/drop-flags.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdrop-flags.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -10,7 +10,7 @@ How can it do this with conditional initialization?\n \n Note that this is not a problem that all assignments need worry about. In\n particular, assigning through a dereference unconditionally drops, and assigning\n-in a `let` unconditionally *doesn't* drop:\n+in a `let` unconditionally doesn't drop:\n \n ```\n let mut x = Box::new(0); // let makes a fresh variable, so never need to drop\n@@ -23,11 +23,11 @@ one of its subfields.\n \n It turns out that Rust actually tracks whether a type should be dropped or not\n *at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*\n-for that variable is toggled. When a variable *might* need to be dropped, this\n-flag is evaluated to determine if it *should* be dropped.\n+for that variable is toggled. When a variable might need to be dropped, this\n+flag is evaluated to determine if it should be dropped.\n \n-Of course, it is *often* the case that a value's initialization state can be\n-*statically* known at every point in the program. If this is the case, then the\n+Of course, it is often the case that a value's initialization state can be\n+statically known at every point in the program. If this is the case, then the\n compiler can theoretically generate more efficient code! For instance, straight-\n line code has such *static drop semantics*:\n \n@@ -40,8 +40,8 @@ y = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n                          // x goes out of scope; x was uninit; do nothing.\n ```\n \n-And even branched code where all branches have the same behaviour with respect\n-to initialization:\n+Similarly, branched code where all branches have the same behaviour with respect\n+to initialization has static drop semantics:\n \n ```rust\n # let condition = true;\n@@ -65,7 +65,7 @@ if condition {\n     x = Box::new(0);        // x was uninit; just overwrite.\n     println!(\"{}\", x);\n }\n-                            // x goes out of scope; x *might* be uninit;\n+                            // x goes out of scope; x might be uninit;\n                             // check the flag!\n ```\n \n@@ -81,7 +81,7 @@ if condition {\n \n As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a hidden\n field of any type that implements Drop. Rust sets the drop flag by overwriting\n-the *entire* value with a particular bit pattern. This is pretty obviously Not\n+the entire value with a particular bit pattern. This is pretty obviously Not\n The Fastest and causes a bunch of trouble with optimizing code. It's legacy from\n a time when you could do much more complex conditional initialization.\n \n@@ -92,4 +92,4 @@ as it requires fairly substantial changes to the compiler.\n Regardless, Rust programs don't need to worry about uninitialized values on\n the stack for correctness. Although they might care for performance. Thankfully,\n Rust makes it easy to take control here! Uninitialized values are there, and\n-you can work with them in Safe Rust, but you're *never* in danger.\n+you can work with them in Safe Rust, but you're never in danger."}, {"sha": "df09d1a17447deaeaa64ba806465cf5a63eb4c22", "filename": "src/doc/tarpl/dropck.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdropck.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -30,7 +30,7 @@ let (x, y) = (vec![], vec![]);\n ```\n \n Does either value strictly outlive the other? The answer is in fact *no*,\n-neither value  strictly outlives the other. Of course, one of x or y will be\n+neither value strictly outlives the other. Of course, one of x or y will be\n dropped before the other, but the actual order is not specified. Tuples aren't\n special in this regard; composite structures just don't guarantee their\n destruction order as of Rust 1.0.\n@@ -100,11 +100,11 @@ fn main() {\n <anon>:15 }\n ```\n \n-Implementing Drop lets the Inspector execute some arbitrary code *during* its\n+Implementing Drop lets the Inspector execute some arbitrary code during its\n death. This means it can potentially observe that types that are supposed to\n live as long as it does actually were destroyed first.\n \n-Interestingly, only *generic* types need to worry about this. If they aren't\n+Interestingly, only generic types need to worry about this. If they aren't\n generic, then the only lifetimes they can harbor are `'static`, which will truly\n live *forever*. This is why this problem is referred to as *sound generic drop*.\n Sound generic drop is enforced by the *drop checker*. As of this writing, some\n@@ -116,12 +116,12 @@ section:\n strictly outlive it.**\n \n This rule is sufficient but not necessary to satisfy the drop checker. That is,\n-if your type obeys this rule then it's *definitely* sound to drop. However\n+if your type obeys this rule then it's definitely sound to drop. However\n there are special cases where you can fail to satisfy this, but still\n successfully pass the borrow checker. These are the precise rules that are\n currently up in the air.\n \n It turns out that when writing unsafe code, we generally don't need to\n worry at all about doing the right thing for the drop checker. However there\n-is *one* special case that you need to worry about, which we will look at in\n+is one special case that you need to worry about, which we will look at in\n the next section."}, {"sha": "74f7831a72afb81f26b789b4cc825ab518636f93", "filename": "src/doc/tarpl/exception-safety.md", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexception-safety.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -1,8 +1,8 @@\n % Exception Safety\n \n-Although programs should use unwinding sparingly, there's *a lot* of code that\n+Although programs should use unwinding sparingly, there's a lot of code that\n *can* panic. If you unwrap a None, index out of bounds, or divide by 0, your\n-program *will* panic. On debug builds, *every* arithmetic operation can panic\n+program will panic. On debug builds, every arithmetic operation can panic\n if it overflows. Unless you are very careful and tightly control what code runs,\n pretty much everything can unwind, and you need to be ready for it.\n \n@@ -22,7 +22,7 @@ unsound states must be careful that a panic does not cause that state to be\n used. Generally this means ensuring that only non-panicking code is run while\n these states exist, or making a guard that cleans up the state in the case of\n a panic. This does not necessarily mean that the state a panic witnesses is a\n-fully *coherent* state. We need only guarantee that it's a *safe* state.\n+fully coherent state. We need only guarantee that it's a *safe* state.\n \n Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\n It controls all the code that runs, and most of that code can't panic. However\n@@ -58,17 +58,16 @@ impl<T: Clone> Vec<T> {\n We bypass `push` in order to avoid redundant capacity and `len` checks on the\n Vec that we definitely know has capacity. The logic is totally correct, except\n there's a subtle problem with our code: it's not exception-safe! `set_len`,\n-`offset`, and `write` are all fine, but *clone* is the panic bomb we over-\n-looked.\n+`offset`, and `write` are all fine; `clone` is the panic bomb we over-looked.\n \n Clone is completely out of our control, and is totally free to panic. If it\n does, our function will exit early with the length of the Vec set too large. If\n the Vec is looked at or dropped, uninitialized memory will be read!\n \n The fix in this case is fairly simple. If we want to guarantee that the values\n-we *did* clone are dropped we can set the len *in* the loop. If we just want to\n-guarantee that uninitialized memory can't be observed, we can set the len\n-*after* the loop.\n+we *did* clone are dropped, we can set the `len` every loop iteration. If we\n+just want to guarantee that uninitialized memory can't be observed, we can set\n+the `len` after the loop.\n \n \n \n@@ -89,7 +88,7 @@ bubble_up(heap, index):\n \n A literal transcription of this code to Rust is totally fine, but has an annoying\n performance characteristic: the `self` element is swapped over and over again\n-uselessly. We would *rather* have the following:\n+uselessly. We would rather have the following:\n \n ```text\n bubble_up(heap, index):\n@@ -128,7 +127,7 @@ actually touched the state of the heap yet. Once we do start messing with the\n heap, we're working with only data and functions that we trust, so there's no\n concern of panics.\n \n-Perhaps you're not happy with this design. Surely, it's cheating! And we have\n+Perhaps you're not happy with this design. Surely it's cheating! And we have\n to do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\n intermix untrusted and unsafe code *for reals*.\n "}, {"sha": "0b653a7ad3a3e53c6f54e5eabd57e4a1e7198d38", "filename": "src/doc/tarpl/exotic-sizes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -48,7 +48,7 @@ a variable position based on its alignment][dst-issue].**\n \n # Zero Sized Types (ZSTs)\n \n-Rust actually allows types to be specified that occupy *no* space:\n+Rust actually allows types to be specified that occupy no space:\n \n ```rust\n struct Foo; // No fields = no size\n@@ -124,7 +124,7 @@ let res: Result<u32, Void> = Ok(0);\n let Ok(num) = res;\n ```\n \n-But neither of these tricks work today, so all Void types get you today is\n+But neither of these tricks work today, so all Void types get you is\n the ability to be confident that certain situations are statically impossible.\n \n One final subtle detail about empty types is that raw pointers to them are"}, {"sha": "8692832e2c77ccc7b02345957a5bf668cc94b3bc", "filename": "src/doc/tarpl/hrtb.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fhrtb.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fhrtb.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fhrtb.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -55,7 +55,7 @@ fn main() {\n How on earth are we supposed to express the lifetimes on `F`'s trait bound? We\n need to provide some lifetime there, but the lifetime we care about can't be\n named until we enter the body of `call`! Also, that isn't some fixed lifetime;\n-call works with *any* lifetime `&self` happens to have at that point.\n+`call` works with *any* lifetime `&self` happens to have at that point.\n \n This job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we\n desugar this is as follows:"}, {"sha": "1aa78e112ea187d98b9f8cccd78a59503acd4cf6", "filename": "src/doc/tarpl/leaking.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fleaking.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -21,21 +21,21 @@ uselessly, holding on to its precious resources until the program terminates (at\n which point all those resources would have been reclaimed by the OS anyway).\n \n We may consider a more restricted form of leak: failing to drop a value that is\n-unreachable. Rust also doesn't prevent this. In fact Rust has a *function for\n+unreachable. Rust also doesn't prevent this. In fact Rust *has a function for\n doing this*: `mem::forget`. This function consumes the value it is passed *and\n then doesn't run its destructor*.\n \n In the past `mem::forget` was marked as unsafe as a sort of lint against using\n it, since failing to call a destructor is generally not a well-behaved thing to\n do (though useful for some special unsafe code). However this was generally\n-determined to be an untenable stance to take: there are *many* ways to fail to\n+determined to be an untenable stance to take: there are many ways to fail to\n call a destructor in safe code. The most famous example is creating a cycle of\n reference-counted pointers using interior mutability.\n \n It is reasonable for safe code to assume that destructor leaks do not happen, as\n any program that leaks destructors is probably wrong. However *unsafe* code\n-cannot rely on destructors to be run to be *safe*. For most types this doesn't\n-matter: if you leak the destructor then the type is *by definition*\n+cannot rely on destructors to be run in order to be safe. For most types this\n+doesn't matter: if you leak the destructor then the type is by definition\n inaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>`\n then you waste some memory but that's hardly going to violate memory-safety.\n \n@@ -64,7 +64,7 @@ uninitialized data! We could backshift all the elements in the Vec every time we\n remove a value, but this would have pretty catastrophic performance\n consequences.\n \n-Instead, we would like Drain to *fix* the Vec's backing storage when it is\n+Instead, we would like Drain to fix the Vec's backing storage when it is\n dropped. It should run itself to completion, backshift any elements that weren't\n removed (drain supports subranges), and then fix Vec's `len`. It's even\n unwinding-safe! Easy!\n@@ -97,13 +97,13 @@ consistent state gives us Undefined Behaviour in safe code (making the API\n unsound).\n \n So what can we do? Well, we can pick a trivially consistent state: set the Vec's\n-len to be 0 when we *start* the iteration, and fix it up if necessary in the\n+len to be 0 when we start the iteration, and fix it up if necessary in the\n destructor. That way, if everything executes like normal we get the desired\n behaviour with minimal overhead. But if someone has the *audacity* to\n mem::forget us in the middle of the iteration, all that does is *leak even more*\n-(and possibly leave the Vec in an *unexpected* but consistent state). Since\n-we've accepted that mem::forget is safe, this is definitely safe. We call leaks\n-causing more leaks a *leak amplification*.\n+(and possibly leave the Vec in an unexpected but otherwise consistent state).\n+Since we've accepted that mem::forget is safe, this is definitely safe. We call\n+leaks causing more leaks a *leak amplification*.\n \n \n \n@@ -167,16 +167,16 @@ impl<T> Drop for Rc<T> {\n }\n ```\n \n-This code contains an implicit and subtle assumption: ref_count can fit in a\n+This code contains an implicit and subtle assumption: `ref_count` can fit in a\n `usize`, because there can't be more than `usize::MAX` Rcs in memory. However\n-this itself assumes that the ref_count accurately reflects the number of Rcs\n-in memory, which we know is false with mem::forget. Using mem::forget we can\n-overflow the ref_count, and then get it down to 0 with outstanding Rcs. Then we\n-can happily use-after-free the inner data. Bad Bad Not Good.\n+this itself assumes that the `ref_count` accurately reflects the number of Rcs\n+in memory, which we know is false with `mem::forget`. Using `mem::forget` we can\n+overflow the `ref_count`, and then get it down to 0 with outstanding Rcs. Then\n+we can happily use-after-free the inner data. Bad Bad Not Good.\n \n-This can be solved by *saturating* the ref_count, which is sound because\n-decreasing the refcount by `n` still requires `n` Rcs simultaneously living\n-in memory.\n+This can be solved by just checking the `ref_count` and doing *something*. The\n+standard library's stance is to just abort, because your program has become\n+horribly degenerate. Also *oh my gosh* it's such a ridiculous corner case.\n \n \n \n@@ -237,7 +237,7 @@ In principle, this totally works! Rust's ownership system perfectly ensures it!\n let mut data = Box::new(0);\n {\n     let guard = thread::scoped(|| {\n-        // This is at best a data race. At worst, it's *also* a use-after-free.\n+        // This is at best a data race. At worst, it's also a use-after-free.\n         *data += 1;\n     });\n     // Because the guard is forgotten, expiring the loan without blocking this"}, {"sha": "8b01616ee0d109efbf037b6f11dd593c42fee187", "filename": "src/doc/tarpl/lifetime-mismatch.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -18,7 +18,7 @@ fn main() {\n ```\n \n One might expect it to compile. We call `mutate_and_share`, which mutably borrows\n-`foo` *temporarily*, but then returns *only* a shared reference. Therefore we\n+`foo` temporarily, but then returns only a shared reference. Therefore we\n would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.\n \n However when we try to compile it:\n@@ -69,7 +69,7 @@ due to the lifetime of `loan` and mutate_and_share's signature. Then when we\n try to call `share`, and it sees we're trying to alias that `&'c mut foo` and\n blows up in our face!\n \n-This program is clearly correct according to the reference semantics we *actually*\n+This program is clearly correct according to the reference semantics we actually\n care about, but the lifetime system is too coarse-grained to handle that.\n \n \n@@ -78,4 +78,4 @@ TODO: other common problems? SEME regions stuff, mostly?\n \n \n \n-[ex2]: lifetimes.html#example-2:-aliasing-a-mutable-reference\n\\ No newline at end of file\n+[ex2]: lifetimes.html#example-2:-aliasing-a-mutable-reference"}, {"sha": "f211841ec0ce792e7193594558c7e891f0a70b53", "filename": "src/doc/tarpl/lifetimes.md", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetimes.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -6,11 +6,11 @@ and anything that contains a reference, is tagged with a lifetime specifying\n the scope it's valid for.\n \n Within a function body, Rust generally doesn't let you explicitly name the\n-lifetimes involved. This is because it's generally not really *necessary*\n+lifetimes involved. This is because it's generally not really necessary\n to talk about lifetimes in a local context; Rust has all the information and\n can work out everything as optimally as possible. Many anonymous scopes and\n temporaries that you would otherwise have to write are often introduced to\n-make your code *just work*.\n+make your code Just Work.\n \n However once you cross the function boundary, you need to start talking about\n lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip\n@@ -42,7 +42,7 @@ likely desugar to the following:\n 'a: {\n     let x: i32 = 0;\n     'b: {\n-        // lifetime used is 'b because that's *good enough*.\n+        // lifetime used is 'b because that's good enough.\n         let y: &'b i32 = &'b x;\n         'c: {\n             // ditto on 'c\n@@ -107,8 +107,9 @@ fn as_str<'a>(data: &'a u32) -> &'a str {\n This signature of `as_str` takes a reference to a u32 with *some* lifetime, and\n promises that it can produce a reference to a str that can live *just as long*.\n Already we can see why this signature might be trouble. That basically implies\n-that we're going to *find* a str somewhere in the scope the scope the reference\n-to the u32 originated in, or somewhere *even* earlier. That's a *bit* of a big ask.\n+that we're going to find a str somewhere in the scope the reference\n+to the u32 originated in, or somewhere *even earlier*. That's a bit of a big\n+ask.\n \n We then proceed to compute the string `s`, and return a reference to it. Since\n the contract of our function says the reference must outlive `'a`, that's the\n@@ -135,7 +136,7 @@ fn main() {\n         'd: {\n             // An anonymous scope is introduced because the borrow does not\n             // need to last for the whole scope x is valid for. The return\n-            // of as_str must find a str somewhere *before* this function\n+            // of as_str must find a str somewhere before this function\n             // call. Obviously not happening.\n             println!(\"{}\", as_str::<'d>(&'d x));\n         }\n@@ -195,21 +196,21 @@ println!(\"{}\", x);\n \n The problem here is is bit more subtle and interesting. We want Rust to\n reject this program for the following reason: We have a live shared reference `x`\n-to a descendent of `data` when try to take a *mutable* reference to `data`\n-when we call `push`. This would create an aliased mutable reference, which would\n+to a descendent of `data` when we try to take a mutable reference to `data`\n+to `push`. This would create an aliased mutable reference, which would\n violate the *second* rule of references.\n \n However this is *not at all* how Rust reasons that this program is bad. Rust\n doesn't understand that `x` is a reference to a subpath of `data`. It doesn't\n understand Vec at all. What it *does* see is that `x` has to live for `'b` to\n be printed. The signature of `Index::index` subsequently demands that the\n-reference we take to *data* has to survive for `'b`. When we try to call `push`,\n+reference we take to `data` has to survive for `'b`. When we try to call `push`,\n it then sees us try to make an `&'c mut data`. Rust knows that `'c` is contained\n within `'b`, and rejects our program because the `&'b data` must still be live!\n \n-Here we see that the lifetime system is *much* more coarse than the reference\n+Here we see that the lifetime system is much more coarse than the reference\n semantics we're actually interested in preserving. For the most part, *that's\n totally ok*, because it keeps us from spending all day explaining our program\n-to the compiler. However it does mean that several programs that are *totally*\n+to the compiler. However it does mean that several programs that are totally\n correct with respect to Rust's *true* semantics are rejected because lifetimes\n are too dumb."}, {"sha": "15e49c747b81075f46b83c59b142db0b0928f274", "filename": "src/doc/tarpl/meet-safe-and-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -29,7 +29,7 @@ Rust, you will never have to worry about type-safety or memory-safety. You will\n never endure a null or dangling pointer, or any of that Undefined Behaviour\n nonsense.\n \n-*That's totally awesome*.\n+*That's totally awesome.*\n \n The standard library also gives you enough utilities out-of-the-box that you'll\n be able to write awesome high-performance applications and libraries in pure\n@@ -41,7 +41,7 @@ low-level abstraction not exposed by the standard library. Maybe you're\n need to do something the type-system doesn't understand and just *frob some dang\n bits*. Maybe you need Unsafe Rust.\n \n-Unsafe Rust is exactly like Safe Rust with *all* the same rules and semantics.\n+Unsafe Rust is exactly like Safe Rust with all the same rules and semantics.\n However Unsafe Rust lets you do some *extra* things that are Definitely Not Safe.\n \n The only things that are different in Unsafe Rust are that you can:"}, {"sha": "e80c64c3543f8a18503d58db992b63aba2d12930", "filename": "src/doc/tarpl/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fownership.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -12,7 +12,7 @@ language?\n \n Regardless of your feelings on GC, it is pretty clearly a *massive* boon to\n making code safe. You never have to worry about things going away *too soon*\n-(although whether you still *wanted* to be pointing at that thing is a different\n+(although whether you still wanted to be pointing at that thing is a different\n issue...). This is a pervasive problem that C and C++ programs need to deal\n with. Consider this simple mistake that all of us who have used a non-GC'd\n language have made at one point:"}, {"sha": "0d7ec7f161796e3cf8bc26760e173d419b6e02f9", "filename": "src/doc/tarpl/phantom-data.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fphantom-data.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -14,11 +14,11 @@ struct Iter<'a, T: 'a> {\n \n However because `'a` is unused within the struct's body, it's *unbounded*.\n Because of the troubles this has historically caused, unbounded lifetimes and\n-types are *illegal* in struct definitions. Therefore we must somehow refer\n+types are *forbidden* in struct definitions. Therefore we must somehow refer\n to these types in the body. Correctly doing this is necessary to have\n correct variance and drop checking.\n \n-We do this using *PhantomData*, which is a special marker type. PhantomData\n+We do this using `PhantomData`, which is a special marker type. `PhantomData`\n consumes no space, but simulates a field of the given type for the purpose of\n static analysis. This was deemed to be less error-prone than explicitly telling\n the type-system the kind of variance that you want, while also providing other\n@@ -57,7 +57,7 @@ Good to go!\n Nope.\n \n The drop checker will generously determine that Vec<T> does not own any values\n-of type T. This will in turn make it conclude that it does *not* need to worry\n+of type T. This will in turn make it conclude that it doesn't need to worry\n about Vec dropping any T's in its destructor for determining drop check\n soundness. This will in turn allow people to create unsoundness using\n Vec's destructor."}, {"sha": "70de91af61f6f900c8746422fb7999d4a74be040", "filename": "src/doc/tarpl/poisoning.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fpoisoning.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b33a1e2de89c8b1c302da245b224653e8041d67/src%2Fdoc%2Ftarpl%2Fpoisoning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fpoisoning.md?ref=7b33a1e2de89c8b1c302da245b224653e8041d67", "patch": "@@ -20,7 +20,7 @@ standard library's Mutex type. A Mutex will poison itself if one of its\n MutexGuards (the thing it returns when a lock is obtained) is dropped during a\n panic. Any future attempts to lock the Mutex will return an `Err` or panic.\n \n-Mutex poisons not for *true* safety in the sense that Rust normally cares about. It\n+Mutex poisons not for true safety in the sense that Rust normally cares about. It\n poisons as a safety-guard against blindly using the data that comes out of a Mutex\n that has witnessed a panic while locked. The data in such a Mutex was likely in the\n middle of being modified, and as such may be in an inconsistent or incomplete state."}]}