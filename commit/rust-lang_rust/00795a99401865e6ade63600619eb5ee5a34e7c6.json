{"sha": "00795a99401865e6ade63600619eb5ee5a34e7c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNzk1YTk5NDAxODY1ZTZhZGU2MzYwMDYxOWViNWVlNWEzNGU3YzY=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-04-08T01:50:27Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-04-14T01:58:17Z"}, "message": "Fix style nits", "tree": {"sha": "fe7bc95b72f790967c7755e28157e2e5ab465bf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe7bc95b72f790967c7755e28157e2e5ab465bf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00795a99401865e6ade63600619eb5ee5a34e7c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00795a99401865e6ade63600619eb5ee5a34e7c6", "html_url": "https://github.com/rust-lang/rust/commit/00795a99401865e6ade63600619eb5ee5a34e7c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00795a99401865e6ade63600619eb5ee5a34e7c6/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df0a16b29fcd4e785598b4205a7b9a8cd4c48171", "url": "https://api.github.com/repos/rust-lang/rust/commits/df0a16b29fcd4e785598b4205a7b9a8cd4c48171", "html_url": "https://github.com/rust-lang/rust/commit/df0a16b29fcd4e785598b4205a7b9a8cd4c48171"}], "stats": {"total": 82, "additions": 37, "deletions": 45}, "files": [{"sha": "99e91bbe089c7e5d4a99b441ea6e1533b87285e5", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/00795a99401865e6ade63600619eb5ee5a34e7c6/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00795a99401865e6ade63600619eb5ee5a34e7c6/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=00795a99401865e6ade63600619eb5ee5a34e7c6", "patch": "@@ -1095,6 +1095,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             obligation.predicate, obligation.cause.span\n         );\n         let source_map = self.tcx.sess.source_map();\n+        let hir = self.tcx.hir();\n \n         // Attempt to detect an async-await error by looking at the obligation causes, looking\n         // for a generator to be present.\n@@ -1178,7 +1179,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let span = self.tcx.def_span(generator_did);\n \n         // Do not ICE on closure typeck (#66868).\n-        if self.tcx.hir().as_local_hir_id(generator_did).is_none() {\n+        if hir.as_local_hir_id(generator_did).is_none() {\n             return false;\n         }\n \n@@ -1204,12 +1205,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let generator_body = self\n-            .tcx\n-            .hir()\n+        let generator_body = hir\n             .as_local_hir_id(generator_did)\n-            .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n-            .map(|body_id| self.tcx.hir().body(body_id));\n+            .and_then(|hir_id| hir.maybe_body_owned_by(hir_id))\n+            .map(|body_id| hir.body(body_id));\n         let mut visitor = AwaitsVisitor::default();\n         if let Some(body) = generator_body {\n             visitor.visit_body(body);\n@@ -1219,50 +1218,46 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // Look for a type inside the generator interior that matches the target type to get\n         // a span.\n         let target_ty_erased = self.tcx.erase_regions(&target_ty);\n+        let ty_matches = |ty| -> bool {\n+            // Careful: the regions for types that appear in the\n+            // generator interior are not generally known, so we\n+            // want to erase them when comparing (and anyway,\n+            // `Send` and other bounds are generally unaffected by\n+            // the choice of region).  When erasing regions, we\n+            // also have to erase late-bound regions. This is\n+            // because the types that appear in the generator\n+            // interior generally contain \"bound regions\" to\n+            // represent regions that are part of the suspended\n+            // generator frame. Bound regions are preserved by\n+            // `erase_regions` and so we must also call\n+            // `erase_late_bound_regions`.\n+            let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(ty));\n+            let ty_erased = self.tcx.erase_regions(&ty_erased);\n+            let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n+            debug!(\n+                \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n+                    target_ty_erased={:?} eq={:?}\",\n+                ty_erased, target_ty_erased, eq\n+            );\n+            eq\n+        };\n         let target_span = tables\n             .generator_interior_types\n             .iter()\n-            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| {\n-                // Careful: the regions for types that appear in the\n-                // generator interior are not generally known, so we\n-                // want to erase them when comparing (and anyway,\n-                // `Send` and other bounds are generally unaffected by\n-                // the choice of region).  When erasing regions, we\n-                // also have to erase late-bound regions. This is\n-                // because the types that appear in the generator\n-                // interior generally contain \"bound regions\" to\n-                // represent regions that are part of the suspended\n-                // generator frame. Bound regions are preserved by\n-                // `erase_regions` and so we must also call\n-                // `erase_late_bound_regions`.\n-                let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(*ty));\n-                let ty_erased = self.tcx.erase_regions(&ty_erased);\n-                let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n-                debug!(\n-                    \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n-                        target_ty_erased={:?} eq={:?}\",\n-                    ty_erased, target_ty_erased, eq\n-                );\n-                eq\n-            })\n+            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty_matches(ty))\n             .map(|cause| {\n                 // Check to see if any awaited expressions have the target type.\n                 let from_awaited_ty = visitor\n                     .awaits\n                     .into_iter()\n-                    .map(|id| self.tcx.hir().expect_expr(id))\n-                    .find(|expr| {\n-                        let ty = tables.expr_ty_adjusted(&expr);\n-                        // Compare types using the same logic as above.\n-                        let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(ty));\n-                        let ty_erased = self.tcx.erase_regions(&ty_erased);\n-                        let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n+                    .map(|id| hir.expect_expr(id))\n+                    .find(|await_expr| {\n+                        let ty = tables.expr_ty_adjusted(&await_expr);\n                         debug!(\n-                            \"maybe_note_obligation_cause_for_async_await: await_expr={:?} \\\n-                            await_ty_erased={:?}  target_ty_erased={:?} eq={:?}\",\n-                            expr, ty_erased, target_ty_erased, eq\n+                            \"maybe_note_obligation_cause_for_async_await: await_expr={:?}\",\n+                            await_expr\n                         );\n-                        eq\n+                        ty_matches(ty)\n                     })\n                     .map(|expr| expr.span);\n                 let ty::GeneratorInteriorTypeCause { span, scope_span, expr, .. } = cause;\n@@ -1791,11 +1786,8 @@ impl<'v> Visitor<'v> for AwaitsVisitor {\n     }\n \n     fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-        match ex.kind {\n-            hir::ExprKind::Yield(_, hir::YieldSource::Await { expr: Some(id) }) => {\n-                self.awaits.push(id)\n-            }\n-            _ => (),\n+        if let hir::ExprKind::Yield(_, hir::YieldSource::Await { expr: Some(id) }) = ex.kind {\n+            self.awaits.push(id)\n         }\n         hir::intravisit::walk_expr(self, ex)\n     }"}]}