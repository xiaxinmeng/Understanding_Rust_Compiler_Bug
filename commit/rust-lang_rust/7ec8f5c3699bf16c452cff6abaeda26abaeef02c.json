{"sha": "7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYzhmNWMzNjk5YmYxNmM0NTJjZmY2YWJhZWRhMjZhYmFlZWYwMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-21T07:07:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-21T07:07:33Z"}, "message": "Auto merge of #32054 - seanmonstar:impl-debug-core, r=alexcrichton\n\nlibcore: add Debug implementations to most missing types\n\nAlso adds `#![deny(missing_debug_implementations)]` to the core crate.\n\ncc #31869", "tree": {"sha": "03778fce618b1d5dd712a9fbef1d7c6b731746ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03778fce618b1d5dd712a9fbef1d7c6b731746ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "html_url": "https://github.com/rust-lang/rust/commit/7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "html_url": "https://github.com/rust-lang/rust/commit/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1"}, {"sha": "e0945937c4d6786af0b03a11c8cec2c34cde7662", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0945937c4d6786af0b03a11c8cec2c34cde7662", "html_url": "https://github.com/rust-lang/rust/commit/e0945937c4d6786af0b03a11c8cec2c34cde7662"}], "stats": {"total": 353, "additions": 319, "deletions": 34}, "files": [{"sha": "5b39fa42c6edb184a456d01f65e28278f75b8d07", "filename": "src/libcore/char.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -416,14 +416,14 @@ pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n ///\n /// [`escape_unicode()`]: ../../std/primitive.char.html#method.escape_unicode\n /// [`char`]: ../../std/primitive.char.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeUnicode {\n     c: char,\n     state: EscapeUnicodeState\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -496,13 +496,13 @@ impl Iterator for EscapeUnicode {\n ///\n /// [`escape_default()`]: ../../std/primitive.char.html#method.escape_default\n /// [`char`]: ../../std/primitive.char.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n     state: EscapeDefaultState\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),"}, {"sha": "5ad1e2009b3f6b4fb849e2be7cf8c32880f42cc3", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -54,6 +54,7 @@ impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n ///\n /// Constructed by the `Formatter::debug_struct` method.\n #[must_use]\n+#[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n pub struct DebugStruct<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,\n@@ -120,6 +121,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n ///\n /// Constructed by the `Formatter::debug_tuple` method.\n #[must_use]\n+#[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n pub struct DebugTuple<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,\n@@ -231,6 +233,7 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n ///\n /// Constructed by the `Formatter::debug_set` method.\n #[must_use]\n+#[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n pub struct DebugSet<'a, 'b: 'a> {\n     inner: DebugInner<'a, 'b>,\n@@ -279,6 +282,7 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n ///\n /// Constructed by the `Formatter::debug_list` method.\n #[must_use]\n+#[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n pub struct DebugList<'a, 'b: 'a> {\n     inner: DebugInner<'a, 'b>,\n@@ -327,6 +331,7 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n ///\n /// Constructed by the `Formatter::debug_map` method.\n #[must_use]\n+#[allow(missing_debug_implementations)]\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n pub struct DebugMap<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,"}, {"sha": "d2da16624cabe91d1d9d454a2549f34b9cc8ab8f", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -14,7 +14,7 @@\n \n use prelude::v1::*;\n \n-use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n+use cell::{UnsafeCell, Cell, RefCell, Ref, RefMut, BorrowState};\n use marker::PhantomData;\n use mem;\n use num::flt2dec;\n@@ -25,6 +25,7 @@ use str;\n \n #[unstable(feature = \"fmt_flags_align\", issue = \"27726\")]\n /// Possible alignments returned by `Formatter::align`\n+#[derive(Debug)]\n pub enum Alignment {\n     /// Indication that contents should be left-aligned.\n     Left,\n@@ -152,6 +153,7 @@ impl<'a, W: Write + ?Sized> Write for &'a mut W {\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n+#[allow(missing_debug_implementations)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Formatter<'a> {\n     flags: u32,\n@@ -175,6 +177,7 @@ enum Void {}\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[derive(Copy)]\n+#[allow(missing_debug_implementations)]\n #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n            issue = \"0\")]\n #[doc(hidden)]\n@@ -1585,7 +1588,9 @@ impl<T: ?Sized> Debug for PhantomData<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        write!(f, \"Cell {{ value: {:?} }}\", self.get())\n+        f.debug_struct(\"Cell\")\n+            .field(\"value\", &self.get())\n+            .finish()\n     }\n }\n \n@@ -1594,9 +1599,15 @@ impl<T: ?Sized + Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.borrow_state() {\n             BorrowState::Unused | BorrowState::Reading => {\n-                write!(f, \"RefCell {{ value: {:?} }}\", self.borrow())\n+                f.debug_struct(\"RefCell\")\n+                    .field(\"value\", &self.borrow())\n+                    .finish()\n+            }\n+            BorrowState::Writing => {\n+                f.debug_struct(\"RefCell\")\n+                    .field(\"value\", &\"<borrowed>\")\n+                    .finish()\n             }\n-            BorrowState::Writing => write!(f, \"RefCell {{ <borrowed> }}\"),\n         }\n     }\n }\n@@ -1615,5 +1626,12 @@ impl<'b, T: ?Sized + Debug> Debug for RefMut<'b, T> {\n     }\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T: ?Sized + Debug> Debug for UnsafeCell<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(\"UnsafeCell\")\n+    }\n+}\n+\n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n // it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "6b31e040622cd083943d7396d80c52207264554b", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -13,6 +13,7 @@\n //!\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n+#![allow(missing_debug_implementations)]\n \n #[derive(Copy, Clone)]\n pub struct Argument {"}, {"sha": "4d0fed983343611f32a57a5591275b3e2a606304", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -73,6 +73,7 @@\n \n use prelude::v1::*;\n \n+use fmt;\n use marker;\n use mem;\n \n@@ -215,6 +216,13 @@ pub trait BuildHasher {\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n \n+#[stable(since = \"1.9.0\", feature = \"core_impl_debug\")]\n+impl<H> fmt::Debug for BuildHasherDefault<H> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"BuildHasherDefault\")\n+    }\n+}\n+\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n impl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n     type Hasher = H;"}, {"sha": "a1a306d5c7d7da7fc3aff94e4b2e38e7797dcc31", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -30,6 +30,7 @@ use super::Hasher;\n /// Although the SipHash algorithm is considered to be generally strong,\n /// it is not intended for cryptographic purposes. As such, all\n /// cryptographic uses of this implementation are _strongly discouraged_.\n+#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SipHasher {\n     k0: u64,"}, {"sha": "72421e94a435528b206c4149e07232ecb452d764", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 101, "deletions": 14, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -303,6 +303,7 @@ use clone::Clone;\n use cmp;\n use cmp::{Ord, PartialOrd, PartialEq, Ordering};\n use default::Default;\n+use fmt;\n use marker;\n use mem;\n use num::{Zero, One};\n@@ -2929,7 +2930,7 @@ impl<A, B> ExactSizeIterator for Zip<A, B>\n ///\n /// [`rev()`]: trait.Iterator.html#method.rev\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rev<T> {\n@@ -2961,7 +2962,7 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n /// [`Iterator`]: trait.Iterator.html\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct Cloned<I> {\n     it: I,\n }\n@@ -3002,7 +3003,7 @@ impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n ///\n /// [`cycle()`]: trait.Iterator.html#method.cycle\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cycle<I> {\n@@ -3040,7 +3041,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n ///\n /// [`chain()`]: trait.Iterator.html#method.chain\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n@@ -3062,7 +3063,7 @@ pub struct Chain<A, B> {\n //\n //  The fourth state (neither iterator is remaining) only occurs after Chain has\n //  returned None once, so we don't need to store this state.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n enum ChainState {\n     // both front and back iterator are remaining\n     Both,\n@@ -3184,7 +3185,7 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n ///\n /// [`zip()`]: trait.Iterator.html#method.zip\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Zip<A, B> {\n@@ -3307,6 +3308,15 @@ pub struct Map<I, F> {\n     f: F,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Map\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n     type Item = B;\n@@ -3347,6 +3357,15 @@ pub struct Filter<I, P> {\n     predicate: P,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Filter\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n     type Item = I::Item;\n@@ -3398,6 +3417,15 @@ pub struct FilterMap<I, F> {\n     f: F,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FilterMap\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     where F: FnMut(I::Item) -> Option<B>,\n@@ -3443,7 +3471,7 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n ///\n /// [`enumerate()`]: trait.Iterator.html#method.enumerate\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Enumerate<I> {\n@@ -3517,7 +3545,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n ///\n /// [`peekable()`]: trait.Iterator.html#method.peekable\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Peekable<I: Iterator> {\n@@ -3676,6 +3704,16 @@ pub struct SkipWhile<I, P> {\n     predicate: P,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SkipWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n     where P: FnMut(&I::Item) -> bool\n@@ -3716,6 +3754,16 @@ pub struct TakeWhile<I, P> {\n     predicate: P,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"TakeWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n     where P: FnMut(&I::Item) -> bool\n@@ -3752,7 +3800,7 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n ///\n /// [`skip()`]: trait.Iterator.html#method.skip\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Skip<I> {\n@@ -3843,7 +3891,7 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n ///\n /// [`take()`]: trait.Iterator.html#method.take\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<I> {\n@@ -3914,6 +3962,16 @@ pub struct Scan<I, St, F> {\n     state: St,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Scan\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"state\", &self.state)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I, St, F> Iterator for Scan<I, St, F> where\n     I: Iterator,\n@@ -3951,6 +4009,19 @@ pub struct FlatMap<I, U: IntoIterator, F> {\n     backiter: Option<U::IntoIter>,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n+    where U::IntoIter: fmt::Debug\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FlatMap\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"frontiter\", &self.frontiter)\n+            .field(\"backiter\", &self.backiter)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n     where F: FnMut(I::Item) -> U,\n@@ -4014,7 +4085,7 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n ///\n /// [`fuse()`]: trait.Iterator.html#method.fuse\n /// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Fuse<I> {\n@@ -4109,6 +4180,15 @@ pub struct Inspect<I, F> {\n     f: F,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Inspect\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n@@ -4272,7 +4352,7 @@ step_impl_no_between!(u64 i64);\n /// The resulting iterator handles overflow by stopping. The `A`\n /// parameter is the type being iterated over, while `R` is the range\n /// type (usually one of `std::ops::{Range, RangeFrom, RangeInclusive}`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[unstable(feature = \"step_by\", reason = \"recent addition\",\n            issue = \"27741\")]\n pub struct StepBy<A, R> {\n@@ -4679,7 +4759,7 @@ impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n /// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n ///\n /// [`repeat()`]: fn.repeat.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n     element: A\n@@ -4761,6 +4841,13 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub struct Empty<T>(marker::PhantomData<T>);\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T> fmt::Debug for Empty<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Empty\")\n+    }\n+}\n+\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n impl<T> Iterator for Empty<T> {\n     type Item = T;\n@@ -4830,7 +4917,7 @@ pub fn empty<T>() -> Empty<T> {\n /// This `struct` is created by the [`once()`] function. See its documentation for more.\n ///\n /// [`once()`]: fn.once.html\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub struct Once<T> {\n     inner: ::option::IntoIter<T>"}, {"sha": "f199909dfa90aaa097354e6e607c87517f3ebff8", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -56,6 +56,7 @@\n \n #![no_core]\n #![deny(missing_docs)]\n+#![deny(missing_debug_implementations)]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(allow_internal_unstable)]"}, {"sha": "b549f33424264d3ddcf741b19cc8408486aabd74", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -222,6 +222,7 @@ impl<'a> Part<'a> {\n \n /// Formatted result containing one or more parts.\n /// This can be written to the byte buffer or converted to the allocated string.\n+#[allow(missing_debug_implementations)]\n #[derive(Clone)]\n pub struct Formatted<'a> {\n     /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`."}, {"sha": "dd60e8797a948347c7bd2655d9cc0b81a02eddd4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -763,7 +763,7 @@ impl<'a, T> IntoIterator for &'a mut Option<T> {\n // The Option Iterators\n /////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n struct Item<A> {\n     opt: Option<A>\n }\n@@ -796,6 +796,7 @@ impl<A> ExactSizeIterator for Item<A> {}\n \n /// An iterator over a reference of the contained item in an Option.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -826,6 +827,7 @@ impl<'a, A> Clone for Iter<'a, A> {\n \n /// An iterator over a mutable reference of the contained item in an Option.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -848,7 +850,7 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }\n "}, {"sha": "ec72809acab6a23d0333b4e930757ca610bb651b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -520,6 +520,7 @@ impl<T: ?Sized> PartialOrd for *mut T {\n /// modified without a unique path to the `Unique` reference. Useful\n /// for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n+#[allow(missing_debug_implementations)]\n #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n pub struct Unique<T: ?Sized> {\n@@ -592,6 +593,7 @@ impl<T> fmt::Pointer for Unique<T> {\n /// of this wrapper has shared ownership of the referent. Useful for\n /// building abstractions like `Rc<T>` or `Arc<T>`, which internally\n /// use raw pointers to manage the memory that they own.\n+#[allow(missing_debug_implementations)]\n #[unstable(feature = \"shared\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n pub struct Shared<T: ?Sized> {"}, {"sha": "20c85b5efc116cdc03cc7b62c0de5e9e3670745b", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -59,6 +59,7 @@ use mem;\n /// println!(\"data pointer = {:?}, length = {}\", repr.data, repr.len);\n /// ```\n #[repr(C)]\n+#[allow(missing_debug_implementations)]\n pub struct Slice<T> {\n     pub data: *const T,\n     pub len: usize,\n@@ -143,6 +144,7 @@ impl<T> Clone for Slice<T> {\n /// ```\n #[repr(C)]\n #[derive(Copy, Clone)]\n+#[allow(missing_debug_implementations)]\n pub struct TraitObject {\n     pub data: *mut (),\n     pub vtable: *mut (),"}, {"sha": "7f8cf531d26176bc7a8e52739892bef13cb8f129", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -799,6 +799,7 @@ impl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n /////////////////////////////////////////////////////////////////////////////\n \n /// An iterator over a reference to the `Ok` variant of a `Result`.\n+#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n@@ -830,6 +831,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n }\n \n /// An iterator over a mutable reference to the `Ok` variant of a `Result`.\n+#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n@@ -856,6 +858,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n+#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> { inner: Option<T> }\n "}, {"sha": "aa555b44e899f89a786a31ec4343afd97ce212ad", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -38,6 +38,7 @@ use cmp::{Ordering, PartialEq, PartialOrd, Eq, Ord};\n use cmp::Ordering::{Less, Equal, Greater};\n use cmp;\n use default::Default;\n+use fmt;\n use intrinsics::assume;\n use iter::*;\n use ops::{FnMut, self, Index};\n@@ -877,6 +878,15 @@ pub struct Iter<'a, T: 'a> {\n     _marker: marker::PhantomData<&'a T>,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"Iter\")\n+            .field(&self.as_slice())\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -925,6 +935,15 @@ pub struct IterMut<'a, T: 'a> {\n     _marker: marker::PhantomData<&'a mut T>,\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"IterMut\")\n+            .field(&make_slice!(self.ptr, self.end))\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -980,6 +999,16 @@ pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     finished: bool\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Split\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n@@ -1053,6 +1082,16 @@ pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     finished: bool\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SplitMut\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a mut [T]> {\n@@ -1127,6 +1166,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n /// An private iterator over subslices separated by elements that\n /// match a predicate function, splitting at most a fixed number of\n /// times.\n+#[derive(Debug)]\n struct GenericSplitN<I> {\n     iter: I,\n     count: usize,\n@@ -1162,6 +1202,15 @@ pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitN<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SplitN\")\n+            .field(\"inner\", &self.inner)\n+            .finish()\n+    }\n+}\n+\n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n@@ -1170,13 +1219,31 @@ pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitN<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RSplitN\")\n+            .field(\"inner\", &self.inner)\n+            .finish()\n+    }\n+}\n+\n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitNMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SplitNMut\")\n+            .field(\"inner\", &self.inner)\n+            .finish()\n+    }\n+}\n+\n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n@@ -1185,6 +1252,15 @@ pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitNMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RSplitNMut\")\n+            .field(\"inner\", &self.inner)\n+            .finish()\n+    }\n+}\n+\n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1212,6 +1288,7 @@ forward_iterator! { SplitNMut: T, &'a mut [T] }\n forward_iterator! { RSplitNMut: T, &'a mut [T] }\n \n /// An iterator over overlapping subslices of length `size`.\n+#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n@@ -1305,6 +1382,7 @@ impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n ///\n /// When the slice len is not evenly divided by the chunk size, the last slice\n /// of the iteration will be the remainder.\n+#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n@@ -1405,6 +1483,7 @@ impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n /// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n+#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],"}, {"sha": "8e467f52fa4a814bf4066850613e8b042004cc8f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -323,7 +323,7 @@ Section: Iterators\n /// Created with the method [`chars()`].\n ///\n /// [`chars()`]: ../../std/primitive.str.html#method.chars\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n@@ -468,7 +468,7 @@ impl<'a> Chars<'a> {\n }\n \n /// Iterator for a string's characters and their byte offsets.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n     front_offset: usize,\n@@ -533,7 +533,7 @@ impl<'a> CharIndices<'a> {\n ///\n /// [`bytes()`]: ../../std/primitive.str.html#method.bytes\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -662,6 +662,17 @@ macro_rules! generate_pattern_iterators {\n         $(#[$common_stability_attribute])*\n         pub struct $forward_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n \n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> fmt::Debug for $forward_iterator<'a, P>\n+            where P::Searcher: fmt::Debug\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                f.debug_tuple(stringify!($forward_iterator))\n+                    .field(&self.0)\n+                    .finish()\n+            }\n+        }\n+\n         $(#[$common_stability_attribute])*\n         impl<'a, P: Pattern<'a>> Iterator for $forward_iterator<'a, P> {\n             type Item = $iterty;\n@@ -685,6 +696,17 @@ macro_rules! generate_pattern_iterators {\n         $(#[$common_stability_attribute])*\n         pub struct $reverse_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n \n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> fmt::Debug for $reverse_iterator<'a, P>\n+            where P::Searcher: fmt::Debug\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                f.debug_tuple(stringify!($reverse_iterator))\n+                    .field(&self.0)\n+                    .finish()\n+            }\n+        }\n+\n         $(#[$common_stability_attribute])*\n         impl<'a, P: Pattern<'a>> Iterator for $reverse_iterator<'a, P>\n             where P::Searcher: ReverseSearcher<'a>\n@@ -746,6 +768,7 @@ derive_pattern_clone!{\n     clone SplitInternal\n     with |s| SplitInternal { matcher: s.matcher.clone(), ..*s }\n }\n+\n struct SplitInternal<'a, P: Pattern<'a>> {\n     start: usize,\n     end: usize,\n@@ -754,6 +777,18 @@ struct SplitInternal<'a, P: Pattern<'a>> {\n     finished: bool,\n }\n \n+impl<'a, P: Pattern<'a>> fmt::Debug for SplitInternal<'a, P> where P::Searcher: fmt::Debug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SplitInternal\")\n+            .field(\"start\", &self.start)\n+            .field(\"end\", &self.end)\n+            .field(\"matcher\", &self.matcher)\n+            .field(\"allow_trailing_empty\", &self.allow_trailing_empty)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     #[inline]\n     fn get_end(&mut self) -> Option<&'a str> {\n@@ -852,12 +887,22 @@ derive_pattern_clone!{\n     clone SplitNInternal\n     with |s| SplitNInternal { iter: s.iter.clone(), ..*s }\n }\n+\n struct SplitNInternal<'a, P: Pattern<'a>> {\n     iter: SplitInternal<'a, P>,\n     /// The number of splits remaining\n     count: usize,\n }\n \n+impl<'a, P: Pattern<'a>> fmt::Debug for SplitNInternal<'a, P> where P::Searcher: fmt::Debug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SplitNInternal\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"count\", &self.count)\n+            .finish()\n+    }\n+}\n+\n impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n@@ -902,8 +947,17 @@ derive_pattern_clone!{\n     clone MatchIndicesInternal\n     with |s| MatchIndicesInternal(s.0.clone())\n }\n+\n struct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);\n \n+impl<'a, P: Pattern<'a>> fmt::Debug for MatchIndicesInternal<'a, P> where P::Searcher: fmt::Debug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"MatchIndicesInternal\")\n+            .field(&self.0)\n+            .finish()\n+    }\n+}\n+\n impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<(usize, &'a str)> {\n@@ -944,8 +998,17 @@ derive_pattern_clone!{\n     clone MatchesInternal\n     with |s| MatchesInternal(s.0.clone())\n }\n+\n struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);\n \n+impl<'a, P: Pattern<'a>> fmt::Debug for MatchesInternal<'a, P> where P::Searcher: fmt::Debug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"MatchesInternal\")\n+            .field(&self.0)\n+            .finish()\n+    }\n+}\n+\n impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n@@ -988,7 +1051,7 @@ generate_pattern_iterators! {\n ///\n /// [`lines()`]: ../../std/primitive.str.html#method.lines\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct Lines<'a>(Map<SplitTerminator<'a, char>, LinesAnyMap>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1019,7 +1082,7 @@ impl<'a> DoubleEndedIterator for Lines<'a> {\n /// [`lines_any()`]: ../../std/primitive.str.html#method.lines_any\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")]\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[allow(deprecated)]\n pub struct LinesAny<'a>(Lines<'a>);\n \n@@ -1242,7 +1305,7 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n /// Struct that contains a `char` and the index of the first byte of\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n #[unstable(feature = \"str_char\",\n            reason = \"existence of this struct is uncertain as it is frequently \\\n                      able to be replaced with char.len_utf8() and/or \\"}, {"sha": "b803539e12b1a2fd6d91a26d56fb854851168340", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -20,6 +20,7 @@\n use prelude::v1::*;\n \n use cmp;\n+use fmt;\n use usize;\n \n // Pattern\n@@ -275,7 +276,7 @@ impl<'a> CharEq for &'a [char] {\n \n struct CharEqPattern<C: CharEq>(C);\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n struct CharEqSearcher<'a, C: CharEq> {\n     char_eq: C,\n     haystack: &'a str,\n@@ -415,7 +416,7 @@ macro_rules! searcher_methods {\n /////////////////////////////////////////////////////////////////////////////\n \n /// Associated type for `<char as Pattern<'a>>::Searcher`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct CharSearcher<'a>(<CharEqPattern<char> as Pattern<'a>>::Searcher);\n \n unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n@@ -440,7 +441,7 @@ impl<'a> Pattern<'a> for char {\n // Todo: Change / Remove due to ambiguity in meaning.\n \n /// Associated type for `<&[char] as Pattern<'a>>::Searcher`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct CharSliceSearcher<'a, 'b>(<CharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);\n \n unsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> {\n@@ -467,6 +468,17 @@ impl<'a, 'b> Pattern<'a> for &'b [char] {\n pub struct CharPredicateSearcher<'a, F>(<CharEqPattern<F> as Pattern<'a>>::Searcher)\n     where F: FnMut(char) -> bool;\n \n+impl<'a, F> fmt::Debug for CharPredicateSearcher<'a, F>\n+    where F: FnMut(char) -> bool\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"CharPredicateSearcher\")\n+            .field(\"haystack\", &self.0.haystack)\n+            .field(\"char_indices\", &self.0.char_indices)\n+            .field(\"ascii_only\", &self.0.ascii_only)\n+            .finish()\n+    }\n+}\n unsafe impl<'a, F> Searcher<'a> for CharPredicateSearcher<'a, F>\n     where F: FnMut(char) -> bool\n {"}, {"sha": "7ae129eaf487875e9c0532c50520b2f726f2c0ab", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec8f5c3699bf16c452cff6abaeda26abaeef02c/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "patch": "@@ -162,7 +162,7 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// Rust's memory orderings are [the same as\n /// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations. Corresponds to LLVM's\n     /// `Monotonic` ordering."}]}