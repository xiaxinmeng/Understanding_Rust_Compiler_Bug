{"sha": "261bed1f8e4717228d5270133522f65da9ced034", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MWJlZDFmOGU0NzE3MjI4ZDUyNzAxMzM1MjJmNjVkYTljZWQwMzQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-31T08:46:15Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-31T08:46:15Z"}, "message": "Merge pull request #524 from devonhollowood/iterator-suggestions\n\nIterator suggestions", "tree": {"sha": "652921ac6cb902f20ce304e61a817e67b9b7641c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/652921ac6cb902f20ce304e61a817e67b9b7641c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/261bed1f8e4717228d5270133522f65da9ced034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/261bed1f8e4717228d5270133522f65da9ced034", "html_url": "https://github.com/rust-lang/rust/commit/261bed1f8e4717228d5270133522f65da9ced034", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/261bed1f8e4717228d5270133522f65da9ced034/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7f3fa6713c24882c5a8affe506e2c17dc50f1fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7f3fa6713c24882c5a8affe506e2c17dc50f1fa", "html_url": "https://github.com/rust-lang/rust/commit/e7f3fa6713c24882c5a8affe506e2c17dc50f1fa"}, {"sha": "093582c102b4ca983e9b6ef620860a75f6a1d812", "url": "https://api.github.com/repos/rust-lang/rust/commits/093582c102b4ca983e9b6ef620860a75f6a1d812", "html_url": "https://github.com/rust-lang/rust/commit/093582c102b4ca983e9b6ef620860a75f6a1d812"}], "stats": {"total": 198, "additions": 184, "deletions": 14}, "files": [{"sha": "9fe59d4fdaf80fba2de2632f66f8b7b02ab34a81", "filename": "README.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/261bed1f8e4717228d5270133522f65da9ced034/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/261bed1f8e4717228d5270133522f65da9ced034/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=261bed1f8e4717228d5270133522f65da9ced034", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 86 lints included in this crate:\n+There are 88 lints included in this crate:\n \n name                                                                                                     | default | meaning\n ---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -28,6 +28,7 @@ name\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                           | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n [explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)           | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                 | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n+[filter_next](https://github.com/Manishearth/rust-clippy/wiki#filter_next)                               | warn    | using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\n [float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                   | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n [identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                               | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)             | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n@@ -55,8 +56,8 @@ name\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                   | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)     | warn    | nonsensical combination of options for opening a file\n [ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                   | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n-[option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)             | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`)\n-[option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)   | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`)\n+[option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)             | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\n+[option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)   | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\n [option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                 | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n [out_of_bounds_indexing](https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing)         | deny    | out of bound constant indexing\n [panic_params](https://github.com/Manishearth/rust-clippy/wiki#panic_params)                             | warn    | missing parameters in `panic!`\n@@ -68,6 +69,7 @@ name\n [redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                   | warn    | using `name @ _` in a pattern\n [result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)                 | allow   | using `Result.unwrap()`, which might be better handled\n [reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)                 | warn    | Iterating over an empty range, such as `10..0` or `5..5`\n+[search_is_some](https://github.com/Manishearth/rust-clippy/wiki#search_is_some)                         | warn    | using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`\n [shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                             | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                               | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n [shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                     | allow   | The name is re-bound without even using the original value"}, {"sha": "6d39cad20cdb703a942228cd1b19e1818515bc4e", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/261bed1f8e4717228d5270133522f65da9ced034/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/261bed1f8e4717228d5270133522f65da9ced034/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=261bed1f8e4717228d5270133522f65da9ced034", "patch": "@@ -176,9 +176,11 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_BOOL,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n+        methods::FILTER_NEXT,\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_UNWRAP_OR,\n         methods::OPTION_MAP_UNWRAP_OR_ELSE,\n+        methods::SEARCH_IS_SOME,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,"}, {"sha": "a6200534e30e7c50d5eba61065f019c8aef06ef0", "filename": "src/methods.rs", "status": "modified", "additions": 83, "deletions": 9, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/261bed1f8e4717228d5270133522f65da9ced034/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/261bed1f8e4717228d5270133522f65da9ced034/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=261bed1f8e4717228d5270133522f65da9ced034", "patch": "@@ -6,7 +6,7 @@ use std::iter;\n use std::borrow::Cow;\n \n use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args,\n-            walk_ptrs_ty_depth, walk_ptrs_ty};\n+            match_trait_method, walk_ptrs_ty_depth, walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n use utils::MethodArgs;\n \n@@ -135,7 +135,7 @@ declare_lint!(pub OK_EXPECT, Warn,\n /// **Example:** `x.map(|a| a + 1).unwrap_or(0)`\n declare_lint!(pub OPTION_MAP_UNWRAP_OR, Warn,\n               \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n-               `map_or(a, f)`)\");\n+               `map_or(a, f)`\");\n \n /// **What it does:** This lint `Warn`s on `_.map(_).unwrap_or_else(_)`.\n ///\n@@ -146,7 +146,29 @@ declare_lint!(pub OPTION_MAP_UNWRAP_OR, Warn,\n /// **Example:** `x.map(|a| a + 1).unwrap_or_else(some_function)`\n declare_lint!(pub OPTION_MAP_UNWRAP_OR_ELSE, Warn,\n               \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n-               `map_or_else(g, f)`)\");\n+               `map_or_else(g, f)`\");\n+\n+/// **What it does:** This lint `Warn`s on `_.filter(_).next()`.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as `_.find(_)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `iter.filter(|x| x == 0).next()`\n+declare_lint!(pub FILTER_NEXT, Warn,\n+              \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\");\n+\n+/// **What it does:** This lint `Warn`s on an iterator search (such as `find()`, `position()`, or\n+/// `rposition()`) followed by a call to `is_some()`.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as `_.any(_)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `iter.find(|x| x == 0).is_some()`\n+declare_lint!(pub SEARCH_IS_SOME, Warn,\n+              \"using an iterator search followed by `is_some()`, which is more succinctly \\\n+               expressed as a call to `any()`\");\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n@@ -174,6 +196,18 @@ impl LateLintPass for MethodsPass {\n             else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n                 lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n             }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n+                lint_filter_next(cx, expr, arglists[0]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n+                lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n+                lint_search_is_some(cx, expr, \"position\", arglists[0], arglists[1]);\n+            }\n+            else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n+                lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n+            }\n         }\n     }\n \n@@ -275,8 +309,8 @@ fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n \n #[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs,\n-                      map_args: &MethodArgs) {\n+fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n+                      unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n         // lint message\n@@ -293,7 +327,8 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs,\n         if same_span && !multiline {\n             span_note_and_lint(\n                 cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n-                &format!(\"replace this with map_or({1}, {0})\", map_snippet, unwrap_snippet)\n+                &format!(\"replace `map({0}).unwrap_or({1})` with `map_or({1}, {0})`\", map_snippet,\n+                         unwrap_snippet)\n             );\n         }\n         else if same_span && multiline {\n@@ -304,8 +339,8 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs,\n \n #[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or_else()` for `Option`s\n-fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs,\n-                           map_args: &MethodArgs) {\n+fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n+                           unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n         // lint message\n@@ -322,7 +357,8 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, unwrap_args: &MethodAr\n         if same_span && !multiline {\n             span_note_and_lint(\n                 cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n-                &format!(\"replace this with map_or_else({1}, {0})\", map_snippet, unwrap_snippet)\n+                &format!(\"replace `map({0}).unwrap_or_else({1})` with `with map_or_else({1}, {0})`\",\n+                          map_snippet, unwrap_snippet)\n             );\n         }\n         else if same_span && multiline {\n@@ -331,6 +367,44 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, unwrap_args: &MethodAr\n     }\n }\n \n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint use of `filter().next() for Iterators`\n+fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n+    // lint if caller of `.filter().next()` is an Iterator\n+    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+        let msg = \"called `filter(p).next()` on an Iterator. This is more succinctly expressed by \\\n+                   calling `.find(p)` instead.\";\n+        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        if filter_snippet.lines().count() <= 1 { // add note if not multi-line\n+            span_note_and_lint(cx, FILTER_NEXT, expr.span, msg, expr.span,\n+                &format!(\"replace `filter({0}).next()` with `find({0})`\", filter_snippet));\n+        }\n+        else {\n+            span_lint(cx, FILTER_NEXT, expr.span, msg);\n+        }\n+    }\n+}\n+\n+#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+/// lint searching an Iterator followed by `is_some()`\n+fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, search_args: &MethodArgs,\n+                       is_some_args: &MethodArgs) {\n+    // lint if caller of search is an Iterator\n+    if match_trait_method(cx, &*is_some_args[0], &[\"core\", \"iter\", \"Iterator\"]) {\n+        let msg = format!(\"called `is_some()` after searching an iterator with {}. This is more \\\n+                           succinctly expressed by calling `any()`.\", search_method);\n+        let search_snippet = snippet(cx, search_args[1].span, \"..\");\n+        if search_snippet.lines().count() <= 1 { // add note if not multi-line\n+            span_note_and_lint(cx, SEARCH_IS_SOME, expr.span, &msg, expr.span,\n+                &format!(\"replace `{0}({1}).is_some()` with `any({1})`\", search_method,\n+                         search_snippet));\n+        }\n+        else {\n+            span_lint(cx, SEARCH_IS_SOME, expr.span, &msg);\n+        }\n+    }\n+}\n+\n // Given a `Result<T, E>` type, return its error type (`E`)\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     if !match_type(cx, ty, &RESULT_PATH) {"}, {"sha": "b41b28dc11e44592ac6258abdd39e70bad7bb400", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/261bed1f8e4717228d5270133522f65da9ced034/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/261bed1f8e4717228d5270133522f65da9ced034/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=261bed1f8e4717228d5270133522f65da9ced034", "patch": "@@ -50,7 +50,7 @@ fn option_methods() {\n     // Check OPTION_MAP_UNWRAP_OR\n     // single line case\n     let _ = opt.map(|x| x + 1) //~  ERROR called `map(f).unwrap_or(a)`\n-                               //~| NOTE replace this\n+                               //~| NOTE replace `map(|x| x + 1).unwrap_or(0)`\n                .unwrap_or(0); // should lint even though this call is on a separate line\n     // multi line cases\n     let _ = opt.map(|x| { //~ ERROR called `map(f).unwrap_or(a)`\n@@ -67,7 +67,7 @@ fn option_methods() {\n     // Check OPTION_MAP_UNWRAP_OR_ELSE\n     // single line case\n     let _ = opt.map(|x| x + 1) //~  ERROR called `map(f).unwrap_or_else(g)`\n-                               //~| NOTE replace this\n+                               //~| NOTE replace `map(|x| x + 1).unwrap_or_else(|| 0)`\n                .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n     // multi line cases\n     let _ = opt.map(|x| { //~ ERROR called `map(f).unwrap_or_else(g)`\n@@ -83,6 +83,98 @@ fn option_methods() {\n \n }\n \n+/// Struct to generate false positive for Iterator-based lints\n+#[derive(Copy, Clone)]\n+struct IteratorFalsePositives {\n+    foo: u32,\n+}\n+\n+impl IteratorFalsePositives {\n+    fn filter(self) -> IteratorFalsePositives {\n+        self\n+    }\n+\n+    fn next(self) -> IteratorFalsePositives {\n+        self\n+    }\n+\n+    fn find(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+\n+    fn position(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+\n+    fn rposition(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+}\n+\n+/// Checks implementation of FILTER_NEXT lint\n+fn filter_next() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // check single-line case\n+    let _ = v.iter().filter(|&x| *x < 0).next();\n+    //~^ ERROR called `filter(p).next()` on an Iterator.\n+    //~| NOTE replace `filter(|&x| *x < 0).next()`\n+\n+    // check multi-line case\n+    let _ = v.iter().filter(|&x| { //~ERROR called `filter(p).next()` on an Iterator.\n+                                *x < 0\n+                            }\n+                   ).next();\n+\n+    // check that we don't lint if the caller is not an Iterator\n+    let foo = IteratorFalsePositives { foo: 0 };\n+    let _ = foo.filter().next();\n+}\n+\n+/// Checks implementation of SEARCH_IS_SOME lint\n+fn search_is_some() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+\n+    // check `find().is_some()`, single-line\n+    let _ = v.iter().find(|&x| *x < 0).is_some();\n+    //~^ ERROR called `is_some()` after searching\n+    //~| NOTE replace `find(|&x| *x < 0).is_some()`\n+\n+    // check `find().is_some()`, multi-line\n+    let _ = v.iter().find(|&x| { //~ERROR called `is_some()` after searching\n+                              *x < 0\n+                          }\n+                   ).is_some();\n+\n+    // check `position().is_some()`, single-line\n+    let _ = v.iter().position(|&x| x < 0).is_some();\n+    //~^ ERROR called `is_some()` after searching\n+    //~| NOTE replace `position(|&x| x < 0).is_some()`\n+\n+    // check `position().is_some()`, multi-line\n+    let _ = v.iter().position(|&x| { //~ERROR called `is_some()` after searching\n+                                  x < 0\n+                              }\n+                   ).is_some();\n+\n+    // check `rposition().is_some()`, single-line\n+    let _ = v.iter().rposition(|&x| x < 0).is_some();\n+    //~^ ERROR called `is_some()` after searching\n+    //~| NOTE replace `rposition(|&x| x < 0).is_some()`\n+\n+    // check `rposition().is_some()`, multi-line\n+    let _ = v.iter().rposition(|&x| { //~ERROR called `is_some()` after searching\n+                                   x < 0\n+                               }\n+                   ).is_some();\n+\n+    // check that we don't lint if the caller is not an Iterator\n+    let foo = IteratorFalsePositives { foo: 0 };\n+    let _ = foo.find().is_some();\n+    let _ = foo.position().is_some();\n+    let _ = foo.rposition().is_some();\n+}\n+\n fn main() {\n     use std::io;\n "}]}