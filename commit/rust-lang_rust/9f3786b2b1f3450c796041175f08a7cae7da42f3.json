{"sha": "9f3786b2b1f3450c796041175f08a7cae7da42f3", "node_id": "C_kwDOAAsO6NoAKDlmMzc4NmIyYjFmMzQ1MGM3OTYwNDExNzVmMDhhN2NhZTdkYTQyZjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-14T18:26:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-14T18:26:14Z"}, "message": "Rollup merge of #101967 - jmillikin:linux-abstract-socket-addr, r=joshtriplett\n\nMove `unix_socket_abstract` feature API to `SocketAddrExt`.\n\nThe pre-stabilized API for abstract socket addresses exposes methods on `SocketAddr` that are only enabled for `cfg(any(target_os = \"android\", target_os = \"linux\"))`. Per discussion in <https://github.com/rust-lang/rust/issues/85410>, moving these methods to an OS-specific extension trait is required before stabilization can be considered.\n\nThis PR makes four changes:\n1. The internal module `std::os::net` contains logic for the unstable feature `tcp_quickack` (https://github.com/rust-lang/rust/issues/96256). I moved that code into `linux_ext/tcp.rs` and tried to adjust the module tree so it could accommodate a second unstable feature there.\n2. Moves the public API out of `impl SocketAddr`, into `impl SocketAddrExt for SocketAddr` (the headline change).\n3. The existing function names and docs for `unix_socket_abstract` refer to addresses as being created from abstract namespaces, but a more accurate description is that they create sockets in *the* abstract namespace. I adjusted the function signatures correspondingly and tried to update the docs to be clearer.\n4. I also tweaked `from_abstract_name` so it takes an `AsRef<[u8]>` instead of `&[u8]`, allowing `b\"\"` literals to be passed directly.\n\nIssues:\n1. The public module `std::os::linux::net` is marked as part of `tcp_quickack`. I couldn't figure out how to mark a module as being part of two unstable features, so I just left the existing attributes in place. My hope is that this will be fixed as a side-effect of stabilizing either feature.", "tree": {"sha": "f84a7c374e4a5f0bfd13441f7a670aae89ac4556", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f84a7c374e4a5f0bfd13441f7a670aae89ac4556"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f3786b2b1f3450c796041175f08a7cae7da42f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjcohGCRBK7hj4Ov3rIwAAbgAIABF3xWTW5hpYjnu5ULF8MgzW\nbL8yQ8u29iQnLuIrtC2BmWJcaGgT1nwxeNHRuIW3qG+azxGylmw9LKvsfuTayM4L\nvqaOWq9r8M73rftQtQ7JvWFEObktokVXoR/3aF8ACF5wX83lNizpjVRsQK6dw6QJ\nfdeRxrXeKQzXRkW3wP1Sd0joMOxocBPeoT8GrDZBxfSe65EvprbckW8wkwE2wJZA\nXdis5YBw6W2uOF7ARF9+9qlIg3YElOtPXzXeh+kikFae4mkfdk0J44v9kD6SoFZk\nd8jQXVKqd/e6MLO0yBSxHSvEMFC/BIBciq18sVDOmfT2HwCzOttJRfzikzpaqbA=\n=wRwO\n-----END PGP SIGNATURE-----\n", "payload": "tree f84a7c374e4a5f0bfd13441f7a670aae89ac4556\nparent 96ddd32c4bfb1d78f0cd03eb068b1710a8cebeef\nparent 8f1e6eba343452ac48412f11d57aa7d206c8c3dd\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668450374 +0100\ncommitter GitHub <noreply@github.com> 1668450374 +0100\n\nRollup merge of #101967 - jmillikin:linux-abstract-socket-addr, r=joshtriplett\n\nMove `unix_socket_abstract` feature API to `SocketAddrExt`.\n\nThe pre-stabilized API for abstract socket addresses exposes methods on `SocketAddr` that are only enabled for `cfg(any(target_os = \"android\", target_os = \"linux\"))`. Per discussion in <https://github.com/rust-lang/rust/issues/85410>, moving these methods to an OS-specific extension trait is required before stabilization can be considered.\n\nThis PR makes four changes:\n1. The internal module `std::os::net` contains logic for the unstable feature `tcp_quickack` (https://github.com/rust-lang/rust/issues/96256). I moved that code into `linux_ext/tcp.rs` and tried to adjust the module tree so it could accommodate a second unstable feature there.\n2. Moves the public API out of `impl SocketAddr`, into `impl SocketAddrExt for SocketAddr` (the headline change).\n3. The existing function names and docs for `unix_socket_abstract` refer to addresses as being created from abstract namespaces, but a more accurate description is that they create sockets in *the* abstract namespace. I adjusted the function signatures correspondingly and tried to update the docs to be clearer.\n4. I also tweaked `from_abstract_name` so it takes an `AsRef<[u8]>` instead of `&[u8]`, allowing `b\"\"` literals to be passed directly.\n\nIssues:\n1. The public module `std::os::linux::net` is marked as part of `tcp_quickack`. I couldn't figure out how to mark a module as being part of two unstable features, so I just left the existing attributes in place. My hope is that this will be fixed as a side-effect of stabilizing either feature.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3786b2b1f3450c796041175f08a7cae7da42f3", "html_url": "https://github.com/rust-lang/rust/commit/9f3786b2b1f3450c796041175f08a7cae7da42f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f3786b2b1f3450c796041175f08a7cae7da42f3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96ddd32c4bfb1d78f0cd03eb068b1710a8cebeef", "url": "https://api.github.com/repos/rust-lang/rust/commits/96ddd32c4bfb1d78f0cd03eb068b1710a8cebeef", "html_url": "https://github.com/rust-lang/rust/commit/96ddd32c4bfb1d78f0cd03eb068b1710a8cebeef"}, {"sha": "8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "html_url": "https://github.com/rust-lang/rust/commit/8f1e6eba343452ac48412f11d57aa7d206c8c3dd"}], "stats": {"total": 235, "additions": 140, "deletions": 95}, "files": [{"sha": "7cecd1bbfaa95bf360b839c5dbfb2ae0584c40b2", "filename": "library/std/src/os/android/net.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "patch": "@@ -1,4 +1,9 @@\n-//! Linux and Android-specific definitions for socket options.\n+//! Android-specific networking functionality.\n \n #![unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n-pub use crate::os::net::tcp::TcpStreamExt;\n+\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub use crate::os::net::linux_ext::addr::SocketAddrExt;\n+\n+#[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n+pub use crate::os::net::linux_ext::tcp::TcpStreamExt;"}, {"sha": "94081c8dd31c50773dec4d5dc160c5c945170928", "filename": "library/std/src/os/linux/net.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "patch": "@@ -1,4 +1,9 @@\n-//! Linux and Android-specific definitions for socket options.\n+//! Linux-specific networking functionality.\n \n #![unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n-pub use crate::os::net::tcp::TcpStreamExt;\n+\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub use crate::os::net::linux_ext::addr::SocketAddrExt;\n+\n+#[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n+pub use crate::os::net::linux_ext::tcp::TcpStreamExt;"}, {"sha": "df3fc8e6a3b660cfa61f85ccc38fff7501a95f9c", "filename": "library/std/src/os/net/linux_ext/addr.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "patch": "@@ -0,0 +1,64 @@\n+//! Linux and Android-specific extensions to socket addresses.\n+\n+use crate::os::unix::net::SocketAddr;\n+use crate::sealed::Sealed;\n+\n+/// Platform-specific extensions to [`SocketAddr`].\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub trait SocketAddrExt: Sealed {\n+    /// Creates a Unix socket address in the abstract namespace.\n+    ///\n+    /// The abstract namespace is a Linux-specific extension that allows Unix\n+    /// sockets to be bound without creating an entry in the filesystem.\n+    /// Abstract sockets are unaffected by filesystem layout or permissions,\n+    /// and no cleanup is necessary when the socket is closed.\n+    ///\n+    /// An abstract socket address name may contain any bytes, including zero.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns an error if the name is longer than `SUN_LEN - 1`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    /// use std::os::linux::net::SocketAddrExt;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_name(b\"hidden\")?;\n+    ///     let listener = match UnixListener::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {err:?}\");\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    fn from_abstract_name<N>(name: &N) -> crate::io::Result<SocketAddr>\n+    where\n+        N: AsRef<[u8]>;\n+\n+    /// Returns the contents of this address if it is in the abstract namespace.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    /// use std::os::linux::net::SocketAddrExt;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let name = b\"hidden\";\n+    ///     let name_addr = SocketAddr::from_abstract_name(name)?;\n+    ///     let socket = UnixListener::bind_addr(&name_addr)?;\n+    ///     let local_addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(local_addr.as_abstract_name(), Some(&name[..]));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    fn as_abstract_name(&self) -> Option<&[u8]>;\n+}"}, {"sha": "318ebacfd7a08d774d6e2a01f86807df45fde3de", "filename": "library/std/src/os/net/linux_ext/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "patch": "@@ -0,0 +1,12 @@\n+//! Linux and Android-specific networking functionality.\n+\n+#![doc(cfg(any(target_os = \"linux\", target_os = \"android\")))]\n+\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub(crate) mod addr;\n+\n+#[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n+pub(crate) mod tcp;\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "5e9ee65a4152e4ff6d38848facd984365084228c", "filename": "library/std/src/os/net/linux_ext/tcp.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftcp.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "previous_filename": "library/std/src/os/net/tcp.rs"}, {"sha": "2db4deed03630197c897eca5fd4c5e53611ea4a2", "filename": "library/std/src/os/net/linux_ext/tests.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Ftests.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "patch": "@@ -1,9 +1,8 @@\n-#[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n #[test]\n fn quickack() {\n     use crate::{\n         net::{test::next_test_ip4, TcpListener, TcpStream},\n-        os::net::tcp::TcpStreamExt,\n+        os::net::linux_ext::tcp::TcpStreamExt,\n     };\n \n     macro_rules! t {", "previous_filename": "library/std/src/os/net/tests.rs"}, {"sha": "5ec267c41e97ca77a5e3a920b30c918633e2fd77", "filename": "library/std/src/os/net/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "patch": "@@ -1,7 +1,4 @@\n-//! Linux and Android-specific definitions for socket options.\n+//! OS-specific networking functionality.\n \n-#![unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n-#![doc(cfg(any(target_os = \"linux\", target_os = \"android\",)))]\n-pub mod tcp;\n-#[cfg(test)]\n-mod tests;\n+#[cfg(any(target_os = \"linux\", target_os = \"android\", doc))]\n+pub(super) mod linux_ext;"}, {"sha": "81ac829d21bc81164006a02f55a81a32b0ad35c7", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 25, "deletions": 68, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "patch": "@@ -1,6 +1,9 @@\n use crate::ffi::OsStr;\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\"))]\n+use crate::os::net::linux_ext;\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::Path;\n+use crate::sealed::Sealed;\n use crate::sys::cvt;\n use crate::{fmt, io, mem, ptr};\n \n@@ -224,31 +227,6 @@ impl SocketAddr {\n         if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n     }\n \n-    /// Returns the contents of this address if it is an abstract namespace\n-    /// without the leading null byte.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_abstract)]\n-    /// use std::os::unix::net::{UnixListener, SocketAddr};\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let namespace = b\"hidden\";\n-    ///     let namespace_addr = SocketAddr::from_abstract_namespace(&namespace[..])?;\n-    ///     let socket = UnixListener::bind_addr(&namespace_addr)?;\n-    ///     let local_addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(local_addr.as_abstract_namespace(), Some(&namespace[..]));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n-    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n-    pub fn as_abstract_namespace(&self) -> Option<&[u8]> {\n-        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n-    }\n-\n     fn address(&self) -> AddressKind<'_> {\n         let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n@@ -265,62 +243,41 @@ impl SocketAddr {\n             AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n         }\n     }\n+}\n \n-    /// Creates an abstract domain socket address from a namespace\n-    ///\n-    /// An abstract address does not create a file unlike traditional path-based\n-    /// Unix sockets. The advantage of this is that the address will disappear when\n-    /// the socket bound to it is closed, so no filesystem clean up is required.\n-    ///\n-    /// The leading null byte for the abstract namespace is automatically added.\n-    ///\n-    /// This is a Linux-specific extension. See more at [`unix(7)`].\n-    ///\n-    /// [`unix(7)`]: https://man7.org/linux/man-pages/man7/unix.7.html\n-    ///\n-    /// # Errors\n-    ///\n-    /// This will return an error if the given namespace is too long\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_abstract)]\n-    /// use std::os::unix::net::{UnixListener, SocketAddr};\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?;\n-    ///     let listener = match UnixListener::bind_addr(&addr) {\n-    ///         Ok(sock) => sock,\n-    ///         Err(err) => {\n-    ///             println!(\"Couldn't bind: {err:?}\");\n-    ///             return Err(err);\n-    ///         }\n-    ///     };\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n-    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n-    pub fn from_abstract_namespace(namespace: &[u8]) -> io::Result<SocketAddr> {\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+impl Sealed for SocketAddr {}\n+\n+#[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\"))]\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+impl linux_ext::addr::SocketAddrExt for SocketAddr {\n+    fn as_abstract_name(&self) -> Option<&[u8]> {\n+        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n+    }\n+\n+    fn from_abstract_name<N>(name: &N) -> crate::io::Result<Self>\n+    where\n+        N: AsRef<[u8]>,\n+    {\n+        let name = name.as_ref();\n         unsafe {\n             let mut addr: libc::sockaddr_un = mem::zeroed();\n             addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n \n-            if namespace.len() + 1 > addr.sun_path.len() {\n+            if name.len() + 1 > addr.sun_path.len() {\n                 return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    \"namespace must be shorter than SUN_LEN\",\n+                    \"abstract socket name must be shorter than SUN_LEN\",\n                 ));\n             }\n \n             crate::ptr::copy_nonoverlapping(\n-                namespace.as_ptr(),\n+                name.as_ptr(),\n                 addr.sun_path.as_mut_ptr().add(1) as *mut u8,\n-                namespace.len(),\n+                name.len(),\n             );\n-            let len = (sun_path_offset(&addr) + 1 + namespace.len()) as libc::socklen_t;\n+            let len = (sun_path_offset(&addr) + 1 + name.len()) as libc::socklen_t;\n             SocketAddr::from_parts(addr, len)\n         }\n     }"}, {"sha": "37fcfa8446b0e00ebcb8b6a530bce8f1b854107f", "filename": "library/std/src/os/unix/net/tests.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3786b2b1f3450c796041175f08a7cae7da42f3/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs?ref=9f3786b2b1f3450c796041175f08a7cae7da42f3", "patch": "@@ -7,6 +7,12 @@ use crate::sys_common::io::test::tmpdir;\n use crate::thread;\n use crate::time::Duration;\n \n+#[cfg(target_os = \"android\")]\n+use crate::os::android::net::SocketAddrExt;\n+\n+#[cfg(target_os = \"linux\")]\n+use crate::os::linux::net::SocketAddrExt;\n+\n macro_rules! or_panic {\n     ($e:expr) => {\n         match $e {\n@@ -404,7 +410,7 @@ fn test_abstract_stream_connect() {\n     let msg1 = b\"hello\";\n     let msg2 = b\"world\";\n \n-    let socket_addr = or_panic!(SocketAddr::from_abstract_namespace(b\"namespace\"));\n+    let socket_addr = or_panic!(SocketAddr::from_abstract_name(b\"name\"));\n     let listener = or_panic!(UnixListener::bind_addr(&socket_addr));\n \n     let thread = thread::spawn(move || {\n@@ -418,7 +424,7 @@ fn test_abstract_stream_connect() {\n     let mut stream = or_panic!(UnixStream::connect_addr(&socket_addr));\n \n     let peer = or_panic!(stream.peer_addr());\n-    assert_eq!(peer.as_abstract_namespace().unwrap(), b\"namespace\");\n+    assert_eq!(peer.as_abstract_name().unwrap(), b\"name\");\n \n     or_panic!(stream.write_all(msg1));\n     let mut buf = vec![];\n@@ -432,7 +438,7 @@ fn test_abstract_stream_connect() {\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_stream_iter() {\n-    let addr = or_panic!(SocketAddr::from_abstract_namespace(b\"hidden\"));\n+    let addr = or_panic!(SocketAddr::from_abstract_name(b\"hidden\"));\n     let listener = or_panic!(UnixListener::bind_addr(&addr));\n \n     let thread = thread::spawn(move || {\n@@ -454,13 +460,13 @@ fn test_abstract_stream_iter() {\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_datagram_bind_send_to_addr() {\n-    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns1\"));\n+    let addr1 = or_panic!(SocketAddr::from_abstract_name(b\"ns1\"));\n     let sock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n \n     let local = or_panic!(sock1.local_addr());\n-    assert_eq!(local.as_abstract_namespace().unwrap(), b\"ns1\");\n+    assert_eq!(local.as_abstract_name().unwrap(), b\"ns1\");\n \n-    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns2\"));\n+    let addr2 = or_panic!(SocketAddr::from_abstract_name(b\"ns2\"));\n     let sock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n \n     let msg = b\"hello world\";\n@@ -469,13 +475,13 @@ fn test_abstract_datagram_bind_send_to_addr() {\n     let (len, addr) = or_panic!(sock2.recv_from(&mut buf));\n     assert_eq!(msg, &buf[..]);\n     assert_eq!(len, 11);\n-    assert_eq!(addr.as_abstract_namespace().unwrap(), b\"ns1\");\n+    assert_eq!(addr.as_abstract_name().unwrap(), b\"ns1\");\n }\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_datagram_connect_addr() {\n-    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns3\"));\n+    let addr1 = or_panic!(SocketAddr::from_abstract_name(b\"ns3\"));\n     let bsock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n \n     let sock = or_panic!(UnixDatagram::unbound());\n@@ -489,7 +495,7 @@ fn test_abstract_datagram_connect_addr() {\n     assert_eq!(addr.is_unnamed(), true);\n     assert_eq!(msg, &buf[..]);\n \n-    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns4\"));\n+    let addr2 = or_panic!(SocketAddr::from_abstract_name(b\"ns4\"));\n     let bsock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n \n     or_panic!(sock.connect_addr(&addr2));\n@@ -499,8 +505,8 @@ fn test_abstract_datagram_connect_addr() {\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n-fn test_abstract_namespace_too_long() {\n-    match SocketAddr::from_abstract_namespace(\n+fn test_abstract_name_too_long() {\n+    match SocketAddr::from_abstract_name(\n         b\"abcdefghijklmnopqrstuvwxyzabcdefghijklmn\\\n         opqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghi\\\n         jklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\",\n@@ -513,11 +519,11 @@ fn test_abstract_namespace_too_long() {\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n-fn test_abstract_namespace_no_pathname_and_not_unnamed() {\n-    let namespace = b\"local\";\n-    let addr = or_panic!(SocketAddr::from_abstract_namespace(&namespace[..]));\n+fn test_abstract_no_pathname_and_not_unnamed() {\n+    let name = b\"local\";\n+    let addr = or_panic!(SocketAddr::from_abstract_name(name));\n     assert_eq!(addr.as_pathname(), None);\n-    assert_eq!(addr.as_abstract_namespace(), Some(&namespace[..]));\n+    assert_eq!(addr.as_abstract_name(), Some(&name[..]));\n     assert_eq!(addr.is_unnamed(), false);\n }\n "}]}