{"sha": "3001450f95912ec541081b512d4a59eb2d1333ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMDE0NTBmOTU5MTJlYzU0MTA4MWI1MTJkNGE1OWViMmQxMzMzYmE=", "commit": {"author": {"name": "TyOverby", "email": "ty@pre-alpha.com", "date": "2014-05-19T06:31:23Z"}, "committer": {"name": "TyOverby", "email": "ty@pre-alpha.com", "date": "2014-05-20T00:37:39Z"}, "message": "core::iter::order functions now take two types of iterators.\n\nPreviously the type signatures of the ordering functions in\n`core::iter::order` took two iterators, but only if they were\nthe same type of iterator.  This commit loosens that restriction\nand allows different kinds of iterators (but with the same type\nof elements) to be compared.", "tree": {"sha": "efc7182d1e8df9990f24e6e2254ccdfb53852330", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efc7182d1e8df9990f24e6e2254ccdfb53852330"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3001450f95912ec541081b512d4a59eb2d1333ba", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3001450f95912ec541081b512d4a59eb2d1333ba", "html_url": "https://github.com/rust-lang/rust/commit/3001450f95912ec541081b512d4a59eb2d1333ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3001450f95912ec541081b512d4a59eb2d1333ba/comments", "author": {"login": "TyOverby", "id": 573215, "node_id": "MDQ6VXNlcjU3MzIxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/573215?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TyOverby", "html_url": "https://github.com/TyOverby", "followers_url": "https://api.github.com/users/TyOverby/followers", "following_url": "https://api.github.com/users/TyOverby/following{/other_user}", "gists_url": "https://api.github.com/users/TyOverby/gists{/gist_id}", "starred_url": "https://api.github.com/users/TyOverby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TyOverby/subscriptions", "organizations_url": "https://api.github.com/users/TyOverby/orgs", "repos_url": "https://api.github.com/users/TyOverby/repos", "events_url": "https://api.github.com/users/TyOverby/events{/privacy}", "received_events_url": "https://api.github.com/users/TyOverby/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TyOverby", "id": 573215, "node_id": "MDQ6VXNlcjU3MzIxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/573215?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TyOverby", "html_url": "https://github.com/TyOverby", "followers_url": "https://api.github.com/users/TyOverby/followers", "following_url": "https://api.github.com/users/TyOverby/following{/other_user}", "gists_url": "https://api.github.com/users/TyOverby/gists{/gist_id}", "starred_url": "https://api.github.com/users/TyOverby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TyOverby/subscriptions", "organizations_url": "https://api.github.com/users/TyOverby/orgs", "repos_url": "https://api.github.com/users/TyOverby/repos", "events_url": "https://api.github.com/users/TyOverby/events{/privacy}", "received_events_url": "https://api.github.com/users/TyOverby/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed156772bd95b8d621d50102922e5f5ac886d4a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed156772bd95b8d621d50102922e5f5ac886d4a1", "html_url": "https://github.com/rust-lang/rust/commit/ed156772bd95b8d621d50102922e5f5ac886d4a1"}], "stats": {"total": 26, "additions": 18, "deletions": 8}, "files": [{"sha": "9fc16b55631a4d5d15867b33e7033df4f656f33f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3001450f95912ec541081b512d4a59eb2d1333ba/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3001450f95912ec541081b512d4a59eb2d1333ba/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=3001450f95912ec541081b512d4a59eb2d1333ba", "patch": "@@ -2184,7 +2184,7 @@ pub mod order {\n     use super::Iterator;\n \n     /// Compare `a` and `b` for equality using `TotalEq`\n-    pub fn equals<A: TotalEq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn equals<A: TotalEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2195,7 +2195,7 @@ pub mod order {\n     }\n \n     /// Order `a` and `b` lexicographically using `TotalOrd`\n-    pub fn cmp<A: TotalOrd, T: Iterator<A>>(mut a: T, mut b: T) -> cmp::Ordering {\n+    pub fn cmp<A: TotalOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> cmp::Ordering {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return cmp::Equal,\n@@ -2210,7 +2210,7 @@ pub mod order {\n     }\n \n     /// Compare `a` and `b` for equality (Using partial equality, `Eq`)\n-    pub fn eq<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn eq<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2221,7 +2221,7 @@ pub mod order {\n     }\n \n     /// Compare `a` and `b` for nonequality (Using partial equality, `Eq`)\n-    pub fn ne<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn ne<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2232,7 +2232,7 @@ pub mod order {\n     }\n \n     /// Return `a` < `b` lexicographically (Using partial order, `Ord`)\n-    pub fn lt<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn lt<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2244,7 +2244,7 @@ pub mod order {\n     }\n \n     /// Return `a` <= `b` lexicographically (Using partial order, `Ord`)\n-    pub fn le<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn le<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2256,7 +2256,7 @@ pub mod order {\n     }\n \n     /// Return `a` > `b` lexicographically (Using partial order, `Ord`)\n-    pub fn gt<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn gt<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2268,7 +2268,7 @@ pub mod order {\n     }\n \n     /// Return `a` >= `b` lexicographically (Using partial order, `Ord`)\n-    pub fn ge<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn ge<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2325,6 +2325,16 @@ pub mod order {\n         assert!(gt(c.iter(), b.iter()) == (c[0] >  b[0]));\n         assert!(ge(c.iter(), b.iter()) == (c[0] >= b[0]));\n     }\n+\n+    #[test]\n+    fn test_multi_iter() {\n+        use slice::ImmutableVector;\n+        use iter::DoubleEndedIterator;\n+        let xs = [1i,2,3,4];\n+        let ys = [4i,3,2,1];\n+        assert!(eq(xs.iter(), ys.iter().rev()));\n+        assert!(lt(xs.iter(), xs.iter().skip(2)));\n+    }\n }\n \n #[cfg(test)]"}]}