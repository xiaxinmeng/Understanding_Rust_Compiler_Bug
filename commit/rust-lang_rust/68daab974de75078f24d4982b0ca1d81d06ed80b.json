{"sha": "68daab974de75078f24d4982b0ca1d81d06ed80b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZGFhYjk3NGRlNzUwNzhmMjRkNDk4MmIwY2ExZDgxZDA2ZWQ4MGI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-10T11:21:33Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-10T11:23:04Z"}, "message": "Move relevant code into \"traits\" module.", "tree": {"sha": "bd534facae8e3b4de3b849f5e5af7c9dd45cf1ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd534facae8e3b4de3b849f5e5af7c9dd45cf1ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68daab974de75078f24d4982b0ca1d81d06ed80b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68daab974de75078f24d4982b0ca1d81d06ed80b", "html_url": "https://github.com/rust-lang/rust/commit/68daab974de75078f24d4982b0ca1d81d06ed80b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68daab974de75078f24d4982b0ca1d81d06ed80b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8d813c4ad7cb357f56636c0974147914e2b1311", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d813c4ad7cb357f56636c0974147914e2b1311", "html_url": "https://github.com/rust-lang/rust/commit/d8d813c4ad7cb357f56636c0974147914e2b1311"}], "stats": {"total": 496, "additions": 250, "deletions": 246}, "files": [{"sha": "a3b47f533f4be37aa294185ece4c45c5fa017485", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 241, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/68daab974de75078f24d4982b0ca1d81d06ed80b/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68daab974de75078f24d4982b0ca1d81d06ed80b/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=68daab974de75078f24d4982b0ca1d81d06ed80b", "patch": "@@ -1,25 +1,22 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::traits::{self, Reveal};\n-use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::{Layout, Size};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n-use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::{ast, attr, abi};\n+use rustc::ty::{self, Ty, BareFnTy};\n+use syntax::codemap::Span;\n+use syntax::attr;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{Pointer, FunctionDefinition, Function};\n+use memory::{Pointer, FunctionDefinition};\n use value::PrimVal;\n use value::Value;\n \n mod intrinsic;\n mod drop;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-\n     pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n         self.frame_mut().block = target;\n         self.frame_mut().stmt = 0;\n@@ -497,29 +494,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub(super) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n-        // Do the initial selection for the obligation. This yields the shallow result we are\n-        // looking for -- that is, what specific impl.\n-        self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            let mut selcx = traits::SelectionContext::new(&infcx);\n-\n-            let obligation = traits::Obligation::new(\n-                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n-                trait_ref.to_poly_trait_predicate(),\n-            );\n-            let selection = selcx.select(&obligation).unwrap().unwrap();\n-\n-            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n-            // This is because they can inform the inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n-        })\n-    }\n-\n-    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx> {\n+    pub(crate) fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx> {\n         if let Some((last, last_ty)) = args.pop() {\n             let last_layout = self.type_layout(last_ty)?;\n             match (&last_ty.sty, last_layout) {\n@@ -540,215 +515,4 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n         Ok(())\n     }\n-\n-    /// Trait method, which has to be resolved to an impl method.\n-    fn trait_method(\n-        &mut self,\n-        trait_id: DefId,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        args: &mut Vec<(Value, Ty<'tcx>)>,\n-    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Vec<Pointer>)> {\n-        let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n-        let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n-\n-        match self.fulfill_obligation(trait_ref) {\n-            traits::VtableImpl(vtable_impl) => {\n-                let impl_did = vtable_impl.impl_def_id;\n-                let mname = self.tcx.item_name(def_id);\n-                // Create a concatenated set of substitutions which includes those from the impl\n-                // and those from the method:\n-                let (did, substs) = find_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n-\n-                Ok((did, substs, Vec::new()))\n-            }\n-\n-            traits::VtableClosure(vtable_closure) => {\n-                let trait_closure_kind = self.tcx\n-                    .lang_items\n-                    .fn_trait_kind(trait_id)\n-                    .expect(\"The substitutions should have no type parameters remaining after passing through fulfill_obligation\");\n-                let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n-                trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n-                self.unpack_fn_args(args)?;\n-                let mut temporaries = Vec::new();\n-                match (closure_kind, trait_closure_kind) {\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-                    (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) |\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {} // No adapter needed.\n-\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-                        // The closure fn is a `fn(&self, ...)` or `fn(&mut self, ...)`.\n-                        // We want a `fn(self, ...)`.\n-                        // We can produce this by doing something like:\n-                        //\n-                        //     fn call_once(self, ...) { call_mut(&self, ...) }\n-                        //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-                        //\n-                        // These are both the same at trans time.\n-\n-                        // Interpreter magic: insert an intermediate pointer, so we can skip the\n-                        // intermediate function call.\n-                        let ptr = match args[0].0 {\n-                            Value::ByRef(ptr) => ptr,\n-                            Value::ByVal(primval) => {\n-                                let ptr = self.alloc_ptr(args[0].1)?;\n-                                let size = self.type_size(args[0].1)?.expect(\"closures are sized\");\n-                                self.memory.write_primval(ptr, primval, size)?;\n-                                temporaries.push(ptr);\n-                                ptr\n-                            },\n-                            Value::ByValPair(a, b) => {\n-                                let ptr = self.alloc_ptr(args[0].1)?;\n-                                self.write_pair_to_ptr(a, b, ptr, args[0].1)?;\n-                                temporaries.push(ptr);\n-                                ptr\n-                            },\n-                        };\n-                        args[0].0 = Value::ByVal(PrimVal::Ptr(ptr));\n-                        args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n-                    }\n-\n-                    _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n-                }\n-                Ok((vtable_closure.closure_def_id, vtable_closure.substs.substs, temporaries))\n-            }\n-\n-            traits::VtableFnPointer(vtable_fn_ptr) => {\n-                if let ty::TyFnDef(did, substs, _) = vtable_fn_ptr.fn_ty.sty {\n-                    args.remove(0);\n-                    self.unpack_fn_args(args)?;\n-                    Ok((did, substs, Vec::new()))\n-                } else {\n-                    bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n-                }\n-            }\n-\n-            traits::VtableObject(ref data) => {\n-                let idx = self.tcx.get_vtable_index_of_object_method(data, def_id) as u64;\n-                if args.is_empty() {\n-                    return Err(EvalError::VtableForArgumentlessMethod);\n-                }\n-                let (self_ptr, vtable) = args[0].0.expect_ptr_vtable_pair(&self.memory)?;\n-                let idx = idx + 3;\n-                let offset = idx * self.memory.pointer_size();\n-                let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n-                trace!(\"args: {:#?}\", args);\n-                match self.memory.get_fn(fn_ptr.alloc_id)? {\n-                    Function::FnDefAsTraitObject(fn_def) => {\n-                        trace!(\"sig: {:#?}\", fn_def.sig);\n-                        assert!(fn_def.abi != abi::Abi::RustCall);\n-                        assert_eq!(args.len(), 2);\n-                        // a function item turned into a closure trait object\n-                        // the first arg is just there to give use the vtable\n-                        args.remove(0);\n-                        self.unpack_fn_args(args)?;\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    },\n-                    Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n-                    Function::Concrete(fn_def) => {\n-                        trace!(\"sig: {:#?}\", fn_def.sig);\n-                        args[0] = (\n-                            Value::ByVal(PrimVal::Ptr(self_ptr)),\n-                            fn_def.sig.inputs()[0],\n-                        );\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    },\n-                    Function::Closure(fn_def) => {\n-                        self.unpack_fn_args(args)?;\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    }\n-                    Function::FnPtrAsTraitObject(sig) => {\n-                        trace!(\"sig: {:#?}\", sig);\n-                        // the first argument was the fat ptr\n-                        args.remove(0);\n-                        self.unpack_fn_args(args)?;\n-                        let fn_ptr = self.memory.read_ptr(self_ptr)?;\n-                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?.expect_concrete()?;\n-                        assert_eq!(sig, fn_def.sig);\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    }\n-                }\n-            },\n-            vtable => bug!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub(super) struct ImplMethod<'tcx> {\n-    pub(super) method: ty::AssociatedItem,\n-    pub(super) substs: &'tcx Substs<'tcx>,\n-    pub(super) is_provided: bool,\n-}\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub(super) fn get_impl_method<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    substs: &'tcx Substs<'tcx>,\n-    impl_def_id: DefId,\n-    impl_substs: &'tcx Substs<'tcx>,\n-    name: ast::Name,\n-) -> ImplMethod<'tcx> {\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).defs(tcx, name, ty::AssociatedKind::Method).next() {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n-                let substs = traits::translate_substs(&infcx, impl_def_id,\n-                                                      substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            ImplMethod {\n-                method: node_item.item,\n-                substs,\n-                is_provided: node_item.node.is_from_trait(),\n-            }\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n-    }\n-}\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             substs: &'tcx Substs<'tcx>,\n-                             impl_def_id: DefId,\n-                             impl_substs: &'tcx Substs<'tcx>,\n-                             name: ast::Name)\n-                             -> (DefId, &'tcx Substs<'tcx>)\n-{\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).defs(tcx, name, ty::AssociatedKind::Method).next() {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n-                let substs = traits::translate_substs(&infcx, impl_def_id, substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"find_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            (node_item.item.def_id, substs)\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n-    }\n }"}, {"sha": "b892efbf569bb9e3190c13a94c9e0ab67f22419a", "filename": "src/traits.rs", "status": "modified", "additions": 245, "deletions": 5, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/68daab974de75078f24d4982b0ca1d81d06ed80b/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68daab974de75078f24d4982b0ca1d81d06ed80b/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=68daab974de75078f24d4982b0ca1d81d06ed80b", "patch": "@@ -1,14 +1,178 @@\n-use rustc::hir::def_id::DefId;\n use rustc::traits::{self, Reveal, SelectionContext};\n-use rustc::ty::subst::Substs;\n-use rustc::ty;\n \n-use error::EvalResult;\n use eval_context::EvalContext;\n use memory::Pointer;\n-use terminator::{get_impl_method, ImplMethod};\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use syntax::codemap::DUMMY_SP;\n+use syntax::{ast, abi};\n+\n+use error::{EvalError, EvalResult};\n+use memory::Function;\n+use value::PrimVal;\n+use value::Value;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    /// Trait method, which has to be resolved to an impl method.\n+    pub(crate) fn trait_method(\n+        &mut self,\n+        trait_id: DefId,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        args: &mut Vec<(Value, Ty<'tcx>)>,\n+    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Vec<Pointer>)> {\n+        let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n+        let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n+\n+        match self.fulfill_obligation(trait_ref) {\n+            traits::VtableImpl(vtable_impl) => {\n+                let impl_did = vtable_impl.impl_def_id;\n+                let mname = self.tcx.item_name(def_id);\n+                // Create a concatenated set of substitutions which includes those from the impl\n+                // and those from the method:\n+                let (did, substs) = find_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n+\n+                Ok((did, substs, Vec::new()))\n+            }\n+\n+            traits::VtableClosure(vtable_closure) => {\n+                let trait_closure_kind = self.tcx\n+                    .lang_items\n+                    .fn_trait_kind(trait_id)\n+                    .expect(\"The substitutions should have no type parameters remaining after passing through fulfill_obligation\");\n+                let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n+                trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n+                self.unpack_fn_args(args)?;\n+                let mut temporaries = Vec::new();\n+                match (closure_kind, trait_closure_kind) {\n+                    (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+                    (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) |\n+                    (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {} // No adapter needed.\n+\n+                    (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+                        // The closure fn is a `fn(&self, ...)` or `fn(&mut self, ...)`.\n+                        // We want a `fn(self, ...)`.\n+                        // We can produce this by doing something like:\n+                        //\n+                        //     fn call_once(self, ...) { call_mut(&self, ...) }\n+                        //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+                        //\n+                        // These are both the same at trans time.\n+\n+                        // Interpreter magic: insert an intermediate pointer, so we can skip the\n+                        // intermediate function call.\n+                        let ptr = match args[0].0 {\n+                            Value::ByRef(ptr) => ptr,\n+                            Value::ByVal(primval) => {\n+                                let ptr = self.alloc_ptr(args[0].1)?;\n+                                let size = self.type_size(args[0].1)?.expect(\"closures are sized\");\n+                                self.memory.write_primval(ptr, primval, size)?;\n+                                temporaries.push(ptr);\n+                                ptr\n+                            },\n+                            Value::ByValPair(a, b) => {\n+                                let ptr = self.alloc_ptr(args[0].1)?;\n+                                self.write_pair_to_ptr(a, b, ptr, args[0].1)?;\n+                                temporaries.push(ptr);\n+                                ptr\n+                            },\n+                        };\n+                        args[0].0 = Value::ByVal(PrimVal::Ptr(ptr));\n+                        args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n+                    }\n+\n+                    _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n+                }\n+                Ok((vtable_closure.closure_def_id, vtable_closure.substs.substs, temporaries))\n+            }\n+\n+            traits::VtableFnPointer(vtable_fn_ptr) => {\n+                if let ty::TyFnDef(did, substs, _) = vtable_fn_ptr.fn_ty.sty {\n+                    args.remove(0);\n+                    self.unpack_fn_args(args)?;\n+                    Ok((did, substs, Vec::new()))\n+                } else {\n+                    bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n+                }\n+            }\n+\n+            traits::VtableObject(ref data) => {\n+                let idx = self.tcx.get_vtable_index_of_object_method(data, def_id) as u64;\n+                if args.is_empty() {\n+                    return Err(EvalError::VtableForArgumentlessMethod);\n+                }\n+                let (self_ptr, vtable) = args[0].0.expect_ptr_vtable_pair(&self.memory)?;\n+                let idx = idx + 3;\n+                let offset = idx * self.memory.pointer_size();\n+                let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n+                trace!(\"args: {:#?}\", args);\n+                match self.memory.get_fn(fn_ptr.alloc_id)? {\n+                    Function::FnDefAsTraitObject(fn_def) => {\n+                        trace!(\"sig: {:#?}\", fn_def.sig);\n+                        assert!(fn_def.abi != abi::Abi::RustCall);\n+                        assert_eq!(args.len(), 2);\n+                        // a function item turned into a closure trait object\n+                        // the first arg is just there to give use the vtable\n+                        args.remove(0);\n+                        self.unpack_fn_args(args)?;\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    },\n+                    Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n+                    Function::Concrete(fn_def) => {\n+                        trace!(\"sig: {:#?}\", fn_def.sig);\n+                        args[0] = (\n+                            Value::ByVal(PrimVal::Ptr(self_ptr)),\n+                            fn_def.sig.inputs()[0],\n+                        );\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    },\n+                    Function::Closure(fn_def) => {\n+                        self.unpack_fn_args(args)?;\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    }\n+                    Function::FnPtrAsTraitObject(sig) => {\n+                        trace!(\"sig: {:#?}\", sig);\n+                        // the first argument was the fat ptr\n+                        args.remove(0);\n+                        self.unpack_fn_args(args)?;\n+                        let fn_ptr = self.memory.read_ptr(self_ptr)?;\n+                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?.expect_concrete()?;\n+                        assert_eq!(sig, fn_def.sig);\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    }\n+                }\n+            },\n+            vtable => bug!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n+        }\n+    }\n+\n+    pub(crate) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n+        // Do the initial selection for the obligation. This yields the shallow result we are\n+        // looking for -- that is, what specific impl.\n+        self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+            let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+            let obligation = traits::Obligation::new(\n+                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                trait_ref.to_poly_trait_predicate(),\n+            );\n+            let selection = selcx.select(&obligation).unwrap().unwrap();\n+\n+            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n+            // This is because they can inform the inference of the impl's type parameters.\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let vtable = selection.map(|predicate| {\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+            });\n+            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n+        })\n+    }\n+\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///\n@@ -230,3 +394,79 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         (def_id, substs)\n     }\n }\n+\n+#[derive(Debug)]\n+pub(super) struct ImplMethod<'tcx> {\n+    pub(super) method: ty::AssociatedItem,\n+    pub(super) substs: &'tcx Substs<'tcx>,\n+    pub(super) is_provided: bool,\n+}\n+\n+/// Locates the applicable definition of a method, given its name.\n+pub(super) fn get_impl_method<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    substs: &'tcx Substs<'tcx>,\n+    impl_def_id: DefId,\n+    impl_substs: &'tcx Substs<'tcx>,\n+    name: ast::Name,\n+) -> ImplMethod<'tcx> {\n+    assert!(!substs.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    match trait_def.ancestors(impl_def_id).defs(tcx, name, ty::AssociatedKind::Method).next() {\n+        Some(node_item) => {\n+            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n+                let substs = traits::translate_substs(&infcx, impl_def_id,\n+                                                      substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n+            });\n+            ImplMethod {\n+                method: node_item.item,\n+                substs,\n+                is_provided: node_item.node.is_from_trait(),\n+            }\n+        }\n+        None => {\n+            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n+        }\n+    }\n+}\n+\n+/// Locates the applicable definition of a method, given its name.\n+pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             substs: &'tcx Substs<'tcx>,\n+                             impl_def_id: DefId,\n+                             impl_substs: &'tcx Substs<'tcx>,\n+                             name: ast::Name)\n+                             -> (DefId, &'tcx Substs<'tcx>)\n+{\n+    assert!(!substs.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    match trait_def.ancestors(impl_def_id).defs(tcx, name, ty::AssociatedKind::Method).next() {\n+        Some(node_item) => {\n+            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n+                let substs = traits::translate_substs(&infcx, impl_def_id, substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"find_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n+            });\n+            (node_item.item.def_id, substs)\n+        }\n+        None => {\n+            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n+        }\n+    }\n+}"}]}