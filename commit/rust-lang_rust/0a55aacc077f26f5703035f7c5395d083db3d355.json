{"sha": "0a55aacc077f26f5703035f7c5395d083db3d355", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNTVhYWNjMDc3ZjI2ZjU3MDMwMzVmN2M1Mzk1ZDA4M2RiM2QzNTU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-16T11:27:40Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-16T11:54:19Z"}, "message": "Prefer implemented traits in suggestions.\n\nIf `a.method();` can't be resolved, we first look for implemented traits\nglobally and suggest those. If there are no such traits found, we only\nthen fall back to suggesting from the unfiltered list of traits.", "tree": {"sha": "6543138d63a9cc5e2964daa157b630ffa88a1bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6543138d63a9cc5e2964daa157b630ffa88a1bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a55aacc077f26f5703035f7c5395d083db3d355", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a55aacc077f26f5703035f7c5395d083db3d355", "html_url": "https://github.com/rust-lang/rust/commit/0a55aacc077f26f5703035f7c5395d083db3d355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a55aacc077f26f5703035f7c5395d083db3d355/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3", "html_url": "https://github.com/rust-lang/rust/commit/06ad8bb872c93ed0aa1db00cf02b31b0f30d57b3"}], "stats": {"total": 179, "additions": 148, "deletions": 31}, "files": [{"sha": "345bc5fd2aa60772cb367f8fce554789034013ab", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0a55aacc077f26f5703035f7c5395d083db3d355", "patch": "@@ -38,8 +38,9 @@ mod suggest;\n \n pub enum MethodError {\n     // Did not find an applicable method, but we did find various\n-    // static methods that may apply.\n-    NoMatch(Vec<CandidateSource>),\n+    // static methods that may apply, as well as a list of\n+    // not-in-scope traits which may work.\n+    NoMatch(Vec<CandidateSource>, Vec<ast::DefId>),\n \n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n@@ -65,7 +66,7 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     match probe::probe(fcx, span, method_name, self_ty, call_expr_id) {\n         Ok(_) => true,\n-        Err(NoMatch(_)) => false,\n+        Err(NoMatch(_, _)) => false,\n         Err(Ambiguity(_)) => true,\n     }\n }"}, {"sha": "9df8875152e3b94e0f9bc40434f9005597a0bb49", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0a55aacc077f26f5703035f7c5395d083db3d355", "patch": "@@ -11,6 +11,7 @@\n use super::{MethodError,Ambiguity,NoMatch};\n use super::MethodIndex;\n use super::{CandidateSource,ImplSource,TraitSource};\n+use super::suggest;\n \n use check;\n use check::{FnCtxt, NoPreference};\n@@ -25,6 +26,7 @@ use middle::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use std::collections::HashSet;\n+use std::mem;\n use std::rc::Rc;\n use util::ppaux::Repr;\n \n@@ -42,6 +44,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: HashSet<ast::DefId>,\n     static_candidates: Vec<CandidateSource>,\n+    all_traits_search: bool,\n }\n \n struct CandidateStep<'tcx> {\n@@ -127,7 +130,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // take place in the `fcx.infcx().probe` below.\n     let steps = match create_steps(fcx, span, self_ty) {\n         Some(steps) => steps,\n-        None => return Err(NoMatch(Vec::new())),\n+        None => return Err(NoMatch(Vec::new(), Vec::new())),\n     };\n \n     // Create a list of simplified self types, if we can.\n@@ -208,9 +211,17 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n+            all_traits_search: false,\n         }\n     }\n \n+    fn reset(&mut self) {\n+        self.inherent_candidates.clear();\n+        self.extension_candidates.clear();\n+        self.impl_dups.clear();\n+        self.static_candidates.clear();\n+    }\n+\n     fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n@@ -446,6 +457,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n+    fn assemble_extension_candidates_for_all_traits(&mut self) {\n+        let mut duplicates = HashSet::new();\n+        for trait_info in suggest::all_traits(self.fcx.ccx) {\n+            if duplicates.insert(trait_info.def_id) {\n+                self.assemble_extension_candidates_for_trait(trait_info.def_id)\n+            }\n+        }\n+    }\n+\n     fn assemble_extension_candidates_for_trait(&mut self,\n                                                trait_def_id: ast::DefId) {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={})\",\n@@ -715,7 +735,47 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n         }\n \n-        Err(NoMatch(self.static_candidates))\n+        let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n+\n+        let out_of_scope_traits = if !self.all_traits_search {\n+            // things failed, and we haven't yet looked through all\n+            // traits, so lets do that now:\n+            self.reset();\n+            self.all_traits_search = true;\n+\n+            let span = self.span;\n+            let tcx = self.tcx();\n+\n+            self.assemble_extension_candidates_for_all_traits();\n+\n+            match self.pick() {\n+                Ok(p) => vec![p.method_ty.container.id()],\n+                Err(Ambiguity(v)) => v.into_iter().map(|source| {\n+                    match source {\n+                        TraitSource(id) => id,\n+                        ImplSource(impl_id) => {\n+                            match ty::trait_id_of_impl(tcx, impl_id) {\n+                                Some(id) => id,\n+                                None => tcx.sess.span_bug(span,\n+                                                          \"found inherent method when looking \\\n+                                                           at traits\")\n+                            }\n+                        }\n+                    }\n+                }).collect(),\n+                // it'd be really weird for this assertion to trigger,\n+                // given the `vec![]` in the else branch below\n+                Err(NoMatch(_, others)) => {\n+                    assert!(others.is_empty());\n+                    vec![]\n+                }\n+            }\n+        } else {\n+            // we've just looked through all traits and didn't find\n+            // anything at all.\n+            vec![]\n+        };\n+        Err(NoMatch(static_candidates, out_of_scope_traits))\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {"}, {"sha": "013c6e2f953a07f4d931106b3fbd87aa0e54afcd", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0a55aacc077f26f5703035f7c5395d083db3d355", "patch": "@@ -35,7 +35,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               error: MethodError)\n {\n     match error {\n-        MethodError::NoMatch(static_sources) => {\n+        MethodError::NoMatch(static_sources, out_of_scope_traits) => {\n             let cx = fcx.tcx();\n             let method_ustring = method_name.user_string(cx);\n \n@@ -75,7 +75,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 report_candidates(fcx, span, method_name, static_sources);\n             }\n \n-            suggest_traits_to_import(fcx, span, rcvr_ty, method_name)\n+            suggest_traits_to_import(fcx, span, rcvr_ty, method_name, out_of_scope_traits)\n         }\n \n         MethodError::Ambiguity(sources) => {\n@@ -136,10 +136,35 @@ pub type AllTraitsVec = Vec<TraitInfo>;\n fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       _rcvr_ty: Ty<'tcx>,\n-                                      method_name: ast::Name)\n+                                      method_name: ast::Name,\n+                                      valid_out_of_scope_traits: Vec<ast::DefId>)\n {\n     let tcx = fcx.tcx();\n+    let method_ustring = method_name.user_string(tcx);\n+\n+    if !valid_out_of_scope_traits.is_empty() {\n+        let mut candidates = valid_out_of_scope_traits;\n+        candidates.sort();\n+        let msg = format!(\n+            \"methods from traits can only be called if the trait is in scope; \\\n+             the following {traits_are} implemented and {define} a method `{name}`:\",\n+            traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n+            define = if candidates.len() == 1 {\"defines\"} else {\"define\"},\n+            name = method_ustring);\n+\n+        fcx.sess().fileline_help(span, &msg[]);\n+\n+        for (i, trait_did) in candidates.iter().enumerate() {\n+            fcx.sess().fileline_help(span,\n+                                     &*format!(\"candidate #{}: `{}`\",\n+                                               i + 1,\n+                                               ty::item_path_str(fcx.tcx(), *trait_did)))\n+\n+        }\n+        return\n+    }\n \n+    // there's no implemented traits, so lets suggest some traits to implement\n     let mut candidates = all_traits(fcx.ccx)\n         .filter(|info| trait_method(tcx, info.def_id, method_name).is_some())\n         .collect::<Vec<_>>();\n@@ -148,22 +173,16 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // sort from most relevant to least relevant\n         candidates.sort_by(|a, b| a.cmp(b).reverse());\n \n-        let method_ustring = method_name.user_string(tcx);\n+        let msg = format!(\n+            \"methods from traits can only be called if the trait is implemented and \\\n+             in scope; no such traits are but the following {traits_define} a method `{name}`:\",\n+            traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n+            name = method_ustring);\n \n-        span_help!(fcx.sess(), span,\n-                   \"methods from traits can only be called if the trait is implemented \\\n-                    and in scope; the following trait{s} define{inv_s} a method `{name}`:\",\n-                   s = if candidates.len() == 1 {\"\"} else {\"s\"},\n-                   inv_s = if candidates.len() == 1 {\"s\"} else {\"\"},\n-                   name = method_ustring);\n+        fcx.sess().fileline_help(span, &msg[]);\n \n         for (i, trait_info) in candidates.iter().enumerate() {\n-            // provide a good-as-possible span; the span of\n-            // the trait if it is local, or the span of the\n-            // method call itself if not\n-            let trait_span = fcx.tcx().map.def_id_span(trait_info.def_id, span);\n-\n-            fcx.sess().fileline_help(trait_span,\n+            fcx.sess().fileline_help(span,\n                                      &*format!(\"candidate #{}: `{}`\",\n                                                i + 1,\n                                                ty::item_path_str(fcx.tcx(), trait_info.def_id)))\n@@ -173,7 +192,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n #[derive(Copy)]\n pub struct TraitInfo {\n-    def_id: ast::DefId,\n+    pub def_id: ast::DefId,\n }\n \n impl TraitInfo {\n@@ -206,7 +225,7 @@ impl Ord for TraitInfo {\n }\n \n /// Retrieve all traits in this crate and any dependent crates.\n-fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n+pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n     if ccx.all_traits.borrow().is_none() {\n         use syntax::visit;\n \n@@ -268,7 +287,7 @@ fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n     }\n }\n \n-struct AllTraits<'a> {\n+pub struct AllTraits<'a> {\n     borrow: cell::Ref<'a Option<AllTraitsVec>>,\n     idx: usize\n }"}, {"sha": "328561495eef0a2efafd011611c14e1b7120b1a3", "filename": "src/test/auxiliary/no_method_suggested_traits.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs?ref=0a55aacc077f26f5703035f7c5395d083db3d355", "patch": "@@ -12,8 +12,13 @@ pub use reexport::Reexported;\n \n pub mod foo {\n     pub trait PubPub {\n-        fn method(&self);\n+        fn method(&self) {}\n+\n+        fn method3(&self) {}\n     }\n+\n+    impl PubPub for u32 {}\n+    impl PubPub for i32 {}\n }\n pub mod bar {\n     trait PubPriv {"}, {"sha": "277800778a87ebc67c493c2e15f13c7e545e1d3c", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a55aacc077f26f5703035f7c5395d083db3d355/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=0a55aacc077f26f5703035f7c5395d083db3d355", "patch": "@@ -13,18 +13,50 @@\n extern crate no_method_suggested_traits;\n \n mod foo {\n-    trait Bar { //~ HELP `foo::Bar`\n-        fn method(&self);\n+    trait Bar {\n+        fn method(&self) {}\n+\n+        fn method2(&self) {}\n     }\n+\n+    impl Bar for u32 {}\n+\n+    impl Bar for char {}\n }\n \n fn main() {\n     1u32.method();\n     //~^ ERROR does not implement\n+    //~^^ HELP the following traits are implemented and define a method `method`\n+    //~^^^ HELP `foo::Bar`\n+    //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n+\n+    'a'.method();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following trait is implemented and defines a method `method`\n+    //~^^^ HELP `foo::Bar`\n+\n+    1i32.method();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following trait is implemented and defines a method `method`\n+    //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n+\n+    1u64.method();\n+    //~^ ERROR does not implement\n     //~^^ HELP the following traits define a method `method`\n+    //~^^^ HELP `foo::Bar`\n+    //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n+    //~^^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n+    //~^^^^^^ HELP `no_method_suggested_traits::bar::PubPriv`\n+    //~^^^^^^^ HELP `no_method_suggested_traits::qux::PrivPub`\n+    //~^^^^^^^^ HELP `no_method_suggested_traits::quz::PrivPriv`\n+\n+    1u64.method2();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following trait defines a method `method2`\n+    //~^^^ HELP `foo::Bar`\n+    1u64.method3();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following trait defines a method `method3`\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n-    //~^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n-    //~^^^^^ HELP `no_method_suggested_traits::bar::PubPriv`\n-    //~^^^^^^ HELP `no_method_suggested_traits::qux::PrivPub`\n-    //~^^^^^^^ HELP `no_method_suggested_traits::quz::PrivPriv`\n }"}]}