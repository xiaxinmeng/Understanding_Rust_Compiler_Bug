{"sha": "734368a200904ef9c21db86c595dc04263c87be0", "node_id": "C_kwDOAAsO6NoAKDczNDM2OGEyMDA5MDRlZjljMjFkYjg2YzU5NWRjMDQyNjNjODdiZTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-07T20:32:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-07T20:32:56Z"}, "message": "Auto merge of #87869 - thomcc:skinny-io-error, r=yaahc\n\nMake io::Error use 64 bits on targets with 64 bit pointers.\n\nI've wanted this for a long time, but didn't see a good way to do it without having extra allocation. When looking at it yesterday, it was more clear what to do for some reason.\n\nThis approach avoids any additional allocations, and reduces the size by half (8 bytes, down from 16). AFAICT it doesn't come additional runtime cost, and the compiler seems to do a better job with code using it.\n\nAdditionally, this `io::Error` has a niche (still), so `io::Result<()>` is *also* 64 bits (8 bytes, down from 16), and `io::Result<usize>` (used for lots of io trait functions) is 2x64 bits (16 bytes, down from 24 \u2014 this means on x86_64 it can use the nice rax/rdx 2-reg struct return). More generally, it shaves a whole 64 bit integer register off of the size of basically any `io::Result<()>`.\n\n(For clarity: Improving `io::Result` (rather than io::Error) was most of the motivation for this)\n\nOn 32 bit (or other non-64bit) targets we still use something equivalent the old repr \u2014 I don't think think there's improving it, since one of the fields it stores is a `i32`, so we can't get below that, and it's already about as close as we can get to it.\n\n---\n\n### Isn't Pointer Tagging Dodgy?\n\nThe details of the layout, and why its implemented the way it is, are explained in the header comment of library/std/src/io/error/repr_bitpacked.rs. There's probably more details than there need to be, but I didn't trim it down that much, since there's a lot of stuff I did deliberately, that might have not seemed that way.\n\nThere's actually only one variant holding a pointer which gets tagged. This one is the (holder for the) user-provided error.\n\nI believe the scheme used to tag it is not UB, and that it preserves pointer provenance (even though often pointer tagging does not) because the tagging operation is just `core::ptr::add`, and untagging is `core::ptr::sub`. The result of both operations lands inside the original allocation, so it would follow the safety contract of `core::ptr::{add,sub}`.\n\nThe other pointer this had to encode is not tagged \u2014 or rather, the tagged repr is equivalent to untagged (it's tagged with 0b00, and has >=4b alignment, so we can reuse the bottom bits). And the other variants we encode are just integers, which (which can be untagged using bitwise operations without worry \u2014 they're integers).\n\nCC `@RalfJung` for the stuff in repr_bitpacked.rs, as my comments are informed by a lot of the UCG work, but it's possible I missed something or got it wrong (even if the implementation is okay, there are parts of the header comment that says things like \"We can't do $x\" which could be false).\n\n---\n\n### Why So Many Changes?\n\nThe repr change was mostly internal, but changed one widely used API: I had to switch how `io::Error::new_const` works.\n\nThis required switching `io::Error::new_const` to take the full message data (including the kind) as a `&'static`, rather than just the string. This would have been really tedious, but I made a macro that made it much simpler, but it was a wide change since `io::Error::new_const` is used everywhere.\n\nThis included changing files for a lot of targets I don't have easy access to (SGX? Haiku? Windows? Who has heard of these things), so I expect there to be spottiness in CI initially, unless luck is on my side.\n\nAnyway this large only tangentially-related change is all in the first commit (although that commit also pulls the previous repr out into its own file), whereas the packing stuff is all in commit 2.\n\n---\n\nP.S. I haven't looked at all of this since writing it, and will do a pass over it again later, sorry for any obvious typos or w/e. I also definitely repeat myself in comments and such.\n\n(It probably could use more tests too. I did some basic testing, and made it so we `debug_assert!` in cases the decode isn't what we encoded, but I don't know the degree which I can assume libstd's testing of IO would exercise this. That is: it wouldn't be surprising to me if libstds IO testing were minimal, especially around error cases, although I have no idea).", "tree": {"sha": "9b73116410fcc1adf4cb2b454377586fa195905b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b73116410fcc1adf4cb2b454377586fa195905b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/734368a200904ef9c21db86c595dc04263c87be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/734368a200904ef9c21db86c595dc04263c87be0", "html_url": "https://github.com/rust-lang/rust/commit/734368a200904ef9c21db86c595dc04263c87be0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/734368a200904ef9c21db86c595dc04263c87be0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f52c31840df7ec9c9350baff51a8964b20b5e1ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/f52c31840df7ec9c9350baff51a8964b20b5e1ba", "html_url": "https://github.com/rust-lang/rust/commit/f52c31840df7ec9c9350baff51a8964b20b5e1ba"}, {"sha": "9cbe99488bbeb8bdd742a4d15fe484ee665f9363", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cbe99488bbeb8bdd742a4d15fe484ee665f9363", "html_url": "https://github.com/rust-lang/rust/commit/9cbe99488bbeb8bdd742a4d15fe484ee665f9363"}], "stats": {"total": 1106, "additions": 837, "deletions": 269}, "files": [{"sha": "c3f024026efad027534fa69de42ec34e28b16ee9", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1077,7 +1077,7 @@ impl fmt::Display for NulError {\n impl From<NulError> for io::Error {\n     /// Converts a [`NulError`] into a [`io::Error`].\n     fn from(_: NulError) -> io::Error {\n-        io::Error::new_const(io::ErrorKind::InvalidInput, &\"data provided contains a nul byte\")\n+        io::const_io_error!(io::ErrorKind::InvalidInput, \"data provided contains a nul byte\")\n     }\n }\n "}, {"sha": "95e9064442634b53b510ee545b69b5df11e89850", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -2263,9 +2263,9 @@ impl DirBuilder {\n         match path.parent() {\n             Some(p) => self.create_dir_all(p)?,\n             None => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::Uncategorized,\n-                    &\"failed to create whole tree\",\n+                    \"failed to create whole tree\",\n                 ));\n             }\n         }"}, {"sha": "e7eee4436249b5073e76038d84c1f7be60ba27b9", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -357,9 +357,9 @@ impl<R: Read> Read for BufReader<R> {\n             let mut bytes = Vec::new();\n             self.read_to_end(&mut bytes)?;\n             let string = crate::str::from_utf8(&bytes).map_err(|_| {\n-                io::Error::new_const(\n+                io::const_io_error!(\n                     io::ErrorKind::InvalidData,\n-                    &\"stream did not contain valid UTF-8\",\n+                    \"stream did not contain valid UTF-8\",\n                 )\n             })?;\n             *buf += string;"}, {"sha": "2d3a0f37b4c2a56cf1bf56784e0252a1823cb9bf", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,7 +1,7 @@\n use crate::error;\n use crate::fmt;\n use crate::io::{\n-    self, Error, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n+    self, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n };\n use crate::mem;\n use crate::ptr;\n@@ -168,9 +168,9 @@ impl<W: Write> BufWriter<W> {\n \n             match r {\n                 Ok(0) => {\n-                    return Err(Error::new_const(\n+                    return Err(io::const_io_error!(\n                         ErrorKind::WriteZero,\n-                        &\"failed to write the buffered data\",\n+                        \"failed to write the buffered data\",\n                     ));\n                 }\n                 Ok(n) => guard.consume(n),"}, {"sha": "fc19704becee2e53d01c5d28ff742412a126a39a", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -4,7 +4,7 @@ mod tests;\n use crate::io::prelude::*;\n \n use crate::cmp;\n-use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n \n use core::convert::TryInto;\n \n@@ -297,9 +297,9 @@ where\n                 self.pos = n;\n                 Ok(self.pos)\n             }\n-            None => Err(Error::new_const(\n+            None => Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"invalid seek to a negative or overflowing position\",\n+                \"invalid seek to a negative or overflowing position\",\n             )),\n         }\n     }\n@@ -400,9 +400,9 @@ fn slice_write_vectored(\n // Resizing write implementation\n fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n     let pos: usize = (*pos_mut).try_into().map_err(|_| {\n-        Error::new_const(\n+        io::const_io_error!(\n             ErrorKind::InvalidInput,\n-            &\"cursor position exceeds maximum possible vector length\",\n+            \"cursor position exceeds maximum possible vector length\",\n         )\n     })?;\n     // Make sure the internal buffer is as least as big as where we"}, {"sha": "4b55324a2424cf45d424e44154b291db5ed3bd20", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 122, "deletions": 65, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,6 +1,16 @@\n #[cfg(test)]\n mod tests;\n \n+#[cfg(target_pointer_width = \"64\")]\n+mod repr_bitpacked;\n+#[cfg(target_pointer_width = \"64\")]\n+use repr_bitpacked::Repr;\n+\n+#[cfg(not(target_pointer_width = \"64\"))]\n+mod repr_unpacked;\n+#[cfg(not(target_pointer_width = \"64\"))]\n+use repr_unpacked::Repr;\n+\n use crate::convert::From;\n use crate::error;\n use crate::fmt;\n@@ -66,15 +76,58 @@ impl fmt::Debug for Error {\n     }\n }\n \n-enum Repr {\n+// Only derive debug in tests, to make sure it\n+// doesn't accidentally get printed.\n+#[cfg_attr(test, derive(Debug))]\n+enum ErrorData<C> {\n     Os(i32),\n     Simple(ErrorKind),\n-    // &str is a fat pointer, but &&str is a thin pointer.\n-    SimpleMessage(ErrorKind, &'static &'static str),\n-    Custom(Box<Custom>),\n+    SimpleMessage(&'static SimpleMessage),\n+    Custom(C),\n }\n \n+// `#[repr(align(4))]` is probably redundant, it should have that value or\n+// higher already. We include it just because repr_bitpacked.rs's encoding\n+// requires an alignment >= 4 (note that `#[repr(align)]` will not reduce the\n+// alignment required by the struct, only increase it).\n+//\n+// If we add more variants to ErrorData, this can be increased to 8, but it\n+// should probably be behind `#[cfg_attr(target_pointer_width = \"64\", ...)]` or\n+// whatever cfg we're using to enable the `repr_bitpacked` code, since only the\n+// that version needs the alignment, and 8 is higher than the alignment we'll\n+// have on 32 bit platforms.\n+//\n+// (For the sake of being explicit: the alignment requirement here only matters\n+// if `error/repr_bitpacked.rs` is in use \u2014\u00a0for the unpacked repr it doesn't\n+// matter at all)\n+#[repr(align(4))]\n #[derive(Debug)]\n+pub(crate) struct SimpleMessage {\n+    kind: ErrorKind,\n+    message: &'static str,\n+}\n+\n+impl SimpleMessage {\n+    pub(crate) const fn new(kind: ErrorKind, message: &'static str) -> Self {\n+        Self { kind, message }\n+    }\n+}\n+\n+/// Create and return an `io::Error` for a given `ErrorKind` and constant\n+/// message. This doesn't allocate.\n+pub(crate) macro const_io_error($kind:expr, $message:expr $(,)?) {\n+    $crate::io::error::Error::from_static_message({\n+        const MESSAGE_DATA: $crate::io::error::SimpleMessage =\n+            $crate::io::error::SimpleMessage::new($kind, $message);\n+        &MESSAGE_DATA\n+    })\n+}\n+\n+// As with `SimpleMessage`: `#[repr(align(4))]` here is just because\n+// repr_bitpacked's encoding requires it. In practice it almost certainly be\n+// already be this high or higher.\n+#[derive(Debug)]\n+#[repr(align(4))]\n struct Custom {\n     kind: ErrorKind,\n     error: Box<dyn error::Error + Send + Sync>,\n@@ -396,7 +449,7 @@ impl From<ErrorKind> for Error {\n     /// ```\n     #[inline]\n     fn from(kind: ErrorKind) -> Error {\n-        Error { repr: Repr::Simple(kind) }\n+        Error { repr: Repr::new_simple(kind) }\n     }\n }\n \n@@ -461,20 +514,22 @@ impl Error {\n     }\n \n     fn _new(kind: ErrorKind, error: Box<dyn error::Error + Send + Sync>) -> Error {\n-        Error { repr: Repr::Custom(Box::new(Custom { kind, error })) }\n+        Error { repr: Repr::new_custom(Box::new(Custom { kind, error })) }\n     }\n \n-    /// Creates a new I/O error from a known kind of error as well as a\n-    /// constant message.\n+    /// Creates a new I/O error from a known kind of error as well as a constant\n+    /// message.\n     ///\n     /// This function does not allocate.\n     ///\n-    /// This function should maybe change to\n-    /// `new_const<const MSG: &'static str>(kind: ErrorKind)`\n-    /// in the future, when const generics allow that.\n+    /// You should not use this directly, and instead use the `const_io_error!`\n+    /// macro: `io::const_io_error!(ErrorKind::Something, \"some_message\")`.\n+    ///\n+    /// This function should maybe change to `from_static_message<const MSG: &'static\n+    /// str>(kind: ErrorKind)` in the future, when const generics allow that.\n     #[inline]\n-    pub(crate) const fn new_const(kind: ErrorKind, message: &'static &'static str) -> Error {\n-        Self { repr: Repr::SimpleMessage(kind, message) }\n+    pub(crate) const fn from_static_message(msg: &'static SimpleMessage) -> Error {\n+        Self { repr: Repr::new_simple_message(msg) }\n     }\n \n     /// Returns an error representing the last OS error which occurred.\n@@ -532,7 +587,7 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn from_raw_os_error(code: i32) -> Error {\n-        Error { repr: Repr::Os(code) }\n+        Error { repr: Repr::new_os(code) }\n     }\n \n     /// Returns the OS error that this error represents (if any).\n@@ -568,11 +623,11 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn raw_os_error(&self) -> Option<i32> {\n-        match self.repr {\n-            Repr::Os(i) => Some(i),\n-            Repr::Custom(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n+        match self.repr.data() {\n+            ErrorData::Os(i) => Some(i),\n+            ErrorData::Custom(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n         }\n     }\n \n@@ -607,11 +662,11 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(ref c) => Some(&*c.error),\n+        match self.repr.data() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(c) => Some(&*c.error),\n         }\n     }\n \n@@ -681,11 +736,11 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(ref mut c) => Some(&mut *c.error),\n+        match self.repr.data_mut() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(c) => Some(&mut *c.error),\n         }\n     }\n \n@@ -720,11 +775,11 @@ impl Error {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(c) => Some(c.error),\n+        match self.repr.into_data() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(c) => Some(c.error),\n         }\n     }\n \n@@ -750,44 +805,46 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn kind(&self) -> ErrorKind {\n-        match self.repr {\n-            Repr::Os(code) => sys::decode_error_kind(code),\n-            Repr::Custom(ref c) => c.kind,\n-            Repr::Simple(kind) => kind,\n-            Repr::SimpleMessage(kind, _) => kind,\n+        match self.repr.data() {\n+            ErrorData::Os(code) => sys::decode_error_kind(code),\n+            ErrorData::Custom(c) => c.kind,\n+            ErrorData::Simple(kind) => kind,\n+            ErrorData::SimpleMessage(m) => m.kind,\n         }\n     }\n }\n \n impl fmt::Debug for Repr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Repr::Os(code) => fmt\n+        match self.data() {\n+            ErrorData::Os(code) => fmt\n                 .debug_struct(\"Os\")\n                 .field(\"code\", &code)\n                 .field(\"kind\", &sys::decode_error_kind(code))\n                 .field(\"message\", &sys::os::error_string(code))\n                 .finish(),\n-            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n-            Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n-            Repr::SimpleMessage(kind, &message) => {\n-                fmt.debug_struct(\"Error\").field(\"kind\", &kind).field(\"message\", &message).finish()\n-            }\n+            ErrorData::Custom(c) => fmt::Debug::fmt(&c, fmt),\n+            ErrorData::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n+            ErrorData::SimpleMessage(msg) => fmt\n+                .debug_struct(\"Error\")\n+                .field(\"kind\", &msg.kind)\n+                .field(\"message\", &msg.message)\n+                .finish(),\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Error {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.repr {\n-            Repr::Os(code) => {\n+        match self.repr.data() {\n+            ErrorData::Os(code) => {\n                 let detail = sys::os::error_string(code);\n                 write!(fmt, \"{} (os error {})\", detail, code)\n             }\n-            Repr::Custom(ref c) => c.error.fmt(fmt),\n-            Repr::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n-            Repr::SimpleMessage(_, &msg) => msg.fmt(fmt),\n+            ErrorData::Custom(ref c) => c.error.fmt(fmt),\n+            ErrorData::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n+            ErrorData::SimpleMessage(msg) => msg.message.fmt(fmt),\n         }\n     }\n }\n@@ -796,29 +853,29 @@ impl fmt::Display for Error {\n impl error::Error for Error {\n     #[allow(deprecated, deprecated_in_future)]\n     fn description(&self) -> &str {\n-        match self.repr {\n-            Repr::Os(..) | Repr::Simple(..) => self.kind().as_str(),\n-            Repr::SimpleMessage(_, &msg) => msg,\n-            Repr::Custom(ref c) => c.error.description(),\n+        match self.repr.data() {\n+            ErrorData::Os(..) | ErrorData::Simple(..) => self.kind().as_str(),\n+            ErrorData::SimpleMessage(msg) => msg.message,\n+            ErrorData::Custom(c) => c.error.description(),\n         }\n     }\n \n     #[allow(deprecated)]\n     fn cause(&self) -> Option<&dyn error::Error> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(ref c) => c.error.cause(),\n+        match self.repr.data() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(c) => c.error.cause(),\n         }\n     }\n \n     fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(ref c) => c.error.source(),\n+        match self.repr.data() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(c) => c.error.source(),\n         }\n     }\n }"}, {"sha": "f317368e8e59dec5138f35fd71dda97c03f38863", "filename": "library/std/src/io/error/repr_bitpacked.rs", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -0,0 +1,391 @@\n+//! This is a densely packed error representation which is used on targets with\n+//! 64-bit pointers.\n+//!\n+//! (Note that `bitpacked` vs `unpacked` here has no relationship to\n+//! `#[repr(packed)]`, it just refers to attempting to use any available bits in\n+//! a more clever manner than `rustc`'s default layout algorithm would).\n+//!\n+//! Conceptually, it stores the same data as the \"unpacked\" equivalent we use on\n+//! other targets. Specifically, you can imagine it as an optimized version of\n+//! the following enum (which is roughly equivalent to what's stored by\n+//! `repr_unpacked::Repr`, e.g. `super::ErrorData<Box<Custom>>`):\n+//!\n+//! ```ignore (exposition-only)\n+//! enum ErrorData {\n+//!    Os(i32),\n+//!    Simple(ErrorKind),\n+//!    SimpleMessage(&'static SimpleMessage),\n+//!    Custom(Box<Custom>),\n+//! }\n+//! ```\n+//!\n+//! However, it packs this data into a 64bit non-zero value.\n+//!\n+//! This optimization not only allows `io::Error` to occupy a single pointer,\n+//! but improves `io::Result` as well, especially for situations like\n+//! `io::Result<()>` (which is now 64 bits) or `io::Result<u64>` (which is now\n+//! 128 bits), which are quite common.\n+//!\n+//! # Layout\n+//! Tagged values are 64 bits, with the 2 least significant bits used for the\n+//! tag. This means there are there are 4 \"variants\":\n+//!\n+//! - **Tag 0b00**: The first variant is equivalent to\n+//!   `ErrorData::SimpleMessage`, and holds a `&'static SimpleMessage` directly.\n+//!\n+//!   `SimpleMessage` has an alignment >= 4 (which is requested with\n+//!   `#[repr(align)]` and checked statically at the bottom of this file), which\n+//!   means every `&'static SimpleMessage` should have the both tag bits as 0,\n+//!   meaning its tagged and untagged representation are equivalent.\n+//!\n+//!   This means we can skip tagging it, which is necessary as this variant can\n+//!   be constructed from a `const fn`, which probably cannot tag pointers (or\n+//!   at least it would be difficult).\n+//!\n+//! - **Tag 0b01**: The other pointer variant holds the data for\n+//!   `ErrorData::Custom` and the remaining 62 bits are used to store a\n+//!   `Box<Custom>`. `Custom` also has alignment >= 4, so the bottom two bits\n+//!   are free to use for the tag.\n+//!\n+//!   The only important thing to note is that `ptr::wrapping_add` and\n+//!   `ptr::wrapping_sub` are used to tag the pointer, rather than bitwise\n+//!   operations. This should preserve the pointer's provenance, which would\n+//!   otherwise be lost.\n+//!\n+//! - **Tag 0b10**: Holds the data for `ErrorData::Os(i32)`. We store the `i32`\n+//!   in the pointer's most significant 32 bits, and don't use the bits `2..32`\n+//!   for anything. Using the top 32 bits is just to let us easily recover the\n+//!   `i32` code with the correct sign.\n+//!\n+//! - **Tag 0b11**: Holds the data for `ErrorData::Simple(ErrorKind)`. This\n+//!   stores the `ErrorKind` in the top 32 bits as well, although it doesn't\n+//!   occupy nearly that many. Most of the bits are unused here, but it's not\n+//!   like we need them for anything else yet.\n+//!\n+//! # Use of `NonNull<()>`\n+//!\n+//! Everything is stored in a `NonNull<()>`, which is odd, but actually serves a\n+//! purpose.\n+//!\n+//! Conceptually you might think of this more like:\n+//!\n+//! ```ignore (exposition-only)\n+//! union Repr {\n+//!     // holds integer (Simple/Os) variants, and\n+//!     // provides access to the tag bits.\n+//!     bits: NonZeroU64,\n+//!     // Tag is 0, so this is stored untagged.\n+//!     msg: &'static SimpleMessage,\n+//!     // Tagged (offset) `Box<Custom>` pointer.\n+//!     tagged_custom: NonNull<()>,\n+//! }\n+//! ```\n+//!\n+//! But there are a few problems with this:\n+//!\n+//! 1. Union access is equivalent to a transmute, so this representation would\n+//!    require we transmute between integers and pointers in at least one\n+//!    direction, which may be UB (and even if not, it is likely harder for a\n+//!    compiler to reason about than explicit ptr->int operations).\n+//!\n+//! 2. Even if all fields of a union have a niche, the union itself doesn't,\n+//!    although this may change in the future. This would make things like\n+//!    `io::Result<()>` and `io::Result<usize>` larger, which defeats part of\n+//!    the motivation of this bitpacking.\n+//!\n+//! Storing everything in a `NonZeroUsize` (or some other integer) would be a\n+//! bit more traditional for pointer tagging, but it would lose provenance\n+//! information, couldn't be constructed from a `const fn`, and would probably\n+//! run into other issues as well.\n+//!\n+//! The `NonNull<()>` seems like the only alternative, even if it's fairly odd\n+//! to use a pointer type to store something that may hold an integer, some of\n+//! the time.\n+\n+use super::{Custom, ErrorData, ErrorKind, SimpleMessage};\n+use alloc::boxed::Box;\n+use core::mem::{align_of, size_of};\n+use core::ptr::NonNull;\n+\n+// The 2 least-significant bits are used as tag.\n+const TAG_MASK: usize = 0b11;\n+const TAG_SIMPLE_MESSAGE: usize = 0b00;\n+const TAG_CUSTOM: usize = 0b01;\n+const TAG_OS: usize = 0b10;\n+const TAG_SIMPLE: usize = 0b11;\n+\n+#[repr(transparent)]\n+pub(super) struct Repr(NonNull<()>);\n+\n+// All the types `Repr` stores internally are Send + Sync, and so is it.\n+unsafe impl Send for Repr {}\n+unsafe impl Sync for Repr {}\n+\n+impl Repr {\n+    pub(super) fn new_custom(b: Box<Custom>) -> Self {\n+        let p = Box::into_raw(b).cast::<u8>();\n+        // Should only be possible if an allocator handed out a pointer with\n+        // wrong alignment.\n+        debug_assert_eq!((p as usize & TAG_MASK), 0);\n+        // Note: We know `TAG_CUSTOM <= size_of::<Custom>()` (static_assert at\n+        // end of file), and both the start and end of the expression must be\n+        // valid without address space wraparound due to `Box`'s semantics.\n+        //\n+        // This means it would be correct to implement this using `ptr::add`\n+        // (rather than `ptr::wrapping_add`), but it's unclear this would give\n+        // any benefit, so we just use `wrapping_add` instead.\n+        let tagged = p.wrapping_add(TAG_CUSTOM).cast::<()>();\n+        // Safety: `TAG_CUSTOM + p` is the same as `TAG_CUSTOM | p`,\n+        // because `p`'s alignment means it isn't allowed to have any of the\n+        // `TAG_BITS` set (you can verify that addition and bitwise-or are the\n+        // same when the operands have no bits in common using a truth table).\n+        //\n+        // Then, `TAG_CUSTOM | p` is not zero, as that would require\n+        // `TAG_CUSTOM` and `p` both be zero, and neither is (as `p` came from a\n+        // box, and `TAG_CUSTOM` just... isn't zero -- it's `0b01`). Therefore,\n+        // `TAG_CUSTOM + p` isn't zero and so `tagged` can't be, and the\n+        // `new_unchecked` is safe.\n+        let res = Self(unsafe { NonNull::new_unchecked(tagged) });\n+        // quickly smoke-check we encoded the right thing (This generally will\n+        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        debug_assert!(matches!(res.data(), ErrorData::Custom(_)), \"repr(custom) encoding failed\");\n+        res\n+    }\n+\n+    #[inline]\n+    pub(super) fn new_os(code: i32) -> Self {\n+        let utagged = ((code as usize) << 32) | TAG_OS;\n+        // Safety: `TAG_OS` is not zero, so the result of the `|` is not 0.\n+        let res = Self(unsafe { NonNull::new_unchecked(utagged as *mut ()) });\n+        // quickly smoke-check we encoded the right thing (This generally will\n+        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        debug_assert!(\n+            matches!(res.data(), ErrorData::Os(c) if c == code),\n+            \"repr(os) encoding failed for {}\",\n+            code,\n+        );\n+        res\n+    }\n+\n+    #[inline]\n+    pub(super) fn new_simple(kind: ErrorKind) -> Self {\n+        let utagged = ((kind as usize) << 32) | TAG_SIMPLE;\n+        // Safety: `TAG_SIMPLE` is not zero, so the result of the `|` is not 0.\n+        let res = Self(unsafe { NonNull::new_unchecked(utagged as *mut ()) });\n+        // quickly smoke-check we encoded the right thing (This generally will\n+        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        debug_assert!(\n+            matches!(res.data(), ErrorData::Simple(k) if k == kind),\n+            \"repr(simple) encoding failed {:?}\",\n+            kind,\n+        );\n+        res\n+    }\n+\n+    #[inline]\n+    pub(super) const fn new_simple_message(m: &'static SimpleMessage) -> Self {\n+        // Safety: References are never null.\n+        Self(unsafe { NonNull::new_unchecked(m as *const _ as *mut ()) })\n+    }\n+\n+    #[inline]\n+    pub(super) fn data(&self) -> ErrorData<&Custom> {\n+        // Safety: We're a Repr, decode_repr is fine.\n+        unsafe { decode_repr(self.0, |c| &*c) }\n+    }\n+\n+    #[inline]\n+    pub(super) fn data_mut(&mut self) -> ErrorData<&mut Custom> {\n+        // Safety: We're a Repr, decode_repr is fine.\n+        unsafe { decode_repr(self.0, |c| &mut *c) }\n+    }\n+\n+    #[inline]\n+    pub(super) fn into_data(self) -> ErrorData<Box<Custom>> {\n+        let this = core::mem::ManuallyDrop::new(self);\n+        // Safety: We're a Repr, decode_repr is fine. The `Box::from_raw` is\n+        // safe because we prevent double-drop using `ManuallyDrop`.\n+        unsafe { decode_repr(this.0, |p| Box::from_raw(p)) }\n+    }\n+}\n+\n+impl Drop for Repr {\n+    #[inline]\n+    fn drop(&mut self) {\n+        // Safety: We're a Repr, decode_repr is fine. The `Box::from_raw` is\n+        // safe because we're being dropped.\n+        unsafe {\n+            let _ = decode_repr(self.0, |p| Box::<Custom>::from_raw(p));\n+        }\n+    }\n+}\n+\n+// Shared helper to decode a `Repr`'s internal pointer into an ErrorData.\n+//\n+// Safety: `ptr`'s bits should be encoded as described in the document at the\n+// top (it should `some_repr.0`)\n+#[inline]\n+unsafe fn decode_repr<C, F>(ptr: NonNull<()>, make_custom: F) -> ErrorData<C>\n+where\n+    F: FnOnce(*mut Custom) -> C,\n+{\n+    let bits = ptr.as_ptr() as usize;\n+    match bits & TAG_MASK {\n+        TAG_OS => {\n+            let code = ((bits as i64) >> 32) as i32;\n+            ErrorData::Os(code)\n+        }\n+        TAG_SIMPLE => {\n+            let kind_bits = (bits >> 32) as u32;\n+            let kind = kind_from_prim(kind_bits).unwrap_or_else(|| {\n+                debug_assert!(false, \"Invalid io::error::Repr bits: `Repr({:#018x})`\", bits);\n+                // This means the `ptr` passed in was not valid, which violates\n+                // the unsafe contract of `decode_repr`.\n+                //\n+                // Using this rather than unwrap meaningfully improves the code\n+                // for callers which only care about one variant (usually\n+                // `Custom`)\n+                core::hint::unreachable_unchecked();\n+            });\n+            ErrorData::Simple(kind)\n+        }\n+        TAG_SIMPLE_MESSAGE => ErrorData::SimpleMessage(&*ptr.cast::<SimpleMessage>().as_ptr()),\n+        TAG_CUSTOM => {\n+            // It would be correct for us to use `ptr::sub` here (see the\n+            // comment above the `wrapping_add` call in `new_custom` for why),\n+            // but it isn't clear that it makes a difference, so we don't.\n+            let custom = ptr.as_ptr().cast::<u8>().wrapping_sub(TAG_CUSTOM).cast::<Custom>();\n+            ErrorData::Custom(make_custom(custom))\n+        }\n+        _ => {\n+            // Can't happen, and compiler can tell\n+            unreachable!();\n+        }\n+    }\n+}\n+\n+// This compiles to the same code as the check+transmute, but doesn't require\n+// unsafe, or to hard-code max ErrorKind or its size in a way the compiler\n+// couldn't verify.\n+#[inline]\n+fn kind_from_prim(ek: u32) -> Option<ErrorKind> {\n+    macro_rules! from_prim {\n+        ($prim:expr => $Enum:ident { $($Variant:ident),* $(,)? }) => {{\n+            // Force a compile error if the list gets out of date.\n+            const _: fn(e: $Enum) = |e: $Enum| match e {\n+                $($Enum::$Variant => ()),*\n+            };\n+            match $prim {\n+                $(v if v == ($Enum::$Variant as _) => Some($Enum::$Variant),)*\n+                _ => None,\n+            }\n+        }}\n+    }\n+    from_prim!(ek => ErrorKind {\n+        NotFound,\n+        PermissionDenied,\n+        ConnectionRefused,\n+        ConnectionReset,\n+        HostUnreachable,\n+        NetworkUnreachable,\n+        ConnectionAborted,\n+        NotConnected,\n+        AddrInUse,\n+        AddrNotAvailable,\n+        NetworkDown,\n+        BrokenPipe,\n+        AlreadyExists,\n+        WouldBlock,\n+        NotADirectory,\n+        IsADirectory,\n+        DirectoryNotEmpty,\n+        ReadOnlyFilesystem,\n+        FilesystemLoop,\n+        StaleNetworkFileHandle,\n+        InvalidInput,\n+        InvalidData,\n+        TimedOut,\n+        WriteZero,\n+        StorageFull,\n+        NotSeekable,\n+        FilesystemQuotaExceeded,\n+        FileTooLarge,\n+        ResourceBusy,\n+        ExecutableFileBusy,\n+        Deadlock,\n+        CrossesDevices,\n+        TooManyLinks,\n+        FilenameTooLong,\n+        ArgumentListTooLong,\n+        Interrupted,\n+        Other,\n+        UnexpectedEof,\n+        Unsupported,\n+        OutOfMemory,\n+        Uncategorized,\n+    })\n+}\n+\n+// Some static checking to alert us if a change breaks any of the assumptions\n+// that our encoding relies on for correctness and soundness. (Some of these are\n+// a bit overly thorough/cautious, admittedly)\n+//\n+// If any of these are hit on a platform that libstd supports, we should likely\n+// just use `repr_unpacked.rs` there instead (unless the fix is easy).\n+macro_rules! static_assert {\n+    ($condition:expr) => {\n+        const _: () = assert!($condition);\n+    };\n+    (@usize_eq: $lhs:expr, $rhs:expr) => {\n+        const _: [(); $lhs] = [(); $rhs];\n+    };\n+}\n+\n+// The bitpacking we use requires pointers be exactly 64 bits.\n+static_assert!(@usize_eq: size_of::<NonNull<()>>(), 8);\n+\n+// We also require pointers and usize be the same size.\n+static_assert!(@usize_eq: size_of::<NonNull<()>>(), size_of::<usize>());\n+\n+// `Custom` and `SimpleMessage` need to be thin pointers.\n+static_assert!(@usize_eq: size_of::<&'static SimpleMessage>(), 8);\n+static_assert!(@usize_eq: size_of::<Box<Custom>>(), 8);\n+\n+static_assert!((TAG_MASK + 1).is_power_of_two());\n+// And they must have sufficient alignment.\n+static_assert!(align_of::<SimpleMessage>() >= TAG_MASK + 1);\n+static_assert!(align_of::<Custom>() >= TAG_MASK + 1);\n+\n+static_assert!(@usize_eq: (TAG_MASK & TAG_SIMPLE_MESSAGE), TAG_SIMPLE_MESSAGE);\n+static_assert!(@usize_eq: (TAG_MASK & TAG_CUSTOM), TAG_CUSTOM);\n+static_assert!(@usize_eq: (TAG_MASK & TAG_OS), TAG_OS);\n+static_assert!(@usize_eq: (TAG_MASK & TAG_SIMPLE), TAG_SIMPLE);\n+\n+// This is obviously true (`TAG_CUSTOM` is `0b01`), but in `Repr::new_custom` we\n+// offset a pointer by this value, and expect it to both be within the same\n+// object, and to not wrap around the address space. See the comment in that\n+// function for further details.\n+//\n+// Actually, at the moment we use `ptr::wrapping_add`, not `ptr::add`, so this\n+// check isn't needed for that one, although the assertion that we don't\n+// actually wrap around in that wrapping_add does simplify the safety reasoning\n+// elsewhere considerably.\n+static_assert!(size_of::<Custom>() >= TAG_CUSTOM);\n+\n+// These two store a payload which is allowed to be zero, so they must be\n+// non-zero to preserve the `NonNull`'s range invariant.\n+static_assert!(TAG_OS != 0);\n+static_assert!(TAG_SIMPLE != 0);\n+// We can't tag `SimpleMessage`s, the tag must be 0.\n+static_assert!(@usize_eq: TAG_SIMPLE_MESSAGE, 0);\n+\n+// Check that the point of all of this still holds.\n+//\n+// We'd check against `io::Error`, but *technically* it's allowed to vary,\n+// as it's not `#[repr(transparent)]`/`#[repr(C)]`. We could add that, but\n+// the `#[repr()]` would show up in rustdoc, which might be seen as a stable\n+// commitment.\n+static_assert!(@usize_eq: size_of::<Repr>(), 8);\n+static_assert!(@usize_eq: size_of::<Option<Repr>>(), 8);\n+static_assert!(@usize_eq: size_of::<Result<(), Repr>>(), 8);\n+static_assert!(@usize_eq: size_of::<Result<usize, Repr>>(), 16);"}, {"sha": "3729c039c42d70553482fe6a74511d60017547c1", "filename": "library/std/src/io/error/repr_unpacked.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -0,0 +1,50 @@\n+//! This is a fairly simple unpacked error representation that's used on\n+//! non-64bit targets, where the packed 64 bit representation wouldn't work, and\n+//! would have no benefit.\n+\n+use super::{Custom, ErrorData, ErrorKind, SimpleMessage};\n+use alloc::boxed::Box;\n+\n+type Inner = ErrorData<Box<Custom>>;\n+\n+pub(super) struct Repr(Inner);\n+\n+impl Repr {\n+    pub(super) fn new_custom(b: Box<Custom>) -> Self {\n+        Self(Inner::Custom(b))\n+    }\n+    #[inline]\n+    pub(super) fn new_os(code: i32) -> Self {\n+        Self(Inner::Os(code))\n+    }\n+    #[inline]\n+    pub(super) fn new_simple(kind: ErrorKind) -> Self {\n+        Self(Inner::Simple(kind))\n+    }\n+    #[inline]\n+    pub(super) const fn new_simple_message(m: &'static SimpleMessage) -> Self {\n+        Self(Inner::SimpleMessage(m))\n+    }\n+    #[inline]\n+    pub(super) fn into_data(self) -> ErrorData<Box<Custom>> {\n+        self.0\n+    }\n+    #[inline]\n+    pub(super) fn data(&self) -> ErrorData<&Custom> {\n+        match &self.0 {\n+            Inner::Os(c) => ErrorData::Os(*c),\n+            Inner::Simple(k) => ErrorData::Simple(*k),\n+            Inner::SimpleMessage(m) => ErrorData::SimpleMessage(*m),\n+            Inner::Custom(m) => ErrorData::Custom(&*m),\n+        }\n+    }\n+    #[inline]\n+    pub(super) fn data_mut(&mut self) -> ErrorData<&mut Custom> {\n+        match &mut self.0 {\n+            Inner::Os(c) => ErrorData::Os(*c),\n+            Inner::Simple(k) => ErrorData::Simple(*k),\n+            Inner::SimpleMessage(m) => ErrorData::SimpleMessage(*m),\n+            Inner::Custom(m) => ErrorData::Custom(&mut *m),\n+        }\n+    }\n+}"}, {"sha": "c2c51553b208c25253eff217e4891d2f9b2f5dce", "filename": "library/std/src/io/error/tests.rs", "status": "modified", "additions": 78, "deletions": 4, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,4 +1,5 @@\n-use super::{Custom, Error, ErrorKind, Repr};\n+use super::{const_io_error, Custom, Error, ErrorData, ErrorKind, Repr};\n+use crate::assert_matches::assert_matches;\n use crate::error;\n use crate::fmt;\n use crate::mem::size_of;\n@@ -16,9 +17,9 @@ fn test_debug_error() {\n     let msg = error_string(code);\n     let kind = decode_error_kind(code);\n     let err = Error {\n-        repr: Repr::Custom(box Custom {\n+        repr: Repr::new_custom(box Custom {\n             kind: ErrorKind::InvalidInput,\n-            error: box Error { repr: super::Repr::Os(code) },\n+            error: box Error { repr: super::Repr::new_os(code) },\n         }),\n     };\n     let expected = format!(\n@@ -60,10 +61,83 @@ fn test_downcasting() {\n \n #[test]\n fn test_const() {\n-    const E: Error = Error::new_const(ErrorKind::NotFound, &\"hello\");\n+    const E: Error = const_io_error!(ErrorKind::NotFound, \"hello\");\n \n     assert_eq!(E.kind(), ErrorKind::NotFound);\n     assert_eq!(E.to_string(), \"hello\");\n     assert!(format!(\"{:?}\", E).contains(\"\\\"hello\\\"\"));\n     assert!(format!(\"{:?}\", E).contains(\"NotFound\"));\n }\n+\n+#[test]\n+fn test_os_packing() {\n+    for code in -20i32..20i32 {\n+        let e = Error::from_raw_os_error(code);\n+        assert_eq!(e.raw_os_error(), Some(code));\n+        assert_matches!(\n+            e.repr.data(),\n+            ErrorData::Os(c) if c == code,\n+        );\n+    }\n+}\n+\n+#[test]\n+fn test_errorkind_packing() {\n+    assert_eq!(Error::from(ErrorKind::NotFound).kind(), ErrorKind::NotFound);\n+    assert_eq!(Error::from(ErrorKind::PermissionDenied).kind(), ErrorKind::PermissionDenied);\n+    assert_eq!(Error::from(ErrorKind::Uncategorized).kind(), ErrorKind::Uncategorized);\n+    // Check that the innards look like like what we want.\n+    assert_matches!(\n+        Error::from(ErrorKind::OutOfMemory).repr.data(),\n+        ErrorData::Simple(ErrorKind::OutOfMemory),\n+    );\n+}\n+\n+#[test]\n+fn test_simple_message_packing() {\n+    use super::{ErrorKind::*, SimpleMessage};\n+    macro_rules! check_simple_msg {\n+        ($err:expr, $kind:ident, $msg:literal) => {{\n+            let e = &$err;\n+            // Check that the public api is right.\n+            assert_eq!(e.kind(), $kind);\n+            assert!(format!(\"{:?}\", e).contains($msg));\n+            // and we got what we expected\n+            assert_matches!(\n+                e.repr.data(),\n+                ErrorData::SimpleMessage(SimpleMessage { kind: $kind, message: $msg })\n+            );\n+        }};\n+    }\n+\n+    let not_static = const_io_error!(Uncategorized, \"not a constant!\");\n+    check_simple_msg!(not_static, Uncategorized, \"not a constant!\");\n+\n+    const CONST: Error = const_io_error!(NotFound, \"definitely a constant!\");\n+    check_simple_msg!(CONST, NotFound, \"definitely a constant!\");\n+\n+    static STATIC: Error = const_io_error!(BrokenPipe, \"a constant, sort of!\");\n+    check_simple_msg!(STATIC, BrokenPipe, \"a constant, sort of!\");\n+}\n+\n+#[derive(Debug, PartialEq)]\n+struct Bojji(bool);\n+impl error::Error for Bojji {}\n+impl fmt::Display for Bojji {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ah! {:?}\", self)\n+    }\n+}\n+\n+#[test]\n+fn test_custom_error_packing() {\n+    use super::Custom;\n+    let test = Error::new(ErrorKind::Uncategorized, Bojji(true));\n+    assert_matches!(\n+        test.repr.data(),\n+        ErrorData::Custom(Custom {\n+            kind: ErrorKind::Uncategorized,\n+            error,\n+        }) if error.downcast_ref::<Bojji>().as_deref() == Some(&Bojji(true)),\n+    );\n+}"}, {"sha": "64d2457bce1596b28c2d619e3ca40b2fb142f93b", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -5,7 +5,7 @@ use crate::alloc::Allocator;\n use crate::cmp;\n use crate::fmt;\n use crate::io::{\n-    self, BufRead, Error, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write,\n+    self, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write,\n };\n use crate::mem;\n \n@@ -279,7 +279,10 @@ impl Read for &[u8] {\n     #[inline]\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         if buf.len() > self.len() {\n-            return Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"));\n+            return Err(io::const_io_error!(\n+                ErrorKind::UnexpectedEof,\n+                \"failed to fill whole buffer\"\n+            ));\n         }\n         let (a, b) = self.split_at(buf.len());\n \n@@ -361,7 +364,7 @@ impl Write for &mut [u8] {\n         if self.write(data)? == data.len() {\n             Ok(())\n         } else {\n-            Err(Error::new_const(ErrorKind::WriteZero, &\"failed to write whole buffer\"))\n+            Err(io::const_io_error!(ErrorKind::WriteZero, \"failed to write whole buffer\"))\n         }\n     }\n "}, {"sha": "71a59fb58032115e17e61ff233003068ad7887da", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -282,6 +282,7 @@ pub use self::{\n \n #[unstable(feature = \"read_buf\", issue = \"78485\")]\n pub use self::readbuf::ReadBuf;\n+pub(crate) use error::const_io_error;\n \n mod buffered;\n pub(crate) mod copy;\n@@ -337,7 +338,10 @@ where\n     let ret = f(g.buf);\n     if str::from_utf8(&g.buf[g.len..]).is_err() {\n         ret.and_then(|_| {\n-            Err(Error::new_const(ErrorKind::InvalidData, &\"stream did not contain valid UTF-8\"))\n+            Err(error::const_io_error!(\n+                ErrorKind::InvalidData,\n+                \"stream did not contain valid UTF-8\"\n+            ))\n         })\n     } else {\n         g.len = g.buf.len();\n@@ -454,7 +458,7 @@ pub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [\n         }\n     }\n     if !buf.is_empty() {\n-        Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n+        Err(error::const_io_error!(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n     } else {\n         Ok(())\n     }\n@@ -1512,9 +1516,9 @@ pub trait Write {\n         while !buf.is_empty() {\n             match self.write(buf) {\n                 Ok(0) => {\n-                    return Err(Error::new_const(\n+                    return Err(error::const_io_error!(\n                         ErrorKind::WriteZero,\n-                        &\"failed to write whole buffer\",\n+                        \"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => buf = &buf[n..],\n@@ -1580,9 +1584,9 @@ pub trait Write {\n         while !bufs.is_empty() {\n             match self.write_vectored(bufs) {\n                 Ok(0) => {\n-                    return Err(Error::new_const(\n+                    return Err(error::const_io_error!(\n                         ErrorKind::WriteZero,\n-                        &\"failed to write whole buffer\",\n+                        \"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => IoSlice::advance_slices(&mut bufs, n),\n@@ -1657,7 +1661,7 @@ pub trait Write {\n                 if output.error.is_err() {\n                     output.error\n                 } else {\n-                    Err(Error::new_const(ErrorKind::Uncategorized, &\"formatter error\"))\n+                    Err(error::const_io_error!(ErrorKind::Uncategorized, \"formatter error\"))\n                 }\n             }\n         }"}, {"sha": "eb62634856462aa874bc26ab64a9d3381df7a116", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -185,12 +185,12 @@ fn take_eof() {\n \n     impl Read for R {\n         fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n+            Err(io::const_io_error!(io::ErrorKind::Other, \"\"))\n         }\n     }\n     impl BufRead for R {\n         fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n+            Err(io::const_io_error!(io::ErrorKind::Other, \"\"))\n         }\n         fn consume(&mut self, _amt: usize) {}\n     }"}, {"sha": "f676e0a04f000883760a3a141da84018273b1b18", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -17,7 +17,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::io::{self, Error, ErrorKind};\n+use crate::io::{self, ErrorKind};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n@@ -90,6 +90,6 @@ where\n         }\n     }\n     Err(last_err.unwrap_or_else(|| {\n-        Error::new_const(ErrorKind::InvalidInput, &\"could not resolve to any addresses\")\n+        io::const_io_error!(ErrorKind::InvalidInput, \"could not resolve to any addresses\")\n     }))\n }"}, {"sha": "11a696e92c82565725411e01b018e8d1bf61c5fd", "filename": "library/std/src/net/udp.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -2,7 +2,7 @@\n mod tests;\n \n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind};\n+use crate::io::{self, ErrorKind};\n use crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -175,7 +175,9 @@ impl UdpSocket {\n     pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> io::Result<usize> {\n         match addr.to_socket_addrs()?.next() {\n             Some(addr) => self.0.send_to(buf, &addr),\n-            None => Err(Error::new_const(ErrorKind::InvalidInput, &\"no addresses to send data to\")),\n+            None => {\n+                Err(io::const_io_error!(ErrorKind::InvalidInput, \"no addresses to send data to\"))\n+            }\n         }\n     }\n "}, {"sha": "b53c3e79b0fe6e7a9046a434ef3623ec313baa31", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -93,9 +93,9 @@ impl OwnedFd {\n \n     #[cfg(target_os = \"wasi\")]\n     pub fn try_clone(&self) -> crate::io::Result<Self> {\n-        Err(crate::io::Error::new_const(\n+        Err(crate::io::const_io_error!(\n             crate::io::ErrorKind::Unsupported,\n-            &\"operation not supported on WASI yet\",\n+            \"operation not supported on WASI yet\",\n         ))\n     }\n }"}, {"sha": "db7edcd057432563b925d1118690ab7a5817b459", "filename": "library/std/src/os/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -114,7 +114,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new_const(io::ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n+            Err(io::const_io_error!(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\",))\n         } else {\n             Ok(())\n         }\n@@ -196,9 +196,9 @@ pub trait FileExt {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n                 Ok(0) => {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::WriteZero,\n-                        &\"failed to write whole buffer\",\n+                        \"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => {"}, {"sha": "034fa301ba1ead4c434edf14adb9a41886f22844", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -30,16 +30,16 @@ pub(super) fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::s\n     let bytes = path.as_os_str().as_bytes();\n \n     if bytes.contains(&0) {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             io::ErrorKind::InvalidInput,\n-            &\"paths must not contain interior null bytes\",\n+            \"paths must not contain interior null bytes\",\n         ));\n     }\n \n     if bytes.len() >= addr.sun_path.len() {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             io::ErrorKind::InvalidInput,\n-            &\"path must be shorter than SUN_LEN\",\n+            \"path must be shorter than SUN_LEN\",\n         ));\n     }\n     // SAFETY: `bytes` and `addr.sun_path` are not overlapping and\n@@ -121,9 +121,9 @@ impl SocketAddr {\n             // linux returns zero bytes of address\n             len = sun_path_offset(&addr) as libc::socklen_t; // i.e., zero-length address\n         } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"file descriptor did not correspond to a Unix socket\",\n+                \"file descriptor did not correspond to a Unix socket\",\n             ));\n         }\n \n@@ -323,9 +323,9 @@ impl SocketAddr {\n             addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n \n             if namespace.len() + 1 > addr.sun_path.len() {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    &\"namespace must be shorter than SUN_LEN\",\n+                    \"namespace must be shorter than SUN_LEN\",\n                 ));\n             }\n "}, {"sha": "160c8f1eca251a01fe4286ed7a23269226c8e6ae", "filename": "library/std/src/os/wasi/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -87,7 +87,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new_const(io::ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n+            Err(io::const_io_error!(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -153,9 +153,9 @@ pub trait FileExt {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n                 Ok(0) => {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::WriteZero,\n-                        &\"failed to write whole buffer\",\n+                        \"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => {\n@@ -258,9 +258,9 @@ impl FileExt for fs::File {\n             a if a == wasi::ADVICE_DONTNEED.raw() => wasi::ADVICE_DONTNEED,\n             a if a == wasi::ADVICE_NOREUSE.raw() => wasi::ADVICE_NOREUSE,\n             _ => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    &\"invalid parameter 'advice'\",\n+                    \"invalid parameter 'advice'\",\n                 ));\n             }\n         };\n@@ -554,5 +554,5 @@ pub fn symlink_path<P: AsRef<Path>, U: AsRef<Path>>(old_path: P, new_path: U) ->\n \n fn osstr2str(f: &OsStr) -> io::Result<&str> {\n     f.to_str()\n-        .ok_or_else(|| io::Error::new_const(io::ErrorKind::Uncategorized, &\"input must be utf-8\"))\n+        .ok_or_else(|| io::const_io_error!(io::ErrorKind::Uncategorized, \"input must be utf-8\"))\n }"}, {"sha": "d3a5b6dcc76c6847125ac630d2e04a036e928b21", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -135,7 +135,7 @@ impl OwnedSocket {\n \n     #[cfg(target_vendor = \"uwp\")]\n     pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n-        Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Unavailable on UWP\"))\n+        Err(io::const_io_error!(io::ErrorKind::Unsupported, \"Unavailable on UWP\"))\n     }\n }\n "}, {"sha": "fa9a7fb19e4631fcab9c7d99de57a78857256559", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -226,7 +226,7 @@ impl OpenOptions {\n             (false, _, true) => Ok(O_WRONLY | O_APPEND),\n             (true, _, true) => Ok(O_RDWR | O_APPEND),\n             (false, false, false) => {\n-                Err(io::Error::new_const(ErrorKind::InvalidInput, &\"invalid access mode\"))\n+                Err(io::const_io_error!(ErrorKind::InvalidInput, \"invalid access mode\"))\n             }\n         }\n     }\n@@ -236,17 +236,17 @@ impl OpenOptions {\n             (true, false) => {}\n             (false, false) => {\n                 if self.truncate || self.create || self.create_new {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         ErrorKind::InvalidInput,\n-                        &\"invalid creation mode\",\n+                        \"invalid creation mode\",\n                     ));\n                 }\n             }\n             (_, true) => {\n                 if self.truncate && !self.create_new {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         ErrorKind::InvalidInput,\n-                        &\"invalid creation mode\",\n+                        \"invalid creation mode\",\n                     ));\n                 }\n             }"}, {"sha": "b798c97448b8f541aa68c19076e7736d0b6217ce", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -58,9 +58,9 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new_const(\n+    crate::io::const_io_error!(\n         crate::io::ErrorKind::Unsupported,\n-        &\"operation not supported on HermitCore yet\",\n+        \"operation not supported on HermitCore yet\",\n     )\n }\n "}, {"sha": "f65fd8e53bdc999a26998c5093124b0b2bba7ee6", "filename": "library/std/src/sys/hermit/net.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -14,9 +14,9 @@ use crate::time::Duration;\n /// if not, starts it.\n pub fn init() -> io::Result<()> {\n     if abi::network_init() < 0 {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             ErrorKind::Uncategorized,\n-            &\"Unable to initialize network interface\",\n+            \"Unable to initialize network interface\",\n         ));\n     }\n \n@@ -50,9 +50,9 @@ impl TcpStream {\n \n         match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n             Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => Err(io::Error::new_const(\n+            _ => Err(io::const_io_error!(\n                 ErrorKind::Uncategorized,\n-                &\"Unable to initiate a connection on a socket\",\n+                \"Unable to initiate a connection on a socket\",\n             )),\n         }\n     }\n@@ -64,17 +64,17 @@ impl TcpStream {\n             Some(duration.as_millis() as u64),\n         ) {\n             Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => Err(io::Error::new_const(\n+            _ => Err(io::const_io_error!(\n                 ErrorKind::Uncategorized,\n-                &\"Unable to initiate a connection on a socket\",\n+                \"Unable to initiate a connection on a socket\",\n             )),\n         }\n     }\n \n     pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n         abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n             .map_err(|_| {\n-                io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to set timeout value\")\n+                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to set timeout value\")\n             })\n     }\n \n@@ -83,28 +83,28 @@ impl TcpStream {\n             *self.0.as_inner(),\n             duration.map(|d| d.as_millis() as u64),\n         )\n-        .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to set timeout value\"))\n+        .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"Unable to set timeout value\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner()).map_err(|_| {\n-            io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to determine timeout value\")\n+            io::const_io_error!(ErrorKind::Uncategorized, \"Unable to determine timeout value\")\n         })?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner()).map_err(|_| {\n-            io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to determine timeout value\")\n+            io::const_io_error!(ErrorKind::Uncategorized, \"Unable to determine timeout value\")\n         })?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n         abi::tcpstream::peek(*self.0.as_inner(), buf)\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"peek failed\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"peek failed\"))\n     }\n \n     pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n@@ -116,7 +116,7 @@ impl TcpStream {\n \n         for i in ioslice.iter_mut() {\n             let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..]).map_err(|_| {\n-                io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to read on socket\")\n+                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to read on socket\")\n             })?;\n \n             if ret != 0 {\n@@ -141,7 +141,7 @@ impl TcpStream {\n \n         for i in ioslice.iter() {\n             size += abi::tcpstream::write(*self.0.as_inner(), i).map_err(|_| {\n-                io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to write on socket\")\n+                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to write on socket\")\n             })?;\n         }\n \n@@ -155,13 +155,13 @@ impl TcpStream {\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"peer_addr failed\"))?;\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"peer_addr failed\"))?;\n \n         let saddr = match ipaddr {\n             Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n             Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n             _ => {\n-                return Err(io::Error::new_const(ErrorKind::Uncategorized, &\"peer_addr failed\"));\n+                return Err(io::const_io_error!(ErrorKind::Uncategorized, \"peer_addr failed\"));\n             }\n         };\n \n@@ -173,9 +173,8 @@ impl TcpStream {\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32).map_err(|_| {\n-            io::Error::new_const(ErrorKind::Uncategorized, &\"unable to shutdown socket\")\n-        })\n+        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to shutdown socket\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n@@ -192,22 +191,22 @@ impl TcpStream {\n \n     pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n         abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"set_nodelay failed\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"set_nodelay failed\"))\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n         abi::tcpstream::nodelay(*self.0.as_inner())\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"nodelay failed\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"nodelay failed\"))\n     }\n \n     pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n         abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"unable to set TTL\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to set TTL\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n         abi::tcpstream::get_tll(*self.0.as_inner())\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"unable to get TTL\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to get TTL\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n@@ -216,7 +215,7 @@ impl TcpStream {\n \n     pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n         abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode).map_err(|_| {\n-            io::Error::new_const(ErrorKind::Uncategorized, &\"unable to set blocking mode\")\n+            io::const_io_error!(ErrorKind::Uncategorized, \"unable to set blocking mode\")\n         })\n     }\n }\n@@ -243,12 +242,12 @@ impl TcpListener {\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"accept failed\"))?;\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"accept failed\"))?;\n         let saddr = match ipaddr {\n             Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n             Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n             _ => {\n-                return Err(io::Error::new_const(ErrorKind::Uncategorized, &\"accept failed\"));\n+                return Err(io::const_io_error!(ErrorKind::Uncategorized, \"accept failed\"));\n             }\n         };\n "}, {"sha": "514de1df6f9c33bc32f0ca34b0bd29ee6523c6c8", "filename": "library/std/src/sys/hermit/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -40,7 +40,7 @@ impl io::Write for Stdout {\n         unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Stdout is not able to print\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Stdout is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -52,7 +52,7 @@ impl io::Write for Stdout {\n         unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Stdout is not able to print\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Stdout is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -81,7 +81,7 @@ impl io::Write for Stderr {\n         unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Stderr is not able to print\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Stderr is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -93,7 +93,7 @@ impl io::Write for Stderr {\n         unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Stderr is not able to print\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Stderr is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }"}, {"sha": "e53a1fea6a0dca8b4a6e49aeecd49839e6efbe25", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -39,7 +39,7 @@ impl Thread {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n             // safe to reconstruct the box so that it gets deallocated.\n             drop(Box::from_raw(p));\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Unable to create thread!\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Unable to create thread!\"))\n         } else {\n             Ok(Thread { tid: tid })\n         };"}, {"sha": "158c92e7a77d42ccf08c79e23ca576852885967d", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -58,7 +58,7 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new_const(ErrorKind::Unsupported, &\"operation not supported on SGX yet\")\n+    crate::io::const_io_error!(ErrorKind::Unsupported, \"operation not supported on SGX yet\")\n }\n \n /// This function is used to implement various functions that doesn't exist,\n@@ -69,9 +69,9 @@ pub fn unsupported_err() -> crate::io::Error {\n pub fn sgx_ineffective<T>(v: T) -> crate::io::Result<T> {\n     static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n     if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n-        Err(crate::io::Error::new_const(\n+        Err(crate::io::const_io_error!(\n             ErrorKind::Uncategorized,\n-            &\"operation can't be trusted to have any effect on SGX\",\n+            \"operation can't be trusted to have any effect on SGX\",\n         ))\n     } else {\n         Ok(v)"}, {"sha": "d14990c6877af6384dfc4385d2bd2c4702523109", "filename": "library/std/src/sys/sgx/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -97,9 +97,9 @@ impl TcpStream {\n \n     pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {\n         if dur == Duration::default() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"cannot set a 0 duration timeout\",\n+                \"cannot set a 0 duration timeout\",\n             ));\n         }\n         Self::connect(Ok(addr)) // FIXME: ignoring timeout\n@@ -108,9 +108,9 @@ impl TcpStream {\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    &\"cannot set a 0 duration timeout\",\n+                    \"cannot set a 0 duration timeout\",\n                 ));\n             }\n             _ => sgx_ineffective(()),\n@@ -120,9 +120,9 @@ impl TcpStream {\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    &\"cannot set a 0 duration timeout\",\n+                    \"cannot set a 0 duration timeout\",\n                 ));\n             }\n             _ => sgx_ineffective(()),"}, {"sha": "a6ed10f7789d26ffdd1e90a55c24243d7106b47b", "filename": "library/std/src/sys/solid/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -461,7 +461,7 @@ impl fmt::Debug for File {\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n     if stat(p)?.file_type().is_dir() {\n-        Err(io::Error::new_const(io::ErrorKind::IsADirectory, &\"is a directory\"))\n+        Err(io::const_io_error!(io::ErrorKind::IsADirectory, \"is a directory\"))\n     } else {\n         error::SolidError::err_if_negative(unsafe { abi::SOLID_FS_Unlink(cstr(p)?.as_ptr()) })\n             .map_err(|e| e.as_io_error())?;\n@@ -491,7 +491,7 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n             .map_err(|e| e.as_io_error())?;\n         Ok(())\n     } else {\n-        Err(io::Error::new_const(io::ErrorKind::NotADirectory, &\"not a directory\"))\n+        Err(io::const_io_error!(io::ErrorKind::NotADirectory, \"not a directory\"))\n     }\n }\n \n@@ -511,7 +511,7 @@ pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     // This target doesn't support symlinks\n     stat(p)?;\n-    Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"not a symbolic link\"))\n+    Err(io::const_io_error!(io::ErrorKind::InvalidInput, \"not a symbolic link\"))\n }\n \n pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {"}, {"sha": "2082c9401535e8d1f4dd67a535f03eda626286bf", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -57,9 +57,9 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new_const(\n+    crate::io::const_io_error!(\n         crate::io::ErrorKind::Unsupported,\n-        &\"operation not supported on this platform\",\n+        \"operation not supported on this platform\",\n     )\n }\n "}, {"sha": "a43407bd0f8652a767cef42a221a33c83d26fd13", "filename": "library/std/src/sys/solid/net.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -243,9 +243,9 @@ impl Socket {\n         }\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"cannot set a 0 duration timeout\",\n+                \"cannot set a 0 duration timeout\",\n             ));\n         }\n \n@@ -271,7 +271,7 @@ impl Socket {\n         };\n \n         match n {\n-            0 => Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\")),\n+            0 => Err(io::const_io_error!(io::ErrorKind::TimedOut, \"connection timed out\")),\n             _ => {\n                 let can_write = writefds.num_fds != 0;\n                 if !can_write {\n@@ -364,9 +364,9 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::InvalidInput,\n-                        &\"cannot set a 0 duration timeout\",\n+                        \"cannot set a 0 duration timeout\",\n                     ));\n                 }\n "}, {"sha": "22239e1fa8ebc1944be2e0ae43e8f13b92b90a34", "filename": "library/std/src/sys/solid/os.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -173,11 +173,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n /// In kmclib, `setenv` and `unsetenv` don't always set `errno`, so this\n /// function just returns a generic error.\n fn cvt_env(t: c_int) -> io::Result<c_int> {\n-    if t == -1 {\n-        Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"failure\"))\n-    } else {\n-        Ok(t)\n-    }\n+    if t == -1 { Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"failure\")) } else { Ok(t) }\n }\n \n pub fn temp_dir() -> PathBuf {"}, {"sha": "8bd0b9b14afedb4cb14c7b23eb1abee90ffecaf2", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -387,17 +387,17 @@ impl FileAttr {\n                         tv_nsec: ext.stx_btime.tv_nsec as _,\n                     }))\n                 } else {\n-                    Err(io::Error::new_const(\n+                    Err(io::const_io_error!(\n                         io::ErrorKind::Uncategorized,\n-                        &\"creation time is not available for the filesystem\",\n+                        \"creation time is not available for the filesystem\",\n                     ))\n                 };\n             }\n         }\n \n-        Err(io::Error::new_const(\n+        Err(io::const_io_error!(\n             io::ErrorKind::Unsupported,\n-            &\"creation time is not available on this platform \\\n+            \"creation time is not available on this platform \\\n                             currently\",\n         ))\n     }"}, {"sha": "d13e1ecbbfed4c8627a1f9ecf2ae91a5878c0a14", "filename": "library/std/src/sys/unix/l4re.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -1,8 +1,8 @@\n macro_rules! unimpl {\n     () => {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             io::ErrorKind::Unsupported,\n-            &\"No networking available on L4Re.\",\n+            \"No networking available on L4Re.\",\n         ));\n     };\n }"}, {"sha": "6382354eb6ebd050e218a059eb786d24a807020b", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -322,9 +322,6 @@ mod unsupported {\n     }\n \n     pub fn unsupported_err() -> io::Error {\n-        io::Error::new_const(\n-            io::ErrorKind::Unsupported,\n-            &\"operation not supported on this platform\",\n-        )\n+        io::const_io_error!(io::ErrorKind::Unsupported, \"operation not supported on this platform\",)\n     }\n }"}, {"sha": "61c15ecd85de3ce0a80355126d86fa899671cdb3", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -154,9 +154,9 @@ impl Socket {\n         let mut pollfd = libc::pollfd { fd: self.as_raw_fd(), events: libc::POLLOUT, revents: 0 };\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"cannot set a 0 duration timeout\",\n+                \"cannot set a 0 duration timeout\",\n             ));\n         }\n \n@@ -165,7 +165,7 @@ impl Socket {\n         loop {\n             let elapsed = start.elapsed();\n             if elapsed >= timeout {\n-                return Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"));\n+                return Err(io::const_io_error!(io::ErrorKind::TimedOut, \"connection timed out\"));\n             }\n \n             let timeout = timeout - elapsed;\n@@ -192,9 +192,9 @@ impl Socket {\n                     // for POLLHUP rather than read readiness\n                     if pollfd.revents & libc::POLLHUP != 0 {\n                         let e = self.take_error()?.unwrap_or_else(|| {\n-                            io::Error::new_const(\n+                            io::const_io_error!(\n                                 io::ErrorKind::Uncategorized,\n-                                &\"no error set after POLLHUP\",\n+                                \"no error set after POLLHUP\",\n                             )\n                         });\n                         return Err(e);\n@@ -338,9 +338,9 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::InvalidInput,\n-                        &\"cannot set a 0 duration timeout\",\n+                        \"cannot set a 0 duration timeout\",\n                     ));\n                 }\n "}, {"sha": "b268ef5c36400ba3c2aa97cc97f61792d2e83c4c", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -294,9 +294,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                 0,\n             ))?;\n             if path_len <= 1 {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::Uncategorized,\n-                    &\"KERN_PROC_PATHNAME sysctl returned zero-length string\",\n+                    \"KERN_PROC_PATHNAME sysctl returned zero-length string\",\n                 ));\n             }\n             let mut path: Vec<u8> = Vec::with_capacity(path_len);\n@@ -317,9 +317,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         if curproc_exe.is_file() {\n             return crate::fs::read_link(curproc_exe);\n         }\n-        Err(io::Error::new_const(\n+        Err(io::const_io_error!(\n             io::ErrorKind::Uncategorized,\n-            &\"/proc/curproc/exe doesn't point to regular file.\",\n+            \"/proc/curproc/exe doesn't point to regular file.\",\n         ))\n     }\n     sysctl().or_else(|_| procfs())\n@@ -336,9 +336,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _, &mut argv_len, ptr::null_mut(), 0))?;\n         argv.set_len(argv_len as usize);\n         if argv[0].is_null() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::Uncategorized,\n-                &\"no current exe available\",\n+                \"no current exe available\",\n             ));\n         }\n         let argv0 = CStr::from_ptr(argv[0]).to_bytes();\n@@ -353,9 +353,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"emscripten\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     match crate::fs::read_link(\"/proc/self/exe\") {\n-        Err(ref e) if e.kind() == io::ErrorKind::NotFound => Err(io::Error::new_const(\n+        Err(ref e) if e.kind() == io::ErrorKind::NotFound => Err(io::const_io_error!(\n             io::ErrorKind::Uncategorized,\n-            &\"no /proc/self/exe available. Is /proc mounted?\",\n+            \"no /proc/self/exe available. Is /proc mounted?\",\n         )),\n         other => other,\n     }\n@@ -417,7 +417,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         );\n         if result != 0 {\n             use crate::io::ErrorKind;\n-            Err(io::Error::new_const(ErrorKind::Uncategorized, &\"Error getting executable path\"))\n+            Err(io::const_io_error!(ErrorKind::Uncategorized, \"Error getting executable path\"))\n         } else {\n             let name = CStr::from_ptr((*info.as_ptr()).name.as_ptr()).to_bytes();\n             Ok(PathBuf::from(OsStr::from_bytes(name)))\n@@ -433,7 +433,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n #[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     use crate::io::ErrorKind;\n-    Err(io::Error::new_const(ErrorKind::Unsupported, &\"Not yet implemented!\"))\n+    Err(io::const_io_error!(ErrorKind::Unsupported, \"Not yet implemented!\"))\n }\n \n #[cfg(target_os = \"vxworks\")]"}, {"sha": "09bfd9680f5b2c50841d9ee9b9267c1a62e6e7a7", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -23,9 +23,9 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n+                \"nul byte found in provided data\",\n             ));\n         }\n \n@@ -38,9 +38,9 @@ impl Command {\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         if self.saw_nul() {\n-            return io::Error::new_const(\n+            return io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n+                \"nul byte found in provided data\",\n             );\n         }\n \n@@ -186,9 +186,9 @@ impl Process {\n             ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidData,\n-                &\"Failed to get exit status of process\",\n+                \"Failed to get exit status of process\",\n             ));\n         }\n         Ok(ExitStatus(proc_info.return_code))\n@@ -224,9 +224,9 @@ impl Process {\n             ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidData,\n-                &\"Failed to get exit status of process\",\n+                \"Failed to get exit status of process\",\n             ));\n         }\n         Ok(Some(ExitStatus(proc_info.return_code)))"}, {"sha": "9fc2d9fce4dc41b5df8c5fe2b0a5762a03b1bb24", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -44,9 +44,9 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n+                \"nul byte found in provided data\",\n             ));\n         }\n \n@@ -222,10 +222,7 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return io::Error::new_const(\n-                ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n-            );\n+            return io::const_io_error!(ErrorKind::InvalidInput, \"nul byte found in provided data\",);\n         }\n \n         match self.setup_io(default, true) {\n@@ -581,9 +578,9 @@ impl Process {\n         // and used for another process, and we probably shouldn't be killing\n         // random processes, so just return an error.\n         if self.status.is_some() {\n-            Err(Error::new_const(\n+            Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"invalid argument: can't kill an exited process\",\n+                \"invalid argument: can't kill an exited process\",\n             ))\n         } else {\n             cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)"}, {"sha": "c6714d3aae246ffb8d640b8cb34106dfcfc31d8b", "filename": "library/std/src/sys/unix/process/process_vxworks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -24,9 +24,9 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n+                \"nul byte found in provided data\",\n             ));\n         }\n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n@@ -142,9 +142,9 @@ impl Process {\n         // and used for another process, and we probably shouldn't be killing\n         // random processes, so just return an error.\n         if self.status.is_some() {\n-            Err(Error::new_const(\n+            Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"invalid argument: can't kill an exited process\",\n+                \"invalid argument: can't kill an exited process\",\n             ))\n         } else {\n             cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)"}, {"sha": "cf8cf5ad49f73d03f3122f7a81a318928d8e23d5", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -287,7 +287,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n             }\n             match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n                 -1 => Err(io::Error::last_os_error()),\n-                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n+                0 => Err(io::const_io_error!(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\")),\n                 cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n             }\n         } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n@@ -318,7 +318,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n                 if res == -1 {\n                     return Err(io::Error::last_os_error());\n                 } else if cpus == 0 {\n-                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n+                    return Err(io::const_io_error!(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n                 }\n             }\n             Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n@@ -344,7 +344,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n             if res == -1 {\n                 return Err(io::Error::last_os_error());\n             } else if cpus == 0 {\n-                return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n+                return Err(io::const_io_error!(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n             }\n \n             Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n@@ -356,14 +356,14 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n                 let res = libc::get_system_info(&mut sinfo);\n \n                 if res != libc::B_OK {\n-                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n+                    return Err(io::const_io_error!(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n                 }\n \n                 Ok(NonZeroUsize::new_unchecked(sinfo.cpu_count as usize))\n             }\n         } else {\n             // FIXME: implement on vxWorks, Redox, l4re\n-            Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Getting the number of hardware threads is not supported on the target platform\"))\n+            Err(io::const_io_error!(io::ErrorKind::Unsupported, \"Getting the number of hardware threads is not supported on the target platform\"))\n         }\n     }\n }"}, {"sha": "5274f53a7dbdb5be7fdcf270c4526d269885b681", "filename": "library/std/src/sys/unsupported/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -21,9 +21,9 @@ pub fn unsupported<T>() -> std_io::Result<T> {\n }\n \n pub fn unsupported_err() -> std_io::Error {\n-    std_io::Error::new_const(\n+    std_io::const_io_error!(\n         std_io::ErrorKind::Unsupported,\n-        &\"operation not supported on this platform\",\n+        \"operation not supported on this platform\",\n     )\n }\n "}, {"sha": "e150ae143ad99b271338186ba51110a55e2cfd97", "filename": "library/std/src/sys/unsupported/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -81,11 +81,11 @@ pub fn getenv(_: &OsStr) -> Option<OsString> {\n }\n \n pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n-    Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"cannot set env vars on this platform\"))\n+    Err(io::const_io_error!(io::ErrorKind::Unsupported, \"cannot set env vars on this platform\"))\n }\n \n pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n-    Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"cannot unset env vars on this platform\"))\n+    Err(io::const_io_error!(io::ErrorKind::Unsupported, \"cannot unset env vars on this platform\"))\n }\n \n pub fn temp_dir() -> PathBuf {"}, {"sha": "cd6815bfc2136786e36a73b6225852782535453d", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -711,7 +711,7 @@ fn open_parent(p: &Path) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n \n pub fn osstr2str(f: &OsStr) -> io::Result<&str> {\n     f.to_str()\n-        .ok_or_else(|| io::Error::new_const(io::ErrorKind::Uncategorized, &\"input must be utf-8\"))\n+        .ok_or_else(|| io::const_io_error!(io::ErrorKind::Uncategorized, \"input must be utf-8\"))\n }\n \n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n@@ -757,7 +757,7 @@ fn remove_dir_all_recursive(parent: &WasiFd, path: &Path) -> io::Result<()> {\n     for entry in ReadDir::new(fd, dummy_root) {\n         let entry = entry?;\n         let path = crate::str::from_utf8(&entry.name).map_err(|_| {\n-            io::Error::new_const(io::ErrorKind::Uncategorized, &\"invalid utf-8 file name found\")\n+            io::const_io_error!(io::ErrorKind::Uncategorized, \"invalid utf-8 file name found\")\n         })?;\n \n         if entry.file_type()?.is_dir() {"}, {"sha": "fed655af87e635070d077b36734205205c98d40e", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -511,9 +511,9 @@ impl File {\n                     )\n                 }\n                 _ => {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::Uncategorized,\n-                        &\"Unsupported reparse point type\",\n+                        \"Unsupported reparse point type\",\n                     ));\n                 }\n             };\n@@ -1124,9 +1124,9 @@ pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n \n #[cfg(target_vendor = \"uwp\")]\n pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n-    return Err(io::Error::new_const(\n+    return Err(io::const_io_error!(\n         io::ErrorKind::Unsupported,\n-        &\"hard link are not supported on UWP\",\n+        \"hard link are not supported on UWP\",\n     ));\n }\n "}, {"sha": "c70f254cf39f8d734354a11c5400f864bb117f4d", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -160,9 +160,9 @@ pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> crate::io::Result<Vec<u16>> {\n     fn inner(s: &OsStr) -> crate::io::Result<Vec<u16>> {\n         let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n         if unrolled_find_u16s(0, &maybe_result).is_some() {\n-            return Err(crate::io::Error::new_const(\n+            return Err(crate::io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"strings passed to WinAPI cannot contain NULs\",\n+                \"strings passed to WinAPI cannot contain NULs\",\n             ));\n         }\n         maybe_result.push(0);"}, {"sha": "aa6400aeefa0ddb2cb186c36f8e3ef3c636b2c5e", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -152,9 +152,9 @@ impl Socket {\n         match result {\n             Err(ref error) if error.kind() == io::ErrorKind::WouldBlock => {\n                 if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::InvalidInput,\n-                        &\"cannot set a 0 duration timeout\",\n+                        \"cannot set a 0 duration timeout\",\n                     ));\n                 }\n \n@@ -185,9 +185,7 @@ impl Socket {\n                 };\n \n                 match count {\n-                    0 => {\n-                        Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"))\n-                    }\n+                    0 => Err(io::const_io_error!(io::ErrorKind::TimedOut, \"connection timed out\")),\n                     _ => {\n                         if writefds.fd_count != 1 {\n                             if let Some(e) = self.take_error()? {\n@@ -353,9 +351,9 @@ impl Socket {\n             Some(dur) => {\n                 let timeout = sys::dur2timeout(dur);\n                 if timeout == 0 {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::InvalidInput,\n-                        &\"cannot set a 0 duration timeout\",\n+                        \"cannot set a 0 duration timeout\",\n                     ));\n                 }\n                 timeout"}, {"sha": "c6f641d0932bf4bb0aeaa514c8d718a4176b6d7c", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -149,7 +149,7 @@ impl AsRef<OsStr> for EnvKey {\n \n fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n     if str.as_ref().encode_wide().any(|b| b == 0) {\n-        Err(io::Error::new_const(ErrorKind::InvalidInput, &\"nul byte found in provided data\"))\n+        Err(io::const_io_error!(ErrorKind::InvalidInput, \"nul byte found in provided data\"))\n     } else {\n         Ok(str)\n     }\n@@ -369,9 +369,9 @@ fn resolve_exe<'a>(\n ) -> io::Result<PathBuf> {\n     // Early return if there is no filename.\n     if exe_path.is_empty() || path::has_trailing_slash(exe_path) {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             io::ErrorKind::InvalidInput,\n-            &\"program path has no file name\",\n+            \"program path has no file name\",\n         ));\n     }\n     // Test if the file name has the `exe` extension.\n@@ -422,7 +422,7 @@ fn resolve_exe<'a>(\n         }\n     }\n     // If we get here then the executable cannot be found.\n-    Err(io::Error::new_const(io::ErrorKind::NotFound, &\"program not found\"))\n+    Err(io::const_io_error!(io::ErrorKind::NotFound, \"program not found\"))\n }\n \n // Calls `f` for every path that should be used to find an executable."}, {"sha": "a001d6b9858234a79bce1044e4d8c7e49bcf02b6", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -110,9 +110,9 @@ fn write(\n         if data[0] >> 6 != 0b10 {\n             // not a continuation byte - reject\n             incomplete_utf8.len = 0;\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidData,\n-                &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n             ));\n         }\n         incomplete_utf8.bytes[incomplete_utf8.len as usize] = data[0];\n@@ -132,9 +132,9 @@ fn write(\n                 return Ok(1);\n             }\n             Err(_) => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidData,\n-                    &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                    \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n                 ));\n             }\n         }\n@@ -156,9 +156,9 @@ fn write(\n                 incomplete_utf8.len = 1;\n                 return Ok(1);\n             } else {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidData,\n-                    &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                    \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n                 ));\n             }\n         }\n@@ -364,9 +364,9 @@ fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n             }\n             Err(_) => {\n                 // We can't really do any better than forget all data and return an error.\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidData,\n-                    &\"Windows stdin in console mode does not support non-UTF-16 input; \\\n+                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n                      encountered unpaired surrogate\",\n                 ));\n             }"}, {"sha": "e4bba9255d23e774849196a88f09ee882638be2c", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -107,9 +107,9 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         sysinfo.dwNumberOfProcessors as usize\n     };\n     match res {\n-        0 => Err(io::Error::new_const(\n+        0 => Err(io::const_io_error!(\n             io::ErrorKind::NotFound,\n-            &\"The number of hardware threads is not known for the target platform\",\n+            \"The number of hardware threads is not known for the target platform\",\n         )),\n         cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus) }),\n     }"}, {"sha": "617ac52e51ca81aeb24b4ddcc289cc31acacbcee", "filename": "library/std/src/sys_common/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -4,9 +4,9 @@ use crate::fs;\n use crate::io::{self, Error, ErrorKind};\n use crate::path::Path;\n \n-pub(crate) const NOT_FILE_ERROR: Error = Error::new_const(\n+pub(crate) const NOT_FILE_ERROR: Error = io::const_io_error!(\n     ErrorKind::InvalidInput,\n-    &\"the source path is neither a regular file nor a symlink to a regular file\",\n+    \"the source path is neither a regular file nor a symlink to a regular file\",\n );\n \n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {"}, {"sha": "70b29d4a92ed56f64b837474229fd208ee577d52", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734368a200904ef9c21db86c595dc04263c87be0/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=734368a200904ef9c21db86c595dc04263c87be0", "patch": "@@ -5,7 +5,7 @@ use crate::cmp;\n use crate::convert::{TryFrom, TryInto};\n use crate::ffi::CString;\n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::ptr;\n@@ -102,7 +102,7 @@ pub fn sockaddr_to_addr(storage: &c::sockaddr_storage, len: usize) -> io::Result\n                 *(storage as *const _ as *const c::sockaddr_in6)\n             })))\n         }\n-        _ => Err(Error::new_const(ErrorKind::InvalidInput, &\"invalid argument\")),\n+        _ => Err(io::const_io_error!(ErrorKind::InvalidInput, \"invalid argument\")),\n     }\n }\n \n@@ -165,7 +165,7 @@ impl TryFrom<&str> for LookupHost {\n             ($e:expr, $msg:expr) => {\n                 match $e {\n                     Some(r) => r,\n-                    None => return Err(io::Error::new_const(io::ErrorKind::InvalidInput, &$msg)),\n+                    None => return Err(io::const_io_error!(io::ErrorKind::InvalidInput, $msg)),\n                 }\n             };\n         }"}]}