{"sha": "3d10c64b26936a5b597bffc983220058a9a250b9", "node_id": "C_kwDOAAsO6NoAKDNkMTBjNjRiMjY5MzZhNWI1OTdiZmZjOTgzMjIwMDU4YTlhMjUwYjk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-20T22:37:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-20T22:37:29Z"}, "message": "Rollup merge of #91032 - eholk:generator-drop-tracking, r=nikomatsakis\n\nIntroduce drop range tracking to generator interior analysis\n\nThis PR addresses cases such as this one from #57478:\n```rust\nstruct Foo;\nimpl !Send for Foo {}\n\nlet _: impl Send = || {\n    let guard = Foo;\n    drop(guard);\n    yield;\n};\n```\n\nPreviously, the `generator_interior` pass would unnecessarily include the type `Foo` in the generator because it was not aware of the behavior of `drop`. We fix this issue by introducing a drop range analysis that finds portions of the code where a value is guaranteed to be dropped. If a value is dropped at all suspend points, then it is no longer included in the generator type. Note that we are using \"dropped\" in a generic sense to include any case in which a value has been moved. That is, we do not only look at calls to the `drop` function.\n\nThere are several phases to the drop tracking algorithm, and we'll go into more detail below.\n1. Use `ExprUseVisitor` to find values that are consumed and borrowed.\n2. `DropRangeVisitor` uses consume and borrow information to gather drop and reinitialization events, as well as build a control flow graph.\n3. We then propagate drop and reinitialization information through the CFG until we reach a fix point (see `DropRanges::propagate_to_fixpoint`).\n4. When recording a type (see `InteriorVisitor::record`), we check the computed drop ranges to see if that value is definitely dropped at the suspend point. If so, we skip including it in the type.\n\n## 1. Use `ExprUseVisitor` to find values that are consumed and borrowed.\n\nWe use `ExprUseVisitor` to identify the places where values are consumed. We track both the `hir_id` of the value, and the `hir_id` of the expression that consumes it. For example, in the expression `[Foo]`, the `Foo` is consumed by the array expression, so after the array expression we can consider the `Foo` temporary to be dropped.\n\nIn this process, we also collect values that are borrowed. The reason is that the MIR transform for generators conservatively assumes anything borrowed is live across a suspend point (see `rustc_mir_transform::generator::locals_live_across_suspend_points`). We match this behavior here as well.\n\n## 2. Gather drop events, reinitialization events, and control flow graph\n\nAfter finding the values of interest, we perform a post-order traversal over the HIR tree to find the points where these values are dropped or reinitialized. We use the post-order index of each event because this is how the existing generator interior analysis refers to the position of suspend points and the scopes of variables.\n\nDuring this traversal, we also record branching and merging information to handle control flow constructs such as `if`, `match`, and `loop`. This is necessary because values may be dropped along some control flow paths but not others.\n\n## 3. Iterate to fixed point\n\nThe previous pass found the interesting events and locations, but now we need to find the actual ranges where things are dropped. Upon entry, we have a list of nodes ordered by their position in the post-order traversal. Each node has a set of successors. For each node we additionally keep a bitfield with one bit per potentially consumed value. The bit is set if we the value is dropped along all paths entering this node.\n\nTo compute the drop information, we first reverse the successor edges to find each node's predecessors. Then we iterate through each node, and for each node we set its dropped value bitfield to the intersection of all incoming dropped value bitfields.\n\nIf any bitfield for any node changes, we re-run the propagation loop again.\n\n## 4. Ignore dropped values across suspend points\n\nAt this point we have a data structure where we can ask whether a value is guaranteed to be dropped at any post order index for the HIR tree. We use this information in `InteriorVisitor` to check whether a value in question is dropped at a particular suspend point. If it is, we do not include that value's type in the generator type.\n\nNote that we had to augment the region scope tree to include all yields in scope, rather than just the last one as we did before.\n\nr? `@nikomatsakis`", "tree": {"sha": "204b5d18632cfe4a4783d4b3c92e475056626b36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/204b5d18632cfe4a4783d4b3c92e475056626b36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d10c64b26936a5b597bffc983220058a9a250b9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh6eQpCRBK7hj4Ov3rIwAAEgcIAEQtmKlbPVPgHDZfm/Kqb887\npLyo4wXQXAvkde364yElNWhTpb7QwzAfaVVl4j7voL2RkBCD6BwWvttR83oMZHUL\nZ1y2L84EDB2m2O8yTMkruZBM+oc+79KdISeu27ebnB8mbguzY1mrYEDr609qTe6g\nl57k6En+nzMBqk0c6+V9O9NIuOZ8Jy1lAHIONyoigCCsV0b33KHOe2nNYMadvfrw\nKR3SAZDbUgWj/nYmnZnIIyrpIFSSysz4cJSat0++4V3huDGogHL7b5mwCH5RZlNT\nRbIodi0gVq1WNYQlvmqxKK0gutdVbKgHG96a7IKC04O25Ck8UcW+rtmWmXpf38Q=\n=RgcD\n-----END PGP SIGNATURE-----\n", "payload": "tree 204b5d18632cfe4a4783d4b3c92e475056626b36\nparent 74fbbefea8d13683cca5eee62e4740706cb3144a\nparent 76f6b57125bd9394ad3ce8c241d2eebc4f99042b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642718249 +0100\ncommitter GitHub <noreply@github.com> 1642718249 +0100\n\nRollup merge of #91032 - eholk:generator-drop-tracking, r=nikomatsakis\n\nIntroduce drop range tracking to generator interior analysis\n\nThis PR addresses cases such as this one from #57478:\n```rust\nstruct Foo;\nimpl !Send for Foo {}\n\nlet _: impl Send = || {\n    let guard = Foo;\n    drop(guard);\n    yield;\n};\n```\n\nPreviously, the `generator_interior` pass would unnecessarily include the type `Foo` in the generator because it was not aware of the behavior of `drop`. We fix this issue by introducing a drop range analysis that finds portions of the code where a value is guaranteed to be dropped. If a value is dropped at all suspend points, then it is no longer included in the generator type. Note that we are using \"dropped\" in a generic sense to include any case in which a value has been moved. That is, we do not only look at calls to the `drop` function.\n\nThere are several phases to the drop tracking algorithm, and we'll go into more detail below.\n1. Use `ExprUseVisitor` to find values that are consumed and borrowed.\n2. `DropRangeVisitor` uses consume and borrow information to gather drop and reinitialization events, as well as build a control flow graph.\n3. We then propagate drop and reinitialization information through the CFG until we reach a fix point (see `DropRanges::propagate_to_fixpoint`).\n4. When recording a type (see `InteriorVisitor::record`), we check the computed drop ranges to see if that value is definitely dropped at the suspend point. If so, we skip including it in the type.\n\n## 1. Use `ExprUseVisitor` to find values that are consumed and borrowed.\n\nWe use `ExprUseVisitor` to identify the places where values are consumed. We track both the `hir_id` of the value, and the `hir_id` of the expression that consumes it. For example, in the expression `[Foo]`, the `Foo` is consumed by the array expression, so after the array expression we can consider the `Foo` temporary to be dropped.\n\nIn this process, we also collect values that are borrowed. The reason is that the MIR transform for generators conservatively assumes anything borrowed is live across a suspend point (see `rustc_mir_transform::generator::locals_live_across_suspend_points`). We match this behavior here as well.\n\n## 2. Gather drop events, reinitialization events, and control flow graph\n\nAfter finding the values of interest, we perform a post-order traversal over the HIR tree to find the points where these values are dropped or reinitialized. We use the post-order index of each event because this is how the existing generator interior analysis refers to the position of suspend points and the scopes of variables.\n\nDuring this traversal, we also record branching and merging information to handle control flow constructs such as `if`, `match`, and `loop`. This is necessary because values may be dropped along some control flow paths but not others.\n\n## 3. Iterate to fixed point\n\nThe previous pass found the interesting events and locations, but now we need to find the actual ranges where things are dropped. Upon entry, we have a list of nodes ordered by their position in the post-order traversal. Each node has a set of successors. For each node we additionally keep a bitfield with one bit per potentially consumed value. The bit is set if we the value is dropped along all paths entering this node.\n\nTo compute the drop information, we first reverse the successor edges to find each node's predecessors. Then we iterate through each node, and for each node we set its dropped value bitfield to the intersection of all incoming dropped value bitfields.\n\nIf any bitfield for any node changes, we re-run the propagation loop again.\n\n## 4. Ignore dropped values across suspend points\n\nAt this point we have a data structure where we can ask whether a value is guaranteed to be dropped at any post order index for the HIR tree. We use this information in `InteriorVisitor` to check whether a value in question is dropped at a particular suspend point. If it is, we do not include that value's type in the generator type.\n\nNote that we had to augment the region scope tree to include all yields in scope, rather than just the last one as we did before.\n\nr? `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d10c64b26936a5b597bffc983220058a9a250b9", "html_url": "https://github.com/rust-lang/rust/commit/3d10c64b26936a5b597bffc983220058a9a250b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d10c64b26936a5b597bffc983220058a9a250b9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74fbbefea8d13683cca5eee62e4740706cb3144a", "url": "https://api.github.com/repos/rust-lang/rust/commits/74fbbefea8d13683cca5eee62e4740706cb3144a", "html_url": "https://github.com/rust-lang/rust/commit/74fbbefea8d13683cca5eee62e4740706cb3144a"}, {"sha": "76f6b57125bd9394ad3ce8c241d2eebc4f99042b", "url": "https://api.github.com/repos/rust-lang/rust/commits/76f6b57125bd9394ad3ce8c241d2eebc4f99042b", "html_url": "https://github.com/rust-lang/rust/commit/76f6b57125bd9394ad3ce8c241d2eebc4f99042b"}], "stats": {"total": 1591, "additions": 1488, "deletions": 103}, "files": [{"sha": "1c309c137b796a3d18423251cb6d3ef625ea44d6", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -4413,13 +4413,15 @@ dependencies = [\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_graphviz\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\","}, {"sha": "75dd223d014d485804e5a3a1dd97815d76770c46", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -308,7 +308,7 @@ pub struct ScopeTree {\n     /// The reason is that semantically, until the `box` expression returns,\n     /// the values are still owned by their containing expressions. So\n     /// we'll see that `&x`.\n-    pub yield_in_scope: FxHashMap<Scope, YieldData>,\n+    pub yield_in_scope: FxHashMap<Scope, Vec<YieldData>>,\n \n     /// The number of visit_expr and visit_pat calls done in the body.\n     /// Used to sanity check visit_expr/visit_pat call count when\n@@ -423,8 +423,8 @@ impl ScopeTree {\n \n     /// Checks whether the given scope contains a `yield`. If so,\n     /// returns `Some(YieldData)`. If not, returns `None`.\n-    pub fn yield_in_scope(&self, scope: Scope) -> Option<YieldData> {\n-        self.yield_in_scope.get(&scope).cloned()\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<&Vec<YieldData>> {\n+        self.yield_in_scope.get(&scope)\n     }\n \n     /// Gives the number of expressions visited in a body."}, {"sha": "fdf93e5893247aa94bc69cef4af37127b8dd80e4", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -366,7 +366,8 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             let target_scopes = visitor.fixup_scopes.drain(start_point..);\n \n             for scope in target_scopes {\n-                let mut yield_data = visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap();\n+                let mut yield_data =\n+                    visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap().last_mut().unwrap();\n                 let count = yield_data.expr_and_pat_count;\n                 let span = yield_data.span;\n \n@@ -429,7 +430,13 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             };\n             let data =\n                 YieldData { span, expr_and_pat_count: visitor.expr_and_pat_count, source: *source };\n-            visitor.scope_tree.yield_in_scope.insert(scope, data);\n+            match visitor.scope_tree.yield_in_scope.get_mut(&scope) {\n+                Some(yields) => yields.push(data),\n+                None => {\n+                    visitor.scope_tree.yield_in_scope.insert(scope, vec![data]);\n+                }\n+            }\n+\n             if visitor.pessimistic_yield {\n                 debug!(\"resolve_expr in pessimistic_yield - marking scope {:?} for fixup\", scope);\n                 visitor.fixup_scopes.push(scope);"}, {"sha": "57930a28a35a159ba9267aac1e0e3a129e47ba62", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -15,6 +15,7 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n+rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n rustc_target = { path = \"../rustc_target\" }\n@@ -27,3 +28,4 @@ rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n rustc_lint = { path = \"../rustc_lint\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }"}, {"sha": "56b6dd9a284468311638cf1a30effccdbdfe8489", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -3,6 +3,7 @@\n //! is calculated in `rustc_const_eval::transform::generator` and may be a subset of the\n //! types computed here.\n \n+use self::drop_ranges::DropRanges;\n use super::FnCtxt;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::pluralize;\n@@ -19,6 +20,8 @@ use rustc_span::Span;\n use smallvec::SmallVec;\n use tracing::debug;\n \n+mod drop_ranges;\n+\n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     types: FxIndexSet<ty::GeneratorInteriorTypeCause<'tcx>>,\n@@ -34,6 +37,7 @@ struct InteriorVisitor<'a, 'tcx> {\n     guard_bindings: SmallVec<[SmallVec<[HirId; 4]>; 1]>,\n     guard_bindings_set: HirIdSet,\n     linted_values: HirIdSet,\n+    drop_ranges: DropRanges,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -48,9 +52,11 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n     ) {\n         use rustc_span::DUMMY_SP;\n \n+        let ty = self.fcx.resolve_vars_if_possible(ty);\n+\n         debug!(\n-            \"generator_interior: attempting to record type {:?} {:?} {:?} {:?}\",\n-            ty, scope, expr, source_span\n+            \"attempting to record type ty={:?}; hir_id={:?}; scope={:?}; expr={:?}; source_span={:?}; expr_count={:?}\",\n+            ty, hir_id, scope, expr, source_span, self.expr_count,\n         );\n \n         let live_across_yield = scope\n@@ -63,29 +69,34 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                     //\n                     // See the mega-comment at `yield_in_scope` for a proof.\n \n-                    debug!(\n-                        \"comparing counts yield: {} self: {}, source_span = {:?}\",\n-                        yield_data.expr_and_pat_count, self.expr_count, source_span\n-                    );\n+                    yield_data\n+                        .iter()\n+                        .find(|yield_data| {\n+                            debug!(\n+                                \"comparing counts yield: {} self: {}, source_span = {:?}\",\n+                                yield_data.expr_and_pat_count, self.expr_count, source_span\n+                            );\n+\n+                            if self.drop_ranges.is_dropped_at(hir_id, yield_data.expr_and_pat_count)\n+                            {\n+                                debug!(\"value is dropped at yield point; not recording\");\n+                                return false;\n+                            }\n \n-                    // If it is a borrowing happening in the guard,\n-                    // it needs to be recorded regardless because they\n-                    // do live across this yield point.\n-                    if guard_borrowing_from_pattern\n-                        || yield_data.expr_and_pat_count >= self.expr_count\n-                    {\n-                        Some(yield_data)\n-                    } else {\n-                        None\n-                    }\n+                            // If it is a borrowing happening in the guard,\n+                            // it needs to be recorded regardless because they\n+                            // do live across this yield point.\n+                            guard_borrowing_from_pattern\n+                                || yield_data.expr_and_pat_count >= self.expr_count\n+                        })\n+                        .cloned()\n                 })\n             })\n             .unwrap_or_else(|| {\n                 Some(YieldData { span: DUMMY_SP, expr_and_pat_count: 0, source: self.kind.into() })\n             });\n \n         if let Some(yield_data) = live_across_yield {\n-            let ty = self.fcx.resolve_vars_if_possible(ty);\n             debug!(\n                 \"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n                 expr, scope, ty, self.expr_count, yield_data.span\n@@ -154,7 +165,6 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 self.expr_count,\n                 expr.map(|e| e.span)\n             );\n-            let ty = self.fcx.resolve_vars_if_possible(ty);\n             if let Some((unresolved_type, unresolved_type_span)) =\n                 self.fcx.unresolved_type_vars(&ty)\n             {\n@@ -186,6 +196,7 @@ pub fn resolve_interior<'a, 'tcx>(\n         guard_bindings: <_>::default(),\n         guard_bindings_set: <_>::default(),\n         linted_values: <_>::default(),\n+        drop_ranges: drop_ranges::compute_drop_ranges(fcx, def_id, body),\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n@@ -313,6 +324,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         let mut guard_borrowing_from_pattern = false;\n+\n         match &expr.kind {\n             ExprKind::Call(callee, args) => match &callee.kind {\n                 ExprKind::Path(qpath) => {"}, {"sha": "21a8d7b5634569975ce0029d50e243a38db5194f", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,269 @@\n+//! Drop range analysis finds the portions of the tree where a value is guaranteed to be dropped\n+//! (i.e. moved, uninitialized, etc.). This is used to exclude the types of those values from the\n+//! generator type. See `InteriorVisitor::record` for where the results of this analysis are used.\n+//!\n+//! There are three phases to this analysis:\n+//! 1. Use `ExprUseVisitor` to identify the interesting values that are consumed and borrowed.\n+//! 2. Use `DropRangeVisitor` to find where the interesting values are dropped or reinitialized,\n+//!    and also build a control flow graph.\n+//! 3. Use `DropRanges::propagate_to_fixpoint` to flow the dropped/reinitialized information through\n+//!    the CFG and find the exact points where we know a value is definitely dropped.\n+//!\n+//! The end result is a data structure that maps the post-order index of each node in the HIR tree\n+//! to a set of values that are known to be dropped at that location.\n+\n+use self::cfg_build::build_control_flow_graph;\n+use self::record_consumed_borrow::find_consumed_and_borrowed;\n+use crate::check::FnCtxt;\n+use hir::def_id::DefId;\n+use hir::{Body, HirId, HirIdMap, Node};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n+use rustc_middle::ty;\n+use std::collections::BTreeMap;\n+use std::fmt::Debug;\n+\n+mod cfg_build;\n+mod cfg_propagate;\n+mod cfg_visualize;\n+mod record_consumed_borrow;\n+\n+pub fn compute_drop_ranges<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    def_id: DefId,\n+    body: &'tcx Body<'tcx>,\n+) -> DropRanges {\n+    let consumed_borrowed_places = find_consumed_and_borrowed(fcx, def_id, body);\n+\n+    let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n+    let mut drop_ranges = build_control_flow_graph(\n+        fcx.tcx.hir(),\n+        fcx.tcx,\n+        &fcx.typeck_results.borrow(),\n+        consumed_borrowed_places,\n+        body,\n+        num_exprs,\n+    );\n+\n+    drop_ranges.propagate_to_fixpoint();\n+\n+    DropRanges { tracked_value_map: drop_ranges.tracked_value_map, nodes: drop_ranges.nodes }\n+}\n+\n+/// Applies `f` to consumable node in the HIR subtree pointed to by `place`.\n+///\n+/// This includes the place itself, and if the place is a reference to a local\n+/// variable then `f` is also called on the HIR node for that variable as well.\n+///\n+/// For example, if `place` points to `foo()`, then `f` is called once for the\n+/// result of `foo`. On the other hand, if `place` points to `x` then `f` will\n+/// be called both on the `ExprKind::Path` node that represents the expression\n+/// as well as the HirId of the local `x` itself.\n+fn for_each_consumable<'tcx>(hir: Map<'tcx>, place: TrackedValue, mut f: impl FnMut(TrackedValue)) {\n+    f(place);\n+    let node = hir.find(place.hir_id());\n+    if let Some(Node::Expr(expr)) = node {\n+        match expr.kind {\n+            hir::ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+            )) => {\n+                f(TrackedValue::Variable(*hir_id));\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct PostOrderId {\n+        DEBUG_FORMAT = \"id({})\",\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct TrackedValueIndex {\n+        DEBUG_FORMAT = \"hidx({})\",\n+    }\n+}\n+\n+/// Identifies a value whose drop state we need to track.\n+#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\n+enum TrackedValue {\n+    /// Represents a named variable, such as a let binding, parameter, or upvar.\n+    ///\n+    /// The HirId points to the variable's definition site.\n+    Variable(HirId),\n+    /// A value produced as a result of an expression.\n+    ///\n+    /// The HirId points to the expression that returns this value.\n+    Temporary(HirId),\n+}\n+\n+impl TrackedValue {\n+    fn hir_id(&self) -> HirId {\n+        match self {\n+            TrackedValue::Variable(hir_id) | TrackedValue::Temporary(hir_id) => *hir_id,\n+        }\n+    }\n+}\n+\n+/// Represents a reason why we might not be able to convert a HirId or Place\n+/// into a tracked value.\n+#[derive(Debug)]\n+enum TrackedValueConversionError {\n+    /// Place projects are not currently supported.\n+    ///\n+    /// The reasoning around these is kind of subtle, so we choose to be more\n+    /// conservative around these for now. There is not reason in theory we\n+    /// cannot support these, we just have not implemented it yet.\n+    PlaceProjectionsNotSupported,\n+}\n+\n+impl TryFrom<&PlaceWithHirId<'_>> for TrackedValue {\n+    type Error = TrackedValueConversionError;\n+\n+    fn try_from(place_with_id: &PlaceWithHirId<'_>) -> Result<Self, Self::Error> {\n+        if !place_with_id.place.projections.is_empty() {\n+            debug!(\n+                \"TrackedValue from PlaceWithHirId: {:?} has projections, which are not supported.\",\n+                place_with_id\n+            );\n+            return Err(TrackedValueConversionError::PlaceProjectionsNotSupported);\n+        }\n+\n+        match place_with_id.place.base {\n+            PlaceBase::Rvalue | PlaceBase::StaticItem => {\n+                Ok(TrackedValue::Temporary(place_with_id.hir_id))\n+            }\n+            PlaceBase::Local(hir_id)\n+            | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => {\n+                Ok(TrackedValue::Variable(hir_id))\n+            }\n+        }\n+    }\n+}\n+\n+pub struct DropRanges {\n+    tracked_value_map: FxHashMap<TrackedValue, TrackedValueIndex>,\n+    nodes: IndexVec<PostOrderId, NodeInfo>,\n+}\n+\n+impl DropRanges {\n+    pub fn is_dropped_at(&self, hir_id: HirId, location: usize) -> bool {\n+        self.tracked_value_map\n+            .get(&TrackedValue::Temporary(hir_id))\n+            .or(self.tracked_value_map.get(&TrackedValue::Variable(hir_id)))\n+            .cloned()\n+            .map_or(false, |tracked_value_id| {\n+                self.expect_node(location.into()).drop_state.contains(tracked_value_id)\n+            })\n+    }\n+\n+    /// Returns a reference to the NodeInfo for a node, panicking if it does not exist\n+    fn expect_node(&self, id: PostOrderId) -> &NodeInfo {\n+        &self.nodes[id]\n+    }\n+}\n+\n+/// Tracks information needed to compute drop ranges.\n+struct DropRangesBuilder {\n+    /// The core of DropRangesBuilder is a set of nodes, which each represent\n+    /// one expression. We primarily refer to them by their index in a\n+    /// post-order traversal of the HIR tree,  since this is what\n+    /// generator_interior uses to talk about yield positions.\n+    ///\n+    /// This IndexVec keeps the relevant details for each node. See the\n+    /// NodeInfo struct for more details, but this information includes things\n+    /// such as the set of control-flow successors, which variables are dropped\n+    /// or reinitialized, and whether each variable has been inferred to be\n+    /// known-dropped or potentially reintiialized at each point.\n+    nodes: IndexVec<PostOrderId, NodeInfo>,\n+    /// We refer to values whose drop state we are tracking by the HirId of\n+    /// where they are defined. Within a NodeInfo, however, we store the\n+    /// drop-state in a bit vector indexed by a HirIdIndex\n+    /// (see NodeInfo::drop_state). The hir_id_map field stores the mapping\n+    /// from HirIds to the HirIdIndex that is used to represent that value in\n+    /// bitvector.\n+    tracked_value_map: FxHashMap<TrackedValue, TrackedValueIndex>,\n+\n+    /// When building the control flow graph, we don't always know the\n+    /// post-order index of the target node at the point we encounter it.\n+    /// For example, this happens with break and continue. In those cases,\n+    /// we store a pair of the PostOrderId of the source and the HirId\n+    /// of the target. Once we have gathered all of these edges, we make a\n+    /// pass over the set of deferred edges (see process_deferred_edges in\n+    /// cfg_build.rs), look up the PostOrderId for the target (since now the\n+    /// post-order index for all nodes is known), and add missing control flow\n+    /// edges.\n+    deferred_edges: Vec<(PostOrderId, HirId)>,\n+    /// This maps HirIds of expressions to their post-order index. It is\n+    /// used in process_deferred_edges to correctly add back-edges.\n+    post_order_map: HirIdMap<PostOrderId>,\n+}\n+\n+impl Debug for DropRangesBuilder {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"DropRanges\")\n+            .field(\"hir_id_map\", &self.tracked_value_map)\n+            .field(\"post_order_maps\", &self.post_order_map)\n+            .field(\"nodes\", &self.nodes.iter_enumerated().collect::<BTreeMap<_, _>>())\n+            .finish()\n+    }\n+}\n+\n+/// DropRanges keeps track of what values are definitely dropped at each point in the code.\n+///\n+/// Values of interest are defined by the hir_id of their place. Locations in code are identified\n+/// by their index in the post-order traversal. At its core, DropRanges maps\n+/// (hir_id, post_order_id) -> bool, where a true value indicates that the value is definitely\n+/// dropped at the point of the node identified by post_order_id.\n+impl DropRangesBuilder {\n+    /// Returns the number of values (hir_ids) that are tracked\n+    fn num_values(&self) -> usize {\n+        self.tracked_value_map.len()\n+    }\n+\n+    fn node_mut(&mut self, id: PostOrderId) -> &mut NodeInfo {\n+        let size = self.num_values();\n+        self.nodes.ensure_contains_elem(id, || NodeInfo::new(size));\n+        &mut self.nodes[id]\n+    }\n+\n+    fn add_control_edge(&mut self, from: PostOrderId, to: PostOrderId) {\n+        trace!(\"adding control edge from {:?} to {:?}\", from, to);\n+        self.node_mut(from.into()).successors.push(to.into());\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct NodeInfo {\n+    /// IDs of nodes that can follow this one in the control flow\n+    ///\n+    /// If the vec is empty, then control proceeds to the next node.\n+    successors: Vec<PostOrderId>,\n+\n+    /// List of hir_ids that are dropped by this node.\n+    drops: Vec<TrackedValueIndex>,\n+\n+    /// List of hir_ids that are reinitialized by this node.\n+    reinits: Vec<TrackedValueIndex>,\n+\n+    /// Set of values that are definitely dropped at this point.\n+    drop_state: BitSet<TrackedValueIndex>,\n+}\n+\n+impl NodeInfo {\n+    fn new(num_values: usize) -> Self {\n+        Self {\n+            successors: vec![],\n+            drops: vec![],\n+            reinits: vec![],\n+            drop_state: BitSet::new_filled(num_values),\n+        }\n+    }\n+}"}, {"sha": "fc957b899909d59a0d4de658eabf0508837f4509", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,473 @@\n+use super::{\n+    for_each_consumable, record_consumed_borrow::ConsumedAndBorrowedPlaces, DropRangesBuilder,\n+    NodeInfo, PostOrderId, TrackedValue, TrackedValueIndex,\n+};\n+use hir::{\n+    intravisit::{self, Visitor},\n+    Body, Expr, ExprKind, Guard, HirId,\n+};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::{\n+    hir::map::Map,\n+    ty::{TyCtxt, TypeckResults},\n+};\n+use std::mem::swap;\n+\n+/// Traverses the body to find the control flow graph and locations for the\n+/// relevant places are dropped or reinitialized.\n+///\n+/// The resulting structure still needs to be iterated to a fixed point, which\n+/// can be done with propagate_to_fixpoint in cfg_propagate.\n+pub(super) fn build_control_flow_graph<'tcx>(\n+    hir: Map<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n+    body: &'tcx Body<'tcx>,\n+    num_exprs: usize,\n+) -> DropRangesBuilder {\n+    let mut drop_range_visitor =\n+        DropRangeVisitor::new(hir, tcx, typeck_results, consumed_borrowed_places, num_exprs);\n+    intravisit::walk_body(&mut drop_range_visitor, body);\n+\n+    drop_range_visitor.drop_ranges.process_deferred_edges();\n+\n+    drop_range_visitor.drop_ranges\n+}\n+\n+/// This struct is used to gather the information for `DropRanges` to determine the regions of the\n+/// HIR tree for which a value is dropped.\n+///\n+/// We are interested in points where a variables is dropped or initialized, and the control flow\n+/// of the code. We identify locations in code by their post-order traversal index, so it is\n+/// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n+///\n+/// We make several simplifying assumptions, with the goal of being more conservative than\n+/// necessary rather than less conservative (since being less conservative is unsound, but more\n+/// conservative is still safe). These assumptions are:\n+///\n+/// 1. Moving a variable `a` counts as a move of the whole variable.\n+/// 2. Moving a partial path like `a.b.c` is ignored.\n+/// 3. Reinitializing through a field (e.g. `a.b.c = 5`) counds as a reinitialization of all of\n+///    `a`.\n+///\n+/// Some examples:\n+///\n+/// Rule 1:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a);\n+/// // `a` is not considered initialized.\n+/// ```\n+///\n+/// Rule 2:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a.0);\n+/// drop(a.1);\n+/// // `a` is still considered initialized.\n+/// ```\n+///\n+/// Rule 3:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a);\n+/// a.1 = vec![1];\n+/// // all of `a` is considered initialized\n+/// ```\n+\n+struct DropRangeVisitor<'a, 'tcx> {\n+    hir: Map<'tcx>,\n+    places: ConsumedAndBorrowedPlaces,\n+    drop_ranges: DropRangesBuilder,\n+    expr_index: PostOrderId,\n+    tcx: TyCtxt<'tcx>,\n+    typeck_results: &'a TypeckResults<'tcx>,\n+}\n+\n+impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n+    fn new(\n+        hir: Map<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a TypeckResults<'tcx>,\n+        places: ConsumedAndBorrowedPlaces,\n+        num_exprs: usize,\n+    ) -> Self {\n+        debug!(\"consumed_places: {:?}\", places.consumed);\n+        let drop_ranges = DropRangesBuilder::new(\n+            places.consumed.iter().flat_map(|(_, places)| places.iter().cloned()),\n+            hir,\n+            num_exprs,\n+        );\n+        Self { hir, places, drop_ranges, expr_index: PostOrderId::from_u32(0), typeck_results, tcx }\n+    }\n+\n+    fn record_drop(&mut self, value: TrackedValue) {\n+        if self.places.borrowed.contains(&value) {\n+            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", value);\n+        } else {\n+            debug!(\"marking {:?} as dropped at {:?}\", value, self.expr_index);\n+            let count = self.expr_index;\n+            self.drop_ranges.drop_at(value, count);\n+        }\n+    }\n+\n+    /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n+    /// expressions. This method consumes a little deeper into the expression when needed.\n+    fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n+        debug!(\"consuming expr {:?}, count={:?}\", expr.hir_id, self.expr_index);\n+        let places = self\n+            .places\n+            .consumed\n+            .get(&expr.hir_id)\n+            .map_or(vec![], |places| places.iter().cloned().collect());\n+        for place in places {\n+            for_each_consumable(self.hir, place, |value| self.record_drop(value));\n+        }\n+    }\n+\n+    /// Marks an expression as being reinitialized.\n+    ///\n+    /// Note that we always approximated on the side of things being more\n+    /// initialized than they actually are, as opposed to less. In cases such\n+    /// as `x.y = ...`, we would consider all of `x` as being initialized\n+    /// instead of just the `y` field.\n+    ///\n+    /// This is because it is always safe to consider something initialized\n+    /// even when it is not, but the other way around will cause problems.\n+    ///\n+    /// In the future, we will hopefully tighten up these rules to be more\n+    /// precise.\n+    fn reinit_expr(&mut self, expr: &hir::Expr<'_>) {\n+        // Walk the expression to find the base. For example, in an expression\n+        // like `*a[i].x`, we want to find the `a` and mark that as\n+        // reinitialized.\n+        match expr.kind {\n+            ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+            )) => {\n+                // This is the base case, where we have found an actual named variable.\n+\n+                let location = self.expr_index;\n+                debug!(\"reinitializing {:?} at {:?}\", hir_id, location);\n+                self.drop_ranges.reinit_at(TrackedValue::Variable(*hir_id), location);\n+            }\n+\n+            ExprKind::Field(base, _) => self.reinit_expr(base),\n+\n+            // Most expressions do not refer to something where we need to track\n+            // reinitializations.\n+            //\n+            // Some of these may be interesting in the future\n+            ExprKind::Path(..)\n+            | ExprKind::Box(..)\n+            | ExprKind::ConstBlock(..)\n+            | ExprKind::Array(..)\n+            | ExprKind::Call(..)\n+            | ExprKind::MethodCall(..)\n+            | ExprKind::Tup(..)\n+            | ExprKind::Binary(..)\n+            | ExprKind::Unary(..)\n+            | ExprKind::Lit(..)\n+            | ExprKind::Cast(..)\n+            | ExprKind::Type(..)\n+            | ExprKind::DropTemps(..)\n+            | ExprKind::Let(..)\n+            | ExprKind::If(..)\n+            | ExprKind::Loop(..)\n+            | ExprKind::Match(..)\n+            | ExprKind::Closure(..)\n+            | ExprKind::Block(..)\n+            | ExprKind::Assign(..)\n+            | ExprKind::AssignOp(..)\n+            | ExprKind::Index(..)\n+            | ExprKind::AddrOf(..)\n+            | ExprKind::Break(..)\n+            | ExprKind::Continue(..)\n+            | ExprKind::Ret(..)\n+            | ExprKind::InlineAsm(..)\n+            | ExprKind::Struct(..)\n+            | ExprKind::Repeat(..)\n+            | ExprKind::Yield(..)\n+            | ExprKind::Err => (),\n+        }\n+    }\n+\n+    /// For an expression with an uninhabited return type (e.g. a function that returns !),\n+    /// this adds a self edge to to the CFG to model the fact that the function does not\n+    /// return.\n+    fn handle_uninhabited_return(&mut self, expr: &Expr<'tcx>) {\n+        let ty = self.typeck_results.expr_ty(expr);\n+        let ty = self.tcx.erase_regions(ty);\n+        let m = self.tcx.parent_module(expr.hir_id).to_def_id();\n+        let param_env = self.tcx.param_env(m.expect_local());\n+        if self.tcx.is_ty_uninhabited_from(m, ty, param_env) {\n+            // This function will not return. We model this fact as an infinite loop.\n+            self.drop_ranges.add_control_edge(self.expr_index + 1, self.expr_index + 1);\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        let mut reinit = None;\n+        match expr.kind {\n+            ExprKind::Assign(lhs, rhs, _) => {\n+                self.visit_expr(lhs);\n+                self.visit_expr(rhs);\n+\n+                reinit = Some(lhs);\n+            }\n+\n+            ExprKind::If(test, if_true, if_false) => {\n+                self.visit_expr(test);\n+\n+                let fork = self.expr_index;\n+\n+                self.drop_ranges.add_control_edge(fork, self.expr_index + 1);\n+                self.visit_expr(if_true);\n+                let true_end = self.expr_index;\n+\n+                self.drop_ranges.add_control_edge(fork, self.expr_index + 1);\n+                if let Some(if_false) = if_false {\n+                    self.visit_expr(if_false);\n+                }\n+\n+                self.drop_ranges.add_control_edge(true_end, self.expr_index + 1);\n+            }\n+            ExprKind::Match(scrutinee, arms, ..) => {\n+                // We walk through the match expression almost like a chain of if expressions.\n+                // Here's a diagram to follow along with:\n+                //\n+                //           \u250c\u2500\u2510\n+                //     match \u2502A\u2502 {\n+                //       \u250c\u2500\u2500\u2500\u2534\u2500\u2518\n+                //       \u2502\n+                //      \u250c\u25bc\u250c\u2500\u2500\u2500\u25ba\u250c\u2500\u2510   \u250c\u2500\u2510\n+                //      \u2502B\u2502 if \u2502C\u2502 =>\u2502D\u2502,\n+                //      \u2514\u2500\u2518    \u251c\u2500\u2534\u2500\u2500\u25ba\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                //          \u250c\u2500\u2500\u2518              \u2502\n+                //       \u250c\u2500\u2500\u2518                 \u2502\n+                //       \u2502                    \u2502\n+                //      \u250c\u25bc\u250c\u2500\u2500\u2500\u25ba\u250c\u2500\u2510   \u250c\u2500\u2510      \u2502\n+                //      \u2502E\u2502 if \u2502F\u2502 =>\u2502G\u2502,     \u2502\n+                //      \u2514\u2500\u2518    \u251c\u2500\u2534\u2500\u2500\u25ba\u2514\u2500\u2534\u2510     \u2502\n+                //             \u2502        \u2502     \u2502\n+                //     }       \u25bc        \u25bc     \u2502\n+                //     \u250c\u2500\u2510\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                //     \u2502H\u2502\n+                //     \u2514\u2500\u2518\n+                //\n+                // The order we want is that the scrutinee (A) flows into the first pattern (B),\n+                // which flows into the guard (C). Then the guard either flows into the arm body\n+                // (D) or into the start of the next arm (E). Finally, the body flows to the end\n+                // of the match block (H).\n+                //\n+                // The subsequent arms follow the same ordering. First we go to the pattern, then\n+                // the guard (if present, otherwise it flows straight into the body), then into\n+                // the body and then to the end of the match expression.\n+                //\n+                // The comments below show which edge is being added.\n+                self.visit_expr(scrutinee);\n+\n+                let (guard_exit, arm_end_ids) = arms.iter().fold(\n+                    (self.expr_index, vec![]),\n+                    |(incoming_edge, mut arm_end_ids), hir::Arm { pat, body, guard, .. }| {\n+                        // A -> B, or C -> E\n+                        self.drop_ranges.add_control_edge(incoming_edge, self.expr_index + 1);\n+                        self.visit_pat(pat);\n+                        // B -> C and E -> F are added implicitly due to the traversal order.\n+                        match guard {\n+                            Some(Guard::If(expr)) => self.visit_expr(expr),\n+                            Some(Guard::IfLet(pat, expr)) => {\n+                                self.visit_pat(pat);\n+                                self.visit_expr(expr);\n+                            }\n+                            None => (),\n+                        }\n+                        // Likewise, C -> D and F -> G are added implicitly.\n+\n+                        // Save C, F, so we can add the other outgoing edge.\n+                        let to_next_arm = self.expr_index;\n+\n+                        // The default edge does not get added since we also have an explicit edge,\n+                        // so we also need to add an edge to the next node as well.\n+                        //\n+                        // This adds C -> D, F -> G\n+                        self.drop_ranges.add_control_edge(self.expr_index, self.expr_index + 1);\n+                        self.visit_expr(body);\n+\n+                        // Save the end of the body so we can add the exit edge once we know where\n+                        // the exit is.\n+                        arm_end_ids.push(self.expr_index);\n+\n+                        // Pass C to the next iteration, as well as vec![D]\n+                        //\n+                        // On the last round through, we pass F and vec![D, G] so that we can\n+                        // add all the exit edges.\n+                        (to_next_arm, arm_end_ids)\n+                    },\n+                );\n+                // F -> H\n+                self.drop_ranges.add_control_edge(guard_exit, self.expr_index + 1);\n+\n+                arm_end_ids.into_iter().for_each(|arm_end| {\n+                    // D -> H, G -> H\n+                    self.drop_ranges.add_control_edge(arm_end, self.expr_index + 1)\n+                });\n+            }\n+\n+            ExprKind::Loop(body, ..) => {\n+                let loop_begin = self.expr_index + 1;\n+                if body.stmts.is_empty() && body.expr.is_none() {\n+                    // For empty loops we won't have updated self.expr_index after visiting the\n+                    // body, meaning we'd get an edge from expr_index to expr_index + 1, but\n+                    // instead we want an edge from expr_index + 1 to expr_index + 1.\n+                    self.drop_ranges.add_control_edge(loop_begin, loop_begin);\n+                } else {\n+                    self.visit_block(body);\n+                    self.drop_ranges.add_control_edge(self.expr_index, loop_begin);\n+                }\n+            }\n+            ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n+            | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n+                self.drop_ranges.add_control_edge_hir_id(self.expr_index, target);\n+            }\n+\n+            ExprKind::Call(f, args) => {\n+                self.visit_expr(f);\n+                for arg in args {\n+                    self.visit_expr(arg);\n+                }\n+\n+                self.handle_uninhabited_return(expr);\n+            }\n+            ExprKind::MethodCall(_, _, exprs, _) => {\n+                for expr in exprs {\n+                    self.visit_expr(expr);\n+                }\n+\n+                self.handle_uninhabited_return(expr);\n+            }\n+\n+            ExprKind::AddrOf(..)\n+            | ExprKind::Array(..)\n+            | ExprKind::AssignOp(..)\n+            | ExprKind::Binary(..)\n+            | ExprKind::Block(..)\n+            | ExprKind::Box(..)\n+            | ExprKind::Break(..)\n+            | ExprKind::Cast(..)\n+            | ExprKind::Closure(..)\n+            | ExprKind::ConstBlock(..)\n+            | ExprKind::Continue(..)\n+            | ExprKind::DropTemps(..)\n+            | ExprKind::Err\n+            | ExprKind::Field(..)\n+            | ExprKind::Index(..)\n+            | ExprKind::InlineAsm(..)\n+            | ExprKind::Let(..)\n+            | ExprKind::Lit(..)\n+            | ExprKind::Path(..)\n+            | ExprKind::Repeat(..)\n+            | ExprKind::Ret(..)\n+            | ExprKind::Struct(..)\n+            | ExprKind::Tup(..)\n+            | ExprKind::Type(..)\n+            | ExprKind::Unary(..)\n+            | ExprKind::Yield(..) => intravisit::walk_expr(self, expr),\n+        }\n+\n+        self.expr_index = self.expr_index + 1;\n+        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_index);\n+        self.consume_expr(expr);\n+        if let Some(expr) = reinit {\n+            self.reinit_expr(expr);\n+        }\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n+        intravisit::walk_pat(self, pat);\n+\n+        // Increment expr_count here to match what InteriorVisitor expects.\n+        self.expr_index = self.expr_index + 1;\n+    }\n+}\n+\n+impl DropRangesBuilder {\n+    fn new(\n+        tracked_values: impl Iterator<Item = TrackedValue>,\n+        hir: Map<'_>,\n+        num_exprs: usize,\n+    ) -> Self {\n+        let mut tracked_value_map = FxHashMap::<_, TrackedValueIndex>::default();\n+        let mut next = <_>::from(0u32);\n+        for value in tracked_values {\n+            for_each_consumable(hir, value, |value| {\n+                if !tracked_value_map.contains_key(&value) {\n+                    tracked_value_map.insert(value, next);\n+                    next = next + 1;\n+                }\n+            });\n+        }\n+        debug!(\"hir_id_map: {:?}\", tracked_value_map);\n+        let num_values = tracked_value_map.len();\n+        Self {\n+            tracked_value_map,\n+            nodes: IndexVec::from_fn_n(|_| NodeInfo::new(num_values), num_exprs + 1),\n+            deferred_edges: <_>::default(),\n+            post_order_map: <_>::default(),\n+        }\n+    }\n+\n+    fn tracked_value_index(&self, tracked_value: TrackedValue) -> TrackedValueIndex {\n+        *self.tracked_value_map.get(&tracked_value).unwrap()\n+    }\n+\n+    /// Adds an entry in the mapping from HirIds to PostOrderIds\n+    ///\n+    /// Needed so that `add_control_edge_hir_id` can work.\n+    fn add_node_mapping(&mut self, node_hir_id: HirId, post_order_id: PostOrderId) {\n+        self.post_order_map.insert(node_hir_id, post_order_id);\n+    }\n+\n+    /// Like add_control_edge, but uses a hir_id as the target.\n+    ///\n+    /// This can be used for branches where we do not know the PostOrderId of the target yet,\n+    /// such as when handling `break` or `continue`.\n+    fn add_control_edge_hir_id(&mut self, from: PostOrderId, to: HirId) {\n+        self.deferred_edges.push((from, to));\n+    }\n+\n+    fn drop_at(&mut self, value: TrackedValue, location: PostOrderId) {\n+        let value = self.tracked_value_index(value);\n+        self.node_mut(location.into()).drops.push(value);\n+    }\n+\n+    fn reinit_at(&mut self, value: TrackedValue, location: PostOrderId) {\n+        let value = match self.tracked_value_map.get(&value) {\n+            Some(value) => *value,\n+            // If there's no value, this is never consumed and therefore is never dropped. We can\n+            // ignore this.\n+            None => return,\n+        };\n+        self.node_mut(location.into()).reinits.push(value);\n+    }\n+\n+    /// Looks up PostOrderId for any control edges added by HirId and adds a proper edge for them.\n+    ///\n+    /// Should be called after visiting the HIR but before solving the control flow, otherwise some\n+    /// edges will be missed.\n+    fn process_deferred_edges(&mut self) {\n+        let mut edges = vec![];\n+        swap(&mut edges, &mut self.deferred_edges);\n+        edges.into_iter().for_each(|(from, to)| {\n+            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n+            trace!(\"Adding deferred edge from {:?} to {:?}\", from, to);\n+            self.add_control_edge(from, to)\n+        });\n+    }\n+}"}, {"sha": "139d17d2e1ca186d72705afb98d310597a1c09f5", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_propagate.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,92 @@\n+use super::{DropRangesBuilder, PostOrderId};\n+use rustc_index::{bit_set::BitSet, vec::IndexVec};\n+use std::collections::BTreeMap;\n+\n+impl DropRangesBuilder {\n+    pub fn propagate_to_fixpoint(&mut self) {\n+        trace!(\"before fixpoint: {:#?}\", self);\n+        let preds = self.compute_predecessors();\n+\n+        trace!(\"predecessors: {:#?}\", preds.iter_enumerated().collect::<BTreeMap<_, _>>());\n+\n+        let mut new_state = BitSet::new_empty(self.num_values());\n+        let mut changed_nodes = BitSet::new_empty(self.nodes.len());\n+        let mut unchanged_mask = BitSet::new_filled(self.nodes.len());\n+        changed_nodes.insert(0u32.into());\n+\n+        let mut propagate = || {\n+            let mut changed = false;\n+            unchanged_mask.insert_all();\n+            for id in self.nodes.indices() {\n+                trace!(\"processing {:?}, changed_nodes: {:?}\", id, changed_nodes);\n+                // Check if any predecessor has changed, and if not then short-circuit.\n+                //\n+                // We handle the start node specially, since it doesn't have any predecessors,\n+                // but we need to start somewhere.\n+                if match id.index() {\n+                    0 => !changed_nodes.contains(id),\n+                    _ => !preds[id].iter().any(|pred| changed_nodes.contains(*pred)),\n+                } {\n+                    trace!(\"short-circuiting because none of {:?} have changed\", preds[id]);\n+                    unchanged_mask.remove(id);\n+                    continue;\n+                }\n+\n+                if id.index() == 0 {\n+                    new_state.clear();\n+                } else {\n+                    // If we are not the start node and we have no predecessors, treat\n+                    // everything as dropped because there's no way to get here anyway.\n+                    new_state.insert_all();\n+                };\n+\n+                for pred in &preds[id] {\n+                    new_state.intersect(&self.nodes[*pred].drop_state);\n+                }\n+\n+                for drop in &self.nodes[id].drops {\n+                    new_state.insert(*drop);\n+                }\n+\n+                for reinit in &self.nodes[id].reinits {\n+                    new_state.remove(*reinit);\n+                }\n+\n+                if self.nodes[id].drop_state.intersect(&new_state) {\n+                    changed_nodes.insert(id);\n+                    changed = true;\n+                } else {\n+                    unchanged_mask.remove(id);\n+                }\n+            }\n+\n+            changed_nodes.intersect(&unchanged_mask);\n+            changed\n+        };\n+\n+        while propagate() {\n+            trace!(\"drop_state changed, re-running propagation\");\n+        }\n+\n+        trace!(\"after fixpoint: {:#?}\", self);\n+    }\n+\n+    fn compute_predecessors(&self) -> IndexVec<PostOrderId, Vec<PostOrderId>> {\n+        let mut preds = IndexVec::from_fn_n(|_| vec![], self.nodes.len());\n+        for (id, node) in self.nodes.iter_enumerated() {\n+            // If the node has no explicit successors, we assume that control\n+            // will from this node into the next one.\n+            //\n+            // If there are successors listed, then we assume that all\n+            // possible successors are given and we do not include the default.\n+            if node.successors.len() == 0 && id.index() != self.nodes.len() - 1 {\n+                preds[id + 1].push(id);\n+            } else {\n+                for succ in &node.successors {\n+                    preds[*succ].push(id);\n+                }\n+            }\n+        }\n+        preds\n+    }\n+}"}, {"sha": "20aad7aedf77580e84e1f1e2a2caaa3dd0383fa6", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_visualize.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,77 @@\n+//! Implementation of GraphWalk for DropRanges so we can visualize the control\n+//! flow graph when needed for debugging.\n+\n+use rustc_graphviz as dot;\n+\n+use super::{DropRangesBuilder, PostOrderId};\n+\n+/// Writes the CFG for DropRangesBuilder to a .dot file for visualization.\n+///\n+/// It is not normally called, but is kept around to easily add debugging\n+/// code when needed.\n+#[allow(dead_code)]\n+pub(super) fn write_graph_to_file(drop_ranges: &DropRangesBuilder, filename: &str) {\n+    dot::render(drop_ranges, &mut std::fs::File::create(filename).unwrap()).unwrap();\n+}\n+\n+impl<'a> dot::GraphWalk<'a> for DropRangesBuilder {\n+    type Node = PostOrderId;\n+\n+    type Edge = (PostOrderId, PostOrderId);\n+\n+    fn nodes(&'a self) -> dot::Nodes<'a, Self::Node> {\n+        self.nodes.iter_enumerated().map(|(i, _)| i).collect()\n+    }\n+\n+    fn edges(&'a self) -> dot::Edges<'a, Self::Edge> {\n+        self.nodes\n+            .iter_enumerated()\n+            .flat_map(|(i, node)| {\n+                if node.successors.len() == 0 {\n+                    vec![(i, i + 1)]\n+                } else {\n+                    node.successors.iter().map(move |&s| (i, s)).collect()\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    fn source(&'a self, edge: &Self::Edge) -> Self::Node {\n+        edge.0\n+    }\n+\n+    fn target(&'a self, edge: &Self::Edge) -> Self::Node {\n+        edge.1\n+    }\n+}\n+\n+impl<'a> dot::Labeller<'a> for DropRangesBuilder {\n+    type Node = PostOrderId;\n+\n+    type Edge = (PostOrderId, PostOrderId);\n+\n+    fn graph_id(&'a self) -> dot::Id<'a> {\n+        dot::Id::new(\"drop_ranges\").unwrap()\n+    }\n+\n+    fn node_id(&'a self, n: &Self::Node) -> dot::Id<'a> {\n+        dot::Id::new(format!(\"id{}\", n.index())).unwrap()\n+    }\n+\n+    fn node_label(&'a self, n: &Self::Node) -> dot::LabelText<'a> {\n+        dot::LabelText::LabelStr(\n+            format!(\n+                \"{:?}, local_id: {}\",\n+                n,\n+                self.post_order_map\n+                    .iter()\n+                    .find(|(_hir_id, &post_order_id)| post_order_id == *n)\n+                    .map_or(\"<unknown>\".into(), |(hir_id, _)| format!(\n+                        \"{}\",\n+                        hir_id.local_id.index()\n+                    ))\n+            )\n+            .into(),\n+        )\n+    }\n+}"}, {"sha": "059a135a6fb6517018424292aa9ee3858e2614c8", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,118 @@\n+use super::TrackedValue;\n+use crate::{\n+    check::FnCtxt,\n+    expr_use_visitor::{self, ExprUseVisitor},\n+};\n+use hir::{def_id::DefId, Body, HirId, HirIdMap};\n+use rustc_data_structures::stable_set::FxHashSet;\n+use rustc_hir as hir;\n+use rustc_middle::hir::map::Map;\n+\n+pub(super) fn find_consumed_and_borrowed<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    def_id: DefId,\n+    body: &'tcx Body<'tcx>,\n+) -> ConsumedAndBorrowedPlaces {\n+    let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx.hir());\n+    expr_use_visitor.consume_body(fcx, def_id, body);\n+    expr_use_visitor.places\n+}\n+\n+pub(super) struct ConsumedAndBorrowedPlaces {\n+    /// Records the variables/expressions that are dropped by a given expression.\n+    ///\n+    /// The key is the hir-id of the expression, and the value is a set or hir-ids for variables\n+    /// or values that are consumed by that expression.\n+    ///\n+    /// Note that this set excludes \"partial drops\" -- for example, a statement like `drop(x.y)` is\n+    /// not considered a drop of `x`, although it would be a drop of `x.y`.\n+    pub(super) consumed: HirIdMap<FxHashSet<TrackedValue>>,\n+    /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n+    pub(super) borrowed: FxHashSet<TrackedValue>,\n+}\n+\n+/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n+///\n+/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n+/// record the parent expression, which is the point where the drop actually takes place.\n+struct ExprUseDelegate<'tcx> {\n+    hir: Map<'tcx>,\n+    places: ConsumedAndBorrowedPlaces,\n+}\n+\n+impl<'tcx> ExprUseDelegate<'tcx> {\n+    fn new(hir: Map<'tcx>) -> Self {\n+        Self {\n+            hir,\n+            places: ConsumedAndBorrowedPlaces {\n+                consumed: <_>::default(),\n+                borrowed: <_>::default(),\n+            },\n+        }\n+    }\n+\n+    fn consume_body(&mut self, fcx: &'_ FnCtxt<'_, 'tcx>, def_id: DefId, body: &'tcx Body<'tcx>) {\n+        // Run ExprUseVisitor to find where values are consumed.\n+        ExprUseVisitor::new(\n+            self,\n+            &fcx.infcx,\n+            def_id.expect_local(),\n+            fcx.param_env,\n+            &fcx.typeck_results.borrow(),\n+        )\n+        .consume_body(body);\n+    }\n+\n+    fn mark_consumed(&mut self, consumer: HirId, target: TrackedValue) {\n+        if !self.places.consumed.contains_key(&consumer) {\n+            self.places.consumed.insert(consumer, <_>::default());\n+        }\n+        self.places.consumed.get_mut(&consumer).map(|places| places.insert(target));\n+    }\n+}\n+\n+impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n+    fn consume(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        diag_expr_id: HirId,\n+    ) {\n+        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n+            Some(parent) => parent,\n+            None => place_with_id.hir_id,\n+        };\n+        debug!(\n+            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n+            place_with_id, diag_expr_id, parent\n+        );\n+        place_with_id\n+            .try_into()\n+            .map_or((), |tracked_value| self.mark_consumed(parent, tracked_value));\n+    }\n+\n+    fn borrow(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: HirId,\n+        _bk: rustc_middle::ty::BorrowKind,\n+    ) {\n+        place_with_id\n+            .try_into()\n+            .map_or(false, |tracked_value| self.places.borrowed.insert(tracked_value));\n+    }\n+\n+    fn mutate(\n+        &mut self,\n+        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: HirId,\n+    ) {\n+    }\n+\n+    fn fake_read(\n+        &mut self,\n+        _place: expr_use_visitor::Place<'tcx>,\n+        _cause: rustc_middle::mir::FakeReadCause,\n+        _diag_expr_id: HirId,\n+    ) {\n+    }\n+}"}, {"sha": "c5453b67ef5b6cbfc90462a2a54fe3e24e10ae20", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -18,7 +18,7 @@ async fn fut() {}\n async fn fut_arg<T>(_: T) {}\n \n async fn local_dropped_before_await() {\n-    // FIXME: it'd be nice for this to be allowed in a `Send` `async fn`\n+    // this is okay now because of the drop\n     let x = non_send();\n     drop(x);\n     fut().await;\n@@ -35,21 +35,40 @@ async fn non_send_temporary_in_match() {\n     }\n }\n \n+fn get_formatter() -> std::fmt::Formatter<'static> {\n+    panic!()\n+}\n+\n async fn non_sync_with_method_call() {\n-    // FIXME: it'd be nice for this to work.\n+    let f: &mut std::fmt::Formatter = &mut get_formatter();\n+    // It would by nice for this to work.\n+    if non_sync().fmt(f).unwrap() == () {\n+        fut().await;\n+    }\n+}\n+\n+async fn non_sync_with_method_call_panic() {\n     let f: &mut std::fmt::Formatter = panic!();\n     if non_sync().fmt(f).unwrap() == () {\n         fut().await;\n     }\n }\n \n+async fn non_sync_with_method_call_infinite_loop() {\n+    let f: &mut std::fmt::Formatter = loop {};\n+    if non_sync().fmt(f).unwrap() == () {\n+        fut().await;\n+    }\n+}\n+\n fn assert_send(_: impl Send) {}\n \n pub fn pass_assert() {\n     assert_send(local_dropped_before_await());\n-    //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_send_temporary_in_match());\n     //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_sync_with_method_call());\n     //~^ ERROR future cannot be sent between threads safely\n+    assert_send(non_sync_with_method_call_panic());\n+    assert_send(non_sync_with_method_call_infinite_loop());\n }"}, {"sha": "40ad46b48620d86454d6cb450d2cbd9d6d9cbfb2", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -1,28 +1,5 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:49:17\n-   |\n-LL |     assert_send(local_dropped_before_await());\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future returned by `local_dropped_before_await` is not `Send`\n-   |\n-   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n-note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-fn-nonsend.rs:24:10\n-   |\n-LL |     let x = non_send();\n-   |         - has type `impl Debug` which is not `Send`\n-LL |     drop(x);\n-LL |     fut().await;\n-   |          ^^^^^^ await occurs here, with `x` maybe used later\n-LL | }\n-   | - `x` is later dropped here\n-note: required by a bound in `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:46:24\n-   |\n-LL | fn assert_send(_: impl Send) {}\n-   |                        ^^^^ required by this bound in `assert_send`\n-\n-error: future cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:51:17\n+  --> $DIR/async-fn-nonsend.rs:68:17\n    |\n LL |     assert_send(non_send_temporary_in_match());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future returned by `non_send_temporary_in_match` is not `Send`\n@@ -32,41 +9,41 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/async-fn-nonsend.rs:33:25\n    |\n LL |     match Some(non_send()) {\n-   |                ---------- has type `impl Debug` which is not `Send`\n+   |           ---------------- has type `Option<impl Debug>` which is not `Send`\n LL |         Some(_) => fut().await,\n-   |                         ^^^^^^ await occurs here, with `non_send()` maybe used later\n+   |                         ^^^^^^ await occurs here, with `Some(non_send())` maybe used later\n ...\n LL | }\n-   | - `non_send()` is later dropped here\n+   | - `Some(non_send())` is later dropped here\n note: required by a bound in `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:46:24\n+  --> $DIR/async-fn-nonsend.rs:64:24\n    |\n LL | fn assert_send(_: impl Send) {}\n    |                        ^^^^ required by this bound in `assert_send`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:53:17\n+  --> $DIR/async-fn-nonsend.rs:70:17\n    |\n LL |     assert_send(non_sync_with_method_call());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ future returned by `non_sync_with_method_call` is not `Send`\n    |\n    = help: the trait `Send` is not implemented for `dyn std::fmt::Write`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-fn-nonsend.rs:42:14\n+  --> $DIR/async-fn-nonsend.rs:46:14\n    |\n-LL |     let f: &mut std::fmt::Formatter = panic!();\n-   |         - has type `&mut Formatter<'_>` which is not `Send`\n-LL |     if non_sync().fmt(f).unwrap() == () {\n+LL |     let f: &mut std::fmt::Formatter = &mut get_formatter();\n+   |                                            --------------- has type `Formatter<'_>` which is not `Send`\n+...\n LL |         fut().await;\n-   |              ^^^^^^ await occurs here, with `f` maybe used later\n+   |              ^^^^^^ await occurs here, with `get_formatter()` maybe used later\n LL |     }\n LL | }\n-   | - `f` is later dropped here\n+   | - `get_formatter()` is later dropped here\n note: required by a bound in `assert_send`\n-  --> $DIR/async-fn-nonsend.rs:46:24\n+  --> $DIR/async-fn-nonsend.rs:64:24\n    |\n LL | fn assert_send(_: impl Send) {}\n    |                        ^^^^ required by this bound in `assert_send`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "73f0ca8153cb9d9c68d72842a12a4ee8cb4b6121", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,29 @@\n+// edition:2021\n+#![feature(negative_impls)]\n+#![allow(unused)]\n+\n+fn main() {\n+    gimme_send(foo());\n+    //~^ ERROR cannot be sent between threads safely\n+}\n+\n+fn gimme_send<T: Send>(t: T) {\n+    drop(t);\n+}\n+\n+struct NotSend {}\n+\n+impl Drop for NotSend {\n+    fn drop(&mut self) {}\n+}\n+\n+impl !Send for NotSend {}\n+\n+async fn foo() {\n+    let mut x = (NotSend {},);\n+    drop(x.0);\n+    x.0 = NotSend {};\n+    bar().await;\n+}\n+\n+async fn bar() {}"}, {"sha": "2097642eb24abb5d6d9fc91939c589e281f5d1e7", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.stderr?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,27 @@\n+error[E0277]: `NotSend` cannot be sent between threads safely\n+  --> $DIR/partial-drop-partial-reinit.rs:6:16\n+   |\n+LL |     gimme_send(foo());\n+   |     ---------- ^^^^^ `NotSend` cannot be sent between threads safely\n+   |     |\n+   |     required by a bound introduced by this call\n+...\n+LL | async fn foo() {\n+   |                - within this `impl Future<Output = ()>`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NotSend`\n+   = note: required because it appears within the type `(NotSend,)`\n+   = note: required because it appears within the type `{ResumeTy, (NotSend,), impl Future<Output = ()>, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/partial-drop-partial-reinit.rs:22:16: 27:2]`\n+   = note: required because it appears within the type `from_generator::GenFuture<[static generator@$DIR/partial-drop-partial-reinit.rs:22:16: 27:2]>`\n+   = note: required because it appears within the type `impl Future<Output = [async output]>`\n+   = note: required because it appears within the type `impl Future<Output = ()>`\n+note: required by a bound in `gimme_send`\n+  --> $DIR/partial-drop-partial-reinit.rs:10:18\n+   |\n+LL | fn gimme_send<T: Send>(t: T) {\n+   |                  ^^^^ required by this bound in `gimme_send`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d313691b388577ffb80a60888bf95c513ad5a3aa", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -10,20 +10,12 @@ async fn foo() {\n     //~^ ERROR type inside `async fn` body must be known in this context\n     //~| ERROR type inside `async fn` body must be known in this context\n     //~| ERROR type inside `async fn` body must be known in this context\n-    //~| ERROR type inside `async fn` body must be known in this context\n-    //~| ERROR type inside `async fn` body must be known in this context\n-    //~| NOTE cannot infer type for type parameter `T`\n-    //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE the type is part of the `async fn` body because of this `await`\n-    //~| NOTE in this expansion of desugaring of `await`\n-    //~| NOTE in this expansion of desugaring of `await`\n     //~| NOTE in this expansion of desugaring of `await`\n     //~| NOTE in this expansion of desugaring of `await`\n     //~| NOTE in this expansion of desugaring of `await`"}, {"sha": "d19a3226ef9a44c71a47d82bafbee82411f09bc3", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -34,30 +34,6 @@ note: the type is part of the `async fn` body because of this `await`\n LL |     bar().await;\n    |          ^^^^^^\n \n-error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n-   |\n-LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n-   |\n-note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n-   |\n-LL |     bar().await;\n-   |          ^^^^^^\n-\n-error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:5\n-   |\n-LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n-   |\n-note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/unresolved_type_param.rs:9:10\n-   |\n-LL |     bar().await;\n-   |          ^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0698`."}, {"sha": "6319a29f5b7d0e3806a7e5c0a5c51395d9abc642", "filename": "src/test/ui/generator/drop-control-flow.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-control-flow.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,121 @@\n+// build-pass\n+\n+// A test to ensure generators capture values that were conditionally dropped,\n+// and also that values that are dropped along all paths to a yield do not get\n+// included in the generator type.\n+\n+#![feature(generators, negative_impls)]\n+#![allow(unused_assignments, dead_code)]\n+\n+struct Ptr;\n+impl<'a> Drop for Ptr {\n+    fn drop(&mut self) {}\n+}\n+\n+struct NonSend;\n+impl !Send for NonSend {}\n+\n+fn assert_send<T: Send>(_: T) {}\n+\n+// This test case is reduced from src/test/ui/drop/dynamic-drop-async.rs\n+fn one_armed_if(arg: bool) {\n+    let _ = || {\n+        let arr = [Ptr];\n+        if arg {\n+            drop(arr);\n+        }\n+        yield;\n+    };\n+}\n+\n+fn two_armed_if(arg: bool) {\n+    assert_send(|| {\n+        let arr = [Ptr];\n+        if arg {\n+            drop(arr);\n+        } else {\n+            drop(arr);\n+        }\n+        yield;\n+    })\n+}\n+\n+fn if_let(arg: Option<i32>) {\n+    let _ = || {\n+        let arr = [Ptr];\n+        if let Some(_) = arg {\n+            drop(arr);\n+        }\n+        yield;\n+    };\n+}\n+\n+fn init_in_if(arg: bool) {\n+    assert_send(|| {\n+        let mut x = NonSend;\n+        drop(x);\n+        if arg {\n+            x = NonSend;\n+        } else {\n+            yield;\n+        }\n+    })\n+}\n+\n+fn init_in_match_arm(arg: Option<i32>) {\n+    assert_send(|| {\n+        let mut x = NonSend;\n+        drop(x);\n+        match arg {\n+            Some(_) => x = NonSend,\n+            None => yield,\n+        }\n+    })\n+}\n+\n+fn reinit() {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        drop(arr);\n+        arr = [Ptr];\n+        yield;\n+    };\n+}\n+\n+fn loop_uninit() {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        let mut count = 0;\n+        drop(arr);\n+        while count < 3 {\n+            yield;\n+            arr = [Ptr];\n+            count += 1;\n+        }\n+    };\n+}\n+\n+fn nested_loop() {\n+    let _ = || {\n+        let mut arr = [Ptr];\n+        let mut count = 0;\n+        drop(arr);\n+        while count < 3 {\n+            for _ in 0..3 {\n+                yield;\n+            }\n+            arr = [Ptr];\n+            count += 1;\n+        }\n+    };\n+}\n+\n+fn main() {\n+    one_armed_if(true);\n+    if_let(Some(41));\n+    init_in_if(true);\n+    init_in_match_arm(Some(41));\n+    reinit();\n+    loop_uninit();\n+    nested_loop();\n+}"}, {"sha": "f484cbb8d67d575aa046e0fa9b7d9f69e7fc3bca", "filename": "src/test/ui/generator/drop-yield-twice.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,15 @@\n+#![feature(negative_impls, generators)]\n+\n+struct Foo(i32);\n+impl !Send for Foo {}\n+\n+fn main() {\n+    assert_send(|| { //~ ERROR generator cannot be sent between threads safely\n+        let guard = Foo(42);\n+        yield;\n+        drop(guard);\n+        yield;\n+    })\n+}\n+\n+fn assert_send<T: Send>(_: T) {}"}, {"sha": "f821f2f40055f35dea715a44b55bd4f0870c787e", "filename": "src/test/ui/generator/drop-yield-twice.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-yield-twice.stderr?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,25 @@\n+error: generator cannot be sent between threads safely\n+  --> $DIR/drop-yield-twice.rs:7:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/drop-yield-twice.rs:7:17: 12:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/drop-yield-twice.rs:9:9\n+   |\n+LL |         let guard = Foo(42);\n+   |             ----- has type `Foo` which is not `Send`\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+...\n+LL |     })\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/drop-yield-twice.rs:15:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: aborting due to previous error\n+"}, {"sha": "39710febdb95cf892ea4bdbdbbfa8dd086fc8b06", "filename": "src/test/ui/generator/issue-57478.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-57478.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![feature(negative_impls, generators)]\n+\n+struct Foo;\n+impl !Send for Foo {}\n+\n+fn main() {\n+    assert_send(|| {\n+        let guard = Foo;\n+        drop(guard);\n+        yield;\n+    })\n+}\n+\n+fn assert_send<T: Send>(_: T) {}"}, {"sha": "36f6e78cb3bfe12333526c3ac56b2a4969f319f9", "filename": "src/test/ui/generator/partial-drop.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,40 @@\n+#![feature(negative_impls, generators)]\n+\n+struct Foo;\n+impl !Send for Foo {}\n+\n+struct Bar {\n+    foo: Foo,\n+    x: i32,\n+}\n+\n+fn main() {\n+    assert_send(|| {\n+        //~^ ERROR generator cannot be sent between threads safely\n+        // FIXME: it would be nice to make this work.\n+        let guard = Bar { foo: Foo, x: 42 };\n+        drop(guard.foo);\n+        yield;\n+    });\n+\n+    assert_send(|| {\n+        //~^ ERROR generator cannot be sent between threads safely\n+        // FIXME: it would be nice to make this work.\n+        let guard = Bar { foo: Foo, x: 42 };\n+        drop(guard);\n+        guard.foo = Foo;\n+        guard.x = 23;\n+        yield;\n+    });\n+\n+    assert_send(|| {\n+        //~^ ERROR generator cannot be sent between threads safely\n+        // FIXME: it would be nice to make this work.\n+        let guard = Bar { foo: Foo, x: 42 };\n+        let Bar { foo, x } = guard;\n+        drop(foo);\n+        yield;\n+    });\n+}\n+\n+fn assert_send<T: Send>(_: T) {}"}, {"sha": "9a1b0734d8c865111a2397a6f82c9053a86e1c7e", "filename": "src/test/ui/generator/partial-drop.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,71 @@\n+error: generator cannot be sent between threads safely\n+  --> $DIR/partial-drop.rs:12:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/partial-drop.rs:12:17: 18:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/partial-drop.rs:17:9\n+   |\n+LL |         let guard = Bar { foo: Foo, x: 42 };\n+   |             ----- has type `Bar` which is not `Send`\n+LL |         drop(guard.foo);\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+LL |     });\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/partial-drop.rs:40:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: generator cannot be sent between threads safely\n+  --> $DIR/partial-drop.rs:20:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/partial-drop.rs:20:17: 28:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/partial-drop.rs:27:9\n+   |\n+LL |         let guard = Bar { foo: Foo, x: 42 };\n+   |             ----- has type `Bar` which is not `Send`\n+...\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+LL |     });\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/partial-drop.rs:40:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: generator cannot be sent between threads safely\n+  --> $DIR/partial-drop.rs:30:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/partial-drop.rs:30:17: 37:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/partial-drop.rs:36:9\n+   |\n+LL |         let guard = Bar { foo: Foo, x: 42 };\n+   |             ----- has type `Bar` which is not `Send`\n+...\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+LL |     });\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/partial-drop.rs:40:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "260b341a525252998d318274e104a66f7d2410bd", "filename": "src/test/ui/generator/reinit-in-match-guard.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Freinit-in-match-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Fgenerator%2Freinit-in-match-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Freinit-in-match-guard.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -0,0 +1,25 @@\n+// build-pass\n+\n+#![feature(generators)]\n+\n+#![allow(unused_assignments, dead_code)]\n+\n+fn main() {\n+    let _ = || {\n+        let mut x = vec![22_usize];\n+        std::mem::drop(x);\n+        match y() {\n+            true if {\n+                x = vec![];\n+                false\n+            } => {}\n+            _ => {\n+                yield;\n+            }\n+        }\n+    };\n+}\n+\n+fn y() -> bool {\n+    true\n+}"}, {"sha": "81a08579bb7bcdf24b62cc49d11ab6045da67b47", "filename": "src/test/ui/lint/must_not_suspend/dedup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -13,7 +13,7 @@ async fn wheeee<T>(t: T) {\n }\n \n async fn yes() {\n-    wheeee(No {}).await; //~ ERROR `No` held across\n+    wheeee(&No {}).await; //~ ERROR `No` held across\n }\n \n fn main() {"}, {"sha": "13fa3ae3008d2039640a2812fddf9947417d3a00", "filename": "src/test/ui/lint/must_not_suspend/dedup.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d10c64b26936a5b597bffc983220058a9a250b9/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr?ref=3d10c64b26936a5b597bffc983220058a9a250b9", "patch": "@@ -1,19 +1,19 @@\n error: `No` held across a suspend point, but should not be\n-  --> $DIR/dedup.rs:16:12\n+  --> $DIR/dedup.rs:16:13\n    |\n-LL |     wheeee(No {}).await;\n-   |            ^^^^^ ------ the value is held across this suspend point\n+LL |     wheeee(&No {}).await;\n+   |             ^^^^^ ------ the value is held across this suspend point\n    |\n note: the lint level is defined here\n   --> $DIR/dedup.rs:3:9\n    |\n LL | #![deny(must_not_suspend)]\n    |         ^^^^^^^^^^^^^^^^\n help: consider using a block (`{ ... }`) to shrink the value's scope, ending before the suspend point\n-  --> $DIR/dedup.rs:16:12\n+  --> $DIR/dedup.rs:16:13\n    |\n-LL |     wheeee(No {}).await;\n-   |            ^^^^^\n+LL |     wheeee(&No {}).await;\n+   |             ^^^^^\n \n error: aborting due to previous error\n "}]}